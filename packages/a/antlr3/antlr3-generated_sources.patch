--- tool/src/main/java/ActionAnalysis.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/ActionAnalysis.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,4 @@
+ID=4
+X=5
+X_Y=6
+Y=7
--- tool/src/main/java/ActionTranslator.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/ActionTranslator.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,34 @@
+ACTION=4
+ARG=5
+ATTR_VALUE_EXPR=6
+DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR=7
+DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR=8
+DYNAMIC_SCOPE_ATTR=9
+ENCLOSING_RULE_SCOPE_ATTR=10
+ERROR_SCOPED_XY=11
+ERROR_X=12
+ERROR_XY=13
+ESC=14
+ID=15
+INDIRECT_TEMPLATE_INSTANCE=16
+INT=17
+ISOLATED_DYNAMIC_SCOPE=18
+ISOLATED_LEXER_RULE_REF=19
+ISOLATED_TOKEN_REF=20
+LABEL_REF=21
+LOCAL_ATTR=22
+RULE_SCOPE_ATTR=23
+SCOPE_INDEX_EXPR=24
+SET_ATTRIBUTE=25
+SET_DYNAMIC_SCOPE_ATTR=26
+SET_ENCLOSING_RULE_SCOPE_ATTR=27
+SET_EXPR_ATTRIBUTE=28
+SET_LOCAL_ATTR=29
+SET_RULE_SCOPE_ATTR=30
+SET_TOKEN_SCOPE_ATTR=31
+TEMPLATE_EXPR=32
+TEMPLATE_INSTANCE=33
+TEXT=34
+TOKEN_SCOPE_ATTR=35
+UNKNOWN_SYNTAX=36
+WS=37
--- tool/src/main/java/ANTLR.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/ANTLR.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,114 @@
+ACTION=4
+ACTION_CHAR_LITERAL=5
+ACTION_ESC=6
+ACTION_STRING_LITERAL=7
+ALT=8
+AMPERSAND=9
+ARG=10
+ARGLIST=11
+ARG_ACTION=12
+ASSIGN=13
+BACKTRACK_SEMPRED=14
+BANG=15
+BLOCK=16
+CATCH=17
+CHAR_LITERAL=18
+CHAR_RANGE=19
+CLOSE_ELEMENT_OPTION=20
+CLOSURE=21
+COLON=22
+COMBINED_GRAMMAR=23
+COMMA=24
+COMMENT=25
+DIGIT=26
+DOC_COMMENT=27
+DOLLAR=28
+DOT=29
+DOUBLE_ANGLE_STRING_LITERAL=30
+DOUBLE_QUOTE_STRING_LITERAL=31
+EOA=32
+EOB=33
+EOR=34
+EPSILON=35
+ESC=36
+ETC=37
+FINALLY=38
+FORCED_ACTION=39
+FRAGMENT=40
+GATED_SEMPRED=41
+GRAMMAR=42
+ID=43
+IMPLIES=44
+IMPORT=45
+INITACTION=46
+INT=47
+LABEL=48
+LEXER=49
+LEXER_GRAMMAR=50
+LPAREN=51
+ML_COMMENT=52
+NESTED_ACTION=53
+NESTED_ARG_ACTION=54
+NOT=55
+OPEN_ELEMENT_OPTION=56
+OPTIONAL=57
+OPTIONS=58
+OR=59
+PARSER=60
+PARSER_GRAMMAR=61
+PLUS=62
+PLUS_ASSIGN=63
+POSITIVE_CLOSURE=64
+PREC_RULE=65
+PRIVATE=66
+PROTECTED=67
+PUBLIC=68
+QUESTION=69
+RANGE=70
+RCURLY=71
+RECURSIVE_RULE_REF=72
+RET=73
+RETURNS=74
+REWRITE=75
+REWRITES=76
+ROOT=77
+RPAREN=78
+RULE=79
+RULE_REF=80
+SCOPE=81
+SEMI=82
+SEMPRED=83
+SL_COMMENT=84
+SRC=85
+STAR=86
+STRAY_BRACKET=87
+STRING_LITERAL=88
+SYNPRED=89
+SYN_SEMPRED=90
+TEMPLATE=91
+THROWS=92
+TOKENS=93
+TOKEN_REF=94
+TREE=95
+TREE_BEGIN=96
+TREE_GRAMMAR=97
+WILDCARD=98
+WS=99
+WS_LOOP=100
+WS_OPT=101
+XDIGIT=102
+'.'=98
+'catch'=17
+'finally'=38
+'fragment'=40
+'grammar'=42
+'import'=45
+'lexer'=49
+'parser'=60
+'private'=66
+'protected'=67
+'public'=68
+'returns'=74
+'scope'=81
+'throws'=92
+'tree'=95
--- tool/src/main/java/ANTLRTreePrinter.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/ANTLRTreePrinter.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,114 @@
+ACTION=4
+ACTION_CHAR_LITERAL=5
+ACTION_ESC=6
+ACTION_STRING_LITERAL=7
+ALT=8
+AMPERSAND=9
+ARG=10
+ARGLIST=11
+ARG_ACTION=12
+ASSIGN=13
+BACKTRACK_SEMPRED=14
+BANG=15
+BLOCK=16
+CATCH=17
+CHAR_LITERAL=18
+CHAR_RANGE=19
+CLOSE_ELEMENT_OPTION=20
+CLOSURE=21
+COLON=22
+COMBINED_GRAMMAR=23
+COMMA=24
+COMMENT=25
+DIGIT=26
+DOC_COMMENT=27
+DOLLAR=28
+DOT=29
+DOUBLE_ANGLE_STRING_LITERAL=30
+DOUBLE_QUOTE_STRING_LITERAL=31
+EOA=32
+EOB=33
+EOR=34
+EPSILON=35
+ESC=36
+ETC=37
+FINALLY=38
+FORCED_ACTION=39
+FRAGMENT=40
+GATED_SEMPRED=41
+GRAMMAR=42
+ID=43
+IMPLIES=44
+IMPORT=45
+INITACTION=46
+INT=47
+LABEL=48
+LEXER=49
+LEXER_GRAMMAR=50
+LPAREN=51
+ML_COMMENT=52
+NESTED_ACTION=53
+NESTED_ARG_ACTION=54
+NOT=55
+OPEN_ELEMENT_OPTION=56
+OPTIONAL=57
+OPTIONS=58
+OR=59
+PARSER=60
+PARSER_GRAMMAR=61
+PLUS=62
+PLUS_ASSIGN=63
+POSITIVE_CLOSURE=64
+PREC_RULE=65
+PRIVATE=66
+PROTECTED=67
+PUBLIC=68
+QUESTION=69
+RANGE=70
+RCURLY=71
+RECURSIVE_RULE_REF=72
+RET=73
+RETURNS=74
+REWRITE=75
+REWRITES=76
+ROOT=77
+RPAREN=78
+RULE=79
+RULE_REF=80
+SCOPE=81
+SEMI=82
+SEMPRED=83
+SL_COMMENT=84
+SRC=85
+STAR=86
+STRAY_BRACKET=87
+STRING_LITERAL=88
+SYNPRED=89
+SYN_SEMPRED=90
+TEMPLATE=91
+THROWS=92
+TOKENS=93
+TOKEN_REF=94
+TREE=95
+TREE_BEGIN=96
+TREE_GRAMMAR=97
+WILDCARD=98
+WS=99
+WS_LOOP=100
+WS_OPT=101
+XDIGIT=102
+'.'=98
+'catch'=17
+'finally'=38
+'fragment'=40
+'grammar'=42
+'import'=45
+'lexer'=49
+'parser'=60
+'private'=66
+'protected'=67
+'public'=68
+'returns'=74
+'scope'=81
+'throws'=92
+'tree'=95
--- tool/src/main/java/ANTLRv3.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/ANTLRv3.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,128 @@
+T__67=67
+T__68=68
+T__69=69
+T__70=70
+T__71=71
+T__72=72
+T__73=73
+T__74=74
+T__75=75
+T__76=76
+T__77=77
+T__78=78
+T__79=79
+T__80=80
+T__81=81
+T__82=82
+T__83=83
+T__84=84
+T__85=85
+T__86=86
+T__87=87
+T__88=88
+T__89=89
+T__90=90
+T__91=91
+T__92=92
+T__93=93
+ACTION=4
+ACTION_CHAR_LITERAL=5
+ACTION_ESC=6
+ACTION_STRING_LITERAL=7
+ALT=8
+ARG=9
+ARGLIST=10
+ARG_ACTION=11
+AT=12
+BACKTRACK_SEMPRED=13
+BANG=14
+BLOCK=15
+CHAR_LITERAL=16
+CHAR_RANGE=17
+CLOSURE=18
+COMBINED_GRAMMAR=19
+DOC_COMMENT=20
+DOUBLE_ANGLE_STRING_LITERAL=21
+DOUBLE_QUOTE_STRING_LITERAL=22
+EOA=23
+EOB=24
+EOR=25
+EPSILON=26
+ESC=27
+FRAGMENT=28
+GATED_SEMPRED=29
+ID=30
+INT=31
+LABEL=32
+LABEL_ASSIGN=33
+LEXER=34
+LEXER_GRAMMAR=35
+LIST_LABEL_ASSIGN=36
+LITERAL_CHAR=37
+ML_COMMENT=38
+NESTED_ACTION=39
+NESTED_ARG_ACTION=40
+OPTIONAL=41
+OPTIONS=42
+PARSER=43
+PARSER_GRAMMAR=44
+POSITIVE_CLOSURE=45
+RANGE=46
+RET=47
+REWRITE=48
+ROOT=49
+RULE=50
+RULE_REF=51
+SCOPE=52
+SEMPRED=53
+SL_COMMENT=54
+SRC=55
+STRING_LITERAL=56
+SYNPRED=57
+SYN_SEMPRED=58
+TEMPLATE=59
+TOKENS=60
+TOKEN_REF=61
+TREE_BEGIN=62
+TREE_GRAMMAR=63
+WS=64
+WS_LOOP=65
+XDIGIT=66
+'!'=14
+'$'=67
+'('=68
+')'=69
+'*'=70
+'+'=71
+'+='=36
+','=72
+'->'=48
+'.'=73
+'..'=46
+':'=74
+'::'=75
+';'=76
+'<'=77
+'='=33
+'=>'=78
+'>'=79
+'?'=80
+'@'=12
+'^'=49
+'^('=62
+'catch'=81
+'finally'=82
+'fragment'=28
+'grammar'=83
+'lexer'=84
+'parser'=85
+'private'=86
+'protected'=87
+'public'=88
+'returns'=47
+'scope'=52
+'throws'=89
+'tree'=90
+'|'=91
+'}'=92
+'~'=93
--- tool/src/main/java/ANTLRv3Tree.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/ANTLRv3Tree.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,128 @@
+T__67=67
+T__68=68
+T__69=69
+T__70=70
+T__71=71
+T__72=72
+T__73=73
+T__74=74
+T__75=75
+T__76=76
+T__77=77
+T__78=78
+T__79=79
+T__80=80
+T__81=81
+T__82=82
+T__83=83
+T__84=84
+T__85=85
+T__86=86
+T__87=87
+T__88=88
+T__89=89
+T__90=90
+T__91=91
+T__92=92
+T__93=93
+ACTION=4
+ACTION_CHAR_LITERAL=5
+ACTION_ESC=6
+ACTION_STRING_LITERAL=7
+ALT=8
+ARG=9
+ARGLIST=10
+ARG_ACTION=11
+AT=12
+BACKTRACK_SEMPRED=13
+BANG=14
+BLOCK=15
+CHAR_LITERAL=16
+CHAR_RANGE=17
+CLOSURE=18
+COMBINED_GRAMMAR=19
+DOC_COMMENT=20
+DOUBLE_ANGLE_STRING_LITERAL=21
+DOUBLE_QUOTE_STRING_LITERAL=22
+EOA=23
+EOB=24
+EOR=25
+EPSILON=26
+ESC=27
+FRAGMENT=28
+GATED_SEMPRED=29
+ID=30
+INT=31
+LABEL=32
+LABEL_ASSIGN=33
+LEXER=34
+LEXER_GRAMMAR=35
+LIST_LABEL_ASSIGN=36
+LITERAL_CHAR=37
+ML_COMMENT=38
+NESTED_ACTION=39
+NESTED_ARG_ACTION=40
+OPTIONAL=41
+OPTIONS=42
+PARSER=43
+PARSER_GRAMMAR=44
+POSITIVE_CLOSURE=45
+RANGE=46
+RET=47
+REWRITE=48
+ROOT=49
+RULE=50
+RULE_REF=51
+SCOPE=52
+SEMPRED=53
+SL_COMMENT=54
+SRC=55
+STRING_LITERAL=56
+SYNPRED=57
+SYN_SEMPRED=58
+TEMPLATE=59
+TOKENS=60
+TOKEN_REF=61
+TREE_BEGIN=62
+TREE_GRAMMAR=63
+WS=64
+WS_LOOP=65
+XDIGIT=66
+'!'=14
+'$'=67
+'('=68
+')'=69
+'*'=70
+'+'=71
+'+='=36
+','=72
+'->'=48
+'.'=73
+'..'=46
+':'=74
+'::'=75
+';'=76
+'<'=77
+'='=33
+'=>'=78
+'>'=79
+'?'=80
+'@'=12
+'^'=49
+'^('=62
+'catch'=81
+'finally'=82
+'fragment'=28
+'grammar'=83
+'lexer'=84
+'parser'=85
+'private'=86
+'protected'=87
+'public'=88
+'returns'=47
+'scope'=52
+'throws'=89
+'tree'=90
+'|'=91
+'}'=92
+'~'=93
--- tool/src/main/java/AssignTokenTypesWalker.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/AssignTokenTypesWalker.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,115 @@
+ACTION=4
+ACTION_CHAR_LITERAL=5
+ACTION_ESC=6
+ACTION_STRING_LITERAL=7
+ALT=8
+AMPERSAND=9
+ARG=10
+ARGLIST=11
+ARG_ACTION=12
+ASSIGN=13
+BACKTRACK_SEMPRED=14
+BANG=15
+BLOCK=16
+CATCH=17
+CHAR_LITERAL=18
+CHAR_RANGE=19
+CLOSE_ELEMENT_OPTION=20
+CLOSURE=21
+COLON=22
+COMBINED_GRAMMAR=23
+COMMA=24
+COMMENT=25
+DIGIT=26
+DOC_COMMENT=27
+DOLLAR=28
+DOT=29
+DOUBLE_ANGLE_STRING_LITERAL=30
+DOUBLE_QUOTE_STRING_LITERAL=31
+EOA=32
+EOB=33
+EOR=34
+EPSILON=35
+ESC=36
+ETC=37
+FINALLY=38
+FORCED_ACTION=39
+FRAGMENT=40
+GATED_SEMPRED=41
+GRAMMAR=42
+ID=43
+IMPLIES=44
+IMPORT=45
+INITACTION=46
+INT=47
+LABEL=48
+LEXER=49
+LEXER_GRAMMAR=50
+LPAREN=51
+ML_COMMENT=52
+NESTED_ACTION=53
+NESTED_ARG_ACTION=54
+NOT=55
+OPEN_ELEMENT_OPTION=56
+OPTIONAL=57
+OPTIONS=58
+OR=59
+PARSER=60
+PARSER_GRAMMAR=61
+PLUS=62
+PLUS_ASSIGN=63
+POSITIVE_CLOSURE=64
+PREC_RULE=65
+PRIVATE=66
+PROTECTED=67
+PUBLIC=68
+QUESTION=69
+RANGE=70
+RCURLY=71
+RECURSIVE_RULE_REF=72
+RET=73
+RETURNS=74
+REWRITE=75
+REWRITES=76
+ROOT=77
+RPAREN=78
+RULE=79
+RULE_REF=80
+SCOPE=81
+SEMI=82
+SEMPRED=83
+SL_COMMENT=84
+SRC=85
+STAR=86
+STRAY_BRACKET=87
+STRING_LITERAL=88
+SYNPRED=89
+SYN_SEMPRED=90
+TEMPLATE=91
+THROWS=92
+TOKENS=93
+TOKEN_REF=94
+TREE=95
+TREE_BEGIN=96
+TREE_GRAMMAR=97
+WILDCARD=98
+WS=99
+WS_LOOP=100
+WS_OPT=101
+XDIGIT=102
+CHARSET=103
+'.'=98
+'catch'=17
+'finally'=38
+'fragment'=40
+'grammar'=42
+'import'=45
+'lexer'=49
+'parser'=60
+'private'=66
+'protected'=67
+'public'=68
+'returns'=74
+'scope'=81
+'throws'=92
+'tree'=95
--- tool/src/main/java/CodeGenTreeWalker.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/CodeGenTreeWalker.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,114 @@
+ACTION=4
+ACTION_CHAR_LITERAL=5
+ACTION_ESC=6
+ACTION_STRING_LITERAL=7
+ALT=8
+AMPERSAND=9
+ARG=10
+ARGLIST=11
+ARG_ACTION=12
+ASSIGN=13
+BACKTRACK_SEMPRED=14
+BANG=15
+BLOCK=16
+CATCH=17
+CHAR_LITERAL=18
+CHAR_RANGE=19
+CLOSE_ELEMENT_OPTION=20
+CLOSURE=21
+COLON=22
+COMBINED_GRAMMAR=23
+COMMA=24
+COMMENT=25
+DIGIT=26
+DOC_COMMENT=27
+DOLLAR=28
+DOT=29
+DOUBLE_ANGLE_STRING_LITERAL=30
+DOUBLE_QUOTE_STRING_LITERAL=31
+EOA=32
+EOB=33
+EOR=34
+EPSILON=35
+ESC=36
+ETC=37
+FINALLY=38
+FORCED_ACTION=39
+FRAGMENT=40
+GATED_SEMPRED=41
+GRAMMAR=42
+ID=43
+IMPLIES=44
+IMPORT=45
+INITACTION=46
+INT=47
+LABEL=48
+LEXER=49
+LEXER_GRAMMAR=50
+LPAREN=51
+ML_COMMENT=52
+NESTED_ACTION=53
+NESTED_ARG_ACTION=54
+NOT=55
+OPEN_ELEMENT_OPTION=56
+OPTIONAL=57
+OPTIONS=58
+OR=59
+PARSER=60
+PARSER_GRAMMAR=61
+PLUS=62
+PLUS_ASSIGN=63
+POSITIVE_CLOSURE=64
+PREC_RULE=65
+PRIVATE=66
+PROTECTED=67
+PUBLIC=68
+QUESTION=69
+RANGE=70
+RCURLY=71
+RECURSIVE_RULE_REF=72
+RET=73
+RETURNS=74
+REWRITE=75
+REWRITES=76
+ROOT=77
+RPAREN=78
+RULE=79
+RULE_REF=80
+SCOPE=81
+SEMI=82
+SEMPRED=83
+SL_COMMENT=84
+SRC=85
+STAR=86
+STRAY_BRACKET=87
+STRING_LITERAL=88
+SYNPRED=89
+SYN_SEMPRED=90
+TEMPLATE=91
+THROWS=92
+TOKENS=93
+TOKEN_REF=94
+TREE=95
+TREE_BEGIN=96
+TREE_GRAMMAR=97
+WILDCARD=98
+WS=99
+WS_LOOP=100
+WS_OPT=101
+XDIGIT=102
+'.'=98
+'catch'=17
+'finally'=38
+'fragment'=40
+'grammar'=42
+'import'=45
+'lexer'=49
+'parser'=60
+'private'=66
+'protected'=67
+'public'=68
+'returns'=74
+'scope'=81
+'throws'=92
+'tree'=95
--- tool/src/main/java/DefineGrammarItemsWalker.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/DefineGrammarItemsWalker.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,114 @@
+ACTION=4
+ACTION_CHAR_LITERAL=5
+ACTION_ESC=6
+ACTION_STRING_LITERAL=7
+ALT=8
+AMPERSAND=9
+ARG=10
+ARGLIST=11
+ARG_ACTION=12
+ASSIGN=13
+BACKTRACK_SEMPRED=14
+BANG=15
+BLOCK=16
+CATCH=17
+CHAR_LITERAL=18
+CHAR_RANGE=19
+CLOSE_ELEMENT_OPTION=20
+CLOSURE=21
+COLON=22
+COMBINED_GRAMMAR=23
+COMMA=24
+COMMENT=25
+DIGIT=26
+DOC_COMMENT=27
+DOLLAR=28
+DOT=29
+DOUBLE_ANGLE_STRING_LITERAL=30
+DOUBLE_QUOTE_STRING_LITERAL=31
+EOA=32
+EOB=33
+EOR=34
+EPSILON=35
+ESC=36
+ETC=37
+FINALLY=38
+FORCED_ACTION=39
+FRAGMENT=40
+GATED_SEMPRED=41
+GRAMMAR=42
+ID=43
+IMPLIES=44
+IMPORT=45
+INITACTION=46
+INT=47
+LABEL=48
+LEXER=49
+LEXER_GRAMMAR=50
+LPAREN=51
+ML_COMMENT=52
+NESTED_ACTION=53
+NESTED_ARG_ACTION=54
+NOT=55
+OPEN_ELEMENT_OPTION=56
+OPTIONAL=57
+OPTIONS=58
+OR=59
+PARSER=60
+PARSER_GRAMMAR=61
+PLUS=62
+PLUS_ASSIGN=63
+POSITIVE_CLOSURE=64
+PREC_RULE=65
+PRIVATE=66
+PROTECTED=67
+PUBLIC=68
+QUESTION=69
+RANGE=70
+RCURLY=71
+RECURSIVE_RULE_REF=72
+RET=73
+RETURNS=74
+REWRITE=75
+REWRITES=76
+ROOT=77
+RPAREN=78
+RULE=79
+RULE_REF=80
+SCOPE=81
+SEMI=82
+SEMPRED=83
+SL_COMMENT=84
+SRC=85
+STAR=86
+STRAY_BRACKET=87
+STRING_LITERAL=88
+SYNPRED=89
+SYN_SEMPRED=90
+TEMPLATE=91
+THROWS=92
+TOKENS=93
+TOKEN_REF=94
+TREE=95
+TREE_BEGIN=96
+TREE_GRAMMAR=97
+WILDCARD=98
+WS=99
+WS_LOOP=100
+WS_OPT=101
+XDIGIT=102
+'.'=98
+'catch'=17
+'finally'=38
+'fragment'=40
+'grammar'=42
+'import'=45
+'lexer'=49
+'parser'=60
+'private'=66
+'protected'=67
+'public'=68
+'returns'=74
+'scope'=81
+'throws'=92
+'tree'=95
--- tool/src/main/java/LeftRecursiveRuleWalker.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/LeftRecursiveRuleWalker.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,114 @@
+ACTION=4
+ACTION_CHAR_LITERAL=5
+ACTION_ESC=6
+ACTION_STRING_LITERAL=7
+ALT=8
+AMPERSAND=9
+ARG=10
+ARGLIST=11
+ARG_ACTION=12
+ASSIGN=13
+BACKTRACK_SEMPRED=14
+BANG=15
+BLOCK=16
+CATCH=17
+CHAR_LITERAL=18
+CHAR_RANGE=19
+CLOSE_ELEMENT_OPTION=20
+CLOSURE=21
+COLON=22
+COMBINED_GRAMMAR=23
+COMMA=24
+COMMENT=25
+DIGIT=26
+DOC_COMMENT=27
+DOLLAR=28
+DOT=29
+DOUBLE_ANGLE_STRING_LITERAL=30
+DOUBLE_QUOTE_STRING_LITERAL=31
+EOA=32
+EOB=33
+EOR=34
+EPSILON=35
+ESC=36
+ETC=37
+FINALLY=38
+FORCED_ACTION=39
+FRAGMENT=40
+GATED_SEMPRED=41
+GRAMMAR=42
+ID=43
+IMPLIES=44
+IMPORT=45
+INITACTION=46
+INT=47
+LABEL=48
+LEXER=49
+LEXER_GRAMMAR=50
+LPAREN=51
+ML_COMMENT=52
+NESTED_ACTION=53
+NESTED_ARG_ACTION=54
+NOT=55
+OPEN_ELEMENT_OPTION=56
+OPTIONAL=57
+OPTIONS=58
+OR=59
+PARSER=60
+PARSER_GRAMMAR=61
+PLUS=62
+PLUS_ASSIGN=63
+POSITIVE_CLOSURE=64
+PREC_RULE=65
+PRIVATE=66
+PROTECTED=67
+PUBLIC=68
+QUESTION=69
+RANGE=70
+RCURLY=71
+RECURSIVE_RULE_REF=72
+RET=73
+RETURNS=74
+REWRITE=75
+REWRITES=76
+ROOT=77
+RPAREN=78
+RULE=79
+RULE_REF=80
+SCOPE=81
+SEMI=82
+SEMPRED=83
+SL_COMMENT=84
+SRC=85
+STAR=86
+STRAY_BRACKET=87
+STRING_LITERAL=88
+SYNPRED=89
+SYN_SEMPRED=90
+TEMPLATE=91
+THROWS=92
+TOKENS=93
+TOKEN_REF=94
+TREE=95
+TREE_BEGIN=96
+TREE_GRAMMAR=97
+WILDCARD=98
+WS=99
+WS_LOOP=100
+WS_OPT=101
+XDIGIT=102
+'.'=98
+'catch'=17
+'finally'=38
+'fragment'=40
+'grammar'=42
+'import'=45
+'lexer'=49
+'parser'=60
+'private'=66
+'protected'=67
+'public'=68
+'returns'=74
+'scope'=81
+'throws'=92
+'tree'=95
--- tool/src/main/java/org/antlr/grammar/v3/ActionAnalysis.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/ActionAnalysis.java	2019-04-04 17:22:25.476181469 +0200
@@ -0,0 +1,442 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/ActionAnalysis.g 2019-04-04 15:18:49
+
+package org.antlr.grammar.v3;
+import org.antlr.runtime.*;
+import org.antlr.tool.*;
+
+
+import org.antlr.runtime.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+
+/** We need to set Rule.referencedPredefinedRuleAttributes before
+ *  code generation.  This filter looks at an action in context of
+ *  its rule and outer alternative number and figures out which
+ *  rules have predefined prefs referenced.  I need this so I can
+ *  remove unusued labels.  This also tracks, for labeled rules,
+ *  which are referenced by actions.
+ */
+@SuppressWarnings("all")
+public class ActionAnalysis extends Lexer {
+	public static final int EOF=-1;
+	public static final int ID=4;
+	public static final int X=5;
+	public static final int X_Y=6;
+	public static final int Y=7;
+
+	Rule enclosingRule;
+	Grammar grammar;
+	Token actionToken;
+	int outerAltNum = 0;
+
+		public ActionAnalysis(Grammar grammar, String ruleName, GrammarAST actionAST)
+		{
+			this(new ANTLRStringStream(actionAST.token.getText()));
+			this.grammar = grammar;
+		    this.enclosingRule = grammar.getLocallyDefinedRule(ruleName);
+		    this.actionToken = actionAST.token;
+		    this.outerAltNum = actionAST.outerAltNum;
+		}
+
+	public void analyze() {
+		// System.out.println("###\naction="+actionToken);
+		Token t;
+		do {
+			t = nextToken();
+		} while ( t.getType()!= Token.EOF );
+	}
+
+
+	// delegates
+	// delegators
+	public Lexer[] getDelegates() {
+		return new Lexer[] {};
+	}
+
+	public ActionAnalysis() {} 
+	public ActionAnalysis(CharStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public ActionAnalysis(CharStream input, RecognizerSharedState state) {
+		super(input,state);
+	}
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/ActionAnalysis.g"; }
+
+	@Override
+	public Token nextToken() {
+		while (true) {
+			if ( input.LA(1)==CharStream.EOF ) {
+				Token eof = new CommonToken(input,Token.EOF,
+											Token.DEFAULT_CHANNEL,
+											input.index(),input.index());
+				eof.setLine(getLine());
+				eof.setCharPositionInLine(getCharPositionInLine());
+				return eof;
+			}
+			state.token = null;
+		state.channel = Token.DEFAULT_CHANNEL;
+			state.tokenStartCharIndex = input.index();
+			state.tokenStartCharPositionInLine = input.getCharPositionInLine();
+			state.tokenStartLine = input.getLine();
+		state.text = null;
+			try {
+				int m = input.mark();
+				state.backtracking=1; 
+				state.failed=false;
+				mTokens();
+				state.backtracking=0;
+				if ( state.failed ) {
+					input.rewind(m);
+					input.consume(); 
+				}
+				else {
+					emit();
+					return state.token;
+				}
+			}
+			catch (RecognitionException re) {
+				// shouldn't happen in backtracking mode, but...
+				reportError(re);
+				recover(re);
+			}
+		}
+	}
+
+	@Override
+	public void memoize(IntStream input,
+			int ruleIndex,
+			int ruleStartIndex)
+	{
+	if ( state.backtracking>1 ) super.memoize(input, ruleIndex, ruleStartIndex);
+	}
+
+	@Override
+	public boolean alreadyParsedRule(IntStream input, int ruleIndex) {
+	if ( state.backtracking>1 ) return super.alreadyParsedRule(input, ruleIndex);
+	return false;
+	}
+	// $ANTLR start "X_Y"
+	public final void mX_Y() throws RecognitionException {
+		try {
+			int _type = X_Y;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+
+			// org/antlr/grammar/v3/ActionAnalysis.g:75:5: ( '$' x= ID '.' y= ID {...}?)
+			// org/antlr/grammar/v3/ActionAnalysis.g:75:7: '$' x= ID '.' y= ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int xStart55 = getCharIndex();
+			int xStartLine55 = getLine();
+			int xStartCharPos55 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart55, getCharIndex()-1);
+			x.setLine(xStartLine55);
+			x.setCharPositionInLine(xStartCharPos55);
+
+			match('.'); if (state.failed) return;
+			int yStart61 = getCharIndex();
+			int yStartLine61 = getLine();
+			int yStartCharPos61 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart61, getCharIndex()-1);
+			y.setLine(yStartLine61);
+			y.setCharPositionInLine(yStartCharPos61);
+
+			if ( !((enclosingRule!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "X_Y", "enclosingRule!=null");
+			}
+			if ( state.backtracking==1 ) {
+					AttributeScope scope = null;
+					String refdRuleName = null;
+					if ( (x!=null?x.getText():null).equals(enclosingRule.name) ) {
+						// ref to enclosing rule.
+						refdRuleName = (x!=null?x.getText():null);
+						scope = enclosingRule.getLocalAttributeScope((y!=null?y.getText():null));
+					}
+					else if ( enclosingRule.getRuleLabel((x!=null?x.getText():null))!=null ) {
+						// ref to rule label
+						Grammar.LabelElementPair pair = enclosingRule.getRuleLabel((x!=null?x.getText():null));
+						pair.actionReferencesLabel = true;
+						refdRuleName = pair.referencedRuleName;
+						Rule refdRule = grammar.getRule(refdRuleName);
+						if ( refdRule!=null ) {
+							scope = refdRule.getLocalAttributeScope((y!=null?y.getText():null));
+						}
+					}
+					else if ( enclosingRule.getRuleRefsInAlt(x.getText(), outerAltNum)!=null ) {
+						// ref to rule referenced in this alt
+						refdRuleName = (x!=null?x.getText():null);
+						Rule refdRule = grammar.getRule(refdRuleName);
+						if ( refdRule!=null ) {
+							scope = refdRule.getLocalAttributeScope((y!=null?y.getText():null));
+						}
+					}
+					if ( scope!=null &&
+						 (scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
+					{
+						grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+						//System.out.println("referenceRuleLabelPredefinedAttribute for "+refdRuleName);
+					}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "X_Y"
+
+	// $ANTLR start "X"
+	public final void mX() throws RecognitionException {
+		try {
+			int _type = X;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+
+			// org/antlr/grammar/v3/ActionAnalysis.g:112:3: ( '$' x= ID {...}?)
+			// org/antlr/grammar/v3/ActionAnalysis.g:112:5: '$' x= ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int xStart83 = getCharIndex();
+			int xStartLine83 = getLine();
+			int xStartCharPos83 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart83, getCharIndex()-1);
+			x.setLine(xStartLine83);
+			x.setCharPositionInLine(xStartCharPos83);
+
+			if ( !((enclosingRule!=null && enclosingRule.getRuleLabel((x!=null?x.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "X", "enclosingRule!=null && enclosingRule.getRuleLabel($x.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+						Grammar.LabelElementPair pair = enclosingRule.getRuleLabel((x!=null?x.getText():null));
+						pair.actionReferencesLabel = true;
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "X"
+
+	// $ANTLR start "Y"
+	public final void mY() throws RecognitionException {
+		try {
+			int _type = Y;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken ID1=null;
+
+			// org/antlr/grammar/v3/ActionAnalysis.g:120:3: ( '$' ID {...}?)
+			// org/antlr/grammar/v3/ActionAnalysis.g:120:5: '$' ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int ID1Start104 = getCharIndex();
+			int ID1StartLine104 = getLine();
+			int ID1StartCharPos104 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			ID1 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, ID1Start104, getCharIndex()-1);
+			ID1.setLine(ID1StartLine104);
+			ID1.setCharPositionInLine(ID1StartCharPos104);
+
+			if ( !((enclosingRule!=null && enclosingRule.getLocalAttributeScope((ID1!=null?ID1.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "Y", "enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+						AttributeScope scope = enclosingRule.getLocalAttributeScope((ID1!=null?ID1.getText():null));
+						if ( scope!=null &&
+							 (scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
+						{
+							grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+							//System.out.println("referenceRuleLabelPredefinedAttribute for "+(ID1!=null?ID1.getText():null));
+						}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "Y"
+
+	// $ANTLR start "ID"
+	public final void mID() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ActionAnalysis.g:133:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// org/antlr/grammar/v3/ActionAnalysis.g:133:9: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			{
+			if ( (input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
+				input.consume();
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				recover(mse);
+				throw mse;
+			}
+			// org/antlr/grammar/v3/ActionAnalysis.g:133:33: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			loop1:
+			while (true) {
+				int alt1=2;
+				int LA1_0 = input.LA(1);
+				if ( ((LA1_0 >= '0' && LA1_0 <= '9')||(LA1_0 >= 'A' && LA1_0 <= 'Z')||LA1_0=='_'||(LA1_0 >= 'a' && LA1_0 <= 'z')) ) {
+					alt1=1;
+				}
+
+				switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionAnalysis.g:
+					{
+					if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop1;
+				}
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ID"
+
+	@Override
+	public void mTokens() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionAnalysis.g:1:39: ( X_Y | X | Y )
+		int alt2=3;
+		int LA2_0 = input.LA(1);
+		if ( (LA2_0=='$') ) {
+			int LA2_1 = input.LA(2);
+			if ( (synpred1_ActionAnalysis()) ) {
+				alt2=1;
+			}
+			else if ( (synpred2_ActionAnalysis()) ) {
+				alt2=2;
+			}
+			else if ( (true) ) {
+				alt2=3;
+			}
+
+		}
+
+		else {
+			if (state.backtracking>0) {state.failed=true; return;}
+			NoViableAltException nvae =
+				new NoViableAltException("", 2, 0, input);
+			throw nvae;
+		}
+
+		switch (alt2) {
+			case 1 :
+				// org/antlr/grammar/v3/ActionAnalysis.g:1:41: X_Y
+				{
+				mX_Y(); if (state.failed) return;
+
+				}
+				break;
+			case 2 :
+				// org/antlr/grammar/v3/ActionAnalysis.g:1:45: X
+				{
+				mX(); if (state.failed) return;
+
+				}
+				break;
+			case 3 :
+				// org/antlr/grammar/v3/ActionAnalysis.g:1:47: Y
+				{
+				mY(); if (state.failed) return;
+
+				}
+				break;
+
+		}
+	}
+
+	// $ANTLR start synpred1_ActionAnalysis
+	public final void synpred1_ActionAnalysis_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionAnalysis.g:1:41: ( X_Y )
+		// org/antlr/grammar/v3/ActionAnalysis.g:1:41: X_Y
+		{
+		mX_Y(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred1_ActionAnalysis
+
+	// $ANTLR start synpred2_ActionAnalysis
+	public final void synpred2_ActionAnalysis_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionAnalysis.g:1:45: ( X )
+		// org/antlr/grammar/v3/ActionAnalysis.g:1:45: X
+		{
+		mX(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred2_ActionAnalysis
+
+	public final boolean synpred2_ActionAnalysis() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred2_ActionAnalysis_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred1_ActionAnalysis() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred1_ActionAnalysis_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+
+}
--- tool/src/main/java/org/antlr/grammar/v3/ActionTranslator.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/ActionTranslator.java	2019-04-04 17:22:25.476181469 +0200
@@ -0,0 +1,3600 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/ActionTranslator.g 2019-04-04 15:18:50
+
+package org.antlr.grammar.v3;
+import org.stringtemplate.v4.ST;
+import org.antlr.runtime.*;
+import org.antlr.tool.*;
+import org.antlr.codegen.*;
+
+import org.antlr.runtime.*;
+import java.util.List;
+import java.util.ArrayList;
+import org.antlr.grammar.v3.ANTLRParser;
+
+
+
+import org.antlr.runtime.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+
+@SuppressWarnings("all")
+public class ActionTranslator extends Lexer {
+	public static final int EOF=-1;
+	public static final int ACTION=4;
+	public static final int ARG=5;
+	public static final int ATTR_VALUE_EXPR=6;
+	public static final int DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR=7;
+	public static final int DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR=8;
+	public static final int DYNAMIC_SCOPE_ATTR=9;
+	public static final int ENCLOSING_RULE_SCOPE_ATTR=10;
+	public static final int ERROR_SCOPED_XY=11;
+	public static final int ERROR_X=12;
+	public static final int ERROR_XY=13;
+	public static final int ESC=14;
+	public static final int ID=15;
+	public static final int INDIRECT_TEMPLATE_INSTANCE=16;
+	public static final int INT=17;
+	public static final int ISOLATED_DYNAMIC_SCOPE=18;
+	public static final int ISOLATED_LEXER_RULE_REF=19;
+	public static final int ISOLATED_TOKEN_REF=20;
+	public static final int LABEL_REF=21;
+	public static final int LOCAL_ATTR=22;
+	public static final int RULE_SCOPE_ATTR=23;
+	public static final int SCOPE_INDEX_EXPR=24;
+	public static final int SET_ATTRIBUTE=25;
+	public static final int SET_DYNAMIC_SCOPE_ATTR=26;
+	public static final int SET_ENCLOSING_RULE_SCOPE_ATTR=27;
+	public static final int SET_EXPR_ATTRIBUTE=28;
+	public static final int SET_LOCAL_ATTR=29;
+	public static final int SET_RULE_SCOPE_ATTR=30;
+	public static final int SET_TOKEN_SCOPE_ATTR=31;
+	public static final int TEMPLATE_EXPR=32;
+	public static final int TEMPLATE_INSTANCE=33;
+	public static final int TEXT=34;
+	public static final int TOKEN_SCOPE_ATTR=35;
+	public static final int UNKNOWN_SYNTAX=36;
+	public static final int WS=37;
+
+	public List<Object> chunks = new ArrayList<Object>();
+	Rule enclosingRule;
+	int outerAltNum;
+	Grammar grammar;
+	CodeGenerator generator;
+	Token actionToken;
+
+		public ActionTranslator(CodeGenerator generator,
+									 String ruleName,
+									 GrammarAST actionAST)
+		{
+			this(new ANTLRStringStream(actionAST.token.getText()));
+			this.generator = generator;
+			this.grammar = generator.grammar;
+		    this.enclosingRule = grammar.getLocallyDefinedRule(ruleName);
+		    this.actionToken = actionAST.token;
+		    this.outerAltNum = actionAST.outerAltNum;
+		}
+
+		public ActionTranslator(CodeGenerator generator,
+									 String ruleName,
+									 Token actionToken,
+									 int outerAltNum)
+		{
+			this(new ANTLRStringStream(actionToken.getText()));
+			this.generator = generator;
+			grammar = generator.grammar;
+		    this.enclosingRule = grammar.getRule(ruleName);
+		    this.actionToken = actionToken;
+			this.outerAltNum = outerAltNum;
+		}
+
+	/** Return a list of strings and ST objects that
+	 *  represent the translated action.
+	 */
+	public List<Object> translateToChunks() {
+		// System.out.println("###\naction="+action);
+		Token t;
+		do {
+			t = nextToken();
+		} while ( t.getType()!= Token.EOF );
+		return chunks;
+	}
+
+	public String translate() {
+		List<Object> theChunks = translateToChunks();
+		//System.out.println("chunks="+a.chunks);
+		StringBuilder buf = new StringBuilder();
+		for (int i = 0; i < theChunks.size(); i++) {
+			Object o = theChunks.get(i);
+			if ( o instanceof ST ) buf.append(((ST)o).render());
+			else buf.append(o);
+		}
+		//System.out.println("translated: "+buf.toString());
+		return buf.toString();
+	}
+
+	public List<Object> translateAction(String action) {
+		String rname = null;
+		if ( enclosingRule!=null ) {
+			rname = enclosingRule.name;
+		}
+		ActionTranslator translator =
+			new ActionTranslator(generator,
+									  rname,
+									  new CommonToken(ANTLRParser.ACTION,action),outerAltNum);
+	    return translator.translateToChunks();
+	}
+
+	public boolean isTokenRefInAlt(String id) {
+	    return enclosingRule.getTokenRefsInAlt(id, outerAltNum)!=null;
+	}
+	public boolean isRuleRefInAlt(String id) {
+	    return enclosingRule.getRuleRefsInAlt(id, outerAltNum)!=null;
+	}
+	public Grammar.LabelElementPair getElementLabel(String id) {
+	    return enclosingRule.getLabel(id);
+	}
+
+	public void checkElementRefUniqueness(String ref, boolean isToken) {
+			List<GrammarAST> refs = null;
+			if ( isToken ) {
+			    refs = enclosingRule.getTokenRefsInAlt(ref, outerAltNum);
+			}
+			else {
+			    refs = enclosingRule.getRuleRefsInAlt(ref, outerAltNum);
+			}
+			if ( refs!=null && refs.size()>1 ) {
+				ErrorManager.grammarError(ErrorManager.MSG_NONUNIQUE_REF,
+										  grammar,
+										  actionToken,
+										  ref);
+			}
+	}
+
+	/** For $rulelabel.name, return the Attribute found for name.  It
+	 *  will be a predefined property or a return value.
+	 */
+	public Attribute getRuleLabelAttribute(String ruleName, String attrName) {
+		Rule r = grammar.getRule(ruleName);
+		AttributeScope scope = r.getLocalAttributeScope(attrName);
+		if ( scope!=null && !scope.isParameterScope ) {
+			return scope.getAttribute(attrName);
+		}
+		return null;
+	}
+
+	AttributeScope resolveDynamicScope(String scopeName) {
+		if ( grammar.getGlobalScope(scopeName)!=null ) {
+			return grammar.getGlobalScope(scopeName);
+		}
+		Rule scopeRule = grammar.getRule(scopeName);
+		if ( scopeRule!=null ) {
+			return scopeRule.ruleScope;
+		}
+		return null; // not a valid dynamic scope
+	}
+
+	protected ST template(String name) {
+		ST st = generator.getTemplates().getInstanceOf(name);
+		chunks.add(st);
+		return st;
+	}
+
+
+
+
+	// delegates
+	// delegators
+	public Lexer[] getDelegates() {
+		return new Lexer[] {};
+	}
+
+	public ActionTranslator() {} 
+	public ActionTranslator(CharStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public ActionTranslator(CharStream input, RecognizerSharedState state) {
+		super(input,state);
+	}
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/ActionTranslator.g"; }
+
+	@Override
+	public Token nextToken() {
+		while (true) {
+			if ( input.LA(1)==CharStream.EOF ) {
+				Token eof = new CommonToken(input,Token.EOF,
+											Token.DEFAULT_CHANNEL,
+											input.index(),input.index());
+				eof.setLine(getLine());
+				eof.setCharPositionInLine(getCharPositionInLine());
+				return eof;
+			}
+			state.token = null;
+		state.channel = Token.DEFAULT_CHANNEL;
+			state.tokenStartCharIndex = input.index();
+			state.tokenStartCharPositionInLine = input.getCharPositionInLine();
+			state.tokenStartLine = input.getLine();
+		state.text = null;
+			try {
+				int m = input.mark();
+				state.backtracking=1; 
+				state.failed=false;
+				mTokens();
+				state.backtracking=0;
+				if ( state.failed ) {
+					input.rewind(m);
+					input.consume(); 
+				}
+				else {
+					emit();
+					return state.token;
+				}
+			}
+			catch (RecognitionException re) {
+				// shouldn't happen in backtracking mode, but...
+				reportError(re);
+				recover(re);
+			}
+		}
+	}
+
+	@Override
+	public void memoize(IntStream input,
+			int ruleIndex,
+			int ruleStartIndex)
+	{
+	if ( state.backtracking>1 ) super.memoize(input, ruleIndex, ruleStartIndex);
+	}
+
+	@Override
+	public boolean alreadyParsedRule(IntStream input, int ruleIndex) {
+	if ( state.backtracking>1 ) return super.alreadyParsedRule(input, ruleIndex);
+	return false;
+	}
+	// $ANTLR start "SET_ENCLOSING_RULE_SCOPE_ATTR"
+	public final void mSET_ENCLOSING_RULE_SCOPE_ATTR() throws RecognitionException {
+		try {
+			int _type = SET_ENCLOSING_RULE_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+			CommonToken expr=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:185:2: ( '$' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:185:4: '$' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
+			{
+			match('$'); if (state.failed) return;
+			int xStart56 = getCharIndex();
+			int xStartLine56 = getLine();
+			int xStartCharPos56 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart56, getCharIndex()-1);
+			x.setLine(xStartLine56);
+			x.setCharPositionInLine(xStartCharPos56);
+
+			match('.'); if (state.failed) return;
+			int yStart62 = getCharIndex();
+			int yStartLine62 = getLine();
+			int yStartCharPos62 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart62, getCharIndex()-1);
+			y.setLine(yStartLine62);
+			y.setCharPositionInLine(yStartCharPos62);
+
+			// org/antlr/grammar/v3/ActionTranslator.g:185:22: ( WS )?
+			int alt1=2;
+			int LA1_0 = input.LA(1);
+			if ( ((LA1_0 >= '\t' && LA1_0 <= '\n')||LA1_0=='\r'||LA1_0==' ') ) {
+				alt1=1;
+			}
+			switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:185:22: WS
+					{
+					mWS(); if (state.failed) return;
+
+					}
+					break;
+
+			}
+
+			match('='); if (state.failed) return;
+			int exprStart71 = getCharIndex();
+			int exprStartLine71 = getLine();
+			int exprStartCharPos71 = getCharPositionInLine();
+			mATTR_VALUE_EXPR(); if (state.failed) return;
+			expr = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, exprStart71, getCharIndex()-1);
+			expr.setLine(exprStartLine71);
+			expr.setCharPositionInLine(exprStartCharPos71);
+
+			match(';'); if (state.failed) return;
+			if ( !((enclosingRule!=null &&
+				                         (x!=null?x.getText():null).equals(enclosingRule.name) &&
+				                         enclosingRule.getLocalAttributeScope((y!=null?y.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "SET_ENCLOSING_RULE_SCOPE_ATTR", "enclosingRule!=null &&\n\t                         $x.text.equals(enclosingRule.name) &&\n\t                         enclosingRule.getLocalAttributeScope($y.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+					ST st = null;
+					AttributeScope scope = enclosingRule.getLocalAttributeScope((y!=null?y.getText():null));
+					if ( scope.isPredefinedRuleScope ) {
+						if ( (y!=null?y.getText():null).equals("st") || (y!=null?y.getText():null).equals("tree") ) {
+							st = template("ruleSetPropertyRef_"+(y!=null?y.getText():null));
+							grammar.referenceRuleLabelPredefinedAttribute((x!=null?x.getText():null));
+							st.add("scope", (x!=null?x.getText():null));
+							st.add("attr", (y!=null?y.getText():null));
+							st.add("expr", translateAction((expr!=null?expr.getText():null)));
+						} else {
+							ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+													  grammar,
+													  actionToken,
+													  (x!=null?x.getText():null),
+													  (y!=null?y.getText():null));
+						}
+					}
+				    else if ( scope.isPredefinedLexerRuleScope ) {
+				    	// this is a better message to emit than the previous one...
+						ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+												  grammar,
+												  actionToken,
+												  (x!=null?x.getText():null),
+												  (y!=null?y.getText():null));
+				    }
+					else if ( scope.isParameterScope ) {
+						st = template("parameterSetAttributeRef");
+						st.add("attr", scope.getAttribute((y!=null?y.getText():null)));
+						st.add("expr", translateAction((expr!=null?expr.getText():null)));
+					}
+					else { // must be return value
+						st = template("returnSetAttributeRef");
+						st.add("ruleDescriptor", enclosingRule);
+						st.add("attr", scope.getAttribute((y!=null?y.getText():null)));
+						st.add("expr", translateAction((expr!=null?expr.getText():null)));
+					}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SET_ENCLOSING_RULE_SCOPE_ATTR"
+
+	// $ANTLR start "ENCLOSING_RULE_SCOPE_ATTR"
+	public final void mENCLOSING_RULE_SCOPE_ATTR() throws RecognitionException {
+		try {
+			int _type = ENCLOSING_RULE_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:230:2: ( '$' x= ID '.' y= ID {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:230:4: '$' x= ID '.' y= ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int xStart103 = getCharIndex();
+			int xStartLine103 = getLine();
+			int xStartCharPos103 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart103, getCharIndex()-1);
+			x.setLine(xStartLine103);
+			x.setCharPositionInLine(xStartCharPos103);
+
+			match('.'); if (state.failed) return;
+			int yStart109 = getCharIndex();
+			int yStartLine109 = getLine();
+			int yStartCharPos109 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart109, getCharIndex()-1);
+			y.setLine(yStartLine109);
+			y.setCharPositionInLine(yStartCharPos109);
+
+			if ( !((enclosingRule!=null &&
+				                         (x!=null?x.getText():null).equals(enclosingRule.name) &&
+				                         enclosingRule.getLocalAttributeScope((y!=null?y.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "ENCLOSING_RULE_SCOPE_ATTR", "enclosingRule!=null &&\n\t                         $x.text.equals(enclosingRule.name) &&\n\t                         enclosingRule.getLocalAttributeScope($y.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+					if ( isRuleRefInAlt((x!=null?x.getText():null))  ) {
+						ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+												  grammar,
+												  actionToken,
+												  (x!=null?x.getText():null));
+					}
+					ST st = null;
+					AttributeScope scope = enclosingRule.getLocalAttributeScope((y!=null?y.getText():null));
+					if ( scope.isPredefinedRuleScope ) {
+						st = template("rulePropertyRef_"+(y!=null?y.getText():null));
+						grammar.referenceRuleLabelPredefinedAttribute((x!=null?x.getText():null));
+						st.add("scope", (x!=null?x.getText():null));
+						st.add("attr", (y!=null?y.getText():null));
+					}
+				    else if ( scope.isPredefinedLexerRuleScope ) {
+				    	// perhaps not the most precise error message to use, but...
+						ErrorManager.grammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS,
+												  grammar,
+												  actionToken,
+												  (x!=null?x.getText():null));
+				    }
+					else if ( scope.isParameterScope ) {
+						st = template("parameterAttributeRef");
+						st.add("attr", scope.getAttribute((y!=null?y.getText():null)));
+					}
+					else { // must be return value
+						st = template("returnAttributeRef");
+						st.add("ruleDescriptor", enclosingRule);
+						st.add("attr", scope.getAttribute((y!=null?y.getText():null)));
+					}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ENCLOSING_RULE_SCOPE_ATTR"
+
+	// $ANTLR start "SET_TOKEN_SCOPE_ATTR"
+	public final void mSET_TOKEN_SCOPE_ATTR() throws RecognitionException {
+		try {
+			int _type = SET_TOKEN_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:270:2: ( '$' x= ID '.' y= ID ( WS )? '=' {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:270:4: '$' x= ID '.' y= ID ( WS )? '=' {...}?
+			{
+			match('$'); if (state.failed) return;
+			int xStart135 = getCharIndex();
+			int xStartLine135 = getLine();
+			int xStartCharPos135 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart135, getCharIndex()-1);
+			x.setLine(xStartLine135);
+			x.setCharPositionInLine(xStartCharPos135);
+
+			match('.'); if (state.failed) return;
+			int yStart141 = getCharIndex();
+			int yStartLine141 = getLine();
+			int yStartCharPos141 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart141, getCharIndex()-1);
+			y.setLine(yStartLine141);
+			y.setCharPositionInLine(yStartCharPos141);
+
+			// org/antlr/grammar/v3/ActionTranslator.g:270:22: ( WS )?
+			int alt2=2;
+			int LA2_0 = input.LA(1);
+			if ( ((LA2_0 >= '\t' && LA2_0 <= '\n')||LA2_0=='\r'||LA2_0==' ') ) {
+				alt2=1;
+			}
+			switch (alt2) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:270:22: WS
+					{
+					mWS(); if (state.failed) return;
+
+					}
+					break;
+
+			}
+
+			match('='); if (state.failed) return;
+			if ( !((enclosingRule!=null && input.LA(1)!='=' &&
+				                         (enclosingRule.getTokenLabel((x!=null?x.getText():null))!=null||
+				                          isTokenRefInAlt((x!=null?x.getText():null))) &&
+				                         AttributeScope.tokenScope.getAttribute((y!=null?y.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "SET_TOKEN_SCOPE_ATTR", "enclosingRule!=null && input.LA(1)!='=' &&\n\t                         (enclosingRule.getTokenLabel($x.text)!=null||\n\t                          isTokenRefInAlt($x.text)) &&\n\t                         AttributeScope.tokenScope.getAttribute($y.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+					ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+											  grammar,
+											  actionToken,
+											  (x!=null?x.getText():null),
+											  (y!=null?y.getText():null));
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SET_TOKEN_SCOPE_ATTR"
+
+	// $ANTLR start "TOKEN_SCOPE_ATTR"
+	public final void mTOKEN_SCOPE_ATTR() throws RecognitionException {
+		try {
+			int _type = TOKEN_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:289:2: ( '$' x= ID '.' y= ID {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:289:4: '$' x= ID '.' y= ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int xStart180 = getCharIndex();
+			int xStartLine180 = getLine();
+			int xStartCharPos180 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart180, getCharIndex()-1);
+			x.setLine(xStartLine180);
+			x.setCharPositionInLine(xStartCharPos180);
+
+			match('.'); if (state.failed) return;
+			int yStart186 = getCharIndex();
+			int yStartLine186 = getLine();
+			int yStartCharPos186 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart186, getCharIndex()-1);
+			y.setLine(yStartLine186);
+			y.setCharPositionInLine(yStartCharPos186);
+
+			if ( !((enclosingRule!=null &&
+				                         (enclosingRule.getTokenLabel((x!=null?x.getText():null))!=null||
+				                          isTokenRefInAlt((x!=null?x.getText():null))) &&
+				                         AttributeScope.tokenScope.getAttribute((y!=null?y.getText():null))!=null &&
+				                         (grammar.type!=Grammar.LEXER ||
+				                         getElementLabel((x!=null?x.getText():null)).elementRef.token.getType()==ANTLRParser.TOKEN_REF ||
+				                         getElementLabel((x!=null?x.getText():null)).elementRef.token.getType()==ANTLRParser.STRING_LITERAL))) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "TOKEN_SCOPE_ATTR", "enclosingRule!=null &&\n\t                         (enclosingRule.getTokenLabel($x.text)!=null||\n\t                          isTokenRefInAlt($x.text)) &&\n\t                         AttributeScope.tokenScope.getAttribute($y.text)!=null &&\n\t                         (grammar.type!=Grammar.LEXER ||\n\t                         getElementLabel($x.text).elementRef.token.getType()==ANTLRParser.TOKEN_REF ||\n\t                         getElementLabel($x.text).elementRef.token.getType()==ANTLRParser.STRING_LITERAL)");
+			}
+			if ( state.backtracking==1 ) {
+					String label = (x!=null?x.getText():null);
+					if ( enclosingRule.getTokenLabel((x!=null?x.getText():null))==null ) {
+						// $tokenref.attr  gotta get old label or compute new one
+						checkElementRefUniqueness((x!=null?x.getText():null), true);
+						label = enclosingRule.getElementLabel((x!=null?x.getText():null), outerAltNum, generator);
+						if ( label==null ) {
+							ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+													  grammar,
+													  actionToken,
+													  "$"+(x!=null?x.getText():null)+"."+(y!=null?y.getText():null));
+							label = (x!=null?x.getText():null);
+						}
+					}
+					ST st = template("tokenLabelPropertyRef_"+(y!=null?y.getText():null));
+					st.add("scope", label);
+					st.add("attr", AttributeScope.tokenScope.getAttribute((y!=null?y.getText():null)));
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TOKEN_SCOPE_ATTR"
+
+	// $ANTLR start "SET_RULE_SCOPE_ATTR"
+	public final void mSET_RULE_SCOPE_ATTR() throws RecognitionException {
+		try {
+			int _type = SET_RULE_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+
+
+			Grammar.LabelElementPair pair=null;
+			String refdRuleName=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:327:2: ( '$' x= ID '.' y= ID ( WS )? '=' {...}?{...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:327:4: '$' x= ID '.' y= ID ( WS )? '=' {...}?{...}?
+			{
+			match('$'); if (state.failed) return;
+			int xStart217 = getCharIndex();
+			int xStartLine217 = getLine();
+			int xStartCharPos217 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart217, getCharIndex()-1);
+			x.setLine(xStartLine217);
+			x.setCharPositionInLine(xStartCharPos217);
+
+			match('.'); if (state.failed) return;
+			int yStart223 = getCharIndex();
+			int yStartLine223 = getLine();
+			int yStartCharPos223 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart223, getCharIndex()-1);
+			y.setLine(yStartLine223);
+			y.setCharPositionInLine(yStartCharPos223);
+
+			// org/antlr/grammar/v3/ActionTranslator.g:327:22: ( WS )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+			if ( ((LA3_0 >= '\t' && LA3_0 <= '\n')||LA3_0=='\r'||LA3_0==' ') ) {
+				alt3=1;
+			}
+			switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:327:22: WS
+					{
+					mWS(); if (state.failed) return;
+
+					}
+					break;
+
+			}
+
+			match('='); if (state.failed) return;
+			if ( !((enclosingRule!=null && input.LA(1)!='=')) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "SET_RULE_SCOPE_ATTR", "enclosingRule!=null && input.LA(1)!='='");
+			}
+			if ( state.backtracking==1 ) {
+					pair = enclosingRule.getRuleLabel((x!=null?x.getText():null));
+					refdRuleName = (x!=null?x.getText():null);
+					if ( pair!=null ) {
+						refdRuleName = pair.referencedRuleName;
+					}
+					}
+			if ( !(((enclosingRule.getRuleLabel((x!=null?x.getText():null))!=null || isRuleRefInAlt((x!=null?x.getText():null))) &&
+				      getRuleLabelAttribute(enclosingRule.getRuleLabel((x!=null?x.getText():null))!=null?enclosingRule.getRuleLabel((x!=null?x.getText():null)).referencedRuleName:(x!=null?x.getText():null),(y!=null?y.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "SET_RULE_SCOPE_ATTR", "(enclosingRule.getRuleLabel($x.text)!=null || isRuleRefInAlt($x.text)) &&\n\t      getRuleLabelAttribute(enclosingRule.getRuleLabel($x.text)!=null?enclosingRule.getRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+					ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+											  grammar,
+											  actionToken,
+											  (x!=null?x.getText():null),
+											  (y!=null?y.getText():null));
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SET_RULE_SCOPE_ATTR"
+
+	// $ANTLR start "RULE_SCOPE_ATTR"
+	public final void mRULE_SCOPE_ATTR() throws RecognitionException {
+		try {
+			int _type = RULE_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+
+
+			Grammar.LabelElementPair pair=null;
+			String refdRuleName=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:356:2: ( '$' x= ID '.' y= ID {...}?{...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:356:4: '$' x= ID '.' y= ID {...}?{...}?
+			{
+			match('$'); if (state.failed) return;
+			int xStart276 = getCharIndex();
+			int xStartLine276 = getLine();
+			int xStartCharPos276 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart276, getCharIndex()-1);
+			x.setLine(xStartLine276);
+			x.setCharPositionInLine(xStartCharPos276);
+
+			match('.'); if (state.failed) return;
+			int yStart282 = getCharIndex();
+			int yStartLine282 = getLine();
+			int yStartCharPos282 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart282, getCharIndex()-1);
+			y.setLine(yStartLine282);
+			y.setCharPositionInLine(yStartCharPos282);
+
+			if ( !((enclosingRule!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "RULE_SCOPE_ATTR", "enclosingRule!=null");
+			}
+			if ( state.backtracking==1 ) {
+					pair = enclosingRule.getRuleLabel((x!=null?x.getText():null));
+					refdRuleName = (x!=null?x.getText():null);
+					if ( pair!=null ) {
+						refdRuleName = pair.referencedRuleName;
+					}
+					}
+			if ( !(((enclosingRule.getRuleLabel((x!=null?x.getText():null))!=null || isRuleRefInAlt((x!=null?x.getText():null))) &&
+				      getRuleLabelAttribute(enclosingRule.getRuleLabel((x!=null?x.getText():null))!=null?enclosingRule.getRuleLabel((x!=null?x.getText():null)).referencedRuleName:(x!=null?x.getText():null),(y!=null?y.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "RULE_SCOPE_ATTR", "(enclosingRule.getRuleLabel($x.text)!=null || isRuleRefInAlt($x.text)) &&\n\t      getRuleLabelAttribute(enclosingRule.getRuleLabel($x.text)!=null?enclosingRule.getRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+					String label = (x!=null?x.getText():null);
+					if ( pair==null ) {
+						// $ruleref.attr  gotta get old label or compute new one
+						checkElementRefUniqueness((x!=null?x.getText():null), false);
+						label = enclosingRule.getElementLabel((x!=null?x.getText():null), outerAltNum, generator);
+						if ( label==null ) {
+							ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+													  grammar,
+													  actionToken,
+													  "$"+(x!=null?x.getText():null)+"."+(y!=null?y.getText():null));
+							label = (x!=null?x.getText():null);
+						}
+					}
+					ST st;
+					Rule refdRule = grammar.getRule(refdRuleName);
+					AttributeScope scope = refdRule.getLocalAttributeScope((y!=null?y.getText():null));
+					if ( scope.isPredefinedRuleScope ) {
+						st = template("ruleLabelPropertyRef_"+(y!=null?y.getText():null));
+						grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+						st.add("scope", label);
+						st.add("attr", (y!=null?y.getText():null));
+					}
+					else if ( scope.isPredefinedLexerRuleScope ) {
+						st = template("lexerRuleLabelPropertyRef_"+(y!=null?y.getText():null));
+						grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+						st.add("scope", label);
+						st.add("attr", (y!=null?y.getText():null));
+					}
+					else if ( scope.isParameterScope ) {
+						// TODO: error!
+					}
+					else {
+						st = template("ruleLabelRef");
+						st.add("referencedRule", refdRule);
+						st.add("scope", label);
+						st.add("attr", scope.getAttribute((y!=null?y.getText():null)));
+					}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "RULE_SCOPE_ATTR"
+
+	// $ANTLR start "LABEL_REF"
+	public final void mLABEL_REF() throws RecognitionException {
+		try {
+			int _type = LABEL_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken ID1=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:414:2: ( '$' ID {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:414:4: '$' ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int ID1Start324 = getCharIndex();
+			int ID1StartLine324 = getLine();
+			int ID1StartCharPos324 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			ID1 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, ID1Start324, getCharIndex()-1);
+			ID1.setLine(ID1StartLine324);
+			ID1.setCharPositionInLine(ID1StartCharPos324);
+
+			if ( !((enclosingRule!=null &&
+				            getElementLabel((ID1!=null?ID1.getText():null))!=null &&
+					        enclosingRule.getRuleLabel((ID1!=null?ID1.getText():null))==null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "LABEL_REF", "enclosingRule!=null &&\n\t            getElementLabel($ID.text)!=null &&\n\t\t        enclosingRule.getRuleLabel($ID.text)==null");
+			}
+			if ( state.backtracking==1 ) {
+					ST st;
+					Grammar.LabelElementPair pair = getElementLabel((ID1!=null?ID1.getText():null));
+					if ( pair.type==Grammar.RULE_LIST_LABEL ||
+			             pair.type==Grammar.TOKEN_LIST_LABEL ||
+			             pair.type==Grammar.WILDCARD_TREE_LIST_LABEL )
+			        {
+						st = template("listLabelRef");
+					}
+					else {
+						st = template("tokenLabelRef");
+					}
+					st.add("label", (ID1!=null?ID1.getText():null));
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "LABEL_REF"
+
+	// $ANTLR start "ISOLATED_TOKEN_REF"
+	public final void mISOLATED_TOKEN_REF() throws RecognitionException {
+		try {
+			int _type = ISOLATED_TOKEN_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken ID2=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:436:2: ( '$' ID {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:436:4: '$' ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int ID2Start348 = getCharIndex();
+			int ID2StartLine348 = getLine();
+			int ID2StartCharPos348 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			ID2 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, ID2Start348, getCharIndex()-1);
+			ID2.setLine(ID2StartLine348);
+			ID2.setCharPositionInLine(ID2StartCharPos348);
+
+			if ( !((grammar.type!=Grammar.LEXER && enclosingRule!=null && isTokenRefInAlt((ID2!=null?ID2.getText():null)))) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "ISOLATED_TOKEN_REF", "grammar.type!=Grammar.LEXER && enclosingRule!=null && isTokenRefInAlt($ID.text)");
+			}
+			if ( state.backtracking==1 ) {
+					String label = enclosingRule.getElementLabel((ID2!=null?ID2.getText():null), outerAltNum, generator);
+					checkElementRefUniqueness((ID2!=null?ID2.getText():null), true);
+					if ( label==null ) {
+						ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+												  grammar,
+												  actionToken,
+												  (ID2!=null?ID2.getText():null));
+					}
+					else {
+						ST st = template("tokenLabelRef");
+						st.add("label", label);
+					}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ISOLATED_TOKEN_REF"
+
+	// $ANTLR start "ISOLATED_LEXER_RULE_REF"
+	public final void mISOLATED_LEXER_RULE_REF() throws RecognitionException {
+		try {
+			int _type = ISOLATED_LEXER_RULE_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken ID3=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:456:2: ( '$' ID {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:456:4: '$' ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int ID3Start372 = getCharIndex();
+			int ID3StartLine372 = getLine();
+			int ID3StartCharPos372 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			ID3 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, ID3Start372, getCharIndex()-1);
+			ID3.setLine(ID3StartLine372);
+			ID3.setCharPositionInLine(ID3StartCharPos372);
+
+			if ( !((grammar.type==Grammar.LEXER &&
+				             enclosingRule!=null &&
+				             isRuleRefInAlt((ID3!=null?ID3.getText():null)))) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "ISOLATED_LEXER_RULE_REF", "grammar.type==Grammar.LEXER &&\n\t             enclosingRule!=null &&\n\t             isRuleRefInAlt($ID.text)");
+			}
+			if ( state.backtracking==1 ) {
+					String label = enclosingRule.getElementLabel((ID3!=null?ID3.getText():null), outerAltNum, generator);
+					checkElementRefUniqueness((ID3!=null?ID3.getText():null), false);
+					if ( label==null ) {
+						ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+												  grammar,
+												  actionToken,
+												  (ID3!=null?ID3.getText():null));
+					}
+					else {
+						ST st = template("lexerRuleLabel");
+						st.add("label", label);
+					}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ISOLATED_LEXER_RULE_REF"
+
+	// $ANTLR start "SET_LOCAL_ATTR"
+	public final void mSET_LOCAL_ATTR() throws RecognitionException {
+		try {
+			int _type = SET_LOCAL_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken expr=null;
+			CommonToken ID4=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:488:2: ( '$' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:488:4: '$' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
+			{
+			match('$'); if (state.failed) return;
+			int ID4Start396 = getCharIndex();
+			int ID4StartLine396 = getLine();
+			int ID4StartCharPos396 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			ID4 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, ID4Start396, getCharIndex()-1);
+			ID4.setLine(ID4StartLine396);
+			ID4.setCharPositionInLine(ID4StartCharPos396);
+
+			// org/antlr/grammar/v3/ActionTranslator.g:488:11: ( WS )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+			if ( ((LA4_0 >= '\t' && LA4_0 <= '\n')||LA4_0=='\r'||LA4_0==' ') ) {
+				alt4=1;
+			}
+			switch (alt4) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:488:11: WS
+					{
+					mWS(); if (state.failed) return;
+
+					}
+					break;
+
+			}
+
+			match('='); if (state.failed) return;
+			int exprStart405 = getCharIndex();
+			int exprStartLine405 = getLine();
+			int exprStartCharPos405 = getCharPositionInLine();
+			mATTR_VALUE_EXPR(); if (state.failed) return;
+			expr = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, exprStart405, getCharIndex()-1);
+			expr.setLine(exprStartLine405);
+			expr.setCharPositionInLine(exprStartCharPos405);
+
+			match(';'); if (state.failed) return;
+			if ( !((enclosingRule!=null
+																&& enclosingRule.getLocalAttributeScope((ID4!=null?ID4.getText():null))!=null
+																&& !enclosingRule.getLocalAttributeScope((ID4!=null?ID4.getText():null)).isPredefinedLexerRuleScope)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "SET_LOCAL_ATTR", "enclosingRule!=null\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& enclosingRule.getLocalAttributeScope($ID.text)!=null\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& !enclosingRule.getLocalAttributeScope($ID.text).isPredefinedLexerRuleScope");
+			}
+			if ( state.backtracking==1 ) {
+					ST st;
+					AttributeScope scope = enclosingRule.getLocalAttributeScope((ID4!=null?ID4.getText():null));
+					if ( scope.isPredefinedRuleScope ) {
+						if ((ID4!=null?ID4.getText():null).equals("tree") || (ID4!=null?ID4.getText():null).equals("st")) {
+							st = template("ruleSetPropertyRef_"+(ID4!=null?ID4.getText():null));
+							grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+							st.add("scope", enclosingRule.name);
+							st.add("attr", (ID4!=null?ID4.getText():null));
+							st.add("expr", translateAction((expr!=null?expr.getText():null)));
+						} else {
+							ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+													 grammar,
+													 actionToken,
+													 (ID4!=null?ID4.getText():null),
+													 "");
+						}
+					}
+					else if ( scope.isParameterScope ) {
+						st = template("parameterSetAttributeRef");
+						st.add("attr", scope.getAttribute((ID4!=null?ID4.getText():null)));
+						st.add("expr", translateAction((expr!=null?expr.getText():null)));
+					}
+					else {
+						st = template("returnSetAttributeRef");
+						st.add("ruleDescriptor", enclosingRule);
+						st.add("attr", scope.getAttribute((ID4!=null?ID4.getText():null)));
+						st.add("expr", translateAction((expr!=null?expr.getText():null)));
+						}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SET_LOCAL_ATTR"
+
+	// $ANTLR start "LOCAL_ATTR"
+	public final void mLOCAL_ATTR() throws RecognitionException {
+		try {
+			int _type = LOCAL_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken ID5=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:524:2: ( '$' ID {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:524:4: '$' ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int ID5Start428 = getCharIndex();
+			int ID5StartLine428 = getLine();
+			int ID5StartCharPos428 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			ID5 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, ID5Start428, getCharIndex()-1);
+			ID5.setLine(ID5StartLine428);
+			ID5.setCharPositionInLine(ID5StartCharPos428);
+
+			if ( !((enclosingRule!=null && enclosingRule.getLocalAttributeScope((ID5!=null?ID5.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "LOCAL_ATTR", "enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+					ST st;
+					AttributeScope scope = enclosingRule.getLocalAttributeScope((ID5!=null?ID5.getText():null));
+					if ( scope.isPredefinedRuleScope ) {
+						st = template("rulePropertyRef_"+(ID5!=null?ID5.getText():null));
+						grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+						st.add("scope", enclosingRule.name);
+						st.add("attr", (ID5!=null?ID5.getText():null));
+					}
+					else if ( scope.isPredefinedLexerRuleScope ) {
+						st = template("lexerRulePropertyRef_"+(ID5!=null?ID5.getText():null));
+						st.add("scope", enclosingRule.name);
+						st.add("attr", (ID5!=null?ID5.getText():null));
+					}
+					else if ( scope.isParameterScope ) {
+						st = template("parameterAttributeRef");
+						st.add("attr", scope.getAttribute((ID5!=null?ID5.getText():null)));
+					}
+					else {
+						st = template("returnAttributeRef");
+						st.add("ruleDescriptor", enclosingRule);
+						st.add("attr", scope.getAttribute((ID5!=null?ID5.getText():null)));
+					}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "LOCAL_ATTR"
+
+	// $ANTLR start "SET_DYNAMIC_SCOPE_ATTR"
+	public final void mSET_DYNAMIC_SCOPE_ATTR() throws RecognitionException {
+		try {
+			int _type = SET_DYNAMIC_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+			CommonToken expr=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:565:2: ( '$' x= ID '::' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:565:4: '$' x= ID '::' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
+			{
+			match('$'); if (state.failed) return;
+			int xStart454 = getCharIndex();
+			int xStartLine454 = getLine();
+			int xStartCharPos454 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart454, getCharIndex()-1);
+			x.setLine(xStartLine454);
+			x.setCharPositionInLine(xStartCharPos454);
+
+			match("::"); if (state.failed) return;
+
+			int yStart460 = getCharIndex();
+			int yStartLine460 = getLine();
+			int yStartCharPos460 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart460, getCharIndex()-1);
+			y.setLine(yStartLine460);
+			y.setCharPositionInLine(yStartCharPos460);
+
+			// org/antlr/grammar/v3/ActionTranslator.g:565:23: ( WS )?
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+			if ( ((LA5_0 >= '\t' && LA5_0 <= '\n')||LA5_0=='\r'||LA5_0==' ') ) {
+				alt5=1;
+			}
+			switch (alt5) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:565:23: WS
+					{
+					mWS(); if (state.failed) return;
+
+					}
+					break;
+
+			}
+
+			match('='); if (state.failed) return;
+			int exprStart469 = getCharIndex();
+			int exprStartLine469 = getLine();
+			int exprStartCharPos469 = getCharPositionInLine();
+			mATTR_VALUE_EXPR(); if (state.failed) return;
+			expr = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, exprStart469, getCharIndex()-1);
+			expr.setLine(exprStartLine469);
+			expr.setCharPositionInLine(exprStartCharPos469);
+
+			match(';'); if (state.failed) return;
+			if ( !((resolveDynamicScope((x!=null?x.getText():null))!=null &&
+									     resolveDynamicScope((x!=null?x.getText():null)).getAttribute((y!=null?y.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "SET_DYNAMIC_SCOPE_ATTR", "resolveDynamicScope($x.text)!=null &&\n\t\t\t\t\t\t     resolveDynamicScope($x.text).getAttribute($y.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+					AttributeScope scope = resolveDynamicScope((x!=null?x.getText():null));
+					if ( scope!=null ) {
+						ST st = template("scopeSetAttributeRef");
+						st.add("scope", (x!=null?x.getText():null));
+						st.add("attr",  scope.getAttribute((y!=null?y.getText():null)));
+						st.add("expr",  translateAction((expr!=null?expr.getText():null)));
+					}
+					else {
+						// error: invalid dynamic attribute
+					}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SET_DYNAMIC_SCOPE_ATTR"
+
+	// $ANTLR start "DYNAMIC_SCOPE_ATTR"
+	public final void mDYNAMIC_SCOPE_ATTR() throws RecognitionException {
+		try {
+			int _type = DYNAMIC_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:584:2: ( '$' x= ID '::' y= ID {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:584:4: '$' x= ID '::' y= ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int xStart504 = getCharIndex();
+			int xStartLine504 = getLine();
+			int xStartCharPos504 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart504, getCharIndex()-1);
+			x.setLine(xStartLine504);
+			x.setCharPositionInLine(xStartCharPos504);
+
+			match("::"); if (state.failed) return;
+
+			int yStart510 = getCharIndex();
+			int yStartLine510 = getLine();
+			int yStartCharPos510 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart510, getCharIndex()-1);
+			y.setLine(yStartLine510);
+			y.setCharPositionInLine(yStartCharPos510);
+
+			if ( !((resolveDynamicScope((x!=null?x.getText():null))!=null &&
+									     resolveDynamicScope((x!=null?x.getText():null)).getAttribute((y!=null?y.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "DYNAMIC_SCOPE_ATTR", "resolveDynamicScope($x.text)!=null &&\n\t\t\t\t\t\t     resolveDynamicScope($x.text).getAttribute($y.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+					AttributeScope scope = resolveDynamicScope((x!=null?x.getText():null));
+					if ( scope!=null ) {
+						ST st = template("scopeAttributeRef");
+						st.add("scope", (x!=null?x.getText():null));
+						st.add("attr",  scope.getAttribute((y!=null?y.getText():null)));
+					}
+					else {
+						// error: invalid dynamic attribute
+					}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "DYNAMIC_SCOPE_ATTR"
+
+	// $ANTLR start "ERROR_SCOPED_XY"
+	public final void mERROR_SCOPED_XY() throws RecognitionException {
+		try {
+			int _type = ERROR_SCOPED_XY;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:603:2: ( '$' x= ID '::' y= ID )
+			// org/antlr/grammar/v3/ActionTranslator.g:603:4: '$' x= ID '::' y= ID
+			{
+			match('$'); if (state.failed) return;
+			int xStart544 = getCharIndex();
+			int xStartLine544 = getLine();
+			int xStartCharPos544 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart544, getCharIndex()-1);
+			x.setLine(xStartLine544);
+			x.setCharPositionInLine(xStartCharPos544);
+
+			match("::"); if (state.failed) return;
+
+			int yStart550 = getCharIndex();
+			int yStartLine550 = getLine();
+			int yStartCharPos550 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart550, getCharIndex()-1);
+			y.setLine(yStartLine550);
+			y.setCharPositionInLine(yStartCharPos550);
+
+			if ( state.backtracking==1 ) {
+					chunks.add(getText());
+					generator.issueInvalidScopeError((x!=null?x.getText():null),(y!=null?y.getText():null),
+					                                 enclosingRule,actionToken,
+					                                 outerAltNum);		
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ERROR_SCOPED_XY"
+
+	// $ANTLR start "DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR"
+	public final void mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR() throws RecognitionException {
+		try {
+			int _type = DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken expr=null;
+			CommonToken y=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:621:2: ( '$' x= ID '[' '-' expr= SCOPE_INDEX_EXPR ']' '::' y= ID )
+			// org/antlr/grammar/v3/ActionTranslator.g:621:4: '$' x= ID '[' '-' expr= SCOPE_INDEX_EXPR ']' '::' y= ID
+			{
+			match('$'); if (state.failed) return;
+			int xStart572 = getCharIndex();
+			int xStartLine572 = getLine();
+			int xStartCharPos572 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart572, getCharIndex()-1);
+			x.setLine(xStartLine572);
+			x.setCharPositionInLine(xStartCharPos572);
+
+			match('['); if (state.failed) return;
+			match('-'); if (state.failed) return;
+			int exprStart580 = getCharIndex();
+			int exprStartLine580 = getLine();
+			int exprStartCharPos580 = getCharPositionInLine();
+			mSCOPE_INDEX_EXPR(); if (state.failed) return;
+			expr = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, exprStart580, getCharIndex()-1);
+			expr.setLine(exprStartLine580);
+			expr.setCharPositionInLine(exprStartCharPos580);
+
+			match(']'); if (state.failed) return;
+			match("::"); if (state.failed) return;
+
+			int yStart588 = getCharIndex();
+			int yStartLine588 = getLine();
+			int yStartCharPos588 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart588, getCharIndex()-1);
+			y.setLine(yStartLine588);
+			y.setCharPositionInLine(yStartCharPos588);
+
+			if ( state.backtracking==1 ) {
+					ST st = template("scopeAttributeRef");
+					st.add("scope",    (x!=null?x.getText():null));
+					st.add("attr",     resolveDynamicScope((x!=null?x.getText():null)).getAttribute((y!=null?y.getText():null)));
+					st.add("negIndex", (expr!=null?expr.getText():null));
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR"
+
+	// $ANTLR start "DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR"
+	public final void mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR() throws RecognitionException {
+		try {
+			int _type = DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken expr=null;
+			CommonToken y=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:632:2: ( '$' x= ID '[' expr= SCOPE_INDEX_EXPR ']' '::' y= ID )
+			// org/antlr/grammar/v3/ActionTranslator.g:632:4: '$' x= ID '[' expr= SCOPE_INDEX_EXPR ']' '::' y= ID
+			{
+			match('$'); if (state.failed) return;
+			int xStart612 = getCharIndex();
+			int xStartLine612 = getLine();
+			int xStartCharPos612 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart612, getCharIndex()-1);
+			x.setLine(xStartLine612);
+			x.setCharPositionInLine(xStartCharPos612);
+
+			match('['); if (state.failed) return;
+			int exprStart618 = getCharIndex();
+			int exprStartLine618 = getLine();
+			int exprStartCharPos618 = getCharPositionInLine();
+			mSCOPE_INDEX_EXPR(); if (state.failed) return;
+			expr = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, exprStart618, getCharIndex()-1);
+			expr.setLine(exprStartLine618);
+			expr.setCharPositionInLine(exprStartCharPos618);
+
+			match(']'); if (state.failed) return;
+			match("::"); if (state.failed) return;
+
+			int yStart626 = getCharIndex();
+			int yStartLine626 = getLine();
+			int yStartCharPos626 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart626, getCharIndex()-1);
+			y.setLine(yStartLine626);
+			y.setCharPositionInLine(yStartCharPos626);
+
+			if ( state.backtracking==1 ) {
+					ST st = template("scopeAttributeRef");
+					st.add("scope", (x!=null?x.getText():null));
+					st.add("attr",  resolveDynamicScope((x!=null?x.getText():null)).getAttribute((y!=null?y.getText():null)));
+					st.add("index", (expr!=null?expr.getText():null));
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR"
+
+	// $ANTLR start "SCOPE_INDEX_EXPR"
+	public final void mSCOPE_INDEX_EXPR() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ActionTranslator.g:644:2: ( (~ ']' )+ )
+			// org/antlr/grammar/v3/ActionTranslator.g:644:4: (~ ']' )+
+			{
+			// org/antlr/grammar/v3/ActionTranslator.g:644:4: (~ ']' )+
+			int cnt6=0;
+			loop6:
+			while (true) {
+				int alt6=2;
+				int LA6_0 = input.LA(1);
+				if ( ((LA6_0 >= '\u0000' && LA6_0 <= '\\')||(LA6_0 >= '^' && LA6_0 <= '\uFFFF')) ) {
+					alt6=1;
+				}
+
+				switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '\\')||(input.LA(1) >= '^' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					if ( cnt6 >= 1 ) break loop6;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(6, input);
+					throw eee;
+				}
+				cnt6++;
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SCOPE_INDEX_EXPR"
+
+	// $ANTLR start "ISOLATED_DYNAMIC_SCOPE"
+	public final void mISOLATED_DYNAMIC_SCOPE() throws RecognitionException {
+		try {
+			int _type = ISOLATED_DYNAMIC_SCOPE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken ID6=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:653:2: ( '$' ID {...}?)
+			// org/antlr/grammar/v3/ActionTranslator.g:653:4: '$' ID {...}?
+			{
+			match('$'); if (state.failed) return;
+			int ID6Start669 = getCharIndex();
+			int ID6StartLine669 = getLine();
+			int ID6StartCharPos669 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			ID6 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, ID6Start669, getCharIndex()-1);
+			ID6.setLine(ID6StartLine669);
+			ID6.setCharPositionInLine(ID6StartCharPos669);
+
+			if ( !((resolveDynamicScope((ID6!=null?ID6.getText():null))!=null)) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "ISOLATED_DYNAMIC_SCOPE", "resolveDynamicScope($ID.text)!=null");
+			}
+			if ( state.backtracking==1 ) {
+					ST st = template("isolatedDynamicScopeRef");
+					st.add("scope", (ID6!=null?ID6.getText():null));
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ISOLATED_DYNAMIC_SCOPE"
+
+	// $ANTLR start "TEMPLATE_INSTANCE"
+	public final void mTEMPLATE_INSTANCE() throws RecognitionException {
+		try {
+			int _type = TEMPLATE_INSTANCE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ActionTranslator.g:666:2: ( '%' ID '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')' )
+			// org/antlr/grammar/v3/ActionTranslator.g:666:4: '%' ID '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')'
+			{
+			match('%'); if (state.failed) return;
+			mID(); if (state.failed) return;
+
+			match('('); if (state.failed) return;
+			// org/antlr/grammar/v3/ActionTranslator.g:666:15: ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )?
+			int alt11=2;
+			int LA11_0 = input.LA(1);
+			if ( ((LA11_0 >= '\t' && LA11_0 <= '\n')||LA11_0=='\r'||LA11_0==' '||(LA11_0 >= 'A' && LA11_0 <= 'Z')||LA11_0=='_'||(LA11_0 >= 'a' && LA11_0 <= 'z')) ) {
+				alt11=1;
+			}
+			switch (alt11) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:666:17: ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )?
+					{
+					// org/antlr/grammar/v3/ActionTranslator.g:666:17: ( WS )?
+					int alt7=2;
+					int LA7_0 = input.LA(1);
+					if ( ((LA7_0 >= '\t' && LA7_0 <= '\n')||LA7_0=='\r'||LA7_0==' ') ) {
+						alt7=1;
+					}
+					switch (alt7) {
+						case 1 :
+							// org/antlr/grammar/v3/ActionTranslator.g:666:17: WS
+							{
+							mWS(); if (state.failed) return;
+
+							}
+							break;
+
+					}
+
+					mARG(); if (state.failed) return;
+
+					// org/antlr/grammar/v3/ActionTranslator.g:666:25: ( ',' ( WS )? ARG )*
+					loop9:
+					while (true) {
+						int alt9=2;
+						int LA9_0 = input.LA(1);
+						if ( (LA9_0==',') ) {
+							alt9=1;
+						}
+
+						switch (alt9) {
+						case 1 :
+							// org/antlr/grammar/v3/ActionTranslator.g:666:26: ',' ( WS )? ARG
+							{
+							match(','); if (state.failed) return;
+							// org/antlr/grammar/v3/ActionTranslator.g:666:30: ( WS )?
+							int alt8=2;
+							int LA8_0 = input.LA(1);
+							if ( ((LA8_0 >= '\t' && LA8_0 <= '\n')||LA8_0=='\r'||LA8_0==' ') ) {
+								alt8=1;
+							}
+							switch (alt8) {
+								case 1 :
+									// org/antlr/grammar/v3/ActionTranslator.g:666:30: WS
+									{
+									mWS(); if (state.failed) return;
+
+									}
+									break;
+
+							}
+
+							mARG(); if (state.failed) return;
+
+							}
+							break;
+
+						default :
+							break loop9;
+						}
+					}
+
+					// org/antlr/grammar/v3/ActionTranslator.g:666:40: ( WS )?
+					int alt10=2;
+					int LA10_0 = input.LA(1);
+					if ( ((LA10_0 >= '\t' && LA10_0 <= '\n')||LA10_0=='\r'||LA10_0==' ') ) {
+						alt10=1;
+					}
+					switch (alt10) {
+						case 1 :
+							// org/antlr/grammar/v3/ActionTranslator.g:666:40: WS
+							{
+							mWS(); if (state.failed) return;
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+
+			}
+
+			match(')'); if (state.failed) return;
+			if ( state.backtracking==1 ) {
+					String action = getText().substring(1,getText().length());
+					String ruleName = "<outside-of-rule>";
+					if ( enclosingRule!=null ) {
+						ruleName = enclosingRule.name;
+					}
+					ST st =
+						generator.translateTemplateConstructor(ruleName,
+															   outerAltNum,
+															   actionToken,
+															   action);
+					if ( st!=null ) {
+						chunks.add(st);
+					}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TEMPLATE_INSTANCE"
+
+	// $ANTLR start "INDIRECT_TEMPLATE_INSTANCE"
+	public final void mINDIRECT_TEMPLATE_INSTANCE() throws RecognitionException {
+		try {
+			int _type = INDIRECT_TEMPLATE_INSTANCE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ActionTranslator.g:687:2: ( '%' '(' ACTION ')' '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')' )
+			// org/antlr/grammar/v3/ActionTranslator.g:687:4: '%' '(' ACTION ')' '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')'
+			{
+			match('%'); if (state.failed) return;
+			match('('); if (state.failed) return;
+			mACTION(); if (state.failed) return;
+
+			match(')'); if (state.failed) return;
+			match('('); if (state.failed) return;
+			// org/antlr/grammar/v3/ActionTranslator.g:687:27: ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+			if ( ((LA16_0 >= '\t' && LA16_0 <= '\n')||LA16_0=='\r'||LA16_0==' '||(LA16_0 >= 'A' && LA16_0 <= 'Z')||LA16_0=='_'||(LA16_0 >= 'a' && LA16_0 <= 'z')) ) {
+				alt16=1;
+			}
+			switch (alt16) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:687:29: ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )?
+					{
+					// org/antlr/grammar/v3/ActionTranslator.g:687:29: ( WS )?
+					int alt12=2;
+					int LA12_0 = input.LA(1);
+					if ( ((LA12_0 >= '\t' && LA12_0 <= '\n')||LA12_0=='\r'||LA12_0==' ') ) {
+						alt12=1;
+					}
+					switch (alt12) {
+						case 1 :
+							// org/antlr/grammar/v3/ActionTranslator.g:687:29: WS
+							{
+							mWS(); if (state.failed) return;
+
+							}
+							break;
+
+					}
+
+					mARG(); if (state.failed) return;
+
+					// org/antlr/grammar/v3/ActionTranslator.g:687:37: ( ',' ( WS )? ARG )*
+					loop14:
+					while (true) {
+						int alt14=2;
+						int LA14_0 = input.LA(1);
+						if ( (LA14_0==',') ) {
+							alt14=1;
+						}
+
+						switch (alt14) {
+						case 1 :
+							// org/antlr/grammar/v3/ActionTranslator.g:687:38: ',' ( WS )? ARG
+							{
+							match(','); if (state.failed) return;
+							// org/antlr/grammar/v3/ActionTranslator.g:687:42: ( WS )?
+							int alt13=2;
+							int LA13_0 = input.LA(1);
+							if ( ((LA13_0 >= '\t' && LA13_0 <= '\n')||LA13_0=='\r'||LA13_0==' ') ) {
+								alt13=1;
+							}
+							switch (alt13) {
+								case 1 :
+									// org/antlr/grammar/v3/ActionTranslator.g:687:42: WS
+									{
+									mWS(); if (state.failed) return;
+
+									}
+									break;
+
+							}
+
+							mARG(); if (state.failed) return;
+
+							}
+							break;
+
+						default :
+							break loop14;
+						}
+					}
+
+					// org/antlr/grammar/v3/ActionTranslator.g:687:52: ( WS )?
+					int alt15=2;
+					int LA15_0 = input.LA(1);
+					if ( ((LA15_0 >= '\t' && LA15_0 <= '\n')||LA15_0=='\r'||LA15_0==' ') ) {
+						alt15=1;
+					}
+					switch (alt15) {
+						case 1 :
+							// org/antlr/grammar/v3/ActionTranslator.g:687:52: WS
+							{
+							mWS(); if (state.failed) return;
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+
+			}
+
+			match(')'); if (state.failed) return;
+			if ( state.backtracking==1 ) {
+					String action = getText().substring(1,getText().length());
+					ST st =
+						generator.translateTemplateConstructor(enclosingRule.name,
+															   outerAltNum,
+															   actionToken,
+															   action);
+					chunks.add(st);
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "INDIRECT_TEMPLATE_INSTANCE"
+
+	// $ANTLR start "ARG"
+	public final void mARG() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ActionTranslator.g:701:5: ( ID '=' ACTION )
+			// org/antlr/grammar/v3/ActionTranslator.g:701:7: ID '=' ACTION
+			{
+			mID(); if (state.failed) return;
+
+			match('='); if (state.failed) return;
+			mACTION(); if (state.failed) return;
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ARG"
+
+	// $ANTLR start "SET_EXPR_ATTRIBUTE"
+	public final void mSET_EXPR_ATTRIBUTE() throws RecognitionException {
+		try {
+			int _type = SET_EXPR_ATTRIBUTE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken a=null;
+			CommonToken expr=null;
+			CommonToken ID7=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:706:2: ( '%' a= ACTION '.' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' )
+			// org/antlr/grammar/v3/ActionTranslator.g:706:4: '%' a= ACTION '.' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';'
+			{
+			match('%'); if (state.failed) return;
+			int aStart819 = getCharIndex();
+			int aStartLine819 = getLine();
+			int aStartCharPos819 = getCharPositionInLine();
+			mACTION(); if (state.failed) return;
+			a = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, aStart819, getCharIndex()-1);
+			a.setLine(aStartLine819);
+			a.setCharPositionInLine(aStartCharPos819);
+
+			match('.'); if (state.failed) return;
+			int ID7Start823 = getCharIndex();
+			int ID7StartLine823 = getLine();
+			int ID7StartCharPos823 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			ID7 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, ID7Start823, getCharIndex()-1);
+			ID7.setLine(ID7StartLine823);
+			ID7.setCharPositionInLine(ID7StartCharPos823);
+
+			// org/antlr/grammar/v3/ActionTranslator.g:706:24: ( WS )?
+			int alt17=2;
+			int LA17_0 = input.LA(1);
+			if ( ((LA17_0 >= '\t' && LA17_0 <= '\n')||LA17_0=='\r'||LA17_0==' ') ) {
+				alt17=1;
+			}
+			switch (alt17) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:706:24: WS
+					{
+					mWS(); if (state.failed) return;
+
+					}
+					break;
+
+			}
+
+			match('='); if (state.failed) return;
+			int exprStart832 = getCharIndex();
+			int exprStartLine832 = getLine();
+			int exprStartCharPos832 = getCharPositionInLine();
+			mATTR_VALUE_EXPR(); if (state.failed) return;
+			expr = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, exprStart832, getCharIndex()-1);
+			expr.setLine(exprStartLine832);
+			expr.setCharPositionInLine(exprStartCharPos832);
+
+			match(';'); if (state.failed) return;
+			if ( state.backtracking==1 ) {
+					ST st = template("actionSetAttribute");
+					String action = (a!=null?a.getText():null);
+					action = action.substring(1,action.length()-1); // stuff inside {...}
+					st.add("st", translateAction(action));
+					st.add("attrName", (ID7!=null?ID7.getText():null));
+					st.add("expr", translateAction((expr!=null?expr.getText():null)));
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SET_EXPR_ATTRIBUTE"
+
+	// $ANTLR start "SET_ATTRIBUTE"
+	public final void mSET_ATTRIBUTE() throws RecognitionException {
+		try {
+			int _type = SET_ATTRIBUTE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+			CommonToken expr=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:723:2: ( '%' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' )
+			// org/antlr/grammar/v3/ActionTranslator.g:723:4: '%' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';'
+			{
+			match('%'); if (state.failed) return;
+			int xStart859 = getCharIndex();
+			int xStartLine859 = getLine();
+			int xStartCharPos859 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart859, getCharIndex()-1);
+			x.setLine(xStartLine859);
+			x.setCharPositionInLine(xStartCharPos859);
+
+			match('.'); if (state.failed) return;
+			int yStart865 = getCharIndex();
+			int yStartLine865 = getLine();
+			int yStartCharPos865 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart865, getCharIndex()-1);
+			y.setLine(yStartLine865);
+			y.setCharPositionInLine(yStartCharPos865);
+
+			// org/antlr/grammar/v3/ActionTranslator.g:723:22: ( WS )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+			if ( ((LA18_0 >= '\t' && LA18_0 <= '\n')||LA18_0=='\r'||LA18_0==' ') ) {
+				alt18=1;
+			}
+			switch (alt18) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:723:22: WS
+					{
+					mWS(); if (state.failed) return;
+
+					}
+					break;
+
+			}
+
+			match('='); if (state.failed) return;
+			int exprStart874 = getCharIndex();
+			int exprStartLine874 = getLine();
+			int exprStartCharPos874 = getCharPositionInLine();
+			mATTR_VALUE_EXPR(); if (state.failed) return;
+			expr = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, exprStart874, getCharIndex()-1);
+			expr.setLine(exprStartLine874);
+			expr.setCharPositionInLine(exprStartCharPos874);
+
+			match(';'); if (state.failed) return;
+			if ( state.backtracking==1 ) {
+					ST st = template("actionSetAttribute");
+					st.add("st", (x!=null?x.getText():null));
+					st.add("attrName", (y!=null?y.getText():null));
+					st.add("expr", translateAction((expr!=null?expr.getText():null)));
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SET_ATTRIBUTE"
+
+	// $ANTLR start "ATTR_VALUE_EXPR"
+	public final void mATTR_VALUE_EXPR() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ActionTranslator.g:736:2: (~ '=' (~ ';' )* )
+			// org/antlr/grammar/v3/ActionTranslator.g:736:4: ~ '=' (~ ';' )*
+			{
+			if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '<')||(input.LA(1) >= '>' && input.LA(1) <= '\uFFFF') ) {
+				input.consume();
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				recover(mse);
+				throw mse;
+			}
+			// org/antlr/grammar/v3/ActionTranslator.g:736:9: (~ ';' )*
+			loop19:
+			while (true) {
+				int alt19=2;
+				int LA19_0 = input.LA(1);
+				if ( ((LA19_0 >= '\u0000' && LA19_0 <= ':')||(LA19_0 >= '<' && LA19_0 <= '\uFFFF')) ) {
+					alt19=1;
+				}
+
+				switch (alt19) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= ':')||(input.LA(1) >= '<' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop19;
+				}
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ATTR_VALUE_EXPR"
+
+	// $ANTLR start "TEMPLATE_EXPR"
+	public final void mTEMPLATE_EXPR() throws RecognitionException {
+		try {
+			int _type = TEMPLATE_EXPR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken a=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:741:2: ( '%' a= ACTION )
+			// org/antlr/grammar/v3/ActionTranslator.g:741:4: '%' a= ACTION
+			{
+			match('%'); if (state.failed) return;
+			int aStart923 = getCharIndex();
+			int aStartLine923 = getLine();
+			int aStartCharPos923 = getCharPositionInLine();
+			mACTION(); if (state.failed) return;
+			a = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, aStart923, getCharIndex()-1);
+			a.setLine(aStartLine923);
+			a.setCharPositionInLine(aStartCharPos923);
+
+			if ( state.backtracking==1 ) {
+					ST st = template("actionStringConstructor");
+					String action = (a!=null?a.getText():null);
+					action = action.substring(1,action.length()-1); // stuff inside {...}
+					st.add("stringExpr", translateAction(action));
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TEMPLATE_EXPR"
+
+	// $ANTLR start "ACTION"
+	public final void mACTION() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ActionTranslator.g:753:2: ( '{' ( options {greedy=false; } : . )* '}' )
+			// org/antlr/grammar/v3/ActionTranslator.g:753:4: '{' ( options {greedy=false; } : . )* '}'
+			{
+			match('{'); if (state.failed) return;
+			// org/antlr/grammar/v3/ActionTranslator.g:753:8: ( options {greedy=false; } : . )*
+			loop20:
+			while (true) {
+				int alt20=2;
+				int LA20_0 = input.LA(1);
+				if ( (LA20_0=='}') ) {
+					alt20=2;
+				}
+				else if ( ((LA20_0 >= '\u0000' && LA20_0 <= '|')||(LA20_0 >= '~' && LA20_0 <= '\uFFFF')) ) {
+					alt20=1;
+				}
+
+				switch (alt20) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:753:33: .
+					{
+					matchAny(); if (state.failed) return;
+					}
+					break;
+
+				default :
+					break loop20;
+				}
+			}
+
+			match('}'); if (state.failed) return;
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ACTION"
+
+	// $ANTLR start "ESC"
+	public final void mESC() throws RecognitionException {
+		try {
+			int _type = ESC;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ActionTranslator.g:756:5: ( '\\\\' '$' | '\\\\' '%' | '\\\\' ~ ( '$' | '%' ) )
+			int alt21=3;
+			int LA21_0 = input.LA(1);
+			if ( (LA21_0=='\\') ) {
+				int LA21_1 = input.LA(2);
+				if ( (LA21_1=='$') ) {
+					alt21=1;
+				}
+				else if ( (LA21_1=='%') ) {
+					alt21=2;
+				}
+				else if ( ((LA21_1 >= '\u0000' && LA21_1 <= '#')||(LA21_1 >= '&' && LA21_1 <= '\uFFFF')) ) {
+					alt21=3;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 21, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 21, 0, input);
+				throw nvae;
+			}
+
+			switch (alt21) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:756:9: '\\\\' '$'
+					{
+					match('\\'); if (state.failed) return;
+					match('$'); if (state.failed) return;
+					if ( state.backtracking==1 ) {chunks.add("$");}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ActionTranslator.g:757:4: '\\\\' '%'
+					{
+					match('\\'); if (state.failed) return;
+					match('%'); if (state.failed) return;
+					if ( state.backtracking==1 ) {chunks.add("%");}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ActionTranslator.g:758:4: '\\\\' ~ ( '$' | '%' )
+					{
+					match('\\'); if (state.failed) return;
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '#')||(input.LA(1) >= '&' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					if ( state.backtracking==1 ) {chunks.add(getText());}
+					}
+					break;
+
+			}
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ESC"
+
+	// $ANTLR start "ERROR_XY"
+	public final void mERROR_XY() throws RecognitionException {
+		try {
+			int _type = ERROR_XY;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+			CommonToken y=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:762:2: ( '$' x= ID '.' y= ID )
+			// org/antlr/grammar/v3/ActionTranslator.g:762:4: '$' x= ID '.' y= ID
+			{
+			match('$'); if (state.failed) return;
+			int xStart1023 = getCharIndex();
+			int xStartLine1023 = getLine();
+			int xStartCharPos1023 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart1023, getCharIndex()-1);
+			x.setLine(xStartLine1023);
+			x.setCharPositionInLine(xStartCharPos1023);
+
+			match('.'); if (state.failed) return;
+			int yStart1029 = getCharIndex();
+			int yStartLine1029 = getLine();
+			int yStartCharPos1029 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			y = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, yStart1029, getCharIndex()-1);
+			y.setLine(yStartLine1029);
+			y.setCharPositionInLine(yStartCharPos1029);
+
+			if ( state.backtracking==1 ) {
+					chunks.add(getText());
+					generator.issueInvalidAttributeError((x!=null?x.getText():null),(y!=null?y.getText():null),
+					                                     enclosingRule,actionToken,
+					                                     outerAltNum);
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ERROR_XY"
+
+	// $ANTLR start "ERROR_X"
+	public final void mERROR_X() throws RecognitionException {
+		try {
+			int _type = ERROR_X;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			CommonToken x=null;
+
+			// org/antlr/grammar/v3/ActionTranslator.g:772:2: ( '$' x= ID )
+			// org/antlr/grammar/v3/ActionTranslator.g:772:4: '$' x= ID
+			{
+			match('$'); if (state.failed) return;
+			int xStart1049 = getCharIndex();
+			int xStartLine1049 = getLine();
+			int xStartCharPos1049 = getCharPositionInLine();
+			mID(); if (state.failed) return;
+			x = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, xStart1049, getCharIndex()-1);
+			x.setLine(xStartLine1049);
+			x.setCharPositionInLine(xStartCharPos1049);
+
+			if ( state.backtracking==1 ) {
+					chunks.add(getText());
+					generator.issueInvalidAttributeError((x!=null?x.getText():null),
+					                                     enclosingRule,actionToken,
+					                                     outerAltNum);
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ERROR_X"
+
+	// $ANTLR start "UNKNOWN_SYNTAX"
+	public final void mUNKNOWN_SYNTAX() throws RecognitionException {
+		try {
+			int _type = UNKNOWN_SYNTAX;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ActionTranslator.g:782:2: ( '$' | '%' ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )* )
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+			if ( (LA23_0=='$') ) {
+				alt23=1;
+			}
+			else if ( (LA23_0=='%') ) {
+				alt23=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 23, 0, input);
+				throw nvae;
+			}
+
+			switch (alt23) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:782:4: '$'
+					{
+					match('$'); if (state.failed) return;
+					if ( state.backtracking==1 ) {
+							chunks.add(getText());
+							// shouldn't need an error here.  Just accept $ if it doesn't look like anything
+							}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ActionTranslator.g:787:4: '%' ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )*
+					{
+					match('%'); if (state.failed) return;
+					// org/antlr/grammar/v3/ActionTranslator.g:787:8: ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )*
+					loop22:
+					while (true) {
+						int alt22=9;
+						switch ( input.LA(1) ) {
+						case 'A':
+						case 'B':
+						case 'C':
+						case 'D':
+						case 'E':
+						case 'F':
+						case 'G':
+						case 'H':
+						case 'I':
+						case 'J':
+						case 'K':
+						case 'L':
+						case 'M':
+						case 'N':
+						case 'O':
+						case 'P':
+						case 'Q':
+						case 'R':
+						case 'S':
+						case 'T':
+						case 'U':
+						case 'V':
+						case 'W':
+						case 'X':
+						case 'Y':
+						case 'Z':
+						case '_':
+						case 'a':
+						case 'b':
+						case 'c':
+						case 'd':
+						case 'e':
+						case 'f':
+						case 'g':
+						case 'h':
+						case 'i':
+						case 'j':
+						case 'k':
+						case 'l':
+						case 'm':
+						case 'n':
+						case 'o':
+						case 'p':
+						case 'q':
+						case 'r':
+						case 's':
+						case 't':
+						case 'u':
+						case 'v':
+						case 'w':
+						case 'x':
+						case 'y':
+						case 'z':
+							{
+							alt22=1;
+							}
+							break;
+						case '.':
+							{
+							alt22=2;
+							}
+							break;
+						case '(':
+							{
+							alt22=3;
+							}
+							break;
+						case ')':
+							{
+							alt22=4;
+							}
+							break;
+						case ',':
+							{
+							alt22=5;
+							}
+							break;
+						case '{':
+							{
+							alt22=6;
+							}
+							break;
+						case '}':
+							{
+							alt22=7;
+							}
+							break;
+						case '\"':
+							{
+							alt22=8;
+							}
+							break;
+						}
+						switch (alt22) {
+						case 1 :
+							// org/antlr/grammar/v3/ActionTranslator.g:787:9: ID
+							{
+							mID(); if (state.failed) return;
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ActionTranslator.g:787:12: '.'
+							{
+							match('.'); if (state.failed) return;
+							}
+							break;
+						case 3 :
+							// org/antlr/grammar/v3/ActionTranslator.g:787:16: '('
+							{
+							match('('); if (state.failed) return;
+							}
+							break;
+						case 4 :
+							// org/antlr/grammar/v3/ActionTranslator.g:787:20: ')'
+							{
+							match(')'); if (state.failed) return;
+							}
+							break;
+						case 5 :
+							// org/antlr/grammar/v3/ActionTranslator.g:787:24: ','
+							{
+							match(','); if (state.failed) return;
+							}
+							break;
+						case 6 :
+							// org/antlr/grammar/v3/ActionTranslator.g:787:28: '{'
+							{
+							match('{'); if (state.failed) return;
+							}
+							break;
+						case 7 :
+							// org/antlr/grammar/v3/ActionTranslator.g:787:32: '}'
+							{
+							match('}'); if (state.failed) return;
+							}
+							break;
+						case 8 :
+							// org/antlr/grammar/v3/ActionTranslator.g:787:36: '\"'
+							{
+							match('\"'); if (state.failed) return;
+							}
+							break;
+
+						default :
+							break loop22;
+						}
+					}
+
+					if ( state.backtracking==1 ) {
+							chunks.add(getText());
+							ErrorManager.grammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
+													  grammar,
+													  actionToken,
+													  getText());
+							}
+					}
+					break;
+
+			}
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "UNKNOWN_SYNTAX"
+
+	// $ANTLR start "TEXT"
+	public final void mTEXT() throws RecognitionException {
+		try {
+			int _type = TEXT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ActionTranslator.g:797:5: ( (~ ( '$' | '%' | '\\\\' ) )+ )
+			// org/antlr/grammar/v3/ActionTranslator.g:797:7: (~ ( '$' | '%' | '\\\\' ) )+
+			{
+			// org/antlr/grammar/v3/ActionTranslator.g:797:7: (~ ( '$' | '%' | '\\\\' ) )+
+			int cnt24=0;
+			loop24:
+			while (true) {
+				int alt24=2;
+				int LA24_0 = input.LA(1);
+				if ( ((LA24_0 >= '\u0000' && LA24_0 <= '#')||(LA24_0 >= '&' && LA24_0 <= '[')||(LA24_0 >= ']' && LA24_0 <= '\uFFFF')) ) {
+					alt24=1;
+				}
+
+				switch (alt24) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '#')||(input.LA(1) >= '&' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					if ( cnt24 >= 1 ) break loop24;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(24, input);
+					throw eee;
+				}
+				cnt24++;
+			}
+
+			if ( state.backtracking==1 ) {chunks.add(getText());}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TEXT"
+
+	// $ANTLR start "ID"
+	public final void mID() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ActionTranslator.g:801:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// org/antlr/grammar/v3/ActionTranslator.g:801:9: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			{
+			if ( (input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
+				input.consume();
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				recover(mse);
+				throw mse;
+			}
+			// org/antlr/grammar/v3/ActionTranslator.g:801:33: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			loop25:
+			while (true) {
+				int alt25=2;
+				int LA25_0 = input.LA(1);
+				if ( ((LA25_0 >= '0' && LA25_0 <= '9')||(LA25_0 >= 'A' && LA25_0 <= 'Z')||LA25_0=='_'||(LA25_0 >= 'a' && LA25_0 <= 'z')) ) {
+					alt25=1;
+				}
+
+				switch (alt25) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:
+					{
+					if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop25;
+				}
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ID"
+
+	// $ANTLR start "INT"
+	public final void mINT() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ActionTranslator.g:805:5: ( ( '0' .. '9' )+ )
+			// org/antlr/grammar/v3/ActionTranslator.g:805:7: ( '0' .. '9' )+
+			{
+			// org/antlr/grammar/v3/ActionTranslator.g:805:7: ( '0' .. '9' )+
+			int cnt26=0;
+			loop26:
+			while (true) {
+				int alt26=2;
+				int LA26_0 = input.LA(1);
+				if ( ((LA26_0 >= '0' && LA26_0 <= '9')) ) {
+					alt26=1;
+				}
+
+				switch (alt26) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:
+					{
+					if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					if ( cnt26 >= 1 ) break loop26;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(26, input);
+					throw eee;
+				}
+				cnt26++;
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "INT"
+
+	// $ANTLR start "WS"
+	public final void mWS() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ActionTranslator.g:809:4: ( ( ' ' | '\\t' | '\\n' | '\\r' )+ )
+			// org/antlr/grammar/v3/ActionTranslator.g:809:6: ( ' ' | '\\t' | '\\n' | '\\r' )+
+			{
+			// org/antlr/grammar/v3/ActionTranslator.g:809:6: ( ' ' | '\\t' | '\\n' | '\\r' )+
+			int cnt27=0;
+			loop27:
+			while (true) {
+				int alt27=2;
+				int LA27_0 = input.LA(1);
+				if ( ((LA27_0 >= '\t' && LA27_0 <= '\n')||LA27_0=='\r'||LA27_0==' ') ) {
+					alt27=1;
+				}
+
+				switch (alt27) {
+				case 1 :
+					// org/antlr/grammar/v3/ActionTranslator.g:
+					{
+					if ( (input.LA(1) >= '\t' && input.LA(1) <= '\n')||input.LA(1)=='\r'||input.LA(1)==' ' ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					if ( cnt27 >= 1 ) break loop27;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(27, input);
+					throw eee;
+				}
+				cnt27++;
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "WS"
+
+	@Override
+	public void mTokens() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:39: ( SET_ENCLOSING_RULE_SCOPE_ATTR | ENCLOSING_RULE_SCOPE_ATTR | SET_TOKEN_SCOPE_ATTR | TOKEN_SCOPE_ATTR | SET_RULE_SCOPE_ATTR | RULE_SCOPE_ATTR | LABEL_REF | ISOLATED_TOKEN_REF | ISOLATED_LEXER_RULE_REF | SET_LOCAL_ATTR | LOCAL_ATTR | SET_DYNAMIC_SCOPE_ATTR | DYNAMIC_SCOPE_ATTR | ERROR_SCOPED_XY | DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR | DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR | ISOLATED_DYNAMIC_SCOPE | TEMPLATE_INSTANCE | INDIRECT_TEMPLATE_INSTANCE | SET_EXPR_ATTRIBUTE | SET_ATTRIBUTE | TEMPLATE_EXPR | ESC | ERROR_XY | ERROR_X | UNKNOWN_SYNTAX | TEXT )
+		int alt28=27;
+		int LA28_0 = input.LA(1);
+		if ( (LA28_0=='$') ) {
+			int LA28_1 = input.LA(2);
+			if ( (synpred1_ActionTranslator()) ) {
+				alt28=1;
+			}
+			else if ( (synpred2_ActionTranslator()) ) {
+				alt28=2;
+			}
+			else if ( (synpred3_ActionTranslator()) ) {
+				alt28=3;
+			}
+			else if ( (synpred4_ActionTranslator()) ) {
+				alt28=4;
+			}
+			else if ( (synpred5_ActionTranslator()) ) {
+				alt28=5;
+			}
+			else if ( (synpred6_ActionTranslator()) ) {
+				alt28=6;
+			}
+			else if ( (synpred7_ActionTranslator()) ) {
+				alt28=7;
+			}
+			else if ( (synpred8_ActionTranslator()) ) {
+				alt28=8;
+			}
+			else if ( (synpred9_ActionTranslator()) ) {
+				alt28=9;
+			}
+			else if ( (synpred10_ActionTranslator()) ) {
+				alt28=10;
+			}
+			else if ( (synpred11_ActionTranslator()) ) {
+				alt28=11;
+			}
+			else if ( (synpred12_ActionTranslator()) ) {
+				alt28=12;
+			}
+			else if ( (synpred13_ActionTranslator()) ) {
+				alt28=13;
+			}
+			else if ( (synpred14_ActionTranslator()) ) {
+				alt28=14;
+			}
+			else if ( (synpred15_ActionTranslator()) ) {
+				alt28=15;
+			}
+			else if ( (synpred16_ActionTranslator()) ) {
+				alt28=16;
+			}
+			else if ( (synpred17_ActionTranslator()) ) {
+				alt28=17;
+			}
+			else if ( (synpred24_ActionTranslator()) ) {
+				alt28=24;
+			}
+			else if ( (synpred25_ActionTranslator()) ) {
+				alt28=25;
+			}
+			else if ( (synpred26_ActionTranslator()) ) {
+				alt28=26;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				int nvaeMark = input.mark();
+				try {
+					input.consume();
+					NoViableAltException nvae =
+						new NoViableAltException("", 28, 1, input);
+					throw nvae;
+				} finally {
+					input.rewind(nvaeMark);
+				}
+			}
+
+		}
+		else if ( (LA28_0=='%') ) {
+			int LA28_22 = input.LA(2);
+			if ( (synpred18_ActionTranslator()) ) {
+				alt28=18;
+			}
+			else if ( (synpred19_ActionTranslator()) ) {
+				alt28=19;
+			}
+			else if ( (synpred20_ActionTranslator()) ) {
+				alt28=20;
+			}
+			else if ( (synpred21_ActionTranslator()) ) {
+				alt28=21;
+			}
+			else if ( (synpred22_ActionTranslator()) ) {
+				alt28=22;
+			}
+			else if ( (synpred26_ActionTranslator()) ) {
+				alt28=26;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				int nvaeMark = input.mark();
+				try {
+					input.consume();
+					NoViableAltException nvae =
+						new NoViableAltException("", 28, 22, input);
+					throw nvae;
+				} finally {
+					input.rewind(nvaeMark);
+				}
+			}
+
+		}
+		else if ( (LA28_0=='\\') ) {
+			alt28=23;
+		}
+		else if ( ((LA28_0 >= '\u0000' && LA28_0 <= '#')||(LA28_0 >= '&' && LA28_0 <= '[')||(LA28_0 >= ']' && LA28_0 <= '\uFFFF')) ) {
+			alt28=27;
+		}
+
+		else {
+			if (state.backtracking>0) {state.failed=true; return;}
+			NoViableAltException nvae =
+				new NoViableAltException("", 28, 0, input);
+			throw nvae;
+		}
+
+		switch (alt28) {
+			case 1 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:41: SET_ENCLOSING_RULE_SCOPE_ATTR
+				{
+				mSET_ENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 2 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:71: ENCLOSING_RULE_SCOPE_ATTR
+				{
+				mENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 3 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:97: SET_TOKEN_SCOPE_ATTR
+				{
+				mSET_TOKEN_SCOPE_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 4 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:118: TOKEN_SCOPE_ATTR
+				{
+				mTOKEN_SCOPE_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 5 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:135: SET_RULE_SCOPE_ATTR
+				{
+				mSET_RULE_SCOPE_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 6 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:155: RULE_SCOPE_ATTR
+				{
+				mRULE_SCOPE_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 7 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:171: LABEL_REF
+				{
+				mLABEL_REF(); if (state.failed) return;
+
+				}
+				break;
+			case 8 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:181: ISOLATED_TOKEN_REF
+				{
+				mISOLATED_TOKEN_REF(); if (state.failed) return;
+
+				}
+				break;
+			case 9 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:200: ISOLATED_LEXER_RULE_REF
+				{
+				mISOLATED_LEXER_RULE_REF(); if (state.failed) return;
+
+				}
+				break;
+			case 10 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:224: SET_LOCAL_ATTR
+				{
+				mSET_LOCAL_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 11 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:239: LOCAL_ATTR
+				{
+				mLOCAL_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 12 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:250: SET_DYNAMIC_SCOPE_ATTR
+				{
+				mSET_DYNAMIC_SCOPE_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 13 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:273: DYNAMIC_SCOPE_ATTR
+				{
+				mDYNAMIC_SCOPE_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 14 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:292: ERROR_SCOPED_XY
+				{
+				mERROR_SCOPED_XY(); if (state.failed) return;
+
+				}
+				break;
+			case 15 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:308: DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
+				{
+				mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 16 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:344: DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
+				{
+				mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR(); if (state.failed) return;
+
+				}
+				break;
+			case 17 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:380: ISOLATED_DYNAMIC_SCOPE
+				{
+				mISOLATED_DYNAMIC_SCOPE(); if (state.failed) return;
+
+				}
+				break;
+			case 18 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:403: TEMPLATE_INSTANCE
+				{
+				mTEMPLATE_INSTANCE(); if (state.failed) return;
+
+				}
+				break;
+			case 19 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:421: INDIRECT_TEMPLATE_INSTANCE
+				{
+				mINDIRECT_TEMPLATE_INSTANCE(); if (state.failed) return;
+
+				}
+				break;
+			case 20 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:448: SET_EXPR_ATTRIBUTE
+				{
+				mSET_EXPR_ATTRIBUTE(); if (state.failed) return;
+
+				}
+				break;
+			case 21 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:467: SET_ATTRIBUTE
+				{
+				mSET_ATTRIBUTE(); if (state.failed) return;
+
+				}
+				break;
+			case 22 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:481: TEMPLATE_EXPR
+				{
+				mTEMPLATE_EXPR(); if (state.failed) return;
+
+				}
+				break;
+			case 23 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:495: ESC
+				{
+				mESC(); if (state.failed) return;
+
+				}
+				break;
+			case 24 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:499: ERROR_XY
+				{
+				mERROR_XY(); if (state.failed) return;
+
+				}
+				break;
+			case 25 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:508: ERROR_X
+				{
+				mERROR_X(); if (state.failed) return;
+
+				}
+				break;
+			case 26 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:516: UNKNOWN_SYNTAX
+				{
+				mUNKNOWN_SYNTAX(); if (state.failed) return;
+
+				}
+				break;
+			case 27 :
+				// org/antlr/grammar/v3/ActionTranslator.g:1:531: TEXT
+				{
+				mTEXT(); if (state.failed) return;
+
+				}
+				break;
+
+		}
+	}
+
+	// $ANTLR start synpred1_ActionTranslator
+	public final void synpred1_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:41: ( SET_ENCLOSING_RULE_SCOPE_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:41: SET_ENCLOSING_RULE_SCOPE_ATTR
+		{
+		mSET_ENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred1_ActionTranslator
+
+	// $ANTLR start synpred2_ActionTranslator
+	public final void synpred2_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:71: ( ENCLOSING_RULE_SCOPE_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:71: ENCLOSING_RULE_SCOPE_ATTR
+		{
+		mENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred2_ActionTranslator
+
+	// $ANTLR start synpred3_ActionTranslator
+	public final void synpred3_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:97: ( SET_TOKEN_SCOPE_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:97: SET_TOKEN_SCOPE_ATTR
+		{
+		mSET_TOKEN_SCOPE_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred3_ActionTranslator
+
+	// $ANTLR start synpred4_ActionTranslator
+	public final void synpred4_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:118: ( TOKEN_SCOPE_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:118: TOKEN_SCOPE_ATTR
+		{
+		mTOKEN_SCOPE_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred4_ActionTranslator
+
+	// $ANTLR start synpred5_ActionTranslator
+	public final void synpred5_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:135: ( SET_RULE_SCOPE_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:135: SET_RULE_SCOPE_ATTR
+		{
+		mSET_RULE_SCOPE_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred5_ActionTranslator
+
+	// $ANTLR start synpred6_ActionTranslator
+	public final void synpred6_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:155: ( RULE_SCOPE_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:155: RULE_SCOPE_ATTR
+		{
+		mRULE_SCOPE_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred6_ActionTranslator
+
+	// $ANTLR start synpred7_ActionTranslator
+	public final void synpred7_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:171: ( LABEL_REF )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:171: LABEL_REF
+		{
+		mLABEL_REF(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred7_ActionTranslator
+
+	// $ANTLR start synpred8_ActionTranslator
+	public final void synpred8_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:181: ( ISOLATED_TOKEN_REF )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:181: ISOLATED_TOKEN_REF
+		{
+		mISOLATED_TOKEN_REF(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred8_ActionTranslator
+
+	// $ANTLR start synpred9_ActionTranslator
+	public final void synpred9_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:200: ( ISOLATED_LEXER_RULE_REF )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:200: ISOLATED_LEXER_RULE_REF
+		{
+		mISOLATED_LEXER_RULE_REF(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred9_ActionTranslator
+
+	// $ANTLR start synpred10_ActionTranslator
+	public final void synpred10_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:224: ( SET_LOCAL_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:224: SET_LOCAL_ATTR
+		{
+		mSET_LOCAL_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred10_ActionTranslator
+
+	// $ANTLR start synpred11_ActionTranslator
+	public final void synpred11_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:239: ( LOCAL_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:239: LOCAL_ATTR
+		{
+		mLOCAL_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred11_ActionTranslator
+
+	// $ANTLR start synpred12_ActionTranslator
+	public final void synpred12_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:250: ( SET_DYNAMIC_SCOPE_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:250: SET_DYNAMIC_SCOPE_ATTR
+		{
+		mSET_DYNAMIC_SCOPE_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred12_ActionTranslator
+
+	// $ANTLR start synpred13_ActionTranslator
+	public final void synpred13_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:273: ( DYNAMIC_SCOPE_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:273: DYNAMIC_SCOPE_ATTR
+		{
+		mDYNAMIC_SCOPE_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred13_ActionTranslator
+
+	// $ANTLR start synpred14_ActionTranslator
+	public final void synpred14_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:292: ( ERROR_SCOPED_XY )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:292: ERROR_SCOPED_XY
+		{
+		mERROR_SCOPED_XY(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred14_ActionTranslator
+
+	// $ANTLR start synpred15_ActionTranslator
+	public final void synpred15_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:308: ( DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:308: DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
+		{
+		mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred15_ActionTranslator
+
+	// $ANTLR start synpred16_ActionTranslator
+	public final void synpred16_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:344: ( DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:344: DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
+		{
+		mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred16_ActionTranslator
+
+	// $ANTLR start synpred17_ActionTranslator
+	public final void synpred17_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:380: ( ISOLATED_DYNAMIC_SCOPE )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:380: ISOLATED_DYNAMIC_SCOPE
+		{
+		mISOLATED_DYNAMIC_SCOPE(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred17_ActionTranslator
+
+	// $ANTLR start synpred18_ActionTranslator
+	public final void synpred18_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:403: ( TEMPLATE_INSTANCE )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:403: TEMPLATE_INSTANCE
+		{
+		mTEMPLATE_INSTANCE(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred18_ActionTranslator
+
+	// $ANTLR start synpred19_ActionTranslator
+	public final void synpred19_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:421: ( INDIRECT_TEMPLATE_INSTANCE )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:421: INDIRECT_TEMPLATE_INSTANCE
+		{
+		mINDIRECT_TEMPLATE_INSTANCE(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred19_ActionTranslator
+
+	// $ANTLR start synpred20_ActionTranslator
+	public final void synpred20_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:448: ( SET_EXPR_ATTRIBUTE )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:448: SET_EXPR_ATTRIBUTE
+		{
+		mSET_EXPR_ATTRIBUTE(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred20_ActionTranslator
+
+	// $ANTLR start synpred21_ActionTranslator
+	public final void synpred21_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:467: ( SET_ATTRIBUTE )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:467: SET_ATTRIBUTE
+		{
+		mSET_ATTRIBUTE(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred21_ActionTranslator
+
+	// $ANTLR start synpred22_ActionTranslator
+	public final void synpred22_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:481: ( TEMPLATE_EXPR )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:481: TEMPLATE_EXPR
+		{
+		mTEMPLATE_EXPR(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred22_ActionTranslator
+
+	// $ANTLR start synpred24_ActionTranslator
+	public final void synpred24_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:499: ( ERROR_XY )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:499: ERROR_XY
+		{
+		mERROR_XY(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred24_ActionTranslator
+
+	// $ANTLR start synpred25_ActionTranslator
+	public final void synpred25_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:508: ( ERROR_X )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:508: ERROR_X
+		{
+		mERROR_X(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred25_ActionTranslator
+
+	// $ANTLR start synpred26_ActionTranslator
+	public final void synpred26_ActionTranslator_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ActionTranslator.g:1:516: ( UNKNOWN_SYNTAX )
+		// org/antlr/grammar/v3/ActionTranslator.g:1:516: UNKNOWN_SYNTAX
+		{
+		mUNKNOWN_SYNTAX(); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred26_ActionTranslator
+
+	public final boolean synpred7_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred7_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred26_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred26_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred18_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred18_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred13_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred13_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred17_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred17_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred6_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred6_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred2_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred2_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred21_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred21_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred1_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred1_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred25_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred25_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred19_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred19_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred12_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred12_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred16_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred16_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred11_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred11_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred9_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred9_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred24_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred24_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred5_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred5_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred20_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred20_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred15_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred15_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred4_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred4_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred10_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred10_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred14_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred14_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred8_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred8_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred22_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred22_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred3_ActionTranslator() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred3_ActionTranslator_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+
+}
--- tool/src/main/java/org/antlr/grammar/v3/ANTLRLexer.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/ANTLRLexer.java	2019-04-04 17:22:25.476181469 +0200
@@ -0,0 +1,3520 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/ANTLR.g 2019-04-04 15:18:49
+
+package org.antlr.grammar.v3;
+import org.antlr.tool.ErrorManager;
+import org.antlr.tool.Grammar;
+
+
+import org.antlr.runtime.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+
+@SuppressWarnings("all")
+public class ANTLRLexer extends Lexer {
+	public static final int EOF=-1;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int AMPERSAND=9;
+	public static final int ARG=10;
+	public static final int ARGLIST=11;
+	public static final int ARG_ACTION=12;
+	public static final int ASSIGN=13;
+	public static final int BACKTRACK_SEMPRED=14;
+	public static final int BANG=15;
+	public static final int BLOCK=16;
+	public static final int CATCH=17;
+	public static final int CHAR_LITERAL=18;
+	public static final int CHAR_RANGE=19;
+	public static final int CLOSE_ELEMENT_OPTION=20;
+	public static final int CLOSURE=21;
+	public static final int COLON=22;
+	public static final int COMBINED_GRAMMAR=23;
+	public static final int COMMA=24;
+	public static final int COMMENT=25;
+	public static final int DIGIT=26;
+	public static final int DOC_COMMENT=27;
+	public static final int DOLLAR=28;
+	public static final int DOT=29;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public static final int EOA=32;
+	public static final int EOB=33;
+	public static final int EOR=34;
+	public static final int EPSILON=35;
+	public static final int ESC=36;
+	public static final int ETC=37;
+	public static final int FINALLY=38;
+	public static final int FORCED_ACTION=39;
+	public static final int FRAGMENT=40;
+	public static final int GATED_SEMPRED=41;
+	public static final int GRAMMAR=42;
+	public static final int ID=43;
+	public static final int IMPLIES=44;
+	public static final int IMPORT=45;
+	public static final int INITACTION=46;
+	public static final int INT=47;
+	public static final int LABEL=48;
+	public static final int LEXER=49;
+	public static final int LEXER_GRAMMAR=50;
+	public static final int LPAREN=51;
+	public static final int ML_COMMENT=52;
+	public static final int NESTED_ACTION=53;
+	public static final int NESTED_ARG_ACTION=54;
+	public static final int NOT=55;
+	public static final int OPEN_ELEMENT_OPTION=56;
+	public static final int OPTIONAL=57;
+	public static final int OPTIONS=58;
+	public static final int OR=59;
+	public static final int PARSER=60;
+	public static final int PARSER_GRAMMAR=61;
+	public static final int PLUS=62;
+	public static final int PLUS_ASSIGN=63;
+	public static final int POSITIVE_CLOSURE=64;
+	public static final int PREC_RULE=65;
+	public static final int PRIVATE=66;
+	public static final int PROTECTED=67;
+	public static final int PUBLIC=68;
+	public static final int QUESTION=69;
+	public static final int RANGE=70;
+	public static final int RCURLY=71;
+	public static final int RECURSIVE_RULE_REF=72;
+	public static final int RET=73;
+	public static final int RETURNS=74;
+	public static final int REWRITE=75;
+	public static final int REWRITES=76;
+	public static final int ROOT=77;
+	public static final int RPAREN=78;
+	public static final int RULE=79;
+	public static final int RULE_REF=80;
+	public static final int SCOPE=81;
+	public static final int SEMI=82;
+	public static final int SEMPRED=83;
+	public static final int SL_COMMENT=84;
+	public static final int SRC=85;
+	public static final int STAR=86;
+	public static final int STRAY_BRACKET=87;
+	public static final int STRING_LITERAL=88;
+	public static final int SYNPRED=89;
+	public static final int SYN_SEMPRED=90;
+	public static final int TEMPLATE=91;
+	public static final int THROWS=92;
+	public static final int TOKENS=93;
+	public static final int TOKEN_REF=94;
+	public static final int TREE=95;
+	public static final int TREE_BEGIN=96;
+	public static final int TREE_GRAMMAR=97;
+	public static final int WILDCARD=98;
+	public static final int WS=99;
+	public static final int WS_LOOP=100;
+	public static final int WS_OPT=101;
+	public static final int XDIGIT=102;
+
+	public boolean hasASTOperator = false;
+	private String fileName;
+
+	public String getFileName() {
+	    return fileName;
+	}
+
+	public void setFileName(String value) {
+	    fileName = value;
+	}
+
+	@Override
+	public Token nextToken() {
+		Token token = super.nextToken();
+		while (token.getType() == STRAY_BRACKET) {
+			ErrorManager.syntaxError(
+				ErrorManager.MSG_SYNTAX_ERROR,
+				null,
+				token,
+				"antlr: dangling ']'? make sure to escape with \\]",
+				null);
+
+			// skip this token
+			token = super.nextToken();
+		}
+
+		return token;
+	}
+
+
+	// delegates
+	// delegators
+	public Lexer[] getDelegates() {
+		return new Lexer[] {};
+	}
+
+	public ANTLRLexer() {} 
+	public ANTLRLexer(CharStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public ANTLRLexer(CharStream input, RecognizerSharedState state) {
+		super(input,state);
+	}
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/ANTLR.g"; }
+
+	// $ANTLR start "CATCH"
+	public final void mCATCH() throws RecognitionException {
+		try {
+			int _type = CATCH;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:43:7: ( 'catch' )
+			// org/antlr/grammar/v3/ANTLR.g:43:9: 'catch'
+			{
+			match("catch"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "CATCH"
+
+	// $ANTLR start "FINALLY"
+	public final void mFINALLY() throws RecognitionException {
+		try {
+			int _type = FINALLY;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:44:9: ( 'finally' )
+			// org/antlr/grammar/v3/ANTLR.g:44:11: 'finally'
+			{
+			match("finally"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "FINALLY"
+
+	// $ANTLR start "FRAGMENT"
+	public final void mFRAGMENT() throws RecognitionException {
+		try {
+			int _type = FRAGMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:45:10: ( 'fragment' )
+			// org/antlr/grammar/v3/ANTLR.g:45:12: 'fragment'
+			{
+			match("fragment"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "FRAGMENT"
+
+	// $ANTLR start "GRAMMAR"
+	public final void mGRAMMAR() throws RecognitionException {
+		try {
+			int _type = GRAMMAR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:46:9: ( 'grammar' )
+			// org/antlr/grammar/v3/ANTLR.g:46:11: 'grammar'
+			{
+			match("grammar"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "GRAMMAR"
+
+	// $ANTLR start "IMPORT"
+	public final void mIMPORT() throws RecognitionException {
+		try {
+			int _type = IMPORT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:47:8: ( 'import' )
+			// org/antlr/grammar/v3/ANTLR.g:47:10: 'import'
+			{
+			match("import"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "IMPORT"
+
+	// $ANTLR start "LEXER"
+	public final void mLEXER() throws RecognitionException {
+		try {
+			int _type = LEXER;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:48:7: ( 'lexer' )
+			// org/antlr/grammar/v3/ANTLR.g:48:9: 'lexer'
+			{
+			match("lexer"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "LEXER"
+
+	// $ANTLR start "PARSER"
+	public final void mPARSER() throws RecognitionException {
+		try {
+			int _type = PARSER;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:49:8: ( 'parser' )
+			// org/antlr/grammar/v3/ANTLR.g:49:10: 'parser'
+			{
+			match("parser"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "PARSER"
+
+	// $ANTLR start "PRIVATE"
+	public final void mPRIVATE() throws RecognitionException {
+		try {
+			int _type = PRIVATE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:50:9: ( 'private' )
+			// org/antlr/grammar/v3/ANTLR.g:50:11: 'private'
+			{
+			match("private"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "PRIVATE"
+
+	// $ANTLR start "PROTECTED"
+	public final void mPROTECTED() throws RecognitionException {
+		try {
+			int _type = PROTECTED;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:51:11: ( 'protected' )
+			// org/antlr/grammar/v3/ANTLR.g:51:13: 'protected'
+			{
+			match("protected"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "PROTECTED"
+
+	// $ANTLR start "PUBLIC"
+	public final void mPUBLIC() throws RecognitionException {
+		try {
+			int _type = PUBLIC;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:52:8: ( 'public' )
+			// org/antlr/grammar/v3/ANTLR.g:52:10: 'public'
+			{
+			match("public"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "PUBLIC"
+
+	// $ANTLR start "RETURNS"
+	public final void mRETURNS() throws RecognitionException {
+		try {
+			int _type = RETURNS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:53:9: ( 'returns' )
+			// org/antlr/grammar/v3/ANTLR.g:53:11: 'returns'
+			{
+			match("returns"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "RETURNS"
+
+	// $ANTLR start "SCOPE"
+	public final void mSCOPE() throws RecognitionException {
+		try {
+			int _type = SCOPE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:54:7: ( 'scope' )
+			// org/antlr/grammar/v3/ANTLR.g:54:9: 'scope'
+			{
+			match("scope"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SCOPE"
+
+	// $ANTLR start "THROWS"
+	public final void mTHROWS() throws RecognitionException {
+		try {
+			int _type = THROWS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:55:8: ( 'throws' )
+			// org/antlr/grammar/v3/ANTLR.g:55:10: 'throws'
+			{
+			match("throws"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "THROWS"
+
+	// $ANTLR start "TREE"
+	public final void mTREE() throws RecognitionException {
+		try {
+			int _type = TREE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:56:6: ( 'tree' )
+			// org/antlr/grammar/v3/ANTLR.g:56:8: 'tree'
+			{
+			match("tree"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TREE"
+
+	// $ANTLR start "STRING_LITERAL"
+	public final void mSTRING_LITERAL() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1075:25: ()
+			// org/antlr/grammar/v3/ANTLR.g:1075:27: 
+			{
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "STRING_LITERAL"
+
+	// $ANTLR start "FORCED_ACTION"
+	public final void mFORCED_ACTION() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1076:24: ()
+			// org/antlr/grammar/v3/ANTLR.g:1076:26: 
+			{
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "FORCED_ACTION"
+
+	// $ANTLR start "DOC_COMMENT"
+	public final void mDOC_COMMENT() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1077:22: ()
+			// org/antlr/grammar/v3/ANTLR.g:1077:24: 
+			{
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "DOC_COMMENT"
+
+	// $ANTLR start "SEMPRED"
+	public final void mSEMPRED() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1078:18: ()
+			// org/antlr/grammar/v3/ANTLR.g:1078:20: 
+			{
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SEMPRED"
+
+	// $ANTLR start "WS"
+	public final void mWS() throws RecognitionException {
+		try {
+			int _type = WS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1081:2: ( ( ' ' | '\\t' | ( '\\r' )? '\\n' ) )
+			// org/antlr/grammar/v3/ANTLR.g:1081:4: ( ' ' | '\\t' | ( '\\r' )? '\\n' )
+			{
+			// org/antlr/grammar/v3/ANTLR.g:1081:4: ( ' ' | '\\t' | ( '\\r' )? '\\n' )
+			int alt2=3;
+			switch ( input.LA(1) ) {
+			case ' ':
+				{
+				alt2=1;
+				}
+				break;
+			case '\t':
+				{
+				alt2=2;
+				}
+				break;
+			case '\n':
+			case '\r':
+				{
+				alt2=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 2, 0, input);
+				throw nvae;
+			}
+			switch (alt2) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1081:6: ' '
+					{
+					match(' '); if (state.failed) return;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1082:5: '\\t'
+					{
+					match('\t'); if (state.failed) return;
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:1083:5: ( '\\r' )? '\\n'
+					{
+					// org/antlr/grammar/v3/ANTLR.g:1083:5: ( '\\r' )?
+					int alt1=2;
+					int LA1_0 = input.LA(1);
+					if ( (LA1_0=='\r') ) {
+						alt1=1;
+					}
+					switch (alt1) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:1083:6: '\\r'
+							{
+							match('\r'); if (state.failed) return;
+							}
+							break;
+
+					}
+
+					match('\n'); if (state.failed) return;
+					}
+					break;
+
+			}
+
+			if ( state.backtracking==0 ) { _channel = HIDDEN; }
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "WS"
+
+	// $ANTLR start "COMMENT"
+	public final void mCOMMENT() throws RecognitionException {
+		try {
+			int _type = COMMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			List<Integer> type = new ArrayList<Integer>() {{ add(0); }};
+			// org/antlr/grammar/v3/ANTLR.g:1090:2: ( ( SL_COMMENT | ML_COMMENT[type] ) )
+			// org/antlr/grammar/v3/ANTLR.g:1090:4: ( SL_COMMENT | ML_COMMENT[type] )
+			{
+			// org/antlr/grammar/v3/ANTLR.g:1090:4: ( SL_COMMENT | ML_COMMENT[type] )
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+			if ( (LA3_0=='/') ) {
+				int LA3_1 = input.LA(2);
+				if ( (LA3_1=='/') ) {
+					alt3=1;
+				}
+				else if ( (LA3_1=='*') ) {
+					alt3=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 3, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 3, 0, input);
+				throw nvae;
+			}
+
+			switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1090:6: SL_COMMENT
+					{
+					mSL_COMMENT(); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1090:19: ML_COMMENT[type]
+					{
+					mML_COMMENT(type); if (state.failed) return;
+
+					if ( state.backtracking==0 ) {_type = type.get(0);}
+					}
+					break;
+
+			}
+
+			if ( state.backtracking==0 ) {
+						if ( _type != DOC_COMMENT )
+							_channel = HIDDEN;
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "COMMENT"
+
+	// $ANTLR start "SL_COMMENT"
+	public final void mSL_COMMENT() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1100:2: ( '//' ( ( ' $ANTLR' )=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? ) )
+			// org/antlr/grammar/v3/ANTLR.g:1100:4: '//' ( ( ' $ANTLR' )=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )
+			{
+			match("//"); if (state.failed) return;
+
+			// org/antlr/grammar/v3/ANTLR.g:1101:3: ( ( ' $ANTLR' )=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )
+			int alt9=2;
+			alt9 = dfa9.predict(input);
+			switch (alt9) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1101:5: ( ' $ANTLR' )=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )?
+					{
+					match(" $ANTLR "); if (state.failed) return;
+
+					mSRC(); if (state.failed) return;
+
+					// org/antlr/grammar/v3/ANTLR.g:1101:35: ( ( '\\r' )? '\\n' )?
+					int alt5=2;
+					int LA5_0 = input.LA(1);
+					if ( (LA5_0=='\n'||LA5_0=='\r') ) {
+						alt5=1;
+					}
+					switch (alt5) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:1101:36: ( '\\r' )? '\\n'
+							{
+							// org/antlr/grammar/v3/ANTLR.g:1101:36: ( '\\r' )?
+							int alt4=2;
+							int LA4_0 = input.LA(1);
+							if ( (LA4_0=='\r') ) {
+								alt4=1;
+							}
+							switch (alt4) {
+								case 1 :
+									// org/antlr/grammar/v3/ANTLR.g:1101:37: '\\r'
+									{
+									match('\r'); if (state.failed) return;
+									}
+									break;
+
+							}
+
+							match('\n'); if (state.failed) return;
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1102:5: (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )?
+					{
+					// org/antlr/grammar/v3/ANTLR.g:1102:5: (~ ( '\\r' | '\\n' ) )*
+					loop6:
+					while (true) {
+						int alt6=2;
+						int LA6_0 = input.LA(1);
+						if ( ((LA6_0 >= '\u0000' && LA6_0 <= '\t')||(LA6_0 >= '\u000B' && LA6_0 <= '\f')||(LA6_0 >= '\u000E' && LA6_0 <= '\uFFFF')) ) {
+							alt6=1;
+						}
+
+						switch (alt6) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:
+							{
+							if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '\t')||(input.LA(1) >= '\u000B' && input.LA(1) <= '\f')||(input.LA(1) >= '\u000E' && input.LA(1) <= '\uFFFF') ) {
+								input.consume();
+								state.failed=false;
+							}
+							else {
+								if (state.backtracking>0) {state.failed=true; return;}
+								MismatchedSetException mse = new MismatchedSetException(null,input);
+								recover(mse);
+								throw mse;
+							}
+							}
+							break;
+
+						default :
+							break loop6;
+						}
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:1102:19: ( ( '\\r' )? '\\n' )?
+					int alt8=2;
+					int LA8_0 = input.LA(1);
+					if ( (LA8_0=='\n'||LA8_0=='\r') ) {
+						alt8=1;
+					}
+					switch (alt8) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:1102:20: ( '\\r' )? '\\n'
+							{
+							// org/antlr/grammar/v3/ANTLR.g:1102:20: ( '\\r' )?
+							int alt7=2;
+							int LA7_0 = input.LA(1);
+							if ( (LA7_0=='\r') ) {
+								alt7=1;
+							}
+							switch (alt7) {
+								case 1 :
+									// org/antlr/grammar/v3/ANTLR.g:1102:21: '\\r'
+									{
+									match('\r'); if (state.failed) return;
+									}
+									break;
+
+							}
+
+							match('\n'); if (state.failed) return;
+							}
+							break;
+
+					}
+
+					}
+					break;
+
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SL_COMMENT"
+
+	// $ANTLR start "ML_COMMENT"
+	public final void mML_COMMENT(List<Integer> type) throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1108:2: ( '/*' ( . )* '*/' )
+			// org/antlr/grammar/v3/ANTLR.g:1108:4: '/*' ( . )* '*/'
+			{
+			match("/*"); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {type.set(0, (input.LA(1) == '*' && input.LA(2) != '/') ? DOC_COMMENT : ML_COMMENT);}
+			// org/antlr/grammar/v3/ANTLR.g:1110:3: ( . )*
+			loop10:
+			while (true) {
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+				if ( (LA10_0=='*') ) {
+					int LA10_1 = input.LA(2);
+					if ( (LA10_1=='/') ) {
+						alt10=2;
+					}
+					else if ( ((LA10_1 >= '\u0000' && LA10_1 <= '.')||(LA10_1 >= '0' && LA10_1 <= '\uFFFF')) ) {
+						alt10=1;
+					}
+
+				}
+				else if ( ((LA10_0 >= '\u0000' && LA10_0 <= ')')||(LA10_0 >= '+' && LA10_0 <= '\uFFFF')) ) {
+					alt10=1;
+				}
+
+				switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1110:3: .
+					{
+					matchAny(); if (state.failed) return;
+					}
+					break;
+
+				default :
+					break loop10;
+				}
+			}
+
+			match("*/"); if (state.failed) return;
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ML_COMMENT"
+
+	// $ANTLR start "OPEN_ELEMENT_OPTION"
+	public final void mOPEN_ELEMENT_OPTION() throws RecognitionException {
+		try {
+			int _type = OPEN_ELEMENT_OPTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1114:2: ( '<' )
+			// org/antlr/grammar/v3/ANTLR.g:1114:4: '<'
+			{
+			match('<'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "OPEN_ELEMENT_OPTION"
+
+	// $ANTLR start "CLOSE_ELEMENT_OPTION"
+	public final void mCLOSE_ELEMENT_OPTION() throws RecognitionException {
+		try {
+			int _type = CLOSE_ELEMENT_OPTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1118:2: ( '>' )
+			// org/antlr/grammar/v3/ANTLR.g:1118:4: '>'
+			{
+			match('>'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "CLOSE_ELEMENT_OPTION"
+
+	// $ANTLR start "AMPERSAND"
+	public final void mAMPERSAND() throws RecognitionException {
+		try {
+			int _type = AMPERSAND;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1121:11: ( '@' )
+			// org/antlr/grammar/v3/ANTLR.g:1121:13: '@'
+			{
+			match('@'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "AMPERSAND"
+
+	// $ANTLR start "COMMA"
+	public final void mCOMMA() throws RecognitionException {
+		try {
+			int _type = COMMA;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1123:7: ( ',' )
+			// org/antlr/grammar/v3/ANTLR.g:1123:9: ','
+			{
+			match(','); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "COMMA"
+
+	// $ANTLR start "QUESTION"
+	public final void mQUESTION() throws RecognitionException {
+		try {
+			int _type = QUESTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1125:10: ( '?' )
+			// org/antlr/grammar/v3/ANTLR.g:1125:12: '?'
+			{
+			match('?'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "QUESTION"
+
+	// $ANTLR start "TREE_BEGIN"
+	public final void mTREE_BEGIN() throws RecognitionException {
+		try {
+			int _type = TREE_BEGIN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1127:12: ( '^(' )
+			// org/antlr/grammar/v3/ANTLR.g:1127:14: '^('
+			{
+			match("^("); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TREE_BEGIN"
+
+	// $ANTLR start "LPAREN"
+	public final void mLPAREN() throws RecognitionException {
+		try {
+			int _type = LPAREN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1129:7: ( '(' )
+			// org/antlr/grammar/v3/ANTLR.g:1129:9: '('
+			{
+			match('('); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "LPAREN"
+
+	// $ANTLR start "RPAREN"
+	public final void mRPAREN() throws RecognitionException {
+		try {
+			int _type = RPAREN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1131:7: ( ')' )
+			// org/antlr/grammar/v3/ANTLR.g:1131:9: ')'
+			{
+			match(')'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "RPAREN"
+
+	// $ANTLR start "COLON"
+	public final void mCOLON() throws RecognitionException {
+		try {
+			int _type = COLON;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1133:7: ( ':' )
+			// org/antlr/grammar/v3/ANTLR.g:1133:9: ':'
+			{
+			match(':'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "COLON"
+
+	// $ANTLR start "STAR"
+	public final void mSTAR() throws RecognitionException {
+		try {
+			int _type = STAR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1135:5: ( '*' )
+			// org/antlr/grammar/v3/ANTLR.g:1135:7: '*'
+			{
+			match('*'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "STAR"
+
+	// $ANTLR start "PLUS"
+	public final void mPLUS() throws RecognitionException {
+		try {
+			int _type = PLUS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1137:5: ( '+' )
+			// org/antlr/grammar/v3/ANTLR.g:1137:7: '+'
+			{
+			match('+'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "PLUS"
+
+	// $ANTLR start "ASSIGN"
+	public final void mASSIGN() throws RecognitionException {
+		try {
+			int _type = ASSIGN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1139:8: ( '=' )
+			// org/antlr/grammar/v3/ANTLR.g:1139:10: '='
+			{
+			match('='); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ASSIGN"
+
+	// $ANTLR start "PLUS_ASSIGN"
+	public final void mPLUS_ASSIGN() throws RecognitionException {
+		try {
+			int _type = PLUS_ASSIGN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1141:13: ( '+=' )
+			// org/antlr/grammar/v3/ANTLR.g:1141:15: '+='
+			{
+			match("+="); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "PLUS_ASSIGN"
+
+	// $ANTLR start "IMPLIES"
+	public final void mIMPLIES() throws RecognitionException {
+		try {
+			int _type = IMPLIES;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1143:9: ( '=>' )
+			// org/antlr/grammar/v3/ANTLR.g:1143:11: '=>'
+			{
+			match("=>"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "IMPLIES"
+
+	// $ANTLR start "REWRITE"
+	public final void mREWRITE() throws RecognitionException {
+		try {
+			int _type = REWRITE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1145:9: ( '->' )
+			// org/antlr/grammar/v3/ANTLR.g:1145:11: '->'
+			{
+			match("->"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "REWRITE"
+
+	// $ANTLR start "SEMI"
+	public final void mSEMI() throws RecognitionException {
+		try {
+			int _type = SEMI;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1147:5: ( ';' )
+			// org/antlr/grammar/v3/ANTLR.g:1147:7: ';'
+			{
+			match(';'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SEMI"
+
+	// $ANTLR start "ROOT"
+	public final void mROOT() throws RecognitionException {
+		try {
+			int _type = ROOT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1149:6: ( '^' )
+			// org/antlr/grammar/v3/ANTLR.g:1149:8: '^'
+			{
+			match('^'); if (state.failed) return;
+			if ( state.backtracking==0 ) {hasASTOperator=true;}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ROOT"
+
+	// $ANTLR start "BANG"
+	public final void mBANG() throws RecognitionException {
+		try {
+			int _type = BANG;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1151:6: ( '!' )
+			// org/antlr/grammar/v3/ANTLR.g:1151:8: '!'
+			{
+			match('!'); if (state.failed) return;
+			if ( state.backtracking==0 ) {hasASTOperator=true;}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "BANG"
+
+	// $ANTLR start "OR"
+	public final void mOR() throws RecognitionException {
+		try {
+			int _type = OR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1153:4: ( '|' )
+			// org/antlr/grammar/v3/ANTLR.g:1153:6: '|'
+			{
+			match('|'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "OR"
+
+	// $ANTLR start "WILDCARD"
+	public final void mWILDCARD() throws RecognitionException {
+		try {
+			int _type = WILDCARD;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1155:10: ( '.' )
+			// org/antlr/grammar/v3/ANTLR.g:1155:12: '.'
+			{
+			match('.'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "WILDCARD"
+
+	// $ANTLR start "ETC"
+	public final void mETC() throws RecognitionException {
+		try {
+			int _type = ETC;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1157:5: ( '...' )
+			// org/antlr/grammar/v3/ANTLR.g:1157:7: '...'
+			{
+			match("..."); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ETC"
+
+	// $ANTLR start "RANGE"
+	public final void mRANGE() throws RecognitionException {
+		try {
+			int _type = RANGE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1159:7: ( '..' )
+			// org/antlr/grammar/v3/ANTLR.g:1159:9: '..'
+			{
+			match(".."); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "RANGE"
+
+	// $ANTLR start "NOT"
+	public final void mNOT() throws RecognitionException {
+		try {
+			int _type = NOT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1161:5: ( '~' )
+			// org/antlr/grammar/v3/ANTLR.g:1161:7: '~'
+			{
+			match('~'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "NOT"
+
+	// $ANTLR start "RCURLY"
+	public final void mRCURLY() throws RecognitionException {
+		try {
+			int _type = RCURLY;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1163:7: ( '}' )
+			// org/antlr/grammar/v3/ANTLR.g:1163:9: '}'
+			{
+			match('}'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "RCURLY"
+
+	// $ANTLR start "DOLLAR"
+	public final void mDOLLAR() throws RecognitionException {
+		try {
+			int _type = DOLLAR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1165:8: ( '$' )
+			// org/antlr/grammar/v3/ANTLR.g:1165:10: '$'
+			{
+			match('$'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "DOLLAR"
+
+	// $ANTLR start "STRAY_BRACKET"
+	public final void mSTRAY_BRACKET() throws RecognitionException {
+		try {
+			int _type = STRAY_BRACKET;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1168:2: ( ']' )
+			// org/antlr/grammar/v3/ANTLR.g:1168:4: ']'
+			{
+			match(']'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "STRAY_BRACKET"
+
+	// $ANTLR start "CHAR_LITERAL"
+	public final void mCHAR_LITERAL() throws RecognitionException {
+		try {
+			int _type = CHAR_LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1172:2: ( '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
+			// org/antlr/grammar/v3/ANTLR.g:1172:4: '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\''
+			{
+			match('\''); if (state.failed) return;
+			// org/antlr/grammar/v3/ANTLR.g:1173:3: ( ESC |~ ( '\\\\' | '\\'' ) )*
+			loop11:
+			while (true) {
+				int alt11=3;
+				int LA11_0 = input.LA(1);
+				if ( (LA11_0=='\\') ) {
+					alt11=1;
+				}
+				else if ( ((LA11_0 >= '\u0000' && LA11_0 <= '&')||(LA11_0 >= '(' && LA11_0 <= '[')||(LA11_0 >= ']' && LA11_0 <= '\uFFFF')) ) {
+					alt11=2;
+				}
+
+				switch (alt11) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1173:5: ESC
+					{
+					mESC(); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1174:5: ~ ( '\\\\' | '\\'' )
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '&')||(input.LA(1) >= '(' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop11;
+				}
+			}
+
+			match('\''); if (state.failed) return;
+			if ( state.backtracking==0 ) {
+						StringBuffer s = Grammar.getUnescapedStringFromGrammarStringLiteral(getText());
+						if ( s.length() > 1 )
+						{
+							_type = STRING_LITERAL;
+						}
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "CHAR_LITERAL"
+
+	// $ANTLR start "DOUBLE_QUOTE_STRING_LITERAL"
+	public final void mDOUBLE_QUOTE_STRING_LITERAL() throws RecognitionException {
+		try {
+			int _type = DOUBLE_QUOTE_STRING_LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			int c;
+
+
+				StringBuilder builder = new StringBuilder();
+
+			// org/antlr/grammar/v3/ANTLR.g:1191:2: ( '\"' ( ( '\\\\\\\"' )=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"' )
+			// org/antlr/grammar/v3/ANTLR.g:1191:4: '\"' ( ( '\\\\\\\"' )=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"'
+			{
+			match('\"'); if (state.failed) return;
+			if ( state.backtracking==0 ) {builder.append('"');}
+			// org/antlr/grammar/v3/ANTLR.g:1192:3: ( ( '\\\\\\\"' )=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )*
+			loop12:
+			while (true) {
+				int alt12=4;
+				int LA12_0 = input.LA(1);
+				if ( (LA12_0=='\\') ) {
+					int LA12_2 = input.LA(2);
+					if ( (LA12_2=='\"') && (synpred2_ANTLR())) {
+						alt12=1;
+					}
+					else if ( ((LA12_2 >= '\u0000' && LA12_2 <= '!')||(LA12_2 >= '#' && LA12_2 <= '\uFFFF')) ) {
+						alt12=2;
+					}
+
+				}
+				else if ( ((LA12_0 >= '\u0000' && LA12_0 <= '!')||(LA12_0 >= '#' && LA12_0 <= '[')||(LA12_0 >= ']' && LA12_0 <= '\uFFFF')) ) {
+					alt12=3;
+				}
+
+				switch (alt12) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1192:5: ( '\\\\\\\"' )=> '\\\\' '\"'
+					{
+					match('\\'); if (state.failed) return;
+					match('\"'); if (state.failed) return;
+					if ( state.backtracking==0 ) {builder.append('"');}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1193:5: '\\\\' c=~ '\"'
+					{
+					match('\\'); if (state.failed) return;
+					c= input.LA(1);
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					if ( state.backtracking==0 ) {builder.append("\\" + (char)c);}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:1194:5: c=~ ( '\\\\' | '\"' )
+					{
+					c= input.LA(1);
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					if ( state.backtracking==0 ) {builder.append((char)c);}
+					}
+					break;
+
+				default :
+					break loop12;
+				}
+			}
+
+			match('\"'); if (state.failed) return;
+			if ( state.backtracking==0 ) {builder.append('"');}
+			if ( state.backtracking==0 ) {
+						setText(builder.toString());
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "DOUBLE_QUOTE_STRING_LITERAL"
+
+	// $ANTLR start "DOUBLE_ANGLE_STRING_LITERAL"
+	public final void mDOUBLE_ANGLE_STRING_LITERAL() throws RecognitionException {
+		try {
+			int _type = DOUBLE_ANGLE_STRING_LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1203:2: ( '<<' ( . )* '>>' )
+			// org/antlr/grammar/v3/ANTLR.g:1203:4: '<<' ( . )* '>>'
+			{
+			match("<<"); if (state.failed) return;
+
+			// org/antlr/grammar/v3/ANTLR.g:1203:9: ( . )*
+			loop13:
+			while (true) {
+				int alt13=2;
+				int LA13_0 = input.LA(1);
+				if ( (LA13_0=='>') ) {
+					int LA13_1 = input.LA(2);
+					if ( (LA13_1=='>') ) {
+						alt13=2;
+					}
+					else if ( ((LA13_1 >= '\u0000' && LA13_1 <= '=')||(LA13_1 >= '?' && LA13_1 <= '\uFFFF')) ) {
+						alt13=1;
+					}
+
+				}
+				else if ( ((LA13_0 >= '\u0000' && LA13_0 <= '=')||(LA13_0 >= '?' && LA13_0 <= '\uFFFF')) ) {
+					alt13=1;
+				}
+
+				switch (alt13) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1203:9: .
+					{
+					matchAny(); if (state.failed) return;
+					}
+					break;
+
+				default :
+					break loop13;
+				}
+			}
+
+			match(">>"); if (state.failed) return;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "DOUBLE_ANGLE_STRING_LITERAL"
+
+	// $ANTLR start "ESC"
+	public final void mESC() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1209:2: ( '\\\\' ( . ) )
+			// org/antlr/grammar/v3/ANTLR.g:1209:4: '\\\\' ( . )
+			{
+			match('\\'); if (state.failed) return;
+			// org/antlr/grammar/v3/ANTLR.g:1210:3: ( . )
+			// org/antlr/grammar/v3/ANTLR.g:1221:7: .
+			{
+			matchAny(); if (state.failed) return;
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ESC"
+
+	// $ANTLR start "DIGIT"
+	public final void mDIGIT() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1227:2: ( '0' .. '9' )
+			// org/antlr/grammar/v3/ANTLR.g:
+			{
+			if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
+				input.consume();
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				recover(mse);
+				throw mse;
+			}
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "DIGIT"
+
+	// $ANTLR start "XDIGIT"
+	public final void mXDIGIT() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1232:2: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
+			// org/antlr/grammar/v3/ANTLR.g:
+			{
+			if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'F')||(input.LA(1) >= 'a' && input.LA(1) <= 'f') ) {
+				input.consume();
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				recover(mse);
+				throw mse;
+			}
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "XDIGIT"
+
+	// $ANTLR start "INT"
+	public final void mINT() throws RecognitionException {
+		try {
+			int _type = INT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1237:2: ( ( '0' .. '9' )+ )
+			// org/antlr/grammar/v3/ANTLR.g:1237:4: ( '0' .. '9' )+
+			{
+			// org/antlr/grammar/v3/ANTLR.g:1237:4: ( '0' .. '9' )+
+			int cnt14=0;
+			loop14:
+			while (true) {
+				int alt14=2;
+				int LA14_0 = input.LA(1);
+				if ( ((LA14_0 >= '0' && LA14_0 <= '9')) ) {
+					alt14=1;
+				}
+
+				switch (alt14) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:
+					{
+					if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					if ( cnt14 >= 1 ) break loop14;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(14, input);
+					throw eee;
+				}
+				cnt14++;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "INT"
+
+	// $ANTLR start "ARG_ACTION"
+	public final void mARG_ACTION() throws RecognitionException {
+		try {
+			int _type = ARG_ACTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+
+				List<String> text = new ArrayList<String>() {{ add(null); }};
+
+			// org/antlr/grammar/v3/ANTLR.g:1244:2: ( '[' NESTED_ARG_ACTION[text] ']' )
+			// org/antlr/grammar/v3/ANTLR.g:1244:4: '[' NESTED_ARG_ACTION[text] ']'
+			{
+			match('['); if (state.failed) return;
+			mNESTED_ARG_ACTION(text); if (state.failed) return;
+
+			match(']'); if (state.failed) return;
+			if ( state.backtracking==0 ) {setText(text.get(0));}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ARG_ACTION"
+
+	// $ANTLR start "NESTED_ARG_ACTION"
+	public final void mNESTED_ARG_ACTION(List<String> text) throws RecognitionException {
+		try {
+			CommonToken ACTION_STRING_LITERAL1=null;
+			CommonToken ACTION_CHAR_LITERAL2=null;
+			int c;
+
+
+				text.set(0, "");
+				StringBuilder builder = new StringBuilder();
+
+			// org/antlr/grammar/v3/ANTLR.g:1257:2: ( ( ( '\\\\]' )=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )* )
+			// org/antlr/grammar/v3/ANTLR.g:1257:4: ( ( '\\\\]' )=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
+			{
+			// org/antlr/grammar/v3/ANTLR.g:1257:4: ( ( '\\\\]' )=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
+			loop15:
+			while (true) {
+				int alt15=6;
+				int LA15_0 = input.LA(1);
+				if ( (LA15_0=='\\') ) {
+					int LA15_2 = input.LA(2);
+					if ( (LA15_2==']') && (synpred3_ANTLR())) {
+						alt15=1;
+					}
+					else if ( ((LA15_2 >= '\u0000' && LA15_2 <= '\\')||(LA15_2 >= '^' && LA15_2 <= '\uFFFF')) ) {
+						alt15=2;
+					}
+
+				}
+				else if ( (LA15_0=='\"') ) {
+					alt15=3;
+				}
+				else if ( (LA15_0=='\'') ) {
+					alt15=4;
+				}
+				else if ( ((LA15_0 >= '\u0000' && LA15_0 <= '!')||(LA15_0 >= '#' && LA15_0 <= '&')||(LA15_0 >= '(' && LA15_0 <= '[')||(LA15_0 >= '^' && LA15_0 <= '\uFFFF')) ) {
+					alt15=5;
+				}
+
+				switch (alt15) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1257:6: ( '\\\\]' )=> '\\\\' ']'
+					{
+					match('\\'); if (state.failed) return;
+					match(']'); if (state.failed) return;
+					if ( state.backtracking==0 ) {builder.append("]");}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1258:5: '\\\\' c=~ ( ']' )
+					{
+					match('\\'); if (state.failed) return;
+					c= input.LA(1);
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '\\')||(input.LA(1) >= '^' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					if ( state.backtracking==0 ) {builder.append("\\" + (char)c);}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:1259:5: ACTION_STRING_LITERAL
+					{
+					int ACTION_STRING_LITERAL1Start859 = getCharIndex();
+					int ACTION_STRING_LITERAL1StartLine859 = getLine();
+					int ACTION_STRING_LITERAL1StartCharPos859 = getCharPositionInLine();
+					mACTION_STRING_LITERAL(); if (state.failed) return;
+					ACTION_STRING_LITERAL1 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, ACTION_STRING_LITERAL1Start859, getCharIndex()-1);
+					ACTION_STRING_LITERAL1.setLine(ACTION_STRING_LITERAL1StartLine859);
+					ACTION_STRING_LITERAL1.setCharPositionInLine(ACTION_STRING_LITERAL1StartCharPos859);
+
+					if ( state.backtracking==0 ) {builder.append((ACTION_STRING_LITERAL1!=null?ACTION_STRING_LITERAL1.getText():null));}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:1260:5: ACTION_CHAR_LITERAL
+					{
+					int ACTION_CHAR_LITERAL2Start867 = getCharIndex();
+					int ACTION_CHAR_LITERAL2StartLine867 = getLine();
+					int ACTION_CHAR_LITERAL2StartCharPos867 = getCharPositionInLine();
+					mACTION_CHAR_LITERAL(); if (state.failed) return;
+					ACTION_CHAR_LITERAL2 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, ACTION_CHAR_LITERAL2Start867, getCharIndex()-1);
+					ACTION_CHAR_LITERAL2.setLine(ACTION_CHAR_LITERAL2StartLine867);
+					ACTION_CHAR_LITERAL2.setCharPositionInLine(ACTION_CHAR_LITERAL2StartCharPos867);
+
+					if ( state.backtracking==0 ) {builder.append((ACTION_CHAR_LITERAL2!=null?ACTION_CHAR_LITERAL2.getText():null));}
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLR.g:1261:5: c=~ ( '\\\\' | '\"' | '\\'' | ']' )
+					{
+					c= input.LA(1);
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '&')||(input.LA(1) >= '(' && input.LA(1) <= '[')||(input.LA(1) >= '^' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					if ( state.backtracking==0 ) {builder.append((char)c);}
+					}
+					break;
+
+				default :
+					break loop15;
+				}
+			}
+
+			if ( state.backtracking==0 ) {
+						text.set(0, builder.toString());
+					}
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "NESTED_ARG_ACTION"
+
+	// $ANTLR start "ACTION"
+	public final void mACTION() throws RecognitionException {
+		try {
+			int _type = ACTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+
+				int actionLine = getLine();
+				int actionColumn = getCharPositionInLine();
+
+			// org/antlr/grammar/v3/ANTLR.g:1273:2: ( NESTED_ACTION ( '?' )? )
+			// org/antlr/grammar/v3/ANTLR.g:1273:4: NESTED_ACTION ( '?' )?
+			{
+			mNESTED_ACTION(); if (state.failed) return;
+
+			// org/antlr/grammar/v3/ANTLR.g:1274:3: ( '?' )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+			if ( (LA16_0=='?') ) {
+				alt16=1;
+			}
+			switch (alt16) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1274:4: '?'
+					{
+					match('?'); if (state.failed) return;
+					if ( state.backtracking==0 ) {_type = SEMPRED;}
+					}
+					break;
+
+			}
+
+			if ( state.backtracking==0 ) {
+						String action = getText();
+						int n = 1; // num delimiter chars
+						if ( action.startsWith("{{") && action.endsWith("}}") )
+						{
+							_type = FORCED_ACTION;
+							n = 2;
+						}
+						action = action.substring(n,action.length()-n - (_type==SEMPRED ? 1 : 0));
+						setText(action);
+					}
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ACTION"
+
+	// $ANTLR start "NESTED_ACTION"
+	public final void mNESTED_ACTION() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1291:2: ( '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL | ( '//' | '/*' )=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}' )
+			// org/antlr/grammar/v3/ANTLR.g:1291:4: '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL | ( '//' | '/*' )=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}'
+			{
+			match('{'); if (state.failed) return;
+			// org/antlr/grammar/v3/ANTLR.g:1292:3: ( NESTED_ACTION | ACTION_CHAR_LITERAL | ( '//' | '/*' )=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )*
+			loop17:
+			while (true) {
+				int alt17=7;
+				int LA17_0 = input.LA(1);
+				if ( (LA17_0=='{') ) {
+					alt17=1;
+				}
+				else if ( (LA17_0=='\'') ) {
+					alt17=2;
+				}
+				else if ( (LA17_0=='/') ) {
+					int LA17_4 = input.LA(2);
+					if ( (synpred4_ANTLR()) ) {
+						alt17=3;
+					}
+					else if ( (true) ) {
+						alt17=6;
+					}
+
+				}
+				else if ( (LA17_0=='\"') ) {
+					alt17=4;
+				}
+				else if ( (LA17_0=='\\') ) {
+					alt17=5;
+				}
+				else if ( ((LA17_0 >= '\u0000' && LA17_0 <= '!')||(LA17_0 >= '#' && LA17_0 <= '&')||(LA17_0 >= '(' && LA17_0 <= '.')||(LA17_0 >= '0' && LA17_0 <= '[')||(LA17_0 >= ']' && LA17_0 <= 'z')||LA17_0=='|'||(LA17_0 >= '~' && LA17_0 <= '\uFFFF')) ) {
+					alt17=6;
+				}
+
+				switch (alt17) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1292:5: NESTED_ACTION
+					{
+					mNESTED_ACTION(); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1293:5: ACTION_CHAR_LITERAL
+					{
+					mACTION_CHAR_LITERAL(); if (state.failed) return;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:1294:5: ( '//' | '/*' )=> COMMENT
+					{
+					mCOMMENT(); if (state.failed) return;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:1295:5: ACTION_STRING_LITERAL
+					{
+					mACTION_STRING_LITERAL(); if (state.failed) return;
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLR.g:1296:5: ACTION_ESC
+					{
+					mACTION_ESC(); if (state.failed) return;
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLR.g:1297:5: ~ ( '{' | '\\'' | '\"' | '\\\\' | '}' )
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '&')||(input.LA(1) >= '(' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= 'z')||input.LA(1)=='|'||(input.LA(1) >= '~' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop17;
+				}
+			}
+
+			match('}'); if (state.failed) return;
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "NESTED_ACTION"
+
+	// $ANTLR start "ACTION_CHAR_LITERAL"
+	public final void mACTION_CHAR_LITERAL() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1304:2: ( '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
+			// org/antlr/grammar/v3/ANTLR.g:1304:4: '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\''
+			{
+			match('\''); if (state.failed) return;
+			// org/antlr/grammar/v3/ANTLR.g:1305:3: ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )*
+			loop18:
+			while (true) {
+				int alt18=3;
+				int LA18_0 = input.LA(1);
+				if ( (LA18_0=='\\') ) {
+					alt18=1;
+				}
+				else if ( ((LA18_0 >= '\u0000' && LA18_0 <= '&')||(LA18_0 >= '(' && LA18_0 <= '[')||(LA18_0 >= ']' && LA18_0 <= '\uFFFF')) ) {
+					alt18=2;
+				}
+
+				switch (alt18) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1305:5: ACTION_ESC
+					{
+					mACTION_ESC(); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1306:5: ~ ( '\\\\' | '\\'' )
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '&')||(input.LA(1) >= '(' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop18;
+				}
+			}
+
+			match('\''); if (state.failed) return;
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ACTION_CHAR_LITERAL"
+
+	// $ANTLR start "ACTION_STRING_LITERAL"
+	public final void mACTION_STRING_LITERAL() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1313:2: ( '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"' )
+			// org/antlr/grammar/v3/ANTLR.g:1313:4: '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"'
+			{
+			match('\"'); if (state.failed) return;
+			// org/antlr/grammar/v3/ANTLR.g:1314:3: ( ACTION_ESC |~ ( '\\\\' | '\"' ) )*
+			loop19:
+			while (true) {
+				int alt19=3;
+				int LA19_0 = input.LA(1);
+				if ( (LA19_0=='\\') ) {
+					alt19=1;
+				}
+				else if ( ((LA19_0 >= '\u0000' && LA19_0 <= '!')||(LA19_0 >= '#' && LA19_0 <= '[')||(LA19_0 >= ']' && LA19_0 <= '\uFFFF')) ) {
+					alt19=2;
+				}
+
+				switch (alt19) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1314:5: ACTION_ESC
+					{
+					mACTION_ESC(); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1315:5: ~ ( '\\\\' | '\"' )
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop19;
+				}
+			}
+
+			match('\"'); if (state.failed) return;
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ACTION_STRING_LITERAL"
+
+	// $ANTLR start "ACTION_ESC"
+	public final void mACTION_ESC() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1322:2: ( '\\\\\\'' | '\\\\\\\"' | '\\\\' ~ ( '\\'' | '\"' ) )
+			int alt20=3;
+			int LA20_0 = input.LA(1);
+			if ( (LA20_0=='\\') ) {
+				int LA20_1 = input.LA(2);
+				if ( (LA20_1=='\'') ) {
+					alt20=1;
+				}
+				else if ( (LA20_1=='\"') ) {
+					alt20=2;
+				}
+				else if ( ((LA20_1 >= '\u0000' && LA20_1 <= '!')||(LA20_1 >= '#' && LA20_1 <= '&')||(LA20_1 >= '(' && LA20_1 <= '\uFFFF')) ) {
+					alt20=3;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 20, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 20, 0, input);
+				throw nvae;
+			}
+
+			switch (alt20) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1322:4: '\\\\\\''
+					{
+					match("\\'"); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1323:4: '\\\\\\\"'
+					{
+					match("\\\""); if (state.failed) return;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:1324:4: '\\\\' ~ ( '\\'' | '\"' )
+					{
+					match('\\'); if (state.failed) return;
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '&')||(input.LA(1) >= '(' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+			}
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ACTION_ESC"
+
+	// $ANTLR start "TOKEN_REF"
+	public final void mTOKEN_REF() throws RecognitionException {
+		try {
+			int _type = TOKEN_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1327:2: ( 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// org/antlr/grammar/v3/ANTLR.g:1327:4: 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			{
+			matchRange('A','Z'); if (state.failed) return;
+			// org/antlr/grammar/v3/ANTLR.g:1328:3: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			loop21:
+			while (true) {
+				int alt21=2;
+				int LA21_0 = input.LA(1);
+				if ( ((LA21_0 >= '0' && LA21_0 <= '9')||(LA21_0 >= 'A' && LA21_0 <= 'Z')||LA21_0=='_'||(LA21_0 >= 'a' && LA21_0 <= 'z')) ) {
+					alt21=1;
+				}
+
+				switch (alt21) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:
+					{
+					if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop21;
+				}
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TOKEN_REF"
+
+	// $ANTLR start "TOKENS"
+	public final void mTOKENS() throws RecognitionException {
+		try {
+			int _type = TOKENS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1333:2: ( 'tokens' WS_LOOP '{' )
+			// org/antlr/grammar/v3/ANTLR.g:1333:4: 'tokens' WS_LOOP '{'
+			{
+			match("tokens"); if (state.failed) return;
+
+			mWS_LOOP(); if (state.failed) return;
+
+			match('{'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TOKENS"
+
+	// $ANTLR start "OPTIONS"
+	public final void mOPTIONS() throws RecognitionException {
+		try {
+			int _type = OPTIONS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLR.g:1337:2: ( 'options' WS_LOOP '{' )
+			// org/antlr/grammar/v3/ANTLR.g:1337:4: 'options' WS_LOOP '{'
+			{
+			match("options"); if (state.failed) return;
+
+			mWS_LOOP(); if (state.failed) return;
+
+			match('{'); if (state.failed) return;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "OPTIONS"
+
+	// $ANTLR start "RULE_REF"
+	public final void mRULE_REF() throws RecognitionException {
+		try {
+			int _type = RULE_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+
+				int t=0;
+
+			// org/antlr/grammar/v3/ANTLR.g:1346:2: ( 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// org/antlr/grammar/v3/ANTLR.g:1346:4: 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			{
+			matchRange('a','z'); if (state.failed) return;
+			// org/antlr/grammar/v3/ANTLR.g:1346:13: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			loop22:
+			while (true) {
+				int alt22=2;
+				int LA22_0 = input.LA(1);
+				if ( ((LA22_0 >= '0' && LA22_0 <= '9')||(LA22_0 >= 'A' && LA22_0 <= 'Z')||LA22_0=='_'||(LA22_0 >= 'a' && LA22_0 <= 'z')) ) {
+					alt22=1;
+				}
+
+				switch (alt22) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:
+					{
+					if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
+						input.consume();
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop22;
+				}
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "RULE_REF"
+
+	// $ANTLR start "WS_LOOP"
+	public final void mWS_LOOP() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1352:2: ( ( WS | COMMENT )* )
+			// org/antlr/grammar/v3/ANTLR.g:1352:4: ( WS | COMMENT )*
+			{
+			// org/antlr/grammar/v3/ANTLR.g:1352:4: ( WS | COMMENT )*
+			loop23:
+			while (true) {
+				int alt23=3;
+				int LA23_0 = input.LA(1);
+				if ( ((LA23_0 >= '\t' && LA23_0 <= '\n')||LA23_0=='\r'||LA23_0==' ') ) {
+					alt23=1;
+				}
+				else if ( (LA23_0=='/') ) {
+					alt23=2;
+				}
+
+				switch (alt23) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1352:6: WS
+					{
+					mWS(); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1353:5: COMMENT
+					{
+					mCOMMENT(); if (state.failed) return;
+
+					}
+					break;
+
+				default :
+					break loop23;
+				}
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "WS_LOOP"
+
+	// $ANTLR start "WS_OPT"
+	public final void mWS_OPT() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1359:2: ( ( WS )? )
+			// org/antlr/grammar/v3/ANTLR.g:1359:4: ( WS )?
+			{
+			// org/antlr/grammar/v3/ANTLR.g:1359:4: ( WS )?
+			int alt24=2;
+			int LA24_0 = input.LA(1);
+			if ( ((LA24_0 >= '\t' && LA24_0 <= '\n')||LA24_0=='\r'||LA24_0==' ') ) {
+				alt24=1;
+			}
+			switch (alt24) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1359:5: WS
+					{
+					mWS(); if (state.failed) return;
+
+					}
+					break;
+
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "WS_OPT"
+
+	// $ANTLR start "SRC"
+	public final void mSRC() throws RecognitionException {
+		try {
+			CommonToken file=null;
+			CommonToken line=null;
+
+			// org/antlr/grammar/v3/ANTLR.g:1372:2: ( 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT )
+			// org/antlr/grammar/v3/ANTLR.g:1372:4: 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT
+			{
+			match("src"); if (state.failed) return;
+
+			match(' '); if (state.failed) return;
+			int fileStart1272 = getCharIndex();
+			int fileStartLine1272 = getLine();
+			int fileStartCharPos1272 = getCharPositionInLine();
+			mACTION_STRING_LITERAL(); if (state.failed) return;
+			file = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, fileStart1272, getCharIndex()-1);
+			file.setLine(fileStartLine1272);
+			file.setCharPositionInLine(fileStartCharPos1272);
+
+			match(' '); if (state.failed) return;
+			int lineStart1278 = getCharIndex();
+			int lineStartLine1278 = getLine();
+			int lineStartCharPos1278 = getCharPositionInLine();
+			mINT(); if (state.failed) return;
+			line = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, lineStart1278, getCharIndex()-1);
+			line.setLine(lineStartLine1278);
+			line.setCharPositionInLine(lineStartCharPos1278);
+
+			if ( state.backtracking==0 ) {
+						setFileName((file!=null?file.getText():null).substring(1,(file!=null?file.getText():null).length()-1));
+						input.setLine(Integer.parseInt((line!=null?line.getText():null)) - 1);  // -1 because SL_COMMENT will increment the line no. KR
+					}
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SRC"
+
+	@Override
+	public void mTokens() throws RecognitionException {
+		// org/antlr/grammar/v3/ANTLR.g:1:8: ( CATCH | FINALLY | FRAGMENT | GRAMMAR | IMPORT | LEXER | PARSER | PRIVATE | PROTECTED | PUBLIC | RETURNS | SCOPE | THROWS | TREE | WS | COMMENT | OPEN_ELEMENT_OPTION | CLOSE_ELEMENT_OPTION | AMPERSAND | COMMA | QUESTION | TREE_BEGIN | LPAREN | RPAREN | COLON | STAR | PLUS | ASSIGN | PLUS_ASSIGN | IMPLIES | REWRITE | SEMI | ROOT | BANG | OR | WILDCARD | ETC | RANGE | NOT | RCURLY | DOLLAR | STRAY_BRACKET | CHAR_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | TOKENS | OPTIONS | RULE_REF )
+		int alt25=52;
+		alt25 = dfa25.predict(input);
+		switch (alt25) {
+			case 1 :
+				// org/antlr/grammar/v3/ANTLR.g:1:10: CATCH
+				{
+				mCATCH(); if (state.failed) return;
+
+				}
+				break;
+			case 2 :
+				// org/antlr/grammar/v3/ANTLR.g:1:16: FINALLY
+				{
+				mFINALLY(); if (state.failed) return;
+
+				}
+				break;
+			case 3 :
+				// org/antlr/grammar/v3/ANTLR.g:1:24: FRAGMENT
+				{
+				mFRAGMENT(); if (state.failed) return;
+
+				}
+				break;
+			case 4 :
+				// org/antlr/grammar/v3/ANTLR.g:1:33: GRAMMAR
+				{
+				mGRAMMAR(); if (state.failed) return;
+
+				}
+				break;
+			case 5 :
+				// org/antlr/grammar/v3/ANTLR.g:1:41: IMPORT
+				{
+				mIMPORT(); if (state.failed) return;
+
+				}
+				break;
+			case 6 :
+				// org/antlr/grammar/v3/ANTLR.g:1:48: LEXER
+				{
+				mLEXER(); if (state.failed) return;
+
+				}
+				break;
+			case 7 :
+				// org/antlr/grammar/v3/ANTLR.g:1:54: PARSER
+				{
+				mPARSER(); if (state.failed) return;
+
+				}
+				break;
+			case 8 :
+				// org/antlr/grammar/v3/ANTLR.g:1:61: PRIVATE
+				{
+				mPRIVATE(); if (state.failed) return;
+
+				}
+				break;
+			case 9 :
+				// org/antlr/grammar/v3/ANTLR.g:1:69: PROTECTED
+				{
+				mPROTECTED(); if (state.failed) return;
+
+				}
+				break;
+			case 10 :
+				// org/antlr/grammar/v3/ANTLR.g:1:79: PUBLIC
+				{
+				mPUBLIC(); if (state.failed) return;
+
+				}
+				break;
+			case 11 :
+				// org/antlr/grammar/v3/ANTLR.g:1:86: RETURNS
+				{
+				mRETURNS(); if (state.failed) return;
+
+				}
+				break;
+			case 12 :
+				// org/antlr/grammar/v3/ANTLR.g:1:94: SCOPE
+				{
+				mSCOPE(); if (state.failed) return;
+
+				}
+				break;
+			case 13 :
+				// org/antlr/grammar/v3/ANTLR.g:1:100: THROWS
+				{
+				mTHROWS(); if (state.failed) return;
+
+				}
+				break;
+			case 14 :
+				// org/antlr/grammar/v3/ANTLR.g:1:107: TREE
+				{
+				mTREE(); if (state.failed) return;
+
+				}
+				break;
+			case 15 :
+				// org/antlr/grammar/v3/ANTLR.g:1:112: WS
+				{
+				mWS(); if (state.failed) return;
+
+				}
+				break;
+			case 16 :
+				// org/antlr/grammar/v3/ANTLR.g:1:115: COMMENT
+				{
+				mCOMMENT(); if (state.failed) return;
+
+				}
+				break;
+			case 17 :
+				// org/antlr/grammar/v3/ANTLR.g:1:123: OPEN_ELEMENT_OPTION
+				{
+				mOPEN_ELEMENT_OPTION(); if (state.failed) return;
+
+				}
+				break;
+			case 18 :
+				// org/antlr/grammar/v3/ANTLR.g:1:143: CLOSE_ELEMENT_OPTION
+				{
+				mCLOSE_ELEMENT_OPTION(); if (state.failed) return;
+
+				}
+				break;
+			case 19 :
+				// org/antlr/grammar/v3/ANTLR.g:1:164: AMPERSAND
+				{
+				mAMPERSAND(); if (state.failed) return;
+
+				}
+				break;
+			case 20 :
+				// org/antlr/grammar/v3/ANTLR.g:1:174: COMMA
+				{
+				mCOMMA(); if (state.failed) return;
+
+				}
+				break;
+			case 21 :
+				// org/antlr/grammar/v3/ANTLR.g:1:180: QUESTION
+				{
+				mQUESTION(); if (state.failed) return;
+
+				}
+				break;
+			case 22 :
+				// org/antlr/grammar/v3/ANTLR.g:1:189: TREE_BEGIN
+				{
+				mTREE_BEGIN(); if (state.failed) return;
+
+				}
+				break;
+			case 23 :
+				// org/antlr/grammar/v3/ANTLR.g:1:200: LPAREN
+				{
+				mLPAREN(); if (state.failed) return;
+
+				}
+				break;
+			case 24 :
+				// org/antlr/grammar/v3/ANTLR.g:1:207: RPAREN
+				{
+				mRPAREN(); if (state.failed) return;
+
+				}
+				break;
+			case 25 :
+				// org/antlr/grammar/v3/ANTLR.g:1:214: COLON
+				{
+				mCOLON(); if (state.failed) return;
+
+				}
+				break;
+			case 26 :
+				// org/antlr/grammar/v3/ANTLR.g:1:220: STAR
+				{
+				mSTAR(); if (state.failed) return;
+
+				}
+				break;
+			case 27 :
+				// org/antlr/grammar/v3/ANTLR.g:1:225: PLUS
+				{
+				mPLUS(); if (state.failed) return;
+
+				}
+				break;
+			case 28 :
+				// org/antlr/grammar/v3/ANTLR.g:1:230: ASSIGN
+				{
+				mASSIGN(); if (state.failed) return;
+
+				}
+				break;
+			case 29 :
+				// org/antlr/grammar/v3/ANTLR.g:1:237: PLUS_ASSIGN
+				{
+				mPLUS_ASSIGN(); if (state.failed) return;
+
+				}
+				break;
+			case 30 :
+				// org/antlr/grammar/v3/ANTLR.g:1:249: IMPLIES
+				{
+				mIMPLIES(); if (state.failed) return;
+
+				}
+				break;
+			case 31 :
+				// org/antlr/grammar/v3/ANTLR.g:1:257: REWRITE
+				{
+				mREWRITE(); if (state.failed) return;
+
+				}
+				break;
+			case 32 :
+				// org/antlr/grammar/v3/ANTLR.g:1:265: SEMI
+				{
+				mSEMI(); if (state.failed) return;
+
+				}
+				break;
+			case 33 :
+				// org/antlr/grammar/v3/ANTLR.g:1:270: ROOT
+				{
+				mROOT(); if (state.failed) return;
+
+				}
+				break;
+			case 34 :
+				// org/antlr/grammar/v3/ANTLR.g:1:275: BANG
+				{
+				mBANG(); if (state.failed) return;
+
+				}
+				break;
+			case 35 :
+				// org/antlr/grammar/v3/ANTLR.g:1:280: OR
+				{
+				mOR(); if (state.failed) return;
+
+				}
+				break;
+			case 36 :
+				// org/antlr/grammar/v3/ANTLR.g:1:283: WILDCARD
+				{
+				mWILDCARD(); if (state.failed) return;
+
+				}
+				break;
+			case 37 :
+				// org/antlr/grammar/v3/ANTLR.g:1:292: ETC
+				{
+				mETC(); if (state.failed) return;
+
+				}
+				break;
+			case 38 :
+				// org/antlr/grammar/v3/ANTLR.g:1:296: RANGE
+				{
+				mRANGE(); if (state.failed) return;
+
+				}
+				break;
+			case 39 :
+				// org/antlr/grammar/v3/ANTLR.g:1:302: NOT
+				{
+				mNOT(); if (state.failed) return;
+
+				}
+				break;
+			case 40 :
+				// org/antlr/grammar/v3/ANTLR.g:1:306: RCURLY
+				{
+				mRCURLY(); if (state.failed) return;
+
+				}
+				break;
+			case 41 :
+				// org/antlr/grammar/v3/ANTLR.g:1:313: DOLLAR
+				{
+				mDOLLAR(); if (state.failed) return;
+
+				}
+				break;
+			case 42 :
+				// org/antlr/grammar/v3/ANTLR.g:1:320: STRAY_BRACKET
+				{
+				mSTRAY_BRACKET(); if (state.failed) return;
+
+				}
+				break;
+			case 43 :
+				// org/antlr/grammar/v3/ANTLR.g:1:334: CHAR_LITERAL
+				{
+				mCHAR_LITERAL(); if (state.failed) return;
+
+				}
+				break;
+			case 44 :
+				// org/antlr/grammar/v3/ANTLR.g:1:347: DOUBLE_QUOTE_STRING_LITERAL
+				{
+				mDOUBLE_QUOTE_STRING_LITERAL(); if (state.failed) return;
+
+				}
+				break;
+			case 45 :
+				// org/antlr/grammar/v3/ANTLR.g:1:375: DOUBLE_ANGLE_STRING_LITERAL
+				{
+				mDOUBLE_ANGLE_STRING_LITERAL(); if (state.failed) return;
+
+				}
+				break;
+			case 46 :
+				// org/antlr/grammar/v3/ANTLR.g:1:403: INT
+				{
+				mINT(); if (state.failed) return;
+
+				}
+				break;
+			case 47 :
+				// org/antlr/grammar/v3/ANTLR.g:1:407: ARG_ACTION
+				{
+				mARG_ACTION(); if (state.failed) return;
+
+				}
+				break;
+			case 48 :
+				// org/antlr/grammar/v3/ANTLR.g:1:418: ACTION
+				{
+				mACTION(); if (state.failed) return;
+
+				}
+				break;
+			case 49 :
+				// org/antlr/grammar/v3/ANTLR.g:1:425: TOKEN_REF
+				{
+				mTOKEN_REF(); if (state.failed) return;
+
+				}
+				break;
+			case 50 :
+				// org/antlr/grammar/v3/ANTLR.g:1:435: TOKENS
+				{
+				mTOKENS(); if (state.failed) return;
+
+				}
+				break;
+			case 51 :
+				// org/antlr/grammar/v3/ANTLR.g:1:442: OPTIONS
+				{
+				mOPTIONS(); if (state.failed) return;
+
+				}
+				break;
+			case 52 :
+				// org/antlr/grammar/v3/ANTLR.g:1:450: RULE_REF
+				{
+				mRULE_REF(); if (state.failed) return;
+
+				}
+				break;
+
+		}
+	}
+
+	// $ANTLR start synpred1_ANTLR
+	public final void synpred1_ANTLR_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ANTLR.g:1101:5: ( ' $ANTLR' )
+		// org/antlr/grammar/v3/ANTLR.g:1101:6: ' $ANTLR'
+		{
+		match(" $ANTLR"); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred1_ANTLR
+
+	// $ANTLR start synpred2_ANTLR
+	public final void synpred2_ANTLR_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ANTLR.g:1192:5: ( '\\\\\\\"' )
+		// org/antlr/grammar/v3/ANTLR.g:1192:6: '\\\\\\\"'
+		{
+		match("\\\""); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred2_ANTLR
+
+	// $ANTLR start synpred3_ANTLR
+	public final void synpred3_ANTLR_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ANTLR.g:1257:6: ( '\\\\]' )
+		// org/antlr/grammar/v3/ANTLR.g:1257:7: '\\\\]'
+		{
+		match("\\]"); if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred3_ANTLR
+
+	// $ANTLR start synpred4_ANTLR
+	public final void synpred4_ANTLR_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ANTLR.g:1294:5: ( '//' | '/*' )
+		int alt26=2;
+		int LA26_0 = input.LA(1);
+		if ( (LA26_0=='/') ) {
+			int LA26_1 = input.LA(2);
+			if ( (LA26_1=='/') ) {
+				alt26=1;
+			}
+			else if ( (LA26_1=='*') ) {
+				alt26=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				int nvaeMark = input.mark();
+				try {
+					input.consume();
+					NoViableAltException nvae =
+						new NoViableAltException("", 26, 1, input);
+					throw nvae;
+				} finally {
+					input.rewind(nvaeMark);
+				}
+			}
+
+		}
+
+		else {
+			if (state.backtracking>0) {state.failed=true; return;}
+			NoViableAltException nvae =
+				new NoViableAltException("", 26, 0, input);
+			throw nvae;
+		}
+
+		switch (alt26) {
+			case 1 :
+				// org/antlr/grammar/v3/ANTLR.g:1294:6: '//'
+				{
+				match("//"); if (state.failed) return;
+
+				}
+				break;
+			case 2 :
+				// org/antlr/grammar/v3/ANTLR.g:1294:13: '/*'
+				{
+				match("/*"); if (state.failed) return;
+
+				}
+				break;
+
+		}
+	}
+	// $ANTLR end synpred4_ANTLR
+
+	public final boolean synpred1_ANTLR() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred1_ANTLR_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred3_ANTLR() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred3_ANTLR_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred4_ANTLR() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred4_ANTLR_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred2_ANTLR() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred2_ANTLR_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+	protected DFA9 dfa9 = new DFA9(this);
+	protected DFA25 dfa25 = new DFA25(this);
+	static final String DFA9_eotS =
+		"\2\2\1\uffff\15\2\1\uffff\5\2\1\uffff\2\2\3\uffff\1\2\1\uffff";
+	static final String DFA9_eofS =
+		"\36\uffff";
+	static final String DFA9_minS =
+		"\1\40\1\44\1\uffff\1\101\1\116\1\124\1\114\1\122\1\40\1\163\1\162\1\143"+
+		"\1\40\1\42\3\0\1\40\7\0\3\uffff\1\60\1\0";
+	static final String DFA9_maxS =
+		"\1\40\1\44\1\uffff\1\101\1\116\1\124\1\114\1\122\1\40\1\163\1\162\1\143"+
+		"\1\40\1\42\3\uffff\1\40\7\uffff\3\uffff\1\71\1\0";
+	static final String DFA9_acceptS =
+		"\2\uffff\1\2\26\uffff\3\1\2\uffff";
+	static final String DFA9_specialS =
+		"\16\uffff\1\6\1\0\1\7\1\uffff\1\11\1\1\1\2\1\4\1\12\1\3\1\5\4\uffff\1"+
+		"\10}>";
+	static final String[] DFA9_transitionS = {
+			"\1\1",
+			"\1\3",
+			"",
+			"\1\4",
+			"\1\5",
+			"\1\6",
+			"\1\7",
+			"\1\10",
+			"\1\11",
+			"\1\12",
+			"\1\13",
+			"\1\14",
+			"\1\15",
+			"\1\16",
+			"\12\23\1\22\2\23\1\20\24\23\1\21\71\23\1\17\uffa3\23",
+			"\12\30\1\27\2\30\1\26\24\30\1\25\4\30\1\24\uffd8\30",
+			"\12\33\1\22\27\33\1\31\71\33\1\32\uffa3\33",
+			"\1\34",
+			"\42\33\1\31\71\33\1\32\uffa3\33",
+			"\12\23\1\22\2\23\1\20\24\23\1\21\71\23\1\17\uffa3\23",
+			"\12\23\1\22\2\23\1\20\24\23\1\21\71\23\1\17\uffa3\23",
+			"\12\23\1\22\2\23\1\20\24\23\1\21\71\23\1\17\uffa3\23",
+			"\12\33\1\22\27\33\1\31\71\33\1\32\uffa3\33",
+			"\42\33\1\31\71\33\1\32\uffa3\33",
+			"\12\23\1\22\2\23\1\20\24\23\1\21\71\23\1\17\uffa3\23",
+			"",
+			"",
+			"",
+			"\12\35",
+			"\1\uffff"
+	};
+
+	static final short[] DFA9_eot = DFA.unpackEncodedString(DFA9_eotS);
+	static final short[] DFA9_eof = DFA.unpackEncodedString(DFA9_eofS);
+	static final char[] DFA9_min = DFA.unpackEncodedStringToUnsignedChars(DFA9_minS);
+	static final char[] DFA9_max = DFA.unpackEncodedStringToUnsignedChars(DFA9_maxS);
+	static final short[] DFA9_accept = DFA.unpackEncodedString(DFA9_acceptS);
+	static final short[] DFA9_special = DFA.unpackEncodedString(DFA9_specialS);
+	static final short[][] DFA9_transition;
+
+	static {
+		int numStates = DFA9_transitionS.length;
+		DFA9_transition = new short[numStates][];
+		for (int i=0; i<numStates; i++) {
+			DFA9_transition[i] = DFA.unpackEncodedString(DFA9_transitionS[i]);
+		}
+	}
+
+	protected class DFA9 extends DFA {
+
+		public DFA9(BaseRecognizer recognizer) {
+			this.recognizer = recognizer;
+			this.decisionNumber = 9;
+			this.eot = DFA9_eot;
+			this.eof = DFA9_eof;
+			this.min = DFA9_min;
+			this.max = DFA9_max;
+			this.accept = DFA9_accept;
+			this.special = DFA9_special;
+			this.transition = DFA9_transition;
+		}
+		@Override
+		public String getDescription() {
+			return "1101:3: ( ( ' $ANTLR' )=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )";
+		}
+		@Override
+		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
+			IntStream input = _input;
+			int _s = s;
+			switch ( s ) {
+					case 0 : 
+						int LA9_15 = input.LA(1);
+						s = -1;
+						if ( (LA9_15=='\'') ) {s = 20;}
+						else if ( (LA9_15=='\"') ) {s = 21;}
+						else if ( (LA9_15=='\r') ) {s = 22;}
+						else if ( (LA9_15=='\n') ) {s = 23;}
+						else if ( ((LA9_15 >= '\u0000' && LA9_15 <= '\t')||(LA9_15 >= '\u000B' && LA9_15 <= '\f')||(LA9_15 >= '\u000E' && LA9_15 <= '!')||(LA9_15 >= '#' && LA9_15 <= '&')||(LA9_15 >= '(' && LA9_15 <= '\uFFFF')) ) {s = 24;}
+						else s = 2;
+						if ( s>=0 ) return s;
+						break;
+					case 1 : 
+						int LA9_19 = input.LA(1);
+						s = -1;
+						if ( (LA9_19=='\"') ) {s = 17;}
+						else if ( (LA9_19=='\\') ) {s = 15;}
+						else if ( (LA9_19=='\r') ) {s = 16;}
+						else if ( (LA9_19=='\n') ) {s = 18;}
+						else if ( ((LA9_19 >= '\u0000' && LA9_19 <= '\t')||(LA9_19 >= '\u000B' && LA9_19 <= '\f')||(LA9_19 >= '\u000E' && LA9_19 <= '!')||(LA9_19 >= '#' && LA9_19 <= '[')||(LA9_19 >= ']' && LA9_19 <= '\uFFFF')) ) {s = 19;}
+						else s = 2;
+						if ( s>=0 ) return s;
+						break;
+					case 2 : 
+						int LA9_20 = input.LA(1);
+						s = -1;
+						if ( (LA9_20=='\"') ) {s = 17;}
+						else if ( (LA9_20=='\\') ) {s = 15;}
+						else if ( (LA9_20=='\r') ) {s = 16;}
+						else if ( (LA9_20=='\n') ) {s = 18;}
+						else if ( ((LA9_20 >= '\u0000' && LA9_20 <= '\t')||(LA9_20 >= '\u000B' && LA9_20 <= '\f')||(LA9_20 >= '\u000E' && LA9_20 <= '!')||(LA9_20 >= '#' && LA9_20 <= '[')||(LA9_20 >= ']' && LA9_20 <= '\uFFFF')) ) {s = 19;}
+						else s = 2;
+						if ( s>=0 ) return s;
+						break;
+					case 3 : 
+						int LA9_23 = input.LA(1);
+						 
+						int index9_23 = input.index();
+						input.rewind();
+						s = -1;
+						if ( (LA9_23=='\"') && (synpred1_ANTLR())) {s = 25;}
+						else if ( (LA9_23=='\\') && (synpred1_ANTLR())) {s = 26;}
+						else if ( ((LA9_23 >= '\u0000' && LA9_23 <= '!')||(LA9_23 >= '#' && LA9_23 <= '[')||(LA9_23 >= ']' && LA9_23 <= '\uFFFF')) && (synpred1_ANTLR())) {s = 27;}
+						else s = 2;
+						 
+						input.seek(index9_23);
+						if ( s>=0 ) return s;
+						break;
+					case 4 : 
+						int LA9_21 = input.LA(1);
+						s = -1;
+						if ( (LA9_21=='\"') ) {s = 17;}
+						else if ( (LA9_21=='\\') ) {s = 15;}
+						else if ( (LA9_21=='\r') ) {s = 16;}
+						else if ( (LA9_21=='\n') ) {s = 18;}
+						else if ( ((LA9_21 >= '\u0000' && LA9_21 <= '\t')||(LA9_21 >= '\u000B' && LA9_21 <= '\f')||(LA9_21 >= '\u000E' && LA9_21 <= '!')||(LA9_21 >= '#' && LA9_21 <= '[')||(LA9_21 >= ']' && LA9_21 <= '\uFFFF')) ) {s = 19;}
+						else s = 2;
+						if ( s>=0 ) return s;
+						break;
+					case 5 : 
+						int LA9_24 = input.LA(1);
+						s = -1;
+						if ( (LA9_24=='\"') ) {s = 17;}
+						else if ( (LA9_24=='\\') ) {s = 15;}
+						else if ( (LA9_24=='\r') ) {s = 16;}
+						else if ( (LA9_24=='\n') ) {s = 18;}
+						else if ( ((LA9_24 >= '\u0000' && LA9_24 <= '\t')||(LA9_24 >= '\u000B' && LA9_24 <= '\f')||(LA9_24 >= '\u000E' && LA9_24 <= '!')||(LA9_24 >= '#' && LA9_24 <= '[')||(LA9_24 >= ']' && LA9_24 <= '\uFFFF')) ) {s = 19;}
+						else s = 2;
+						if ( s>=0 ) return s;
+						break;
+					case 6 : 
+						int LA9_14 = input.LA(1);
+						s = -1;
+						if ( (LA9_14=='\\') ) {s = 15;}
+						else if ( (LA9_14=='\r') ) {s = 16;}
+						else if ( (LA9_14=='\"') ) {s = 17;}
+						else if ( (LA9_14=='\n') ) {s = 18;}
+						else if ( ((LA9_14 >= '\u0000' && LA9_14 <= '\t')||(LA9_14 >= '\u000B' && LA9_14 <= '\f')||(LA9_14 >= '\u000E' && LA9_14 <= '!')||(LA9_14 >= '#' && LA9_14 <= '[')||(LA9_14 >= ']' && LA9_14 <= '\uFFFF')) ) {s = 19;}
+						else s = 2;
+						if ( s>=0 ) return s;
+						break;
+					case 7 : 
+						int LA9_16 = input.LA(1);
+						 
+						int index9_16 = input.index();
+						input.rewind();
+						s = -1;
+						if ( (LA9_16=='\"') && (synpred1_ANTLR())) {s = 25;}
+						else if ( (LA9_16=='\\') && (synpred1_ANTLR())) {s = 26;}
+						else if ( (LA9_16=='\n') ) {s = 18;}
+						else if ( ((LA9_16 >= '\u0000' && LA9_16 <= '\t')||(LA9_16 >= '\u000B' && LA9_16 <= '!')||(LA9_16 >= '#' && LA9_16 <= '[')||(LA9_16 >= ']' && LA9_16 <= '\uFFFF')) && (synpred1_ANTLR())) {s = 27;}
+						 
+						input.seek(index9_16);
+						if ( s>=0 ) return s;
+						break;
+					case 8 : 
+						int LA9_29 = input.LA(1);
+						 
+						int index9_29 = input.index();
+						input.rewind();
+						s = -1;
+						if ( (synpred1_ANTLR()) ) {s = 27;}
+						else if ( (true) ) {s = 2;}
+						 
+						input.seek(index9_29);
+						if ( s>=0 ) return s;
+						break;
+					case 9 : 
+						int LA9_18 = input.LA(1);
+						 
+						int index9_18 = input.index();
+						input.rewind();
+						s = -1;
+						if ( (LA9_18=='\"') && (synpred1_ANTLR())) {s = 25;}
+						else if ( (LA9_18=='\\') && (synpred1_ANTLR())) {s = 26;}
+						else if ( ((LA9_18 >= '\u0000' && LA9_18 <= '!')||(LA9_18 >= '#' && LA9_18 <= '[')||(LA9_18 >= ']' && LA9_18 <= '\uFFFF')) && (synpred1_ANTLR())) {s = 27;}
+						else s = 2;
+						 
+						input.seek(index9_18);
+						if ( s>=0 ) return s;
+						break;
+					case 10 : 
+						int LA9_22 = input.LA(1);
+						 
+						int index9_22 = input.index();
+						input.rewind();
+						s = -1;
+						if ( (LA9_22=='\"') && (synpred1_ANTLR())) {s = 25;}
+						else if ( (LA9_22=='\\') && (synpred1_ANTLR())) {s = 26;}
+						else if ( (LA9_22=='\n') ) {s = 18;}
+						else if ( ((LA9_22 >= '\u0000' && LA9_22 <= '\t')||(LA9_22 >= '\u000B' && LA9_22 <= '!')||(LA9_22 >= '#' && LA9_22 <= '[')||(LA9_22 >= ']' && LA9_22 <= '\uFFFF')) && (synpred1_ANTLR())) {s = 27;}
+						 
+						input.seek(index9_22);
+						if ( s>=0 ) return s;
+						break;
+			}
+			if (state.backtracking>0) {state.failed=true; return -1;}
+			NoViableAltException nvae =
+				new NoViableAltException(getDescription(), 9, _s, input);
+			error(nvae);
+			throw nvae;
+		}
+	}
+
+	static final String DFA25_eotS =
+		"\1\uffff\11\50\2\uffff\1\70\4\uffff\1\72\4\uffff\1\74\1\76\4\uffff\1\100"+
+		"\12\uffff\1\50\1\uffff\16\50\10\uffff\1\122\1\uffff\20\50\2\uffff\16\50"+
+		"\1\161\2\50\1\164\4\50\1\171\5\50\1\177\1\50\1\uffff\2\50\1\uffff\3\50"+
+		"\1\u0086\1\uffff\1\u0087\2\50\1\u008a\1\50\1\uffff\1\u008c\2\50\1\u008f"+
+		"\1\50\1\u0091\2\uffff\1\u0092\1\50\1\uffff\1\u0094\2\uffff\1\50\1\uffff"+
+		"\1\u0096\2\uffff\1\50\3\uffff\1\u0098\1\uffff";
+	static final String DFA25_eofS =
+		"\u0099\uffff";
+	static final String DFA25_minS =
+		"\1\11\1\141\1\151\1\162\1\155\1\145\1\141\1\145\1\143\1\150\2\uffff\1"+
+		"\74\4\uffff\1\50\4\uffff\1\75\1\76\4\uffff\1\56\12\uffff\1\160\1\uffff"+
+		"\1\164\1\156\2\141\1\160\1\170\1\162\1\151\1\142\1\164\1\157\1\162\1\145"+
+		"\1\153\10\uffff\1\56\1\uffff\1\164\1\143\1\141\1\147\1\155\1\157\1\145"+
+		"\1\163\1\166\1\164\1\154\1\165\1\160\1\157\2\145\2\uffff\1\151\1\150\1"+
+		"\154\2\155\2\162\1\145\1\141\1\145\1\151\1\162\1\145\1\167\1\60\1\156"+
+		"\1\157\1\60\1\154\1\145\1\141\1\164\1\60\1\162\1\164\2\143\1\156\1\60"+
+		"\1\163\1\uffff\1\163\1\156\1\uffff\1\171\1\156\1\162\1\60\1\uffff\1\60"+
+		"\1\145\1\164\1\60\1\163\1\uffff\1\60\1\11\1\163\1\60\1\164\1\60\2\uffff"+
+		"\1\60\1\145\1\uffff\1\60\2\uffff\1\11\1\uffff\1\60\2\uffff\1\144\3\uffff"+
+		"\1\60\1\uffff";
+	static final String DFA25_maxS =
+		"\1\176\1\141\2\162\1\155\1\145\1\165\1\145\1\143\1\162\2\uffff\1\74\4"+
+		"\uffff\1\50\4\uffff\1\75\1\76\4\uffff\1\56\12\uffff\1\160\1\uffff\1\164"+
+		"\1\156\2\141\1\160\1\170\1\162\1\157\1\142\1\164\1\157\1\162\1\145\1\153"+
+		"\10\uffff\1\56\1\uffff\1\164\1\143\1\141\1\147\1\155\1\157\1\145\1\163"+
+		"\1\166\1\164\1\154\1\165\1\160\1\157\2\145\2\uffff\1\151\1\150\1\154\2"+
+		"\155\2\162\1\145\1\141\1\145\1\151\1\162\1\145\1\167\1\172\1\156\1\157"+
+		"\1\172\1\154\1\145\1\141\1\164\1\172\1\162\1\164\2\143\1\156\1\172\1\163"+
+		"\1\uffff\1\163\1\156\1\uffff\1\171\1\156\1\162\1\172\1\uffff\1\172\1\145"+
+		"\1\164\1\172\1\163\1\uffff\1\172\1\173\1\163\1\172\1\164\1\172\2\uffff"+
+		"\1\172\1\145\1\uffff\1\172\2\uffff\1\173\1\uffff\1\172\2\uffff\1\144\3"+
+		"\uffff\1\172\1\uffff";
+	static final String DFA25_acceptS =
+		"\12\uffff\1\17\1\20\1\uffff\1\22\1\23\1\24\1\25\1\uffff\1\27\1\30\1\31"+
+		"\1\32\2\uffff\1\37\1\40\1\42\1\43\1\uffff\1\47\1\50\1\51\1\52\1\53\1\54"+
+		"\1\56\1\57\1\60\1\61\1\uffff\1\64\16\uffff\1\55\1\21\1\26\1\41\1\35\1"+
+		"\33\1\36\1\34\1\uffff\1\44\20\uffff\1\45\1\46\36\uffff\1\16\2\uffff\1"+
+		"\1\4\uffff\1\6\5\uffff\1\14\6\uffff\1\5\1\7\2\uffff\1\12\1\uffff\1\15"+
+		"\1\62\1\uffff\1\2\1\uffff\1\4\1\10\1\uffff\1\13\1\63\1\3\1\uffff\1\11";
+	static final String DFA25_specialS =
+		"\u0099\uffff}>";
+	static final String[] DFA25_transitionS = {
+			"\2\12\2\uffff\1\12\22\uffff\1\12\1\32\1\42\1\uffff\1\37\2\uffff\1\41"+
+			"\1\22\1\23\1\25\1\26\1\17\1\30\1\34\1\13\12\43\1\24\1\31\1\14\1\27\1"+
+			"\15\1\20\1\16\32\46\1\44\1\uffff\1\40\1\21\2\uffff\2\50\1\1\2\50\1\2"+
+			"\1\3\1\50\1\4\2\50\1\5\2\50\1\47\1\6\1\50\1\7\1\10\1\11\6\50\1\45\1\33"+
+			"\1\36\1\35",
+			"\1\51",
+			"\1\52\10\uffff\1\53",
+			"\1\54",
+			"\1\55",
+			"\1\56",
+			"\1\57\20\uffff\1\60\2\uffff\1\61",
+			"\1\62",
+			"\1\63",
+			"\1\64\6\uffff\1\66\2\uffff\1\65",
+			"",
+			"",
+			"\1\67",
+			"",
+			"",
+			"",
+			"",
+			"\1\71",
+			"",
+			"",
+			"",
+			"",
+			"\1\73",
+			"\1\75",
+			"",
+			"",
+			"",
+			"",
+			"\1\77",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"\1\101",
+			"",
+			"\1\102",
+			"\1\103",
+			"\1\104",
+			"\1\105",
+			"\1\106",
+			"\1\107",
+			"\1\110",
+			"\1\111\5\uffff\1\112",
+			"\1\113",
+			"\1\114",
+			"\1\115",
+			"\1\116",
+			"\1\117",
+			"\1\120",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"\1\121",
+			"",
+			"\1\123",
+			"\1\124",
+			"\1\125",
+			"\1\126",
+			"\1\127",
+			"\1\130",
+			"\1\131",
+			"\1\132",
+			"\1\133",
+			"\1\134",
+			"\1\135",
+			"\1\136",
+			"\1\137",
+			"\1\140",
+			"\1\141",
+			"\1\142",
+			"",
+			"",
+			"\1\143",
+			"\1\144",
+			"\1\145",
+			"\1\146",
+			"\1\147",
+			"\1\150",
+			"\1\151",
+			"\1\152",
+			"\1\153",
+			"\1\154",
+			"\1\155",
+			"\1\156",
+			"\1\157",
+			"\1\160",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"\1\162",
+			"\1\163",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"\1\165",
+			"\1\166",
+			"\1\167",
+			"\1\170",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"\1\172",
+			"\1\173",
+			"\1\174",
+			"\1\175",
+			"\1\176",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"\1\u0080",
+			"",
+			"\1\u0081",
+			"\1\u0082",
+			"",
+			"\1\u0083",
+			"\1\u0084",
+			"\1\u0085",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"\1\u0088",
+			"\1\u0089",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"\1\u008b",
+			"",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"\2\u008d\2\uffff\1\u008d\22\uffff\1\u008d\16\uffff\1\u008d\113\uffff"+
+			"\1\u008d",
+			"\1\u008e",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"\1\u0090",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"",
+			"",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"\1\u0093",
+			"",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"",
+			"",
+			"\2\u0095\2\uffff\1\u0095\22\uffff\1\u0095\16\uffff\1\u0095\113\uffff"+
+			"\1\u0095",
+			"",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			"",
+			"",
+			"\1\u0097",
+			"",
+			"",
+			"",
+			"\12\50\7\uffff\32\50\4\uffff\1\50\1\uffff\32\50",
+			""
+	};
+
+	static final short[] DFA25_eot = DFA.unpackEncodedString(DFA25_eotS);
+	static final short[] DFA25_eof = DFA.unpackEncodedString(DFA25_eofS);
+	static final char[] DFA25_min = DFA.unpackEncodedStringToUnsignedChars(DFA25_minS);
+	static final char[] DFA25_max = DFA.unpackEncodedStringToUnsignedChars(DFA25_maxS);
+	static final short[] DFA25_accept = DFA.unpackEncodedString(DFA25_acceptS);
+	static final short[] DFA25_special = DFA.unpackEncodedString(DFA25_specialS);
+	static final short[][] DFA25_transition;
+
+	static {
+		int numStates = DFA25_transitionS.length;
+		DFA25_transition = new short[numStates][];
+		for (int i=0; i<numStates; i++) {
+			DFA25_transition[i] = DFA.unpackEncodedString(DFA25_transitionS[i]);
+		}
+	}
+
+	protected class DFA25 extends DFA {
+
+		public DFA25(BaseRecognizer recognizer) {
+			this.recognizer = recognizer;
+			this.decisionNumber = 25;
+			this.eot = DFA25_eot;
+			this.eof = DFA25_eof;
+			this.min = DFA25_min;
+			this.max = DFA25_max;
+			this.accept = DFA25_accept;
+			this.special = DFA25_special;
+			this.transition = DFA25_transition;
+		}
+		@Override
+		public String getDescription() {
+			return "1:1: Tokens : ( CATCH | FINALLY | FRAGMENT | GRAMMAR | IMPORT | LEXER | PARSER | PRIVATE | PROTECTED | PUBLIC | RETURNS | SCOPE | THROWS | TREE | WS | COMMENT | OPEN_ELEMENT_OPTION | CLOSE_ELEMENT_OPTION | AMPERSAND | COMMA | QUESTION | TREE_BEGIN | LPAREN | RPAREN | COLON | STAR | PLUS | ASSIGN | PLUS_ASSIGN | IMPLIES | REWRITE | SEMI | ROOT | BANG | OR | WILDCARD | ETC | RANGE | NOT | RCURLY | DOLLAR | STRAY_BRACKET | CHAR_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | TOKENS | OPTIONS | RULE_REF );";
+		}
+	}
+
+}
--- tool/src/main/java/org/antlr/grammar/v3/ANTLRParser.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/ANTLRParser.java	2019-04-04 17:22:25.476181469 +0200
@@ -0,0 +1,10497 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/ANTLR.g 2019-04-04 15:18:49
+
+package org.antlr.grammar.v3;
+import org.antlr.tool.ErrorManager;
+import org.antlr.tool.Grammar;
+import org.antlr.tool.GrammarAST;
+import org.antlr.misc.IntSet;
+import org.antlr.tool.Rule;
+
+
+import org.antlr.runtime.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+
+import org.antlr.runtime.tree.*;
+
+
+/** Read in an ANTLR grammar and build an AST.  Try not to do
+ *  any actions, just build the tree.
+ *
+ *  The phases are:
+ *
+ *		antlr.g (this file)
+ *		assign.types.g
+ *		define.g
+ *		buildnfa.g
+ *		antlr.print.g (optional)
+ *		codegen.g
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  2005
+ */
+@SuppressWarnings("all")
+public class ANTLRParser extends Parser {
+	public static final String[] tokenNames = new String[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", 
+		"ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", 
+		"ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", 
+		"CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", 
+		"COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", 
+		"DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", 
+		"EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", 
+		"GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", 
+		"LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", 
+		"NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", 
+		"OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", 
+		"PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", 
+		"RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", 
+		"RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", 
+		"SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", 
+		"TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", 
+		"WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public static final int EOF=-1;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int AMPERSAND=9;
+	public static final int ARG=10;
+	public static final int ARGLIST=11;
+	public static final int ARG_ACTION=12;
+	public static final int ASSIGN=13;
+	public static final int BACKTRACK_SEMPRED=14;
+	public static final int BANG=15;
+	public static final int BLOCK=16;
+	public static final int CATCH=17;
+	public static final int CHAR_LITERAL=18;
+	public static final int CHAR_RANGE=19;
+	public static final int CLOSE_ELEMENT_OPTION=20;
+	public static final int CLOSURE=21;
+	public static final int COLON=22;
+	public static final int COMBINED_GRAMMAR=23;
+	public static final int COMMA=24;
+	public static final int COMMENT=25;
+	public static final int DIGIT=26;
+	public static final int DOC_COMMENT=27;
+	public static final int DOLLAR=28;
+	public static final int DOT=29;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public static final int EOA=32;
+	public static final int EOB=33;
+	public static final int EOR=34;
+	public static final int EPSILON=35;
+	public static final int ESC=36;
+	public static final int ETC=37;
+	public static final int FINALLY=38;
+	public static final int FORCED_ACTION=39;
+	public static final int FRAGMENT=40;
+	public static final int GATED_SEMPRED=41;
+	public static final int GRAMMAR=42;
+	public static final int ID=43;
+	public static final int IMPLIES=44;
+	public static final int IMPORT=45;
+	public static final int INITACTION=46;
+	public static final int INT=47;
+	public static final int LABEL=48;
+	public static final int LEXER=49;
+	public static final int LEXER_GRAMMAR=50;
+	public static final int LPAREN=51;
+	public static final int ML_COMMENT=52;
+	public static final int NESTED_ACTION=53;
+	public static final int NESTED_ARG_ACTION=54;
+	public static final int NOT=55;
+	public static final int OPEN_ELEMENT_OPTION=56;
+	public static final int OPTIONAL=57;
+	public static final int OPTIONS=58;
+	public static final int OR=59;
+	public static final int PARSER=60;
+	public static final int PARSER_GRAMMAR=61;
+	public static final int PLUS=62;
+	public static final int PLUS_ASSIGN=63;
+	public static final int POSITIVE_CLOSURE=64;
+	public static final int PREC_RULE=65;
+	public static final int PRIVATE=66;
+	public static final int PROTECTED=67;
+	public static final int PUBLIC=68;
+	public static final int QUESTION=69;
+	public static final int RANGE=70;
+	public static final int RCURLY=71;
+	public static final int RECURSIVE_RULE_REF=72;
+	public static final int RET=73;
+	public static final int RETURNS=74;
+	public static final int REWRITE=75;
+	public static final int REWRITES=76;
+	public static final int ROOT=77;
+	public static final int RPAREN=78;
+	public static final int RULE=79;
+	public static final int RULE_REF=80;
+	public static final int SCOPE=81;
+	public static final int SEMI=82;
+	public static final int SEMPRED=83;
+	public static final int SL_COMMENT=84;
+	public static final int SRC=85;
+	public static final int STAR=86;
+	public static final int STRAY_BRACKET=87;
+	public static final int STRING_LITERAL=88;
+	public static final int SYNPRED=89;
+	public static final int SYN_SEMPRED=90;
+	public static final int TEMPLATE=91;
+	public static final int THROWS=92;
+	public static final int TOKENS=93;
+	public static final int TOKEN_REF=94;
+	public static final int TREE=95;
+	public static final int TREE_BEGIN=96;
+	public static final int TREE_GRAMMAR=97;
+	public static final int WILDCARD=98;
+	public static final int WS=99;
+	public static final int WS_LOOP=100;
+	public static final int WS_OPT=101;
+	public static final int XDIGIT=102;
+
+	// delegates
+	public Parser[] getDelegates() {
+		return new Parser[] {};
+	}
+
+	// delegators
+
+
+	public ANTLRParser(TokenStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public ANTLRParser(TokenStream input, RecognizerSharedState state) {
+		super(input, state);
+	}
+
+	protected TreeAdaptor adaptor = new CommonTreeAdaptor();
+
+	public void setTreeAdaptor(TreeAdaptor adaptor) {
+		this.adaptor = adaptor;
+	}
+	public TreeAdaptor getTreeAdaptor() {
+		return adaptor;
+	}
+	@Override public String[] getTokenNames() { return ANTLRParser.tokenNames; }
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/ANTLR.g"; }
+
+
+	protected String currentRuleName = null;
+	protected GrammarAST currentBlockAST = null;
+	protected boolean atTreeRoot; // are we matching a tree root in tree grammar?
+
+	public static ANTLRParser createParser(TokenStream input) {
+	    ANTLRParser parser = new ANTLRParser(input);
+	    parser.adaptor = new grammar_Adaptor(parser);
+	    return parser;
+	}
+
+	private static class GrammarASTErrorNode extends GrammarAST {
+	    public IntStream input;
+	    public Token start;
+	    public Token stop;
+	    public RecognitionException trappedException;
+
+	    public GrammarASTErrorNode(TokenStream input, Token start, Token stop, RecognitionException e) {
+	        super(stop);
+	        //Console.Out.WriteLine( "start: " + start + ", stop: " + stop );
+	        if ( stop == null ||
+	             ( stop.getTokenIndex() < start.getTokenIndex() &&
+	              stop.getType() != Token.EOF) ) {
+	            // sometimes resync does not consume a token (when LT(1) is
+	            // in follow set.  So, stop will be 1 to left to start. adjust.
+	            // Also handle case where start is the first token and no token
+	            // is consumed during recovery; LT(-1) will return null.
+	            stop = start;
+	        }
+	        this.input = input;
+	        this.start = start;
+	        this.stop = stop;
+	        this.trappedException = e;
+	    }
+
+	    @Override
+	    public boolean isNil() { return false; }
+
+	    @Override
+	    public String getText() {
+	        String badText = null;
+	        if (start != null) {
+	            int i = start.getTokenIndex();
+	            int j = stop.getTokenIndex();
+	            if (stop.getType() == Token.EOF) {
+	                j = input.size();
+	            }
+	            badText = ((TokenStream)input).toString(i, j);
+	        } else {
+	            // people should subclass if they alter the tree type so this
+	            // next one is for sure correct.
+	            badText = "<unknown>";
+	        }
+	        return badText;
+	    }
+
+	    @Override
+	    public void setText(String value) { }
+
+	    @Override
+	    public int getType() { return Token.INVALID_TOKEN_TYPE; }
+
+	    @Override
+	    public void setType(int value) { }
+
+	    @Override
+	    public String toString()
+	    {
+	        if (trappedException instanceof MissingTokenException)
+	        {
+	            return "<missing type: " +
+	                   ( (MissingTokenException)trappedException ).getMissingType() +
+	                   ">";
+	        } else if (trappedException instanceof UnwantedTokenException) {
+	            return "<extraneous: " +
+	                   ( (UnwantedTokenException)trappedException ).getUnexpectedToken() +
+	                   ", resync=" + getText() + ">";
+	        } else if (trappedException instanceof MismatchedTokenException) {
+	            return "<mismatched token: " + trappedException.token + ", resync=" + getText() + ">";
+	        } else if (trappedException instanceof NoViableAltException) {
+	            return "<unexpected: " + trappedException.token +
+	                   ", resync=" + getText() + ">";
+	        }
+	        return "<error: " + getText() + ">";
+	    }
+	}
+
+	static class grammar_Adaptor extends CommonTreeAdaptor {
+	    ANTLRParser _outer;
+
+	    public grammar_Adaptor(ANTLRParser outer) {
+	        _outer = outer;
+	    }
+
+	    @Override
+	    public Object create(Token payload) {
+	        GrammarAST t = new GrammarAST( payload );
+	        if (_outer != null)
+	            t.enclosingRuleName = _outer.currentRuleName;
+	        return t;
+	    }
+
+	    @Override
+	    public Object errorNode(TokenStream input, Token start, Token stop, RecognitionException e) {
+	        GrammarAST t = new GrammarASTErrorNode(input, start, stop, e);
+	        if (_outer != null)
+	            t.enclosingRuleName = _outer.currentRuleName;
+	        return t;
+	    }
+	}
+
+	private Grammar grammar;
+	private int grammarType;
+	private String fileName;
+
+	public Grammar getGrammar() {
+	    return grammar;
+	}
+
+	public void setGrammar(Grammar value) {
+	    grammar = value;
+	}
+
+	public int getGrammarType() {
+	    return grammarType;
+	}
+
+	public void setGrammarType(int value) {
+	    grammarType = value;
+	}
+
+	public String getFileName() {
+	    return fileName;
+	}
+
+	public void setFileName(String value) {
+	    fileName = value;
+	}
+
+	private final int LA(int i) { return input.LA( i ); }
+
+	private final Token LT(int k) { return input.LT( k ); }
+
+	/*partial void createTreeAdaptor(ref ITreeAdaptor adaptor)
+	{
+	    adaptor = new grammar_Adaptor(this);
+	}*/
+
+	protected GrammarAST setToBlockWithSet(GrammarAST b) {
+	    /*
+	     * alt = ^(ALT["ALT"] {b} EOA["EOA"])
+	     * prefixWithSynpred( alt )
+	     * return ^(BLOCK["BLOCK"] {alt} EOB["<end-of-block>"])
+	     */
+	    GrammarAST alt = (GrammarAST)adaptor.create(ALT, "ALT");
+	    adaptor.addChild(alt, b);
+	    adaptor.addChild(alt, adaptor.create(EOA, "<end-of-alt>"));
+
+	    prefixWithSynPred(alt);
+
+	    GrammarAST block = (GrammarAST)adaptor.create(BLOCK, b.getToken(), "BLOCK");
+	    adaptor.addChild(block, alt);
+	    adaptor.addChild(alt, adaptor.create(EOB, "<end-of-block>"));
+
+	    return block;
+	}
+
+	/** Create a copy of the alt and make it into a BLOCK; all actions,
+	 *  labels, tree operators, rewrites are removed.
+	 */
+	protected GrammarAST createBlockFromDupAlt(GrammarAST alt) {
+	    /*
+	     * ^(BLOCK["BLOCK"] {GrammarAST.dupTreeNoActions(alt)} EOB["<end-of-block>"])
+	     */
+	    GrammarAST nalt = GrammarAST.dupTreeNoActions(alt, null);
+
+	    GrammarAST block = (GrammarAST)adaptor.create(BLOCK, alt.getToken(), "BLOCK");
+	    adaptor.addChild( block, nalt );
+	    adaptor.addChild( block, adaptor.create( EOB, "<end-of-block>" ) );
+
+	    return block;
+	}
+
+	/** Rewrite alt to have a synpred as first element;
+	 *  (xxx)=&gt;xxx
+	 *  but only if they didn't specify one manually.
+	 */
+	protected void prefixWithSynPred( GrammarAST alt ) {
+	    // if they want backtracking and it's not a lexer rule in combined grammar
+	    String autoBacktrack = (String)grammar.getBlockOption( currentBlockAST, "backtrack" );
+	    if ( autoBacktrack == null )
+	    {
+	        autoBacktrack = (String)grammar.getOption( "backtrack" );
+	    }
+	    if ( autoBacktrack != null && autoBacktrack.equals( "true" ) &&
+	         !( grammarType == Grammar.COMBINED &&
+	         Rule.getRuleType(currentRuleName) == Grammar.LEXER) &&
+	         alt.getChild( 0 ).getType() != SYN_SEMPRED )
+	    {
+	        // duplicate alt and make a synpred block around that dup'd alt
+	        GrammarAST synpredBlockAST = createBlockFromDupAlt( alt );
+
+	        // Create a BACKTRACK_SEMPRED node as if user had typed this in
+	        // Effectively we replace (xxx)=>xxx with {synpredxxx}? xxx
+	        GrammarAST synpredAST = createSynSemPredFromBlock( synpredBlockAST,
+	                                                          BACKTRACK_SEMPRED );
+
+	        // insert BACKTRACK_SEMPRED as first element of alt
+	        //synpredAST.getLastSibling().setNextSibling( alt.getFirstChild() );
+	        //synpredAST.addChild( alt.getFirstChild() );
+	        //alt.setFirstChild( synpredAST );
+	        GrammarAST[] children = alt.getChildrenAsArray();
+	        adaptor.setChild( alt, 0, synpredAST );
+	        for ( int i = 0; i < children.length; i++ )
+	        {
+	            if ( i < children.length - 1 )
+	                adaptor.setChild( alt, i + 1, children[i] );
+	            else
+	                adaptor.addChild( alt, children[i] );
+	        }
+	    }
+	}
+
+	protected GrammarAST createSynSemPredFromBlock( GrammarAST synpredBlockAST, int synpredTokenType ) {
+	    // add grammar fragment to a list so we can make fake rules for them later.
+	    String predName = grammar.defineSyntacticPredicate( synpredBlockAST, currentRuleName );
+	    // convert (alpha)=> into {synpredN}? where N is some pred count
+	    // during code gen we convert to function call with templates
+	    String synpredinvoke = predName;
+	    GrammarAST p = (GrammarAST)adaptor.create( synpredTokenType, synpredinvoke );
+	    // track how many decisions have synpreds
+	    grammar.blocksWithSynPreds.add( currentBlockAST );
+	    return p;
+	}
+
+	public static GrammarAST createSimpleRuleAST( String name, GrammarAST block, boolean fragment ) {
+	    TreeAdaptor adaptor = new grammar_Adaptor(null);
+
+	    GrammarAST modifier = null;
+	    if ( fragment )
+	    {
+	        modifier = (GrammarAST)adaptor.create( FRAGMENT, "fragment" );
+	    }
+
+	    /*
+	     * EOBAST = block.getLastChild()
+	     * ^(RULE[block,"rule"] ID["name"] {modifier} ARG["ARG"] RET["RET"] SCOPE["scope"] {block} EOR[EOBAST,"<end-of-rule>"])
+	     */
+	    GrammarAST rule = (GrammarAST)adaptor.create( RULE, block.getToken(), "rule" );
+
+	    adaptor.addChild( rule, adaptor.create( ID, name ) );
+	    if ( modifier != null )
+	        adaptor.addChild( rule, modifier );
+	    adaptor.addChild( rule, adaptor.create( ARG, "ARG" ) );
+	    adaptor.addChild( rule, adaptor.create( RET, "RET" ) );
+	    adaptor.addChild( rule, adaptor.create( SCOPE, "scope" ) );
+	    adaptor.addChild( rule, block );
+	    adaptor.addChild( rule, adaptor.create( EOR, block.getLastChild().getToken(), "<end-of-rule>" ) );
+
+	    return rule;
+	}
+
+	@Override
+	public void reportError(RecognitionException ex)
+	{
+	    //Token token = null;
+	    //try
+	    //{
+	    //    token = LT( 1 );
+	    //}
+	    //catch ( TokenStreamException tse )
+	    //{
+	    //    ErrorManager.internalError( "can't get token???", tse );
+	    //}
+	    Token token = ex.token;
+	    ErrorManager.syntaxError(
+	        ErrorManager.MSG_SYNTAX_ERROR,
+	        grammar,
+	        token,
+	        "antlr: " + ex.toString(),
+	        ex );
+	}
+
+	public void cleanup( GrammarAST root )
+	{
+	    if ( grammarType == Grammar.LEXER )
+	    {
+	        String filter = (String)grammar.getOption( "filter" );
+	        GrammarAST tokensRuleAST =
+	            grammar.addArtificialMatchTokensRule(
+	                root,
+	                grammar.lexerRuleNamesInCombined,
+	                grammar.getDelegateNames(),
+	                filter != null && filter.equals( "true" ) );
+	    }
+	}
+
+
+	public static class grammar__return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "grammar_"
+	// org/antlr/grammar/v3/ANTLR.g:457:1: public grammar_[Grammar g] : ( ACTION )? (cmt= DOC_COMMENT )? gr= grammarType gid= id SEMI ( optionsSpec )? (ig= delegateGrammars )? (ts= tokensSpec )? scopes= attrScopes (a= actions )? r= rules EOF -> ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r) ;
+	public final ANTLRParser.grammar__return grammar_(Grammar g) throws RecognitionException {
+		ANTLRParser.grammar__return retval = new ANTLRParser.grammar__return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token cmt=null;
+		Token ACTION1=null;
+		Token SEMI2=null;
+		Token EOF4=null;
+		ParserRuleReturnScope gr =null;
+		ParserRuleReturnScope gid =null;
+		ParserRuleReturnScope ig =null;
+		ParserRuleReturnScope ts =null;
+		ParserRuleReturnScope scopes =null;
+		ParserRuleReturnScope a =null;
+		ParserRuleReturnScope r =null;
+		ParserRuleReturnScope optionsSpec3 =null;
+
+		GrammarAST cmt_tree=null;
+		GrammarAST ACTION1_tree=null;
+		GrammarAST SEMI2_tree=null;
+		GrammarAST EOF4_tree=null;
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_SEMI=new RewriteRuleTokenStream(adaptor,"token SEMI");
+		RewriteRuleTokenStream stream_DOC_COMMENT=new RewriteRuleTokenStream(adaptor,"token DOC_COMMENT");
+		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
+		RewriteRuleSubtreeStream stream_tokensSpec=new RewriteRuleSubtreeStream(adaptor,"rule tokensSpec");
+		RewriteRuleSubtreeStream stream_grammarType=new RewriteRuleSubtreeStream(adaptor,"rule grammarType");
+		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
+		RewriteRuleSubtreeStream stream_delegateGrammars=new RewriteRuleSubtreeStream(adaptor,"rule delegateGrammars");
+		RewriteRuleSubtreeStream stream_rules=new RewriteRuleSubtreeStream(adaptor,"rule rules");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_actions=new RewriteRuleSubtreeStream(adaptor,"rule actions");
+		RewriteRuleSubtreeStream stream_attrScopes=new RewriteRuleSubtreeStream(adaptor,"rule attrScopes");
+
+
+			this.grammar = g;
+			Map<String, Object> opts;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:467:2: ( ( ACTION )? (cmt= DOC_COMMENT )? gr= grammarType gid= id SEMI ( optionsSpec )? (ig= delegateGrammars )? (ts= tokensSpec )? scopes= attrScopes (a= actions )? r= rules EOF -> ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r) )
+			// org/antlr/grammar/v3/ANTLR.g:468:3: ( ACTION )? (cmt= DOC_COMMENT )? gr= grammarType gid= id SEMI ( optionsSpec )? (ig= delegateGrammars )? (ts= tokensSpec )? scopes= attrScopes (a= actions )? r= rules EOF
+			{
+			// org/antlr/grammar/v3/ANTLR.g:468:3: ( ACTION )?
+			int alt1=2;
+			int LA1_0 = input.LA(1);
+			if ( (LA1_0==ACTION) ) {
+				alt1=1;
+			}
+			switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:468:5: ACTION
+					{
+					ACTION1=(Token)match(input,ACTION,FOLLOW_ACTION_in_grammar_324); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ACTION.add(ACTION1);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:469:3: (cmt= DOC_COMMENT )?
+			int alt2=2;
+			int LA2_0 = input.LA(1);
+			if ( (LA2_0==DOC_COMMENT) ) {
+				alt2=1;
+			}
+			switch (alt2) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:469:5: cmt= DOC_COMMENT
+					{
+					cmt=(Token)match(input,DOC_COMMENT,FOLLOW_DOC_COMMENT_in_grammar_335); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_DOC_COMMENT.add(cmt);
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_grammarType_in_grammar_345);
+			gr=grammarType();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_grammarType.add(gr.getTree());
+			pushFollow(FOLLOW_id_in_grammar_349);
+			gid=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(gid.getTree());
+			if ( state.backtracking==0 ) {grammar.setName((gid!=null?input.toString(gid.start,gid.stop):null));}
+			SEMI2=(Token)match(input,SEMI,FOLLOW_SEMI_in_grammar_353); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_SEMI.add(SEMI2);
+
+			// org/antlr/grammar/v3/ANTLR.g:471:3: ( optionsSpec )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+			if ( (LA3_0==OPTIONS) ) {
+				alt3=1;
+			}
+			switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:471:5: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_grammar_359);
+					optionsSpec3=optionsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_optionsSpec.add(optionsSpec3.getTree());
+					if ( state.backtracking==0 ) {opts = (optionsSpec3!=null?((ANTLRParser.optionsSpec_return)optionsSpec3).opts:null); grammar.setOptions(opts, (optionsSpec3!=null?(optionsSpec3.start):null));}
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:473:3: (ig= delegateGrammars )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+			if ( (LA4_0==IMPORT) ) {
+				alt4=1;
+			}
+			switch (alt4) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:473:4: ig= delegateGrammars
+					{
+					pushFollow(FOLLOW_delegateGrammars_in_grammar_373);
+					ig=delegateGrammars();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_delegateGrammars.add(ig.getTree());
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:474:3: (ts= tokensSpec )?
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+			if ( (LA5_0==TOKENS) ) {
+				alt5=1;
+			}
+			switch (alt5) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:474:4: ts= tokensSpec
+					{
+					pushFollow(FOLLOW_tokensSpec_in_grammar_382);
+					ts=tokensSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_tokensSpec.add(ts.getTree());
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_attrScopes_in_grammar_390);
+			scopes=attrScopes();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_attrScopes.add(scopes.getTree());
+			// org/antlr/grammar/v3/ANTLR.g:476:3: (a= actions )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+			if ( (LA6_0==AMPERSAND) ) {
+				alt6=1;
+			}
+			switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:476:4: a= actions
+					{
+					pushFollow(FOLLOW_actions_in_grammar_397);
+					a=actions();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_actions.add(a.getTree());
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_rules_in_grammar_405);
+			r=rules();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rules.add(r.getTree());
+			EOF4=(Token)match(input,EOF,FOLLOW_EOF_in_grammar_409); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_EOF.add(EOF4);
+
+			// AST REWRITE
+			// elements: r, scopes, cmt, ig, gr, a, gid, ts, optionsSpec
+			// token labels: cmt
+			// rule labels: a, r, gid, scopes, gr, ig, retval, ts
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleTokenStream stream_cmt=new RewriteRuleTokenStream(adaptor,"token cmt",cmt);
+			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.getTree():null);
+			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.getTree():null);
+			RewriteRuleSubtreeStream stream_gid=new RewriteRuleSubtreeStream(adaptor,"rule gid",gid!=null?gid.getTree():null);
+			RewriteRuleSubtreeStream stream_scopes=new RewriteRuleSubtreeStream(adaptor,"rule scopes",scopes!=null?scopes.getTree():null);
+			RewriteRuleSubtreeStream stream_gr=new RewriteRuleSubtreeStream(adaptor,"rule gr",gr!=null?gr.getTree():null);
+			RewriteRuleSubtreeStream stream_ig=new RewriteRuleSubtreeStream(adaptor,"rule ig",ig!=null?ig.getTree():null);
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+			RewriteRuleSubtreeStream stream_ts=new RewriteRuleSubtreeStream(adaptor,"rule ts",ts!=null?ts.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 479:3: -> ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r)
+			{
+				// org/antlr/grammar/v3/ANTLR.g:479:6: ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r)
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot(stream_gr.nextNode(), root_1);
+				adaptor.addChild(root_1, stream_gid.nextTree());
+				// org/antlr/grammar/v3/ANTLR.g:479:18: ( $cmt)?
+				if ( stream_cmt.hasNext() ) {
+					adaptor.addChild(root_1, stream_cmt.nextNode());
+				}
+				stream_cmt.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:479:23: ( optionsSpec )?
+				if ( stream_optionsSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_optionsSpec.nextTree());
+				}
+				stream_optionsSpec.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:479:37: ( $ig)?
+				if ( stream_ig.hasNext() ) {
+					adaptor.addChild(root_1, stream_ig.nextTree());
+				}
+				stream_ig.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:479:42: ( $ts)?
+				if ( stream_ts.hasNext() ) {
+					adaptor.addChild(root_1, stream_ts.nextTree());
+				}
+				stream_ts.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:479:47: ( $scopes)?
+				if ( stream_scopes.hasNext() ) {
+					adaptor.addChild(root_1, stream_scopes.nextTree());
+				}
+				stream_scopes.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:479:56: ( $a)?
+				if ( stream_a.hasNext() ) {
+					adaptor.addChild(root_1, stream_a.nextTree());
+				}
+				stream_a.reset();
+
+				adaptor.addChild(root_1, stream_r.nextTree());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+			if ( state.backtracking==0 ) {
+				cleanup( retval.tree );
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "grammar_"
+
+
+	public static class grammarType_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "grammarType"
+	// org/antlr/grammar/v3/ANTLR.g:482:1: grammarType : ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] ) ;
+	public final ANTLRParser.grammarType_return grammarType() throws RecognitionException {
+		ANTLRParser.grammarType_return retval = new ANTLRParser.grammarType_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token gr=null;
+		Token string_literal5=null;
+		Token string_literal6=null;
+		Token string_literal7=null;
+
+		GrammarAST gr_tree=null;
+		GrammarAST string_literal5_tree=null;
+		GrammarAST string_literal6_tree=null;
+		GrammarAST string_literal7_tree=null;
+		RewriteRuleTokenStream stream_PARSER=new RewriteRuleTokenStream(adaptor,"token PARSER");
+		RewriteRuleTokenStream stream_LEXER=new RewriteRuleTokenStream(adaptor,"token LEXER");
+		RewriteRuleTokenStream stream_GRAMMAR=new RewriteRuleTokenStream(adaptor,"token GRAMMAR");
+		RewriteRuleTokenStream stream_TREE=new RewriteRuleTokenStream(adaptor,"token TREE");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:483:2: ( ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] ) )
+			// org/antlr/grammar/v3/ANTLR.g:483:4: ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] )
+			{
+			// org/antlr/grammar/v3/ANTLR.g:483:4: ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] )
+			int alt7=4;
+			switch ( input.LA(1) ) {
+			case LEXER:
+				{
+				alt7=1;
+				}
+				break;
+			case PARSER:
+				{
+				alt7=2;
+				}
+				break;
+			case TREE:
+				{
+				alt7=3;
+				}
+				break;
+			case GRAMMAR:
+				{
+				alt7=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 7, 0, input);
+				throw nvae;
+			}
+			switch (alt7) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:483:6: 'lexer' gr= 'grammar'
+					{
+					string_literal5=(Token)match(input,LEXER,FOLLOW_LEXER_in_grammarType460); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_LEXER.add(string_literal5);
+
+					gr=(Token)match(input,GRAMMAR,FOLLOW_GRAMMAR_in_grammarType465); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_GRAMMAR.add(gr);
+
+					if ( state.backtracking==0 ) {grammarType=Grammar.LEXER; grammar.type = Grammar.LEXER;}
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 484:4: -> LEXER_GRAMMAR[$gr]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(LEXER_GRAMMAR, gr));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:485:5: 'parser' gr= 'grammar'
+					{
+					string_literal6=(Token)match(input,PARSER,FOLLOW_PARSER_in_grammarType488); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_PARSER.add(string_literal6);
+
+					gr=(Token)match(input,GRAMMAR,FOLLOW_GRAMMAR_in_grammarType492); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_GRAMMAR.add(gr);
+
+					if ( state.backtracking==0 ) {grammarType=Grammar.PARSER; grammar.type = Grammar.PARSER;}
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 486:4: -> PARSER_GRAMMAR[$gr]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(PARSER_GRAMMAR, gr));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:487:5: 'tree' gr= 'grammar'
+					{
+					string_literal7=(Token)match(input,TREE,FOLLOW_TREE_in_grammarType513); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_TREE.add(string_literal7);
+
+					gr=(Token)match(input,GRAMMAR,FOLLOW_GRAMMAR_in_grammarType519); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_GRAMMAR.add(gr);
+
+					if ( state.backtracking==0 ) {grammarType=Grammar.TREE_PARSER; grammar.type = Grammar.TREE_PARSER;}
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 488:4: -> TREE_GRAMMAR[$gr]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(TREE_GRAMMAR, gr));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:489:8: gr= 'grammar'
+					{
+					gr=(Token)match(input,GRAMMAR,FOLLOW_GRAMMAR_in_grammarType542); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_GRAMMAR.add(gr);
+
+					if ( state.backtracking==0 ) {grammarType=Grammar.COMBINED; grammar.type = Grammar.COMBINED;}
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 490:4: -> COMBINED_GRAMMAR[$gr]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(COMBINED_GRAMMAR, gr));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "grammarType"
+
+
+	public static class actions_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "actions"
+	// org/antlr/grammar/v3/ANTLR.g:494:1: actions : ( action )+ ;
+	public final ANTLRParser.actions_return actions() throws RecognitionException {
+		ANTLRParser.actions_return retval = new ANTLRParser.actions_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ParserRuleReturnScope action8 =null;
+
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:495:2: ( ( action )+ )
+			// org/antlr/grammar/v3/ANTLR.g:495:4: ( action )+
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			// org/antlr/grammar/v3/ANTLR.g:495:4: ( action )+
+			int cnt8=0;
+			loop8:
+			while (true) {
+				int alt8=2;
+				int LA8_0 = input.LA(1);
+				if ( (LA8_0==AMPERSAND) ) {
+					alt8=1;
+				}
+
+				switch (alt8) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:495:5: action
+					{
+					pushFollow(FOLLOW_action_in_actions569);
+					action8=action();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, action8.getTree());
+
+					}
+					break;
+
+				default :
+					if ( cnt8 >= 1 ) break loop8;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(8, input);
+					throw eee;
+				}
+				cnt8++;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "actions"
+
+
+	public static class action_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "action"
+	// org/antlr/grammar/v3/ANTLR.g:499:1: action : AMPERSAND ^ ( actionScopeName COLON ! COLON !)? id ACTION ;
+	public final ANTLRParser.action_return action() throws RecognitionException {
+		ANTLRParser.action_return retval = new ANTLRParser.action_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token AMPERSAND9=null;
+		Token COLON11=null;
+		Token COLON12=null;
+		Token ACTION14=null;
+		ParserRuleReturnScope actionScopeName10 =null;
+		ParserRuleReturnScope id13 =null;
+
+		GrammarAST AMPERSAND9_tree=null;
+		GrammarAST COLON11_tree=null;
+		GrammarAST COLON12_tree=null;
+		GrammarAST ACTION14_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:500:2: ( AMPERSAND ^ ( actionScopeName COLON ! COLON !)? id ACTION )
+			// org/antlr/grammar/v3/ANTLR.g:500:4: AMPERSAND ^ ( actionScopeName COLON ! COLON !)? id ACTION
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			AMPERSAND9=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_action584); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			AMPERSAND9_tree = (GrammarAST)adaptor.create(AMPERSAND9);
+			root_0 = (GrammarAST)adaptor.becomeRoot(AMPERSAND9_tree, root_0);
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:500:15: ( actionScopeName COLON ! COLON !)?
+			int alt9=2;
+			switch ( input.LA(1) ) {
+				case TOKEN_REF:
+					{
+					int LA9_1 = input.LA(2);
+					if ( (LA9_1==COLON) ) {
+						alt9=1;
+					}
+					}
+					break;
+				case RULE_REF:
+					{
+					int LA9_2 = input.LA(2);
+					if ( (LA9_2==COLON) ) {
+						alt9=1;
+					}
+					}
+					break;
+				case LEXER:
+				case PARSER:
+					{
+					alt9=1;
+					}
+					break;
+			}
+			switch (alt9) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:500:16: actionScopeName COLON ! COLON !
+					{
+					pushFollow(FOLLOW_actionScopeName_in_action588);
+					actionScopeName10=actionScopeName();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, actionScopeName10.getTree());
+
+					COLON11=(Token)match(input,COLON,FOLLOW_COLON_in_action590); if (state.failed) return retval;
+					COLON12=(Token)match(input,COLON,FOLLOW_COLON_in_action593); if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_id_in_action598);
+			id13=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, id13.getTree());
+
+			ACTION14=(Token)match(input,ACTION,FOLLOW_ACTION_in_action600); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ACTION14_tree = (GrammarAST)adaptor.create(ACTION14);
+			adaptor.addChild(root_0, ACTION14_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "action"
+
+
+	public static class actionScopeName_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "actionScopeName"
+	// org/antlr/grammar/v3/ANTLR.g:506:1: actionScopeName : ( id |l= 'lexer' -> ID[$l] |p= 'parser' -> ID[$p] );
+	public final ANTLRParser.actionScopeName_return actionScopeName() throws RecognitionException {
+		ANTLRParser.actionScopeName_return retval = new ANTLRParser.actionScopeName_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token l=null;
+		Token p=null;
+		ParserRuleReturnScope id15 =null;
+
+		GrammarAST l_tree=null;
+		GrammarAST p_tree=null;
+		RewriteRuleTokenStream stream_PARSER=new RewriteRuleTokenStream(adaptor,"token PARSER");
+		RewriteRuleTokenStream stream_LEXER=new RewriteRuleTokenStream(adaptor,"token LEXER");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:507:2: ( id |l= 'lexer' -> ID[$l] |p= 'parser' -> ID[$p] )
+			int alt10=3;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+			case TOKEN_REF:
+				{
+				alt10=1;
+				}
+				break;
+			case LEXER:
+				{
+				alt10=2;
+				}
+				break;
+			case PARSER:
+				{
+				alt10=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 10, 0, input);
+				throw nvae;
+			}
+			switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:507:4: id
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_id_in_actionScopeName613);
+					id15=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, id15.getTree());
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:508:4: l= 'lexer'
+					{
+					l=(Token)match(input,LEXER,FOLLOW_LEXER_in_actionScopeName620); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_LEXER.add(l);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 509:3: -> ID[$l]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(ID, l));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:510:4: p= 'parser'
+					{
+					p=(Token)match(input,PARSER,FOLLOW_PARSER_in_actionScopeName634); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_PARSER.add(p);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 511:3: -> ID[$p]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(ID, p));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "actionScopeName"
+
+
+	public static class optionsSpec_return extends ParserRuleReturnScope {
+		public Map<String, Object> opts=new HashMap<String, Object>();
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "optionsSpec"
+	// org/antlr/grammar/v3/ANTLR.g:514:1: optionsSpec returns [Map<String, Object> opts=new HashMap<String, Object>()] : OPTIONS ^ ( option[$opts] SEMI !)+ RCURLY !;
+	public final ANTLRParser.optionsSpec_return optionsSpec() throws RecognitionException {
+		ANTLRParser.optionsSpec_return retval = new ANTLRParser.optionsSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token OPTIONS16=null;
+		Token SEMI18=null;
+		Token RCURLY19=null;
+		ParserRuleReturnScope option17 =null;
+
+		GrammarAST OPTIONS16_tree=null;
+		GrammarAST SEMI18_tree=null;
+		GrammarAST RCURLY19_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:515:2: ( OPTIONS ^ ( option[$opts] SEMI !)+ RCURLY !)
+			// org/antlr/grammar/v3/ANTLR.g:515:4: OPTIONS ^ ( option[$opts] SEMI !)+ RCURLY !
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			OPTIONS16=(Token)match(input,OPTIONS,FOLLOW_OPTIONS_in_optionsSpec656); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			OPTIONS16_tree = (GrammarAST)adaptor.create(OPTIONS16);
+			root_0 = (GrammarAST)adaptor.becomeRoot(OPTIONS16_tree, root_0);
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:515:13: ( option[$opts] SEMI !)+
+			int cnt11=0;
+			loop11:
+			while (true) {
+				int alt11=2;
+				int LA11_0 = input.LA(1);
+				if ( (LA11_0==RULE_REF||LA11_0==TOKEN_REF) ) {
+					alt11=1;
+				}
+
+				switch (alt11) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:515:14: option[$opts] SEMI !
+					{
+					pushFollow(FOLLOW_option_in_optionsSpec660);
+					option17=option(retval.opts);
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, option17.getTree());
+
+					SEMI18=(Token)match(input,SEMI,FOLLOW_SEMI_in_optionsSpec663); if (state.failed) return retval;
+					}
+					break;
+
+				default :
+					if ( cnt11 >= 1 ) break loop11;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(11, input);
+					throw eee;
+				}
+				cnt11++;
+			}
+
+			RCURLY19=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_optionsSpec668); if (state.failed) return retval;
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "optionsSpec"
+
+
+	public static class option_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "option"
+	// org/antlr/grammar/v3/ANTLR.g:518:1: option[Map<String, Object> opts] : id ASSIGN ^ optionValue ;
+	public final ANTLRParser.option_return option(Map<String, Object> opts) throws RecognitionException {
+		ANTLRParser.option_return retval = new ANTLRParser.option_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token ASSIGN21=null;
+		ParserRuleReturnScope id20 =null;
+		ParserRuleReturnScope optionValue22 =null;
+
+		GrammarAST ASSIGN21_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:519:2: ( id ASSIGN ^ optionValue )
+			// org/antlr/grammar/v3/ANTLR.g:519:4: id ASSIGN ^ optionValue
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			pushFollow(FOLLOW_id_in_option681);
+			id20=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, id20.getTree());
+
+			ASSIGN21=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_option683); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ASSIGN21_tree = (GrammarAST)adaptor.create(ASSIGN21);
+			root_0 = (GrammarAST)adaptor.becomeRoot(ASSIGN21_tree, root_0);
+			}
+
+			pushFollow(FOLLOW_optionValue_in_option686);
+			optionValue22=optionValue();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, optionValue22.getTree());
+
+			if ( state.backtracking==0 ) {
+						opts.put((id20!=null?input.toString(id20.start,id20.stop):null), (optionValue22!=null?((ANTLRParser.optionValue_return)optionValue22).value:null));
+					}
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "option"
+
+
+	public static class optionValue_return extends ParserRuleReturnScope {
+		public Object value = null;
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "optionValue"
+	// org/antlr/grammar/v3/ANTLR.g:525:1: optionValue returns [Object value = null] : (x= id |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT |ss= STAR -> STRING_LITERAL[$ss] );
+	public final ANTLRParser.optionValue_return optionValue() throws RecognitionException {
+		ANTLRParser.optionValue_return retval = new ANTLRParser.optionValue_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token s=null;
+		Token c=null;
+		Token i=null;
+		Token ss=null;
+		ParserRuleReturnScope x =null;
+
+		GrammarAST s_tree=null;
+		GrammarAST c_tree=null;
+		GrammarAST i_tree=null;
+		GrammarAST ss_tree=null;
+		RewriteRuleTokenStream stream_STAR=new RewriteRuleTokenStream(adaptor,"token STAR");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:526:2: (x= id |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT |ss= STAR -> STRING_LITERAL[$ss] )
+			int alt12=5;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+			case TOKEN_REF:
+				{
+				alt12=1;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt12=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt12=3;
+				}
+				break;
+			case INT:
+				{
+				alt12=4;
+				}
+				break;
+			case STAR:
+				{
+				alt12=5;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 12, 0, input);
+				throw nvae;
+			}
+			switch (alt12) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:526:4: x= id
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_id_in_optionValue707);
+					x=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, x.getTree());
+
+					if ( state.backtracking==0 ) {retval.value = (x!=null?input.toString(x.start,x.stop):null);}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:527:4: s= STRING_LITERAL
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					s=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_optionValue719); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					s_tree = (GrammarAST)adaptor.create(s);
+					adaptor.addChild(root_0, s_tree);
+					}
+
+					if ( state.backtracking==0 ) {String vs = (s!=null?s.getText():null);
+											  // remove the quotes:
+											  retval.value =vs.substring(1,vs.length()-1);}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:530:4: c= CHAR_LITERAL
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					c=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_optionValue728); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					c_tree = (GrammarAST)adaptor.create(c);
+					adaptor.addChild(root_0, c_tree);
+					}
+
+					if ( state.backtracking==0 ) {String vs = (c!=null?c.getText():null);
+											  // remove the quotes:
+											  retval.value =vs.substring(1,vs.length()-1);}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:533:4: i= INT
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					i=(Token)match(input,INT,FOLLOW_INT_in_optionValue739); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					i_tree = (GrammarAST)adaptor.create(i);
+					adaptor.addChild(root_0, i_tree);
+					}
+
+					if ( state.backtracking==0 ) {retval.value = Integer.parseInt((i!=null?i.getText():null));}
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLR.g:534:4: ss= STAR
+					{
+					ss=(Token)match(input,STAR,FOLLOW_STAR_in_optionValue759); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_STAR.add(ss);
+
+					if ( state.backtracking==0 ) {retval.value = "*";}
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 535:3: -> STRING_LITERAL[$ss]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(STRING_LITERAL, ss));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "optionValue"
+
+
+	public static class delegateGrammars_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "delegateGrammars"
+	// org/antlr/grammar/v3/ANTLR.g:539:1: delegateGrammars : 'import' ^ delegateGrammar ( COMMA ! delegateGrammar )* SEMI !;
+	public final ANTLRParser.delegateGrammars_return delegateGrammars() throws RecognitionException {
+		ANTLRParser.delegateGrammars_return retval = new ANTLRParser.delegateGrammars_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token string_literal23=null;
+		Token COMMA25=null;
+		Token SEMI27=null;
+		ParserRuleReturnScope delegateGrammar24 =null;
+		ParserRuleReturnScope delegateGrammar26 =null;
+
+		GrammarAST string_literal23_tree=null;
+		GrammarAST COMMA25_tree=null;
+		GrammarAST SEMI27_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:540:2: ( 'import' ^ delegateGrammar ( COMMA ! delegateGrammar )* SEMI !)
+			// org/antlr/grammar/v3/ANTLR.g:540:4: 'import' ^ delegateGrammar ( COMMA ! delegateGrammar )* SEMI !
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			string_literal23=(Token)match(input,IMPORT,FOLLOW_IMPORT_in_delegateGrammars784); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			string_literal23_tree = (GrammarAST)adaptor.create(string_literal23);
+			root_0 = (GrammarAST)adaptor.becomeRoot(string_literal23_tree, root_0);
+			}
+
+			pushFollow(FOLLOW_delegateGrammar_in_delegateGrammars787);
+			delegateGrammar24=delegateGrammar();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, delegateGrammar24.getTree());
+
+			// org/antlr/grammar/v3/ANTLR.g:540:30: ( COMMA ! delegateGrammar )*
+			loop13:
+			while (true) {
+				int alt13=2;
+				int LA13_0 = input.LA(1);
+				if ( (LA13_0==COMMA) ) {
+					alt13=1;
+				}
+
+				switch (alt13) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:540:31: COMMA ! delegateGrammar
+					{
+					COMMA25=(Token)match(input,COMMA,FOLLOW_COMMA_in_delegateGrammars790); if (state.failed) return retval;
+					pushFollow(FOLLOW_delegateGrammar_in_delegateGrammars793);
+					delegateGrammar26=delegateGrammar();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, delegateGrammar26.getTree());
+
+					}
+					break;
+
+				default :
+					break loop13;
+				}
+			}
+
+			SEMI27=(Token)match(input,SEMI,FOLLOW_SEMI_in_delegateGrammars797); if (state.failed) return retval;
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "delegateGrammars"
+
+
+	public static class delegateGrammar_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "delegateGrammar"
+	// org/antlr/grammar/v3/ANTLR.g:543:1: delegateGrammar : (lab= id ASSIGN ^g= id |g2= id );
+	public final ANTLRParser.delegateGrammar_return delegateGrammar() throws RecognitionException {
+		ANTLRParser.delegateGrammar_return retval = new ANTLRParser.delegateGrammar_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token ASSIGN28=null;
+		ParserRuleReturnScope lab =null;
+		ParserRuleReturnScope g =null;
+		ParserRuleReturnScope g2 =null;
+
+		GrammarAST ASSIGN28_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:544:2: (lab= id ASSIGN ^g= id |g2= id )
+			int alt14=2;
+			int LA14_0 = input.LA(1);
+			if ( (LA14_0==TOKEN_REF) ) {
+				int LA14_1 = input.LA(2);
+				if ( (LA14_1==ASSIGN) ) {
+					alt14=1;
+				}
+				else if ( (LA14_1==COMMA||LA14_1==SEMI) ) {
+					alt14=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 14, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+			else if ( (LA14_0==RULE_REF) ) {
+				int LA14_2 = input.LA(2);
+				if ( (LA14_2==ASSIGN) ) {
+					alt14=1;
+				}
+				else if ( (LA14_2==COMMA||LA14_2==SEMI) ) {
+					alt14=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 14, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 14, 0, input);
+				throw nvae;
+			}
+
+			switch (alt14) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:544:4: lab= id ASSIGN ^g= id
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_id_in_delegateGrammar811);
+					lab=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, lab.getTree());
+
+					ASSIGN28=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_delegateGrammar813); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ASSIGN28_tree = (GrammarAST)adaptor.create(ASSIGN28);
+					root_0 = (GrammarAST)adaptor.becomeRoot(ASSIGN28_tree, root_0);
+					}
+
+					pushFollow(FOLLOW_id_in_delegateGrammar818);
+					g=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, g.getTree());
+
+					if ( state.backtracking==0 ) {grammar.importGrammar((g!=null?((GrammarAST)g.getTree()):null), (lab!=null?input.toString(lab.start,lab.stop):null));}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:545:4: g2= id
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_id_in_delegateGrammar827);
+					g2=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, g2.getTree());
+
+					if ( state.backtracking==0 ) {grammar.importGrammar((g2!=null?((GrammarAST)g2.getTree()):null),null);}
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "delegateGrammar"
+
+
+	public static class tokensSpec_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "tokensSpec"
+	// org/antlr/grammar/v3/ANTLR.g:548:1: tokensSpec : TOKENS ^ ( tokenSpec )* RCURLY !;
+	public final ANTLRParser.tokensSpec_return tokensSpec() throws RecognitionException {
+		ANTLRParser.tokensSpec_return retval = new ANTLRParser.tokensSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token TOKENS29=null;
+		Token RCURLY31=null;
+		ParserRuleReturnScope tokenSpec30 =null;
+
+		GrammarAST TOKENS29_tree=null;
+		GrammarAST RCURLY31_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:549:2: ( TOKENS ^ ( tokenSpec )* RCURLY !)
+			// org/antlr/grammar/v3/ANTLR.g:549:4: TOKENS ^ ( tokenSpec )* RCURLY !
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			TOKENS29=(Token)match(input,TOKENS,FOLLOW_TOKENS_in_tokensSpec854); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			TOKENS29_tree = (GrammarAST)adaptor.create(TOKENS29);
+			root_0 = (GrammarAST)adaptor.becomeRoot(TOKENS29_tree, root_0);
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:550:4: ( tokenSpec )*
+			loop15:
+			while (true) {
+				int alt15=2;
+				int LA15_0 = input.LA(1);
+				if ( (LA15_0==TOKEN_REF) ) {
+					alt15=1;
+				}
+
+				switch (alt15) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:550:4: tokenSpec
+					{
+					pushFollow(FOLLOW_tokenSpec_in_tokensSpec860);
+					tokenSpec30=tokenSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, tokenSpec30.getTree());
+
+					}
+					break;
+
+				default :
+					break loop15;
+				}
+			}
+
+			RCURLY31=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_tokensSpec865); if (state.failed) return retval;
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "tokensSpec"
+
+
+	public static class tokenSpec_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "tokenSpec"
+	// org/antlr/grammar/v3/ANTLR.g:554:1: tokenSpec : TOKEN_REF ( ASSIGN ^ ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI !;
+	public final ANTLRParser.tokenSpec_return tokenSpec() throws RecognitionException {
+		ANTLRParser.tokenSpec_return retval = new ANTLRParser.tokenSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token TOKEN_REF32=null;
+		Token ASSIGN33=null;
+		Token set34=null;
+		Token SEMI35=null;
+
+		GrammarAST TOKEN_REF32_tree=null;
+		GrammarAST ASSIGN33_tree=null;
+		GrammarAST set34_tree=null;
+		GrammarAST SEMI35_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:555:2: ( TOKEN_REF ( ASSIGN ^ ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI !)
+			// org/antlr/grammar/v3/ANTLR.g:555:4: TOKEN_REF ( ASSIGN ^ ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI !
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			TOKEN_REF32=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec877); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			TOKEN_REF32_tree = (GrammarAST)adaptor.create(TOKEN_REF32);
+			adaptor.addChild(root_0, TOKEN_REF32_tree);
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:555:14: ( ASSIGN ^ ( STRING_LITERAL | CHAR_LITERAL ) )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+			if ( (LA16_0==ASSIGN) ) {
+				alt16=1;
+			}
+			switch (alt16) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:555:16: ASSIGN ^ ( STRING_LITERAL | CHAR_LITERAL )
+					{
+					ASSIGN33=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_tokenSpec881); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ASSIGN33_tree = (GrammarAST)adaptor.create(ASSIGN33);
+					root_0 = (GrammarAST)adaptor.becomeRoot(ASSIGN33_tree, root_0);
+					}
+
+					set34=input.LT(1);
+					if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL ) {
+						input.consume();
+						if ( state.backtracking==0 ) adaptor.addChild(root_0, (GrammarAST)adaptor.create(set34));
+						state.errorRecovery=false;
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						throw mse;
+					}
+					}
+					break;
+
+			}
+
+			SEMI35=(Token)match(input,SEMI,FOLLOW_SEMI_in_tokenSpec893); if (state.failed) return retval;
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "tokenSpec"
+
+
+	public static class attrScopes_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "attrScopes"
+	// org/antlr/grammar/v3/ANTLR.g:558:1: attrScopes : ( attrScope )* ;
+	public final ANTLRParser.attrScopes_return attrScopes() throws RecognitionException {
+		ANTLRParser.attrScopes_return retval = new ANTLRParser.attrScopes_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ParserRuleReturnScope attrScope36 =null;
+
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:559:2: ( ( attrScope )* )
+			// org/antlr/grammar/v3/ANTLR.g:559:4: ( attrScope )*
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			// org/antlr/grammar/v3/ANTLR.g:559:4: ( attrScope )*
+			loop17:
+			while (true) {
+				int alt17=2;
+				int LA17_0 = input.LA(1);
+				if ( (LA17_0==SCOPE) ) {
+					alt17=1;
+				}
+
+				switch (alt17) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:559:5: attrScope
+					{
+					pushFollow(FOLLOW_attrScope_in_attrScopes906);
+					attrScope36=attrScope();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, attrScope36.getTree());
+
+					}
+					break;
+
+				default :
+					break loop17;
+				}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "attrScopes"
+
+
+	public static class attrScope_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "attrScope"
+	// org/antlr/grammar/v3/ANTLR.g:562:1: attrScope : 'scope' ^ id ( ruleActions )? ACTION ;
+	public final ANTLRParser.attrScope_return attrScope() throws RecognitionException {
+		ANTLRParser.attrScope_return retval = new ANTLRParser.attrScope_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token string_literal37=null;
+		Token ACTION40=null;
+		ParserRuleReturnScope id38 =null;
+		ParserRuleReturnScope ruleActions39 =null;
+
+		GrammarAST string_literal37_tree=null;
+		GrammarAST ACTION40_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:563:2: ( 'scope' ^ id ( ruleActions )? ACTION )
+			// org/antlr/grammar/v3/ANTLR.g:563:4: 'scope' ^ id ( ruleActions )? ACTION
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			string_literal37=(Token)match(input,SCOPE,FOLLOW_SCOPE_in_attrScope919); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			string_literal37_tree = (GrammarAST)adaptor.create(string_literal37);
+			root_0 = (GrammarAST)adaptor.becomeRoot(string_literal37_tree, root_0);
+			}
+
+			pushFollow(FOLLOW_id_in_attrScope922);
+			id38=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, id38.getTree());
+
+			// org/antlr/grammar/v3/ANTLR.g:563:16: ( ruleActions )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+			if ( (LA18_0==AMPERSAND) ) {
+				alt18=1;
+			}
+			switch (alt18) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:563:16: ruleActions
+					{
+					pushFollow(FOLLOW_ruleActions_in_attrScope924);
+					ruleActions39=ruleActions();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, ruleActions39.getTree());
+
+					}
+					break;
+
+			}
+
+			ACTION40=(Token)match(input,ACTION,FOLLOW_ACTION_in_attrScope927); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ACTION40_tree = (GrammarAST)adaptor.create(ACTION40);
+			adaptor.addChild(root_0, ACTION40_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "attrScope"
+
+
+	public static class rules_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rules"
+	// org/antlr/grammar/v3/ANTLR.g:566:1: rules : ( rule )+ ;
+	public final ANTLRParser.rules_return rules() throws RecognitionException {
+		ANTLRParser.rules_return retval = new ANTLRParser.rules_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ParserRuleReturnScope rule41 =null;
+
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:567:2: ( ( rule )+ )
+			// org/antlr/grammar/v3/ANTLR.g:567:4: ( rule )+
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			// org/antlr/grammar/v3/ANTLR.g:567:4: ( rule )+
+			int cnt19=0;
+			loop19:
+			while (true) {
+				int alt19=2;
+				int LA19_0 = input.LA(1);
+				if ( (LA19_0==DOC_COMMENT||LA19_0==FRAGMENT||(LA19_0 >= PRIVATE && LA19_0 <= PUBLIC)||LA19_0==RULE_REF||LA19_0==TOKEN_REF) ) {
+					alt19=1;
+				}
+
+				switch (alt19) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:567:6: rule
+					{
+					pushFollow(FOLLOW_rule_in_rules940);
+					rule41=rule();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rule41.getTree());
+
+					}
+					break;
+
+				default :
+					if ( cnt19 >= 1 ) break loop19;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(19, input);
+					throw eee;
+				}
+				cnt19++;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rules"
+
+
+	public static class rule_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rule"
+	// org/antlr/grammar/v3/ANTLR.g:572:1: public rule : ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON ruleAltList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) ) ;
+	public final ANTLRParser.rule_return rule() throws RecognitionException {
+		ANTLRParser.rule_return retval = new ANTLRParser.rule_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token d=null;
+		Token p1=null;
+		Token p2=null;
+		Token p3=null;
+		Token p4=null;
+		Token aa=null;
+		Token rt=null;
+		Token BANG42=null;
+		Token string_literal43=null;
+		Token COLON47=null;
+		Token SEMI49=null;
+		ParserRuleReturnScope ruleName =null;
+		ParserRuleReturnScope scopes =null;
+		ParserRuleReturnScope ex =null;
+		ParserRuleReturnScope throwsSpec44 =null;
+		ParserRuleReturnScope optionsSpec45 =null;
+		ParserRuleReturnScope ruleActions46 =null;
+		ParserRuleReturnScope ruleAltList48 =null;
+
+		GrammarAST d_tree=null;
+		GrammarAST p1_tree=null;
+		GrammarAST p2_tree=null;
+		GrammarAST p3_tree=null;
+		GrammarAST p4_tree=null;
+		GrammarAST aa_tree=null;
+		GrammarAST rt_tree=null;
+		GrammarAST BANG42_tree=null;
+		GrammarAST string_literal43_tree=null;
+		GrammarAST COLON47_tree=null;
+		GrammarAST SEMI49_tree=null;
+		RewriteRuleTokenStream stream_BANG=new RewriteRuleTokenStream(adaptor,"token BANG");
+		RewriteRuleTokenStream stream_RETURNS=new RewriteRuleTokenStream(adaptor,"token RETURNS");
+		RewriteRuleTokenStream stream_ARG_ACTION=new RewriteRuleTokenStream(adaptor,"token ARG_ACTION");
+		RewriteRuleTokenStream stream_SEMI=new RewriteRuleTokenStream(adaptor,"token SEMI");
+		RewriteRuleTokenStream stream_FRAGMENT=new RewriteRuleTokenStream(adaptor,"token FRAGMENT");
+		RewriteRuleTokenStream stream_PUBLIC=new RewriteRuleTokenStream(adaptor,"token PUBLIC");
+		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
+		RewriteRuleTokenStream stream_DOC_COMMENT=new RewriteRuleTokenStream(adaptor,"token DOC_COMMENT");
+		RewriteRuleTokenStream stream_PROTECTED=new RewriteRuleTokenStream(adaptor,"token PROTECTED");
+		RewriteRuleTokenStream stream_PRIVATE=new RewriteRuleTokenStream(adaptor,"token PRIVATE");
+		RewriteRuleSubtreeStream stream_throwsSpec=new RewriteRuleSubtreeStream(adaptor,"rule throwsSpec");
+		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
+		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_ruleAltList=new RewriteRuleSubtreeStream(adaptor,"rule ruleAltList");
+		RewriteRuleSubtreeStream stream_ruleScopeSpec=new RewriteRuleSubtreeStream(adaptor,"rule ruleScopeSpec");
+		RewriteRuleSubtreeStream stream_exceptionGroup=new RewriteRuleSubtreeStream(adaptor,"rule exceptionGroup");
+
+
+			GrammarAST eob=null;
+			CommonToken start = (CommonToken)LT(1);
+			int startLine = LT(1).getLine();
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:579:2: ( ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON ruleAltList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) ) )
+			// org/antlr/grammar/v3/ANTLR.g:580:2: ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON ruleAltList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) )
+			{
+			// org/antlr/grammar/v3/ANTLR.g:580:2: ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON ruleAltList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) )
+			// org/antlr/grammar/v3/ANTLR.g:580:4: (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON ruleAltList[$optionsSpec.opts] SEMI (ex= exceptionGroup )?
+			{
+			// org/antlr/grammar/v3/ANTLR.g:580:4: (d= DOC_COMMENT )?
+			int alt20=2;
+			int LA20_0 = input.LA(1);
+			if ( (LA20_0==DOC_COMMENT) ) {
+				alt20=1;
+			}
+			switch (alt20) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:580:6: d= DOC_COMMENT
+					{
+					d=(Token)match(input,DOC_COMMENT,FOLLOW_DOC_COMMENT_in_rule970); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_DOC_COMMENT.add(d);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:582:3: (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )?
+			int alt21=5;
+			switch ( input.LA(1) ) {
+				case PROTECTED:
+					{
+					alt21=1;
+					}
+					break;
+				case PUBLIC:
+					{
+					alt21=2;
+					}
+					break;
+				case PRIVATE:
+					{
+					alt21=3;
+					}
+					break;
+				case FRAGMENT:
+					{
+					alt21=4;
+					}
+					break;
+			}
+			switch (alt21) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:582:5: p1= 'protected'
+					{
+					p1=(Token)match(input,PROTECTED,FOLLOW_PROTECTED_in_rule983); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_PROTECTED.add(p1);
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:583:5: p2= 'public'
+					{
+					p2=(Token)match(input,PUBLIC,FOLLOW_PUBLIC_in_rule992); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_PUBLIC.add(p2);
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:584:5: p3= 'private'
+					{
+					p3=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_rule1002); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_PRIVATE.add(p3);
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:585:5: p4= 'fragment'
+					{
+					p4=(Token)match(input,FRAGMENT,FOLLOW_FRAGMENT_in_rule1011); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_FRAGMENT.add(p4);
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_id_in_rule1023);
+			ruleName=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(ruleName.getTree());
+			if ( state.backtracking==0 ) {
+						currentRuleName=(ruleName!=null?input.toString(ruleName.start,ruleName.stop):null);
+						if ( grammarType==Grammar.LEXER && p4==null )
+							grammar.lexerRuleNamesInCombined.add(currentRuleName);
+					}
+			// org/antlr/grammar/v3/ANTLR.g:593:3: ( BANG )?
+			int alt22=2;
+			int LA22_0 = input.LA(1);
+			if ( (LA22_0==BANG) ) {
+				alt22=1;
+			}
+			switch (alt22) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:593:5: BANG
+					{
+					BANG42=(Token)match(input,BANG,FOLLOW_BANG_in_rule1033); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_BANG.add(BANG42);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:594:3: (aa= ARG_ACTION )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+			if ( (LA23_0==ARG_ACTION) ) {
+				alt23=1;
+			}
+			switch (alt23) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:594:5: aa= ARG_ACTION
+					{
+					aa=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule1044); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ARG_ACTION.add(aa);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:595:3: ( 'returns' rt= ARG_ACTION )?
+			int alt24=2;
+			int LA24_0 = input.LA(1);
+			if ( (LA24_0==RETURNS) ) {
+				alt24=1;
+			}
+			switch (alt24) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:595:5: 'returns' rt= ARG_ACTION
+					{
+					string_literal43=(Token)match(input,RETURNS,FOLLOW_RETURNS_in_rule1053); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_RETURNS.add(string_literal43);
+
+					rt=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule1057); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ARG_ACTION.add(rt);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:596:3: ( throwsSpec )?
+			int alt25=2;
+			int LA25_0 = input.LA(1);
+			if ( (LA25_0==THROWS) ) {
+				alt25=1;
+			}
+			switch (alt25) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:596:5: throwsSpec
+					{
+					pushFollow(FOLLOW_throwsSpec_in_rule1067);
+					throwsSpec44=throwsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_throwsSpec.add(throwsSpec44.getTree());
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:597:3: ( optionsSpec )?
+			int alt26=2;
+			int LA26_0 = input.LA(1);
+			if ( (LA26_0==OPTIONS) ) {
+				alt26=1;
+			}
+			switch (alt26) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:597:5: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_rule1076);
+					optionsSpec45=optionsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_optionsSpec.add(optionsSpec45.getTree());
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_ruleScopeSpec_in_rule1085);
+			scopes=ruleScopeSpec();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_ruleScopeSpec.add(scopes.getTree());
+			// org/antlr/grammar/v3/ANTLR.g:599:3: ( ruleActions )?
+			int alt27=2;
+			int LA27_0 = input.LA(1);
+			if ( (LA27_0==AMPERSAND) ) {
+				alt27=1;
+			}
+			switch (alt27) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:599:4: ruleActions
+					{
+					pushFollow(FOLLOW_ruleActions_in_rule1090);
+					ruleActions46=ruleActions();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_ruleActions.add(ruleActions46.getTree());
+					}
+					break;
+
+			}
+
+			COLON47=(Token)match(input,COLON,FOLLOW_COLON_in_rule1096); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_COLON.add(COLON47);
+
+			pushFollow(FOLLOW_ruleAltList_in_rule1100);
+			ruleAltList48=ruleAltList((optionsSpec45!=null?((ANTLRParser.optionsSpec_return)optionsSpec45).opts:null));
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_ruleAltList.add(ruleAltList48.getTree());
+			SEMI49=(Token)match(input,SEMI,FOLLOW_SEMI_in_rule1105); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_SEMI.add(SEMI49);
+
+			// org/antlr/grammar/v3/ANTLR.g:603:3: (ex= exceptionGroup )?
+			int alt28=2;
+			int LA28_0 = input.LA(1);
+			if ( (LA28_0==CATCH||LA28_0==FINALLY) ) {
+				alt28=1;
+			}
+			switch (alt28) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:603:5: ex= exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_rule1113);
+					ex=exceptionGroup();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_exceptionGroup.add(ex.getTree());
+					}
+					break;
+
+			}
+
+			// AST REWRITE
+			// elements: ruleAltList, scopes, throwsSpec, ex, optionsSpec, p1, ruleActions, p3, aa, p2, ruleName, p4, rt
+			// token labels: aa, p1, p2, rt, p3, p4
+			// rule labels: ex, ruleName, scopes, retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleTokenStream stream_aa=new RewriteRuleTokenStream(adaptor,"token aa",aa);
+			RewriteRuleTokenStream stream_p1=new RewriteRuleTokenStream(adaptor,"token p1",p1);
+			RewriteRuleTokenStream stream_p2=new RewriteRuleTokenStream(adaptor,"token p2",p2);
+			RewriteRuleTokenStream stream_rt=new RewriteRuleTokenStream(adaptor,"token rt",rt);
+			RewriteRuleTokenStream stream_p3=new RewriteRuleTokenStream(adaptor,"token p3",p3);
+			RewriteRuleTokenStream stream_p4=new RewriteRuleTokenStream(adaptor,"token p4",p4);
+			RewriteRuleSubtreeStream stream_ex=new RewriteRuleSubtreeStream(adaptor,"rule ex",ex!=null?ex.getTree():null);
+			RewriteRuleSubtreeStream stream_ruleName=new RewriteRuleSubtreeStream(adaptor,"rule ruleName",ruleName!=null?ruleName.getTree():null);
+			RewriteRuleSubtreeStream stream_scopes=new RewriteRuleSubtreeStream(adaptor,"rule scopes",scopes!=null?scopes.getTree():null);
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 604:3: -> ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] )
+			{
+				// org/antlr/grammar/v3/ANTLR.g:604:6: ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(RULE, (ruleName!=null?(ruleName.start):null), "rule"), root_1);
+				adaptor.addChild(root_1, stream_ruleName.nextTree());
+				// org/antlr/grammar/v3/ANTLR.g:607:6: ( $p1)?
+				if ( stream_p1.hasNext() ) {
+					adaptor.addChild(root_1, stream_p1.nextNode());
+				}
+				stream_p1.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:607:11: ( $p2)?
+				if ( stream_p2.hasNext() ) {
+					adaptor.addChild(root_1, stream_p2.nextNode());
+				}
+				stream_p2.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:607:16: ( $p3)?
+				if ( stream_p3.hasNext() ) {
+					adaptor.addChild(root_1, stream_p3.nextNode());
+				}
+				stream_p3.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:607:21: ( $p4)?
+				if ( stream_p4.hasNext() ) {
+					adaptor.addChild(root_1, stream_p4.nextNode());
+				}
+				stream_p4.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:608:5: ^( ARG[\"ARG\"] ( $aa)? )
+				{
+				GrammarAST root_2 = (GrammarAST)adaptor.nil();
+				root_2 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(ARG, "ARG"), root_2);
+				// org/antlr/grammar/v3/ANTLR.g:608:19: ( $aa)?
+				if ( stream_aa.hasNext() ) {
+					adaptor.addChild(root_2, stream_aa.nextNode());
+				}
+				stream_aa.reset();
+
+				adaptor.addChild(root_1, root_2);
+				}
+
+				// org/antlr/grammar/v3/ANTLR.g:609:5: ^( RET[\"RET\"] ( $rt)? )
+				{
+				GrammarAST root_2 = (GrammarAST)adaptor.nil();
+				root_2 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(RET, "RET"), root_2);
+				// org/antlr/grammar/v3/ANTLR.g:609:19: ( $rt)?
+				if ( stream_rt.hasNext() ) {
+					adaptor.addChild(root_2, stream_rt.nextNode());
+				}
+				stream_rt.reset();
+
+				adaptor.addChild(root_1, root_2);
+				}
+
+				// org/antlr/grammar/v3/ANTLR.g:610:5: ( throwsSpec )?
+				if ( stream_throwsSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_throwsSpec.nextTree());
+				}
+				stream_throwsSpec.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:611:5: ( optionsSpec )?
+				if ( stream_optionsSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_optionsSpec.nextTree());
+				}
+				stream_optionsSpec.reset();
+
+				adaptor.addChild(root_1, stream_scopes.nextTree());
+				// org/antlr/grammar/v3/ANTLR.g:613:5: ( ruleActions )?
+				if ( stream_ruleActions.hasNext() ) {
+					adaptor.addChild(root_1, stream_ruleActions.nextTree());
+				}
+				stream_ruleActions.reset();
+
+				adaptor.addChild(root_1, stream_ruleAltList.nextTree());
+				// org/antlr/grammar/v3/ANTLR.g:615:6: ( $ex)?
+				if ( stream_ex.hasNext() ) {
+					adaptor.addChild(root_1, stream_ex.nextTree());
+				}
+				stream_ex.reset();
+
+				adaptor.addChild(root_1, (GrammarAST)adaptor.create(EOR, SEMI49, "<end-of-rule>"));
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			if ( state.backtracking==0 ) {
+					retval.tree.setTreeEnclosingRuleNameDeeply(currentRuleName);
+					((GrammarAST)retval.tree.getChild(0)).setBlockOptions((optionsSpec45!=null?((ANTLRParser.optionsSpec_return)optionsSpec45).opts:null));
+				}
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rule"
+
+
+	public static class ruleActions_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ruleActions"
+	// org/antlr/grammar/v3/ANTLR.g:624:1: ruleActions : ( ruleAction )+ ;
+	public final ANTLRParser.ruleActions_return ruleActions() throws RecognitionException {
+		ANTLRParser.ruleActions_return retval = new ANTLRParser.ruleActions_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ParserRuleReturnScope ruleAction50 =null;
+
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:625:2: ( ( ruleAction )+ )
+			// org/antlr/grammar/v3/ANTLR.g:625:4: ( ruleAction )+
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			// org/antlr/grammar/v3/ANTLR.g:625:4: ( ruleAction )+
+			int cnt29=0;
+			loop29:
+			while (true) {
+				int alt29=2;
+				int LA29_0 = input.LA(1);
+				if ( (LA29_0==AMPERSAND) ) {
+					alt29=1;
+				}
+
+				switch (alt29) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:625:5: ruleAction
+					{
+					pushFollow(FOLLOW_ruleAction_in_ruleActions1251);
+					ruleAction50=ruleAction();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, ruleAction50.getTree());
+
+					}
+					break;
+
+				default :
+					if ( cnt29 >= 1 ) break loop29;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(29, input);
+					throw eee;
+				}
+				cnt29++;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleActions"
+
+
+	public static class ruleAction_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ruleAction"
+	// org/antlr/grammar/v3/ANTLR.g:629:1: ruleAction : AMPERSAND ^ id ACTION ;
+	public final ANTLRParser.ruleAction_return ruleAction() throws RecognitionException {
+		ANTLRParser.ruleAction_return retval = new ANTLRParser.ruleAction_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token AMPERSAND51=null;
+		Token ACTION53=null;
+		ParserRuleReturnScope id52 =null;
+
+		GrammarAST AMPERSAND51_tree=null;
+		GrammarAST ACTION53_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:630:2: ( AMPERSAND ^ id ACTION )
+			// org/antlr/grammar/v3/ANTLR.g:630:4: AMPERSAND ^ id ACTION
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			AMPERSAND51=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_ruleAction1266); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			AMPERSAND51_tree = (GrammarAST)adaptor.create(AMPERSAND51);
+			root_0 = (GrammarAST)adaptor.becomeRoot(AMPERSAND51_tree, root_0);
+			}
+
+			pushFollow(FOLLOW_id_in_ruleAction1269);
+			id52=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, id52.getTree());
+
+			ACTION53=(Token)match(input,ACTION,FOLLOW_ACTION_in_ruleAction1271); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ACTION53_tree = (GrammarAST)adaptor.create(ACTION53);
+			adaptor.addChild(root_0, ACTION53_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleAction"
+
+
+	public static class throwsSpec_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "throwsSpec"
+	// org/antlr/grammar/v3/ANTLR.g:633:1: throwsSpec : 'throws' ^ id ( COMMA ! id )* ;
+	public final ANTLRParser.throwsSpec_return throwsSpec() throws RecognitionException {
+		ANTLRParser.throwsSpec_return retval = new ANTLRParser.throwsSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token string_literal54=null;
+		Token COMMA56=null;
+		ParserRuleReturnScope id55 =null;
+		ParserRuleReturnScope id57 =null;
+
+		GrammarAST string_literal54_tree=null;
+		GrammarAST COMMA56_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:634:2: ( 'throws' ^ id ( COMMA ! id )* )
+			// org/antlr/grammar/v3/ANTLR.g:634:4: 'throws' ^ id ( COMMA ! id )*
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			string_literal54=(Token)match(input,THROWS,FOLLOW_THROWS_in_throwsSpec1282); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			string_literal54_tree = (GrammarAST)adaptor.create(string_literal54);
+			root_0 = (GrammarAST)adaptor.becomeRoot(string_literal54_tree, root_0);
+			}
+
+			pushFollow(FOLLOW_id_in_throwsSpec1285);
+			id55=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, id55.getTree());
+
+			// org/antlr/grammar/v3/ANTLR.g:634:17: ( COMMA ! id )*
+			loop30:
+			while (true) {
+				int alt30=2;
+				int LA30_0 = input.LA(1);
+				if ( (LA30_0==COMMA) ) {
+					alt30=1;
+				}
+
+				switch (alt30) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:634:19: COMMA ! id
+					{
+					COMMA56=(Token)match(input,COMMA,FOLLOW_COMMA_in_throwsSpec1289); if (state.failed) return retval;
+					pushFollow(FOLLOW_id_in_throwsSpec1292);
+					id57=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, id57.getTree());
+
+					}
+					break;
+
+				default :
+					break loop30;
+				}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "throwsSpec"
+
+
+	public static class ruleScopeSpec_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// org/antlr/grammar/v3/ANTLR.g:637:1: ruleScopeSpec : ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )* -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* ) ;
+	public final ANTLRParser.ruleScopeSpec_return ruleScopeSpec() throws RecognitionException {
+		ANTLRParser.ruleScopeSpec_return retval = new ANTLRParser.ruleScopeSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token string_literal58=null;
+		Token ACTION60=null;
+		Token string_literal61=null;
+		Token SEMI63=null;
+		ParserRuleReturnScope ruleActions59 =null;
+		ParserRuleReturnScope idList62 =null;
+
+		GrammarAST string_literal58_tree=null;
+		GrammarAST ACTION60_tree=null;
+		GrammarAST string_literal61_tree=null;
+		GrammarAST SEMI63_tree=null;
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_SCOPE=new RewriteRuleTokenStream(adaptor,"token SCOPE");
+		RewriteRuleTokenStream stream_SEMI=new RewriteRuleTokenStream(adaptor,"token SEMI");
+		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
+		RewriteRuleSubtreeStream stream_idList=new RewriteRuleSubtreeStream(adaptor,"rule idList");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:638:2: ( ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )* -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* ) )
+			// org/antlr/grammar/v3/ANTLR.g:638:4: ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )*
+			{
+			// org/antlr/grammar/v3/ANTLR.g:638:4: ( 'scope' ( ruleActions )? ACTION )?
+			int alt32=2;
+			int LA32_0 = input.LA(1);
+			if ( (LA32_0==SCOPE) ) {
+				int LA32_1 = input.LA(2);
+				if ( (LA32_1==ACTION||LA32_1==AMPERSAND) ) {
+					alt32=1;
+				}
+			}
+			switch (alt32) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:638:6: 'scope' ( ruleActions )? ACTION
+					{
+					string_literal58=(Token)match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec1308); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_SCOPE.add(string_literal58);
+
+					// org/antlr/grammar/v3/ANTLR.g:638:14: ( ruleActions )?
+					int alt31=2;
+					int LA31_0 = input.LA(1);
+					if ( (LA31_0==AMPERSAND) ) {
+						alt31=1;
+					}
+					switch (alt31) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:638:14: ruleActions
+							{
+							pushFollow(FOLLOW_ruleActions_in_ruleScopeSpec1310);
+							ruleActions59=ruleActions();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_ruleActions.add(ruleActions59.getTree());
+							}
+							break;
+
+					}
+
+					ACTION60=(Token)match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec1313); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ACTION.add(ACTION60);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:639:3: ( 'scope' idList SEMI )*
+			loop33:
+			while (true) {
+				int alt33=2;
+				int LA33_0 = input.LA(1);
+				if ( (LA33_0==SCOPE) ) {
+					alt33=1;
+				}
+
+				switch (alt33) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:639:5: 'scope' idList SEMI
+					{
+					string_literal61=(Token)match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec1322); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_SCOPE.add(string_literal61);
+
+					pushFollow(FOLLOW_idList_in_ruleScopeSpec1324);
+					idList62=idList();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_idList.add(idList62.getTree());
+					SEMI63=(Token)match(input,SEMI,FOLLOW_SEMI_in_ruleScopeSpec1326); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_SEMI.add(SEMI63);
+
+					}
+					break;
+
+				default :
+					break loop33;
+				}
+			}
+
+			// AST REWRITE
+			// elements: idList, ruleActions, ACTION
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 640:3: -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* )
+			{
+				// org/antlr/grammar/v3/ANTLR.g:640:6: ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(SCOPE, (retval.start), "scope"), root_1);
+				// org/antlr/grammar/v3/ANTLR.g:640:30: ( ruleActions )?
+				if ( stream_ruleActions.hasNext() ) {
+					adaptor.addChild(root_1, stream_ruleActions.nextTree());
+				}
+				stream_ruleActions.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:640:43: ( ACTION )?
+				if ( stream_ACTION.hasNext() ) {
+					adaptor.addChild(root_1, stream_ACTION.nextNode());
+				}
+				stream_ACTION.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:640:51: ( idList )*
+				while ( stream_idList.hasNext() ) {
+					adaptor.addChild(root_1, stream_idList.nextTree());
+				}
+				stream_idList.reset();
+
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+
+	public static class ruleAltList_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ruleAltList"
+	// org/antlr/grammar/v3/ANTLR.g:643:1: ruleAltList[Map<String, Object> opts] : ( -> BLOCK[input.LT(-1),\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+ |) -> ^( $ruleAltList EOB[\"<end-of-block>\"] ) ;
+	public final ANTLRParser.ruleAltList_return ruleAltList(Map<String, Object> opts) throws RecognitionException {
+		ANTLRParser.ruleAltList_return retval = new ANTLRParser.ruleAltList_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token OR64=null;
+		ParserRuleReturnScope a1 =null;
+		ParserRuleReturnScope r1 =null;
+		ParserRuleReturnScope a2 =null;
+		ParserRuleReturnScope r2 =null;
+
+		GrammarAST OR64_tree=null;
+		RewriteRuleTokenStream stream_OR=new RewriteRuleTokenStream(adaptor,"token OR");
+		RewriteRuleSubtreeStream stream_alternative=new RewriteRuleSubtreeStream(adaptor,"rule alternative");
+		RewriteRuleSubtreeStream stream_rewrite=new RewriteRuleSubtreeStream(adaptor,"rule rewrite");
+
+
+			GrammarAST blkRoot = null;
+			GrammarAST save = currentBlockAST;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:649:2: ( ( -> BLOCK[input.LT(-1),\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+ |) -> ^( $ruleAltList EOB[\"<end-of-block>\"] ) )
+			// org/antlr/grammar/v3/ANTLR.g:649:4: ( -> BLOCK[input.LT(-1),\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+ |)
+			{
+			// org/antlr/grammar/v3/ANTLR.g:649:4: ( -> BLOCK[input.LT(-1),\"BLOCK\"] )
+			// org/antlr/grammar/v3/ANTLR.g:649:6: 
+			{
+			// AST REWRITE
+			// elements: 
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 649:6: -> BLOCK[input.LT(-1),\"BLOCK\"]
+			{
+				adaptor.addChild(root_0, (GrammarAST)adaptor.create(BLOCK, input.LT(-1), "BLOCK"));
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			if ( state.backtracking==0 ) {
+						blkRoot = (GrammarAST)retval.tree.getChild(0);
+						blkRoot.setBlockOptions(opts);
+						currentBlockAST = blkRoot;
+					}
+			// org/antlr/grammar/v3/ANTLR.g:655:3: (a1= alternative r1= rewrite -> $a1 ( $r1)? )
+			// org/antlr/grammar/v3/ANTLR.g:655:5: a1= alternative r1= rewrite
+			{
+			pushFollow(FOLLOW_alternative_in_ruleAltList1383);
+			a1=alternative();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_alternative.add(a1.getTree());
+			pushFollow(FOLLOW_rewrite_in_ruleAltList1387);
+			r1=rewrite();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite.add(r1.getTree());
+			if ( state.backtracking==0 ) {if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred((a1!=null?((GrammarAST)a1.getTree()):null));}
+			// AST REWRITE
+			// elements: a1, r1
+			// token labels: 
+			// rule labels: a1, retval, r1
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.getTree():null);
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+			RewriteRuleSubtreeStream stream_r1=new RewriteRuleSubtreeStream(adaptor,"rule r1",r1!=null?r1.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 657:4: -> $a1 ( $r1)?
+			{
+				adaptor.addChild(root_0, stream_a1.nextTree());
+				// org/antlr/grammar/v3/ANTLR.g:657:12: ( $r1)?
+				if ( stream_r1.hasNext() ) {
+					adaptor.addChild(root_0, stream_r1.nextTree());
+				}
+				stream_r1.reset();
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:659:3: ( ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+ |)
+			int alt35=2;
+			int LA35_0 = input.LA(1);
+			if ( (LA35_0==OR) ) {
+				alt35=1;
+			}
+			else if ( (LA35_0==SEMI) ) {
+				alt35=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 35, 0, input);
+				throw nvae;
+			}
+
+			switch (alt35) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:659:5: ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+
+					{
+					// org/antlr/grammar/v3/ANTLR.g:659:5: ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+
+					int cnt34=0;
+					loop34:
+					while (true) {
+						int alt34=2;
+						int LA34_0 = input.LA(1);
+						if ( (LA34_0==OR) ) {
+							alt34=1;
+						}
+
+						switch (alt34) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:659:7: OR a2= alternative r2= rewrite
+							{
+							OR64=(Token)match(input,OR,FOLLOW_OR_in_ruleAltList1416); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_OR.add(OR64);
+
+							pushFollow(FOLLOW_alternative_in_ruleAltList1420);
+							a2=alternative();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_alternative.add(a2.getTree());
+							pushFollow(FOLLOW_rewrite_in_ruleAltList1424);
+							r2=rewrite();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_rewrite.add(r2.getTree());
+							if ( state.backtracking==0 ) {if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred((a2!=null?((GrammarAST)a2.getTree()):null));}
+							// AST REWRITE
+							// elements: r2, ruleAltList, a2
+							// token labels: 
+							// rule labels: r2, a2, retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_r2=new RewriteRuleSubtreeStream(adaptor,"rule r2",r2!=null?r2.getTree():null);
+							RewriteRuleSubtreeStream stream_a2=new RewriteRuleSubtreeStream(adaptor,"rule a2",a2!=null?a2.getTree():null);
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (GrammarAST)adaptor.nil();
+							// 661:5: -> $ruleAltList $a2 ( $r2)?
+							{
+								adaptor.addChild(root_0, stream_retval.nextTree());
+								adaptor.addChild(root_0, stream_a2.nextTree());
+								// org/antlr/grammar/v3/ANTLR.g:661:26: ( $r2)?
+								if ( stream_r2.hasNext() ) {
+									adaptor.addChild(root_0, stream_r2.nextTree());
+								}
+								stream_r2.reset();
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+						default :
+							if ( cnt34 >= 1 ) break loop34;
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							EarlyExitException eee = new EarlyExitException(34, input);
+							throw eee;
+						}
+						cnt34++;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:664:3: 
+					{
+					}
+					break;
+
+			}
+
+			// AST REWRITE
+			// elements: ruleAltList
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 665:3: -> ^( $ruleAltList EOB[\"<end-of-block>\"] )
+			{
+				// org/antlr/grammar/v3/ANTLR.g:665:6: ^( $ruleAltList EOB[\"<end-of-block>\"] )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot(blkRoot, root_1);
+				adaptor.addChild(root_1, stream_retval.nextTree());
+				adaptor.addChild(root_1, (GrammarAST)adaptor.create(EOB, "<end-of-block>"));
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+			 currentBlockAST = save; 
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleAltList"
+
+
+	public static class block_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "block"
+	// org/antlr/grammar/v3/ANTLR.g:670:1: block : (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] ) ;
+	public final ANTLRParser.block_return block() throws RecognitionException {
+		ANTLRParser.block_return retval = new ANTLRParser.block_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token lp=null;
+		Token rp=null;
+		Token COLON67=null;
+		Token ACTION68=null;
+		Token COLON69=null;
+		Token OR70=null;
+		ParserRuleReturnScope a =null;
+		ParserRuleReturnScope r =null;
+		ParserRuleReturnScope optionsSpec65 =null;
+		ParserRuleReturnScope ruleActions66 =null;
+
+		GrammarAST lp_tree=null;
+		GrammarAST rp_tree=null;
+		GrammarAST COLON67_tree=null;
+		GrammarAST ACTION68_tree=null;
+		GrammarAST COLON69_tree=null;
+		GrammarAST OR70_tree=null;
+		RewriteRuleTokenStream stream_OR=new RewriteRuleTokenStream(adaptor,"token OR");
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
+		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
+		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
+		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
+		RewriteRuleSubtreeStream stream_alternative=new RewriteRuleSubtreeStream(adaptor,"rule alternative");
+		RewriteRuleSubtreeStream stream_rewrite=new RewriteRuleSubtreeStream(adaptor,"rule rewrite");
+
+
+			GrammarAST save = currentBlockAST;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:675:2: ( (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] ) )
+			// org/antlr/grammar/v3/ANTLR.g:675:4: (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN
+			{
+			// org/antlr/grammar/v3/ANTLR.g:675:4: (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] )
+			// org/antlr/grammar/v3/ANTLR.g:675:6: lp= LPAREN
+			{
+			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_block1500); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_LPAREN.add(lp);
+
+			// AST REWRITE
+			// elements: 
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 676:4: -> BLOCK[$lp,\"BLOCK\"]
+			{
+				adaptor.addChild(root_0, (GrammarAST)adaptor.create(BLOCK, lp, "BLOCK"));
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			if ( state.backtracking==0 ) {currentBlockAST = (GrammarAST)retval.tree.getChild(0);}
+			// org/antlr/grammar/v3/ANTLR.g:679:3: ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )?
+			int alt38=3;
+			int LA38_0 = input.LA(1);
+			if ( (LA38_0==AMPERSAND||LA38_0==COLON||LA38_0==OPTIONS) ) {
+				alt38=1;
+			}
+			else if ( (LA38_0==ACTION) ) {
+				int LA38_2 = input.LA(2);
+				if ( (LA38_2==COLON) ) {
+					alt38=2;
+				}
+			}
+			switch (alt38) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:683:4: ( optionsSpec )? ( ruleActions )? COLON
+					{
+					// org/antlr/grammar/v3/ANTLR.g:683:4: ( optionsSpec )?
+					int alt36=2;
+					int LA36_0 = input.LA(1);
+					if ( (LA36_0==OPTIONS) ) {
+						alt36=1;
+					}
+					switch (alt36) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:683:5: optionsSpec
+							{
+							pushFollow(FOLLOW_optionsSpec_in_block1538);
+							optionsSpec65=optionsSpec();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_optionsSpec.add(optionsSpec65.getTree());
+							if ( state.backtracking==0 ) {((GrammarAST)retval.tree.getChild(0)).setOptions(grammar,(optionsSpec65!=null?((ANTLRParser.optionsSpec_return)optionsSpec65).opts:null));}
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:684:4: ( ruleActions )?
+					int alt37=2;
+					int LA37_0 = input.LA(1);
+					if ( (LA37_0==AMPERSAND) ) {
+						alt37=1;
+					}
+					switch (alt37) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:684:6: ruleActions
+							{
+							pushFollow(FOLLOW_ruleActions_in_block1549);
+							ruleActions66=ruleActions();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_ruleActions.add(ruleActions66.getTree());
+							}
+							break;
+
+					}
+
+					COLON67=(Token)match(input,COLON,FOLLOW_COLON_in_block1557); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_COLON.add(COLON67);
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:686:5: ACTION COLON
+					{
+					ACTION68=(Token)match(input,ACTION,FOLLOW_ACTION_in_block1563); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ACTION.add(ACTION68);
+
+					COLON69=(Token)match(input,COLON,FOLLOW_COLON_in_block1565); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_COLON.add(COLON69);
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_alternative_in_block1577);
+			a=alternative();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_alternative.add(a.getTree());
+			pushFollow(FOLLOW_rewrite_in_block1581);
+			r=rewrite();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite.add(r.getTree());
+			if ( state.backtracking==0 ) {
+						stream_alternative.add( (r!=null?((GrammarAST)r.getTree()):null) );
+						if ( LA(1)==OR || (LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR) )
+							prefixWithSynPred((a!=null?((GrammarAST)a.getTree()):null));
+					}
+			// org/antlr/grammar/v3/ANTLR.g:695:3: ( OR a= alternative r= rewrite )*
+			loop39:
+			while (true) {
+				int alt39=2;
+				int LA39_0 = input.LA(1);
+				if ( (LA39_0==OR) ) {
+					alt39=1;
+				}
+
+				switch (alt39) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:695:5: OR a= alternative r= rewrite
+					{
+					OR70=(Token)match(input,OR,FOLLOW_OR_in_block1591); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_OR.add(OR70);
+
+					pushFollow(FOLLOW_alternative_in_block1595);
+					a=alternative();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_alternative.add(a.getTree());
+					pushFollow(FOLLOW_rewrite_in_block1599);
+					r=rewrite();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite.add(r.getTree());
+					if ( state.backtracking==0 ) {
+									stream_alternative.add( (r!=null?((GrammarAST)r.getTree()):null) );
+									if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR))
+										prefixWithSynPred((a!=null?((GrammarAST)a.getTree()):null));
+								}
+					}
+					break;
+
+				default :
+					break loop39;
+				}
+			}
+
+			rp=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_block1616); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_RPAREN.add(rp);
+
+			// AST REWRITE
+			// elements: alternative, ACTION, ruleActions, optionsSpec, block
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 704:3: -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] )
+			{
+				// org/antlr/grammar/v3/ANTLR.g:704:6: ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot(stream_retval.nextNode(), root_1);
+				// org/antlr/grammar/v3/ANTLR.g:704:15: ( optionsSpec )?
+				if ( stream_optionsSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_optionsSpec.nextTree());
+				}
+				stream_optionsSpec.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:704:28: ( ruleActions )?
+				if ( stream_ruleActions.hasNext() ) {
+					adaptor.addChild(root_1, stream_ruleActions.nextTree());
+				}
+				stream_ruleActions.reset();
+
+				// org/antlr/grammar/v3/ANTLR.g:704:41: ( ACTION )?
+				if ( stream_ACTION.hasNext() ) {
+					adaptor.addChild(root_1, stream_ACTION.nextNode());
+				}
+				stream_ACTION.reset();
+
+				if ( !(stream_alternative.hasNext()) ) {
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_alternative.hasNext() ) {
+					adaptor.addChild(root_1, stream_alternative.nextTree());
+				}
+				stream_alternative.reset();
+
+				adaptor.addChild(root_1, (GrammarAST)adaptor.create(EOB, rp, "<end-of-block>"));
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+			 currentBlockAST = save; 
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+	public static class alternative_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "alternative"
+	// org/antlr/grammar/v3/ANTLR.g:709:1: alternative : ( ( element )+ -> ^( ALT[$start,\"ALT\"] ( element )+ EOA[input.LT(-1),\"<end-of-alt>\"] ) | -> ^( ALT[$start,\"ALT\"] EPSILON[input.LT(-1),\"epsilon\"] EOA[input.LT(-1),\"<end-of-alt>\"] ) );
+	public final ANTLRParser.alternative_return alternative() throws RecognitionException {
+		ANTLRParser.alternative_return retval = new ANTLRParser.alternative_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ParserRuleReturnScope element71 =null;
+
+		RewriteRuleSubtreeStream stream_element=new RewriteRuleSubtreeStream(adaptor,"rule element");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:710:2: ( ( element )+ -> ^( ALT[$start,\"ALT\"] ( element )+ EOA[input.LT(-1),\"<end-of-alt>\"] ) | -> ^( ALT[$start,\"ALT\"] EPSILON[input.LT(-1),\"epsilon\"] EOA[input.LT(-1),\"<end-of-alt>\"] ) )
+			int alt41=2;
+			int LA41_0 = input.LA(1);
+			if ( (LA41_0==ACTION||LA41_0==CHAR_LITERAL||LA41_0==FORCED_ACTION||LA41_0==LPAREN||LA41_0==NOT||LA41_0==RULE_REF||LA41_0==SEMPRED||LA41_0==STRING_LITERAL||LA41_0==TOKEN_REF||LA41_0==TREE_BEGIN||LA41_0==WILDCARD) ) {
+				alt41=1;
+			}
+			else if ( (LA41_0==OR||LA41_0==REWRITE||LA41_0==RPAREN||LA41_0==SEMI) ) {
+				alt41=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 41, 0, input);
+				throw nvae;
+			}
+
+			switch (alt41) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:710:4: ( element )+
+					{
+					// org/antlr/grammar/v3/ANTLR.g:710:4: ( element )+
+					int cnt40=0;
+					loop40:
+					while (true) {
+						int alt40=2;
+						int LA40_0 = input.LA(1);
+						if ( (LA40_0==ACTION||LA40_0==CHAR_LITERAL||LA40_0==FORCED_ACTION||LA40_0==LPAREN||LA40_0==NOT||LA40_0==RULE_REF||LA40_0==SEMPRED||LA40_0==STRING_LITERAL||LA40_0==TOKEN_REF||LA40_0==TREE_BEGIN||LA40_0==WILDCARD) ) {
+							alt40=1;
+						}
+
+						switch (alt40) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:710:4: element
+							{
+							pushFollow(FOLLOW_element_in_alternative1656);
+							element71=element();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_element.add(element71.getTree());
+							}
+							break;
+
+						default :
+							if ( cnt40 >= 1 ) break loop40;
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							EarlyExitException eee = new EarlyExitException(40, input);
+							throw eee;
+						}
+						cnt40++;
+					}
+
+					// AST REWRITE
+					// elements: element
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 711:3: -> ^( ALT[$start,\"ALT\"] ( element )+ EOA[input.LT(-1),\"<end-of-alt>\"] )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:711:6: ^( ALT[$start,\"ALT\"] ( element )+ EOA[input.LT(-1),\"<end-of-alt>\"] )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(ALT, (retval.start), "ALT"), root_1);
+						if ( !(stream_element.hasNext()) ) {
+							throw new RewriteEarlyExitException();
+						}
+						while ( stream_element.hasNext() ) {
+							adaptor.addChild(root_1, stream_element.nextTree());
+						}
+						stream_element.reset();
+
+						adaptor.addChild(root_1, (GrammarAST)adaptor.create(EOA, input.LT(-1), "<end-of-alt>"));
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:713:3: 
+					{
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 713:3: -> ^( ALT[$start,\"ALT\"] EPSILON[input.LT(-1),\"epsilon\"] EOA[input.LT(-1),\"<end-of-alt>\"] )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:713:6: ^( ALT[$start,\"ALT\"] EPSILON[input.LT(-1),\"epsilon\"] EOA[input.LT(-1),\"<end-of-alt>\"] )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(ALT, (retval.start), "ALT"), root_1);
+						adaptor.addChild(root_1, (GrammarAST)adaptor.create(EPSILON, input.LT(-1), "epsilon"));
+						adaptor.addChild(root_1, (GrammarAST)adaptor.create(EOA, input.LT(-1), "<end-of-alt>"));
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "alternative"
+
+
+	public static class exceptionGroup_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "exceptionGroup"
+	// org/antlr/grammar/v3/ANTLR.g:716:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	public final ANTLRParser.exceptionGroup_return exceptionGroup() throws RecognitionException {
+		ANTLRParser.exceptionGroup_return retval = new ANTLRParser.exceptionGroup_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ParserRuleReturnScope exceptionHandler72 =null;
+		ParserRuleReturnScope finallyClause73 =null;
+		ParserRuleReturnScope finallyClause74 =null;
+
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:717:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt44=2;
+			int LA44_0 = input.LA(1);
+			if ( (LA44_0==CATCH) ) {
+				alt44=1;
+			}
+			else if ( (LA44_0==FINALLY) ) {
+				alt44=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 44, 0, input);
+				throw nvae;
+			}
+
+			switch (alt44) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:717:4: ( exceptionHandler )+ ( finallyClause )?
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					// org/antlr/grammar/v3/ANTLR.g:717:4: ( exceptionHandler )+
+					int cnt42=0;
+					loop42:
+					while (true) {
+						int alt42=2;
+						int LA42_0 = input.LA(1);
+						if ( (LA42_0==CATCH) ) {
+							alt42=1;
+						}
+
+						switch (alt42) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:717:4: exceptionHandler
+							{
+							pushFollow(FOLLOW_exceptionHandler_in_exceptionGroup1702);
+							exceptionHandler72=exceptionHandler();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, exceptionHandler72.getTree());
+
+							}
+							break;
+
+						default :
+							if ( cnt42 >= 1 ) break loop42;
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							EarlyExitException eee = new EarlyExitException(42, input);
+							throw eee;
+						}
+						cnt42++;
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:717:22: ( finallyClause )?
+					int alt43=2;
+					int LA43_0 = input.LA(1);
+					if ( (LA43_0==FINALLY) ) {
+						alt43=1;
+					}
+					switch (alt43) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:717:22: finallyClause
+							{
+							pushFollow(FOLLOW_finallyClause_in_exceptionGroup1705);
+							finallyClause73=finallyClause();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, finallyClause73.getTree());
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:718:4: finallyClause
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_finallyClause_in_exceptionGroup1711);
+					finallyClause74=finallyClause();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, finallyClause74.getTree());
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+	public static class exceptionHandler_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "exceptionHandler"
+	// org/antlr/grammar/v3/ANTLR.g:721:1: exceptionHandler : 'catch' ^ ARG_ACTION ACTION ;
+	public final ANTLRParser.exceptionHandler_return exceptionHandler() throws RecognitionException {
+		ANTLRParser.exceptionHandler_return retval = new ANTLRParser.exceptionHandler_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token string_literal75=null;
+		Token ARG_ACTION76=null;
+		Token ACTION77=null;
+
+		GrammarAST string_literal75_tree=null;
+		GrammarAST ARG_ACTION76_tree=null;
+		GrammarAST ACTION77_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:722:2: ( 'catch' ^ ARG_ACTION ACTION )
+			// org/antlr/grammar/v3/ANTLR.g:722:4: 'catch' ^ ARG_ACTION ACTION
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			string_literal75=(Token)match(input,CATCH,FOLLOW_CATCH_in_exceptionHandler1722); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			string_literal75_tree = (GrammarAST)adaptor.create(string_literal75);
+			root_0 = (GrammarAST)adaptor.becomeRoot(string_literal75_tree, root_0);
+			}
+
+			ARG_ACTION76=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_exceptionHandler1725); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ARG_ACTION76_tree = (GrammarAST)adaptor.create(ARG_ACTION76);
+			adaptor.addChild(root_0, ARG_ACTION76_tree);
+			}
+
+			ACTION77=(Token)match(input,ACTION,FOLLOW_ACTION_in_exceptionHandler1727); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ACTION77_tree = (GrammarAST)adaptor.create(ACTION77);
+			adaptor.addChild(root_0, ACTION77_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+	public static class finallyClause_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "finallyClause"
+	// org/antlr/grammar/v3/ANTLR.g:725:1: finallyClause : 'finally' ^ ACTION ;
+	public final ANTLRParser.finallyClause_return finallyClause() throws RecognitionException {
+		ANTLRParser.finallyClause_return retval = new ANTLRParser.finallyClause_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token string_literal78=null;
+		Token ACTION79=null;
+
+		GrammarAST string_literal78_tree=null;
+		GrammarAST ACTION79_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:726:2: ( 'finally' ^ ACTION )
+			// org/antlr/grammar/v3/ANTLR.g:726:4: 'finally' ^ ACTION
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			string_literal78=(Token)match(input,FINALLY,FOLLOW_FINALLY_in_finallyClause1738); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			string_literal78_tree = (GrammarAST)adaptor.create(string_literal78);
+			root_0 = (GrammarAST)adaptor.becomeRoot(string_literal78_tree, root_0);
+			}
+
+			ACTION79=(Token)match(input,ACTION,FOLLOW_ACTION_in_finallyClause1741); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ACTION79_tree = (GrammarAST)adaptor.create(ACTION79);
+			adaptor.addChild(root_0, ACTION79_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "finallyClause"
+
+
+	public static class element_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "element"
+	// org/antlr/grammar/v3/ANTLR.g:729:1: element : elementNoOptionSpec ;
+	public final ANTLRParser.element_return element() throws RecognitionException {
+		ANTLRParser.element_return retval = new ANTLRParser.element_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ParserRuleReturnScope elementNoOptionSpec80 =null;
+
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:730:2: ( elementNoOptionSpec )
+			// org/antlr/grammar/v3/ANTLR.g:730:4: elementNoOptionSpec
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			pushFollow(FOLLOW_elementNoOptionSpec_in_element1752);
+			elementNoOptionSpec80=elementNoOptionSpec();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, elementNoOptionSpec80.getTree());
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "element"
+
+
+	public static class elementNoOptionSpec_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "elementNoOptionSpec"
+	// org/antlr/grammar/v3/ANTLR.g:733:1: elementNoOptionSpec : ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom (sub= ebnfSuffix[root_0,false] !)? | ebnf ) |a= atom (sub2= ebnfSuffix[$a.tree,false] !)? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES !)? |t3= tree_ ) ;
+	public final ANTLRParser.elementNoOptionSpec_return elementNoOptionSpec() throws RecognitionException {
+		ANTLRParser.elementNoOptionSpec_return retval = new ANTLRParser.elementNoOptionSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token p=null;
+		Token ASSIGN82=null;
+		Token PLUS_ASSIGN83=null;
+		Token FORCED_ACTION87=null;
+		Token ACTION88=null;
+		Token IMPLIES89=null;
+		ParserRuleReturnScope sub =null;
+		ParserRuleReturnScope a =null;
+		ParserRuleReturnScope sub2 =null;
+		ParserRuleReturnScope t3 =null;
+		ParserRuleReturnScope id81 =null;
+		ParserRuleReturnScope atom84 =null;
+		ParserRuleReturnScope ebnf85 =null;
+		ParserRuleReturnScope ebnf86 =null;
+
+		GrammarAST p_tree=null;
+		GrammarAST ASSIGN82_tree=null;
+		GrammarAST PLUS_ASSIGN83_tree=null;
+		GrammarAST FORCED_ACTION87_tree=null;
+		GrammarAST ACTION88_tree=null;
+		GrammarAST IMPLIES89_tree=null;
+
+
+			IntSet elements=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:738:2: ( ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom (sub= ebnfSuffix[root_0,false] !)? | ebnf ) |a= atom (sub2= ebnfSuffix[$a.tree,false] !)? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES !)? |t3= tree_ ) )
+			// org/antlr/grammar/v3/ANTLR.g:738:4: ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom (sub= ebnfSuffix[root_0,false] !)? | ebnf ) |a= atom (sub2= ebnfSuffix[$a.tree,false] !)? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES !)? |t3= tree_ )
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			// org/antlr/grammar/v3/ANTLR.g:738:4: ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom (sub= ebnfSuffix[root_0,false] !)? | ebnf ) |a= atom (sub2= ebnfSuffix[$a.tree,false] !)? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES !)? |t3= tree_ )
+			int alt50=7;
+			switch ( input.LA(1) ) {
+			case TOKEN_REF:
+				{
+				int LA50_1 = input.LA(2);
+				if ( (LA50_1==ACTION||LA50_1==ARG_ACTION||LA50_1==BANG||LA50_1==CHAR_LITERAL||LA50_1==FORCED_ACTION||LA50_1==LPAREN||(LA50_1 >= NOT && LA50_1 <= OPEN_ELEMENT_OPTION)||LA50_1==OR||LA50_1==PLUS||(LA50_1 >= QUESTION && LA50_1 <= RANGE)||LA50_1==REWRITE||(LA50_1 >= ROOT && LA50_1 <= RPAREN)||LA50_1==RULE_REF||(LA50_1 >= SEMI && LA50_1 <= SEMPRED)||LA50_1==STAR||LA50_1==STRING_LITERAL||LA50_1==TOKEN_REF||LA50_1==TREE_BEGIN||LA50_1==WILDCARD) ) {
+					alt50=2;
+				}
+				else if ( (LA50_1==ASSIGN||LA50_1==PLUS_ASSIGN) ) {
+					alt50=1;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 50, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case RULE_REF:
+				{
+				int LA50_2 = input.LA(2);
+				if ( (LA50_2==ASSIGN||LA50_2==PLUS_ASSIGN) ) {
+					alt50=1;
+				}
+				else if ( (LA50_2==ACTION||LA50_2==ARG_ACTION||LA50_2==BANG||LA50_2==CHAR_LITERAL||LA50_2==FORCED_ACTION||LA50_2==LPAREN||LA50_2==NOT||LA50_2==OR||LA50_2==PLUS||LA50_2==QUESTION||LA50_2==REWRITE||(LA50_2 >= ROOT && LA50_2 <= RPAREN)||LA50_2==RULE_REF||(LA50_2 >= SEMI && LA50_2 <= SEMPRED)||LA50_2==STAR||LA50_2==STRING_LITERAL||LA50_2==TOKEN_REF||LA50_2==TREE_BEGIN||LA50_2==WILDCARD) ) {
+					alt50=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 50, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case CHAR_LITERAL:
+			case NOT:
+			case STRING_LITERAL:
+			case WILDCARD:
+				{
+				alt50=2;
+				}
+				break;
+			case LPAREN:
+				{
+				alt50=3;
+				}
+				break;
+			case FORCED_ACTION:
+				{
+				alt50=4;
+				}
+				break;
+			case ACTION:
+				{
+				alt50=5;
+				}
+				break;
+			case SEMPRED:
+				{
+				alt50=6;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt50=7;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 50, 0, input);
+				throw nvae;
+			}
+			switch (alt50) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:738:6: id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom (sub= ebnfSuffix[root_0,false] !)? | ebnf )
+					{
+					pushFollow(FOLLOW_id_in_elementNoOptionSpec1770);
+					id81=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, id81.getTree());
+
+					// org/antlr/grammar/v3/ANTLR.g:738:9: ( ASSIGN ^| PLUS_ASSIGN ^)
+					int alt45=2;
+					int LA45_0 = input.LA(1);
+					if ( (LA45_0==ASSIGN) ) {
+						alt45=1;
+					}
+					else if ( (LA45_0==PLUS_ASSIGN) ) {
+						alt45=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 45, 0, input);
+						throw nvae;
+					}
+
+					switch (alt45) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:738:10: ASSIGN ^
+							{
+							ASSIGN82=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_elementNoOptionSpec1773); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ASSIGN82_tree = (GrammarAST)adaptor.create(ASSIGN82);
+							root_0 = (GrammarAST)adaptor.becomeRoot(ASSIGN82_tree, root_0);
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:738:18: PLUS_ASSIGN ^
+							{
+							PLUS_ASSIGN83=(Token)match(input,PLUS_ASSIGN,FOLLOW_PLUS_ASSIGN_in_elementNoOptionSpec1776); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							PLUS_ASSIGN83_tree = (GrammarAST)adaptor.create(PLUS_ASSIGN83);
+							root_0 = (GrammarAST)adaptor.becomeRoot(PLUS_ASSIGN83_tree, root_0);
+							}
+
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:739:4: ( atom (sub= ebnfSuffix[root_0,false] !)? | ebnf )
+					int alt47=2;
+					int LA47_0 = input.LA(1);
+					if ( (LA47_0==CHAR_LITERAL||LA47_0==NOT||LA47_0==RULE_REF||LA47_0==STRING_LITERAL||LA47_0==TOKEN_REF||LA47_0==WILDCARD) ) {
+						alt47=1;
+					}
+					else if ( (LA47_0==LPAREN) ) {
+						alt47=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 47, 0, input);
+						throw nvae;
+					}
+
+					switch (alt47) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:739:6: atom (sub= ebnfSuffix[root_0,false] !)?
+							{
+							pushFollow(FOLLOW_atom_in_elementNoOptionSpec1785);
+							atom84=atom();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, atom84.getTree());
+
+							// org/antlr/grammar/v3/ANTLR.g:739:11: (sub= ebnfSuffix[root_0,false] !)?
+							int alt46=2;
+							int LA46_0 = input.LA(1);
+							if ( (LA46_0==PLUS||LA46_0==QUESTION||LA46_0==STAR) ) {
+								alt46=1;
+							}
+							switch (alt46) {
+								case 1 :
+									// org/antlr/grammar/v3/ANTLR.g:739:12: sub= ebnfSuffix[root_0,false] !
+									{
+									pushFollow(FOLLOW_ebnfSuffix_in_elementNoOptionSpec1790);
+									sub=ebnfSuffix(root_0, false);
+									state._fsp--;
+									if (state.failed) return retval;
+									if ( state.backtracking==0 ) {root_0 = (sub!=null?((GrammarAST)sub.getTree()):null);}
+									}
+									break;
+
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:740:6: ebnf
+							{
+							pushFollow(FOLLOW_ebnf_in_elementNoOptionSpec1803);
+							ebnf85=ebnf();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, ebnf85.getTree());
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:742:5: a= atom (sub2= ebnfSuffix[$a.tree,false] !)?
+					{
+					pushFollow(FOLLOW_atom_in_elementNoOptionSpec1816);
+					a=atom();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, a.getTree());
+
+					// org/antlr/grammar/v3/ANTLR.g:743:4: (sub2= ebnfSuffix[$a.tree,false] !)?
+					int alt48=2;
+					int LA48_0 = input.LA(1);
+					if ( (LA48_0==PLUS||LA48_0==QUESTION||LA48_0==STAR) ) {
+						alt48=1;
+					}
+					switch (alt48) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:743:6: sub2= ebnfSuffix[$a.tree,false] !
+							{
+							pushFollow(FOLLOW_ebnfSuffix_in_elementNoOptionSpec1825);
+							sub2=ebnfSuffix((a!=null?((GrammarAST)a.getTree()):null), false);
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) {root_0=(sub2!=null?((GrammarAST)sub2.getTree()):null);}
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:745:5: ebnf
+					{
+					pushFollow(FOLLOW_ebnf_in_elementNoOptionSpec1841);
+					ebnf86=ebnf();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, ebnf86.getTree());
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:746:5: FORCED_ACTION
+					{
+					FORCED_ACTION87=(Token)match(input,FORCED_ACTION,FOLLOW_FORCED_ACTION_in_elementNoOptionSpec1847); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					FORCED_ACTION87_tree = (GrammarAST)adaptor.create(FORCED_ACTION87);
+					adaptor.addChild(root_0, FORCED_ACTION87_tree);
+					}
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLR.g:747:5: ACTION
+					{
+					ACTION88=(Token)match(input,ACTION,FOLLOW_ACTION_in_elementNoOptionSpec1853); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ACTION88_tree = (GrammarAST)adaptor.create(ACTION88);
+					adaptor.addChild(root_0, ACTION88_tree);
+					}
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLR.g:748:5: p= SEMPRED ( IMPLIES !)?
+					{
+					p=(Token)match(input,SEMPRED,FOLLOW_SEMPRED_in_elementNoOptionSpec1861); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					p_tree = (GrammarAST)adaptor.create(p);
+					adaptor.addChild(root_0, p_tree);
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:748:15: ( IMPLIES !)?
+					int alt49=2;
+					int LA49_0 = input.LA(1);
+					if ( (LA49_0==IMPLIES) ) {
+						alt49=1;
+					}
+					switch (alt49) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:748:17: IMPLIES !
+							{
+							IMPLIES89=(Token)match(input,IMPLIES,FOLLOW_IMPLIES_in_elementNoOptionSpec1865); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {p.setType(GATED_SEMPRED);}
+							}
+							break;
+
+					}
+
+					if ( state.backtracking==0 ) {
+								grammar.blocksWithSemPreds.add(currentBlockAST);
+								}
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/ANTLR.g:752:5: t3= tree_
+					{
+					pushFollow(FOLLOW_tree__in_elementNoOptionSpec1884);
+					t3=tree_();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, t3.getTree());
+
+					}
+					break;
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "elementNoOptionSpec"
+
+
+	public static class atom_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "atom"
+	// org/antlr/grammar/v3/ANTLR.g:756:1: atom : ( range ( ROOT ^| BANG ^)? | ( ({...}? id WILDCARD ( terminal | ruleref ) )=> id w= WILDCARD ^ ( terminal | ruleref ) | terminal | ruleref ) | notSet ( ROOT ^| BANG ^)? );
+	public final ANTLRParser.atom_return atom() throws RecognitionException {
+		ANTLRParser.atom_return retval = new ANTLRParser.atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token w=null;
+		Token ROOT91=null;
+		Token BANG92=null;
+		Token ROOT99=null;
+		Token BANG100=null;
+		ParserRuleReturnScope range90 =null;
+		ParserRuleReturnScope id93 =null;
+		ParserRuleReturnScope terminal94 =null;
+		ParserRuleReturnScope ruleref95 =null;
+		ParserRuleReturnScope terminal96 =null;
+		ParserRuleReturnScope ruleref97 =null;
+		ParserRuleReturnScope notSet98 =null;
+
+		GrammarAST w_tree=null;
+		GrammarAST ROOT91_tree=null;
+		GrammarAST BANG92_tree=null;
+		GrammarAST ROOT99_tree=null;
+		GrammarAST BANG100_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:757:2: ( range ( ROOT ^| BANG ^)? | ( ({...}? id WILDCARD ( terminal | ruleref ) )=> id w= WILDCARD ^ ( terminal | ruleref ) | terminal | ruleref ) | notSet ( ROOT ^| BANG ^)? )
+			int alt55=3;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				int LA55_1 = input.LA(2);
+				if ( (LA55_1==RANGE) ) {
+					alt55=1;
+				}
+				else if ( (LA55_1==ACTION||LA55_1==BANG||LA55_1==CHAR_LITERAL||LA55_1==FORCED_ACTION||LA55_1==LPAREN||(LA55_1 >= NOT && LA55_1 <= OPEN_ELEMENT_OPTION)||LA55_1==OR||LA55_1==PLUS||LA55_1==QUESTION||LA55_1==REWRITE||(LA55_1 >= ROOT && LA55_1 <= RPAREN)||LA55_1==RULE_REF||(LA55_1 >= SEMI && LA55_1 <= SEMPRED)||LA55_1==STAR||LA55_1==STRING_LITERAL||LA55_1==TOKEN_REF||LA55_1==TREE_BEGIN||LA55_1==WILDCARD) ) {
+					alt55=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 55, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case TOKEN_REF:
+				{
+				int LA55_2 = input.LA(2);
+				if ( (LA55_2==RANGE) ) {
+					alt55=1;
+				}
+				else if ( (LA55_2==ACTION||LA55_2==ARG_ACTION||LA55_2==BANG||LA55_2==CHAR_LITERAL||LA55_2==FORCED_ACTION||LA55_2==LPAREN||(LA55_2 >= NOT && LA55_2 <= OPEN_ELEMENT_OPTION)||LA55_2==OR||LA55_2==PLUS||LA55_2==QUESTION||LA55_2==REWRITE||(LA55_2 >= ROOT && LA55_2 <= RPAREN)||LA55_2==RULE_REF||(LA55_2 >= SEMI && LA55_2 <= SEMPRED)||LA55_2==STAR||LA55_2==STRING_LITERAL||LA55_2==TOKEN_REF||LA55_2==TREE_BEGIN||LA55_2==WILDCARD) ) {
+					alt55=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 55, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				int LA55_3 = input.LA(2);
+				if ( (LA55_3==RANGE) ) {
+					alt55=1;
+				}
+				else if ( (LA55_3==ACTION||LA55_3==BANG||LA55_3==CHAR_LITERAL||LA55_3==FORCED_ACTION||LA55_3==LPAREN||(LA55_3 >= NOT && LA55_3 <= OPEN_ELEMENT_OPTION)||LA55_3==OR||LA55_3==PLUS||LA55_3==QUESTION||LA55_3==REWRITE||(LA55_3 >= ROOT && LA55_3 <= RPAREN)||LA55_3==RULE_REF||(LA55_3 >= SEMI && LA55_3 <= SEMPRED)||LA55_3==STAR||LA55_3==STRING_LITERAL||LA55_3==TOKEN_REF||LA55_3==TREE_BEGIN||LA55_3==WILDCARD) ) {
+					alt55=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 55, 3, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case RULE_REF:
+			case WILDCARD:
+				{
+				alt55=2;
+				}
+				break;
+			case NOT:
+				{
+				alt55=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 55, 0, input);
+				throw nvae;
+			}
+			switch (alt55) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:757:4: range ( ROOT ^| BANG ^)?
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_range_in_atom1899);
+					range90=range();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, range90.getTree());
+
+					// org/antlr/grammar/v3/ANTLR.g:757:10: ( ROOT ^| BANG ^)?
+					int alt51=3;
+					int LA51_0 = input.LA(1);
+					if ( (LA51_0==ROOT) ) {
+						alt51=1;
+					}
+					else if ( (LA51_0==BANG) ) {
+						alt51=2;
+					}
+					switch (alt51) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:757:11: ROOT ^
+							{
+							ROOT91=(Token)match(input,ROOT,FOLLOW_ROOT_in_atom1902); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ROOT91_tree = (GrammarAST)adaptor.create(ROOT91);
+							root_0 = (GrammarAST)adaptor.becomeRoot(ROOT91_tree, root_0);
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:757:17: BANG ^
+							{
+							BANG92=(Token)match(input,BANG,FOLLOW_BANG_in_atom1905); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							BANG92_tree = (GrammarAST)adaptor.create(BANG92);
+							root_0 = (GrammarAST)adaptor.becomeRoot(BANG92_tree, root_0);
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:758:4: ( ({...}? id WILDCARD ( terminal | ruleref ) )=> id w= WILDCARD ^ ( terminal | ruleref ) | terminal | ruleref )
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					// org/antlr/grammar/v3/ANTLR.g:758:4: ( ({...}? id WILDCARD ( terminal | ruleref ) )=> id w= WILDCARD ^ ( terminal | ruleref ) | terminal | ruleref )
+					int alt53=3;
+					switch ( input.LA(1) ) {
+					case TOKEN_REF:
+						{
+						int LA53_1 = input.LA(2);
+						if ( (LA53_1==WILDCARD) ) {
+							switch ( input.LA(3) ) {
+							case CHAR_LITERAL:
+								{
+								int LA53_7 = input.LA(4);
+								if ( (synpred1_ANTLR()) ) {
+									alt53=1;
+								}
+								else if ( (true) ) {
+									alt53=2;
+								}
+
+								}
+								break;
+							case TOKEN_REF:
+								{
+								int LA53_8 = input.LA(4);
+								if ( (synpred1_ANTLR()) ) {
+									alt53=1;
+								}
+								else if ( (true) ) {
+									alt53=2;
+								}
+
+								}
+								break;
+							case STRING_LITERAL:
+								{
+								int LA53_9 = input.LA(4);
+								if ( (synpred1_ANTLR()) ) {
+									alt53=1;
+								}
+								else if ( (true) ) {
+									alt53=2;
+								}
+
+								}
+								break;
+							case WILDCARD:
+								{
+								int LA53_10 = input.LA(4);
+								if ( (synpred1_ANTLR()) ) {
+									alt53=1;
+								}
+								else if ( (true) ) {
+									alt53=2;
+								}
+
+								}
+								break;
+							case RULE_REF:
+								{
+								int LA53_11 = input.LA(4);
+								if ( (synpred1_ANTLR()) ) {
+									alt53=1;
+								}
+								else if ( (true) ) {
+									alt53=2;
+								}
+
+								}
+								break;
+							case ACTION:
+							case BANG:
+							case FORCED_ACTION:
+							case LPAREN:
+							case NOT:
+							case OR:
+							case PLUS:
+							case QUESTION:
+							case REWRITE:
+							case ROOT:
+							case RPAREN:
+							case SEMI:
+							case SEMPRED:
+							case STAR:
+							case TREE_BEGIN:
+								{
+								alt53=2;
+								}
+								break;
+							default:
+								if (state.backtracking>0) {state.failed=true; return retval;}
+								int nvaeMark = input.mark();
+								try {
+									for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+										input.consume();
+									}
+									NoViableAltException nvae =
+										new NoViableAltException("", 53, 4, input);
+									throw nvae;
+								} finally {
+									input.rewind(nvaeMark);
+								}
+							}
+						}
+						else if ( (LA53_1==ACTION||LA53_1==ARG_ACTION||LA53_1==BANG||LA53_1==CHAR_LITERAL||LA53_1==FORCED_ACTION||LA53_1==LPAREN||(LA53_1 >= NOT && LA53_1 <= OPEN_ELEMENT_OPTION)||LA53_1==OR||LA53_1==PLUS||LA53_1==QUESTION||LA53_1==REWRITE||(LA53_1 >= ROOT && LA53_1 <= RPAREN)||LA53_1==RULE_REF||(LA53_1 >= SEMI && LA53_1 <= SEMPRED)||LA53_1==STAR||LA53_1==STRING_LITERAL||LA53_1==TOKEN_REF||LA53_1==TREE_BEGIN) ) {
+							alt53=2;
+						}
+
+						else {
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							int nvaeMark = input.mark();
+							try {
+								input.consume();
+								NoViableAltException nvae =
+									new NoViableAltException("", 53, 1, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+						}
+						break;
+					case RULE_REF:
+						{
+						int LA53_2 = input.LA(2);
+						if ( (LA53_2==WILDCARD) ) {
+							switch ( input.LA(3) ) {
+							case CHAR_LITERAL:
+								{
+								int LA53_12 = input.LA(4);
+								if ( (synpred1_ANTLR()) ) {
+									alt53=1;
+								}
+								else if ( (true) ) {
+									alt53=3;
+								}
+
+								}
+								break;
+							case TOKEN_REF:
+								{
+								int LA53_13 = input.LA(4);
+								if ( (synpred1_ANTLR()) ) {
+									alt53=1;
+								}
+								else if ( (true) ) {
+									alt53=3;
+								}
+
+								}
+								break;
+							case STRING_LITERAL:
+								{
+								int LA53_14 = input.LA(4);
+								if ( (synpred1_ANTLR()) ) {
+									alt53=1;
+								}
+								else if ( (true) ) {
+									alt53=3;
+								}
+
+								}
+								break;
+							case WILDCARD:
+								{
+								int LA53_15 = input.LA(4);
+								if ( (synpred1_ANTLR()) ) {
+									alt53=1;
+								}
+								else if ( (true) ) {
+									alt53=3;
+								}
+
+								}
+								break;
+							case RULE_REF:
+								{
+								int LA53_16 = input.LA(4);
+								if ( (synpred1_ANTLR()) ) {
+									alt53=1;
+								}
+								else if ( (true) ) {
+									alt53=3;
+								}
+
+								}
+								break;
+							case ACTION:
+							case BANG:
+							case FORCED_ACTION:
+							case LPAREN:
+							case NOT:
+							case OR:
+							case PLUS:
+							case QUESTION:
+							case REWRITE:
+							case ROOT:
+							case RPAREN:
+							case SEMI:
+							case SEMPRED:
+							case STAR:
+							case TREE_BEGIN:
+								{
+								alt53=3;
+								}
+								break;
+							default:
+								if (state.backtracking>0) {state.failed=true; return retval;}
+								int nvaeMark = input.mark();
+								try {
+									for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+										input.consume();
+									}
+									NoViableAltException nvae =
+										new NoViableAltException("", 53, 5, input);
+									throw nvae;
+								} finally {
+									input.rewind(nvaeMark);
+								}
+							}
+						}
+						else if ( (LA53_2==ACTION||LA53_2==ARG_ACTION||LA53_2==BANG||LA53_2==CHAR_LITERAL||LA53_2==FORCED_ACTION||LA53_2==LPAREN||LA53_2==NOT||LA53_2==OR||LA53_2==PLUS||LA53_2==QUESTION||LA53_2==REWRITE||(LA53_2 >= ROOT && LA53_2 <= RPAREN)||LA53_2==RULE_REF||(LA53_2 >= SEMI && LA53_2 <= SEMPRED)||LA53_2==STAR||LA53_2==STRING_LITERAL||LA53_2==TOKEN_REF||LA53_2==TREE_BEGIN) ) {
+							alt53=3;
+						}
+
+						else {
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							int nvaeMark = input.mark();
+							try {
+								input.consume();
+								NoViableAltException nvae =
+									new NoViableAltException("", 53, 2, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+						}
+						break;
+					case CHAR_LITERAL:
+					case STRING_LITERAL:
+					case WILDCARD:
+						{
+						alt53=2;
+						}
+						break;
+					default:
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 53, 0, input);
+						throw nvae;
+					}
+					switch (alt53) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:761:4: ({...}? id WILDCARD ( terminal | ruleref ) )=> id w= WILDCARD ^ ( terminal | ruleref )
+							{
+							pushFollow(FOLLOW_id_in_atom1945);
+							id93=id();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, id93.getTree());
+
+							w=(Token)match(input,WILDCARD,FOLLOW_WILDCARD_in_atom1949); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							w_tree = (GrammarAST)adaptor.create(w);
+							root_0 = (GrammarAST)adaptor.becomeRoot(w_tree, root_0);
+							}
+
+							// org/antlr/grammar/v3/ANTLR.g:763:19: ( terminal | ruleref )
+							int alt52=2;
+							int LA52_0 = input.LA(1);
+							if ( (LA52_0==CHAR_LITERAL||LA52_0==STRING_LITERAL||LA52_0==TOKEN_REF||LA52_0==WILDCARD) ) {
+								alt52=1;
+							}
+							else if ( (LA52_0==RULE_REF) ) {
+								alt52=2;
+							}
+
+							else {
+								if (state.backtracking>0) {state.failed=true; return retval;}
+								NoViableAltException nvae =
+									new NoViableAltException("", 52, 0, input);
+								throw nvae;
+							}
+
+							switch (alt52) {
+								case 1 :
+									// org/antlr/grammar/v3/ANTLR.g:763:20: terminal
+									{
+									pushFollow(FOLLOW_terminal_in_atom1953);
+									terminal94=terminal();
+									state._fsp--;
+									if (state.failed) return retval;
+									if ( state.backtracking==0 ) adaptor.addChild(root_0, terminal94.getTree());
+
+									}
+									break;
+								case 2 :
+									// org/antlr/grammar/v3/ANTLR.g:763:29: ruleref
+									{
+									pushFollow(FOLLOW_ruleref_in_atom1955);
+									ruleref95=ruleref();
+									state._fsp--;
+									if (state.failed) return retval;
+									if ( state.backtracking==0 ) adaptor.addChild(root_0, ruleref95.getTree());
+
+									}
+									break;
+
+							}
+
+							if ( state.backtracking==0 ) {w.setType(DOT);}
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:764:5: terminal
+							{
+							pushFollow(FOLLOW_terminal_in_atom1964);
+							terminal96=terminal();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, terminal96.getTree());
+
+							}
+							break;
+						case 3 :
+							// org/antlr/grammar/v3/ANTLR.g:765:5: ruleref
+							{
+							pushFollow(FOLLOW_ruleref_in_atom1970);
+							ruleref97=ruleref();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, ruleref97.getTree());
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:767:4: notSet ( ROOT ^| BANG ^)?
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_notSet_in_atom1979);
+					notSet98=notSet();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, notSet98.getTree());
+
+					// org/antlr/grammar/v3/ANTLR.g:767:11: ( ROOT ^| BANG ^)?
+					int alt54=3;
+					int LA54_0 = input.LA(1);
+					if ( (LA54_0==ROOT) ) {
+						alt54=1;
+					}
+					else if ( (LA54_0==BANG) ) {
+						alt54=2;
+					}
+					switch (alt54) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:767:12: ROOT ^
+							{
+							ROOT99=(Token)match(input,ROOT,FOLLOW_ROOT_in_atom1982); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ROOT99_tree = (GrammarAST)adaptor.create(ROOT99);
+							root_0 = (GrammarAST)adaptor.becomeRoot(ROOT99_tree, root_0);
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:767:18: BANG ^
+							{
+							BANG100=(Token)match(input,BANG,FOLLOW_BANG_in_atom1985); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							BANG100_tree = (GrammarAST)adaptor.create(BANG100);
+							root_0 = (GrammarAST)adaptor.becomeRoot(BANG100_tree, root_0);
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "atom"
+
+
+	public static class ruleref_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ruleref"
+	// org/antlr/grammar/v3/ANTLR.g:770:1: ruleref : RULE_REF ^ ( ARG_ACTION )? ( ROOT ^| BANG ^)? ;
+	public final ANTLRParser.ruleref_return ruleref() throws RecognitionException {
+		ANTLRParser.ruleref_return retval = new ANTLRParser.ruleref_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token RULE_REF101=null;
+		Token ARG_ACTION102=null;
+		Token ROOT103=null;
+		Token BANG104=null;
+
+		GrammarAST RULE_REF101_tree=null;
+		GrammarAST ARG_ACTION102_tree=null;
+		GrammarAST ROOT103_tree=null;
+		GrammarAST BANG104_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:771:2: ( RULE_REF ^ ( ARG_ACTION )? ( ROOT ^| BANG ^)? )
+			// org/antlr/grammar/v3/ANTLR.g:771:4: RULE_REF ^ ( ARG_ACTION )? ( ROOT ^| BANG ^)?
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			RULE_REF101=(Token)match(input,RULE_REF,FOLLOW_RULE_REF_in_ruleref1999); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			RULE_REF101_tree = (GrammarAST)adaptor.create(RULE_REF101);
+			root_0 = (GrammarAST)adaptor.becomeRoot(RULE_REF101_tree, root_0);
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:771:14: ( ARG_ACTION )?
+			int alt56=2;
+			int LA56_0 = input.LA(1);
+			if ( (LA56_0==ARG_ACTION) ) {
+				alt56=1;
+			}
+			switch (alt56) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:771:14: ARG_ACTION
+					{
+					ARG_ACTION102=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_ruleref2002); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ARG_ACTION102_tree = (GrammarAST)adaptor.create(ARG_ACTION102);
+					adaptor.addChild(root_0, ARG_ACTION102_tree);
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:771:26: ( ROOT ^| BANG ^)?
+			int alt57=3;
+			int LA57_0 = input.LA(1);
+			if ( (LA57_0==ROOT) ) {
+				alt57=1;
+			}
+			else if ( (LA57_0==BANG) ) {
+				alt57=2;
+			}
+			switch (alt57) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:771:27: ROOT ^
+					{
+					ROOT103=(Token)match(input,ROOT,FOLLOW_ROOT_in_ruleref2006); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ROOT103_tree = (GrammarAST)adaptor.create(ROOT103);
+					root_0 = (GrammarAST)adaptor.becomeRoot(ROOT103_tree, root_0);
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:771:33: BANG ^
+					{
+					BANG104=(Token)match(input,BANG,FOLLOW_BANG_in_ruleref2009); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					BANG104_tree = (GrammarAST)adaptor.create(BANG104);
+					root_0 = (GrammarAST)adaptor.becomeRoot(BANG104_tree, root_0);
+					}
+
+					}
+					break;
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleref"
+
+
+	public static class notSet_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "notSet"
+	// org/antlr/grammar/v3/ANTLR.g:774:1: notSet : NOT ^ ( notTerminal | block ) ;
+	public final ANTLRParser.notSet_return notSet() throws RecognitionException {
+		ANTLRParser.notSet_return retval = new ANTLRParser.notSet_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token NOT105=null;
+		ParserRuleReturnScope notTerminal106 =null;
+		ParserRuleReturnScope block107 =null;
+
+		GrammarAST NOT105_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:775:2: ( NOT ^ ( notTerminal | block ) )
+			// org/antlr/grammar/v3/ANTLR.g:775:4: NOT ^ ( notTerminal | block )
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			NOT105=(Token)match(input,NOT,FOLLOW_NOT_in_notSet2023); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			NOT105_tree = (GrammarAST)adaptor.create(NOT105);
+			root_0 = (GrammarAST)adaptor.becomeRoot(NOT105_tree, root_0);
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:776:3: ( notTerminal | block )
+			int alt58=2;
+			int LA58_0 = input.LA(1);
+			if ( (LA58_0==CHAR_LITERAL||LA58_0==STRING_LITERAL||LA58_0==TOKEN_REF) ) {
+				alt58=1;
+			}
+			else if ( (LA58_0==LPAREN) ) {
+				alt58=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 58, 0, input);
+				throw nvae;
+			}
+
+			switch (alt58) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:776:5: notTerminal
+					{
+					pushFollow(FOLLOW_notTerminal_in_notSet2030);
+					notTerminal106=notTerminal();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, notTerminal106.getTree());
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:777:5: block
+					{
+					pushFollow(FOLLOW_block_in_notSet2036);
+					block107=block();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, block107.getTree());
+
+					}
+					break;
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "notSet"
+
+
+	public static class treeRoot_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "treeRoot"
+	// org/antlr/grammar/v3/ANTLR.g:781:1: treeRoot : ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom | block ) | atom | block );
+	public final ANTLRParser.treeRoot_return treeRoot() throws RecognitionException {
+		ANTLRParser.treeRoot_return retval = new ANTLRParser.treeRoot_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token ASSIGN109=null;
+		Token PLUS_ASSIGN110=null;
+		ParserRuleReturnScope id108 =null;
+		ParserRuleReturnScope atom111 =null;
+		ParserRuleReturnScope block112 =null;
+		ParserRuleReturnScope atom113 =null;
+		ParserRuleReturnScope block114 =null;
+
+		GrammarAST ASSIGN109_tree=null;
+		GrammarAST PLUS_ASSIGN110_tree=null;
+
+		atTreeRoot=true;
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:784:2: ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom | block ) | atom | block )
+			int alt61=3;
+			switch ( input.LA(1) ) {
+			case TOKEN_REF:
+				{
+				int LA61_1 = input.LA(2);
+				if ( (LA61_1==ACTION||LA61_1==ARG_ACTION||LA61_1==BANG||LA61_1==CHAR_LITERAL||LA61_1==FORCED_ACTION||LA61_1==LPAREN||(LA61_1 >= NOT && LA61_1 <= OPEN_ELEMENT_OPTION)||LA61_1==RANGE||LA61_1==ROOT||LA61_1==RULE_REF||LA61_1==SEMPRED||LA61_1==STRING_LITERAL||LA61_1==TOKEN_REF||LA61_1==TREE_BEGIN||LA61_1==WILDCARD) ) {
+					alt61=2;
+				}
+				else if ( (LA61_1==ASSIGN||LA61_1==PLUS_ASSIGN) ) {
+					alt61=1;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 61, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case RULE_REF:
+				{
+				int LA61_2 = input.LA(2);
+				if ( (LA61_2==ASSIGN||LA61_2==PLUS_ASSIGN) ) {
+					alt61=1;
+				}
+				else if ( (LA61_2==ACTION||LA61_2==ARG_ACTION||LA61_2==BANG||LA61_2==CHAR_LITERAL||LA61_2==FORCED_ACTION||LA61_2==LPAREN||LA61_2==NOT||LA61_2==ROOT||LA61_2==RULE_REF||LA61_2==SEMPRED||LA61_2==STRING_LITERAL||LA61_2==TOKEN_REF||LA61_2==TREE_BEGIN||LA61_2==WILDCARD) ) {
+					alt61=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 61, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case CHAR_LITERAL:
+			case NOT:
+			case STRING_LITERAL:
+			case WILDCARD:
+				{
+				alt61=2;
+				}
+				break;
+			case LPAREN:
+				{
+				alt61=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 61, 0, input);
+				throw nvae;
+			}
+			switch (alt61) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:784:4: id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom | block )
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_id_in_treeRoot2059);
+					id108=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, id108.getTree());
+
+					// org/antlr/grammar/v3/ANTLR.g:784:7: ( ASSIGN ^| PLUS_ASSIGN ^)
+					int alt59=2;
+					int LA59_0 = input.LA(1);
+					if ( (LA59_0==ASSIGN) ) {
+						alt59=1;
+					}
+					else if ( (LA59_0==PLUS_ASSIGN) ) {
+						alt59=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 59, 0, input);
+						throw nvae;
+					}
+
+					switch (alt59) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:784:8: ASSIGN ^
+							{
+							ASSIGN109=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_treeRoot2062); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ASSIGN109_tree = (GrammarAST)adaptor.create(ASSIGN109);
+							root_0 = (GrammarAST)adaptor.becomeRoot(ASSIGN109_tree, root_0);
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:784:16: PLUS_ASSIGN ^
+							{
+							PLUS_ASSIGN110=(Token)match(input,PLUS_ASSIGN,FOLLOW_PLUS_ASSIGN_in_treeRoot2065); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							PLUS_ASSIGN110_tree = (GrammarAST)adaptor.create(PLUS_ASSIGN110);
+							root_0 = (GrammarAST)adaptor.becomeRoot(PLUS_ASSIGN110_tree, root_0);
+							}
+
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:784:30: ( atom | block )
+					int alt60=2;
+					int LA60_0 = input.LA(1);
+					if ( (LA60_0==CHAR_LITERAL||LA60_0==NOT||LA60_0==RULE_REF||LA60_0==STRING_LITERAL||LA60_0==TOKEN_REF||LA60_0==WILDCARD) ) {
+						alt60=1;
+					}
+					else if ( (LA60_0==LPAREN) ) {
+						alt60=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 60, 0, input);
+						throw nvae;
+					}
+
+					switch (alt60) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:784:31: atom
+							{
+							pushFollow(FOLLOW_atom_in_treeRoot2070);
+							atom111=atom();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, atom111.getTree());
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:784:36: block
+							{
+							pushFollow(FOLLOW_block_in_treeRoot2072);
+							block112=block();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, block112.getTree());
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:785:4: atom
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_atom_in_treeRoot2078);
+					atom113=atom();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, atom113.getTree());
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:786:4: block
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_block_in_treeRoot2083);
+					block114=block();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, block114.getTree());
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+			if ( state.backtracking==0 ) {atTreeRoot=false;}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "treeRoot"
+
+
+	public static class tree__return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "tree_"
+	// org/antlr/grammar/v3/ANTLR.g:789:1: tree_ : TREE_BEGIN ^ treeRoot ( element )+ RPAREN !;
+	public final ANTLRParser.tree__return tree_() throws RecognitionException {
+		ANTLRParser.tree__return retval = new ANTLRParser.tree__return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token TREE_BEGIN115=null;
+		Token RPAREN118=null;
+		ParserRuleReturnScope treeRoot116 =null;
+		ParserRuleReturnScope element117 =null;
+
+		GrammarAST TREE_BEGIN115_tree=null;
+		GrammarAST RPAREN118_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:790:2: ( TREE_BEGIN ^ treeRoot ( element )+ RPAREN !)
+			// org/antlr/grammar/v3/ANTLR.g:790:4: TREE_BEGIN ^ treeRoot ( element )+ RPAREN !
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			TREE_BEGIN115=(Token)match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_tree_2094); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			TREE_BEGIN115_tree = (GrammarAST)adaptor.create(TREE_BEGIN115);
+			root_0 = (GrammarAST)adaptor.becomeRoot(TREE_BEGIN115_tree, root_0);
+			}
+
+			pushFollow(FOLLOW_treeRoot_in_tree_2099);
+			treeRoot116=treeRoot();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, treeRoot116.getTree());
+
+			// org/antlr/grammar/v3/ANTLR.g:791:12: ( element )+
+			int cnt62=0;
+			loop62:
+			while (true) {
+				int alt62=2;
+				int LA62_0 = input.LA(1);
+				if ( (LA62_0==ACTION||LA62_0==CHAR_LITERAL||LA62_0==FORCED_ACTION||LA62_0==LPAREN||LA62_0==NOT||LA62_0==RULE_REF||LA62_0==SEMPRED||LA62_0==STRING_LITERAL||LA62_0==TOKEN_REF||LA62_0==TREE_BEGIN||LA62_0==WILDCARD) ) {
+					alt62=1;
+				}
+
+				switch (alt62) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:791:12: element
+					{
+					pushFollow(FOLLOW_element_in_tree_2101);
+					element117=element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, element117.getTree());
+
+					}
+					break;
+
+				default :
+					if ( cnt62 >= 1 ) break loop62;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(62, input);
+					throw eee;
+				}
+				cnt62++;
+			}
+
+			RPAREN118=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_tree_2106); if (state.failed) return retval;
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "tree_"
+
+
+	public static class ebnf_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ebnf"
+	// org/antlr/grammar/v3/ANTLR.g:796:1: ebnf : block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {grammarType == Grammar.COMBINED && Rule.getRuleType(currentRuleName) == Grammar.LEXER}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block ) ;
+	public final ANTLRParser.ebnf_return ebnf() throws RecognitionException {
+		ANTLRParser.ebnf_return retval = new ANTLRParser.ebnf_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token QUESTION120=null;
+		Token STAR121=null;
+		Token PLUS122=null;
+		Token IMPLIES123=null;
+		Token ROOT124=null;
+		Token BANG125=null;
+		ParserRuleReturnScope block119 =null;
+
+		GrammarAST QUESTION120_tree=null;
+		GrammarAST STAR121_tree=null;
+		GrammarAST PLUS122_tree=null;
+		GrammarAST IMPLIES123_tree=null;
+		GrammarAST ROOT124_tree=null;
+		GrammarAST BANG125_tree=null;
+		RewriteRuleTokenStream stream_IMPLIES=new RewriteRuleTokenStream(adaptor,"token IMPLIES");
+		RewriteRuleTokenStream stream_STAR=new RewriteRuleTokenStream(adaptor,"token STAR");
+		RewriteRuleTokenStream stream_ROOT=new RewriteRuleTokenStream(adaptor,"token ROOT");
+		RewriteRuleTokenStream stream_BANG=new RewriteRuleTokenStream(adaptor,"token BANG");
+		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
+		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
+		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:797:2: ( block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {grammarType == Grammar.COMBINED && Rule.getRuleType(currentRuleName) == Grammar.LEXER}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block ) )
+			// org/antlr/grammar/v3/ANTLR.g:797:4: block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {grammarType == Grammar.COMBINED && Rule.getRuleType(currentRuleName) == Grammar.LEXER}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block )
+			{
+			pushFollow(FOLLOW_block_in_ebnf2120);
+			block119=block();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_block.add(block119.getTree());
+			// org/antlr/grammar/v3/ANTLR.g:798:3: ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {grammarType == Grammar.COMBINED && Rule.getRuleType(currentRuleName) == Grammar.LEXER}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block )
+			int alt63=7;
+			switch ( input.LA(1) ) {
+			case QUESTION:
+				{
+				alt63=1;
+				}
+				break;
+			case STAR:
+				{
+				alt63=2;
+				}
+				break;
+			case PLUS:
+				{
+				alt63=3;
+				}
+				break;
+			case IMPLIES:
+				{
+				alt63=4;
+				}
+				break;
+			case ROOT:
+				{
+				alt63=5;
+				}
+				break;
+			case BANG:
+				{
+				alt63=6;
+				}
+				break;
+			case ACTION:
+			case CHAR_LITERAL:
+			case FORCED_ACTION:
+			case LPAREN:
+			case NOT:
+			case OR:
+			case REWRITE:
+			case RPAREN:
+			case RULE_REF:
+			case SEMI:
+			case SEMPRED:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case TREE_BEGIN:
+			case WILDCARD:
+				{
+				alt63=7;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 63, 0, input);
+				throw nvae;
+			}
+			switch (alt63) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:798:5: QUESTION
+					{
+					QUESTION120=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_ebnf2126); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_QUESTION.add(QUESTION120);
+
+					// AST REWRITE
+					// elements: block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 799:4: -> ^( OPTIONAL[$start,\"?\"] block )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:799:7: ^( OPTIONAL[$start,\"?\"] block )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(OPTIONAL, (retval.start), "?"), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:800:5: STAR
+					{
+					STAR121=(Token)match(input,STAR,FOLLOW_STAR_in_ebnf2144); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_STAR.add(STAR121);
+
+					// AST REWRITE
+					// elements: block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 801:4: -> ^( CLOSURE[$start,\"*\"] block )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:801:7: ^( CLOSURE[$start,\"*\"] block )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(CLOSURE, (retval.start), "*"), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:802:5: PLUS
+					{
+					PLUS122=(Token)match(input,PLUS,FOLLOW_PLUS_in_ebnf2162); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_PLUS.add(PLUS122);
+
+					// AST REWRITE
+					// elements: block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 803:4: -> ^( POSITIVE_CLOSURE[$start,\"+\"] block )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:803:7: ^( POSITIVE_CLOSURE[$start,\"+\"] block )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(POSITIVE_CLOSURE, (retval.start), "+"), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:804:5: IMPLIES
+					{
+					IMPLIES123=(Token)match(input,IMPLIES,FOLLOW_IMPLIES_in_ebnf2180); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_IMPLIES.add(IMPLIES123);
+
+					// AST REWRITE
+					// elements: block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 806:4: -> {grammarType == Grammar.COMBINED && Rule.getRuleType(currentRuleName) == Grammar.LEXER}? ^( SYNPRED[$start,\"=>\"] block )
+					if (grammarType == Grammar.COMBINED && Rule.getRuleType(currentRuleName) == Grammar.LEXER) {
+						// org/antlr/grammar/v3/ANTLR.g:806:96: ^( SYNPRED[$start,\"=>\"] block )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(SYNPRED, (retval.start), "=>"), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+					else // 808:4: ->
+					{
+						adaptor.addChild(root_0, createSynSemPredFromBlock((block119!=null?((GrammarAST)block119.getTree()):null), SYN_SEMPRED));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLR.g:809:5: ROOT
+					{
+					ROOT124=(Token)match(input,ROOT,FOLLOW_ROOT_in_ebnf2216); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ROOT.add(ROOT124);
+
+					// AST REWRITE
+					// elements: ROOT, block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 810:4: -> ^( ROOT block )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:810:7: ^( ROOT block )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot(stream_ROOT.nextNode(), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLR.g:811:5: BANG
+					{
+					BANG125=(Token)match(input,BANG,FOLLOW_BANG_in_ebnf2233); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_BANG.add(BANG125);
+
+					// AST REWRITE
+					// elements: BANG, block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 812:4: -> ^( BANG block )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:812:7: ^( BANG block )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot(stream_BANG.nextNode(), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/ANTLR.g:814:4: 
+					{
+					// AST REWRITE
+					// elements: block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 814:4: -> block
+					{
+						adaptor.addChild(root_0, stream_block.nextTree());
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ebnf"
+
+
+	public static class range_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "range"
+	// org/antlr/grammar/v3/ANTLR.g:818:1: range : ({...}? =>c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2) | (t= TOKEN_REF r= RANGE TOKEN_REF |t= STRING_LITERAL r= RANGE STRING_LITERAL |t= CHAR_LITERAL r= RANGE CHAR_LITERAL ) -> $t);
+	public final ANTLRParser.range_return range() throws RecognitionException {
+		ANTLRParser.range_return retval = new ANTLRParser.range_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token c1=null;
+		Token c2=null;
+		Token t=null;
+		Token r=null;
+		Token RANGE126=null;
+		Token TOKEN_REF127=null;
+		Token STRING_LITERAL128=null;
+		Token CHAR_LITERAL129=null;
+
+		GrammarAST c1_tree=null;
+		GrammarAST c2_tree=null;
+		GrammarAST t_tree=null;
+		GrammarAST r_tree=null;
+		GrammarAST RANGE126_tree=null;
+		GrammarAST TOKEN_REF127_tree=null;
+		GrammarAST STRING_LITERAL128_tree=null;
+		GrammarAST CHAR_LITERAL129_tree=null;
+		RewriteRuleTokenStream stream_TOKEN_REF=new RewriteRuleTokenStream(adaptor,"token TOKEN_REF");
+		RewriteRuleTokenStream stream_STRING_LITERAL=new RewriteRuleTokenStream(adaptor,"token STRING_LITERAL");
+		RewriteRuleTokenStream stream_CHAR_LITERAL=new RewriteRuleTokenStream(adaptor,"token CHAR_LITERAL");
+		RewriteRuleTokenStream stream_RANGE=new RewriteRuleTokenStream(adaptor,"token RANGE");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:819:2: ({...}? =>c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2) | (t= TOKEN_REF r= RANGE TOKEN_REF |t= STRING_LITERAL r= RANGE STRING_LITERAL |t= CHAR_LITERAL r= RANGE CHAR_LITERAL ) -> $t)
+			int alt65=2;
+			int LA65_0 = input.LA(1);
+			if ( (LA65_0==CHAR_LITERAL) ) {
+				int LA65_1 = input.LA(2);
+				if ( (LA65_1==RANGE) ) {
+					int LA65_3 = input.LA(3);
+					if ( (LA65_3==CHAR_LITERAL) ) {
+						int LA65_4 = input.LA(4);
+						if ( ((Rule.getRuleType(currentRuleName) == Grammar.LEXER)) ) {
+							alt65=1;
+						}
+						else if ( (true) ) {
+							alt65=2;
+						}
+
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 65, 3, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 65, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+			else if ( (LA65_0==STRING_LITERAL||LA65_0==TOKEN_REF) ) {
+				alt65=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 65, 0, input);
+				throw nvae;
+			}
+
+			switch (alt65) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:819:4: {...}? =>c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL
+					{
+					if ( !((Rule.getRuleType(currentRuleName) == Grammar.LEXER)) ) {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						throw new FailedPredicateException(input, "range", "Rule.getRuleType(currentRuleName) == Grammar.LEXER");
+					}
+					c1=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_range2280); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_CHAR_LITERAL.add(c1);
+
+					RANGE126=(Token)match(input,RANGE,FOLLOW_RANGE_in_range2282); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_RANGE.add(RANGE126);
+
+					c2=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_range2286); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_CHAR_LITERAL.add(c2);
+
+					// AST REWRITE
+					// elements: c2, c1
+					// token labels: c1, c2
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleTokenStream stream_c1=new RewriteRuleTokenStream(adaptor,"token c1",c1);
+					RewriteRuleTokenStream stream_c2=new RewriteRuleTokenStream(adaptor,"token c2",c2);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 821:3: -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2)
+					{
+						// org/antlr/grammar/v3/ANTLR.g:821:6: ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2)
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(CHAR_RANGE, c1, ".."), root_1);
+						adaptor.addChild(root_1, stream_c1.nextNode());
+						adaptor.addChild(root_1, stream_c2.nextNode());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:823:3: (t= TOKEN_REF r= RANGE TOKEN_REF |t= STRING_LITERAL r= RANGE STRING_LITERAL |t= CHAR_LITERAL r= RANGE CHAR_LITERAL )
+					{
+					// org/antlr/grammar/v3/ANTLR.g:823:3: (t= TOKEN_REF r= RANGE TOKEN_REF |t= STRING_LITERAL r= RANGE STRING_LITERAL |t= CHAR_LITERAL r= RANGE CHAR_LITERAL )
+					int alt64=3;
+					switch ( input.LA(1) ) {
+					case TOKEN_REF:
+						{
+						alt64=1;
+						}
+						break;
+					case STRING_LITERAL:
+						{
+						alt64=2;
+						}
+						break;
+					case CHAR_LITERAL:
+						{
+						alt64=3;
+						}
+						break;
+					default:
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 64, 0, input);
+						throw nvae;
+					}
+					switch (alt64) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:823:5: t= TOKEN_REF r= RANGE TOKEN_REF
+							{
+							t=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_range2313); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_TOKEN_REF.add(t);
+
+							r=(Token)match(input,RANGE,FOLLOW_RANGE_in_range2317); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_RANGE.add(r);
+
+							TOKEN_REF127=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_range2319); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_TOKEN_REF.add(TOKEN_REF127);
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:824:5: t= STRING_LITERAL r= RANGE STRING_LITERAL
+							{
+							t=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_range2327); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_STRING_LITERAL.add(t);
+
+							r=(Token)match(input,RANGE,FOLLOW_RANGE_in_range2331); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_RANGE.add(r);
+
+							STRING_LITERAL128=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_range2333); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_STRING_LITERAL.add(STRING_LITERAL128);
+
+							}
+							break;
+						case 3 :
+							// org/antlr/grammar/v3/ANTLR.g:825:5: t= CHAR_LITERAL r= RANGE CHAR_LITERAL
+							{
+							t=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_range2341); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_CHAR_LITERAL.add(t);
+
+							r=(Token)match(input,RANGE,FOLLOW_RANGE_in_range2345); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_RANGE.add(r);
+
+							CHAR_LITERAL129=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_range2347); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_CHAR_LITERAL.add(CHAR_LITERAL129);
+
+							}
+							break;
+
+					}
+
+					if ( state.backtracking==0 ) {
+							ErrorManager.syntaxError(
+								ErrorManager.MSG_RANGE_OP_ILLEGAL,grammar,r,null,null);
+							}
+					// AST REWRITE
+					// elements: t
+					// token labels: t
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleTokenStream stream_t=new RewriteRuleTokenStream(adaptor,"token t",t);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 831:3: -> $t
+					{
+						adaptor.addChild(root_0, stream_t.nextNode());
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "range"
+
+
+	public static class terminal_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "terminal"
+	// org/antlr/grammar/v3/ANTLR.g:834:1: terminal : (cl= CHAR_LITERAL ^ ( elementOptions[$cl.tree] !)? ( ROOT ^| BANG ^)? |tr= TOKEN_REF ^ ( elementOptions[$tr.tree] !)? ( ARG_ACTION )? ( ROOT ^| BANG ^)? |sl= STRING_LITERAL ^ ( elementOptions[$sl.tree] !)? ( ROOT ^| BANG ^)? |wi= WILDCARD ( ROOT ^| BANG ^)? );
+	public final ANTLRParser.terminal_return terminal() throws RecognitionException {
+		ANTLRParser.terminal_return retval = new ANTLRParser.terminal_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token cl=null;
+		Token tr=null;
+		Token sl=null;
+		Token wi=null;
+		Token ROOT131=null;
+		Token BANG132=null;
+		Token ARG_ACTION134=null;
+		Token ROOT135=null;
+		Token BANG136=null;
+		Token ROOT138=null;
+		Token BANG139=null;
+		Token ROOT140=null;
+		Token BANG141=null;
+		ParserRuleReturnScope elementOptions130 =null;
+		ParserRuleReturnScope elementOptions133 =null;
+		ParserRuleReturnScope elementOptions137 =null;
+
+		GrammarAST cl_tree=null;
+		GrammarAST tr_tree=null;
+		GrammarAST sl_tree=null;
+		GrammarAST wi_tree=null;
+		GrammarAST ROOT131_tree=null;
+		GrammarAST BANG132_tree=null;
+		GrammarAST ARG_ACTION134_tree=null;
+		GrammarAST ROOT135_tree=null;
+		GrammarAST BANG136_tree=null;
+		GrammarAST ROOT138_tree=null;
+		GrammarAST BANG139_tree=null;
+		GrammarAST ROOT140_tree=null;
+		GrammarAST BANG141_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:835:2: (cl= CHAR_LITERAL ^ ( elementOptions[$cl.tree] !)? ( ROOT ^| BANG ^)? |tr= TOKEN_REF ^ ( elementOptions[$tr.tree] !)? ( ARG_ACTION )? ( ROOT ^| BANG ^)? |sl= STRING_LITERAL ^ ( elementOptions[$sl.tree] !)? ( ROOT ^| BANG ^)? |wi= WILDCARD ( ROOT ^| BANG ^)? )
+			int alt74=4;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				alt74=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt74=2;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt74=3;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt74=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 74, 0, input);
+				throw nvae;
+			}
+			switch (alt74) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:835:4: cl= CHAR_LITERAL ^ ( elementOptions[$cl.tree] !)? ( ROOT ^| BANG ^)?
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					cl=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_terminal2376); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					cl_tree = (GrammarAST)adaptor.create(cl);
+					root_0 = (GrammarAST)adaptor.becomeRoot(cl_tree, root_0);
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:835:21: ( elementOptions[$cl.tree] !)?
+					int alt66=2;
+					int LA66_0 = input.LA(1);
+					if ( (LA66_0==OPEN_ELEMENT_OPTION) ) {
+						alt66=1;
+					}
+					switch (alt66) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:835:23: elementOptions[$cl.tree] !
+							{
+							pushFollow(FOLLOW_elementOptions_in_terminal2381);
+							elementOptions130=elementOptions(cl_tree);
+							state._fsp--;
+							if (state.failed) return retval;
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:835:52: ( ROOT ^| BANG ^)?
+					int alt67=3;
+					int LA67_0 = input.LA(1);
+					if ( (LA67_0==ROOT) ) {
+						alt67=1;
+					}
+					else if ( (LA67_0==BANG) ) {
+						alt67=2;
+					}
+					switch (alt67) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:835:53: ROOT ^
+							{
+							ROOT131=(Token)match(input,ROOT,FOLLOW_ROOT_in_terminal2389); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ROOT131_tree = (GrammarAST)adaptor.create(ROOT131);
+							root_0 = (GrammarAST)adaptor.becomeRoot(ROOT131_tree, root_0);
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:835:59: BANG ^
+							{
+							BANG132=(Token)match(input,BANG,FOLLOW_BANG_in_terminal2392); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							BANG132_tree = (GrammarAST)adaptor.create(BANG132);
+							root_0 = (GrammarAST)adaptor.becomeRoot(BANG132_tree, root_0);
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:837:4: tr= TOKEN_REF ^ ( elementOptions[$tr.tree] !)? ( ARG_ACTION )? ( ROOT ^| BANG ^)?
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					tr=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_terminal2403); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					tr_tree = (GrammarAST)adaptor.create(tr);
+					root_0 = (GrammarAST)adaptor.becomeRoot(tr_tree, root_0);
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:838:3: ( elementOptions[$tr.tree] !)?
+					int alt68=2;
+					int LA68_0 = input.LA(1);
+					if ( (LA68_0==OPEN_ELEMENT_OPTION) ) {
+						alt68=1;
+					}
+					switch (alt68) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:838:5: elementOptions[$tr.tree] !
+							{
+							pushFollow(FOLLOW_elementOptions_in_terminal2410);
+							elementOptions133=elementOptions(tr_tree);
+							state._fsp--;
+							if (state.failed) return retval;
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:839:3: ( ARG_ACTION )?
+					int alt69=2;
+					int LA69_0 = input.LA(1);
+					if ( (LA69_0==ARG_ACTION) ) {
+						alt69=1;
+					}
+					switch (alt69) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:839:5: ARG_ACTION
+							{
+							ARG_ACTION134=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_terminal2421); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ARG_ACTION134_tree = (GrammarAST)adaptor.create(ARG_ACTION134);
+							adaptor.addChild(root_0, ARG_ACTION134_tree);
+							}
+
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:840:3: ( ROOT ^| BANG ^)?
+					int alt70=3;
+					int LA70_0 = input.LA(1);
+					if ( (LA70_0==ROOT) ) {
+						alt70=1;
+					}
+					else if ( (LA70_0==BANG) ) {
+						alt70=2;
+					}
+					switch (alt70) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:840:4: ROOT ^
+							{
+							ROOT135=(Token)match(input,ROOT,FOLLOW_ROOT_in_terminal2430); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ROOT135_tree = (GrammarAST)adaptor.create(ROOT135);
+							root_0 = (GrammarAST)adaptor.becomeRoot(ROOT135_tree, root_0);
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:840:10: BANG ^
+							{
+							BANG136=(Token)match(input,BANG,FOLLOW_BANG_in_terminal2433); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							BANG136_tree = (GrammarAST)adaptor.create(BANG136);
+							root_0 = (GrammarAST)adaptor.becomeRoot(BANG136_tree, root_0);
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:842:4: sl= STRING_LITERAL ^ ( elementOptions[$sl.tree] !)? ( ROOT ^| BANG ^)?
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					sl=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_terminal2444); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					sl_tree = (GrammarAST)adaptor.create(sl);
+					root_0 = (GrammarAST)adaptor.becomeRoot(sl_tree, root_0);
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:842:23: ( elementOptions[$sl.tree] !)?
+					int alt71=2;
+					int LA71_0 = input.LA(1);
+					if ( (LA71_0==OPEN_ELEMENT_OPTION) ) {
+						alt71=1;
+					}
+					switch (alt71) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:842:25: elementOptions[$sl.tree] !
+							{
+							pushFollow(FOLLOW_elementOptions_in_terminal2449);
+							elementOptions137=elementOptions(sl_tree);
+							state._fsp--;
+							if (state.failed) return retval;
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:842:54: ( ROOT ^| BANG ^)?
+					int alt72=3;
+					int LA72_0 = input.LA(1);
+					if ( (LA72_0==ROOT) ) {
+						alt72=1;
+					}
+					else if ( (LA72_0==BANG) ) {
+						alt72=2;
+					}
+					switch (alt72) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:842:55: ROOT ^
+							{
+							ROOT138=(Token)match(input,ROOT,FOLLOW_ROOT_in_terminal2457); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ROOT138_tree = (GrammarAST)adaptor.create(ROOT138);
+							root_0 = (GrammarAST)adaptor.becomeRoot(ROOT138_tree, root_0);
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:842:61: BANG ^
+							{
+							BANG139=(Token)match(input,BANG,FOLLOW_BANG_in_terminal2460); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							BANG139_tree = (GrammarAST)adaptor.create(BANG139);
+							root_0 = (GrammarAST)adaptor.becomeRoot(BANG139_tree, root_0);
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:844:4: wi= WILDCARD ( ROOT ^| BANG ^)?
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					wi=(Token)match(input,WILDCARD,FOLLOW_WILDCARD_in_terminal2471); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					wi_tree = (GrammarAST)adaptor.create(wi);
+					adaptor.addChild(root_0, wi_tree);
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:844:16: ( ROOT ^| BANG ^)?
+					int alt73=3;
+					int LA73_0 = input.LA(1);
+					if ( (LA73_0==ROOT) ) {
+						alt73=1;
+					}
+					else if ( (LA73_0==BANG) ) {
+						alt73=2;
+					}
+					switch (alt73) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:844:17: ROOT ^
+							{
+							ROOT140=(Token)match(input,ROOT,FOLLOW_ROOT_in_terminal2474); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ROOT140_tree = (GrammarAST)adaptor.create(ROOT140);
+							root_0 = (GrammarAST)adaptor.becomeRoot(ROOT140_tree, root_0);
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:844:23: BANG ^
+							{
+							BANG141=(Token)match(input,BANG,FOLLOW_BANG_in_terminal2477); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							BANG141_tree = (GrammarAST)adaptor.create(BANG141);
+							root_0 = (GrammarAST)adaptor.becomeRoot(BANG141_tree, root_0);
+							}
+
+							}
+							break;
+
+					}
+
+					if ( state.backtracking==0 ) {
+								if ( atTreeRoot )
+								{
+									ErrorManager.syntaxError(
+										ErrorManager.MSG_WILDCARD_AS_ROOT,grammar,wi,null,null);
+								}
+							}
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "terminal"
+
+
+	public static class elementOptions_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "elementOptions"
+	// org/antlr/grammar/v3/ANTLR.g:854:1: elementOptions[GrammarAST terminalAST] : ( OPEN_ELEMENT_OPTION ^ defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION !| OPEN_ELEMENT_OPTION ^ elementOption[terminalAST] ( SEMI ! elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION !);
+	public final ANTLRParser.elementOptions_return elementOptions(GrammarAST terminalAST) throws RecognitionException {
+		ANTLRParser.elementOptions_return retval = new ANTLRParser.elementOptions_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token OPEN_ELEMENT_OPTION142=null;
+		Token CLOSE_ELEMENT_OPTION144=null;
+		Token OPEN_ELEMENT_OPTION145=null;
+		Token SEMI147=null;
+		Token CLOSE_ELEMENT_OPTION149=null;
+		ParserRuleReturnScope defaultNodeOption143 =null;
+		ParserRuleReturnScope elementOption146 =null;
+		ParserRuleReturnScope elementOption148 =null;
+
+		GrammarAST OPEN_ELEMENT_OPTION142_tree=null;
+		GrammarAST CLOSE_ELEMENT_OPTION144_tree=null;
+		GrammarAST OPEN_ELEMENT_OPTION145_tree=null;
+		GrammarAST SEMI147_tree=null;
+		GrammarAST CLOSE_ELEMENT_OPTION149_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:855:2: ( OPEN_ELEMENT_OPTION ^ defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION !| OPEN_ELEMENT_OPTION ^ elementOption[terminalAST] ( SEMI ! elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION !)
+			int alt76=2;
+			int LA76_0 = input.LA(1);
+			if ( (LA76_0==OPEN_ELEMENT_OPTION) ) {
+				int LA76_1 = input.LA(2);
+				if ( (LA76_1==TOKEN_REF) ) {
+					int LA76_2 = input.LA(3);
+					if ( (LA76_2==CLOSE_ELEMENT_OPTION||LA76_2==WILDCARD) ) {
+						alt76=1;
+					}
+					else if ( (LA76_2==ASSIGN) ) {
+						alt76=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 76, 2, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+				else if ( (LA76_1==RULE_REF) ) {
+					int LA76_3 = input.LA(3);
+					if ( (LA76_3==CLOSE_ELEMENT_OPTION||LA76_3==WILDCARD) ) {
+						alt76=1;
+					}
+					else if ( (LA76_3==ASSIGN) ) {
+						alt76=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 76, 3, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 76, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 76, 0, input);
+				throw nvae;
+			}
+
+			switch (alt76) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:855:4: OPEN_ELEMENT_OPTION ^ defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION !
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					OPEN_ELEMENT_OPTION142=(Token)match(input,OPEN_ELEMENT_OPTION,FOLLOW_OPEN_ELEMENT_OPTION_in_elementOptions2496); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					OPEN_ELEMENT_OPTION142_tree = (GrammarAST)adaptor.create(OPEN_ELEMENT_OPTION142);
+					root_0 = (GrammarAST)adaptor.becomeRoot(OPEN_ELEMENT_OPTION142_tree, root_0);
+					}
+
+					pushFollow(FOLLOW_defaultNodeOption_in_elementOptions2499);
+					defaultNodeOption143=defaultNodeOption(terminalAST);
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, defaultNodeOption143.getTree());
+
+					CLOSE_ELEMENT_OPTION144=(Token)match(input,CLOSE_ELEMENT_OPTION,FOLLOW_CLOSE_ELEMENT_OPTION_in_elementOptions2502); if (state.failed) return retval;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:856:4: OPEN_ELEMENT_OPTION ^ elementOption[terminalAST] ( SEMI ! elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION !
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					OPEN_ELEMENT_OPTION145=(Token)match(input,OPEN_ELEMENT_OPTION,FOLLOW_OPEN_ELEMENT_OPTION_in_elementOptions2508); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					OPEN_ELEMENT_OPTION145_tree = (GrammarAST)adaptor.create(OPEN_ELEMENT_OPTION145);
+					root_0 = (GrammarAST)adaptor.becomeRoot(OPEN_ELEMENT_OPTION145_tree, root_0);
+					}
+
+					pushFollow(FOLLOW_elementOption_in_elementOptions2511);
+					elementOption146=elementOption(terminalAST);
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, elementOption146.getTree());
+
+					// org/antlr/grammar/v3/ANTLR.g:856:52: ( SEMI ! elementOption[terminalAST] )*
+					loop75:
+					while (true) {
+						int alt75=2;
+						int LA75_0 = input.LA(1);
+						if ( (LA75_0==SEMI) ) {
+							alt75=1;
+						}
+
+						switch (alt75) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:856:53: SEMI ! elementOption[terminalAST]
+							{
+							SEMI147=(Token)match(input,SEMI,FOLLOW_SEMI_in_elementOptions2515); if (state.failed) return retval;
+							pushFollow(FOLLOW_elementOption_in_elementOptions2518);
+							elementOption148=elementOption(terminalAST);
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, elementOption148.getTree());
+
+							}
+							break;
+
+						default :
+							break loop75;
+						}
+					}
+
+					CLOSE_ELEMENT_OPTION149=(Token)match(input,CLOSE_ELEMENT_OPTION,FOLLOW_CLOSE_ELEMENT_OPTION_in_elementOptions2523); if (state.failed) return retval;
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "elementOptions"
+
+
+	public static class defaultNodeOption_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "defaultNodeOption"
+	// org/antlr/grammar/v3/ANTLR.g:859:1: defaultNodeOption[GrammarAST terminalAST] : elementOptionId ;
+	public final ANTLRParser.defaultNodeOption_return defaultNodeOption(GrammarAST terminalAST) throws RecognitionException {
+		ANTLRParser.defaultNodeOption_return retval = new ANTLRParser.defaultNodeOption_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ParserRuleReturnScope elementOptionId150 =null;
+
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:860:2: ( elementOptionId )
+			// org/antlr/grammar/v3/ANTLR.g:860:4: elementOptionId
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			pushFollow(FOLLOW_elementOptionId_in_defaultNodeOption2536);
+			elementOptionId150=elementOptionId();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, elementOptionId150.getTree());
+
+			if ( state.backtracking==0 ) {terminalAST.setTerminalOption(grammar,Grammar.defaultTokenOption,(elementOptionId150!=null?((ANTLRParser.elementOptionId_return)elementOptionId150).qid:null));}
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "defaultNodeOption"
+
+
+	public static class elementOption_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "elementOption"
+	// org/antlr/grammar/v3/ANTLR.g:864:1: elementOption[GrammarAST terminalAST] : id ASSIGN ^ ( elementOptionId | (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL ) ) ;
+	public final ANTLRParser.elementOption_return elementOption(GrammarAST terminalAST) throws RecognitionException {
+		ANTLRParser.elementOption_return retval = new ANTLRParser.elementOption_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token t=null;
+		Token ASSIGN152=null;
+		ParserRuleReturnScope id151 =null;
+		ParserRuleReturnScope elementOptionId153 =null;
+
+		GrammarAST t_tree=null;
+		GrammarAST ASSIGN152_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:865:2: ( id ASSIGN ^ ( elementOptionId | (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL ) ) )
+			// org/antlr/grammar/v3/ANTLR.g:865:4: id ASSIGN ^ ( elementOptionId | (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL ) )
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			pushFollow(FOLLOW_id_in_elementOption2552);
+			id151=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, id151.getTree());
+
+			ASSIGN152=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_elementOption2554); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ASSIGN152_tree = (GrammarAST)adaptor.create(ASSIGN152);
+			root_0 = (GrammarAST)adaptor.becomeRoot(ASSIGN152_tree, root_0);
+			}
+
+			// org/antlr/grammar/v3/ANTLR.g:866:3: ( elementOptionId | (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL ) )
+			int alt78=2;
+			int LA78_0 = input.LA(1);
+			if ( (LA78_0==RULE_REF||LA78_0==TOKEN_REF) ) {
+				alt78=1;
+			}
+			else if ( ((LA78_0 >= DOUBLE_ANGLE_STRING_LITERAL && LA78_0 <= DOUBLE_QUOTE_STRING_LITERAL)||LA78_0==STRING_LITERAL) ) {
+				alt78=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 78, 0, input);
+				throw nvae;
+			}
+
+			switch (alt78) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:866:5: elementOptionId
+					{
+					pushFollow(FOLLOW_elementOptionId_in_elementOption2561);
+					elementOptionId153=elementOptionId();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, elementOptionId153.getTree());
+
+					if ( state.backtracking==0 ) {terminalAST.setTerminalOption(grammar,(id151!=null?input.toString(id151.start,id151.stop):null),(elementOptionId153!=null?((ANTLRParser.elementOptionId_return)elementOptionId153).qid:null));}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:868:5: (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL )
+					{
+					// org/antlr/grammar/v3/ANTLR.g:868:5: (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL )
+					int alt77=3;
+					switch ( input.LA(1) ) {
+					case STRING_LITERAL:
+						{
+						alt77=1;
+						}
+						break;
+					case DOUBLE_QUOTE_STRING_LITERAL:
+						{
+						alt77=2;
+						}
+						break;
+					case DOUBLE_ANGLE_STRING_LITERAL:
+						{
+						alt77=3;
+						}
+						break;
+					default:
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 77, 0, input);
+						throw nvae;
+					}
+					switch (alt77) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:868:6: t= STRING_LITERAL
+							{
+							t=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_elementOption2575); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							t_tree = (GrammarAST)adaptor.create(t);
+							adaptor.addChild(root_0, t_tree);
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:868:23: t= DOUBLE_QUOTE_STRING_LITERAL
+							{
+							t=(Token)match(input,DOUBLE_QUOTE_STRING_LITERAL,FOLLOW_DOUBLE_QUOTE_STRING_LITERAL_in_elementOption2579); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							t_tree = (GrammarAST)adaptor.create(t);
+							adaptor.addChild(root_0, t_tree);
+							}
+
+							}
+							break;
+						case 3 :
+							// org/antlr/grammar/v3/ANTLR.g:868:53: t= DOUBLE_ANGLE_STRING_LITERAL
+							{
+							t=(Token)match(input,DOUBLE_ANGLE_STRING_LITERAL,FOLLOW_DOUBLE_ANGLE_STRING_LITERAL_in_elementOption2583); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							t_tree = (GrammarAST)adaptor.create(t);
+							adaptor.addChild(root_0, t_tree);
+							}
+
+							}
+							break;
+
+					}
+
+					if ( state.backtracking==0 ) {terminalAST.setTerminalOption(grammar,(id151!=null?input.toString(id151.start,id151.stop):null),(t!=null?t.getText():null));}
+					}
+					break;
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "elementOption"
+
+
+	public static class elementOptionId_return extends ParserRuleReturnScope {
+		public String qid;
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "elementOptionId"
+	// org/antlr/grammar/v3/ANTLR.g:873:1: elementOptionId returns [String qid] : i= id ( '.' i= id )* ;
+	public final ANTLRParser.elementOptionId_return elementOptionId() throws RecognitionException {
+		ANTLRParser.elementOptionId_return retval = new ANTLRParser.elementOptionId_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token char_literal154=null;
+		ParserRuleReturnScope i =null;
+
+		GrammarAST char_literal154_tree=null;
+
+		StringBuffer buf = new StringBuffer();
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:875:2: (i= id ( '.' i= id )* )
+			// org/antlr/grammar/v3/ANTLR.g:875:4: i= id ( '.' i= id )*
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			pushFollow(FOLLOW_id_in_elementOptionId2614);
+			i=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, i.getTree());
+
+			if ( state.backtracking==0 ) {buf.append((i!=null?input.toString(i.start,i.stop):null));}
+			// org/antlr/grammar/v3/ANTLR.g:875:32: ( '.' i= id )*
+			loop79:
+			while (true) {
+				int alt79=2;
+				int LA79_0 = input.LA(1);
+				if ( (LA79_0==WILDCARD) ) {
+					alt79=1;
+				}
+
+				switch (alt79) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:875:33: '.' i= id
+					{
+					char_literal154=(Token)match(input,WILDCARD,FOLLOW_WILDCARD_in_elementOptionId2619); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					char_literal154_tree = (GrammarAST)adaptor.create(char_literal154);
+					adaptor.addChild(root_0, char_literal154_tree);
+					}
+
+					pushFollow(FOLLOW_id_in_elementOptionId2623);
+					i=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, i.getTree());
+
+					if ( state.backtracking==0 ) {buf.append("." + (i!=null?input.toString(i.start,i.stop):null));}
+					}
+					break;
+
+				default :
+					break loop79;
+				}
+			}
+
+			if ( state.backtracking==0 ) {retval.qid = buf.toString();}
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "elementOptionId"
+
+
+	public static class ebnfSuffix_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ebnfSuffix"
+	// org/antlr/grammar/v3/ANTLR.g:879:1: ebnfSuffix[GrammarAST elemAST, boolean inRewrite] : ( -> BLOCK[$elemAST.getToken(), \"BLOCK\"] ) ( -> ^( ALT[$elemAST.getToken(), \"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.getToken(),\"?\"] | STAR -> CLOSURE[$elemAST.getToken(),\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.getToken(),\"+\"] ) -> ^( $ebnfSuffix ^( EOB[$elemAST.getToken(), \"<end-of-block>\"] ) ) ;
+	public final ANTLRParser.ebnfSuffix_return ebnfSuffix(GrammarAST elemAST, boolean inRewrite) throws RecognitionException {
+		ANTLRParser.ebnfSuffix_return retval = new ANTLRParser.ebnfSuffix_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token QUESTION155=null;
+		Token STAR156=null;
+		Token PLUS157=null;
+
+		GrammarAST QUESTION155_tree=null;
+		GrammarAST STAR156_tree=null;
+		GrammarAST PLUS157_tree=null;
+		RewriteRuleTokenStream stream_STAR=new RewriteRuleTokenStream(adaptor,"token STAR");
+		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
+		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
+
+
+		GrammarAST blkRoot=null;
+		GrammarAST alt=null;
+		GrammarAST save = currentBlockAST;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:890:2: ( ( -> BLOCK[$elemAST.getToken(), \"BLOCK\"] ) ( -> ^( ALT[$elemAST.getToken(), \"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.getToken(),\"?\"] | STAR -> CLOSURE[$elemAST.getToken(),\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.getToken(),\"+\"] ) -> ^( $ebnfSuffix ^( EOB[$elemAST.getToken(), \"<end-of-block>\"] ) ) )
+			// org/antlr/grammar/v3/ANTLR.g:890:4: ( -> BLOCK[$elemAST.getToken(), \"BLOCK\"] ) ( -> ^( ALT[$elemAST.getToken(), \"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.getToken(),\"?\"] | STAR -> CLOSURE[$elemAST.getToken(),\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.getToken(),\"+\"] )
+			{
+			// org/antlr/grammar/v3/ANTLR.g:890:4: ( -> BLOCK[$elemAST.getToken(), \"BLOCK\"] )
+			// org/antlr/grammar/v3/ANTLR.g:890:6: 
+			{
+			// AST REWRITE
+			// elements: 
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 890:6: -> BLOCK[$elemAST.getToken(), \"BLOCK\"]
+			{
+				adaptor.addChild(root_0, (GrammarAST)adaptor.create(BLOCK, elemAST.getToken(), "BLOCK"));
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			if ( state.backtracking==0 ) { blkRoot = (GrammarAST)retval.tree.getChild(0); currentBlockAST = blkRoot; }
+			// org/antlr/grammar/v3/ANTLR.g:893:3: ( -> ^( ALT[$elemAST.getToken(), \"ALT\"] EOA[\"<end-of-alt>\"] ) )
+			// org/antlr/grammar/v3/ANTLR.g:894:4: 
+			{
+			// AST REWRITE
+			// elements: 
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 894:4: -> ^( ALT[$elemAST.getToken(), \"ALT\"] EOA[\"<end-of-alt>\"] )
+			{
+				// org/antlr/grammar/v3/ANTLR.g:894:7: ^( ALT[$elemAST.getToken(), \"ALT\"] EOA[\"<end-of-alt>\"] )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(ALT, elemAST.getToken(), "ALT"), root_1);
+				adaptor.addChild(root_1, elemAST);
+				adaptor.addChild(root_1, (GrammarAST)adaptor.create(EOA, "<end-of-alt>"));
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			if ( state.backtracking==0 ) {
+						alt = (GrammarAST)retval.tree.getChild(0);
+						if ( !inRewrite )
+							prefixWithSynPred(alt);
+					}
+			// org/antlr/grammar/v3/ANTLR.g:901:3: ( QUESTION -> OPTIONAL[$elemAST.getToken(),\"?\"] | STAR -> CLOSURE[$elemAST.getToken(),\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.getToken(),\"+\"] )
+			int alt80=3;
+			switch ( input.LA(1) ) {
+			case QUESTION:
+				{
+				alt80=1;
+				}
+				break;
+			case STAR:
+				{
+				alt80=2;
+				}
+				break;
+			case PLUS:
+				{
+				alt80=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 80, 0, input);
+				throw nvae;
+			}
+			switch (alt80) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:901:5: QUESTION
+					{
+					QUESTION155=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_ebnfSuffix2700); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_QUESTION.add(QUESTION155);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 902:4: -> OPTIONAL[$elemAST.getToken(),\"?\"]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(OPTIONAL, elemAST.getToken(), "?"));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:903:5: STAR
+					{
+					STAR156=(Token)match(input,STAR,FOLLOW_STAR_in_ebnfSuffix2714); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_STAR.add(STAR156);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 904:4: -> CLOSURE[$elemAST.getToken(),\"*\"]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(CLOSURE, elemAST.getToken(), "*"));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:905:5: PLUS
+					{
+					PLUS157=(Token)match(input,PLUS,FOLLOW_PLUS_in_ebnfSuffix2728); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_PLUS.add(PLUS157);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 906:4: -> POSITIVE_CLOSURE[$elemAST.getToken(),\"+\"]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(POSITIVE_CLOSURE, elemAST.getToken(), "+"));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+
+			// AST REWRITE
+			// elements: ebnfSuffix
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 908:3: -> ^( $ebnfSuffix ^( EOB[$elemAST.getToken(), \"<end-of-block>\"] ) )
+			{
+				// org/antlr/grammar/v3/ANTLR.g:908:6: ^( $ebnfSuffix ^( EOB[$elemAST.getToken(), \"<end-of-block>\"] ) )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot(stream_retval.nextNode(), root_1);
+				// org/antlr/grammar/v3/ANTLR.g:908:20: ^( EOB[$elemAST.getToken(), \"<end-of-block>\"] )
+				{
+				GrammarAST root_2 = (GrammarAST)adaptor.nil();
+				root_2 = (GrammarAST)adaptor.becomeRoot(blkRoot, root_2);
+				adaptor.addChild(root_2, alt);
+				adaptor.addChild(root_2, (GrammarAST)adaptor.create(EOB, elemAST.getToken(), "<end-of-block>"));
+				adaptor.addChild(root_1, root_2);
+				}
+
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+			if ( state.backtracking==0 ) {
+			currentBlockAST = save;
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ebnfSuffix"
+
+
+	public static class notTerminal_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "notTerminal"
+	// org/antlr/grammar/v3/ANTLR.g:911:1: notTerminal : ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL );
+	public final ANTLRParser.notTerminal_return notTerminal() throws RecognitionException {
+		ANTLRParser.notTerminal_return retval = new ANTLRParser.notTerminal_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token set158=null;
+
+		GrammarAST set158_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:912:2: ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL )
+			// org/antlr/grammar/v3/ANTLR.g:
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			set158=input.LT(1);
+			if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL||input.LA(1)==TOKEN_REF ) {
+				input.consume();
+				if ( state.backtracking==0 ) adaptor.addChild(root_0, (GrammarAST)adaptor.create(set158));
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "notTerminal"
+
+
+	public static class idList_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "idList"
+	// org/antlr/grammar/v3/ANTLR.g:917:1: idList : id ( COMMA ! id )* ;
+	public final ANTLRParser.idList_return idList() throws RecognitionException {
+		ANTLRParser.idList_return retval = new ANTLRParser.idList_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token COMMA160=null;
+		ParserRuleReturnScope id159 =null;
+		ParserRuleReturnScope id161 =null;
+
+		GrammarAST COMMA160_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:918:2: ( id ( COMMA ! id )* )
+			// org/antlr/grammar/v3/ANTLR.g:918:4: id ( COMMA ! id )*
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			pushFollow(FOLLOW_id_in_idList2790);
+			id159=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, id159.getTree());
+
+			// org/antlr/grammar/v3/ANTLR.g:918:7: ( COMMA ! id )*
+			loop81:
+			while (true) {
+				int alt81=2;
+				int LA81_0 = input.LA(1);
+				if ( (LA81_0==COMMA) ) {
+					alt81=1;
+				}
+
+				switch (alt81) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:918:8: COMMA ! id
+					{
+					COMMA160=(Token)match(input,COMMA,FOLLOW_COMMA_in_idList2793); if (state.failed) return retval;
+					pushFollow(FOLLOW_id_in_idList2796);
+					id161=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, id161.getTree());
+
+					}
+					break;
+
+				default :
+					break loop81;
+				}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "idList"
+
+
+	public static class id_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "id"
+	// org/antlr/grammar/v3/ANTLR.g:921:1: id : ( TOKEN_REF -> ID[$TOKEN_REF] | RULE_REF -> ID[$RULE_REF] );
+	public final ANTLRParser.id_return id() throws RecognitionException {
+		ANTLRParser.id_return retval = new ANTLRParser.id_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token TOKEN_REF162=null;
+		Token RULE_REF163=null;
+
+		GrammarAST TOKEN_REF162_tree=null;
+		GrammarAST RULE_REF163_tree=null;
+		RewriteRuleTokenStream stream_TOKEN_REF=new RewriteRuleTokenStream(adaptor,"token TOKEN_REF");
+		RewriteRuleTokenStream stream_RULE_REF=new RewriteRuleTokenStream(adaptor,"token RULE_REF");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:922:2: ( TOKEN_REF -> ID[$TOKEN_REF] | RULE_REF -> ID[$RULE_REF] )
+			int alt82=2;
+			int LA82_0 = input.LA(1);
+			if ( (LA82_0==TOKEN_REF) ) {
+				alt82=1;
+			}
+			else if ( (LA82_0==RULE_REF) ) {
+				alt82=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 82, 0, input);
+				throw nvae;
+			}
+
+			switch (alt82) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:922:4: TOKEN_REF
+					{
+					TOKEN_REF162=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_id2809); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_TOKEN_REF.add(TOKEN_REF162);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 923:3: -> ID[$TOKEN_REF]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(ID, TOKEN_REF162));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:924:4: RULE_REF
+					{
+					RULE_REF163=(Token)match(input,RULE_REF,FOLLOW_RULE_REF_in_id2821); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_RULE_REF.add(RULE_REF163);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 925:3: -> ID[$RULE_REF]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(ID, RULE_REF163));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "id"
+
+
+	public static class rewrite_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite"
+	// org/antlr/grammar/v3/ANTLR.g:930:1: rewrite : ( ( rewrite_with_sempred )* REWRITE rewrite_alternative -> ^( REWRITES ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) ) |);
+	public final ANTLRParser.rewrite_return rewrite() throws RecognitionException {
+		ANTLRParser.rewrite_return retval = new ANTLRParser.rewrite_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token REWRITE165=null;
+		ParserRuleReturnScope rewrite_with_sempred164 =null;
+		ParserRuleReturnScope rewrite_alternative166 =null;
+
+		GrammarAST REWRITE165_tree=null;
+		RewriteRuleTokenStream stream_REWRITE=new RewriteRuleTokenStream(adaptor,"token REWRITE");
+		RewriteRuleSubtreeStream stream_rewrite_alternative=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_alternative");
+		RewriteRuleSubtreeStream stream_rewrite_with_sempred=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_with_sempred");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:931:2: ( ( rewrite_with_sempred )* REWRITE rewrite_alternative -> ^( REWRITES ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) ) |)
+			int alt84=2;
+			int LA84_0 = input.LA(1);
+			if ( (LA84_0==REWRITE) ) {
+				alt84=1;
+			}
+			else if ( (LA84_0==OR||LA84_0==RPAREN||LA84_0==SEMI) ) {
+				alt84=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 84, 0, input);
+				throw nvae;
+			}
+
+			switch (alt84) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:931:4: ( rewrite_with_sempred )* REWRITE rewrite_alternative
+					{
+					// org/antlr/grammar/v3/ANTLR.g:931:4: ( rewrite_with_sempred )*
+					loop83:
+					while (true) {
+						int alt83=2;
+						int LA83_0 = input.LA(1);
+						if ( (LA83_0==REWRITE) ) {
+							int LA83_1 = input.LA(2);
+							if ( (LA83_1==SEMPRED) ) {
+								alt83=1;
+							}
+
+						}
+
+						switch (alt83) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:931:4: rewrite_with_sempred
+							{
+							pushFollow(FOLLOW_rewrite_with_sempred_in_rewrite2841);
+							rewrite_with_sempred164=rewrite_with_sempred();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_rewrite_with_sempred.add(rewrite_with_sempred164.getTree());
+							}
+							break;
+
+						default :
+							break loop83;
+						}
+					}
+
+					REWRITE165=(Token)match(input,REWRITE,FOLLOW_REWRITE_in_rewrite2846); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_REWRITE.add(REWRITE165);
+
+					pushFollow(FOLLOW_rewrite_alternative_in_rewrite2848);
+					rewrite_alternative166=rewrite_alternative();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_alternative.add(rewrite_alternative166.getTree());
+					// AST REWRITE
+					// elements: rewrite_with_sempred, REWRITE, rewrite_alternative
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 933:3: -> ^( REWRITES ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:933:6: ^( REWRITES ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(REWRITES, "REWRITES"), root_1);
+						// org/antlr/grammar/v3/ANTLR.g:933:17: ( rewrite_with_sempred )*
+						while ( stream_rewrite_with_sempred.hasNext() ) {
+							adaptor.addChild(root_1, stream_rewrite_with_sempred.nextTree());
+						}
+						stream_rewrite_with_sempred.reset();
+
+						// org/antlr/grammar/v3/ANTLR.g:933:39: ^( REWRITE rewrite_alternative )
+						{
+						GrammarAST root_2 = (GrammarAST)adaptor.nil();
+						root_2 = (GrammarAST)adaptor.becomeRoot(stream_REWRITE.nextNode(), root_2);
+						adaptor.addChild(root_2, stream_rewrite_alternative.nextTree());
+						adaptor.addChild(root_1, root_2);
+						}
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:935:2: 
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite"
+
+
+	public static class rewrite_with_sempred_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_with_sempred"
+	// org/antlr/grammar/v3/ANTLR.g:937:1: rewrite_with_sempred : REWRITE ^ SEMPRED rewrite_alternative ;
+	public final ANTLRParser.rewrite_with_sempred_return rewrite_with_sempred() throws RecognitionException {
+		ANTLRParser.rewrite_with_sempred_return retval = new ANTLRParser.rewrite_with_sempred_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token REWRITE167=null;
+		Token SEMPRED168=null;
+		ParserRuleReturnScope rewrite_alternative169 =null;
+
+		GrammarAST REWRITE167_tree=null;
+		GrammarAST SEMPRED168_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:938:2: ( REWRITE ^ SEMPRED rewrite_alternative )
+			// org/antlr/grammar/v3/ANTLR.g:938:4: REWRITE ^ SEMPRED rewrite_alternative
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			REWRITE167=(Token)match(input,REWRITE,FOLLOW_REWRITE_in_rewrite_with_sempred2879); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			REWRITE167_tree = (GrammarAST)adaptor.create(REWRITE167);
+			root_0 = (GrammarAST)adaptor.becomeRoot(REWRITE167_tree, root_0);
+			}
+
+			SEMPRED168=(Token)match(input,SEMPRED,FOLLOW_SEMPRED_in_rewrite_with_sempred2882); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			SEMPRED168_tree = (GrammarAST)adaptor.create(SEMPRED168);
+			adaptor.addChild(root_0, SEMPRED168_tree);
+			}
+
+			pushFollow(FOLLOW_rewrite_alternative_in_rewrite_with_sempred2884);
+			rewrite_alternative169=rewrite_alternative();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_alternative169.getTree());
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_with_sempred"
+
+
+	public static class rewrite_block_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_block"
+	// org/antlr/grammar/v3/ANTLR.g:941:1: rewrite_block : LPAREN rewrite_alternative RPAREN -> ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] ) ;
+	public final ANTLRParser.rewrite_block_return rewrite_block() throws RecognitionException {
+		ANTLRParser.rewrite_block_return retval = new ANTLRParser.rewrite_block_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token LPAREN170=null;
+		Token RPAREN172=null;
+		ParserRuleReturnScope rewrite_alternative171 =null;
+
+		GrammarAST LPAREN170_tree=null;
+		GrammarAST RPAREN172_tree=null;
+		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
+		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_rewrite_alternative=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_alternative");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:942:2: ( LPAREN rewrite_alternative RPAREN -> ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] ) )
+			// org/antlr/grammar/v3/ANTLR.g:942:4: LPAREN rewrite_alternative RPAREN
+			{
+			LPAREN170=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_rewrite_block2895); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN170);
+
+			pushFollow(FOLLOW_rewrite_alternative_in_rewrite_block2899);
+			rewrite_alternative171=rewrite_alternative();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite_alternative.add(rewrite_alternative171.getTree());
+			RPAREN172=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_rewrite_block2903); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN172);
+
+			// AST REWRITE
+			// elements: rewrite_alternative
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 945:3: -> ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] )
+			{
+				// org/antlr/grammar/v3/ANTLR.g:945:6: ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(BLOCK, LPAREN170, "BLOCK"), root_1);
+				adaptor.addChild(root_1, stream_rewrite_alternative.nextTree());
+				adaptor.addChild(root_1, (GrammarAST)adaptor.create(EOB, RPAREN172, "<end-of-block>"));
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_block"
+
+
+	public static class rewrite_alternative_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_alternative"
+	// org/antlr/grammar/v3/ANTLR.g:948:1: rewrite_alternative options {k=1; } : ({...}? => rewrite_template |{...}? => ( rewrite_element )+ -> {!stream_rewrite_element.hasNext()}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) |{...}? ETC );
+	public final ANTLRParser.rewrite_alternative_return rewrite_alternative() throws RecognitionException {
+		ANTLRParser.rewrite_alternative_return retval = new ANTLRParser.rewrite_alternative_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token ETC175=null;
+		ParserRuleReturnScope rewrite_template173 =null;
+		ParserRuleReturnScope rewrite_element174 =null;
+
+		GrammarAST ETC175_tree=null;
+		RewriteRuleSubtreeStream stream_rewrite_element=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_element");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:950:2: ({...}? => rewrite_template |{...}? => ( rewrite_element )+ -> {!stream_rewrite_element.hasNext()}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) |{...}? ETC )
+			int alt86=4;
+			int LA86_0 = input.LA(1);
+			if ( (LA86_0==TOKEN_REF) && (((grammar.buildTemplate())||(grammar.buildAST())||((LT(1).getText().equals("template"))&&(grammar.buildTemplate()))))) {
+				int LA86_1 = input.LA(2);
+				if ( ((grammar.buildTemplate())) ) {
+					alt86=1;
+				}
+				else if ( ((grammar.buildAST())) ) {
+					alt86=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 86, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+			else if ( (LA86_0==RULE_REF) && (((grammar.buildTemplate())||(grammar.buildAST())||((LT(1).getText().equals("template"))&&(grammar.buildTemplate()))))) {
+				int LA86_2 = input.LA(2);
+				if ( ((grammar.buildTemplate())) ) {
+					alt86=1;
+				}
+				else if ( ((grammar.buildAST())) ) {
+					alt86=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 86, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+			else if ( (LA86_0==LPAREN) && (((grammar.buildTemplate())||(grammar.buildAST())))) {
+				int LA86_3 = input.LA(2);
+				if ( ((grammar.buildTemplate())) ) {
+					alt86=1;
+				}
+				else if ( ((grammar.buildAST())) ) {
+					alt86=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 86, 3, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+			else if ( (LA86_0==ACTION) && (((grammar.buildTemplate())||(grammar.buildAST())))) {
+				int LA86_4 = input.LA(2);
+				if ( ((grammar.buildTemplate())) ) {
+					alt86=1;
+				}
+				else if ( ((grammar.buildAST())) ) {
+					alt86=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 86, 4, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+			else if ( (LA86_0==CHAR_LITERAL||LA86_0==DOLLAR||LA86_0==STRING_LITERAL||LA86_0==TREE_BEGIN) && ((grammar.buildAST()))) {
+				alt86=2;
+			}
+			else if ( (LA86_0==OR||LA86_0==REWRITE||LA86_0==RPAREN||LA86_0==SEMI) ) {
+				alt86=3;
+			}
+			else if ( (LA86_0==ETC) ) {
+				alt86=4;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 86, 0, input);
+				throw nvae;
+			}
+
+			switch (alt86) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:950:4: {...}? => rewrite_template
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					if ( !((grammar.buildTemplate())) ) {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						throw new FailedPredicateException(input, "rewrite_alternative", "grammar.buildTemplate()");
+					}
+					pushFollow(FOLLOW_rewrite_template_in_rewrite_alternative2939);
+					rewrite_template173=rewrite_template();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_template173.getTree());
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:952:4: {...}? => ( rewrite_element )+
+					{
+					if ( !((grammar.buildAST())) ) {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						throw new FailedPredicateException(input, "rewrite_alternative", "grammar.buildAST()");
+					}
+					// org/antlr/grammar/v3/ANTLR.g:952:29: ( rewrite_element )+
+					int cnt85=0;
+					loop85:
+					while (true) {
+						int alt85=2;
+						int LA85_0 = input.LA(1);
+						if ( (LA85_0==ACTION||LA85_0==CHAR_LITERAL||LA85_0==DOLLAR||LA85_0==LPAREN||LA85_0==RULE_REF||LA85_0==STRING_LITERAL||LA85_0==TOKEN_REF||LA85_0==TREE_BEGIN) ) {
+							alt85=1;
+						}
+
+						switch (alt85) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:952:31: rewrite_element
+							{
+							pushFollow(FOLLOW_rewrite_element_in_rewrite_alternative2951);
+							rewrite_element174=rewrite_element();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_rewrite_element.add(rewrite_element174.getTree());
+							}
+							break;
+
+						default :
+							if ( cnt85 >= 1 ) break loop85;
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							EarlyExitException eee = new EarlyExitException(85, input);
+							throw eee;
+						}
+						cnt85++;
+					}
+
+					// AST REWRITE
+					// elements: rewrite_element
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 953:3: -> {!stream_rewrite_element.hasNext()}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
+					if (!stream_rewrite_element.hasNext()) {
+						// org/antlr/grammar/v3/ANTLR.g:953:43: ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(ALT, LT(1), "ALT"), root_1);
+						adaptor.addChild(root_1, (GrammarAST)adaptor.create(EPSILON, "epsilon"));
+						adaptor.addChild(root_1, (GrammarAST)adaptor.create(EOA, "<end-of-alt>"));
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+					else // 954:3: -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:954:6: ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(ALT, LT(1), "ALT"), root_1);
+						if ( !(stream_rewrite_element.hasNext()) ) {
+							throw new RewriteEarlyExitException();
+						}
+						while ( stream_rewrite_element.hasNext() ) {
+							adaptor.addChild(root_1, stream_rewrite_element.nextTree());
+						}
+						stream_rewrite_element.reset();
+
+						adaptor.addChild(root_1, (GrammarAST)adaptor.create(EOA, "<end-of-alt>"));
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:957:3: 
+					{
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 957:3: -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:957:6: ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(ALT, LT(1), "ALT"), root_1);
+						adaptor.addChild(root_1, (GrammarAST)adaptor.create(EPSILON, "epsilon"));
+						adaptor.addChild(root_1, (GrammarAST)adaptor.create(EOA, "<end-of-alt>"));
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:958:4: {...}? ETC
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					if ( !((grammar.buildAST())) ) {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						throw new FailedPredicateException(input, "rewrite_alternative", "grammar.buildAST()");
+					}
+					ETC175=(Token)match(input,ETC,FOLLOW_ETC_in_rewrite_alternative3012); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ETC175_tree = (GrammarAST)adaptor.create(ETC175);
+					adaptor.addChild(root_0, ETC175_tree);
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_alternative"
+
+
+	public static class rewrite_element_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_element"
+	// org/antlr/grammar/v3/ANTLR.g:961:1: rewrite_element : ( (t= rewrite_atom -> $t) (subrule= ebnfSuffix[$t.tree,true] -> $subrule)? | rewrite_ebnf | (tr= rewrite_tree -> $tr) (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)? );
+	public final ANTLRParser.rewrite_element_return rewrite_element() throws RecognitionException {
+		ANTLRParser.rewrite_element_return retval = new ANTLRParser.rewrite_element_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ParserRuleReturnScope t =null;
+		ParserRuleReturnScope subrule =null;
+		ParserRuleReturnScope tr =null;
+		ParserRuleReturnScope rewrite_ebnf176 =null;
+
+		RewriteRuleSubtreeStream stream_rewrite_atom=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_atom");
+		RewriteRuleSubtreeStream stream_ebnfSuffix=new RewriteRuleSubtreeStream(adaptor,"rule ebnfSuffix");
+		RewriteRuleSubtreeStream stream_rewrite_tree=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:962:2: ( (t= rewrite_atom -> $t) (subrule= ebnfSuffix[$t.tree,true] -> $subrule)? | rewrite_ebnf | (tr= rewrite_tree -> $tr) (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)? )
+			int alt89=3;
+			switch ( input.LA(1) ) {
+			case ACTION:
+			case CHAR_LITERAL:
+			case DOLLAR:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt89=1;
+				}
+				break;
+			case LPAREN:
+				{
+				alt89=2;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt89=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 89, 0, input);
+				throw nvae;
+			}
+			switch (alt89) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:962:4: (t= rewrite_atom -> $t) (subrule= ebnfSuffix[$t.tree,true] -> $subrule)?
+					{
+					// org/antlr/grammar/v3/ANTLR.g:962:4: (t= rewrite_atom -> $t)
+					// org/antlr/grammar/v3/ANTLR.g:962:6: t= rewrite_atom
+					{
+					pushFollow(FOLLOW_rewrite_atom_in_rewrite_element3027);
+					t=rewrite_atom();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_atom.add(t.getTree());
+					// AST REWRITE
+					// elements: t
+					// token labels: 
+					// rule labels: t, retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.getTree():null);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 963:4: -> $t
+					{
+						adaptor.addChild(root_0, stream_t.nextTree());
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:965:3: (subrule= ebnfSuffix[$t.tree,true] -> $subrule)?
+					int alt87=2;
+					int LA87_0 = input.LA(1);
+					if ( (LA87_0==PLUS||LA87_0==QUESTION||LA87_0==STAR) ) {
+						alt87=1;
+					}
+					switch (alt87) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:965:5: subrule= ebnfSuffix[$t.tree,true]
+							{
+							pushFollow(FOLLOW_ebnfSuffix_in_rewrite_element3047);
+							subrule=ebnfSuffix((t!=null?((GrammarAST)t.getTree()):null), true);
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_ebnfSuffix.add(subrule.getTree());
+							// AST REWRITE
+							// elements: subrule
+							// token labels: 
+							// rule labels: subrule, retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_subrule=new RewriteRuleSubtreeStream(adaptor,"rule subrule",subrule!=null?subrule.getTree():null);
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (GrammarAST)adaptor.nil();
+							// 966:4: -> $subrule
+							{
+								adaptor.addChild(root_0, stream_subrule.nextTree());
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:968:4: rewrite_ebnf
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_rewrite_ebnf_in_rewrite_element3066);
+					rewrite_ebnf176=rewrite_ebnf();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_ebnf176.getTree());
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:969:4: (tr= rewrite_tree -> $tr) (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)?
+					{
+					// org/antlr/grammar/v3/ANTLR.g:969:4: (tr= rewrite_tree -> $tr)
+					// org/antlr/grammar/v3/ANTLR.g:969:6: tr= rewrite_tree
+					{
+					pushFollow(FOLLOW_rewrite_tree_in_rewrite_element3075);
+					tr=rewrite_tree();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_tree.add(tr.getTree());
+					// AST REWRITE
+					// elements: tr
+					// token labels: 
+					// rule labels: tr, retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_tr=new RewriteRuleSubtreeStream(adaptor,"rule tr",tr!=null?tr.getTree():null);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 970:4: -> $tr
+					{
+						adaptor.addChild(root_0, stream_tr.nextTree());
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:972:3: (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)?
+					int alt88=2;
+					int LA88_0 = input.LA(1);
+					if ( (LA88_0==PLUS||LA88_0==QUESTION||LA88_0==STAR) ) {
+						alt88=1;
+					}
+					switch (alt88) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:972:5: subrule= ebnfSuffix[$tr.tree,true]
+							{
+							pushFollow(FOLLOW_ebnfSuffix_in_rewrite_element3095);
+							subrule=ebnfSuffix((tr!=null?((GrammarAST)tr.getTree()):null), true);
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_ebnfSuffix.add(subrule.getTree());
+							// AST REWRITE
+							// elements: subrule
+							// token labels: 
+							// rule labels: subrule, retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_subrule=new RewriteRuleSubtreeStream(adaptor,"rule subrule",subrule!=null?subrule.getTree():null);
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (GrammarAST)adaptor.nil();
+							// 973:4: -> $subrule
+							{
+								adaptor.addChild(root_0, stream_subrule.nextTree());
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_element"
+
+
+	public static class rewrite_atom_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_atom"
+	// org/antlr/grammar/v3/ANTLR.g:977:1: rewrite_atom : (tr= TOKEN_REF ^ ( elementOptions[$tr.tree] !)? ( ARG_ACTION )? | RULE_REF |cl= CHAR_LITERAL ( elementOptions[$cl.tree] !)? |sl= STRING_LITERAL ( elementOptions[$sl.tree] !)? | DOLLAR ! label | ACTION );
+	public final ANTLRParser.rewrite_atom_return rewrite_atom() throws RecognitionException {
+		ANTLRParser.rewrite_atom_return retval = new ANTLRParser.rewrite_atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token tr=null;
+		Token cl=null;
+		Token sl=null;
+		Token ARG_ACTION178=null;
+		Token RULE_REF179=null;
+		Token DOLLAR182=null;
+		Token ACTION184=null;
+		ParserRuleReturnScope elementOptions177 =null;
+		ParserRuleReturnScope elementOptions180 =null;
+		ParserRuleReturnScope elementOptions181 =null;
+		ParserRuleReturnScope label183 =null;
+
+		GrammarAST tr_tree=null;
+		GrammarAST cl_tree=null;
+		GrammarAST sl_tree=null;
+		GrammarAST ARG_ACTION178_tree=null;
+		GrammarAST RULE_REF179_tree=null;
+		GrammarAST DOLLAR182_tree=null;
+		GrammarAST ACTION184_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:978:2: (tr= TOKEN_REF ^ ( elementOptions[$tr.tree] !)? ( ARG_ACTION )? | RULE_REF |cl= CHAR_LITERAL ( elementOptions[$cl.tree] !)? |sl= STRING_LITERAL ( elementOptions[$sl.tree] !)? | DOLLAR ! label | ACTION )
+			int alt94=6;
+			switch ( input.LA(1) ) {
+			case TOKEN_REF:
+				{
+				alt94=1;
+				}
+				break;
+			case RULE_REF:
+				{
+				alt94=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt94=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt94=4;
+				}
+				break;
+			case DOLLAR:
+				{
+				alt94=5;
+				}
+				break;
+			case ACTION:
+				{
+				alt94=6;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 94, 0, input);
+				throw nvae;
+			}
+			switch (alt94) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:978:4: tr= TOKEN_REF ^ ( elementOptions[$tr.tree] !)? ( ARG_ACTION )?
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					tr=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_rewrite_atom3122); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					tr_tree = (GrammarAST)adaptor.create(tr);
+					root_0 = (GrammarAST)adaptor.becomeRoot(tr_tree, root_0);
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:978:42: ( elementOptions[$tr.tree] !)?
+					int alt90=2;
+					int LA90_0 = input.LA(1);
+					if ( (LA90_0==OPEN_ELEMENT_OPTION) ) {
+						alt90=1;
+					}
+					switch (alt90) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:978:42: elementOptions[$tr.tree] !
+							{
+							pushFollow(FOLLOW_elementOptions_in_rewrite_atom3125);
+							elementOptions177=elementOptions(tr_tree);
+							state._fsp--;
+							if (state.failed) return retval;
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:978:45: ( ARG_ACTION )?
+					int alt91=2;
+					int LA91_0 = input.LA(1);
+					if ( (LA91_0==ARG_ACTION) ) {
+						alt91=1;
+					}
+					switch (alt91) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:978:45: ARG_ACTION
+							{
+							ARG_ACTION178=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rewrite_atom3130); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ARG_ACTION178_tree = (GrammarAST)adaptor.create(ARG_ACTION178);
+							adaptor.addChild(root_0, ARG_ACTION178_tree);
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:979:4: RULE_REF
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					RULE_REF179=(Token)match(input,RULE_REF,FOLLOW_RULE_REF_in_rewrite_atom3137); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					RULE_REF179_tree = (GrammarAST)adaptor.create(RULE_REF179);
+					adaptor.addChild(root_0, RULE_REF179_tree);
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:980:4: cl= CHAR_LITERAL ( elementOptions[$cl.tree] !)?
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					cl=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_rewrite_atom3144); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					cl_tree = (GrammarAST)adaptor.create(cl);
+					adaptor.addChild(root_0, cl_tree);
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:980:44: ( elementOptions[$cl.tree] !)?
+					int alt92=2;
+					int LA92_0 = input.LA(1);
+					if ( (LA92_0==OPEN_ELEMENT_OPTION) ) {
+						alt92=1;
+					}
+					switch (alt92) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:980:44: elementOptions[$cl.tree] !
+							{
+							pushFollow(FOLLOW_elementOptions_in_rewrite_atom3146);
+							elementOptions180=elementOptions(cl_tree);
+							state._fsp--;
+							if (state.failed) return retval;
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:981:4: sl= STRING_LITERAL ( elementOptions[$sl.tree] !)?
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					sl=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_rewrite_atom3156); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					sl_tree = (GrammarAST)adaptor.create(sl);
+					adaptor.addChild(root_0, sl_tree);
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:981:46: ( elementOptions[$sl.tree] !)?
+					int alt93=2;
+					int LA93_0 = input.LA(1);
+					if ( (LA93_0==OPEN_ELEMENT_OPTION) ) {
+						alt93=1;
+					}
+					switch (alt93) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:981:46: elementOptions[$sl.tree] !
+							{
+							pushFollow(FOLLOW_elementOptions_in_rewrite_atom3158);
+							elementOptions181=elementOptions(sl_tree);
+							state._fsp--;
+							if (state.failed) return retval;
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLR.g:982:4: DOLLAR ! label
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					DOLLAR182=(Token)match(input,DOLLAR,FOLLOW_DOLLAR_in_rewrite_atom3166); if (state.failed) return retval;
+					pushFollow(FOLLOW_label_in_rewrite_atom3169);
+					label183=label();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, label183.getTree());
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLR.g:983:4: ACTION
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					ACTION184=(Token)match(input,ACTION,FOLLOW_ACTION_in_rewrite_atom3175); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ACTION184_tree = (GrammarAST)adaptor.create(ACTION184);
+					adaptor.addChild(root_0, ACTION184_tree);
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_atom"
+
+
+	public static class label_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "label"
+	// org/antlr/grammar/v3/ANTLR.g:986:1: label : ( TOKEN_REF -> LABEL[$TOKEN_REF] | RULE_REF -> LABEL[$RULE_REF] );
+	public final ANTLRParser.label_return label() throws RecognitionException {
+		ANTLRParser.label_return retval = new ANTLRParser.label_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token TOKEN_REF185=null;
+		Token RULE_REF186=null;
+
+		GrammarAST TOKEN_REF185_tree=null;
+		GrammarAST RULE_REF186_tree=null;
+		RewriteRuleTokenStream stream_TOKEN_REF=new RewriteRuleTokenStream(adaptor,"token TOKEN_REF");
+		RewriteRuleTokenStream stream_RULE_REF=new RewriteRuleTokenStream(adaptor,"token RULE_REF");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:987:2: ( TOKEN_REF -> LABEL[$TOKEN_REF] | RULE_REF -> LABEL[$RULE_REF] )
+			int alt95=2;
+			int LA95_0 = input.LA(1);
+			if ( (LA95_0==TOKEN_REF) ) {
+				alt95=1;
+			}
+			else if ( (LA95_0==RULE_REF) ) {
+				alt95=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 95, 0, input);
+				throw nvae;
+			}
+
+			switch (alt95) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:987:4: TOKEN_REF
+					{
+					TOKEN_REF185=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_label3186); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_TOKEN_REF.add(TOKEN_REF185);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 987:14: -> LABEL[$TOKEN_REF]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(LABEL, TOKEN_REF185));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:988:4: RULE_REF
+					{
+					RULE_REF186=(Token)match(input,RULE_REF,FOLLOW_RULE_REF_in_label3196); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_RULE_REF.add(RULE_REF186);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 988:13: -> LABEL[$RULE_REF]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(LABEL, RULE_REF186));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "label"
+
+
+	public static class rewrite_ebnf_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_ebnf"
+	// org/antlr/grammar/v3/ANTLR.g:991:1: rewrite_ebnf : b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) ) ;
+	public final ANTLRParser.rewrite_ebnf_return rewrite_ebnf() throws RecognitionException {
+		ANTLRParser.rewrite_ebnf_return retval = new ANTLRParser.rewrite_ebnf_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token QUESTION187=null;
+		Token STAR188=null;
+		Token PLUS189=null;
+		ParserRuleReturnScope b =null;
+
+		GrammarAST QUESTION187_tree=null;
+		GrammarAST STAR188_tree=null;
+		GrammarAST PLUS189_tree=null;
+		RewriteRuleTokenStream stream_STAR=new RewriteRuleTokenStream(adaptor,"token STAR");
+		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
+		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
+		RewriteRuleSubtreeStream stream_rewrite_block=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_block");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:992:2: (b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) ) )
+			// org/antlr/grammar/v3/ANTLR.g:992:4: b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) )
+			{
+			pushFollow(FOLLOW_rewrite_block_in_rewrite_ebnf3214);
+			b=rewrite_block();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite_block.add(b.getTree());
+			// org/antlr/grammar/v3/ANTLR.g:993:3: ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) )
+			int alt96=3;
+			switch ( input.LA(1) ) {
+			case QUESTION:
+				{
+				alt96=1;
+				}
+				break;
+			case STAR:
+				{
+				alt96=2;
+				}
+				break;
+			case PLUS:
+				{
+				alt96=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 96, 0, input);
+				throw nvae;
+			}
+			switch (alt96) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:993:5: QUESTION
+					{
+					QUESTION187=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_rewrite_ebnf3220); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_QUESTION.add(QUESTION187);
+
+					// AST REWRITE
+					// elements: b
+					// token labels: 
+					// rule labels: b, retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.getTree():null);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 994:4: -> ^( OPTIONAL[$b.start,\"?\"] $b)
+					{
+						// org/antlr/grammar/v3/ANTLR.g:994:7: ^( OPTIONAL[$b.start,\"?\"] $b)
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(OPTIONAL, (b!=null?(b.start):null), "?"), root_1);
+						adaptor.addChild(root_1, stream_b.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:995:5: STAR
+					{
+					STAR188=(Token)match(input,STAR,FOLLOW_STAR_in_rewrite_ebnf3239); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_STAR.add(STAR188);
+
+					// AST REWRITE
+					// elements: b
+					// token labels: 
+					// rule labels: b, retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.getTree():null);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 996:4: -> ^( CLOSURE[$b.start,\"*\"] $b)
+					{
+						// org/antlr/grammar/v3/ANTLR.g:996:7: ^( CLOSURE[$b.start,\"*\"] $b)
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(CLOSURE, (b!=null?(b.start):null), "*"), root_1);
+						adaptor.addChild(root_1, stream_b.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:997:5: PLUS
+					{
+					PLUS189=(Token)match(input,PLUS,FOLLOW_PLUS_in_rewrite_ebnf3258); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_PLUS.add(PLUS189);
+
+					// AST REWRITE
+					// elements: b
+					// token labels: 
+					// rule labels: b, retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.getTree():null);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 998:4: -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b)
+					{
+						// org/antlr/grammar/v3/ANTLR.g:998:7: ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b)
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(POSITIVE_CLOSURE, (b!=null?(b.start):null), "+"), root_1);
+						adaptor.addChild(root_1, stream_b.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_ebnf"
+
+
+	public static class rewrite_tree_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_tree"
+	// org/antlr/grammar/v3/ANTLR.g:1002:1: rewrite_tree : TREE_BEGIN ^ rewrite_atom ( rewrite_element )* RPAREN !;
+	public final ANTLRParser.rewrite_tree_return rewrite_tree() throws RecognitionException {
+		ANTLRParser.rewrite_tree_return retval = new ANTLRParser.rewrite_tree_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token TREE_BEGIN190=null;
+		Token RPAREN193=null;
+		ParserRuleReturnScope rewrite_atom191 =null;
+		ParserRuleReturnScope rewrite_element192 =null;
+
+		GrammarAST TREE_BEGIN190_tree=null;
+		GrammarAST RPAREN193_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1003:2: ( TREE_BEGIN ^ rewrite_atom ( rewrite_element )* RPAREN !)
+			// org/antlr/grammar/v3/ANTLR.g:1003:4: TREE_BEGIN ^ rewrite_atom ( rewrite_element )* RPAREN !
+			{
+			root_0 = (GrammarAST)adaptor.nil();
+
+
+			TREE_BEGIN190=(Token)match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_rewrite_tree3286); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			TREE_BEGIN190_tree = (GrammarAST)adaptor.create(TREE_BEGIN190);
+			root_0 = (GrammarAST)adaptor.becomeRoot(TREE_BEGIN190_tree, root_0);
+			}
+
+			pushFollow(FOLLOW_rewrite_atom_in_rewrite_tree3292);
+			rewrite_atom191=rewrite_atom();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_atom191.getTree());
+
+			// org/antlr/grammar/v3/ANTLR.g:1004:17: ( rewrite_element )*
+			loop97:
+			while (true) {
+				int alt97=2;
+				int LA97_0 = input.LA(1);
+				if ( (LA97_0==ACTION||LA97_0==CHAR_LITERAL||LA97_0==DOLLAR||LA97_0==LPAREN||LA97_0==RULE_REF||LA97_0==STRING_LITERAL||LA97_0==TOKEN_REF||LA97_0==TREE_BEGIN) ) {
+					alt97=1;
+				}
+
+				switch (alt97) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1004:17: rewrite_element
+					{
+					pushFollow(FOLLOW_rewrite_element_in_rewrite_tree3294);
+					rewrite_element192=rewrite_element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_element192.getTree());
+
+					}
+					break;
+
+				default :
+					break loop97;
+				}
+			}
+
+			RPAREN193=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_rewrite_tree3299); if (state.failed) return retval;
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_tree"
+
+
+	public static class rewrite_template_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_template"
+	// org/antlr/grammar/v3/ANTLR.g:1020:1: public rewrite_template options {k=1; } : ({...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL ) | rewrite_template_head | rewrite_indirect_template_head | ACTION );
+	public final ANTLRParser.rewrite_template_return rewrite_template() throws RecognitionException {
+		ANTLRParser.rewrite_template_return retval = new ANTLRParser.rewrite_template_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token st=null;
+		Token ACTION197=null;
+		ParserRuleReturnScope rewrite_template_head194 =null;
+		ParserRuleReturnScope rewrite_template_head195 =null;
+		ParserRuleReturnScope rewrite_indirect_template_head196 =null;
+
+		GrammarAST st_tree=null;
+		GrammarAST ACTION197_tree=null;
+		RewriteRuleTokenStream stream_DOUBLE_QUOTE_STRING_LITERAL=new RewriteRuleTokenStream(adaptor,"token DOUBLE_QUOTE_STRING_LITERAL");
+		RewriteRuleTokenStream stream_DOUBLE_ANGLE_STRING_LITERAL=new RewriteRuleTokenStream(adaptor,"token DOUBLE_ANGLE_STRING_LITERAL");
+		RewriteRuleSubtreeStream stream_rewrite_template_head=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_head");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1022:2: ({...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL ) | rewrite_template_head | rewrite_indirect_template_head | ACTION )
+			int alt99=4;
+			switch ( input.LA(1) ) {
+			case TOKEN_REF:
+				{
+				int LA99_1 = input.LA(2);
+				if ( ((LT(1).getText().equals("template"))) ) {
+					alt99=1;
+				}
+				else if ( (true) ) {
+					alt99=2;
+				}
+
+				}
+				break;
+			case RULE_REF:
+				{
+				int LA99_2 = input.LA(2);
+				if ( ((LT(1).getText().equals("template"))) ) {
+					alt99=1;
+				}
+				else if ( (true) ) {
+					alt99=2;
+				}
+
+				}
+				break;
+			case LPAREN:
+				{
+				alt99=3;
+				}
+				break;
+			case ACTION:
+				{
+				alt99=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 99, 0, input);
+				throw nvae;
+			}
+			switch (alt99) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1023:3: {...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL )
+					{
+					if ( !((LT(1).getText().equals("template"))) ) {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						throw new FailedPredicateException(input, "rewrite_template", "LT(1).getText().equals(\"template\")");
+					}
+					// org/antlr/grammar/v3/ANTLR.g:1024:3: ( rewrite_template_head -> rewrite_template_head )
+					// org/antlr/grammar/v3/ANTLR.g:1024:5: rewrite_template_head
+					{
+					pushFollow(FOLLOW_rewrite_template_head_in_rewrite_template3334);
+					rewrite_template_head194=rewrite_template_head();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_template_head.add(rewrite_template_head194.getTree());
+					// AST REWRITE
+					// elements: rewrite_template_head
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 1025:4: -> rewrite_template_head
+					{
+						adaptor.addChild(root_0, stream_rewrite_template_head.nextTree());
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+
+					// org/antlr/grammar/v3/ANTLR.g:1027:3: (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL )
+					int alt98=2;
+					int LA98_0 = input.LA(1);
+					if ( (LA98_0==DOUBLE_QUOTE_STRING_LITERAL) ) {
+						alt98=1;
+					}
+					else if ( (LA98_0==DOUBLE_ANGLE_STRING_LITERAL) ) {
+						alt98=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 98, 0, input);
+						throw nvae;
+					}
+
+					switch (alt98) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:1027:5: st= DOUBLE_QUOTE_STRING_LITERAL
+							{
+							st=(Token)match(input,DOUBLE_QUOTE_STRING_LITERAL,FOLLOW_DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template3353); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_DOUBLE_QUOTE_STRING_LITERAL.add(st);
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLR.g:1027:38: st= DOUBLE_ANGLE_STRING_LITERAL
+							{
+							st=(Token)match(input,DOUBLE_ANGLE_STRING_LITERAL,FOLLOW_DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template3359); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_DOUBLE_ANGLE_STRING_LITERAL.add(st);
+
+							}
+							break;
+
+					}
+
+					if ( state.backtracking==0 ) { adaptor.addChild( retval.tree.getChild(0), adaptor.create(st) ); }
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1031:3: rewrite_template_head
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_rewrite_template_head_in_rewrite_template3374);
+					rewrite_template_head195=rewrite_template_head();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_template_head195.getTree());
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLR.g:1034:3: rewrite_indirect_template_head
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					pushFollow(FOLLOW_rewrite_indirect_template_head_in_rewrite_template3383);
+					rewrite_indirect_template_head196=rewrite_indirect_template_head();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_indirect_template_head196.getTree());
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLR.g:1037:3: ACTION
+					{
+					root_0 = (GrammarAST)adaptor.nil();
+
+
+					ACTION197=(Token)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template3392); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ACTION197_tree = (GrammarAST)adaptor.create(ACTION197);
+					adaptor.addChild(root_0, ACTION197_tree);
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template"
+
+
+	public static class rewrite_template_head_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_template_head"
+	// org/antlr/grammar/v3/ANTLR.g:1041:1: rewrite_template_head : id lp= LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args ) ;
+	public final ANTLRParser.rewrite_template_head_return rewrite_template_head() throws RecognitionException {
+		ANTLRParser.rewrite_template_head_return retval = new ANTLRParser.rewrite_template_head_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token lp=null;
+		Token RPAREN200=null;
+		ParserRuleReturnScope id198 =null;
+		ParserRuleReturnScope rewrite_template_args199 =null;
+
+		GrammarAST lp_tree=null;
+		GrammarAST RPAREN200_tree=null;
+		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
+		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_rewrite_template_args=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_args");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1042:2: ( id lp= LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args ) )
+			// org/antlr/grammar/v3/ANTLR.g:1042:4: id lp= LPAREN rewrite_template_args RPAREN
+			{
+			pushFollow(FOLLOW_id_in_rewrite_template_head3405);
+			id198=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id198.getTree());
+			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_rewrite_template_head3409); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_LPAREN.add(lp);
+
+			pushFollow(FOLLOW_rewrite_template_args_in_rewrite_template_head3413);
+			rewrite_template_args199=rewrite_template_args();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite_template_args.add(rewrite_template_args199.getTree());
+			RPAREN200=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_rewrite_template_head3417); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN200);
+
+			// AST REWRITE
+			// elements: rewrite_template_args, id
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 1045:3: -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args )
+			{
+				// org/antlr/grammar/v3/ANTLR.g:1045:6: ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(TEMPLATE, lp, "TEMPLATE"), root_1);
+				adaptor.addChild(root_1, stream_id.nextTree());
+				adaptor.addChild(root_1, stream_rewrite_template_args.nextTree());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template_head"
+
+
+	public static class rewrite_indirect_template_head_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_indirect_template_head"
+	// org/antlr/grammar/v3/ANTLR.g:1049:1: rewrite_indirect_template_head : lp= LPAREN ACTION RPAREN LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args ) ;
+	public final ANTLRParser.rewrite_indirect_template_head_return rewrite_indirect_template_head() throws RecognitionException {
+		ANTLRParser.rewrite_indirect_template_head_return retval = new ANTLRParser.rewrite_indirect_template_head_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token lp=null;
+		Token ACTION201=null;
+		Token RPAREN202=null;
+		Token LPAREN203=null;
+		Token RPAREN205=null;
+		ParserRuleReturnScope rewrite_template_args204 =null;
+
+		GrammarAST lp_tree=null;
+		GrammarAST ACTION201_tree=null;
+		GrammarAST RPAREN202_tree=null;
+		GrammarAST LPAREN203_tree=null;
+		GrammarAST RPAREN205_tree=null;
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
+		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_rewrite_template_args=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_args");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1050:2: (lp= LPAREN ACTION RPAREN LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args ) )
+			// org/antlr/grammar/v3/ANTLR.g:1050:4: lp= LPAREN ACTION RPAREN LPAREN rewrite_template_args RPAREN
+			{
+			lp=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_rewrite_indirect_template_head3445); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_LPAREN.add(lp);
+
+			ACTION201=(Token)match(input,ACTION,FOLLOW_ACTION_in_rewrite_indirect_template_head3449); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ACTION.add(ACTION201);
+
+			RPAREN202=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_rewrite_indirect_template_head3453); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN202);
+
+			LPAREN203=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_rewrite_indirect_template_head3457); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN203);
+
+			pushFollow(FOLLOW_rewrite_template_args_in_rewrite_indirect_template_head3459);
+			rewrite_template_args204=rewrite_template_args();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite_template_args.add(rewrite_template_args204.getTree());
+			RPAREN205=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_rewrite_indirect_template_head3461); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN205);
+
+			// AST REWRITE
+			// elements: ACTION, rewrite_template_args
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 1054:3: -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args )
+			{
+				// org/antlr/grammar/v3/ANTLR.g:1054:6: ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(TEMPLATE, lp, "TEMPLATE"), root_1);
+				adaptor.addChild(root_1, stream_ACTION.nextNode());
+				adaptor.addChild(root_1, stream_rewrite_template_args.nextTree());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_indirect_template_head"
+
+
+	public static class rewrite_template_args_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_template_args"
+	// org/antlr/grammar/v3/ANTLR.g:1057:1: rewrite_template_args : ( rewrite_template_arg ( COMMA rewrite_template_arg )* -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ ) | -> ARGLIST[\"ARGLIST\"] );
+	public final ANTLRParser.rewrite_template_args_return rewrite_template_args() throws RecognitionException {
+		ANTLRParser.rewrite_template_args_return retval = new ANTLRParser.rewrite_template_args_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token COMMA207=null;
+		ParserRuleReturnScope rewrite_template_arg206 =null;
+		ParserRuleReturnScope rewrite_template_arg208 =null;
+
+		GrammarAST COMMA207_tree=null;
+		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
+		RewriteRuleSubtreeStream stream_rewrite_template_arg=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_arg");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1058:2: ( rewrite_template_arg ( COMMA rewrite_template_arg )* -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ ) | -> ARGLIST[\"ARGLIST\"] )
+			int alt101=2;
+			int LA101_0 = input.LA(1);
+			if ( (LA101_0==RULE_REF||LA101_0==TOKEN_REF) ) {
+				alt101=1;
+			}
+			else if ( (LA101_0==RPAREN) ) {
+				alt101=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 101, 0, input);
+				throw nvae;
+			}
+
+			switch (alt101) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLR.g:1058:4: rewrite_template_arg ( COMMA rewrite_template_arg )*
+					{
+					pushFollow(FOLLOW_rewrite_template_arg_in_rewrite_template_args3485);
+					rewrite_template_arg206=rewrite_template_arg();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_template_arg.add(rewrite_template_arg206.getTree());
+					// org/antlr/grammar/v3/ANTLR.g:1058:25: ( COMMA rewrite_template_arg )*
+					loop100:
+					while (true) {
+						int alt100=2;
+						int LA100_0 = input.LA(1);
+						if ( (LA100_0==COMMA) ) {
+							alt100=1;
+						}
+
+						switch (alt100) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLR.g:1058:26: COMMA rewrite_template_arg
+							{
+							COMMA207=(Token)match(input,COMMA,FOLLOW_COMMA_in_rewrite_template_args3488); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_COMMA.add(COMMA207);
+
+							pushFollow(FOLLOW_rewrite_template_arg_in_rewrite_template_args3490);
+							rewrite_template_arg208=rewrite_template_arg();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_rewrite_template_arg.add(rewrite_template_arg208.getTree());
+							}
+							break;
+
+						default :
+							break loop100;
+						}
+					}
+
+					// AST REWRITE
+					// elements: rewrite_template_arg
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 1059:3: -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ )
+					{
+						// org/antlr/grammar/v3/ANTLR.g:1059:6: ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ )
+						{
+						GrammarAST root_1 = (GrammarAST)adaptor.nil();
+						root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(ARGLIST, "ARGLIST"), root_1);
+						if ( !(stream_rewrite_template_arg.hasNext()) ) {
+							throw new RewriteEarlyExitException();
+						}
+						while ( stream_rewrite_template_arg.hasNext() ) {
+							adaptor.addChild(root_1, stream_rewrite_template_arg.nextTree());
+						}
+						stream_rewrite_template_arg.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLR.g:1061:3: 
+					{
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (GrammarAST)adaptor.nil();
+					// 1061:3: -> ARGLIST[\"ARGLIST\"]
+					{
+						adaptor.addChild(root_0, (GrammarAST)adaptor.create(ARGLIST, "ARGLIST"));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template_args"
+
+
+	public static class rewrite_template_arg_return extends ParserRuleReturnScope {
+		GrammarAST tree;
+		@Override
+		public GrammarAST getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_template_arg"
+	// org/antlr/grammar/v3/ANTLR.g:1064:1: rewrite_template_arg : id a= ASSIGN ACTION -> ^( ARG[$a,\"ARG\"] id ACTION ) ;
+	public final ANTLRParser.rewrite_template_arg_return rewrite_template_arg() throws RecognitionException {
+		ANTLRParser.rewrite_template_arg_return retval = new ANTLRParser.rewrite_template_arg_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		Token a=null;
+		Token ACTION210=null;
+		ParserRuleReturnScope id209 =null;
+
+		GrammarAST a_tree=null;
+		GrammarAST ACTION210_tree=null;
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		try {
+			// org/antlr/grammar/v3/ANTLR.g:1065:2: ( id a= ASSIGN ACTION -> ^( ARG[$a,\"ARG\"] id ACTION ) )
+			// org/antlr/grammar/v3/ANTLR.g:1065:4: id a= ASSIGN ACTION
+			{
+			pushFollow(FOLLOW_id_in_rewrite_template_arg3525);
+			id209=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id209.getTree());
+			a=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_rewrite_template_arg3529); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ASSIGN.add(a);
+
+			ACTION210=(Token)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template_arg3531); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ACTION.add(ACTION210);
+
+			// AST REWRITE
+			// elements: id, ACTION
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (GrammarAST)adaptor.nil();
+			// 1066:3: -> ^( ARG[$a,\"ARG\"] id ACTION )
+			{
+				// org/antlr/grammar/v3/ANTLR.g:1066:6: ^( ARG[$a,\"ARG\"] id ACTION )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.nil();
+				root_1 = (GrammarAST)adaptor.becomeRoot((GrammarAST)adaptor.create(ARG, a, "ARG"), root_1);
+				adaptor.addChild(root_1, stream_id.nextTree());
+				adaptor.addChild(root_1, stream_ACTION.nextNode());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (GrammarAST)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (GrammarAST)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template_arg"
+
+	// $ANTLR start synpred1_ANTLR
+	public final void synpred1_ANTLR_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ANTLR.g:761:4: ({...}? id WILDCARD ( terminal | ruleref ) )
+		// org/antlr/grammar/v3/ANTLR.g:761:5: {...}? id WILDCARD ( terminal | ruleref )
+		{
+		if ( !((LT(1).getCharPositionInLine()+LT(1).getText().length()==LT(2).getCharPositionInLine()&&
+					 LT(2).getCharPositionInLine()+1==LT(3).getCharPositionInLine())) ) {
+			if (state.backtracking>0) {state.failed=true; return;}
+			throw new FailedPredicateException(input, "synpred1_ANTLR", "LT(1).getCharPositionInLine()+LT(1).getText().length()==LT(2).getCharPositionInLine()&&\n\t\t\t LT(2).getCharPositionInLine()+1==LT(3).getCharPositionInLine()");
+		}
+		pushFollow(FOLLOW_id_in_synpred1_ANTLR1929);
+		id();
+		state._fsp--;
+		if (state.failed) return;
+
+		match(input,WILDCARD,FOLLOW_WILDCARD_in_synpred1_ANTLR1931); if (state.failed) return;
+
+		// org/antlr/grammar/v3/ANTLR.g:762:82: ( terminal | ruleref )
+		int alt102=2;
+		int LA102_0 = input.LA(1);
+		if ( (LA102_0==CHAR_LITERAL||LA102_0==STRING_LITERAL||LA102_0==TOKEN_REF||LA102_0==WILDCARD) ) {
+			alt102=1;
+		}
+		else if ( (LA102_0==RULE_REF) ) {
+			alt102=2;
+		}
+
+		else {
+			if (state.backtracking>0) {state.failed=true; return;}
+			NoViableAltException nvae =
+				new NoViableAltException("", 102, 0, input);
+			throw nvae;
+		}
+
+		switch (alt102) {
+			case 1 :
+				// org/antlr/grammar/v3/ANTLR.g:762:83: terminal
+				{
+				pushFollow(FOLLOW_terminal_in_synpred1_ANTLR1934);
+				terminal();
+				state._fsp--;
+				if (state.failed) return;
+
+				}
+				break;
+			case 2 :
+				// org/antlr/grammar/v3/ANTLR.g:762:92: ruleref
+				{
+				pushFollow(FOLLOW_ruleref_in_synpred1_ANTLR1936);
+				ruleref();
+				state._fsp--;
+				if (state.failed) return;
+
+				}
+				break;
+
+		}
+
+		}
+
+	}
+	// $ANTLR end synpred1_ANTLR
+
+	// Delegated rules
+
+	public final boolean synpred1_ANTLR() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred1_ANTLR_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+
+	public static final BitSet FOLLOW_ACTION_in_grammar_324 = new BitSet(new long[]{0x1002040008000000L,0x0000000080000000L});
+	public static final BitSet FOLLOW_DOC_COMMENT_in_grammar_335 = new BitSet(new long[]{0x1002040000000000L,0x0000000080000000L});
+	public static final BitSet FOLLOW_grammarType_in_grammar_345 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_id_in_grammar_349 = new BitSet(new long[]{0x0000000000000000L,0x0000000000040000L});
+	public static final BitSet FOLLOW_SEMI_in_grammar_353 = new BitSet(new long[]{0x0400210008000200L,0x000000006003001CL});
+	public static final BitSet FOLLOW_optionsSpec_in_grammar_359 = new BitSet(new long[]{0x0000210008000200L,0x000000006003001CL});
+	public static final BitSet FOLLOW_delegateGrammars_in_grammar_373 = new BitSet(new long[]{0x0000010008000200L,0x000000006003001CL});
+	public static final BitSet FOLLOW_tokensSpec_in_grammar_382 = new BitSet(new long[]{0x0000010008000200L,0x000000004003001CL});
+	public static final BitSet FOLLOW_attrScopes_in_grammar_390 = new BitSet(new long[]{0x0000010008000200L,0x000000004001001CL});
+	public static final BitSet FOLLOW_actions_in_grammar_397 = new BitSet(new long[]{0x0000010008000000L,0x000000004001001CL});
+	public static final BitSet FOLLOW_rules_in_grammar_405 = new BitSet(new long[]{0x0000000000000000L});
+	public static final BitSet FOLLOW_EOF_in_grammar_409 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_LEXER_in_grammarType460 = new BitSet(new long[]{0x0000040000000000L});
+	public static final BitSet FOLLOW_GRAMMAR_in_grammarType465 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_PARSER_in_grammarType488 = new BitSet(new long[]{0x0000040000000000L});
+	public static final BitSet FOLLOW_GRAMMAR_in_grammarType492 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TREE_in_grammarType513 = new BitSet(new long[]{0x0000040000000000L});
+	public static final BitSet FOLLOW_GRAMMAR_in_grammarType519 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_GRAMMAR_in_grammarType542 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_action_in_actions569 = new BitSet(new long[]{0x0000000000000202L});
+	public static final BitSet FOLLOW_AMPERSAND_in_action584 = new BitSet(new long[]{0x1002000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_actionScopeName_in_action588 = new BitSet(new long[]{0x0000000000400000L});
+	public static final BitSet FOLLOW_COLON_in_action590 = new BitSet(new long[]{0x0000000000400000L});
+	public static final BitSet FOLLOW_COLON_in_action593 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_id_in_action598 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_action600 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_actionScopeName613 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_LEXER_in_actionScopeName620 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_PARSER_in_actionScopeName634 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONS_in_optionsSpec656 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_option_in_optionsSpec660 = new BitSet(new long[]{0x0000000000000000L,0x0000000000040000L});
+	public static final BitSet FOLLOW_SEMI_in_optionsSpec663 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010080L});
+	public static final BitSet FOLLOW_RCURLY_in_optionsSpec668 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_option681 = new BitSet(new long[]{0x0000000000002000L});
+	public static final BitSet FOLLOW_ASSIGN_in_option683 = new BitSet(new long[]{0x0000800000040000L,0x0000000041410000L});
+	public static final BitSet FOLLOW_optionValue_in_option686 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_optionValue707 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_optionValue719 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_optionValue728 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_INT_in_optionValue739 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STAR_in_optionValue759 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_IMPORT_in_delegateGrammars784 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_delegateGrammar_in_delegateGrammars787 = new BitSet(new long[]{0x0000000001000000L,0x0000000000040000L});
+	public static final BitSet FOLLOW_COMMA_in_delegateGrammars790 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_delegateGrammar_in_delegateGrammars793 = new BitSet(new long[]{0x0000000001000000L,0x0000000000040000L});
+	public static final BitSet FOLLOW_SEMI_in_delegateGrammars797 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_delegateGrammar811 = new BitSet(new long[]{0x0000000000002000L});
+	public static final BitSet FOLLOW_ASSIGN_in_delegateGrammar813 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_id_in_delegateGrammar818 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_delegateGrammar827 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKENS_in_tokensSpec854 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000080L});
+	public static final BitSet FOLLOW_tokenSpec_in_tokensSpec860 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000080L});
+	public static final BitSet FOLLOW_RCURLY_in_tokensSpec865 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec877 = new BitSet(new long[]{0x0000000000002000L,0x0000000000040000L});
+	public static final BitSet FOLLOW_ASSIGN_in_tokenSpec881 = new BitSet(new long[]{0x0000000000040000L,0x0000000001000000L});
+	public static final BitSet FOLLOW_set_in_tokenSpec884 = new BitSet(new long[]{0x0000000000000000L,0x0000000000040000L});
+	public static final BitSet FOLLOW_SEMI_in_tokenSpec893 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_attrScope_in_attrScopes906 = new BitSet(new long[]{0x0000000000000002L,0x0000000000020000L});
+	public static final BitSet FOLLOW_SCOPE_in_attrScope919 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_id_in_attrScope922 = new BitSet(new long[]{0x0000000000000210L});
+	public static final BitSet FOLLOW_ruleActions_in_attrScope924 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_attrScope927 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rule_in_rules940 = new BitSet(new long[]{0x0000010008000002L,0x000000004001001CL});
+	public static final BitSet FOLLOW_DOC_COMMENT_in_rule970 = new BitSet(new long[]{0x0000010000000000L,0x000000004001001CL});
+	public static final BitSet FOLLOW_PROTECTED_in_rule983 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_PUBLIC_in_rule992 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_PRIVATE_in_rule1002 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_FRAGMENT_in_rule1011 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_id_in_rule1023 = new BitSet(new long[]{0x0400000000409200L,0x0000000010020400L});
+	public static final BitSet FOLLOW_BANG_in_rule1033 = new BitSet(new long[]{0x0400000000401200L,0x0000000010020400L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule1044 = new BitSet(new long[]{0x0400000000400200L,0x0000000010020400L});
+	public static final BitSet FOLLOW_RETURNS_in_rule1053 = new BitSet(new long[]{0x0000000000001000L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule1057 = new BitSet(new long[]{0x0400000000400200L,0x0000000010020000L});
+	public static final BitSet FOLLOW_throwsSpec_in_rule1067 = new BitSet(new long[]{0x0400000000400200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_optionsSpec_in_rule1076 = new BitSet(new long[]{0x0000000000400200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_rule1085 = new BitSet(new long[]{0x0000000000400200L});
+	public static final BitSet FOLLOW_ruleActions_in_rule1090 = new BitSet(new long[]{0x0000000000400000L});
+	public static final BitSet FOLLOW_COLON_in_rule1096 = new BitSet(new long[]{0x0888008000040010L,0x0000000541090800L});
+	public static final BitSet FOLLOW_ruleAltList_in_rule1100 = new BitSet(new long[]{0x0000000000000000L,0x0000000000040000L});
+	public static final BitSet FOLLOW_SEMI_in_rule1105 = new BitSet(new long[]{0x0000004000020002L});
+	public static final BitSet FOLLOW_exceptionGroup_in_rule1113 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ruleAction_in_ruleActions1251 = new BitSet(new long[]{0x0000000000000202L});
+	public static final BitSet FOLLOW_AMPERSAND_in_ruleAction1266 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_id_in_ruleAction1269 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_ruleAction1271 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_THROWS_in_throwsSpec1282 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_id_in_throwsSpec1285 = new BitSet(new long[]{0x0000000001000002L});
+	public static final BitSet FOLLOW_COMMA_in_throwsSpec1289 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_id_in_throwsSpec1292 = new BitSet(new long[]{0x0000000001000002L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec1308 = new BitSet(new long[]{0x0000000000000210L});
+	public static final BitSet FOLLOW_ruleActions_in_ruleScopeSpec1310 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec1313 = new BitSet(new long[]{0x0000000000000002L,0x0000000000020000L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec1322 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_idList_in_ruleScopeSpec1324 = new BitSet(new long[]{0x0000000000000000L,0x0000000000040000L});
+	public static final BitSet FOLLOW_SEMI_in_ruleScopeSpec1326 = new BitSet(new long[]{0x0000000000000002L,0x0000000000020000L});
+	public static final BitSet FOLLOW_alternative_in_ruleAltList1383 = new BitSet(new long[]{0x0800000000000000L,0x0000000000000800L});
+	public static final BitSet FOLLOW_rewrite_in_ruleAltList1387 = new BitSet(new long[]{0x0800000000000002L});
+	public static final BitSet FOLLOW_OR_in_ruleAltList1416 = new BitSet(new long[]{0x0888008000040010L,0x0000000541090800L});
+	public static final BitSet FOLLOW_alternative_in_ruleAltList1420 = new BitSet(new long[]{0x0800000000000000L,0x0000000000000800L});
+	public static final BitSet FOLLOW_rewrite_in_ruleAltList1424 = new BitSet(new long[]{0x0800000000000002L});
+	public static final BitSet FOLLOW_LPAREN_in_block1500 = new BitSet(new long[]{0x0C88008000440210L,0x0000000541094800L});
+	public static final BitSet FOLLOW_optionsSpec_in_block1538 = new BitSet(new long[]{0x0000000000400200L});
+	public static final BitSet FOLLOW_ruleActions_in_block1549 = new BitSet(new long[]{0x0000000000400000L});
+	public static final BitSet FOLLOW_COLON_in_block1557 = new BitSet(new long[]{0x0888008000040010L,0x0000000541094800L});
+	public static final BitSet FOLLOW_ACTION_in_block1563 = new BitSet(new long[]{0x0000000000400000L});
+	public static final BitSet FOLLOW_COLON_in_block1565 = new BitSet(new long[]{0x0888008000040010L,0x0000000541094800L});
+	public static final BitSet FOLLOW_alternative_in_block1577 = new BitSet(new long[]{0x0800000000000000L,0x0000000000004800L});
+	public static final BitSet FOLLOW_rewrite_in_block1581 = new BitSet(new long[]{0x0800000000000000L,0x0000000000004000L});
+	public static final BitSet FOLLOW_OR_in_block1591 = new BitSet(new long[]{0x0888008000040010L,0x0000000541094800L});
+	public static final BitSet FOLLOW_alternative_in_block1595 = new BitSet(new long[]{0x0800000000000000L,0x0000000000004800L});
+	public static final BitSet FOLLOW_rewrite_in_block1599 = new BitSet(new long[]{0x0800000000000000L,0x0000000000004000L});
+	public static final BitSet FOLLOW_RPAREN_in_block1616 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_element_in_alternative1656 = new BitSet(new long[]{0x0088008000040012L,0x0000000541090000L});
+	public static final BitSet FOLLOW_exceptionHandler_in_exceptionGroup1702 = new BitSet(new long[]{0x0000004000020002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup1705 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup1711 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CATCH_in_exceptionHandler1722 = new BitSet(new long[]{0x0000000000001000L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_exceptionHandler1725 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_exceptionHandler1727 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_FINALLY_in_finallyClause1738 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_finallyClause1741 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_elementNoOptionSpec_in_element1752 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_elementNoOptionSpec1770 = new BitSet(new long[]{0x8000000000002000L});
+	public static final BitSet FOLLOW_ASSIGN_in_elementNoOptionSpec1773 = new BitSet(new long[]{0x0088000000040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_PLUS_ASSIGN_in_elementNoOptionSpec1776 = new BitSet(new long[]{0x0088000000040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_elementNoOptionSpec1785 = new BitSet(new long[]{0x4000000000000002L,0x0000000000400020L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_elementNoOptionSpec1790 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ebnf_in_elementNoOptionSpec1803 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_atom_in_elementNoOptionSpec1816 = new BitSet(new long[]{0x4000000000000002L,0x0000000000400020L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_elementNoOptionSpec1825 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ebnf_in_elementNoOptionSpec1841 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_FORCED_ACTION_in_elementNoOptionSpec1847 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_elementNoOptionSpec1853 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SEMPRED_in_elementNoOptionSpec1861 = new BitSet(new long[]{0x0000100000000002L});
+	public static final BitSet FOLLOW_IMPLIES_in_elementNoOptionSpec1865 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_tree__in_elementNoOptionSpec1884 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_range_in_atom1899 = new BitSet(new long[]{0x0000000000008002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ROOT_in_atom1902 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_atom1905 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_atom1945 = new BitSet(new long[]{0x0000000000000000L,0x0000000400000000L});
+	public static final BitSet FOLLOW_WILDCARD_in_atom1949 = new BitSet(new long[]{0x0000000000040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_terminal_in_atom1953 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ruleref_in_atom1955 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_terminal_in_atom1964 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ruleref_in_atom1970 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_notSet_in_atom1979 = new BitSet(new long[]{0x0000000000008002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ROOT_in_atom1982 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_atom1985 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_RULE_REF_in_ruleref1999 = new BitSet(new long[]{0x0000000000009002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_ruleref2002 = new BitSet(new long[]{0x0000000000008002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ROOT_in_ruleref2006 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_ruleref2009 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_NOT_in_notSet2023 = new BitSet(new long[]{0x0008000000040000L,0x0000000041000000L});
+	public static final BitSet FOLLOW_notTerminal_in_notSet2030 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_notSet2036 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_treeRoot2059 = new BitSet(new long[]{0x8000000000002000L});
+	public static final BitSet FOLLOW_ASSIGN_in_treeRoot2062 = new BitSet(new long[]{0x0088000000040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_PLUS_ASSIGN_in_treeRoot2065 = new BitSet(new long[]{0x0088000000040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_treeRoot2070 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_treeRoot2072 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_atom_in_treeRoot2078 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_treeRoot2083 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_tree_2094 = new BitSet(new long[]{0x0088000000040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_treeRoot_in_tree_2099 = new BitSet(new long[]{0x0088008000040010L,0x0000000541090000L});
+	public static final BitSet FOLLOW_element_in_tree_2101 = new BitSet(new long[]{0x0088008000040010L,0x0000000541094000L});
+	public static final BitSet FOLLOW_RPAREN_in_tree_2106 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_ebnf2120 = new BitSet(new long[]{0x4000100000008002L,0x0000000000402020L});
+	public static final BitSet FOLLOW_QUESTION_in_ebnf2126 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STAR_in_ebnf2144 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_PLUS_in_ebnf2162 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_IMPLIES_in_ebnf2180 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ROOT_in_ebnf2216 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_ebnf2233 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_range2280 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000040L});
+	public static final BitSet FOLLOW_RANGE_in_range2282 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_range2286 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_range2313 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000040L});
+	public static final BitSet FOLLOW_RANGE_in_range2317 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_range2319 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_range2327 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000040L});
+	public static final BitSet FOLLOW_RANGE_in_range2331 = new BitSet(new long[]{0x0000000000000000L,0x0000000001000000L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_range2333 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_range2341 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000040L});
+	public static final BitSet FOLLOW_RANGE_in_range2345 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_range2347 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_terminal2376 = new BitSet(new long[]{0x0100000000008002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_elementOptions_in_terminal2381 = new BitSet(new long[]{0x0000000000008002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ROOT_in_terminal2389 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_terminal2392 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_terminal2403 = new BitSet(new long[]{0x0100000000009002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_elementOptions_in_terminal2410 = new BitSet(new long[]{0x0000000000009002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_terminal2421 = new BitSet(new long[]{0x0000000000008002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ROOT_in_terminal2430 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_terminal2433 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_terminal2444 = new BitSet(new long[]{0x0100000000008002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_elementOptions_in_terminal2449 = new BitSet(new long[]{0x0000000000008002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ROOT_in_terminal2457 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_terminal2460 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_WILDCARD_in_terminal2471 = new BitSet(new long[]{0x0000000000008002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ROOT_in_terminal2474 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_terminal2477 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPEN_ELEMENT_OPTION_in_elementOptions2496 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_defaultNodeOption_in_elementOptions2499 = new BitSet(new long[]{0x0000000000100000L});
+	public static final BitSet FOLLOW_CLOSE_ELEMENT_OPTION_in_elementOptions2502 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPEN_ELEMENT_OPTION_in_elementOptions2508 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_elementOption_in_elementOptions2511 = new BitSet(new long[]{0x0000000000100000L,0x0000000000040000L});
+	public static final BitSet FOLLOW_SEMI_in_elementOptions2515 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_elementOption_in_elementOptions2518 = new BitSet(new long[]{0x0000000000100000L,0x0000000000040000L});
+	public static final BitSet FOLLOW_CLOSE_ELEMENT_OPTION_in_elementOptions2523 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_elementOptionId_in_defaultNodeOption2536 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_elementOption2552 = new BitSet(new long[]{0x0000000000002000L});
+	public static final BitSet FOLLOW_ASSIGN_in_elementOption2554 = new BitSet(new long[]{0x00000000C0000000L,0x0000000041010000L});
+	public static final BitSet FOLLOW_elementOptionId_in_elementOption2561 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_elementOption2575 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOUBLE_QUOTE_STRING_LITERAL_in_elementOption2579 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOUBLE_ANGLE_STRING_LITERAL_in_elementOption2583 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_elementOptionId2614 = new BitSet(new long[]{0x0000000000000002L,0x0000000400000000L});
+	public static final BitSet FOLLOW_WILDCARD_in_elementOptionId2619 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_id_in_elementOptionId2623 = new BitSet(new long[]{0x0000000000000002L,0x0000000400000000L});
+	public static final BitSet FOLLOW_QUESTION_in_ebnfSuffix2700 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STAR_in_ebnfSuffix2714 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_PLUS_in_ebnfSuffix2728 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_idList2790 = new BitSet(new long[]{0x0000000001000002L});
+	public static final BitSet FOLLOW_COMMA_in_idList2793 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_id_in_idList2796 = new BitSet(new long[]{0x0000000001000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_id2809 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_RULE_REF_in_id2821 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_with_sempred_in_rewrite2841 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite2846 = new BitSet(new long[]{0x0008002010040010L,0x0000000141010000L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite2848 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite_with_sempred2879 = new BitSet(new long[]{0x0000000000000000L,0x0000000000080000L});
+	public static final BitSet FOLLOW_SEMPRED_in_rewrite_with_sempred2882 = new BitSet(new long[]{0x0008002010040010L,0x0000000141010000L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite_with_sempred2884 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_LPAREN_in_rewrite_block2895 = new BitSet(new long[]{0x0008002010040010L,0x0000000141014000L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite_block2899 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});
+	public static final BitSet FOLLOW_RPAREN_in_rewrite_block2903 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_template_in_rewrite_alternative2939 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_element_in_rewrite_alternative2951 = new BitSet(new long[]{0x0008000010040012L,0x0000000141010000L});
+	public static final BitSet FOLLOW_ETC_in_rewrite_alternative3012 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_atom_in_rewrite_element3027 = new BitSet(new long[]{0x4000000000000002L,0x0000000000400020L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_rewrite_element3047 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_ebnf_in_rewrite_element3066 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_in_rewrite_element3075 = new BitSet(new long[]{0x4000000000000002L,0x0000000000400020L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_rewrite_element3095 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_rewrite_atom3122 = new BitSet(new long[]{0x0100000000001002L});
+	public static final BitSet FOLLOW_elementOptions_in_rewrite_atom3125 = new BitSet(new long[]{0x0000000000001002L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rewrite_atom3130 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_RULE_REF_in_rewrite_atom3137 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_rewrite_atom3144 = new BitSet(new long[]{0x0100000000000002L});
+	public static final BitSet FOLLOW_elementOptions_in_rewrite_atom3146 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_rewrite_atom3156 = new BitSet(new long[]{0x0100000000000002L});
+	public static final BitSet FOLLOW_elementOptions_in_rewrite_atom3158 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOLLAR_in_rewrite_atom3166 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_label_in_rewrite_atom3169 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_atom3175 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_label3186 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_RULE_REF_in_label3196 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_block_in_rewrite_ebnf3214 = new BitSet(new long[]{0x4000000000000000L,0x0000000000400020L});
+	public static final BitSet FOLLOW_QUESTION_in_rewrite_ebnf3220 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STAR_in_rewrite_ebnf3239 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_PLUS_in_rewrite_ebnf3258 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_rewrite_tree3286 = new BitSet(new long[]{0x0000000010040010L,0x0000000041010000L});
+	public static final BitSet FOLLOW_rewrite_atom_in_rewrite_tree3292 = new BitSet(new long[]{0x0008000010040010L,0x0000000141014000L});
+	public static final BitSet FOLLOW_rewrite_element_in_rewrite_tree3294 = new BitSet(new long[]{0x0008000010040010L,0x0000000141014000L});
+	public static final BitSet FOLLOW_RPAREN_in_rewrite_tree3299 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_template_head_in_rewrite_template3334 = new BitSet(new long[]{0x00000000C0000000L});
+	public static final BitSet FOLLOW_DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template3353 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template3359 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_template_head_in_rewrite_template3374 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_indirect_template_head_in_rewrite_template3383 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template3392 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_rewrite_template_head3405 = new BitSet(new long[]{0x0008000000000000L});
+	public static final BitSet FOLLOW_LPAREN_in_rewrite_template_head3409 = new BitSet(new long[]{0x0000000000000000L,0x0000000040014000L});
+	public static final BitSet FOLLOW_rewrite_template_args_in_rewrite_template_head3413 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});
+	public static final BitSet FOLLOW_RPAREN_in_rewrite_template_head3417 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_LPAREN_in_rewrite_indirect_template_head3445 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_indirect_template_head3449 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});
+	public static final BitSet FOLLOW_RPAREN_in_rewrite_indirect_template_head3453 = new BitSet(new long[]{0x0008000000000000L});
+	public static final BitSet FOLLOW_LPAREN_in_rewrite_indirect_template_head3457 = new BitSet(new long[]{0x0000000000000000L,0x0000000040014000L});
+	public static final BitSet FOLLOW_rewrite_template_args_in_rewrite_indirect_template_head3459 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});
+	public static final BitSet FOLLOW_RPAREN_in_rewrite_indirect_template_head3461 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_template_arg_in_rewrite_template_args3485 = new BitSet(new long[]{0x0000000001000002L});
+	public static final BitSet FOLLOW_COMMA_in_rewrite_template_args3488 = new BitSet(new long[]{0x0000000000000000L,0x0000000040010000L});
+	public static final BitSet FOLLOW_rewrite_template_arg_in_rewrite_template_args3490 = new BitSet(new long[]{0x0000000001000002L});
+	public static final BitSet FOLLOW_id_in_rewrite_template_arg3525 = new BitSet(new long[]{0x0000000000002000L});
+	public static final BitSet FOLLOW_ASSIGN_in_rewrite_template_arg3529 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template_arg3531 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_synpred1_ANTLR1929 = new BitSet(new long[]{0x0000000000000000L,0x0000000400000000L});
+	public static final BitSet FOLLOW_WILDCARD_in_synpred1_ANTLR1931 = new BitSet(new long[]{0x0000000000040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_terminal_in_synpred1_ANTLR1934 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ruleref_in_synpred1_ANTLR1936 = new BitSet(new long[]{0x0000000000000002L});
+}
--- tool/src/main/java/org/antlr/grammar/v3/ANTLRTreePrinter.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/ANTLRTreePrinter.java	2019-04-04 17:22:25.476181469 +0200
@@ -0,0 +1,3622 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/ANTLRTreePrinter.g 2019-04-04 15:18:49
+
+package org.antlr.grammar.v3;
+import org.antlr.tool.*;
+import java.util.StringTokenizer;
+
+
+import org.antlr.runtime.*;
+import org.antlr.runtime.tree.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+
+/** Print out a grammar (no pretty printing).
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  August 19, 2003
+ */
+@SuppressWarnings("all")
+public class ANTLRTreePrinter extends TreeParser {
+	public static final String[] tokenNames = new String[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", 
+		"ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", 
+		"ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", 
+		"CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", 
+		"COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", 
+		"DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", 
+		"EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", 
+		"GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", 
+		"LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", 
+		"NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", 
+		"OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", 
+		"PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", 
+		"RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", 
+		"RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", 
+		"SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", 
+		"TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", 
+		"WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public static final int EOF=-1;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int AMPERSAND=9;
+	public static final int ARG=10;
+	public static final int ARGLIST=11;
+	public static final int ARG_ACTION=12;
+	public static final int ASSIGN=13;
+	public static final int BACKTRACK_SEMPRED=14;
+	public static final int BANG=15;
+	public static final int BLOCK=16;
+	public static final int CATCH=17;
+	public static final int CHAR_LITERAL=18;
+	public static final int CHAR_RANGE=19;
+	public static final int CLOSE_ELEMENT_OPTION=20;
+	public static final int CLOSURE=21;
+	public static final int COLON=22;
+	public static final int COMBINED_GRAMMAR=23;
+	public static final int COMMA=24;
+	public static final int COMMENT=25;
+	public static final int DIGIT=26;
+	public static final int DOC_COMMENT=27;
+	public static final int DOLLAR=28;
+	public static final int DOT=29;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public static final int EOA=32;
+	public static final int EOB=33;
+	public static final int EOR=34;
+	public static final int EPSILON=35;
+	public static final int ESC=36;
+	public static final int ETC=37;
+	public static final int FINALLY=38;
+	public static final int FORCED_ACTION=39;
+	public static final int FRAGMENT=40;
+	public static final int GATED_SEMPRED=41;
+	public static final int GRAMMAR=42;
+	public static final int ID=43;
+	public static final int IMPLIES=44;
+	public static final int IMPORT=45;
+	public static final int INITACTION=46;
+	public static final int INT=47;
+	public static final int LABEL=48;
+	public static final int LEXER=49;
+	public static final int LEXER_GRAMMAR=50;
+	public static final int LPAREN=51;
+	public static final int ML_COMMENT=52;
+	public static final int NESTED_ACTION=53;
+	public static final int NESTED_ARG_ACTION=54;
+	public static final int NOT=55;
+	public static final int OPEN_ELEMENT_OPTION=56;
+	public static final int OPTIONAL=57;
+	public static final int OPTIONS=58;
+	public static final int OR=59;
+	public static final int PARSER=60;
+	public static final int PARSER_GRAMMAR=61;
+	public static final int PLUS=62;
+	public static final int PLUS_ASSIGN=63;
+	public static final int POSITIVE_CLOSURE=64;
+	public static final int PREC_RULE=65;
+	public static final int PRIVATE=66;
+	public static final int PROTECTED=67;
+	public static final int PUBLIC=68;
+	public static final int QUESTION=69;
+	public static final int RANGE=70;
+	public static final int RCURLY=71;
+	public static final int RECURSIVE_RULE_REF=72;
+	public static final int RET=73;
+	public static final int RETURNS=74;
+	public static final int REWRITE=75;
+	public static final int REWRITES=76;
+	public static final int ROOT=77;
+	public static final int RPAREN=78;
+	public static final int RULE=79;
+	public static final int RULE_REF=80;
+	public static final int SCOPE=81;
+	public static final int SEMI=82;
+	public static final int SEMPRED=83;
+	public static final int SL_COMMENT=84;
+	public static final int SRC=85;
+	public static final int STAR=86;
+	public static final int STRAY_BRACKET=87;
+	public static final int STRING_LITERAL=88;
+	public static final int SYNPRED=89;
+	public static final int SYN_SEMPRED=90;
+	public static final int TEMPLATE=91;
+	public static final int THROWS=92;
+	public static final int TOKENS=93;
+	public static final int TOKEN_REF=94;
+	public static final int TREE=95;
+	public static final int TREE_BEGIN=96;
+	public static final int TREE_GRAMMAR=97;
+	public static final int WILDCARD=98;
+	public static final int WS=99;
+	public static final int WS_LOOP=100;
+	public static final int WS_OPT=101;
+	public static final int XDIGIT=102;
+
+	// delegates
+	public TreeParser[] getDelegates() {
+		return new TreeParser[] {};
+	}
+
+	// delegators
+
+
+	public ANTLRTreePrinter(TreeNodeStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public ANTLRTreePrinter(TreeNodeStream input, RecognizerSharedState state) {
+		super(input, state);
+	}
+
+	@Override public String[] getTokenNames() { return ANTLRTreePrinter.tokenNames; }
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/ANTLRTreePrinter.g"; }
+
+
+	protected Grammar grammar;
+	protected boolean showActions;
+	protected StringBuilder buf = new StringBuilder(300);
+
+	private ANTLRTreePrinter.block_return block(GrammarAST t, boolean forceParens) throws RecognitionException {
+	    ANTLRTreePrinter other = new ANTLRTreePrinter(new CommonTreeNodeStream(t));
+	    other.buf = buf;
+	    return other.block(forceParens);
+	}
+
+	public final int countAltsForBlock(GrammarAST t) {
+	    int n = 0;
+	    for ( int i = 0; i < t.getChildCount(); i++ )
+	    {
+	        if ( t.getChild(i).getType() == ALT )
+	            n++;
+	    }
+
+	    return n;
+	}
+
+	public void out(String s) {
+	    buf.append(s);
+	}
+
+	@Override
+	public void reportError(RecognitionException ex) {
+	    Token token = null;
+	    if (ex instanceof MismatchedTokenException) {
+	        token = ((MismatchedTokenException)ex).token;
+	    } else if (ex instanceof NoViableAltException) {
+	        token = ((NoViableAltException)ex).token;
+	    }
+
+	    ErrorManager.syntaxError(
+	        ErrorManager.MSG_SYNTAX_ERROR,
+	        grammar,
+	        token,
+	        "antlr.print: " + ex.toString(),
+	        ex );
+	}
+
+	/** Normalize a grammar print out by removing all double spaces
+	 *  and trailing/beginning stuff.  FOr example, convert
+	 *
+	 *  ( A  |  B  |  C )*
+	 *
+	 *  to
+	 *
+	 *  ( A | B | C )*
+	 */
+	public static String normalize(String g) {
+	    StringTokenizer st = new StringTokenizer(g, " ", false);
+	    StringBuffer buf = new StringBuffer();
+	    while ( st.hasMoreTokens() ) {
+	        String w = st.nextToken();
+	        buf.append(w);
+	        buf.append(" ");
+	    }
+	    return buf.toString().trim();
+	}
+
+
+
+	// $ANTLR start "toString"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:120:1: public toString[Grammar g, boolean showActions] returns [String s=null] : ( grammar_ | rule | alternative | element | single_rewrite | rewrite | EOR ) ;
+	public final String toString(Grammar g, boolean showActions) throws RecognitionException {
+		String s = null;
+
+
+
+			grammar = g;
+			this.showActions = showActions;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:125:2: ( ( grammar_ | rule | alternative | element | single_rewrite | rewrite | EOR ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:125:4: ( grammar_ | rule | alternative | element | single_rewrite | rewrite | EOR )
+			{
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:125:4: ( grammar_ | rule | alternative | element | single_rewrite | rewrite | EOR )
+			int alt1=7;
+			switch ( input.LA(1) ) {
+			case COMBINED_GRAMMAR:
+			case LEXER_GRAMMAR:
+			case PARSER_GRAMMAR:
+			case TREE_GRAMMAR:
+				{
+				alt1=1;
+				}
+				break;
+			case RULE:
+				{
+				alt1=2;
+				}
+				break;
+			case ALT:
+				{
+				alt1=3;
+				}
+				break;
+			case ACTION:
+			case ASSIGN:
+			case BACKTRACK_SEMPRED:
+			case BANG:
+			case BLOCK:
+			case CHAR_LITERAL:
+			case CHAR_RANGE:
+			case CLOSURE:
+			case DOT:
+			case EPSILON:
+			case FORCED_ACTION:
+			case GATED_SEMPRED:
+			case LABEL:
+			case NOT:
+			case OPTIONAL:
+			case PLUS_ASSIGN:
+			case POSITIVE_CLOSURE:
+			case RANGE:
+			case ROOT:
+			case RULE_REF:
+			case SEMPRED:
+			case STRING_LITERAL:
+			case SYNPRED:
+			case SYN_SEMPRED:
+			case TOKEN_REF:
+			case TREE_BEGIN:
+			case WILDCARD:
+				{
+				alt1=4;
+				}
+				break;
+			case REWRITE:
+				{
+				alt1=5;
+				}
+				break;
+			case EOF:
+			case REWRITES:
+				{
+				alt1=6;
+				}
+				break;
+			case EOR:
+				{
+				alt1=7;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 1, 0, input);
+				throw nvae;
+			}
+			switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:125:6: grammar_
+					{
+					pushFollow(FOLLOW_grammar__in_toString73);
+					grammar_();
+					state._fsp--;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:126:5: rule
+					{
+					pushFollow(FOLLOW_rule_in_toString79);
+					rule();
+					state._fsp--;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:127:5: alternative
+					{
+					pushFollow(FOLLOW_alternative_in_toString85);
+					alternative();
+					state._fsp--;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:128:5: element
+					{
+					pushFollow(FOLLOW_element_in_toString91);
+					element();
+					state._fsp--;
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:129:5: single_rewrite
+					{
+					pushFollow(FOLLOW_single_rewrite_in_toString97);
+					single_rewrite();
+					state._fsp--;
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:130:5: rewrite
+					{
+					pushFollow(FOLLOW_rewrite_in_toString103);
+					rewrite();
+					state._fsp--;
+
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:131:5: EOR
+					{
+					match(input,EOR,FOLLOW_EOR_in_toString109); 
+					}
+					break;
+
+			}
+
+			return normalize(buf.toString());
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return s;
+	}
+	// $ANTLR end "toString"
+
+
+
+	// $ANTLR start "grammar_"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:138:1: grammar_ : ( ^( LEXER_GRAMMAR grammarSpec[\"lexer \" ] ) | ^( PARSER_GRAMMAR grammarSpec[\"parser \"] ) | ^( TREE_GRAMMAR grammarSpec[\"tree \"] ) | ^( COMBINED_GRAMMAR grammarSpec[\"\"] ) );
+	public final void grammar_() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:139:2: ( ^( LEXER_GRAMMAR grammarSpec[\"lexer \" ] ) | ^( PARSER_GRAMMAR grammarSpec[\"parser \"] ) | ^( TREE_GRAMMAR grammarSpec[\"tree \"] ) | ^( COMBINED_GRAMMAR grammarSpec[\"\"] ) )
+			int alt2=4;
+			switch ( input.LA(1) ) {
+			case LEXER_GRAMMAR:
+				{
+				alt2=1;
+				}
+				break;
+			case PARSER_GRAMMAR:
+				{
+				alt2=2;
+				}
+				break;
+			case TREE_GRAMMAR:
+				{
+				alt2=3;
+				}
+				break;
+			case COMBINED_GRAMMAR:
+				{
+				alt2=4;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 2, 0, input);
+				throw nvae;
+			}
+			switch (alt2) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:139:4: ^( LEXER_GRAMMAR grammarSpec[\"lexer \" ] )
+					{
+					match(input,LEXER_GRAMMAR,FOLLOW_LEXER_GRAMMAR_in_grammar_133); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_grammarSpec_in_grammar_135);
+					grammarSpec("lexer ");
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:140:4: ^( PARSER_GRAMMAR grammarSpec[\"parser \"] )
+					{
+					match(input,PARSER_GRAMMAR,FOLLOW_PARSER_GRAMMAR_in_grammar_145); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_grammarSpec_in_grammar_147);
+					grammarSpec("parser ");
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:141:4: ^( TREE_GRAMMAR grammarSpec[\"tree \"] )
+					{
+					match(input,TREE_GRAMMAR,FOLLOW_TREE_GRAMMAR_in_grammar_157); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_grammarSpec_in_grammar_159);
+					grammarSpec("tree ");
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:142:4: ^( COMBINED_GRAMMAR grammarSpec[\"\"] )
+					{
+					match(input,COMBINED_GRAMMAR,FOLLOW_COMBINED_GRAMMAR_in_grammar_169); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_grammarSpec_in_grammar_171);
+					grammarSpec("");
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammar_"
+
+
+
+	// $ANTLR start "attrScope"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:145:1: attrScope : ^( 'scope' ID ( ruleAction )* ACTION ) ;
+	public final void attrScope() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:146:2: ( ^( 'scope' ID ( ruleAction )* ACTION ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:146:4: ^( 'scope' ID ( ruleAction )* ACTION )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_attrScope187); 
+			match(input, Token.DOWN, null); 
+			match(input,ID,FOLLOW_ID_in_attrScope189); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:146:18: ( ruleAction )*
+			loop3:
+			while (true) {
+				int alt3=2;
+				int LA3_0 = input.LA(1);
+				if ( (LA3_0==AMPERSAND) ) {
+					alt3=1;
+				}
+
+				switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:146:18: ruleAction
+					{
+					pushFollow(FOLLOW_ruleAction_in_attrScope191);
+					ruleAction();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop3;
+				}
+			}
+
+			match(input,ACTION,FOLLOW_ACTION_in_attrScope194); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "attrScope"
+
+
+
+	// $ANTLR start "grammarSpec"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:149:1: grammarSpec[String gtype] : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules ;
+	public final void grammarSpec(String gtype) throws RecognitionException {
+		GrammarAST id=null;
+		GrammarAST cmt=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:150:2: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:150:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules
+			{
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_grammarSpec210); 
+			out(gtype+"grammar "+(id!=null?id.getText():null));
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:151:3: (cmt= DOC_COMMENT )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+			if ( (LA4_0==DOC_COMMENT) ) {
+				alt4=1;
+			}
+			switch (alt4) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:151:4: cmt= DOC_COMMENT
+					{
+					cmt=(GrammarAST)match(input,DOC_COMMENT,FOLLOW_DOC_COMMENT_in_grammarSpec219); 
+					out((cmt!=null?cmt.getText():null)+"\n");
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:152:3: ( optionsSpec )?
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+			if ( (LA5_0==OPTIONS) ) {
+				alt5=1;
+			}
+			switch (alt5) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:152:4: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_grammarSpec229);
+					optionsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			out(";\n");
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:153:3: ( delegateGrammars )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+			if ( (LA6_0==IMPORT) ) {
+				alt6=1;
+			}
+			switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:153:4: delegateGrammars
+					{
+					pushFollow(FOLLOW_delegateGrammars_in_grammarSpec238);
+					delegateGrammars();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:154:3: ( tokensSpec )?
+			int alt7=2;
+			int LA7_0 = input.LA(1);
+			if ( (LA7_0==TOKENS) ) {
+				alt7=1;
+			}
+			switch (alt7) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:154:4: tokensSpec
+					{
+					pushFollow(FOLLOW_tokensSpec_in_grammarSpec245);
+					tokensSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:155:3: ( attrScope )*
+			loop8:
+			while (true) {
+				int alt8=2;
+				int LA8_0 = input.LA(1);
+				if ( (LA8_0==SCOPE) ) {
+					alt8=1;
+				}
+
+				switch (alt8) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:155:4: attrScope
+					{
+					pushFollow(FOLLOW_attrScope_in_grammarSpec252);
+					attrScope();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop8;
+				}
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:156:3: ( actions )?
+			int alt9=2;
+			int LA9_0 = input.LA(1);
+			if ( (LA9_0==AMPERSAND) ) {
+				alt9=1;
+			}
+			switch (alt9) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:156:4: actions
+					{
+					pushFollow(FOLLOW_actions_in_grammarSpec259);
+					actions();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_rules_in_grammarSpec265);
+			rules();
+			state._fsp--;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammarSpec"
+
+
+
+	// $ANTLR start "actions"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:160:1: actions : ( action )+ ;
+	public final void actions() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:161:2: ( ( action )+ )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:161:4: ( action )+
+			{
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:161:4: ( action )+
+			int cnt10=0;
+			loop10:
+			while (true) {
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+				if ( (LA10_0==AMPERSAND) ) {
+					alt10=1;
+				}
+
+				switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:161:6: action
+					{
+					pushFollow(FOLLOW_action_in_actions278);
+					action();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt10 >= 1 ) break loop10;
+					EarlyExitException eee = new EarlyExitException(10, input);
+					throw eee;
+				}
+				cnt10++;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "actions"
+
+
+
+	// $ANTLR start "action"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:164:1: action : ^( AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) ;
+	public final void action() throws RecognitionException {
+		GrammarAST id1=null;
+		GrammarAST id2=null;
+		GrammarAST a1=null;
+		GrammarAST a2=null;
+
+
+			String scope=null, name=null;
+			String action=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:169:2: ( ^( AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:169:4: ^( AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) )
+			{
+			match(input,AMPERSAND,FOLLOW_AMPERSAND_in_action299); 
+			match(input, Token.DOWN, null); 
+			id1=(GrammarAST)match(input,ID,FOLLOW_ID_in_action303); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:170:4: (id2= ID a1= ACTION |a2= ACTION )
+			int alt11=2;
+			int LA11_0 = input.LA(1);
+			if ( (LA11_0==ID) ) {
+				alt11=1;
+			}
+			else if ( (LA11_0==ACTION) ) {
+				alt11=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 11, 0, input);
+				throw nvae;
+			}
+
+			switch (alt11) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:170:6: id2= ID a1= ACTION
+					{
+					id2=(GrammarAST)match(input,ID,FOLLOW_ID_in_action312); 
+					a1=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_action316); 
+					scope=(id1!=null?id1.getText():null); name=(a1!=null?a1.getText():null); action=(a1!=null?a1.getText():null);
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:172:6: a2= ACTION
+					{
+					a2=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_action331); 
+					scope=null; name=(id1!=null?id1.getText():null); action=(a2!=null?a2.getText():null);
+					}
+					break;
+
+			}
+
+			match(input, Token.UP, null); 
+
+
+						if ( showActions )
+						{
+							out("@"+(scope!=null?scope+"::":"")+name+action);
+						}
+					
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "action"
+
+
+
+	// $ANTLR start "optionsSpec"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:184:1: optionsSpec : ^( OPTIONS ( option )+ ) ;
+	public final void optionsSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:185:2: ( ^( OPTIONS ( option )+ ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:185:4: ^( OPTIONS ( option )+ )
+			{
+			match(input,OPTIONS,FOLLOW_OPTIONS_in_optionsSpec363); 
+			out(" options {");
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:186:4: ( option )+
+			int cnt12=0;
+			loop12:
+			while (true) {
+				int alt12=2;
+				int LA12_0 = input.LA(1);
+				if ( (LA12_0==ASSIGN) ) {
+					alt12=1;
+				}
+
+				switch (alt12) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:186:5: option
+					{
+					pushFollow(FOLLOW_option_in_optionsSpec371);
+					option();
+					state._fsp--;
+
+					out("; ");
+					}
+					break;
+
+				default :
+					if ( cnt12 >= 1 ) break loop12;
+					EarlyExitException eee = new EarlyExitException(12, input);
+					throw eee;
+				}
+				cnt12++;
+			}
+
+			out("} ");
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "optionsSpec"
+
+
+
+	// $ANTLR start "option"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:191:1: option : ^( ASSIGN id= ID optionValue ) ;
+	public final void option() throws RecognitionException {
+		GrammarAST id=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:192:2: ( ^( ASSIGN id= ID optionValue ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:192:4: ^( ASSIGN id= ID optionValue )
+			{
+			match(input,ASSIGN,FOLLOW_ASSIGN_in_option397); 
+			match(input, Token.DOWN, null); 
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_option401); 
+			out((id!=null?id.getText():null)+"=");
+			pushFollow(FOLLOW_optionValue_in_option405);
+			optionValue();
+			state._fsp--;
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "option"
+
+
+
+	// $ANTLR start "optionValue"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:195:1: optionValue : (id= ID |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT );
+	public final void optionValue() throws RecognitionException {
+		GrammarAST id=null;
+		GrammarAST s=null;
+		GrammarAST c=null;
+		GrammarAST i=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:196:2: (id= ID |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT )
+			int alt13=4;
+			switch ( input.LA(1) ) {
+			case ID:
+				{
+				alt13=1;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt13=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt13=3;
+				}
+				break;
+			case INT:
+				{
+				alt13=4;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 13, 0, input);
+				throw nvae;
+			}
+			switch (alt13) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:196:4: id= ID
+					{
+					id=(GrammarAST)match(input,ID,FOLLOW_ID_in_optionValue420); 
+					out((id!=null?id.getText():null));
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:197:4: s= STRING_LITERAL
+					{
+					s=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_optionValue440); 
+					out((s!=null?s.getText():null));
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:198:4: c= CHAR_LITERAL
+					{
+					c=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_optionValue449); 
+					out((c!=null?c.getText():null));
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:199:4: i= INT
+					{
+					i=(GrammarAST)match(input,INT,FOLLOW_INT_in_optionValue460); 
+					out((i!=null?i.getText():null));
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "optionValue"
+
+
+
+	// $ANTLR start "delegateGrammars"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:215:1: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
+	public final void delegateGrammars() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:216:2: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:216:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
+			{
+			match(input,IMPORT,FOLLOW_IMPORT_in_delegateGrammars490); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:216:16: ( ^( ASSIGN ID ID ) | ID )+
+			int cnt14=0;
+			loop14:
+			while (true) {
+				int alt14=3;
+				int LA14_0 = input.LA(1);
+				if ( (LA14_0==ASSIGN) ) {
+					alt14=1;
+				}
+				else if ( (LA14_0==ID) ) {
+					alt14=2;
+				}
+
+				switch (alt14) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:216:18: ^( ASSIGN ID ID )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_delegateGrammars495); 
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_delegateGrammars497); 
+					match(input,ID,FOLLOW_ID_in_delegateGrammars499); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:216:36: ID
+					{
+					match(input,ID,FOLLOW_ID_in_delegateGrammars504); 
+					}
+					break;
+
+				default :
+					if ( cnt14 >= 1 ) break loop14;
+					EarlyExitException eee = new EarlyExitException(14, input);
+					throw eee;
+				}
+				cnt14++;
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "delegateGrammars"
+
+
+
+	// $ANTLR start "tokensSpec"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:219:1: tokensSpec : ^( TOKENS ( tokenSpec )* ) ;
+	public final void tokensSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:220:2: ( ^( TOKENS ( tokenSpec )* ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:220:4: ^( TOKENS ( tokenSpec )* )
+			{
+			match(input,TOKENS,FOLLOW_TOKENS_in_tokensSpec521); 
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/ANTLRTreePrinter.g:220:13: ( tokenSpec )*
+				loop15:
+				while (true) {
+					int alt15=2;
+					int LA15_0 = input.LA(1);
+					if ( (LA15_0==ASSIGN||LA15_0==TOKEN_REF) ) {
+						alt15=1;
+					}
+
+					switch (alt15) {
+					case 1 :
+						// org/antlr/grammar/v3/ANTLRTreePrinter.g:220:13: tokenSpec
+						{
+						pushFollow(FOLLOW_tokenSpec_in_tokensSpec523);
+						tokenSpec();
+						state._fsp--;
+
+						}
+						break;
+
+					default :
+						break loop15;
+					}
+				}
+
+				match(input, Token.UP, null); 
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tokensSpec"
+
+
+
+	// $ANTLR start "tokenSpec"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:223:1: tokenSpec : ( TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) );
+	public final void tokenSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:224:2: ( TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) )
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+			if ( (LA16_0==TOKEN_REF) ) {
+				alt16=1;
+			}
+			else if ( (LA16_0==ASSIGN) ) {
+				alt16=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 16, 0, input);
+				throw nvae;
+			}
+
+			switch (alt16) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:224:4: TOKEN_REF
+					{
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec536); 
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:225:4: ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_tokenSpec543); 
+					match(input, Token.DOWN, null); 
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec545); 
+					if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL ) {
+						input.consume();
+						state.errorRecovery=false;
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						throw mse;
+					}
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tokenSpec"
+
+
+
+	// $ANTLR start "rules"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:228:1: rules : ( rule | precRule )+ ;
+	public final void rules() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:229:2: ( ( rule | precRule )+ )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:229:4: ( rule | precRule )+
+			{
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:229:4: ( rule | precRule )+
+			int cnt17=0;
+			loop17:
+			while (true) {
+				int alt17=3;
+				int LA17_0 = input.LA(1);
+				if ( (LA17_0==RULE) ) {
+					alt17=1;
+				}
+				else if ( (LA17_0==PREC_RULE) ) {
+					alt17=2;
+				}
+
+				switch (alt17) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:229:6: rule
+					{
+					pushFollow(FOLLOW_rule_in_rules566);
+					rule();
+					state._fsp--;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:229:13: precRule
+					{
+					pushFollow(FOLLOW_precRule_in_rules570);
+					precRule();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt17 >= 1 ) break loop17;
+					EarlyExitException eee = new EarlyExitException(17, input);
+					throw eee;
+				}
+				cnt17++;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rules"
+
+
+
+	// $ANTLR start "rule"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:232:1: rule : ^( RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR ) ;
+	public final void rule() throws RecognitionException {
+		GrammarAST id=null;
+		GrammarAST arg=null;
+		GrammarAST ret=null;
+		TreeRuleReturnScope b =null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:233:2: ( ^( RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:233:4: ^( RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR )
+			{
+			match(input,RULE,FOLLOW_RULE_in_rule586); 
+			match(input, Token.DOWN, null); 
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_rule590); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:234:4: ( modifier )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+			if ( (LA18_0==FRAGMENT||(LA18_0 >= PRIVATE && LA18_0 <= PUBLIC)) ) {
+				alt18=1;
+			}
+			switch (alt18) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:234:5: modifier
+					{
+					pushFollow(FOLLOW_modifier_in_rule596);
+					modifier();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			out((id!=null?id.getText():null));
+			match(input,ARG,FOLLOW_ARG_in_rule609); 
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/ANTLRTreePrinter.g:236:10: (arg= ARG_ACTION )?
+				int alt19=2;
+				int LA19_0 = input.LA(1);
+				if ( (LA19_0==ARG_ACTION) ) {
+					alt19=1;
+				}
+				switch (alt19) {
+					case 1 :
+						// org/antlr/grammar/v3/ANTLRTreePrinter.g:236:11: arg= ARG_ACTION
+						{
+						arg=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule614); 
+						out("["+(arg!=null?arg.getText():null)+"]");
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); 
+			}
+
+			match(input,RET,FOLLOW_RET_in_rule627); 
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/ANTLRTreePrinter.g:237:10: (ret= ARG_ACTION )?
+				int alt20=2;
+				int LA20_0 = input.LA(1);
+				if ( (LA20_0==ARG_ACTION) ) {
+					alt20=1;
+				}
+				switch (alt20) {
+					case 1 :
+						// org/antlr/grammar/v3/ANTLRTreePrinter.g:237:11: ret= ARG_ACTION
+						{
+						ret=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule632); 
+						out(" returns ["+(ret!=null?ret.getText():null)+"]");
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); 
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:238:4: ( throwsSpec )?
+			int alt21=2;
+			int LA21_0 = input.LA(1);
+			if ( (LA21_0==THROWS) ) {
+				alt21=1;
+			}
+			switch (alt21) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:238:5: throwsSpec
+					{
+					pushFollow(FOLLOW_throwsSpec_in_rule645);
+					throwsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:239:4: ( optionsSpec )?
+			int alt22=2;
+			int LA22_0 = input.LA(1);
+			if ( (LA22_0==OPTIONS) ) {
+				alt22=1;
+			}
+			switch (alt22) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:239:5: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_rule653);
+					optionsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:240:4: ( ruleScopeSpec )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+			if ( (LA23_0==SCOPE) ) {
+				alt23=1;
+			}
+			switch (alt23) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:240:5: ruleScopeSpec
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_rule661);
+					ruleScopeSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:241:4: ( ruleAction )*
+			loop24:
+			while (true) {
+				int alt24=2;
+				int LA24_0 = input.LA(1);
+				if ( (LA24_0==AMPERSAND) ) {
+					alt24=1;
+				}
+
+				switch (alt24) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:241:5: ruleAction
+					{
+					pushFollow(FOLLOW_ruleAction_in_rule669);
+					ruleAction();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop24;
+				}
+			}
+
+			out(" :");
+
+							if ( input.LA(5) == NOT || input.LA(5) == ASSIGN )
+								out(" ");
+						
+			pushFollow(FOLLOW_block_in_rule688);
+			b=block(false);
+			state._fsp--;
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:248:4: ( exceptionGroup )?
+			int alt25=2;
+			int LA25_0 = input.LA(1);
+			if ( (LA25_0==CATCH||LA25_0==FINALLY) ) {
+				alt25=1;
+			}
+			switch (alt25) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:248:5: exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_rule695);
+					exceptionGroup();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			match(input,EOR,FOLLOW_EOR_in_rule702); 
+			out(";\n");
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rule"
+
+
+
+	// $ANTLR start "precRule"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:253:1: precRule : ^( PREC_RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR ) ;
+	public final void precRule() throws RecognitionException {
+		GrammarAST id=null;
+		GrammarAST arg=null;
+		GrammarAST ret=null;
+		TreeRuleReturnScope b =null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:254:2: ( ^( PREC_RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:254:4: ^( PREC_RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR )
+			{
+			match(input,PREC_RULE,FOLLOW_PREC_RULE_in_precRule721); 
+			match(input, Token.DOWN, null); 
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_precRule725); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:255:4: ( modifier )?
+			int alt26=2;
+			int LA26_0 = input.LA(1);
+			if ( (LA26_0==FRAGMENT||(LA26_0 >= PRIVATE && LA26_0 <= PUBLIC)) ) {
+				alt26=1;
+			}
+			switch (alt26) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:255:5: modifier
+					{
+					pushFollow(FOLLOW_modifier_in_precRule731);
+					modifier();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			out((id!=null?id.getText():null));
+			match(input,ARG,FOLLOW_ARG_in_precRule744); 
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/ANTLRTreePrinter.g:257:10: (arg= ARG_ACTION )?
+				int alt27=2;
+				int LA27_0 = input.LA(1);
+				if ( (LA27_0==ARG_ACTION) ) {
+					alt27=1;
+				}
+				switch (alt27) {
+					case 1 :
+						// org/antlr/grammar/v3/ANTLRTreePrinter.g:257:11: arg= ARG_ACTION
+						{
+						arg=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_precRule749); 
+						out("["+(arg!=null?arg.getText():null)+"]");
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); 
+			}
+
+			match(input,RET,FOLLOW_RET_in_precRule762); 
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/ANTLRTreePrinter.g:258:10: (ret= ARG_ACTION )?
+				int alt28=2;
+				int LA28_0 = input.LA(1);
+				if ( (LA28_0==ARG_ACTION) ) {
+					alt28=1;
+				}
+				switch (alt28) {
+					case 1 :
+						// org/antlr/grammar/v3/ANTLRTreePrinter.g:258:11: ret= ARG_ACTION
+						{
+						ret=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_precRule767); 
+						out(" returns ["+(ret!=null?ret.getText():null)+"]");
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); 
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:259:4: ( throwsSpec )?
+			int alt29=2;
+			int LA29_0 = input.LA(1);
+			if ( (LA29_0==THROWS) ) {
+				alt29=1;
+			}
+			switch (alt29) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:259:5: throwsSpec
+					{
+					pushFollow(FOLLOW_throwsSpec_in_precRule780);
+					throwsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:260:4: ( optionsSpec )?
+			int alt30=2;
+			int LA30_0 = input.LA(1);
+			if ( (LA30_0==OPTIONS) ) {
+				alt30=1;
+			}
+			switch (alt30) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:260:5: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_precRule788);
+					optionsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:261:4: ( ruleScopeSpec )?
+			int alt31=2;
+			int LA31_0 = input.LA(1);
+			if ( (LA31_0==SCOPE) ) {
+				alt31=1;
+			}
+			switch (alt31) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:261:5: ruleScopeSpec
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_precRule796);
+					ruleScopeSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:262:4: ( ruleAction )*
+			loop32:
+			while (true) {
+				int alt32=2;
+				int LA32_0 = input.LA(1);
+				if ( (LA32_0==AMPERSAND) ) {
+					alt32=1;
+				}
+
+				switch (alt32) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:262:5: ruleAction
+					{
+					pushFollow(FOLLOW_ruleAction_in_precRule804);
+					ruleAction();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop32;
+				}
+			}
+
+			out(" :");
+
+							if ( input.LA(5) == NOT || input.LA(5) == ASSIGN )
+								out(" ");
+						
+			pushFollow(FOLLOW_block_in_precRule823);
+			b=block(false);
+			state._fsp--;
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:269:4: ( exceptionGroup )?
+			int alt33=2;
+			int LA33_0 = input.LA(1);
+			if ( (LA33_0==CATCH||LA33_0==FINALLY) ) {
+				alt33=1;
+			}
+			switch (alt33) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:269:5: exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_precRule830);
+					exceptionGroup();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			match(input,EOR,FOLLOW_EOR_in_precRule837); 
+			out(";\n");
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "precRule"
+
+
+
+	// $ANTLR start "ruleAction"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:274:1: ruleAction : ^( AMPERSAND id= ID a= ACTION ) ;
+	public final void ruleAction() throws RecognitionException {
+		GrammarAST id=null;
+		GrammarAST a=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:275:2: ( ^( AMPERSAND id= ID a= ACTION ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:275:4: ^( AMPERSAND id= ID a= ACTION )
+			{
+			match(input,AMPERSAND,FOLLOW_AMPERSAND_in_ruleAction855); 
+			match(input, Token.DOWN, null); 
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_ruleAction859); 
+			a=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_ruleAction863); 
+			match(input, Token.UP, null); 
+
+			if ( showActions ) out("@"+(id!=null?id.getText():null)+"{"+(a!=null?a.getText():null)+"}");
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ruleAction"
+
+
+	public static class modifier_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "modifier"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:279:1: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
+	public final ANTLRTreePrinter.modifier_return modifier() throws RecognitionException {
+		ANTLRTreePrinter.modifier_return retval = new ANTLRTreePrinter.modifier_return();
+		retval.start = input.LT(1);
+
+		out(((GrammarAST)retval.start).getText()); out(" ");
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:282:2: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) ) {
+				input.consume();
+				state.errorRecovery=false;
+			}
+			else {
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "modifier"
+
+
+
+	// $ANTLR start "throwsSpec"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:288:1: throwsSpec : ^( 'throws' ( ID )+ ) ;
+	public final void throwsSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:289:2: ( ^( 'throws' ( ID )+ ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:289:4: ^( 'throws' ( ID )+ )
+			{
+			match(input,THROWS,FOLLOW_THROWS_in_throwsSpec912); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:289:15: ( ID )+
+			int cnt34=0;
+			loop34:
+			while (true) {
+				int alt34=2;
+				int LA34_0 = input.LA(1);
+				if ( (LA34_0==ID) ) {
+					alt34=1;
+				}
+
+				switch (alt34) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:289:15: ID
+					{
+					match(input,ID,FOLLOW_ID_in_throwsSpec914); 
+					}
+					break;
+
+				default :
+					if ( cnt34 >= 1 ) break loop34;
+					EarlyExitException eee = new EarlyExitException(34, input);
+					throw eee;
+				}
+				cnt34++;
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "throwsSpec"
+
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:292:1: ruleScopeSpec : ^( 'scope' ( ruleAction )* ( ACTION )? ( ID )* ) ;
+	public final void ruleScopeSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:293:2: ( ^( 'scope' ( ruleAction )* ( ACTION )? ( ID )* ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:293:4: ^( 'scope' ( ruleAction )* ( ACTION )? ( ID )* )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec929); 
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/ANTLRTreePrinter.g:293:15: ( ruleAction )*
+				loop35:
+				while (true) {
+					int alt35=2;
+					int LA35_0 = input.LA(1);
+					if ( (LA35_0==AMPERSAND) ) {
+						alt35=1;
+					}
+
+					switch (alt35) {
+					case 1 :
+						// org/antlr/grammar/v3/ANTLRTreePrinter.g:293:15: ruleAction
+						{
+						pushFollow(FOLLOW_ruleAction_in_ruleScopeSpec931);
+						ruleAction();
+						state._fsp--;
+
+						}
+						break;
+
+					default :
+						break loop35;
+					}
+				}
+
+				// org/antlr/grammar/v3/ANTLRTreePrinter.g:293:27: ( ACTION )?
+				int alt36=2;
+				int LA36_0 = input.LA(1);
+				if ( (LA36_0==ACTION) ) {
+					alt36=1;
+				}
+				switch (alt36) {
+					case 1 :
+						// org/antlr/grammar/v3/ANTLRTreePrinter.g:293:28: ACTION
+						{
+						match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec935); 
+						}
+						break;
+
+				}
+
+				// org/antlr/grammar/v3/ANTLRTreePrinter.g:293:37: ( ID )*
+				loop37:
+				while (true) {
+					int alt37=2;
+					int LA37_0 = input.LA(1);
+					if ( (LA37_0==ID) ) {
+						alt37=1;
+					}
+
+					switch (alt37) {
+					case 1 :
+						// org/antlr/grammar/v3/ANTLRTreePrinter.g:293:39: ID
+						{
+						match(input,ID,FOLLOW_ID_in_ruleScopeSpec941); 
+						}
+						break;
+
+					default :
+						break loop37;
+					}
+				}
+
+				match(input, Token.UP, null); 
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+
+	public static class block_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "block"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:296:1: block[boolean forceParens] : ^( BLOCK ( optionsSpec )? alternative rewrite ( alternative rewrite )* EOB ) ;
+	public final ANTLRTreePrinter.block_return block(boolean forceParens) throws RecognitionException {
+		ANTLRTreePrinter.block_return retval = new ANTLRTreePrinter.block_return();
+		retval.start = input.LT(1);
+
+
+		int numAlts = countAltsForBlock(((GrammarAST)retval.start));
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:301:2: ( ^( BLOCK ( optionsSpec )? alternative rewrite ( alternative rewrite )* EOB ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:301:4: ^( BLOCK ( optionsSpec )? alternative rewrite ( alternative rewrite )* EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_block965); 
+
+							if ( forceParens||numAlts>1 )
+							{
+								//for ( Antlr.Runtime.Tree.Tree parent = ((GrammarAST)retval.start).getParent(); parent != null && parent.getType() != RULE; parent = parent.getParent() )
+								//{
+								//	if ( parent.getType() == BLOCK && countAltsForBlock((GrammarAST)parent) > 1 )
+								//	{
+								//		out(" ");
+								//		break;
+								//	}
+								//}
+								out(" (");
+							}
+						
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:316:4: ( optionsSpec )?
+			int alt38=2;
+			int LA38_0 = input.LA(1);
+			if ( (LA38_0==OPTIONS) ) {
+				alt38=1;
+			}
+			switch (alt38) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:316:5: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_block976);
+					optionsSpec();
+					state._fsp--;
+
+					out(" :");
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_alternative_in_block986);
+			alternative();
+			state._fsp--;
+
+			pushFollow(FOLLOW_rewrite_in_block988);
+			rewrite();
+			state._fsp--;
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:317:24: ( alternative rewrite )*
+			loop39:
+			while (true) {
+				int alt39=2;
+				int LA39_0 = input.LA(1);
+				if ( (LA39_0==ALT) ) {
+					alt39=1;
+				}
+
+				switch (alt39) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:317:26: alternative rewrite
+					{
+					out("|");
+					pushFollow(FOLLOW_alternative_in_block994);
+					alternative();
+					state._fsp--;
+
+					pushFollow(FOLLOW_rewrite_in_block996);
+					rewrite();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop39;
+				}
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_block1004); 
+			if ( forceParens||numAlts>1 ) out(")");
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+
+	// $ANTLR start "alternative"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:322:1: alternative : ^( ALT ( element )* EOA ) ;
+	public final void alternative() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:323:2: ( ^( ALT ( element )* EOA ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:323:4: ^( ALT ( element )* EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_alternative1026); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:323:11: ( element )*
+			loop40:
+			while (true) {
+				int alt40=2;
+				int LA40_0 = input.LA(1);
+				if ( (LA40_0==ACTION||(LA40_0 >= ASSIGN && LA40_0 <= BLOCK)||(LA40_0 >= CHAR_LITERAL && LA40_0 <= CHAR_RANGE)||LA40_0==CLOSURE||LA40_0==DOT||LA40_0==EPSILON||LA40_0==FORCED_ACTION||LA40_0==GATED_SEMPRED||LA40_0==LABEL||LA40_0==NOT||LA40_0==OPTIONAL||(LA40_0 >= PLUS_ASSIGN && LA40_0 <= POSITIVE_CLOSURE)||LA40_0==RANGE||LA40_0==ROOT||LA40_0==RULE_REF||LA40_0==SEMPRED||(LA40_0 >= STRING_LITERAL && LA40_0 <= SYN_SEMPRED)||LA40_0==TOKEN_REF||LA40_0==TREE_BEGIN||LA40_0==WILDCARD) ) {
+					alt40=1;
+				}
+
+				switch (alt40) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:323:11: element
+					{
+					pushFollow(FOLLOW_element_in_alternative1028);
+					element();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop40;
+				}
+			}
+
+			match(input,EOA,FOLLOW_EOA_in_alternative1031); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "alternative"
+
+
+
+	// $ANTLR start "exceptionGroup"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:326:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	public final void exceptionGroup() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:327:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt43=2;
+			int LA43_0 = input.LA(1);
+			if ( (LA43_0==CATCH) ) {
+				alt43=1;
+			}
+			else if ( (LA43_0==FINALLY) ) {
+				alt43=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 43, 0, input);
+				throw nvae;
+			}
+
+			switch (alt43) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:327:4: ( exceptionHandler )+ ( finallyClause )?
+					{
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:327:4: ( exceptionHandler )+
+					int cnt41=0;
+					loop41:
+					while (true) {
+						int alt41=2;
+						int LA41_0 = input.LA(1);
+						if ( (LA41_0==CATCH) ) {
+							alt41=1;
+						}
+
+						switch (alt41) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRTreePrinter.g:327:6: exceptionHandler
+							{
+							pushFollow(FOLLOW_exceptionHandler_in_exceptionGroup1046);
+							exceptionHandler();
+							state._fsp--;
+
+							}
+							break;
+
+						default :
+							if ( cnt41 >= 1 ) break loop41;
+							EarlyExitException eee = new EarlyExitException(41, input);
+							throw eee;
+						}
+						cnt41++;
+					}
+
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:327:26: ( finallyClause )?
+					int alt42=2;
+					int LA42_0 = input.LA(1);
+					if ( (LA42_0==FINALLY) ) {
+						alt42=1;
+					}
+					switch (alt42) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRTreePrinter.g:327:27: finallyClause
+							{
+							pushFollow(FOLLOW_finallyClause_in_exceptionGroup1052);
+							finallyClause();
+							state._fsp--;
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:328:4: finallyClause
+					{
+					pushFollow(FOLLOW_finallyClause_in_exceptionGroup1059);
+					finallyClause();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+
+	// $ANTLR start "exceptionHandler"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:331:1: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	public final void exceptionHandler() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:332:2: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:332:4: ^( 'catch' ARG_ACTION ACTION )
+			{
+			match(input,CATCH,FOLLOW_CATCH_in_exceptionHandler1071); 
+			match(input, Token.DOWN, null); 
+			match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_exceptionHandler1073); 
+			match(input,ACTION,FOLLOW_ACTION_in_exceptionHandler1075); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+
+	// $ANTLR start "finallyClause"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:335:1: finallyClause : ^( 'finally' ACTION ) ;
+	public final void finallyClause() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:336:2: ( ^( 'finally' ACTION ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:336:4: ^( 'finally' ACTION )
+			{
+			match(input,FINALLY,FOLLOW_FINALLY_in_finallyClause1088); 
+			match(input, Token.DOWN, null); 
+			match(input,ACTION,FOLLOW_ACTION_in_finallyClause1090); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "finallyClause"
+
+
+
+	// $ANTLR start "rewrite"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:339:1: rewrite : ( ^( REWRITES ( single_rewrite )+ ) | REWRITES |);
+	public final void rewrite() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:340:2: ( ^( REWRITES ( single_rewrite )+ ) | REWRITES |)
+			int alt45=3;
+			int LA45_0 = input.LA(1);
+			if ( (LA45_0==REWRITES) ) {
+				int LA45_1 = input.LA(2);
+				if ( (LA45_1==DOWN) ) {
+					alt45=1;
+				}
+				else if ( (LA45_1==EOF||LA45_1==ALT||LA45_1==EOB) ) {
+					alt45=2;
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 45, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+			else if ( (LA45_0==EOF||LA45_0==ALT||LA45_0==EOB) ) {
+				alt45=3;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 45, 0, input);
+				throw nvae;
+			}
+
+			switch (alt45) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:340:4: ^( REWRITES ( single_rewrite )+ )
+					{
+					match(input,REWRITES,FOLLOW_REWRITES_in_rewrite1103); 
+					match(input, Token.DOWN, null); 
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:340:15: ( single_rewrite )+
+					int cnt44=0;
+					loop44:
+					while (true) {
+						int alt44=2;
+						int LA44_0 = input.LA(1);
+						if ( (LA44_0==REWRITE) ) {
+							alt44=1;
+						}
+
+						switch (alt44) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRTreePrinter.g:340:15: single_rewrite
+							{
+							pushFollow(FOLLOW_single_rewrite_in_rewrite1105);
+							single_rewrite();
+							state._fsp--;
+
+							}
+							break;
+
+						default :
+							if ( cnt44 >= 1 ) break loop44;
+							EarlyExitException eee = new EarlyExitException(44, input);
+							throw eee;
+						}
+						cnt44++;
+					}
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:341:4: REWRITES
+					{
+					match(input,REWRITES,FOLLOW_REWRITES_in_rewrite1112); 
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:343:2: 
+					{
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite"
+
+
+
+	// $ANTLR start "single_rewrite"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:345:1: single_rewrite : ^( REWRITE ( SEMPRED )? ( alternative | rewrite_template | ETC | ACTION ) ) ;
+	public final void single_rewrite() throws RecognitionException {
+		GrammarAST SEMPRED1=null;
+		GrammarAST ACTION2=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:346:2: ( ^( REWRITE ( SEMPRED )? ( alternative | rewrite_template | ETC | ACTION ) ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:346:4: ^( REWRITE ( SEMPRED )? ( alternative | rewrite_template | ETC | ACTION ) )
+			{
+			match(input,REWRITE,FOLLOW_REWRITE_in_single_rewrite1128); 
+			out(" ->");
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:347:4: ( SEMPRED )?
+			int alt46=2;
+			int LA46_0 = input.LA(1);
+			if ( (LA46_0==SEMPRED) ) {
+				alt46=1;
+			}
+			switch (alt46) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:347:6: SEMPRED
+					{
+					SEMPRED1=(GrammarAST)match(input,SEMPRED,FOLLOW_SEMPRED_in_single_rewrite1137); 
+					out(" {"+(SEMPRED1!=null?SEMPRED1.getText():null)+"}?");
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:349:4: ( alternative | rewrite_template | ETC | ACTION )
+			int alt47=4;
+			switch ( input.LA(1) ) {
+			case ALT:
+				{
+				alt47=1;
+				}
+				break;
+			case TEMPLATE:
+				{
+				alt47=2;
+				}
+				break;
+			case ETC:
+				{
+				alt47=3;
+				}
+				break;
+			case ACTION:
+				{
+				alt47=4;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 47, 0, input);
+				throw nvae;
+			}
+			switch (alt47) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:349:6: alternative
+					{
+					pushFollow(FOLLOW_alternative_in_single_rewrite1152);
+					alternative();
+					state._fsp--;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:350:6: rewrite_template
+					{
+					pushFollow(FOLLOW_rewrite_template_in_single_rewrite1159);
+					rewrite_template();
+					state._fsp--;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:351:6: ETC
+					{
+					match(input,ETC,FOLLOW_ETC_in_single_rewrite1166); 
+					out("...");
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:352:6: ACTION
+					{
+					ACTION2=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_single_rewrite1175); 
+					out(" {"+(ACTION2!=null?ACTION2.getText():null)+"}");
+					}
+					break;
+
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "single_rewrite"
+
+
+
+	// $ANTLR start "rewrite_template"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:357:1: rewrite_template : ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) ;
+	public final void rewrite_template() throws RecognitionException {
+		GrammarAST id=null;
+		GrammarAST ind=null;
+		GrammarAST arg=null;
+		GrammarAST a=null;
+		GrammarAST DOUBLE_QUOTE_STRING_LITERAL3=null;
+		GrammarAST DOUBLE_ANGLE_STRING_LITERAL4=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:358:2: ( ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:358:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
+			{
+			match(input,TEMPLATE,FOLLOW_TEMPLATE_in_rewrite_template1199); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:359:4: (id= ID |ind= ACTION )
+			int alt48=2;
+			int LA48_0 = input.LA(1);
+			if ( (LA48_0==ID) ) {
+				alt48=1;
+			}
+			else if ( (LA48_0==ACTION) ) {
+				alt48=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 48, 0, input);
+				throw nvae;
+			}
+
+			switch (alt48) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:359:6: id= ID
+					{
+					id=(GrammarAST)match(input,ID,FOLLOW_ID_in_rewrite_template1208); 
+					out(" "+(id!=null?id.getText():null));
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:360:6: ind= ACTION
+					{
+					ind=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template1219); 
+					out(" ({"+(ind!=null?ind.getText():null)+"})");
+					}
+					break;
+
+			}
+
+			match(input,ARGLIST,FOLLOW_ARGLIST_in_rewrite_template1233); 
+			out("(");
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/ANTLRTreePrinter.g:364:5: ( ^( ARG arg= ID a= ACTION ) )*
+				loop49:
+				while (true) {
+					int alt49=2;
+					int LA49_0 = input.LA(1);
+					if ( (LA49_0==ARG) ) {
+						alt49=1;
+					}
+
+					switch (alt49) {
+					case 1 :
+						// org/antlr/grammar/v3/ANTLRTreePrinter.g:364:7: ^( ARG arg= ID a= ACTION )
+						{
+						match(input,ARG,FOLLOW_ARG_in_rewrite_template1249); 
+						match(input, Token.DOWN, null); 
+						arg=(GrammarAST)match(input,ID,FOLLOW_ID_in_rewrite_template1253); 
+						out((arg!=null?arg.getText():null)+"=");
+						a=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template1265); 
+						out((a!=null?a.getText():null));
+						match(input, Token.UP, null); 
+
+						}
+						break;
+
+					default :
+						break loop49;
+					}
+				}
+
+				out(")");
+				match(input, Token.UP, null); 
+			}
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:370:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
+			int alt50=3;
+			int LA50_0 = input.LA(1);
+			if ( (LA50_0==DOUBLE_QUOTE_STRING_LITERAL) ) {
+				alt50=1;
+			}
+			else if ( (LA50_0==DOUBLE_ANGLE_STRING_LITERAL) ) {
+				alt50=2;
+			}
+			switch (alt50) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:370:6: DOUBLE_QUOTE_STRING_LITERAL
+					{
+					DOUBLE_QUOTE_STRING_LITERAL3=(GrammarAST)match(input,DOUBLE_QUOTE_STRING_LITERAL,FOLLOW_DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template1301); 
+					out(" "+(DOUBLE_QUOTE_STRING_LITERAL3!=null?DOUBLE_QUOTE_STRING_LITERAL3.getText():null));
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:371:6: DOUBLE_ANGLE_STRING_LITERAL
+					{
+					DOUBLE_ANGLE_STRING_LITERAL4=(GrammarAST)match(input,DOUBLE_ANGLE_STRING_LITERAL,FOLLOW_DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template1310); 
+					out(" "+(DOUBLE_ANGLE_STRING_LITERAL4!=null?DOUBLE_ANGLE_STRING_LITERAL4.getText():null));
+					}
+					break;
+
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_template"
+
+
+
+	// $ANTLR start "element"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:376:1: element : ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN id= ID element ) | ^( PLUS_ASSIGN id2= ID element ) | ebnf | tree_ | ^( SYNPRED block[true] ) |a= ACTION |a2= FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON );
+	public final void element() throws RecognitionException {
+		GrammarAST id=null;
+		GrammarAST id2=null;
+		GrammarAST a=null;
+		GrammarAST a2=null;
+		GrammarAST pred=null;
+		GrammarAST spred=null;
+		GrammarAST gpred=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:377:2: ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN id= ID element ) | ^( PLUS_ASSIGN id2= ID element ) | ebnf | tree_ | ^( SYNPRED block[true] ) |a= ACTION |a2= FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON )
+			int alt52=18;
+			switch ( input.LA(1) ) {
+			case ROOT:
+				{
+				alt52=1;
+				}
+				break;
+			case BANG:
+				{
+				alt52=2;
+				}
+				break;
+			case CHAR_LITERAL:
+			case DOT:
+			case LABEL:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case WILDCARD:
+				{
+				alt52=3;
+				}
+				break;
+			case NOT:
+				{
+				alt52=4;
+				}
+				break;
+			case RANGE:
+				{
+				alt52=5;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt52=6;
+				}
+				break;
+			case ASSIGN:
+				{
+				alt52=7;
+				}
+				break;
+			case PLUS_ASSIGN:
+				{
+				alt52=8;
+				}
+				break;
+			case BLOCK:
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt52=9;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt52=10;
+				}
+				break;
+			case SYNPRED:
+				{
+				alt52=11;
+				}
+				break;
+			case ACTION:
+				{
+				alt52=12;
+				}
+				break;
+			case FORCED_ACTION:
+				{
+				alt52=13;
+				}
+				break;
+			case SEMPRED:
+				{
+				alt52=14;
+				}
+				break;
+			case SYN_SEMPRED:
+				{
+				alt52=15;
+				}
+				break;
+			case BACKTRACK_SEMPRED:
+				{
+				alt52=16;
+				}
+				break;
+			case GATED_SEMPRED:
+				{
+				alt52=17;
+				}
+				break;
+			case EPSILON:
+				{
+				alt52=18;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 52, 0, input);
+				throw nvae;
+			}
+			switch (alt52) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:377:4: ^( ROOT element )
+					{
+					match(input,ROOT,FOLLOW_ROOT_in_element1334); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_element_in_element1336);
+					element();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					out("^");
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:378:4: ^( BANG element )
+					{
+					match(input,BANG,FOLLOW_BANG_in_element1345); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_element_in_element1347);
+					element();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					out("!");
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:379:4: atom
+					{
+					pushFollow(FOLLOW_atom_in_element1355);
+					atom();
+					state._fsp--;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:380:4: ^( NOT element )
+					{
+					match(input,NOT,FOLLOW_NOT_in_element1361); 
+					out("~");
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_element_in_element1365);
+					element();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:381:4: ^( RANGE atom atom )
+					{
+					match(input,RANGE,FOLLOW_RANGE_in_element1372); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_atom_in_element1374);
+					atom();
+					state._fsp--;
+
+					out("..");
+					pushFollow(FOLLOW_atom_in_element1378);
+					atom();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:382:4: ^( CHAR_RANGE atom atom )
+					{
+					match(input,CHAR_RANGE,FOLLOW_CHAR_RANGE_in_element1385); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_atom_in_element1387);
+					atom();
+					state._fsp--;
+
+					out("..");
+					pushFollow(FOLLOW_atom_in_element1391);
+					atom();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:383:4: ^( ASSIGN id= ID element )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_element1398); 
+					match(input, Token.DOWN, null); 
+					id=(GrammarAST)match(input,ID,FOLLOW_ID_in_element1402); 
+					out((id!=null?id.getText():null)+"=");
+					pushFollow(FOLLOW_element_in_element1406);
+					element();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 8 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:384:4: ^( PLUS_ASSIGN id2= ID element )
+					{
+					match(input,PLUS_ASSIGN,FOLLOW_PLUS_ASSIGN_in_element1413); 
+					match(input, Token.DOWN, null); 
+					id2=(GrammarAST)match(input,ID,FOLLOW_ID_in_element1417); 
+					out((id2!=null?id2.getText():null)+"+=");
+					pushFollow(FOLLOW_element_in_element1421);
+					element();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 9 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:385:4: ebnf
+					{
+					pushFollow(FOLLOW_ebnf_in_element1427);
+					ebnf();
+					state._fsp--;
+
+					}
+					break;
+				case 10 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:386:4: tree_
+					{
+					pushFollow(FOLLOW_tree__in_element1432);
+					tree_();
+					state._fsp--;
+
+					}
+					break;
+				case 11 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:387:4: ^( SYNPRED block[true] )
+					{
+					match(input,SYNPRED,FOLLOW_SYNPRED_in_element1439); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_element1441);
+					block(true);
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					out("=>");
+					}
+					break;
+				case 12 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:388:4: a= ACTION
+					{
+					a=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_element1453); 
+					if ( showActions ) {out("{"); out((a!=null?a.getText():null)); out("}");}
+					}
+					break;
+				case 13 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:389:4: a2= FORCED_ACTION
+					{
+					a2=(GrammarAST)match(input,FORCED_ACTION,FOLLOW_FORCED_ACTION_in_element1463); 
+					if ( showActions ) {out("{{"); out((a2!=null?a2.getText():null)); out("}}");}
+					}
+					break;
+				case 14 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:390:4: pred= SEMPRED
+					{
+					pred=(GrammarAST)match(input,SEMPRED,FOLLOW_SEMPRED_in_element1473); 
+
+								if ( showActions )
+								{
+									out("{");
+									out((pred!=null?pred.getText():null));
+									out("}?");
+								}
+								else
+								{
+									out("{...}?");
+								}
+							
+					}
+					break;
+				case 15 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:403:4: spred= SYN_SEMPRED
+					{
+					spred=(GrammarAST)match(input,SYN_SEMPRED,FOLLOW_SYN_SEMPRED_in_element1484); 
+
+								String name = (spred!=null?spred.getText():null);
+								GrammarAST predAST=grammar.getSyntacticPredicate(name);
+								block(predAST, true);
+								out("=>");
+							
+					}
+					break;
+				case 16 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:410:4: ^( BACKTRACK_SEMPRED ( . )* )
+					{
+					match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_element1494); 
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); 
+						// org/antlr/grammar/v3/ANTLRTreePrinter.g:410:24: ( . )*
+						loop51:
+						while (true) {
+							int alt51=2;
+							int LA51_0 = input.LA(1);
+							if ( ((LA51_0 >= ACTION && LA51_0 <= XDIGIT)) ) {
+								alt51=1;
+							}
+							else if ( (LA51_0==UP) ) {
+								alt51=2;
+							}
+
+							switch (alt51) {
+							case 1 :
+								// org/antlr/grammar/v3/ANTLRTreePrinter.g:410:24: .
+								{
+								matchAny(input); 
+								}
+								break;
+
+							default :
+								break loop51;
+							}
+						}
+
+						match(input, Token.UP, null); 
+					}
+
+					}
+					break;
+				case 17 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:411:4: gpred= GATED_SEMPRED
+					{
+					gpred=(GrammarAST)match(input,GATED_SEMPRED,FOLLOW_GATED_SEMPRED_in_element1506); 
+
+							if ( showActions ) {out("{"); out((gpred!=null?gpred.getText():null)); out("}? =>");}
+							else {out("{...}? =>");}
+							
+					}
+					break;
+				case 18 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:416:4: EPSILON
+					{
+					match(input,EPSILON,FOLLOW_EPSILON_in_element1515); 
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "element"
+
+
+
+	// $ANTLR start "ebnf"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:419:1: ebnf : ( block[true] | ^( OPTIONAL block[true] ) | ^( CLOSURE block[true] ) | ^( POSITIVE_CLOSURE block[true] ) );
+	public final void ebnf() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:420:2: ( block[true] | ^( OPTIONAL block[true] ) | ^( CLOSURE block[true] ) | ^( POSITIVE_CLOSURE block[true] ) )
+			int alt53=4;
+			switch ( input.LA(1) ) {
+			case BLOCK:
+				{
+				alt53=1;
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt53=2;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt53=3;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt53=4;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 53, 0, input);
+				throw nvae;
+			}
+			switch (alt53) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:420:4: block[true]
+					{
+					pushFollow(FOLLOW_block_in_ebnf1526);
+					block(true);
+					state._fsp--;
+
+					out(" ");
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:421:4: ^( OPTIONAL block[true] )
+					{
+					match(input,OPTIONAL,FOLLOW_OPTIONAL_in_ebnf1536); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_ebnf1538);
+					block(true);
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					out("? ");
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:422:4: ^( CLOSURE block[true] )
+					{
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_ebnf1550); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_ebnf1552);
+					block(true);
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					out("* ");
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:423:4: ^( POSITIVE_CLOSURE block[true] )
+					{
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_ebnf1565); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_ebnf1567);
+					block(true);
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					out("+ ");
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ebnf"
+
+
+
+	// $ANTLR start "tree_"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:426:1: tree_ : ^( TREE_BEGIN element ( element )* ) ;
+	public final void tree_() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:427:2: ( ^( TREE_BEGIN element ( element )* ) )
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:427:4: ^( TREE_BEGIN element ( element )* )
+			{
+			match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_tree_1584); 
+			out(" ^(");
+			match(input, Token.DOWN, null); 
+			pushFollow(FOLLOW_element_in_tree_1588);
+			element();
+			state._fsp--;
+
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:427:39: ( element )*
+			loop54:
+			while (true) {
+				int alt54=2;
+				int LA54_0 = input.LA(1);
+				if ( (LA54_0==ACTION||(LA54_0 >= ASSIGN && LA54_0 <= BLOCK)||(LA54_0 >= CHAR_LITERAL && LA54_0 <= CHAR_RANGE)||LA54_0==CLOSURE||LA54_0==DOT||LA54_0==EPSILON||LA54_0==FORCED_ACTION||LA54_0==GATED_SEMPRED||LA54_0==LABEL||LA54_0==NOT||LA54_0==OPTIONAL||(LA54_0 >= PLUS_ASSIGN && LA54_0 <= POSITIVE_CLOSURE)||LA54_0==RANGE||LA54_0==ROOT||LA54_0==RULE_REF||LA54_0==SEMPRED||(LA54_0 >= STRING_LITERAL && LA54_0 <= SYN_SEMPRED)||LA54_0==TOKEN_REF||LA54_0==TREE_BEGIN||LA54_0==WILDCARD) ) {
+					alt54=1;
+				}
+
+				switch (alt54) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:427:40: element
+					{
+					pushFollow(FOLLOW_element_in_tree_1591);
+					element();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop54;
+				}
+			}
+
+			out(") ");
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tree_"
+
+
+	public static class atom_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "atom"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:430:1: atom : ( ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) ) | LABEL | ^( DOT ID atom ) );
+	public final ANTLRTreePrinter.atom_return atom() throws RecognitionException {
+		ANTLRTreePrinter.atom_return retval = new ANTLRTreePrinter.atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST rarg=null;
+		GrammarAST targ=null;
+		GrammarAST LABEL5=null;
+		GrammarAST ID6=null;
+
+		out(" ");
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:433:2: ( ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) ) | LABEL | ^( DOT ID atom ) )
+			int alt63=3;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case WILDCARD:
+				{
+				alt63=1;
+				}
+				break;
+			case LABEL:
+				{
+				alt63=2;
+				}
+				break;
+			case DOT:
+				{
+				alt63=3;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 63, 0, input);
+				throw nvae;
+			}
+			switch (alt63) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:433:4: ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) )
+					{
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:433:4: ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) )
+					int alt62=5;
+					switch ( input.LA(1) ) {
+					case RULE_REF:
+						{
+						alt62=1;
+						}
+						break;
+					case TOKEN_REF:
+						{
+						alt62=2;
+						}
+						break;
+					case CHAR_LITERAL:
+						{
+						alt62=3;
+						}
+						break;
+					case STRING_LITERAL:
+						{
+						alt62=4;
+						}
+						break;
+					case WILDCARD:
+						{
+						alt62=5;
+						}
+						break;
+					default:
+						NoViableAltException nvae =
+							new NoViableAltException("", 62, 0, input);
+						throw nvae;
+					}
+					switch (alt62) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRTreePrinter.g:433:6: ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? )
+							{
+							match(input,RULE_REF,FOLLOW_RULE_REF_in_atom1617); 
+							out(((GrammarAST)retval.start).toString());
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); 
+								// org/antlr/grammar/v3/ANTLRTreePrinter.g:434:5: (rarg= ARG_ACTION )?
+								int alt55=2;
+								int LA55_0 = input.LA(1);
+								if ( (LA55_0==ARG_ACTION) ) {
+									alt55=1;
+								}
+								switch (alt55) {
+									case 1 :
+										// org/antlr/grammar/v3/ANTLRTreePrinter.g:434:6: rarg= ARG_ACTION
+										{
+										rarg=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1629); 
+										out("["+rarg.toString()+"]");
+										}
+										break;
+
+								}
+
+								// org/antlr/grammar/v3/ANTLRTreePrinter.g:435:5: ( ast_suffix )?
+								int alt56=2;
+								int LA56_0 = input.LA(1);
+								if ( (LA56_0==BANG||LA56_0==ROOT) ) {
+									alt56=1;
+								}
+								switch (alt56) {
+									case 1 :
+										// org/antlr/grammar/v3/ANTLRTreePrinter.g:435:6: ast_suffix
+										{
+										pushFollow(FOLLOW_ast_suffix_in_atom1640);
+										ast_suffix();
+										state._fsp--;
+
+										}
+										break;
+
+								}
+
+								match(input, Token.UP, null); 
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRTreePrinter.g:437:5: ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? )
+							{
+							match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom1655); 
+							out(((GrammarAST)retval.start).toString());
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); 
+								// org/antlr/grammar/v3/ANTLRTreePrinter.g:438:5: (targ= ARG_ACTION )?
+								int alt57=2;
+								int LA57_0 = input.LA(1);
+								if ( (LA57_0==ARG_ACTION) ) {
+									alt57=1;
+								}
+								switch (alt57) {
+									case 1 :
+										// org/antlr/grammar/v3/ANTLRTreePrinter.g:438:6: targ= ARG_ACTION
+										{
+										targ=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1667); 
+										out("["+targ.toString()+"]");
+										}
+										break;
+
+								}
+
+								// org/antlr/grammar/v3/ANTLRTreePrinter.g:439:5: ( ast_suffix )?
+								int alt58=2;
+								int LA58_0 = input.LA(1);
+								if ( (LA58_0==BANG||LA58_0==ROOT) ) {
+									alt58=1;
+								}
+								switch (alt58) {
+									case 1 :
+										// org/antlr/grammar/v3/ANTLRTreePrinter.g:439:6: ast_suffix
+										{
+										pushFollow(FOLLOW_ast_suffix_in_atom1679);
+										ast_suffix();
+										state._fsp--;
+
+										}
+										break;
+
+								}
+
+								match(input, Token.UP, null); 
+							}
+
+							}
+							break;
+						case 3 :
+							// org/antlr/grammar/v3/ANTLRTreePrinter.g:441:5: ^( CHAR_LITERAL ( ast_suffix )? )
+							{
+							match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom1694); 
+							out(((GrammarAST)retval.start).toString());
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); 
+								// org/antlr/grammar/v3/ANTLRTreePrinter.g:442:5: ( ast_suffix )?
+								int alt59=2;
+								int LA59_0 = input.LA(1);
+								if ( (LA59_0==BANG||LA59_0==ROOT) ) {
+									alt59=1;
+								}
+								switch (alt59) {
+									case 1 :
+										// org/antlr/grammar/v3/ANTLRTreePrinter.g:442:6: ast_suffix
+										{
+										pushFollow(FOLLOW_ast_suffix_in_atom1703);
+										ast_suffix();
+										state._fsp--;
+
+										}
+										break;
+
+								}
+
+								match(input, Token.UP, null); 
+							}
+
+							}
+							break;
+						case 4 :
+							// org/antlr/grammar/v3/ANTLRTreePrinter.g:444:5: ^( STRING_LITERAL ( ast_suffix )? )
+							{
+							match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_atom1718); 
+							out(((GrammarAST)retval.start).toString());
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); 
+								// org/antlr/grammar/v3/ANTLRTreePrinter.g:445:5: ( ast_suffix )?
+								int alt60=2;
+								int LA60_0 = input.LA(1);
+								if ( (LA60_0==BANG||LA60_0==ROOT) ) {
+									alt60=1;
+								}
+								switch (alt60) {
+									case 1 :
+										// org/antlr/grammar/v3/ANTLRTreePrinter.g:445:6: ast_suffix
+										{
+										pushFollow(FOLLOW_ast_suffix_in_atom1727);
+										ast_suffix();
+										state._fsp--;
+
+										}
+										break;
+
+								}
+
+								match(input, Token.UP, null); 
+							}
+
+							}
+							break;
+						case 5 :
+							// org/antlr/grammar/v3/ANTLRTreePrinter.g:447:5: ^( WILDCARD ( ast_suffix )? )
+							{
+							match(input,WILDCARD,FOLLOW_WILDCARD_in_atom1742); 
+							out(((GrammarAST)retval.start).toString());
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); 
+								// org/antlr/grammar/v3/ANTLRTreePrinter.g:448:5: ( ast_suffix )?
+								int alt61=2;
+								int LA61_0 = input.LA(1);
+								if ( (LA61_0==BANG||LA61_0==ROOT) ) {
+									alt61=1;
+								}
+								switch (alt61) {
+									case 1 :
+										// org/antlr/grammar/v3/ANTLRTreePrinter.g:448:6: ast_suffix
+										{
+										pushFollow(FOLLOW_ast_suffix_in_atom1752);
+										ast_suffix();
+										state._fsp--;
+
+										}
+										break;
+
+								}
+
+								match(input, Token.UP, null); 
+							}
+
+							}
+							break;
+
+					}
+
+					out(" ");
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:452:4: LABEL
+					{
+					LABEL5=(GrammarAST)match(input,LABEL,FOLLOW_LABEL_in_atom1772); 
+					out(" $"+(LABEL5!=null?LABEL5.getText():null));
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:453:4: ^( DOT ID atom )
+					{
+					match(input,DOT,FOLLOW_DOT_in_atom1781); 
+					match(input, Token.DOWN, null); 
+					ID6=(GrammarAST)match(input,ID,FOLLOW_ID_in_atom1783); 
+					out((ID6!=null?ID6.getText():null)+".");
+					pushFollow(FOLLOW_atom_in_atom1787);
+					atom();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "atom"
+
+
+
+	// $ANTLR start "ast_suffix"
+	// org/antlr/grammar/v3/ANTLRTreePrinter.g:456:1: ast_suffix : ( ROOT | BANG );
+	public final void ast_suffix() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRTreePrinter.g:457:2: ( ROOT | BANG )
+			int alt64=2;
+			int LA64_0 = input.LA(1);
+			if ( (LA64_0==ROOT) ) {
+				alt64=1;
+			}
+			else if ( (LA64_0==BANG) ) {
+				alt64=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 64, 0, input);
+				throw nvae;
+			}
+
+			switch (alt64) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:457:4: ROOT
+					{
+					match(input,ROOT,FOLLOW_ROOT_in_ast_suffix1800); 
+					out("^");
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRTreePrinter.g:458:4: BANG
+					{
+					match(input,BANG,FOLLOW_BANG_in_ast_suffix1807); 
+					out("!");
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ast_suffix"
+
+	// Delegated rules
+
+
+
+	public static final BitSet FOLLOW_grammar__in_toString73 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rule_in_toString79 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_alternative_in_toString85 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_element_in_toString91 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_single_rewrite_in_toString97 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_in_toString103 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_EOR_in_toString109 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_LEXER_GRAMMAR_in_grammar_133 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_135 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PARSER_GRAMMAR_in_grammar_145 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_147 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_GRAMMAR_in_grammar_157 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_159 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_COMBINED_GRAMMAR_in_grammar_169 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_171 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_attrScope187 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_attrScope189 = new BitSet(new long[]{0x0000000000000210L});
+	public static final BitSet FOLLOW_ruleAction_in_attrScope191 = new BitSet(new long[]{0x0000000000000210L});
+	public static final BitSet FOLLOW_ACTION_in_attrScope194 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_grammarSpec210 = new BitSet(new long[]{0x0400200008000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_DOC_COMMENT_in_grammarSpec219 = new BitSet(new long[]{0x0400200000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_optionsSpec_in_grammarSpec229 = new BitSet(new long[]{0x0000200000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_delegateGrammars_in_grammarSpec238 = new BitSet(new long[]{0x0000000000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_tokensSpec_in_grammarSpec245 = new BitSet(new long[]{0x0000000000000200L,0x0000000000028002L});
+	public static final BitSet FOLLOW_attrScope_in_grammarSpec252 = new BitSet(new long[]{0x0000000000000200L,0x0000000000028002L});
+	public static final BitSet FOLLOW_actions_in_grammarSpec259 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008002L});
+	public static final BitSet FOLLOW_rules_in_grammarSpec265 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_action_in_actions278 = new BitSet(new long[]{0x0000000000000202L});
+	public static final BitSet FOLLOW_AMPERSAND_in_action299 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_action303 = new BitSet(new long[]{0x0000080000000010L});
+	public static final BitSet FOLLOW_ID_in_action312 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_action316 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ACTION_in_action331 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_OPTIONS_in_optionsSpec363 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_option_in_optionsSpec371 = new BitSet(new long[]{0x0000000000002008L});
+	public static final BitSet FOLLOW_ASSIGN_in_option397 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_option401 = new BitSet(new long[]{0x0000880000040000L,0x0000000001000000L});
+	public static final BitSet FOLLOW_optionValue_in_option405 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_optionValue420 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_optionValue440 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_optionValue449 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_INT_in_optionValue460 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_IMPORT_in_delegateGrammars490 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ASSIGN_in_delegateGrammars495 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_delegateGrammars497 = new BitSet(new long[]{0x0000080000000000L});
+	public static final BitSet FOLLOW_ID_in_delegateGrammars499 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_delegateGrammars504 = new BitSet(new long[]{0x0000080000002008L});
+	public static final BitSet FOLLOW_TOKENS_in_tokensSpec521 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_tokenSpec_in_tokensSpec523 = new BitSet(new long[]{0x0000000000002008L,0x0000000040000000L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec536 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ASSIGN_in_tokenSpec543 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec545 = new BitSet(new long[]{0x0000000000040000L,0x0000000001000000L});
+	public static final BitSet FOLLOW_set_in_tokenSpec547 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_rule_in_rules566 = new BitSet(new long[]{0x0000000000000002L,0x0000000000008002L});
+	public static final BitSet FOLLOW_precRule_in_rules570 = new BitSet(new long[]{0x0000000000000002L,0x0000000000008002L});
+	public static final BitSet FOLLOW_RULE_in_rule586 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rule590 = new BitSet(new long[]{0x0000010000000400L,0x000000000000001CL});
+	public static final BitSet FOLLOW_modifier_in_rule596 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_ARG_in_rule609 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule614 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RET_in_rule627 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule632 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_throwsSpec_in_rule645 = new BitSet(new long[]{0x0400000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_optionsSpec_in_rule653 = new BitSet(new long[]{0x0000000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_rule661 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_ruleAction_in_rule669 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_block_in_rule688 = new BitSet(new long[]{0x0000004400020000L});
+	public static final BitSet FOLLOW_exceptionGroup_in_rule695 = new BitSet(new long[]{0x0000000400000000L});
+	public static final BitSet FOLLOW_EOR_in_rule702 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PREC_RULE_in_precRule721 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_precRule725 = new BitSet(new long[]{0x0000010000000400L,0x000000000000001CL});
+	public static final BitSet FOLLOW_modifier_in_precRule731 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_ARG_in_precRule744 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_precRule749 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RET_in_precRule762 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_precRule767 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_throwsSpec_in_precRule780 = new BitSet(new long[]{0x0400000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_optionsSpec_in_precRule788 = new BitSet(new long[]{0x0000000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_precRule796 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_ruleAction_in_precRule804 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_block_in_precRule823 = new BitSet(new long[]{0x0000004400020000L});
+	public static final BitSet FOLLOW_exceptionGroup_in_precRule830 = new BitSet(new long[]{0x0000000400000000L});
+	public static final BitSet FOLLOW_EOR_in_precRule837 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_AMPERSAND_in_ruleAction855 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_ruleAction859 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_ruleAction863 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_THROWS_in_throwsSpec912 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_throwsSpec914 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec929 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ruleAction_in_ruleScopeSpec931 = new BitSet(new long[]{0x0000080000000218L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec935 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_ID_in_ruleScopeSpec941 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_block965 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_optionsSpec_in_block976 = new BitSet(new long[]{0x0000000000000100L});
+	public static final BitSet FOLLOW_alternative_in_block986 = new BitSet(new long[]{0x0000000200000100L,0x0000000000001000L});
+	public static final BitSet FOLLOW_rewrite_in_block988 = new BitSet(new long[]{0x0000000200000100L});
+	public static final BitSet FOLLOW_alternative_in_block994 = new BitSet(new long[]{0x0000000200000100L,0x0000000000001000L});
+	public static final BitSet FOLLOW_rewrite_in_block996 = new BitSet(new long[]{0x0000000200000100L});
+	public static final BitSet FOLLOW_EOB_in_block1004 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_alternative1026 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_alternative1028 = new BitSet(new long[]{0x82810289202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_EOA_in_alternative1031 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_exceptionHandler_in_exceptionGroup1046 = new BitSet(new long[]{0x0000004000020002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup1052 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup1059 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CATCH_in_exceptionHandler1071 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_exceptionHandler1073 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_exceptionHandler1075 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_FINALLY_in_finallyClause1088 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_finallyClause1090 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_REWRITES_in_rewrite1103 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_single_rewrite_in_rewrite1105 = new BitSet(new long[]{0x0000000000000008L,0x0000000000000800L});
+	public static final BitSet FOLLOW_REWRITES_in_rewrite1112 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_REWRITE_in_single_rewrite1128 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_SEMPRED_in_single_rewrite1137 = new BitSet(new long[]{0x0000002000000110L,0x0000000008000000L});
+	public static final BitSet FOLLOW_alternative_in_single_rewrite1152 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_rewrite_template_in_single_rewrite1159 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ETC_in_single_rewrite1166 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ACTION_in_single_rewrite1175 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TEMPLATE_in_rewrite_template1199 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rewrite_template1208 = new BitSet(new long[]{0x0000000000000800L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template1219 = new BitSet(new long[]{0x0000000000000800L});
+	public static final BitSet FOLLOW_ARGLIST_in_rewrite_template1233 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_in_rewrite_template1249 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rewrite_template1253 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template1265 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template1301 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template1310 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ROOT_in_element1334 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element1336 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BANG_in_element1345 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element1347 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_atom_in_element1355 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_NOT_in_element1361 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element1365 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RANGE_in_element1372 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_atom_in_element1374 = new BitSet(new long[]{0x0001000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_element1378 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_RANGE_in_element1385 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_atom_in_element1387 = new BitSet(new long[]{0x0001000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_element1391 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ASSIGN_in_element1398 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element1402 = new BitSet(new long[]{0x82810288202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_element1406 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PLUS_ASSIGN_in_element1413 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element1417 = new BitSet(new long[]{0x82810288202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_element1421 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ebnf_in_element1427 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_tree__in_element1432 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYNPRED_in_element1439 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_element1441 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ACTION_in_element1453 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_FORCED_ACTION_in_element1463 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SEMPRED_in_element1473 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYN_SEMPRED_in_element1484 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_element1494 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_GATED_SEMPRED_in_element1506 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_EPSILON_in_element1515 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_ebnf1526 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONAL_in_ebnf1536 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1538 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_ebnf1550 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1552 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_ebnf1565 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1567 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_tree_1584 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_tree_1588 = new BitSet(new long[]{0x82810288202DE018L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_tree_1591 = new BitSet(new long[]{0x82810288202DE018L,0x0000000547092041L});
+	public static final BitSet FOLLOW_RULE_REF_in_atom1617 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1629 = new BitSet(new long[]{0x0000000000008008L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom1640 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom1655 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1667 = new BitSet(new long[]{0x0000000000008008L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom1679 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom1694 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom1703 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_atom1718 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom1727 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_WILDCARD_in_atom1742 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom1752 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_LABEL_in_atom1772 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOT_in_atom1781 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_atom1783 = new BitSet(new long[]{0x0001000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_atom1787 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ROOT_in_ast_suffix1800 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_ast_suffix1807 = new BitSet(new long[]{0x0000000000000002L});
+}
--- tool/src/main/java/org/antlr/grammar/v3/ANTLRv3Lexer.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/ANTLRv3Lexer.java	2019-04-04 17:22:25.476181469 +0200
@@ -0,0 +1,3357 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/ANTLRv3.g 2019-04-04 15:18:50
+
+    package org.antlr.grammar.v3;
+
+
+import org.antlr.runtime.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+
+@SuppressWarnings("all")
+public class ANTLRv3Lexer extends Lexer {
+	public static final int EOF=-1;
+	public static final int T__67=67;
+	public static final int T__68=68;
+	public static final int T__69=69;
+	public static final int T__70=70;
+	public static final int T__71=71;
+	public static final int T__72=72;
+	public static final int T__73=73;
+	public static final int T__74=74;
+	public static final int T__75=75;
+	public static final int T__76=76;
+	public static final int T__77=77;
+	public static final int T__78=78;
+	public static final int T__79=79;
+	public static final int T__80=80;
+	public static final int T__81=81;
+	public static final int T__82=82;
+	public static final int T__83=83;
+	public static final int T__84=84;
+	public static final int T__85=85;
+	public static final int T__86=86;
+	public static final int T__87=87;
+	public static final int T__88=88;
+	public static final int T__89=89;
+	public static final int T__90=90;
+	public static final int T__91=91;
+	public static final int T__92=92;
+	public static final int T__93=93;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int ARG=9;
+	public static final int ARGLIST=10;
+	public static final int ARG_ACTION=11;
+	public static final int AT=12;
+	public static final int BACKTRACK_SEMPRED=13;
+	public static final int BANG=14;
+	public static final int BLOCK=15;
+	public static final int CHAR_LITERAL=16;
+	public static final int CHAR_RANGE=17;
+	public static final int CLOSURE=18;
+	public static final int COMBINED_GRAMMAR=19;
+	public static final int DOC_COMMENT=20;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=21;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=22;
+	public static final int EOA=23;
+	public static final int EOB=24;
+	public static final int EOR=25;
+	public static final int EPSILON=26;
+	public static final int ESC=27;
+	public static final int FRAGMENT=28;
+	public static final int GATED_SEMPRED=29;
+	public static final int ID=30;
+	public static final int INT=31;
+	public static final int LABEL=32;
+	public static final int LABEL_ASSIGN=33;
+	public static final int LEXER=34;
+	public static final int LEXER_GRAMMAR=35;
+	public static final int LIST_LABEL_ASSIGN=36;
+	public static final int LITERAL_CHAR=37;
+	public static final int ML_COMMENT=38;
+	public static final int NESTED_ACTION=39;
+	public static final int NESTED_ARG_ACTION=40;
+	public static final int OPTIONAL=41;
+	public static final int OPTIONS=42;
+	public static final int PARSER=43;
+	public static final int PARSER_GRAMMAR=44;
+	public static final int POSITIVE_CLOSURE=45;
+	public static final int RANGE=46;
+	public static final int RET=47;
+	public static final int REWRITE=48;
+	public static final int ROOT=49;
+	public static final int RULE=50;
+	public static final int RULE_REF=51;
+	public static final int SCOPE=52;
+	public static final int SEMPRED=53;
+	public static final int SL_COMMENT=54;
+	public static final int SRC=55;
+	public static final int STRING_LITERAL=56;
+	public static final int SYNPRED=57;
+	public static final int SYN_SEMPRED=58;
+	public static final int TEMPLATE=59;
+	public static final int TOKENS=60;
+	public static final int TOKEN_REF=61;
+	public static final int TREE_BEGIN=62;
+	public static final int TREE_GRAMMAR=63;
+	public static final int WS=64;
+	public static final int WS_LOOP=65;
+	public static final int XDIGIT=66;
+
+	// delegates
+	// delegators
+	public Lexer[] getDelegates() {
+		return new Lexer[] {};
+	}
+
+	public ANTLRv3Lexer() {} 
+	public ANTLRv3Lexer(CharStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public ANTLRv3Lexer(CharStream input, RecognizerSharedState state) {
+		super(input,state);
+	}
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/ANTLRv3.g"; }
+
+	// $ANTLR start "AT"
+	public final void mAT() throws RecognitionException {
+		try {
+			int _type = AT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:11:4: ( '@' )
+			// org/antlr/grammar/v3/ANTLRv3.g:11:6: '@'
+			{
+			match('@'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "AT"
+
+	// $ANTLR start "BANG"
+	public final void mBANG() throws RecognitionException {
+		try {
+			int _type = BANG;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:12:6: ( '!' )
+			// org/antlr/grammar/v3/ANTLRv3.g:12:8: '!'
+			{
+			match('!'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "BANG"
+
+	// $ANTLR start "FRAGMENT"
+	public final void mFRAGMENT() throws RecognitionException {
+		try {
+			int _type = FRAGMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:13:10: ( 'fragment' )
+			// org/antlr/grammar/v3/ANTLRv3.g:13:12: 'fragment'
+			{
+			match("fragment"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "FRAGMENT"
+
+	// $ANTLR start "LABEL_ASSIGN"
+	public final void mLABEL_ASSIGN() throws RecognitionException {
+		try {
+			int _type = LABEL_ASSIGN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:14:14: ( '=' )
+			// org/antlr/grammar/v3/ANTLRv3.g:14:16: '='
+			{
+			match('='); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "LABEL_ASSIGN"
+
+	// $ANTLR start "LIST_LABEL_ASSIGN"
+	public final void mLIST_LABEL_ASSIGN() throws RecognitionException {
+		try {
+			int _type = LIST_LABEL_ASSIGN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:15:19: ( '+=' )
+			// org/antlr/grammar/v3/ANTLRv3.g:15:21: '+='
+			{
+			match("+="); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "LIST_LABEL_ASSIGN"
+
+	// $ANTLR start "RANGE"
+	public final void mRANGE() throws RecognitionException {
+		try {
+			int _type = RANGE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:16:7: ( '..' )
+			// org/antlr/grammar/v3/ANTLRv3.g:16:9: '..'
+			{
+			match(".."); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "RANGE"
+
+	// $ANTLR start "RET"
+	public final void mRET() throws RecognitionException {
+		try {
+			int _type = RET;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:17:5: ( 'returns' )
+			// org/antlr/grammar/v3/ANTLRv3.g:17:7: 'returns'
+			{
+			match("returns"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "RET"
+
+	// $ANTLR start "REWRITE"
+	public final void mREWRITE() throws RecognitionException {
+		try {
+			int _type = REWRITE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:18:9: ( '->' )
+			// org/antlr/grammar/v3/ANTLRv3.g:18:11: '->'
+			{
+			match("->"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "REWRITE"
+
+	// $ANTLR start "ROOT"
+	public final void mROOT() throws RecognitionException {
+		try {
+			int _type = ROOT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:19:6: ( '^' )
+			// org/antlr/grammar/v3/ANTLRv3.g:19:8: '^'
+			{
+			match('^'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ROOT"
+
+	// $ANTLR start "SCOPE"
+	public final void mSCOPE() throws RecognitionException {
+		try {
+			int _type = SCOPE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:20:7: ( 'scope' )
+			// org/antlr/grammar/v3/ANTLRv3.g:20:9: 'scope'
+			{
+			match("scope"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SCOPE"
+
+	// $ANTLR start "TREE_BEGIN"
+	public final void mTREE_BEGIN() throws RecognitionException {
+		try {
+			int _type = TREE_BEGIN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:21:12: ( '^(' )
+			// org/antlr/grammar/v3/ANTLRv3.g:21:14: '^('
+			{
+			match("^("); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TREE_BEGIN"
+
+	// $ANTLR start "T__67"
+	public final void mT__67() throws RecognitionException {
+		try {
+			int _type = T__67;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:22:7: ( '$' )
+			// org/antlr/grammar/v3/ANTLRv3.g:22:9: '$'
+			{
+			match('$'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__67"
+
+	// $ANTLR start "T__68"
+	public final void mT__68() throws RecognitionException {
+		try {
+			int _type = T__68;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:23:7: ( '(' )
+			// org/antlr/grammar/v3/ANTLRv3.g:23:9: '('
+			{
+			match('('); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__68"
+
+	// $ANTLR start "T__69"
+	public final void mT__69() throws RecognitionException {
+		try {
+			int _type = T__69;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:24:7: ( ')' )
+			// org/antlr/grammar/v3/ANTLRv3.g:24:9: ')'
+			{
+			match(')'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__69"
+
+	// $ANTLR start "T__70"
+	public final void mT__70() throws RecognitionException {
+		try {
+			int _type = T__70;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:25:7: ( '*' )
+			// org/antlr/grammar/v3/ANTLRv3.g:25:9: '*'
+			{
+			match('*'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__70"
+
+	// $ANTLR start "T__71"
+	public final void mT__71() throws RecognitionException {
+		try {
+			int _type = T__71;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:26:7: ( '+' )
+			// org/antlr/grammar/v3/ANTLRv3.g:26:9: '+'
+			{
+			match('+'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__71"
+
+	// $ANTLR start "T__72"
+	public final void mT__72() throws RecognitionException {
+		try {
+			int _type = T__72;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:27:7: ( ',' )
+			// org/antlr/grammar/v3/ANTLRv3.g:27:9: ','
+			{
+			match(','); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__72"
+
+	// $ANTLR start "T__73"
+	public final void mT__73() throws RecognitionException {
+		try {
+			int _type = T__73;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:28:7: ( '.' )
+			// org/antlr/grammar/v3/ANTLRv3.g:28:9: '.'
+			{
+			match('.'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__73"
+
+	// $ANTLR start "T__74"
+	public final void mT__74() throws RecognitionException {
+		try {
+			int _type = T__74;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:29:7: ( ':' )
+			// org/antlr/grammar/v3/ANTLRv3.g:29:9: ':'
+			{
+			match(':'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__74"
+
+	// $ANTLR start "T__75"
+	public final void mT__75() throws RecognitionException {
+		try {
+			int _type = T__75;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:30:7: ( '::' )
+			// org/antlr/grammar/v3/ANTLRv3.g:30:9: '::'
+			{
+			match("::"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__75"
+
+	// $ANTLR start "T__76"
+	public final void mT__76() throws RecognitionException {
+		try {
+			int _type = T__76;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:31:7: ( ';' )
+			// org/antlr/grammar/v3/ANTLRv3.g:31:9: ';'
+			{
+			match(';'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__76"
+
+	// $ANTLR start "T__77"
+	public final void mT__77() throws RecognitionException {
+		try {
+			int _type = T__77;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:32:7: ( '<' )
+			// org/antlr/grammar/v3/ANTLRv3.g:32:9: '<'
+			{
+			match('<'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__77"
+
+	// $ANTLR start "T__78"
+	public final void mT__78() throws RecognitionException {
+		try {
+			int _type = T__78;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:33:7: ( '=>' )
+			// org/antlr/grammar/v3/ANTLRv3.g:33:9: '=>'
+			{
+			match("=>"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__78"
+
+	// $ANTLR start "T__79"
+	public final void mT__79() throws RecognitionException {
+		try {
+			int _type = T__79;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:34:7: ( '>' )
+			// org/antlr/grammar/v3/ANTLRv3.g:34:9: '>'
+			{
+			match('>'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__79"
+
+	// $ANTLR start "T__80"
+	public final void mT__80() throws RecognitionException {
+		try {
+			int _type = T__80;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:35:7: ( '?' )
+			// org/antlr/grammar/v3/ANTLRv3.g:35:9: '?'
+			{
+			match('?'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__80"
+
+	// $ANTLR start "T__81"
+	public final void mT__81() throws RecognitionException {
+		try {
+			int _type = T__81;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:36:7: ( 'catch' )
+			// org/antlr/grammar/v3/ANTLRv3.g:36:9: 'catch'
+			{
+			match("catch"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__81"
+
+	// $ANTLR start "T__82"
+	public final void mT__82() throws RecognitionException {
+		try {
+			int _type = T__82;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:37:7: ( 'finally' )
+			// org/antlr/grammar/v3/ANTLRv3.g:37:9: 'finally'
+			{
+			match("finally"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__82"
+
+	// $ANTLR start "T__83"
+	public final void mT__83() throws RecognitionException {
+		try {
+			int _type = T__83;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:38:7: ( 'grammar' )
+			// org/antlr/grammar/v3/ANTLRv3.g:38:9: 'grammar'
+			{
+			match("grammar"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__83"
+
+	// $ANTLR start "T__84"
+	public final void mT__84() throws RecognitionException {
+		try {
+			int _type = T__84;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:39:7: ( 'lexer' )
+			// org/antlr/grammar/v3/ANTLRv3.g:39:9: 'lexer'
+			{
+			match("lexer"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__84"
+
+	// $ANTLR start "T__85"
+	public final void mT__85() throws RecognitionException {
+		try {
+			int _type = T__85;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:40:7: ( 'parser' )
+			// org/antlr/grammar/v3/ANTLRv3.g:40:9: 'parser'
+			{
+			match("parser"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__85"
+
+	// $ANTLR start "T__86"
+	public final void mT__86() throws RecognitionException {
+		try {
+			int _type = T__86;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:41:7: ( 'private' )
+			// org/antlr/grammar/v3/ANTLRv3.g:41:9: 'private'
+			{
+			match("private"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__86"
+
+	// $ANTLR start "T__87"
+	public final void mT__87() throws RecognitionException {
+		try {
+			int _type = T__87;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:42:7: ( 'protected' )
+			// org/antlr/grammar/v3/ANTLRv3.g:42:9: 'protected'
+			{
+			match("protected"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__87"
+
+	// $ANTLR start "T__88"
+	public final void mT__88() throws RecognitionException {
+		try {
+			int _type = T__88;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:43:7: ( 'public' )
+			// org/antlr/grammar/v3/ANTLRv3.g:43:9: 'public'
+			{
+			match("public"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__88"
+
+	// $ANTLR start "T__89"
+	public final void mT__89() throws RecognitionException {
+		try {
+			int _type = T__89;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:44:7: ( 'throws' )
+			// org/antlr/grammar/v3/ANTLRv3.g:44:9: 'throws'
+			{
+			match("throws"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__89"
+
+	// $ANTLR start "T__90"
+	public final void mT__90() throws RecognitionException {
+		try {
+			int _type = T__90;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:45:7: ( 'tree' )
+			// org/antlr/grammar/v3/ANTLRv3.g:45:9: 'tree'
+			{
+			match("tree"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__90"
+
+	// $ANTLR start "T__91"
+	public final void mT__91() throws RecognitionException {
+		try {
+			int _type = T__91;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:46:7: ( '|' )
+			// org/antlr/grammar/v3/ANTLRv3.g:46:9: '|'
+			{
+			match('|'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__91"
+
+	// $ANTLR start "T__92"
+	public final void mT__92() throws RecognitionException {
+		try {
+			int _type = T__92;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:47:7: ( '}' )
+			// org/antlr/grammar/v3/ANTLRv3.g:47:9: '}'
+			{
+			match('}'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__92"
+
+	// $ANTLR start "T__93"
+	public final void mT__93() throws RecognitionException {
+		try {
+			int _type = T__93;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:48:7: ( '~' )
+			// org/antlr/grammar/v3/ANTLRv3.g:48:9: '~'
+			{
+			match('~'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "T__93"
+
+	// $ANTLR start "SL_COMMENT"
+	public final void mSL_COMMENT() throws RecognitionException {
+		try {
+			int _type = SL_COMMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:472:3: ( '//' ( ' $ANTLR ' SRC | (~ ( '\\r' | '\\n' ) )* ) ( '\\r' )? '\\n' )
+			// org/antlr/grammar/v3/ANTLRv3.g:472:5: '//' ( ' $ANTLR ' SRC | (~ ( '\\r' | '\\n' ) )* ) ( '\\r' )? '\\n'
+			{
+			match("//"); 
+
+			// org/antlr/grammar/v3/ANTLRv3.g:473:5: ( ' $ANTLR ' SRC | (~ ( '\\r' | '\\n' ) )* )
+			int alt2=2;
+			alt2 = dfa2.predict(input);
+			switch (alt2) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:473:7: ' $ANTLR ' SRC
+					{
+					match(" $ANTLR "); 
+
+					mSRC(); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:474:6: (~ ( '\\r' | '\\n' ) )*
+					{
+					// org/antlr/grammar/v3/ANTLRv3.g:474:6: (~ ( '\\r' | '\\n' ) )*
+					loop1:
+					while (true) {
+						int alt1=2;
+						int LA1_0 = input.LA(1);
+						if ( ((LA1_0 >= '\u0000' && LA1_0 <= '\t')||(LA1_0 >= '\u000B' && LA1_0 <= '\f')||(LA1_0 >= '\u000E' && LA1_0 <= '\uFFFF')) ) {
+							alt1=1;
+						}
+
+						switch (alt1) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:
+							{
+							if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '\t')||(input.LA(1) >= '\u000B' && input.LA(1) <= '\f')||(input.LA(1) >= '\u000E' && input.LA(1) <= '\uFFFF') ) {
+								input.consume();
+							}
+							else {
+								MismatchedSetException mse = new MismatchedSetException(null,input);
+								recover(mse);
+								throw mse;
+							}
+							}
+							break;
+
+						default :
+							break loop1;
+						}
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:476:3: ( '\\r' )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+			if ( (LA3_0=='\r') ) {
+				alt3=1;
+			}
+			switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:476:3: '\\r'
+					{
+					match('\r'); 
+					}
+					break;
+
+			}
+
+			match('\n'); 
+			_channel=HIDDEN;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SL_COMMENT"
+
+	// $ANTLR start "ML_COMMENT"
+	public final void mML_COMMENT() throws RecognitionException {
+		try {
+			int _type = ML_COMMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:481:2: ( '/*' ( . )* '*/' )
+			// org/antlr/grammar/v3/ANTLRv3.g:481:4: '/*' ( . )* '*/'
+			{
+			match("/*"); 
+
+			if (input.LA(1)=='*') _type=DOC_COMMENT; else _channel=HIDDEN;
+			// org/antlr/grammar/v3/ANTLRv3.g:481:74: ( . )*
+			loop4:
+			while (true) {
+				int alt4=2;
+				int LA4_0 = input.LA(1);
+				if ( (LA4_0=='*') ) {
+					int LA4_1 = input.LA(2);
+					if ( (LA4_1=='/') ) {
+						alt4=2;
+					}
+					else if ( ((LA4_1 >= '\u0000' && LA4_1 <= '.')||(LA4_1 >= '0' && LA4_1 <= '\uFFFF')) ) {
+						alt4=1;
+					}
+
+				}
+				else if ( ((LA4_0 >= '\u0000' && LA4_0 <= ')')||(LA4_0 >= '+' && LA4_0 <= '\uFFFF')) ) {
+					alt4=1;
+				}
+
+				switch (alt4) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:481:74: .
+					{
+					matchAny(); 
+					}
+					break;
+
+				default :
+					break loop4;
+				}
+			}
+
+			match("*/"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ML_COMMENT"
+
+	// $ANTLR start "CHAR_LITERAL"
+	public final void mCHAR_LITERAL() throws RecognitionException {
+		try {
+			int _type = CHAR_LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:485:2: ( '\\'' LITERAL_CHAR '\\'' )
+			// org/antlr/grammar/v3/ANTLRv3.g:485:4: '\\'' LITERAL_CHAR '\\''
+			{
+			match('\''); 
+			mLITERAL_CHAR(); 
+
+			match('\''); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "CHAR_LITERAL"
+
+	// $ANTLR start "STRING_LITERAL"
+	public final void mSTRING_LITERAL() throws RecognitionException {
+		try {
+			int _type = STRING_LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:489:2: ( '\\'' LITERAL_CHAR ( LITERAL_CHAR )* '\\'' )
+			// org/antlr/grammar/v3/ANTLRv3.g:489:4: '\\'' LITERAL_CHAR ( LITERAL_CHAR )* '\\''
+			{
+			match('\''); 
+			mLITERAL_CHAR(); 
+
+			// org/antlr/grammar/v3/ANTLRv3.g:489:22: ( LITERAL_CHAR )*
+			loop5:
+			while (true) {
+				int alt5=2;
+				int LA5_0 = input.LA(1);
+				if ( ((LA5_0 >= '\u0000' && LA5_0 <= '&')||(LA5_0 >= '(' && LA5_0 <= '\uFFFF')) ) {
+					alt5=1;
+				}
+
+				switch (alt5) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:489:22: LITERAL_CHAR
+					{
+					mLITERAL_CHAR(); 
+
+					}
+					break;
+
+				default :
+					break loop5;
+				}
+			}
+
+			match('\''); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "STRING_LITERAL"
+
+	// $ANTLR start "LITERAL_CHAR"
+	public final void mLITERAL_CHAR() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:495:2: ( ESC |~ ( '\\'' | '\\\\' ) )
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+			if ( (LA6_0=='\\') ) {
+				alt6=1;
+			}
+			else if ( ((LA6_0 >= '\u0000' && LA6_0 <= '&')||(LA6_0 >= '(' && LA6_0 <= '[')||(LA6_0 >= ']' && LA6_0 <= '\uFFFF')) ) {
+				alt6=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 6, 0, input);
+				throw nvae;
+			}
+
+			switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:495:4: ESC
+					{
+					mESC(); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:496:4: ~ ( '\\'' | '\\\\' )
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '&')||(input.LA(1) >= '(' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+			}
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "LITERAL_CHAR"
+
+	// $ANTLR start "DOUBLE_QUOTE_STRING_LITERAL"
+	public final void mDOUBLE_QUOTE_STRING_LITERAL() throws RecognitionException {
+		try {
+			int _type = DOUBLE_QUOTE_STRING_LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:499:2: ( '\"' ( ESC |~ ( '\\\\' | '\"' ) )* '\"' )
+			// org/antlr/grammar/v3/ANTLRv3.g:499:4: '\"' ( ESC |~ ( '\\\\' | '\"' ) )* '\"'
+			{
+			match('\"'); 
+			// org/antlr/grammar/v3/ANTLRv3.g:499:8: ( ESC |~ ( '\\\\' | '\"' ) )*
+			loop7:
+			while (true) {
+				int alt7=3;
+				int LA7_0 = input.LA(1);
+				if ( (LA7_0=='\\') ) {
+					alt7=1;
+				}
+				else if ( ((LA7_0 >= '\u0000' && LA7_0 <= '!')||(LA7_0 >= '#' && LA7_0 <= '[')||(LA7_0 >= ']' && LA7_0 <= '\uFFFF')) ) {
+					alt7=2;
+				}
+
+				switch (alt7) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:499:9: ESC
+					{
+					mESC(); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:499:15: ~ ( '\\\\' | '\"' )
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop7;
+				}
+			}
+
+			match('\"'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "DOUBLE_QUOTE_STRING_LITERAL"
+
+	// $ANTLR start "DOUBLE_ANGLE_STRING_LITERAL"
+	public final void mDOUBLE_ANGLE_STRING_LITERAL() throws RecognitionException {
+		try {
+			int _type = DOUBLE_ANGLE_STRING_LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:503:2: ( '<<' ( . )* '>>' )
+			// org/antlr/grammar/v3/ANTLRv3.g:503:4: '<<' ( . )* '>>'
+			{
+			match("<<"); 
+
+			// org/antlr/grammar/v3/ANTLRv3.g:503:9: ( . )*
+			loop8:
+			while (true) {
+				int alt8=2;
+				int LA8_0 = input.LA(1);
+				if ( (LA8_0=='>') ) {
+					int LA8_1 = input.LA(2);
+					if ( (LA8_1=='>') ) {
+						alt8=2;
+					}
+					else if ( ((LA8_1 >= '\u0000' && LA8_1 <= '=')||(LA8_1 >= '?' && LA8_1 <= '\uFFFF')) ) {
+						alt8=1;
+					}
+
+				}
+				else if ( ((LA8_0 >= '\u0000' && LA8_0 <= '=')||(LA8_0 >= '?' && LA8_0 <= '\uFFFF')) ) {
+					alt8=1;
+				}
+
+				switch (alt8) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:503:9: .
+					{
+					matchAny(); 
+					}
+					break;
+
+				default :
+					break loop8;
+				}
+			}
+
+			match(">>"); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "DOUBLE_ANGLE_STRING_LITERAL"
+
+	// $ANTLR start "ESC"
+	public final void mESC() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:508:5: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:508:7: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . )
+			{
+			match('\\'); 
+			// org/antlr/grammar/v3/ANTLRv3.g:509:3: ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . )
+			int alt9=11;
+			int LA9_0 = input.LA(1);
+			if ( (LA9_0=='n') ) {
+				alt9=1;
+			}
+			else if ( (LA9_0=='r') ) {
+				alt9=2;
+			}
+			else if ( (LA9_0=='t') ) {
+				alt9=3;
+			}
+			else if ( (LA9_0=='b') ) {
+				alt9=4;
+			}
+			else if ( (LA9_0=='f') ) {
+				alt9=5;
+			}
+			else if ( (LA9_0=='\"') ) {
+				alt9=6;
+			}
+			else if ( (LA9_0=='\'') ) {
+				alt9=7;
+			}
+			else if ( (LA9_0=='\\') ) {
+				alt9=8;
+			}
+			else if ( (LA9_0=='>') ) {
+				alt9=9;
+			}
+			else if ( (LA9_0=='u') ) {
+				int LA9_10 = input.LA(2);
+				if ( ((LA9_10 >= '0' && LA9_10 <= '9')||(LA9_10 >= 'A' && LA9_10 <= 'F')||(LA9_10 >= 'a' && LA9_10 <= 'f')) ) {
+					alt9=10;
+				}
+
+				else {
+					alt9=11;
+				}
+
+			}
+			else if ( ((LA9_0 >= '\u0000' && LA9_0 <= '!')||(LA9_0 >= '#' && LA9_0 <= '&')||(LA9_0 >= '(' && LA9_0 <= '=')||(LA9_0 >= '?' && LA9_0 <= '[')||(LA9_0 >= ']' && LA9_0 <= 'a')||(LA9_0 >= 'c' && LA9_0 <= 'e')||(LA9_0 >= 'g' && LA9_0 <= 'm')||(LA9_0 >= 'o' && LA9_0 <= 'q')||LA9_0=='s'||(LA9_0 >= 'v' && LA9_0 <= '\uFFFF')) ) {
+				alt9=11;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 9, 0, input);
+				throw nvae;
+			}
+
+			switch (alt9) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:509:5: 'n'
+					{
+					match('n'); 
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:510:5: 'r'
+					{
+					match('r'); 
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:511:5: 't'
+					{
+					match('t'); 
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:512:5: 'b'
+					{
+					match('b'); 
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRv3.g:513:5: 'f'
+					{
+					match('f'); 
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLRv3.g:514:5: '\"'
+					{
+					match('\"'); 
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/ANTLRv3.g:515:5: '\\''
+					{
+					match('\''); 
+					}
+					break;
+				case 8 :
+					// org/antlr/grammar/v3/ANTLRv3.g:516:5: '\\\\'
+					{
+					match('\\'); 
+					}
+					break;
+				case 9 :
+					// org/antlr/grammar/v3/ANTLRv3.g:517:5: '>'
+					{
+					match('>'); 
+					}
+					break;
+				case 10 :
+					// org/antlr/grammar/v3/ANTLRv3.g:518:5: 'u' XDIGIT XDIGIT XDIGIT XDIGIT
+					{
+					match('u'); 
+					mXDIGIT(); 
+
+					mXDIGIT(); 
+
+					mXDIGIT(); 
+
+					mXDIGIT(); 
+
+					}
+					break;
+				case 11 :
+					// org/antlr/grammar/v3/ANTLRv3.g:519:5: .
+					{
+					matchAny(); 
+					}
+					break;
+
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ESC"
+
+	// $ANTLR start "XDIGIT"
+	public final void mXDIGIT() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:524:8: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
+			// org/antlr/grammar/v3/ANTLRv3.g:
+			{
+			if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'F')||(input.LA(1) >= 'a' && input.LA(1) <= 'f') ) {
+				input.consume();
+			}
+			else {
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				recover(mse);
+				throw mse;
+			}
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "XDIGIT"
+
+	// $ANTLR start "INT"
+	public final void mINT() throws RecognitionException {
+		try {
+			int _type = INT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:529:5: ( ( '0' .. '9' )+ )
+			// org/antlr/grammar/v3/ANTLRv3.g:529:7: ( '0' .. '9' )+
+			{
+			// org/antlr/grammar/v3/ANTLRv3.g:529:7: ( '0' .. '9' )+
+			int cnt10=0;
+			loop10:
+			while (true) {
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+				if ( ((LA10_0 >= '0' && LA10_0 <= '9')) ) {
+					alt10=1;
+				}
+
+				switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:
+					{
+					if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
+						input.consume();
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					if ( cnt10 >= 1 ) break loop10;
+					EarlyExitException eee = new EarlyExitException(10, input);
+					throw eee;
+				}
+				cnt10++;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "INT"
+
+	// $ANTLR start "ARG_ACTION"
+	public final void mARG_ACTION() throws RecognitionException {
+		try {
+			int _type = ARG_ACTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:533:2: ( NESTED_ARG_ACTION )
+			// org/antlr/grammar/v3/ANTLRv3.g:533:4: NESTED_ARG_ACTION
+			{
+			mNESTED_ARG_ACTION(); 
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ARG_ACTION"
+
+	// $ANTLR start "NESTED_ARG_ACTION"
+	public final void mNESTED_ARG_ACTION() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:538:19: ( '[' ( options {greedy=false; k=1; } : NESTED_ARG_ACTION | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL | . )* ']' )
+			// org/antlr/grammar/v3/ANTLRv3.g:539:2: '[' ( options {greedy=false; k=1; } : NESTED_ARG_ACTION | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL | . )* ']'
+			{
+			match('['); 
+			// org/antlr/grammar/v3/ANTLRv3.g:540:2: ( options {greedy=false; k=1; } : NESTED_ARG_ACTION | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL | . )*
+			loop11:
+			while (true) {
+				int alt11=5;
+				int LA11_0 = input.LA(1);
+				if ( (LA11_0==']') ) {
+					alt11=5;
+				}
+				else if ( (LA11_0=='[') ) {
+					alt11=1;
+				}
+				else if ( (LA11_0=='\"') ) {
+					alt11=2;
+				}
+				else if ( (LA11_0=='\'') ) {
+					alt11=3;
+				}
+				else if ( ((LA11_0 >= '\u0000' && LA11_0 <= '!')||(LA11_0 >= '#' && LA11_0 <= '&')||(LA11_0 >= '(' && LA11_0 <= 'Z')||LA11_0=='\\'||(LA11_0 >= '^' && LA11_0 <= '\uFFFF')) ) {
+					alt11=4;
+				}
+
+				switch (alt11) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:541:4: NESTED_ARG_ACTION
+					{
+					mNESTED_ARG_ACTION(); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:542:4: ACTION_STRING_LITERAL
+					{
+					mACTION_STRING_LITERAL(); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:543:4: ACTION_CHAR_LITERAL
+					{
+					mACTION_CHAR_LITERAL(); 
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:544:4: .
+					{
+					matchAny(); 
+					}
+					break;
+
+				default :
+					break loop11;
+				}
+			}
+
+			match(']'); 
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "NESTED_ARG_ACTION"
+
+	// $ANTLR start "ACTION"
+	public final void mACTION() throws RecognitionException {
+		try {
+			int _type = ACTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:550:2: ( NESTED_ACTION ( '?' )? )
+			// org/antlr/grammar/v3/ANTLRv3.g:550:4: NESTED_ACTION ( '?' )?
+			{
+			mNESTED_ACTION(); 
+
+			// org/antlr/grammar/v3/ANTLRv3.g:550:18: ( '?' )?
+			int alt12=2;
+			int LA12_0 = input.LA(1);
+			if ( (LA12_0=='?') ) {
+				alt12=1;
+			}
+			switch (alt12) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:550:20: '?'
+					{
+					match('?'); 
+					_type = SEMPRED;
+					}
+					break;
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ACTION"
+
+	// $ANTLR start "NESTED_ACTION"
+	public final void mNESTED_ACTION() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:555:15: ( '{' ( options {greedy=false; k=2; } : NESTED_ACTION | SL_COMMENT | ML_COMMENT | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL | . )* '}' )
+			// org/antlr/grammar/v3/ANTLRv3.g:556:2: '{' ( options {greedy=false; k=2; } : NESTED_ACTION | SL_COMMENT | ML_COMMENT | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL | . )* '}'
+			{
+			match('{'); 
+			// org/antlr/grammar/v3/ANTLRv3.g:557:2: ( options {greedy=false; k=2; } : NESTED_ACTION | SL_COMMENT | ML_COMMENT | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL | . )*
+			loop13:
+			while (true) {
+				int alt13=7;
+				int LA13_0 = input.LA(1);
+				if ( (LA13_0=='}') ) {
+					alt13=7;
+				}
+				else if ( (LA13_0=='{') ) {
+					alt13=1;
+				}
+				else if ( (LA13_0=='/') ) {
+					int LA13_3 = input.LA(2);
+					if ( (LA13_3=='/') ) {
+						alt13=2;
+					}
+					else if ( (LA13_3=='*') ) {
+						alt13=3;
+					}
+					else if ( ((LA13_3 >= '\u0000' && LA13_3 <= ')')||(LA13_3 >= '+' && LA13_3 <= '.')||(LA13_3 >= '0' && LA13_3 <= '\uFFFF')) ) {
+						alt13=6;
+					}
+
+				}
+				else if ( (LA13_0=='\"') ) {
+					int LA13_4 = input.LA(2);
+					if ( (LA13_4=='\\') ) {
+						alt13=4;
+					}
+					else if ( (LA13_4=='}') ) {
+						alt13=4;
+					}
+					else if ( (LA13_4=='\"') ) {
+						alt13=4;
+					}
+					else if ( (LA13_4=='{') ) {
+						alt13=4;
+					}
+					else if ( (LA13_4=='/') ) {
+						alt13=4;
+					}
+					else if ( (LA13_4=='\'') ) {
+						alt13=4;
+					}
+					else if ( ((LA13_4 >= '\u0000' && LA13_4 <= '!')||(LA13_4 >= '#' && LA13_4 <= '&')||(LA13_4 >= '(' && LA13_4 <= '.')||(LA13_4 >= '0' && LA13_4 <= '[')||(LA13_4 >= ']' && LA13_4 <= 'z')||LA13_4=='|'||(LA13_4 >= '~' && LA13_4 <= '\uFFFF')) ) {
+						alt13=4;
+					}
+
+				}
+				else if ( (LA13_0=='\'') ) {
+					int LA13_5 = input.LA(2);
+					if ( (LA13_5=='\\') ) {
+						alt13=5;
+					}
+					else if ( (LA13_5=='}') ) {
+						alt13=5;
+					}
+					else if ( (LA13_5=='{') ) {
+						alt13=5;
+					}
+					else if ( (LA13_5=='/') ) {
+						alt13=5;
+					}
+					else if ( (LA13_5=='\"') ) {
+						alt13=5;
+					}
+					else if ( ((LA13_5 >= '\u0000' && LA13_5 <= '!')||(LA13_5 >= '#' && LA13_5 <= '&')||(LA13_5 >= '(' && LA13_5 <= '.')||(LA13_5 >= '0' && LA13_5 <= '[')||(LA13_5 >= ']' && LA13_5 <= 'z')||LA13_5=='|'||(LA13_5 >= '~' && LA13_5 <= '\uFFFF')) ) {
+						alt13=5;
+					}
+					else if ( (LA13_5=='\'') ) {
+						alt13=6;
+					}
+
+				}
+				else if ( ((LA13_0 >= '\u0000' && LA13_0 <= '!')||(LA13_0 >= '#' && LA13_0 <= '&')||(LA13_0 >= '(' && LA13_0 <= '.')||(LA13_0 >= '0' && LA13_0 <= 'z')||LA13_0=='|'||(LA13_0 >= '~' && LA13_0 <= '\uFFFF')) ) {
+					alt13=6;
+				}
+
+				switch (alt13) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:558:4: NESTED_ACTION
+					{
+					mNESTED_ACTION(); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:559:4: SL_COMMENT
+					{
+					mSL_COMMENT(); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:560:4: ML_COMMENT
+					{
+					mML_COMMENT(); 
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:561:4: ACTION_STRING_LITERAL
+					{
+					mACTION_STRING_LITERAL(); 
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRv3.g:562:4: ACTION_CHAR_LITERAL
+					{
+					mACTION_CHAR_LITERAL(); 
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLRv3.g:563:4: .
+					{
+					matchAny(); 
+					}
+					break;
+
+				default :
+					break loop13;
+				}
+			}
+
+			match('}'); 
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "NESTED_ACTION"
+
+	// $ANTLR start "ACTION_CHAR_LITERAL"
+	public final void mACTION_CHAR_LITERAL() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:570:2: ( '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) ) '\\'' )
+			// org/antlr/grammar/v3/ANTLRv3.g:570:4: '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) ) '\\''
+			{
+			match('\''); 
+			// org/antlr/grammar/v3/ANTLRv3.g:570:9: ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )
+			int alt14=2;
+			int LA14_0 = input.LA(1);
+			if ( (LA14_0=='\\') ) {
+				alt14=1;
+			}
+			else if ( ((LA14_0 >= '\u0000' && LA14_0 <= '&')||(LA14_0 >= '(' && LA14_0 <= '[')||(LA14_0 >= ']' && LA14_0 <= '\uFFFF')) ) {
+				alt14=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 14, 0, input);
+				throw nvae;
+			}
+
+			switch (alt14) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:570:10: ACTION_ESC
+					{
+					mACTION_ESC(); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:570:21: ~ ( '\\\\' | '\\'' )
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '&')||(input.LA(1) >= '(' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+			}
+
+			match('\''); 
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ACTION_CHAR_LITERAL"
+
+	// $ANTLR start "ACTION_STRING_LITERAL"
+	public final void mACTION_STRING_LITERAL() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:575:2: ( '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"' )
+			// org/antlr/grammar/v3/ANTLRv3.g:575:4: '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"'
+			{
+			match('\"'); 
+			// org/antlr/grammar/v3/ANTLRv3.g:575:8: ( ACTION_ESC |~ ( '\\\\' | '\"' ) )*
+			loop15:
+			while (true) {
+				int alt15=3;
+				int LA15_0 = input.LA(1);
+				if ( (LA15_0=='\\') ) {
+					alt15=1;
+				}
+				else if ( ((LA15_0 >= '\u0000' && LA15_0 <= '!')||(LA15_0 >= '#' && LA15_0 <= '[')||(LA15_0 >= ']' && LA15_0 <= '\uFFFF')) ) {
+					alt15=2;
+				}
+
+				switch (alt15) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:575:9: ACTION_ESC
+					{
+					mACTION_ESC(); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:575:20: ~ ( '\\\\' | '\"' )
+					{
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop15;
+				}
+			}
+
+			match('\"'); 
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ACTION_STRING_LITERAL"
+
+	// $ANTLR start "ACTION_ESC"
+	public final void mACTION_ESC() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:580:2: ( '\\\\\\'' | '\\\\' '\"' | '\\\\' ~ ( '\\'' | '\"' ) )
+			int alt16=3;
+			int LA16_0 = input.LA(1);
+			if ( (LA16_0=='\\') ) {
+				int LA16_1 = input.LA(2);
+				if ( (LA16_1=='\'') ) {
+					alt16=1;
+				}
+				else if ( (LA16_1=='\"') ) {
+					alt16=2;
+				}
+				else if ( ((LA16_1 >= '\u0000' && LA16_1 <= '!')||(LA16_1 >= '#' && LA16_1 <= '&')||(LA16_1 >= '(' && LA16_1 <= '\uFFFF')) ) {
+					alt16=3;
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 16, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 16, 0, input);
+				throw nvae;
+			}
+
+			switch (alt16) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:580:4: '\\\\\\''
+					{
+					match("\\'"); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:581:4: '\\\\' '\"'
+					{
+					match('\\'); 
+					match('\"'); 
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:582:4: '\\\\' ~ ( '\\'' | '\"' )
+					{
+					match('\\'); 
+					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '&')||(input.LA(1) >= '(' && input.LA(1) <= '\uFFFF') ) {
+						input.consume();
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+			}
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ACTION_ESC"
+
+	// $ANTLR start "TOKEN_REF"
+	public final void mTOKEN_REF() throws RecognitionException {
+		try {
+			int _type = TOKEN_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:585:2: ( 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// org/antlr/grammar/v3/ANTLRv3.g:585:4: 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			{
+			matchRange('A','Z'); 
+			// org/antlr/grammar/v3/ANTLRv3.g:585:13: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			loop17:
+			while (true) {
+				int alt17=2;
+				int LA17_0 = input.LA(1);
+				if ( ((LA17_0 >= '0' && LA17_0 <= '9')||(LA17_0 >= 'A' && LA17_0 <= 'Z')||LA17_0=='_'||(LA17_0 >= 'a' && LA17_0 <= 'z')) ) {
+					alt17=1;
+				}
+
+				switch (alt17) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:
+					{
+					if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
+						input.consume();
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop17;
+				}
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TOKEN_REF"
+
+	// $ANTLR start "RULE_REF"
+	public final void mRULE_REF() throws RecognitionException {
+		try {
+			int _type = RULE_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:589:2: ( 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// org/antlr/grammar/v3/ANTLRv3.g:589:4: 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			{
+			matchRange('a','z'); 
+			// org/antlr/grammar/v3/ANTLRv3.g:589:13: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			loop18:
+			while (true) {
+				int alt18=2;
+				int LA18_0 = input.LA(1);
+				if ( ((LA18_0 >= '0' && LA18_0 <= '9')||(LA18_0 >= 'A' && LA18_0 <= 'Z')||LA18_0=='_'||(LA18_0 >= 'a' && LA18_0 <= 'z')) ) {
+					alt18=1;
+				}
+
+				switch (alt18) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:
+					{
+					if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
+						input.consume();
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						recover(mse);
+						throw mse;
+					}
+					}
+					break;
+
+				default :
+					break loop18;
+				}
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "RULE_REF"
+
+	// $ANTLR start "OPTIONS"
+	public final void mOPTIONS() throws RecognitionException {
+		try {
+			int _type = OPTIONS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:599:2: ( 'options' WS_LOOP '{' )
+			// org/antlr/grammar/v3/ANTLRv3.g:599:4: 'options' WS_LOOP '{'
+			{
+			match("options"); 
+
+			mWS_LOOP(); 
+
+			match('{'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "OPTIONS"
+
+	// $ANTLR start "TOKENS"
+	public final void mTOKENS() throws RecognitionException {
+		try {
+			int _type = TOKENS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:600:2: ( 'tokens' WS_LOOP '{' )
+			// org/antlr/grammar/v3/ANTLRv3.g:600:4: 'tokens' WS_LOOP '{'
+			{
+			match("tokens"); 
+
+			mWS_LOOP(); 
+
+			match('{'); 
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "TOKENS"
+
+	// $ANTLR start "SRC"
+	public final void mSRC() throws RecognitionException {
+		try {
+			CommonToken file=null;
+			CommonToken line=null;
+
+			// org/antlr/grammar/v3/ANTLRv3.g:613:5: ( 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT )
+			// org/antlr/grammar/v3/ANTLRv3.g:613:7: 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT
+			{
+			match("src"); 
+
+			match(' '); 
+			int fileStart966 = getCharIndex();
+			int fileStartLine966 = getLine();
+			int fileStartCharPos966 = getCharPositionInLine();
+			mACTION_STRING_LITERAL(); 
+			file = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, fileStart966, getCharIndex()-1);
+			file.setLine(fileStartLine966);
+			file.setCharPositionInLine(fileStartCharPos966);
+
+			match(' '); 
+			int lineStart972 = getCharIndex();
+			int lineStartLine972 = getLine();
+			int lineStartCharPos972 = getCharPositionInLine();
+			mINT(); 
+			line = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, lineStart972, getCharIndex()-1);
+			line.setLine(lineStartLine972);
+			line.setCharPositionInLine(lineStartCharPos972);
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "SRC"
+
+	// $ANTLR start "WS"
+	public final void mWS() throws RecognitionException {
+		try {
+			int _type = WS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// org/antlr/grammar/v3/ANTLRv3.g:611:4: ( ( ' ' | '\\t' | ( '\\r' )? '\\n' )+ )
+			// org/antlr/grammar/v3/ANTLRv3.g:611:6: ( ' ' | '\\t' | ( '\\r' )? '\\n' )+
+			{
+			// org/antlr/grammar/v3/ANTLRv3.g:611:6: ( ' ' | '\\t' | ( '\\r' )? '\\n' )+
+			int cnt20=0;
+			loop20:
+			while (true) {
+				int alt20=4;
+				switch ( input.LA(1) ) {
+				case ' ':
+					{
+					alt20=1;
+					}
+					break;
+				case '\t':
+					{
+					alt20=2;
+					}
+					break;
+				case '\n':
+				case '\r':
+					{
+					alt20=3;
+					}
+					break;
+				}
+				switch (alt20) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:611:8: ' '
+					{
+					match(' '); 
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:612:5: '\\t'
+					{
+					match('\t'); 
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:613:5: ( '\\r' )? '\\n'
+					{
+					// org/antlr/grammar/v3/ANTLRv3.g:613:5: ( '\\r' )?
+					int alt19=2;
+					int LA19_0 = input.LA(1);
+					if ( (LA19_0=='\r') ) {
+						alt19=1;
+					}
+					switch (alt19) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:613:5: '\\r'
+							{
+							match('\r'); 
+							}
+							break;
+
+					}
+
+					match('\n'); 
+					}
+					break;
+
+				default :
+					if ( cnt20 >= 1 ) break loop20;
+					EarlyExitException eee = new EarlyExitException(20, input);
+					throw eee;
+				}
+				cnt20++;
+			}
+
+			_channel=HIDDEN;
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "WS"
+
+	// $ANTLR start "WS_LOOP"
+	public final void mWS_LOOP() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:621:2: ( ( WS | SL_COMMENT | ML_COMMENT )* )
+			// org/antlr/grammar/v3/ANTLRv3.g:621:4: ( WS | SL_COMMENT | ML_COMMENT )*
+			{
+			// org/antlr/grammar/v3/ANTLRv3.g:621:4: ( WS | SL_COMMENT | ML_COMMENT )*
+			loop21:
+			while (true) {
+				int alt21=4;
+				int LA21_0 = input.LA(1);
+				if ( ((LA21_0 >= '\t' && LA21_0 <= '\n')||LA21_0=='\r'||LA21_0==' ') ) {
+					alt21=1;
+				}
+				else if ( (LA21_0=='/') ) {
+					int LA21_3 = input.LA(2);
+					if ( (LA21_3=='/') ) {
+						alt21=2;
+					}
+					else if ( (LA21_3=='*') ) {
+						alt21=3;
+					}
+
+				}
+
+				switch (alt21) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:621:6: WS
+					{
+					mWS(); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:622:5: SL_COMMENT
+					{
+					mSL_COMMENT(); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:623:5: ML_COMMENT
+					{
+					mML_COMMENT(); 
+
+					}
+					break;
+
+				default :
+					break loop21;
+				}
+			}
+
+			}
+
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "WS_LOOP"
+
+	@Override
+	public void mTokens() throws RecognitionException {
+		// org/antlr/grammar/v3/ANTLRv3.g:1:8: ( AT | BANG | FRAGMENT | LABEL_ASSIGN | LIST_LABEL_ASSIGN | RANGE | RET | REWRITE | ROOT | SCOPE | TREE_BEGIN | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | T__81 | T__82 | T__83 | T__84 | T__85 | T__86 | T__87 | T__88 | T__89 | T__90 | T__91 | T__92 | T__93 | SL_COMMENT | ML_COMMENT | CHAR_LITERAL | STRING_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | RULE_REF | OPTIONS | TOKENS | WS )
+		int alt22=52;
+		alt22 = dfa22.predict(input);
+		switch (alt22) {
+			case 1 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:10: AT
+				{
+				mAT(); 
+
+				}
+				break;
+			case 2 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:13: BANG
+				{
+				mBANG(); 
+
+				}
+				break;
+			case 3 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:18: FRAGMENT
+				{
+				mFRAGMENT(); 
+
+				}
+				break;
+			case 4 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:27: LABEL_ASSIGN
+				{
+				mLABEL_ASSIGN(); 
+
+				}
+				break;
+			case 5 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:40: LIST_LABEL_ASSIGN
+				{
+				mLIST_LABEL_ASSIGN(); 
+
+				}
+				break;
+			case 6 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:58: RANGE
+				{
+				mRANGE(); 
+
+				}
+				break;
+			case 7 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:64: RET
+				{
+				mRET(); 
+
+				}
+				break;
+			case 8 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:68: REWRITE
+				{
+				mREWRITE(); 
+
+				}
+				break;
+			case 9 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:76: ROOT
+				{
+				mROOT(); 
+
+				}
+				break;
+			case 10 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:81: SCOPE
+				{
+				mSCOPE(); 
+
+				}
+				break;
+			case 11 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:87: TREE_BEGIN
+				{
+				mTREE_BEGIN(); 
+
+				}
+				break;
+			case 12 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:98: T__67
+				{
+				mT__67(); 
+
+				}
+				break;
+			case 13 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:104: T__68
+				{
+				mT__68(); 
+
+				}
+				break;
+			case 14 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:110: T__69
+				{
+				mT__69(); 
+
+				}
+				break;
+			case 15 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:116: T__70
+				{
+				mT__70(); 
+
+				}
+				break;
+			case 16 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:122: T__71
+				{
+				mT__71(); 
+
+				}
+				break;
+			case 17 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:128: T__72
+				{
+				mT__72(); 
+
+				}
+				break;
+			case 18 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:134: T__73
+				{
+				mT__73(); 
+
+				}
+				break;
+			case 19 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:140: T__74
+				{
+				mT__74(); 
+
+				}
+				break;
+			case 20 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:146: T__75
+				{
+				mT__75(); 
+
+				}
+				break;
+			case 21 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:152: T__76
+				{
+				mT__76(); 
+
+				}
+				break;
+			case 22 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:158: T__77
+				{
+				mT__77(); 
+
+				}
+				break;
+			case 23 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:164: T__78
+				{
+				mT__78(); 
+
+				}
+				break;
+			case 24 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:170: T__79
+				{
+				mT__79(); 
+
+				}
+				break;
+			case 25 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:176: T__80
+				{
+				mT__80(); 
+
+				}
+				break;
+			case 26 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:182: T__81
+				{
+				mT__81(); 
+
+				}
+				break;
+			case 27 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:188: T__82
+				{
+				mT__82(); 
+
+				}
+				break;
+			case 28 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:194: T__83
+				{
+				mT__83(); 
+
+				}
+				break;
+			case 29 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:200: T__84
+				{
+				mT__84(); 
+
+				}
+				break;
+			case 30 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:206: T__85
+				{
+				mT__85(); 
+
+				}
+				break;
+			case 31 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:212: T__86
+				{
+				mT__86(); 
+
+				}
+				break;
+			case 32 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:218: T__87
+				{
+				mT__87(); 
+
+				}
+				break;
+			case 33 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:224: T__88
+				{
+				mT__88(); 
+
+				}
+				break;
+			case 34 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:230: T__89
+				{
+				mT__89(); 
+
+				}
+				break;
+			case 35 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:236: T__90
+				{
+				mT__90(); 
+
+				}
+				break;
+			case 36 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:242: T__91
+				{
+				mT__91(); 
+
+				}
+				break;
+			case 37 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:248: T__92
+				{
+				mT__92(); 
+
+				}
+				break;
+			case 38 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:254: T__93
+				{
+				mT__93(); 
+
+				}
+				break;
+			case 39 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:260: SL_COMMENT
+				{
+				mSL_COMMENT(); 
+
+				}
+				break;
+			case 40 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:271: ML_COMMENT
+				{
+				mML_COMMENT(); 
+
+				}
+				break;
+			case 41 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:282: CHAR_LITERAL
+				{
+				mCHAR_LITERAL(); 
+
+				}
+				break;
+			case 42 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:295: STRING_LITERAL
+				{
+				mSTRING_LITERAL(); 
+
+				}
+				break;
+			case 43 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:310: DOUBLE_QUOTE_STRING_LITERAL
+				{
+				mDOUBLE_QUOTE_STRING_LITERAL(); 
+
+				}
+				break;
+			case 44 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:338: DOUBLE_ANGLE_STRING_LITERAL
+				{
+				mDOUBLE_ANGLE_STRING_LITERAL(); 
+
+				}
+				break;
+			case 45 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:366: INT
+				{
+				mINT(); 
+
+				}
+				break;
+			case 46 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:370: ARG_ACTION
+				{
+				mARG_ACTION(); 
+
+				}
+				break;
+			case 47 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:381: ACTION
+				{
+				mACTION(); 
+
+				}
+				break;
+			case 48 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:388: TOKEN_REF
+				{
+				mTOKEN_REF(); 
+
+				}
+				break;
+			case 49 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:398: RULE_REF
+				{
+				mRULE_REF(); 
+
+				}
+				break;
+			case 50 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:407: OPTIONS
+				{
+				mOPTIONS(); 
+
+				}
+				break;
+			case 51 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:415: TOKENS
+				{
+				mTOKENS(); 
+
+				}
+				break;
+			case 52 :
+				// org/antlr/grammar/v3/ANTLRv3.g:1:422: WS
+				{
+				mWS(); 
+
+				}
+				break;
+
+		}
+	}
+
+
+	protected DFA2 dfa2 = new DFA2(this);
+	protected DFA22 dfa22 = new DFA22(this);
+	static final String DFA2_eotS =
+		"\22\uffff\1\2\4\uffff\1\2\4\uffff";
+	static final String DFA2_eofS =
+		"\34\uffff";
+	static final String DFA2_minS =
+		"\2\0\1\uffff\26\0\1\uffff\1\0\1\uffff";
+	static final String DFA2_maxS =
+		"\2\uffff\1\uffff\26\uffff\1\uffff\1\uffff\1\uffff";
+	static final String DFA2_acceptS =
+		"\2\uffff\1\2\26\uffff\1\1\1\uffff\1\1";
+	static final String DFA2_specialS =
+		"\1\0\1\20\1\uffff\1\21\1\22\1\23\1\24\1\25\1\26\1\12\1\13\1\14\1\15\1"+
+		"\27\1\2\1\17\1\10\1\6\1\16\1\7\1\1\1\3\1\5\1\11\1\4\1\uffff\1\30\1\uffff}>";
+	static final String[] DFA2_transitionS = {
+			"\40\2\1\1\uffdf\2",
+			"\44\2\1\3\uffdb\2",
+			"",
+			"\101\2\1\4\uffbe\2",
+			"\116\2\1\5\uffb1\2",
+			"\124\2\1\6\uffab\2",
+			"\114\2\1\7\uffb3\2",
+			"\122\2\1\10\uffad\2",
+			"\40\2\1\11\uffdf\2",
+			"\163\2\1\12\uff8c\2",
+			"\162\2\1\13\uff8d\2",
+			"\143\2\1\14\uff9c\2",
+			"\40\2\1\15\uffdf\2",
+			"\42\2\1\16\uffdd\2",
+			"\12\23\1\22\2\23\1\20\24\23\1\21\71\23\1\17\uffa3\23",
+			"\12\30\1\27\2\30\1\26\24\30\1\25\4\30\1\24\uffd8\30",
+			"\12\31\1\22\ufff5\31",
+			"\40\2\1\32\uffdf\2",
+			"\0\31",
+			"\12\23\1\22\2\23\1\20\24\23\1\21\71\23\1\17\uffa3\23",
+			"\12\23\1\22\2\23\1\20\24\23\1\21\71\23\1\17\uffa3\23",
+			"\12\23\1\22\2\23\1\20\24\23\1\21\71\23\1\17\uffa3\23",
+			"\12\31\1\22\ufff5\31",
+			"\0\31",
+			"\12\23\1\22\2\23\1\20\24\23\1\21\71\23\1\17\uffa3\23",
+			"",
+			"\60\2\12\33\uffc6\2",
+			""
+	};
+
+	static final short[] DFA2_eot = DFA.unpackEncodedString(DFA2_eotS);
+	static final short[] DFA2_eof = DFA.unpackEncodedString(DFA2_eofS);
+	static final char[] DFA2_min = DFA.unpackEncodedStringToUnsignedChars(DFA2_minS);
+	static final char[] DFA2_max = DFA.unpackEncodedStringToUnsignedChars(DFA2_maxS);
+	static final short[] DFA2_accept = DFA.unpackEncodedString(DFA2_acceptS);
+	static final short[] DFA2_special = DFA.unpackEncodedString(DFA2_specialS);
+	static final short[][] DFA2_transition;
+
+	static {
+		int numStates = DFA2_transitionS.length;
+		DFA2_transition = new short[numStates][];
+		for (int i=0; i<numStates; i++) {
+			DFA2_transition[i] = DFA.unpackEncodedString(DFA2_transitionS[i]);
+		}
+	}
+
+	protected class DFA2 extends DFA {
+
+		public DFA2(BaseRecognizer recognizer) {
+			this.recognizer = recognizer;
+			this.decisionNumber = 2;
+			this.eot = DFA2_eot;
+			this.eof = DFA2_eof;
+			this.min = DFA2_min;
+			this.max = DFA2_max;
+			this.accept = DFA2_accept;
+			this.special = DFA2_special;
+			this.transition = DFA2_transition;
+		}
+		@Override
+		public String getDescription() {
+			return "473:5: ( ' $ANTLR ' SRC | (~ ( '\\r' | '\\n' ) )* )";
+		}
+		@Override
+		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
+			IntStream input = _input;
+			int _s = s;
+			switch ( s ) {
+					case 0 : 
+						int LA2_0 = input.LA(1);
+						s = -1;
+						if ( (LA2_0==' ') ) {s = 1;}
+						else if ( ((LA2_0 >= '\u0000' && LA2_0 <= '\u001F')||(LA2_0 >= '!' && LA2_0 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 1 : 
+						int LA2_20 = input.LA(1);
+						s = -1;
+						if ( (LA2_20=='\"') ) {s = 17;}
+						else if ( (LA2_20=='\\') ) {s = 15;}
+						else if ( (LA2_20=='\r') ) {s = 16;}
+						else if ( (LA2_20=='\n') ) {s = 18;}
+						else if ( ((LA2_20 >= '\u0000' && LA2_20 <= '\t')||(LA2_20 >= '\u000B' && LA2_20 <= '\f')||(LA2_20 >= '\u000E' && LA2_20 <= '!')||(LA2_20 >= '#' && LA2_20 <= '[')||(LA2_20 >= ']' && LA2_20 <= '\uFFFF')) ) {s = 19;}
+						if ( s>=0 ) return s;
+						break;
+					case 2 : 
+						int LA2_14 = input.LA(1);
+						s = -1;
+						if ( (LA2_14=='\\') ) {s = 15;}
+						else if ( (LA2_14=='\r') ) {s = 16;}
+						else if ( (LA2_14=='\"') ) {s = 17;}
+						else if ( (LA2_14=='\n') ) {s = 18;}
+						else if ( ((LA2_14 >= '\u0000' && LA2_14 <= '\t')||(LA2_14 >= '\u000B' && LA2_14 <= '\f')||(LA2_14 >= '\u000E' && LA2_14 <= '!')||(LA2_14 >= '#' && LA2_14 <= '[')||(LA2_14 >= ']' && LA2_14 <= '\uFFFF')) ) {s = 19;}
+						if ( s>=0 ) return s;
+						break;
+					case 3 : 
+						int LA2_21 = input.LA(1);
+						s = -1;
+						if ( (LA2_21=='\"') ) {s = 17;}
+						else if ( (LA2_21=='\\') ) {s = 15;}
+						else if ( (LA2_21=='\r') ) {s = 16;}
+						else if ( (LA2_21=='\n') ) {s = 18;}
+						else if ( ((LA2_21 >= '\u0000' && LA2_21 <= '\t')||(LA2_21 >= '\u000B' && LA2_21 <= '\f')||(LA2_21 >= '\u000E' && LA2_21 <= '!')||(LA2_21 >= '#' && LA2_21 <= '[')||(LA2_21 >= ']' && LA2_21 <= '\uFFFF')) ) {s = 19;}
+						if ( s>=0 ) return s;
+						break;
+					case 4 : 
+						int LA2_24 = input.LA(1);
+						s = -1;
+						if ( (LA2_24=='\"') ) {s = 17;}
+						else if ( (LA2_24=='\\') ) {s = 15;}
+						else if ( (LA2_24=='\r') ) {s = 16;}
+						else if ( (LA2_24=='\n') ) {s = 18;}
+						else if ( ((LA2_24 >= '\u0000' && LA2_24 <= '\t')||(LA2_24 >= '\u000B' && LA2_24 <= '\f')||(LA2_24 >= '\u000E' && LA2_24 <= '!')||(LA2_24 >= '#' && LA2_24 <= '[')||(LA2_24 >= ']' && LA2_24 <= '\uFFFF')) ) {s = 19;}
+						if ( s>=0 ) return s;
+						break;
+					case 5 : 
+						int LA2_22 = input.LA(1);
+						s = -1;
+						if ( ((LA2_22 >= '\u0000' && LA2_22 <= '\t')||(LA2_22 >= '\u000B' && LA2_22 <= '\uFFFF')) ) {s = 25;}
+						else if ( (LA2_22=='\n') ) {s = 18;}
+						if ( s>=0 ) return s;
+						break;
+					case 6 : 
+						int LA2_17 = input.LA(1);
+						s = -1;
+						if ( (LA2_17==' ') ) {s = 26;}
+						else if ( ((LA2_17 >= '\u0000' && LA2_17 <= '\u001F')||(LA2_17 >= '!' && LA2_17 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 7 : 
+						int LA2_19 = input.LA(1);
+						s = -1;
+						if ( (LA2_19=='\"') ) {s = 17;}
+						else if ( (LA2_19=='\\') ) {s = 15;}
+						else if ( (LA2_19=='\r') ) {s = 16;}
+						else if ( (LA2_19=='\n') ) {s = 18;}
+						else if ( ((LA2_19 >= '\u0000' && LA2_19 <= '\t')||(LA2_19 >= '\u000B' && LA2_19 <= '\f')||(LA2_19 >= '\u000E' && LA2_19 <= '!')||(LA2_19 >= '#' && LA2_19 <= '[')||(LA2_19 >= ']' && LA2_19 <= '\uFFFF')) ) {s = 19;}
+						if ( s>=0 ) return s;
+						break;
+					case 8 : 
+						int LA2_16 = input.LA(1);
+						s = -1;
+						if ( ((LA2_16 >= '\u0000' && LA2_16 <= '\t')||(LA2_16 >= '\u000B' && LA2_16 <= '\uFFFF')) ) {s = 25;}
+						else if ( (LA2_16=='\n') ) {s = 18;}
+						if ( s>=0 ) return s;
+						break;
+					case 9 : 
+						int LA2_23 = input.LA(1);
+						s = -1;
+						if ( ((LA2_23 >= '\u0000' && LA2_23 <= '\uFFFF')) ) {s = 25;}
+						else s = 2;
+						if ( s>=0 ) return s;
+						break;
+					case 10 : 
+						int LA2_9 = input.LA(1);
+						s = -1;
+						if ( (LA2_9=='s') ) {s = 10;}
+						else if ( ((LA2_9 >= '\u0000' && LA2_9 <= 'r')||(LA2_9 >= 't' && LA2_9 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 11 : 
+						int LA2_10 = input.LA(1);
+						s = -1;
+						if ( (LA2_10=='r') ) {s = 11;}
+						else if ( ((LA2_10 >= '\u0000' && LA2_10 <= 'q')||(LA2_10 >= 's' && LA2_10 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 12 : 
+						int LA2_11 = input.LA(1);
+						s = -1;
+						if ( (LA2_11=='c') ) {s = 12;}
+						else if ( ((LA2_11 >= '\u0000' && LA2_11 <= 'b')||(LA2_11 >= 'd' && LA2_11 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 13 : 
+						int LA2_12 = input.LA(1);
+						s = -1;
+						if ( (LA2_12==' ') ) {s = 13;}
+						else if ( ((LA2_12 >= '\u0000' && LA2_12 <= '\u001F')||(LA2_12 >= '!' && LA2_12 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 14 : 
+						int LA2_18 = input.LA(1);
+						s = -1;
+						if ( ((LA2_18 >= '\u0000' && LA2_18 <= '\uFFFF')) ) {s = 25;}
+						else s = 2;
+						if ( s>=0 ) return s;
+						break;
+					case 15 : 
+						int LA2_15 = input.LA(1);
+						s = -1;
+						if ( (LA2_15=='\'') ) {s = 20;}
+						else if ( (LA2_15=='\"') ) {s = 21;}
+						else if ( (LA2_15=='\r') ) {s = 22;}
+						else if ( (LA2_15=='\n') ) {s = 23;}
+						else if ( ((LA2_15 >= '\u0000' && LA2_15 <= '\t')||(LA2_15 >= '\u000B' && LA2_15 <= '\f')||(LA2_15 >= '\u000E' && LA2_15 <= '!')||(LA2_15 >= '#' && LA2_15 <= '&')||(LA2_15 >= '(' && LA2_15 <= '\uFFFF')) ) {s = 24;}
+						if ( s>=0 ) return s;
+						break;
+					case 16 : 
+						int LA2_1 = input.LA(1);
+						s = -1;
+						if ( (LA2_1=='$') ) {s = 3;}
+						else if ( ((LA2_1 >= '\u0000' && LA2_1 <= '#')||(LA2_1 >= '%' && LA2_1 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 17 : 
+						int LA2_3 = input.LA(1);
+						s = -1;
+						if ( (LA2_3=='A') ) {s = 4;}
+						else if ( ((LA2_3 >= '\u0000' && LA2_3 <= '@')||(LA2_3 >= 'B' && LA2_3 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 18 : 
+						int LA2_4 = input.LA(1);
+						s = -1;
+						if ( (LA2_4=='N') ) {s = 5;}
+						else if ( ((LA2_4 >= '\u0000' && LA2_4 <= 'M')||(LA2_4 >= 'O' && LA2_4 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 19 : 
+						int LA2_5 = input.LA(1);
+						s = -1;
+						if ( (LA2_5=='T') ) {s = 6;}
+						else if ( ((LA2_5 >= '\u0000' && LA2_5 <= 'S')||(LA2_5 >= 'U' && LA2_5 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 20 : 
+						int LA2_6 = input.LA(1);
+						s = -1;
+						if ( (LA2_6=='L') ) {s = 7;}
+						else if ( ((LA2_6 >= '\u0000' && LA2_6 <= 'K')||(LA2_6 >= 'M' && LA2_6 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 21 : 
+						int LA2_7 = input.LA(1);
+						s = -1;
+						if ( (LA2_7=='R') ) {s = 8;}
+						else if ( ((LA2_7 >= '\u0000' && LA2_7 <= 'Q')||(LA2_7 >= 'S' && LA2_7 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 22 : 
+						int LA2_8 = input.LA(1);
+						s = -1;
+						if ( (LA2_8==' ') ) {s = 9;}
+						else if ( ((LA2_8 >= '\u0000' && LA2_8 <= '\u001F')||(LA2_8 >= '!' && LA2_8 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 23 : 
+						int LA2_13 = input.LA(1);
+						s = -1;
+						if ( (LA2_13=='\"') ) {s = 14;}
+						else if ( ((LA2_13 >= '\u0000' && LA2_13 <= '!')||(LA2_13 >= '#' && LA2_13 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+					case 24 : 
+						int LA2_26 = input.LA(1);
+						s = -1;
+						if ( ((LA2_26 >= '0' && LA2_26 <= '9')) ) {s = 27;}
+						else if ( ((LA2_26 >= '\u0000' && LA2_26 <= '/')||(LA2_26 >= ':' && LA2_26 <= '\uFFFF')) ) {s = 2;}
+						if ( s>=0 ) return s;
+						break;
+			}
+			NoViableAltException nvae =
+				new NoViableAltException(getDescription(), 2, _s, input);
+			error(nvae);
+			throw nvae;
+		}
+	}
+
+	static final String DFA22_eotS =
+		"\3\uffff\1\45\1\52\1\54\1\56\1\45\1\uffff\1\61\1\45\5\uffff\1\64\1\uffff"+
+		"\1\66\2\uffff\5\45\12\uffff\1\45\2\uffff\2\45\6\uffff\1\45\2\uffff\1\45"+
+		"\4\uffff\11\45\4\uffff\17\45\15\uffff\15\45\1\176\1\45\2\uffff\4\45\1"+
+		"\u0085\1\u0086\1\45\1\u0088\5\45\1\uffff\1\45\1\uffff\4\45\2\uffff\1\45"+
+		"\1\uffff\1\u0095\2\45\1\u0098\1\u0099\1\45\1\uffff\2\45\1\u009e\1\u009f"+
+		"\1\u00a0\1\uffff\1\u00a1\1\45\4\uffff\1\45\1\u00a4\4\uffff\1\45\2\uffff"+
+		"\1\u00a6\1\uffff";
+	static final String DFA22_eofS =
+		"\u00a7\uffff";
+	static final String DFA22_minS =
+		"\1\11\2\uffff\1\151\1\76\1\75\1\56\1\145\1\uffff\1\50\1\143\5\uffff\1"+
+		"\72\1\uffff\1\74\2\uffff\1\141\1\162\1\145\1\141\1\150\3\uffff\1\52\1"+
+		"\0\5\uffff\1\160\2\uffff\1\141\1\156\6\uffff\1\164\2\uffff\1\157\4\uffff"+
+		"\1\164\1\141\1\170\1\162\1\151\1\142\1\162\1\145\1\153\2\uffff\2\0\1\164"+
+		"\1\147\1\141\1\165\1\160\1\143\1\155\1\145\1\163\1\166\1\164\1\154\1\157"+
+		"\2\145\13\0\2\uffff\1\151\1\155\1\154\1\162\1\145\1\150\1\155\1\162\1"+
+		"\145\1\141\1\145\1\151\1\167\1\60\1\156\1\0\1\uffff\1\157\1\145\1\154"+
+		"\1\156\2\60\1\141\1\60\1\162\1\164\2\143\1\163\1\uffff\1\163\1\0\2\156"+
+		"\1\171\1\163\2\uffff\1\162\1\uffff\1\60\1\145\1\164\2\60\1\11\1\0\1\163"+
+		"\1\164\3\60\1\uffff\1\60\1\145\3\uffff\1\0\1\11\1\60\4\uffff\1\144\2\uffff"+
+		"\1\60\1\uffff";
+	static final String DFA22_maxS =
+		"\1\176\2\uffff\1\162\1\76\1\75\1\56\1\145\1\uffff\1\50\1\143\5\uffff\1"+
+		"\72\1\uffff\1\74\2\uffff\1\141\1\162\1\145\1\165\1\162\3\uffff\1\57\1"+
+		"\uffff\5\uffff\1\160\2\uffff\1\141\1\156\6\uffff\1\164\2\uffff\1\157\4"+
+		"\uffff\1\164\1\141\1\170\1\162\1\157\1\142\1\162\1\145\1\153\2\uffff\2"+
+		"\uffff\1\164\1\147\1\141\1\165\1\160\1\143\1\155\1\145\1\163\1\166\1\164"+
+		"\1\154\1\157\2\145\13\uffff\2\uffff\1\151\1\155\1\154\1\162\1\145\1\150"+
+		"\1\155\1\162\1\145\1\141\1\145\1\151\1\167\1\172\1\156\1\uffff\1\uffff"+
+		"\1\157\1\145\1\154\1\156\2\172\1\141\1\172\1\162\1\164\2\143\1\163\1\uffff"+
+		"\1\163\1\uffff\2\156\1\171\1\163\2\uffff\1\162\1\uffff\1\172\1\145\1\164"+
+		"\2\172\1\173\1\uffff\1\163\1\164\3\172\1\uffff\1\172\1\145\3\uffff\1\uffff"+
+		"\1\173\1\172\4\uffff\1\144\2\uffff\1\172\1\uffff";
+	static final String DFA22_acceptS =
+		"\1\uffff\1\1\1\2\5\uffff\1\10\2\uffff\1\14\1\15\1\16\1\17\1\21\1\uffff"+
+		"\1\25\1\uffff\1\30\1\31\5\uffff\1\44\1\45\1\46\2\uffff\1\53\1\55\1\56"+
+		"\1\57\1\60\1\uffff\1\61\1\64\2\uffff\1\27\1\4\1\5\1\20\1\6\1\22\1\uffff"+
+		"\1\13\1\11\1\uffff\1\24\1\23\1\54\1\26\11\uffff\1\47\1\50\34\uffff\1\51"+
+		"\1\52\20\uffff\1\51\15\uffff\1\43\6\uffff\1\12\1\32\1\uffff\1\35\14\uffff"+
+		"\1\36\2\uffff\1\41\1\42\1\63\3\uffff\1\33\1\7\1\34\1\37\1\uffff\1\62\1"+
+		"\3\1\uffff\1\40";
+	static final String DFA22_specialS =
+		"\36\uffff\1\13\43\uffff\1\0\1\16\17\uffff\1\2\1\3\1\4\1\5\1\6\1\7\1\10"+
+		"\1\11\1\12\1\14\1\15\21\uffff\1\17\20\uffff\1\20\16\uffff\1\21\13\uffff"+
+		"\1\1\13\uffff}>";
+	static final String[] DFA22_transitionS = {
+			"\2\46\2\uffff\1\46\22\uffff\1\46\1\2\1\37\1\uffff\1\13\2\uffff\1\36\1"+
+			"\14\1\15\1\16\1\5\1\17\1\10\1\6\1\35\12\40\1\20\1\21\1\22\1\4\1\23\1"+
+			"\24\1\1\32\43\1\41\2\uffff\1\11\2\uffff\2\45\1\25\2\45\1\3\1\26\4\45"+
+			"\1\27\2\45\1\44\1\30\1\45\1\7\1\12\1\31\6\45\1\42\1\32\1\33\1\34",
+			"",
+			"",
+			"\1\50\10\uffff\1\47",
+			"\1\51",
+			"\1\53",
+			"\1\55",
+			"\1\57",
+			"",
+			"\1\60",
+			"\1\62",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"\1\63",
+			"",
+			"\1\65",
+			"",
+			"",
+			"\1\67",
+			"\1\70",
+			"\1\71",
+			"\1\72\20\uffff\1\73\2\uffff\1\74",
+			"\1\75\6\uffff\1\77\2\uffff\1\76",
+			"",
+			"",
+			"",
+			"\1\101\4\uffff\1\100",
+			"\47\103\1\uffff\64\103\1\102\uffa3\103",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"\1\104",
+			"",
+			"",
+			"\1\105",
+			"\1\106",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"",
+			"\1\107",
+			"",
+			"",
+			"\1\110",
+			"",
+			"",
+			"",
+			"",
+			"\1\111",
+			"\1\112",
+			"\1\113",
+			"\1\114",
+			"\1\115\5\uffff\1\116",
+			"\1\117",
+			"\1\120",
+			"\1\121",
+			"\1\122",
+			"",
+			"",
+			"\42\135\1\130\4\135\1\131\26\135\1\133\35\135\1\132\5\135\1\126\3\135"+
+			"\1\127\7\135\1\123\3\135\1\124\1\135\1\125\1\134\uff8a\135",
+			"\47\137\1\136\uffd8\137",
+			"\1\140",
+			"\1\141",
+			"\1\142",
+			"\1\143",
+			"\1\144",
+			"\1\145",
+			"\1\146",
+			"\1\147",
+			"\1\150",
+			"\1\151",
+			"\1\152",
+			"\1\153",
+			"\1\154",
+			"\1\155",
+			"\1\156",
+			"\47\137\1\136\uffd8\137",
+			"\47\137\1\136\uffd8\137",
+			"\47\137\1\136\uffd8\137",
+			"\47\137\1\136\uffd8\137",
+			"\47\137\1\136\uffd8\137",
+			"\47\137\1\136\uffd8\137",
+			"\47\137\1\136\uffd8\137",
+			"\47\137\1\136\uffd8\137",
+			"\47\137\1\136\uffd8\137",
+			"\47\137\1\136\10\137\12\157\7\137\6\157\32\137\6\157\uff99\137",
+			"\47\137\1\136\uffd8\137",
+			"",
+			"",
+			"\1\161",
+			"\1\162",
+			"\1\163",
+			"\1\164",
+			"\1\165",
+			"\1\166",
+			"\1\167",
+			"\1\170",
+			"\1\171",
+			"\1\172",
+			"\1\173",
+			"\1\174",
+			"\1\175",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"\1\177",
+			"\60\137\12\u0080\7\137\6\u0080\32\137\6\u0080\uff99\137",
+			"",
+			"\1\u0081",
+			"\1\u0082",
+			"\1\u0083",
+			"\1\u0084",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"\1\u0087",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"\1\u0089",
+			"\1\u008a",
+			"\1\u008b",
+			"\1\u008c",
+			"\1\u008d",
+			"",
+			"\1\u008e",
+			"\60\137\12\u008f\7\137\6\u008f\32\137\6\u008f\uff99\137",
+			"\1\u0090",
+			"\1\u0091",
+			"\1\u0092",
+			"\1\u0093",
+			"",
+			"",
+			"\1\u0094",
+			"",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"\1\u0096",
+			"\1\u0097",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"\2\u009a\2\uffff\1\u009a\22\uffff\1\u009a\16\uffff\1\u009a\113\uffff"+
+			"\1\u009a",
+			"\60\137\12\u009b\7\137\6\u009b\32\137\6\u009b\uff99\137",
+			"\1\u009c",
+			"\1\u009d",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"\1\u00a2",
+			"",
+			"",
+			"",
+			"\47\137\1\136\uffd8\137",
+			"\2\u00a3\2\uffff\1\u00a3\22\uffff\1\u00a3\16\uffff\1\u00a3\113\uffff"+
+			"\1\u00a3",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			"",
+			"",
+			"",
+			"",
+			"\1\u00a5",
+			"",
+			"",
+			"\12\45\7\uffff\32\45\4\uffff\1\45\1\uffff\32\45",
+			""
+	};
+
+	static final short[] DFA22_eot = DFA.unpackEncodedString(DFA22_eotS);
+	static final short[] DFA22_eof = DFA.unpackEncodedString(DFA22_eofS);
+	static final char[] DFA22_min = DFA.unpackEncodedStringToUnsignedChars(DFA22_minS);
+	static final char[] DFA22_max = DFA.unpackEncodedStringToUnsignedChars(DFA22_maxS);
+	static final short[] DFA22_accept = DFA.unpackEncodedString(DFA22_acceptS);
+	static final short[] DFA22_special = DFA.unpackEncodedString(DFA22_specialS);
+	static final short[][] DFA22_transition;
+
+	static {
+		int numStates = DFA22_transitionS.length;
+		DFA22_transition = new short[numStates][];
+		for (int i=0; i<numStates; i++) {
+			DFA22_transition[i] = DFA.unpackEncodedString(DFA22_transitionS[i]);
+		}
+	}
+
+	protected class DFA22 extends DFA {
+
+		public DFA22(BaseRecognizer recognizer) {
+			this.recognizer = recognizer;
+			this.decisionNumber = 22;
+			this.eot = DFA22_eot;
+			this.eof = DFA22_eof;
+			this.min = DFA22_min;
+			this.max = DFA22_max;
+			this.accept = DFA22_accept;
+			this.special = DFA22_special;
+			this.transition = DFA22_transition;
+		}
+		@Override
+		public String getDescription() {
+			return "1:1: Tokens : ( AT | BANG | FRAGMENT | LABEL_ASSIGN | LIST_LABEL_ASSIGN | RANGE | RET | REWRITE | ROOT | SCOPE | TREE_BEGIN | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | T__81 | T__82 | T__83 | T__84 | T__85 | T__86 | T__87 | T__88 | T__89 | T__90 | T__91 | T__92 | T__93 | SL_COMMENT | ML_COMMENT | CHAR_LITERAL | STRING_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | RULE_REF | OPTIONS | TOKENS | WS );";
+		}
+		@Override
+		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
+			IntStream input = _input;
+			int _s = s;
+			switch ( s ) {
+					case 0 : 
+						int LA22_66 = input.LA(1);
+						s = -1;
+						if ( (LA22_66=='n') ) {s = 83;}
+						else if ( (LA22_66=='r') ) {s = 84;}
+						else if ( (LA22_66=='t') ) {s = 85;}
+						else if ( (LA22_66=='b') ) {s = 86;}
+						else if ( (LA22_66=='f') ) {s = 87;}
+						else if ( (LA22_66=='\"') ) {s = 88;}
+						else if ( (LA22_66=='\'') ) {s = 89;}
+						else if ( (LA22_66=='\\') ) {s = 90;}
+						else if ( (LA22_66=='>') ) {s = 91;}
+						else if ( (LA22_66=='u') ) {s = 92;}
+						else if ( ((LA22_66 >= '\u0000' && LA22_66 <= '!')||(LA22_66 >= '#' && LA22_66 <= '&')||(LA22_66 >= '(' && LA22_66 <= '=')||(LA22_66 >= '?' && LA22_66 <= '[')||(LA22_66 >= ']' && LA22_66 <= 'a')||(LA22_66 >= 'c' && LA22_66 <= 'e')||(LA22_66 >= 'g' && LA22_66 <= 'm')||(LA22_66 >= 'o' && LA22_66 <= 'q')||LA22_66=='s'||(LA22_66 >= 'v' && LA22_66 <= '\uFFFF')) ) {s = 93;}
+						if ( s>=0 ) return s;
+						break;
+					case 1 : 
+						int LA22_155 = input.LA(1);
+						s = -1;
+						if ( (LA22_155=='\'') ) {s = 94;}
+						else if ( ((LA22_155 >= '\u0000' && LA22_155 <= '&')||(LA22_155 >= '(' && LA22_155 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 2 : 
+						int LA22_83 = input.LA(1);
+						s = -1;
+						if ( (LA22_83=='\'') ) {s = 94;}
+						else if ( ((LA22_83 >= '\u0000' && LA22_83 <= '&')||(LA22_83 >= '(' && LA22_83 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 3 : 
+						int LA22_84 = input.LA(1);
+						s = -1;
+						if ( (LA22_84=='\'') ) {s = 94;}
+						else if ( ((LA22_84 >= '\u0000' && LA22_84 <= '&')||(LA22_84 >= '(' && LA22_84 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 4 : 
+						int LA22_85 = input.LA(1);
+						s = -1;
+						if ( (LA22_85=='\'') ) {s = 94;}
+						else if ( ((LA22_85 >= '\u0000' && LA22_85 <= '&')||(LA22_85 >= '(' && LA22_85 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 5 : 
+						int LA22_86 = input.LA(1);
+						s = -1;
+						if ( (LA22_86=='\'') ) {s = 94;}
+						else if ( ((LA22_86 >= '\u0000' && LA22_86 <= '&')||(LA22_86 >= '(' && LA22_86 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 6 : 
+						int LA22_87 = input.LA(1);
+						s = -1;
+						if ( (LA22_87=='\'') ) {s = 94;}
+						else if ( ((LA22_87 >= '\u0000' && LA22_87 <= '&')||(LA22_87 >= '(' && LA22_87 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 7 : 
+						int LA22_88 = input.LA(1);
+						s = -1;
+						if ( (LA22_88=='\'') ) {s = 94;}
+						else if ( ((LA22_88 >= '\u0000' && LA22_88 <= '&')||(LA22_88 >= '(' && LA22_88 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 8 : 
+						int LA22_89 = input.LA(1);
+						s = -1;
+						if ( (LA22_89=='\'') ) {s = 94;}
+						else if ( ((LA22_89 >= '\u0000' && LA22_89 <= '&')||(LA22_89 >= '(' && LA22_89 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 9 : 
+						int LA22_90 = input.LA(1);
+						s = -1;
+						if ( (LA22_90=='\'') ) {s = 94;}
+						else if ( ((LA22_90 >= '\u0000' && LA22_90 <= '&')||(LA22_90 >= '(' && LA22_90 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 10 : 
+						int LA22_91 = input.LA(1);
+						s = -1;
+						if ( (LA22_91=='\'') ) {s = 94;}
+						else if ( ((LA22_91 >= '\u0000' && LA22_91 <= '&')||(LA22_91 >= '(' && LA22_91 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 11 : 
+						int LA22_30 = input.LA(1);
+						s = -1;
+						if ( (LA22_30=='\\') ) {s = 66;}
+						else if ( ((LA22_30 >= '\u0000' && LA22_30 <= '&')||(LA22_30 >= '(' && LA22_30 <= '[')||(LA22_30 >= ']' && LA22_30 <= '\uFFFF')) ) {s = 67;}
+						if ( s>=0 ) return s;
+						break;
+					case 12 : 
+						int LA22_92 = input.LA(1);
+						s = -1;
+						if ( ((LA22_92 >= '0' && LA22_92 <= '9')||(LA22_92 >= 'A' && LA22_92 <= 'F')||(LA22_92 >= 'a' && LA22_92 <= 'f')) ) {s = 111;}
+						else if ( (LA22_92=='\'') ) {s = 94;}
+						else if ( ((LA22_92 >= '\u0000' && LA22_92 <= '&')||(LA22_92 >= '(' && LA22_92 <= '/')||(LA22_92 >= ':' && LA22_92 <= '@')||(LA22_92 >= 'G' && LA22_92 <= '`')||(LA22_92 >= 'g' && LA22_92 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 13 : 
+						int LA22_93 = input.LA(1);
+						s = -1;
+						if ( (LA22_93=='\'') ) {s = 94;}
+						else if ( ((LA22_93 >= '\u0000' && LA22_93 <= '&')||(LA22_93 >= '(' && LA22_93 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 14 : 
+						int LA22_67 = input.LA(1);
+						s = -1;
+						if ( (LA22_67=='\'') ) {s = 94;}
+						else if ( ((LA22_67 >= '\u0000' && LA22_67 <= '&')||(LA22_67 >= '(' && LA22_67 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 15 : 
+						int LA22_111 = input.LA(1);
+						s = -1;
+						if ( ((LA22_111 >= '0' && LA22_111 <= '9')||(LA22_111 >= 'A' && LA22_111 <= 'F')||(LA22_111 >= 'a' && LA22_111 <= 'f')) ) {s = 128;}
+						else if ( ((LA22_111 >= '\u0000' && LA22_111 <= '/')||(LA22_111 >= ':' && LA22_111 <= '@')||(LA22_111 >= 'G' && LA22_111 <= '`')||(LA22_111 >= 'g' && LA22_111 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 16 : 
+						int LA22_128 = input.LA(1);
+						s = -1;
+						if ( ((LA22_128 >= '0' && LA22_128 <= '9')||(LA22_128 >= 'A' && LA22_128 <= 'F')||(LA22_128 >= 'a' && LA22_128 <= 'f')) ) {s = 143;}
+						else if ( ((LA22_128 >= '\u0000' && LA22_128 <= '/')||(LA22_128 >= ':' && LA22_128 <= '@')||(LA22_128 >= 'G' && LA22_128 <= '`')||(LA22_128 >= 'g' && LA22_128 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+					case 17 : 
+						int LA22_143 = input.LA(1);
+						s = -1;
+						if ( ((LA22_143 >= '0' && LA22_143 <= '9')||(LA22_143 >= 'A' && LA22_143 <= 'F')||(LA22_143 >= 'a' && LA22_143 <= 'f')) ) {s = 155;}
+						else if ( ((LA22_143 >= '\u0000' && LA22_143 <= '/')||(LA22_143 >= ':' && LA22_143 <= '@')||(LA22_143 >= 'G' && LA22_143 <= '`')||(LA22_143 >= 'g' && LA22_143 <= '\uFFFF')) ) {s = 95;}
+						if ( s>=0 ) return s;
+						break;
+			}
+			NoViableAltException nvae =
+				new NoViableAltException(getDescription(), 22, _s, input);
+			error(nvae);
+			throw nvae;
+		}
+	}
+
+}
--- tool/src/main/java/org/antlr/grammar/v3/ANTLRv3Parser.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/ANTLRv3Parser.java	2019-04-04 17:22:25.476181469 +0200
@@ -0,0 +1,9768 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/ANTLRv3.g 2019-04-04 15:18:50
+
+    package org.antlr.grammar.v3;
+
+
+import org.antlr.runtime.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+
+import org.antlr.runtime.tree.*;
+
+
+/** ANTLR v3 grammar written in ANTLR v3 with AST construction */
+@SuppressWarnings("all")
+public class ANTLRv3Parser extends Parser {
+	public static final String[] tokenNames = new String[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", 
+		"ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "ARG", "ARGLIST", "ARG_ACTION", 
+		"AT", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CHAR_LITERAL", "CHAR_RANGE", 
+		"CLOSURE", "COMBINED_GRAMMAR", "DOC_COMMENT", "DOUBLE_ANGLE_STRING_LITERAL", 
+		"DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", 
+		"FRAGMENT", "GATED_SEMPRED", "ID", "INT", "LABEL", "LABEL_ASSIGN", "LEXER", 
+		"LEXER_GRAMMAR", "LIST_LABEL_ASSIGN", "LITERAL_CHAR", "ML_COMMENT", "NESTED_ACTION", 
+		"NESTED_ARG_ACTION", "OPTIONAL", "OPTIONS", "PARSER", "PARSER_GRAMMAR", 
+		"POSITIVE_CLOSURE", "RANGE", "RET", "REWRITE", "ROOT", "RULE", "RULE_REF", 
+		"SCOPE", "SEMPRED", "SL_COMMENT", "SRC", "STRING_LITERAL", "SYNPRED", 
+		"SYN_SEMPRED", "TEMPLATE", "TOKENS", "TOKEN_REF", "TREE_BEGIN", "TREE_GRAMMAR", 
+		"WS", "WS_LOOP", "XDIGIT", "'$'", "'('", "')'", "'*'", "'+'", "','", "'.'", 
+		"':'", "'::'", "';'", "'<'", "'=>'", "'>'", "'?'", "'catch'", "'finally'", 
+		"'grammar'", "'lexer'", "'parser'", "'private'", "'protected'", "'public'", 
+		"'throws'", "'tree'", "'|'", "'}'", "'~'"
+	};
+	public static final int EOF=-1;
+	public static final int T__67=67;
+	public static final int T__68=68;
+	public static final int T__69=69;
+	public static final int T__70=70;
+	public static final int T__71=71;
+	public static final int T__72=72;
+	public static final int T__73=73;
+	public static final int T__74=74;
+	public static final int T__75=75;
+	public static final int T__76=76;
+	public static final int T__77=77;
+	public static final int T__78=78;
+	public static final int T__79=79;
+	public static final int T__80=80;
+	public static final int T__81=81;
+	public static final int T__82=82;
+	public static final int T__83=83;
+	public static final int T__84=84;
+	public static final int T__85=85;
+	public static final int T__86=86;
+	public static final int T__87=87;
+	public static final int T__88=88;
+	public static final int T__89=89;
+	public static final int T__90=90;
+	public static final int T__91=91;
+	public static final int T__92=92;
+	public static final int T__93=93;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int ARG=9;
+	public static final int ARGLIST=10;
+	public static final int ARG_ACTION=11;
+	public static final int AT=12;
+	public static final int BACKTRACK_SEMPRED=13;
+	public static final int BANG=14;
+	public static final int BLOCK=15;
+	public static final int CHAR_LITERAL=16;
+	public static final int CHAR_RANGE=17;
+	public static final int CLOSURE=18;
+	public static final int COMBINED_GRAMMAR=19;
+	public static final int DOC_COMMENT=20;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=21;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=22;
+	public static final int EOA=23;
+	public static final int EOB=24;
+	public static final int EOR=25;
+	public static final int EPSILON=26;
+	public static final int ESC=27;
+	public static final int FRAGMENT=28;
+	public static final int GATED_SEMPRED=29;
+	public static final int ID=30;
+	public static final int INT=31;
+	public static final int LABEL=32;
+	public static final int LABEL_ASSIGN=33;
+	public static final int LEXER=34;
+	public static final int LEXER_GRAMMAR=35;
+	public static final int LIST_LABEL_ASSIGN=36;
+	public static final int LITERAL_CHAR=37;
+	public static final int ML_COMMENT=38;
+	public static final int NESTED_ACTION=39;
+	public static final int NESTED_ARG_ACTION=40;
+	public static final int OPTIONAL=41;
+	public static final int OPTIONS=42;
+	public static final int PARSER=43;
+	public static final int PARSER_GRAMMAR=44;
+	public static final int POSITIVE_CLOSURE=45;
+	public static final int RANGE=46;
+	public static final int RET=47;
+	public static final int REWRITE=48;
+	public static final int ROOT=49;
+	public static final int RULE=50;
+	public static final int RULE_REF=51;
+	public static final int SCOPE=52;
+	public static final int SEMPRED=53;
+	public static final int SL_COMMENT=54;
+	public static final int SRC=55;
+	public static final int STRING_LITERAL=56;
+	public static final int SYNPRED=57;
+	public static final int SYN_SEMPRED=58;
+	public static final int TEMPLATE=59;
+	public static final int TOKENS=60;
+	public static final int TOKEN_REF=61;
+	public static final int TREE_BEGIN=62;
+	public static final int TREE_GRAMMAR=63;
+	public static final int WS=64;
+	public static final int WS_LOOP=65;
+	public static final int XDIGIT=66;
+
+	// delegates
+	public Parser[] getDelegates() {
+		return new Parser[] {};
+	}
+
+	// delegators
+
+
+	public ANTLRv3Parser(TokenStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public ANTLRv3Parser(TokenStream input, RecognizerSharedState state) {
+		super(input, state);
+	}
+
+	protected TreeAdaptor adaptor = new CommonTreeAdaptor();
+
+	public void setTreeAdaptor(TreeAdaptor adaptor) {
+		this.adaptor = adaptor;
+	}
+	public TreeAdaptor getTreeAdaptor() {
+		return adaptor;
+	}
+	@Override public String[] getTokenNames() { return ANTLRv3Parser.tokenNames; }
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/ANTLRv3.g"; }
+
+
+		int gtype;
+
+
+	public static class grammarDef_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "grammarDef"
+	// org/antlr/grammar/v3/ANTLRv3.g:93:1: grammarDef : ( DOC_COMMENT )? ( 'lexer' | 'parser' | 'tree' |) g= 'grammar' id ';' ( optionsSpec )? ( tokensSpec )? ( attrScope )* ( action )* ( rule )+ EOF -> ^( id ( DOC_COMMENT )? ( optionsSpec )? ( tokensSpec )? ( attrScope )* ( action )* ( rule )+ ) ;
+	public final ANTLRv3Parser.grammarDef_return grammarDef() throws RecognitionException {
+		ANTLRv3Parser.grammarDef_return retval = new ANTLRv3Parser.grammarDef_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token g=null;
+		Token DOC_COMMENT1=null;
+		Token string_literal2=null;
+		Token string_literal3=null;
+		Token string_literal4=null;
+		Token char_literal6=null;
+		Token EOF12=null;
+		ParserRuleReturnScope id5 =null;
+		ParserRuleReturnScope optionsSpec7 =null;
+		ParserRuleReturnScope tokensSpec8 =null;
+		ParserRuleReturnScope attrScope9 =null;
+		ParserRuleReturnScope action10 =null;
+		ParserRuleReturnScope rule11 =null;
+
+		CommonTree g_tree=null;
+		CommonTree DOC_COMMENT1_tree=null;
+		CommonTree string_literal2_tree=null;
+		CommonTree string_literal3_tree=null;
+		CommonTree string_literal4_tree=null;
+		CommonTree char_literal6_tree=null;
+		CommonTree EOF12_tree=null;
+		RewriteRuleTokenStream stream_90=new RewriteRuleTokenStream(adaptor,"token 90");
+		RewriteRuleTokenStream stream_83=new RewriteRuleTokenStream(adaptor,"token 83");
+		RewriteRuleTokenStream stream_DOC_COMMENT=new RewriteRuleTokenStream(adaptor,"token DOC_COMMENT");
+		RewriteRuleTokenStream stream_84=new RewriteRuleTokenStream(adaptor,"token 84");
+		RewriteRuleTokenStream stream_85=new RewriteRuleTokenStream(adaptor,"token 85");
+		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
+		RewriteRuleTokenStream stream_76=new RewriteRuleTokenStream(adaptor,"token 76");
+		RewriteRuleSubtreeStream stream_attrScope=new RewriteRuleSubtreeStream(adaptor,"rule attrScope");
+		RewriteRuleSubtreeStream stream_tokensSpec=new RewriteRuleSubtreeStream(adaptor,"rule tokensSpec");
+		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
+		RewriteRuleSubtreeStream stream_action=new RewriteRuleSubtreeStream(adaptor,"rule action");
+		RewriteRuleSubtreeStream stream_rule=new RewriteRuleSubtreeStream(adaptor,"rule rule");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:94:5: ( ( DOC_COMMENT )? ( 'lexer' | 'parser' | 'tree' |) g= 'grammar' id ';' ( optionsSpec )? ( tokensSpec )? ( attrScope )* ( action )* ( rule )+ EOF -> ^( id ( DOC_COMMENT )? ( optionsSpec )? ( tokensSpec )? ( attrScope )* ( action )* ( rule )+ ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:94:9: ( DOC_COMMENT )? ( 'lexer' | 'parser' | 'tree' |) g= 'grammar' id ';' ( optionsSpec )? ( tokensSpec )? ( attrScope )* ( action )* ( rule )+ EOF
+			{
+			// org/antlr/grammar/v3/ANTLRv3.g:94:9: ( DOC_COMMENT )?
+			int alt1=2;
+			int LA1_0 = input.LA(1);
+			if ( (LA1_0==DOC_COMMENT) ) {
+				alt1=1;
+			}
+			switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:94:9: DOC_COMMENT
+					{
+					DOC_COMMENT1=(Token)match(input,DOC_COMMENT,FOLLOW_DOC_COMMENT_in_grammarDef373); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_DOC_COMMENT.add(DOC_COMMENT1);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:95:6: ( 'lexer' | 'parser' | 'tree' |)
+			int alt2=4;
+			switch ( input.LA(1) ) {
+			case 84:
+				{
+				alt2=1;
+				}
+				break;
+			case 85:
+				{
+				alt2=2;
+				}
+				break;
+			case 90:
+				{
+				alt2=3;
+				}
+				break;
+			case 83:
+				{
+				alt2=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 2, 0, input);
+				throw nvae;
+			}
+			switch (alt2) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:95:8: 'lexer'
+					{
+					string_literal2=(Token)match(input,84,FOLLOW_84_in_grammarDef383); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_84.add(string_literal2);
+
+					if ( state.backtracking==0 ) {gtype=LEXER_GRAMMAR;}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:96:10: 'parser'
+					{
+					string_literal3=(Token)match(input,85,FOLLOW_85_in_grammarDef401); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_85.add(string_literal3);
+
+					if ( state.backtracking==0 ) {gtype=PARSER_GRAMMAR;}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:97:10: 'tree'
+					{
+					string_literal4=(Token)match(input,90,FOLLOW_90_in_grammarDef417); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_90.add(string_literal4);
+
+					if ( state.backtracking==0 ) {gtype=TREE_GRAMMAR;}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:98:14: 
+					{
+					if ( state.backtracking==0 ) {gtype=COMBINED_GRAMMAR;}
+					}
+					break;
+
+			}
+
+			g=(Token)match(input,83,FOLLOW_83_in_grammarDef458); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_83.add(g);
+
+			pushFollow(FOLLOW_id_in_grammarDef460);
+			id5=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id5.getTree());
+			char_literal6=(Token)match(input,76,FOLLOW_76_in_grammarDef462); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_76.add(char_literal6);
+
+			// org/antlr/grammar/v3/ANTLRv3.g:100:25: ( optionsSpec )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+			if ( (LA3_0==OPTIONS) ) {
+				alt3=1;
+			}
+			switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:100:25: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_grammarDef464);
+					optionsSpec7=optionsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_optionsSpec.add(optionsSpec7.getTree());
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:100:38: ( tokensSpec )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+			if ( (LA4_0==TOKENS) ) {
+				alt4=1;
+			}
+			switch (alt4) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:100:38: tokensSpec
+					{
+					pushFollow(FOLLOW_tokensSpec_in_grammarDef467);
+					tokensSpec8=tokensSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_tokensSpec.add(tokensSpec8.getTree());
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:100:50: ( attrScope )*
+			loop5:
+			while (true) {
+				int alt5=2;
+				int LA5_0 = input.LA(1);
+				if ( (LA5_0==SCOPE) ) {
+					alt5=1;
+				}
+
+				switch (alt5) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:100:50: attrScope
+					{
+					pushFollow(FOLLOW_attrScope_in_grammarDef470);
+					attrScope9=attrScope();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_attrScope.add(attrScope9.getTree());
+					}
+					break;
+
+				default :
+					break loop5;
+				}
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:100:61: ( action )*
+			loop6:
+			while (true) {
+				int alt6=2;
+				int LA6_0 = input.LA(1);
+				if ( (LA6_0==AT) ) {
+					alt6=1;
+				}
+
+				switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:100:61: action
+					{
+					pushFollow(FOLLOW_action_in_grammarDef473);
+					action10=action();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_action.add(action10.getTree());
+					}
+					break;
+
+				default :
+					break loop6;
+				}
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:101:6: ( rule )+
+			int cnt7=0;
+			loop7:
+			while (true) {
+				int alt7=2;
+				int LA7_0 = input.LA(1);
+				if ( (LA7_0==DOC_COMMENT||LA7_0==FRAGMENT||LA7_0==RULE_REF||LA7_0==TOKEN_REF||(LA7_0 >= 86 && LA7_0 <= 88)) ) {
+					alt7=1;
+				}
+
+				switch (alt7) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:101:6: rule
+					{
+					pushFollow(FOLLOW_rule_in_grammarDef481);
+					rule11=rule();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rule.add(rule11.getTree());
+					}
+					break;
+
+				default :
+					if ( cnt7 >= 1 ) break loop7;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(7, input);
+					throw eee;
+				}
+				cnt7++;
+			}
+
+			EOF12=(Token)match(input,EOF,FOLLOW_EOF_in_grammarDef489); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_EOF.add(EOF12);
+
+			// AST REWRITE
+			// elements: action, optionsSpec, DOC_COMMENT, attrScope, rule, tokensSpec, id
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 103:6: -> ^( id ( DOC_COMMENT )? ( optionsSpec )? ( tokensSpec )? ( attrScope )* ( action )* ( rule )+ )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:103:9: ^( id ( DOC_COMMENT )? ( optionsSpec )? ( tokensSpec )? ( attrScope )* ( action )* ( rule )+ )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(adaptor.create(gtype,g), root_1);
+				adaptor.addChild(root_1, stream_id.nextTree());
+				// org/antlr/grammar/v3/ANTLRv3.g:104:12: ( DOC_COMMENT )?
+				if ( stream_DOC_COMMENT.hasNext() ) {
+					adaptor.addChild(root_1, stream_DOC_COMMENT.nextNode());
+				}
+				stream_DOC_COMMENT.reset();
+
+				// org/antlr/grammar/v3/ANTLRv3.g:104:25: ( optionsSpec )?
+				if ( stream_optionsSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_optionsSpec.nextTree());
+				}
+				stream_optionsSpec.reset();
+
+				// org/antlr/grammar/v3/ANTLRv3.g:104:38: ( tokensSpec )?
+				if ( stream_tokensSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_tokensSpec.nextTree());
+				}
+				stream_tokensSpec.reset();
+
+				// org/antlr/grammar/v3/ANTLRv3.g:104:50: ( attrScope )*
+				while ( stream_attrScope.hasNext() ) {
+					adaptor.addChild(root_1, stream_attrScope.nextTree());
+				}
+				stream_attrScope.reset();
+
+				// org/antlr/grammar/v3/ANTLRv3.g:104:61: ( action )*
+				while ( stream_action.hasNext() ) {
+					adaptor.addChild(root_1, stream_action.nextTree());
+				}
+				stream_action.reset();
+
+				if ( !(stream_rule.hasNext()) ) {
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_rule.hasNext() ) {
+					adaptor.addChild(root_1, stream_rule.nextTree());
+				}
+				stream_rule.reset();
+
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "grammarDef"
+
+
+	public static class tokensSpec_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "tokensSpec"
+	// org/antlr/grammar/v3/ANTLRv3.g:108:1: tokensSpec : TOKENS ( tokenSpec )+ '}' -> ^( TOKENS ( tokenSpec )+ ) ;
+	public final ANTLRv3Parser.tokensSpec_return tokensSpec() throws RecognitionException {
+		ANTLRv3Parser.tokensSpec_return retval = new ANTLRv3Parser.tokensSpec_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token TOKENS13=null;
+		Token char_literal15=null;
+		ParserRuleReturnScope tokenSpec14 =null;
+
+		CommonTree TOKENS13_tree=null;
+		CommonTree char_literal15_tree=null;
+		RewriteRuleTokenStream stream_92=new RewriteRuleTokenStream(adaptor,"token 92");
+		RewriteRuleTokenStream stream_TOKENS=new RewriteRuleTokenStream(adaptor,"token TOKENS");
+		RewriteRuleSubtreeStream stream_tokenSpec=new RewriteRuleSubtreeStream(adaptor,"rule tokenSpec");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:109:2: ( TOKENS ( tokenSpec )+ '}' -> ^( TOKENS ( tokenSpec )+ ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:109:4: TOKENS ( tokenSpec )+ '}'
+			{
+			TOKENS13=(Token)match(input,TOKENS,FOLLOW_TOKENS_in_tokensSpec550); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_TOKENS.add(TOKENS13);
+
+			// org/antlr/grammar/v3/ANTLRv3.g:109:11: ( tokenSpec )+
+			int cnt8=0;
+			loop8:
+			while (true) {
+				int alt8=2;
+				int LA8_0 = input.LA(1);
+				if ( (LA8_0==TOKEN_REF) ) {
+					alt8=1;
+				}
+
+				switch (alt8) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:109:11: tokenSpec
+					{
+					pushFollow(FOLLOW_tokenSpec_in_tokensSpec552);
+					tokenSpec14=tokenSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_tokenSpec.add(tokenSpec14.getTree());
+					}
+					break;
+
+				default :
+					if ( cnt8 >= 1 ) break loop8;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(8, input);
+					throw eee;
+				}
+				cnt8++;
+			}
+
+			char_literal15=(Token)match(input,92,FOLLOW_92_in_tokensSpec555); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_92.add(char_literal15);
+
+			// AST REWRITE
+			// elements: TOKENS, tokenSpec
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 109:26: -> ^( TOKENS ( tokenSpec )+ )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:109:29: ^( TOKENS ( tokenSpec )+ )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_TOKENS.nextNode(), root_1);
+				if ( !(stream_tokenSpec.hasNext()) ) {
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_tokenSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_tokenSpec.nextTree());
+				}
+				stream_tokenSpec.reset();
+
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "tokensSpec"
+
+
+	public static class tokenSpec_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "tokenSpec"
+	// org/antlr/grammar/v3/ANTLRv3.g:112:1: tokenSpec : TOKEN_REF ( '=' (lit= STRING_LITERAL |lit= CHAR_LITERAL ) -> ^( '=' TOKEN_REF $lit) | -> TOKEN_REF ) ';' ;
+	public final ANTLRv3Parser.tokenSpec_return tokenSpec() throws RecognitionException {
+		ANTLRv3Parser.tokenSpec_return retval = new ANTLRv3Parser.tokenSpec_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token lit=null;
+		Token TOKEN_REF16=null;
+		Token char_literal17=null;
+		Token char_literal18=null;
+
+		CommonTree lit_tree=null;
+		CommonTree TOKEN_REF16_tree=null;
+		CommonTree char_literal17_tree=null;
+		CommonTree char_literal18_tree=null;
+		RewriteRuleTokenStream stream_LABEL_ASSIGN=new RewriteRuleTokenStream(adaptor,"token LABEL_ASSIGN");
+		RewriteRuleTokenStream stream_TOKEN_REF=new RewriteRuleTokenStream(adaptor,"token TOKEN_REF");
+		RewriteRuleTokenStream stream_STRING_LITERAL=new RewriteRuleTokenStream(adaptor,"token STRING_LITERAL");
+		RewriteRuleTokenStream stream_CHAR_LITERAL=new RewriteRuleTokenStream(adaptor,"token CHAR_LITERAL");
+		RewriteRuleTokenStream stream_76=new RewriteRuleTokenStream(adaptor,"token 76");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:113:2: ( TOKEN_REF ( '=' (lit= STRING_LITERAL |lit= CHAR_LITERAL ) -> ^( '=' TOKEN_REF $lit) | -> TOKEN_REF ) ';' )
+			// org/antlr/grammar/v3/ANTLRv3.g:113:4: TOKEN_REF ( '=' (lit= STRING_LITERAL |lit= CHAR_LITERAL ) -> ^( '=' TOKEN_REF $lit) | -> TOKEN_REF ) ';'
+			{
+			TOKEN_REF16=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec575); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_TOKEN_REF.add(TOKEN_REF16);
+
+			// org/antlr/grammar/v3/ANTLRv3.g:114:3: ( '=' (lit= STRING_LITERAL |lit= CHAR_LITERAL ) -> ^( '=' TOKEN_REF $lit) | -> TOKEN_REF )
+			int alt10=2;
+			int LA10_0 = input.LA(1);
+			if ( (LA10_0==LABEL_ASSIGN) ) {
+				alt10=1;
+			}
+			else if ( (LA10_0==76) ) {
+				alt10=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 10, 0, input);
+				throw nvae;
+			}
+
+			switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:114:5: '=' (lit= STRING_LITERAL |lit= CHAR_LITERAL )
+					{
+					char_literal17=(Token)match(input,LABEL_ASSIGN,FOLLOW_LABEL_ASSIGN_in_tokenSpec581); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_LABEL_ASSIGN.add(char_literal17);
+
+					// org/antlr/grammar/v3/ANTLRv3.g:114:9: (lit= STRING_LITERAL |lit= CHAR_LITERAL )
+					int alt9=2;
+					int LA9_0 = input.LA(1);
+					if ( (LA9_0==STRING_LITERAL) ) {
+						alt9=1;
+					}
+					else if ( (LA9_0==CHAR_LITERAL) ) {
+						alt9=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 9, 0, input);
+						throw nvae;
+					}
+
+					switch (alt9) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:114:10: lit= STRING_LITERAL
+							{
+							lit=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_tokenSpec586); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_STRING_LITERAL.add(lit);
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:114:29: lit= CHAR_LITERAL
+							{
+							lit=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_tokenSpec590); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_CHAR_LITERAL.add(lit);
+
+							}
+							break;
+
+					}
+
+					// AST REWRITE
+					// elements: lit, LABEL_ASSIGN, TOKEN_REF
+					// token labels: lit
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleTokenStream stream_lit=new RewriteRuleTokenStream(adaptor,"token lit",lit);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 114:47: -> ^( '=' TOKEN_REF $lit)
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:114:50: ^( '=' TOKEN_REF $lit)
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_LABEL_ASSIGN.nextNode(), root_1);
+						adaptor.addChild(root_1, stream_TOKEN_REF.nextNode());
+						adaptor.addChild(root_1, stream_lit.nextNode());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:115:16: 
+					{
+					// AST REWRITE
+					// elements: TOKEN_REF
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 115:16: -> TOKEN_REF
+					{
+						adaptor.addChild(root_0, stream_TOKEN_REF.nextNode());
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+
+			char_literal18=(Token)match(input,76,FOLLOW_76_in_tokenSpec629); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_76.add(char_literal18);
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "tokenSpec"
+
+
+	public static class attrScope_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "attrScope"
+	// org/antlr/grammar/v3/ANTLRv3.g:120:1: attrScope : 'scope' id ACTION -> ^( 'scope' id ACTION ) ;
+	public final ANTLRv3Parser.attrScope_return attrScope() throws RecognitionException {
+		ANTLRv3Parser.attrScope_return retval = new ANTLRv3Parser.attrScope_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token string_literal19=null;
+		Token ACTION21=null;
+		ParserRuleReturnScope id20 =null;
+
+		CommonTree string_literal19_tree=null;
+		CommonTree ACTION21_tree=null;
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_SCOPE=new RewriteRuleTokenStream(adaptor,"token SCOPE");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:121:2: ( 'scope' id ACTION -> ^( 'scope' id ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:121:4: 'scope' id ACTION
+			{
+			string_literal19=(Token)match(input,SCOPE,FOLLOW_SCOPE_in_attrScope640); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_SCOPE.add(string_literal19);
+
+			pushFollow(FOLLOW_id_in_attrScope642);
+			id20=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id20.getTree());
+			ACTION21=(Token)match(input,ACTION,FOLLOW_ACTION_in_attrScope644); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ACTION.add(ACTION21);
+
+			// AST REWRITE
+			// elements: SCOPE, ACTION, id
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 121:22: -> ^( 'scope' id ACTION )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:121:25: ^( 'scope' id ACTION )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_SCOPE.nextNode(), root_1);
+				adaptor.addChild(root_1, stream_id.nextTree());
+				adaptor.addChild(root_1, stream_ACTION.nextNode());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "attrScope"
+
+
+	public static class action_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "action"
+	// org/antlr/grammar/v3/ANTLRv3.g:125:1: action : '@' ( actionScopeName '::' )? id ACTION -> ^( '@' ( actionScopeName )? id ACTION ) ;
+	public final ANTLRv3Parser.action_return action() throws RecognitionException {
+		ANTLRv3Parser.action_return retval = new ANTLRv3Parser.action_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal22=null;
+		Token string_literal24=null;
+		Token ACTION26=null;
+		ParserRuleReturnScope actionScopeName23 =null;
+		ParserRuleReturnScope id25 =null;
+
+		CommonTree char_literal22_tree=null;
+		CommonTree string_literal24_tree=null;
+		CommonTree ACTION26_tree=null;
+		RewriteRuleTokenStream stream_AT=new RewriteRuleTokenStream(adaptor,"token AT");
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_75=new RewriteRuleTokenStream(adaptor,"token 75");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_actionScopeName=new RewriteRuleSubtreeStream(adaptor,"rule actionScopeName");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:126:2: ( '@' ( actionScopeName '::' )? id ACTION -> ^( '@' ( actionScopeName )? id ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:126:4: '@' ( actionScopeName '::' )? id ACTION
+			{
+			char_literal22=(Token)match(input,AT,FOLLOW_AT_in_action667); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_AT.add(char_literal22);
+
+			// org/antlr/grammar/v3/ANTLRv3.g:126:8: ( actionScopeName '::' )?
+			int alt11=2;
+			switch ( input.LA(1) ) {
+				case TOKEN_REF:
+					{
+					int LA11_1 = input.LA(2);
+					if ( (LA11_1==75) ) {
+						alt11=1;
+					}
+					}
+					break;
+				case RULE_REF:
+					{
+					int LA11_2 = input.LA(2);
+					if ( (LA11_2==75) ) {
+						alt11=1;
+					}
+					}
+					break;
+				case 84:
+				case 85:
+					{
+					alt11=1;
+					}
+					break;
+			}
+			switch (alt11) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:126:9: actionScopeName '::'
+					{
+					pushFollow(FOLLOW_actionScopeName_in_action670);
+					actionScopeName23=actionScopeName();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_actionScopeName.add(actionScopeName23.getTree());
+					string_literal24=(Token)match(input,75,FOLLOW_75_in_action672); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_75.add(string_literal24);
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_id_in_action676);
+			id25=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id25.getTree());
+			ACTION26=(Token)match(input,ACTION,FOLLOW_ACTION_in_action678); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ACTION.add(ACTION26);
+
+			// AST REWRITE
+			// elements: id, ACTION, AT, actionScopeName
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 126:42: -> ^( '@' ( actionScopeName )? id ACTION )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:126:45: ^( '@' ( actionScopeName )? id ACTION )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_AT.nextNode(), root_1);
+				// org/antlr/grammar/v3/ANTLRv3.g:126:51: ( actionScopeName )?
+				if ( stream_actionScopeName.hasNext() ) {
+					adaptor.addChild(root_1, stream_actionScopeName.nextTree());
+				}
+				stream_actionScopeName.reset();
+
+				adaptor.addChild(root_1, stream_id.nextTree());
+				adaptor.addChild(root_1, stream_ACTION.nextNode());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "action"
+
+
+	public static class actionScopeName_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "actionScopeName"
+	// org/antlr/grammar/v3/ANTLRv3.g:132:1: actionScopeName : ( id |l= 'lexer' -> ID[$l] |p= 'parser' -> ID[$p] );
+	public final ANTLRv3Parser.actionScopeName_return actionScopeName() throws RecognitionException {
+		ANTLRv3Parser.actionScopeName_return retval = new ANTLRv3Parser.actionScopeName_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token l=null;
+		Token p=null;
+		ParserRuleReturnScope id27 =null;
+
+		CommonTree l_tree=null;
+		CommonTree p_tree=null;
+		RewriteRuleTokenStream stream_84=new RewriteRuleTokenStream(adaptor,"token 84");
+		RewriteRuleTokenStream stream_85=new RewriteRuleTokenStream(adaptor,"token 85");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:133:2: ( id |l= 'lexer' -> ID[$l] |p= 'parser' -> ID[$p] )
+			int alt12=3;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+			case TOKEN_REF:
+				{
+				alt12=1;
+				}
+				break;
+			case 84:
+				{
+				alt12=2;
+				}
+				break;
+			case 85:
+				{
+				alt12=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 12, 0, input);
+				throw nvae;
+			}
+			switch (alt12) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:133:4: id
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_id_in_actionScopeName704);
+					id27=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, id27.getTree());
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:134:4: l= 'lexer'
+					{
+					l=(Token)match(input,84,FOLLOW_84_in_actionScopeName711); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_84.add(l);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 134:14: -> ID[$l]
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(ID, l));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:135:9: p= 'parser'
+					{
+					p=(Token)match(input,85,FOLLOW_85_in_actionScopeName728); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_85.add(p);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 135:20: -> ID[$p]
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(ID, p));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "actionScopeName"
+
+
+	public static class optionsSpec_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "optionsSpec"
+	// org/antlr/grammar/v3/ANTLRv3.g:138:1: optionsSpec : OPTIONS ( option ';' )+ '}' -> ^( OPTIONS ( option )+ ) ;
+	public final ANTLRv3Parser.optionsSpec_return optionsSpec() throws RecognitionException {
+		ANTLRv3Parser.optionsSpec_return retval = new ANTLRv3Parser.optionsSpec_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token OPTIONS28=null;
+		Token char_literal30=null;
+		Token char_literal31=null;
+		ParserRuleReturnScope option29 =null;
+
+		CommonTree OPTIONS28_tree=null;
+		CommonTree char_literal30_tree=null;
+		CommonTree char_literal31_tree=null;
+		RewriteRuleTokenStream stream_92=new RewriteRuleTokenStream(adaptor,"token 92");
+		RewriteRuleTokenStream stream_OPTIONS=new RewriteRuleTokenStream(adaptor,"token OPTIONS");
+		RewriteRuleTokenStream stream_76=new RewriteRuleTokenStream(adaptor,"token 76");
+		RewriteRuleSubtreeStream stream_option=new RewriteRuleSubtreeStream(adaptor,"rule option");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:139:2: ( OPTIONS ( option ';' )+ '}' -> ^( OPTIONS ( option )+ ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:139:4: OPTIONS ( option ';' )+ '}'
+			{
+			OPTIONS28=(Token)match(input,OPTIONS,FOLLOW_OPTIONS_in_optionsSpec744); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_OPTIONS.add(OPTIONS28);
+
+			// org/antlr/grammar/v3/ANTLRv3.g:139:12: ( option ';' )+
+			int cnt13=0;
+			loop13:
+			while (true) {
+				int alt13=2;
+				int LA13_0 = input.LA(1);
+				if ( (LA13_0==RULE_REF||LA13_0==TOKEN_REF) ) {
+					alt13=1;
+				}
+
+				switch (alt13) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:139:13: option ';'
+					{
+					pushFollow(FOLLOW_option_in_optionsSpec747);
+					option29=option();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_option.add(option29.getTree());
+					char_literal30=(Token)match(input,76,FOLLOW_76_in_optionsSpec749); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_76.add(char_literal30);
+
+					}
+					break;
+
+				default :
+					if ( cnt13 >= 1 ) break loop13;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(13, input);
+					throw eee;
+				}
+				cnt13++;
+			}
+
+			char_literal31=(Token)match(input,92,FOLLOW_92_in_optionsSpec753); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_92.add(char_literal31);
+
+			// AST REWRITE
+			// elements: option, OPTIONS
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 139:30: -> ^( OPTIONS ( option )+ )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:139:33: ^( OPTIONS ( option )+ )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_OPTIONS.nextNode(), root_1);
+				if ( !(stream_option.hasNext()) ) {
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_option.hasNext() ) {
+					adaptor.addChild(root_1, stream_option.nextTree());
+				}
+				stream_option.reset();
+
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "optionsSpec"
+
+
+	public static class option_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "option"
+	// org/antlr/grammar/v3/ANTLRv3.g:142:1: option : id '=' optionValue -> ^( '=' id optionValue ) ;
+	public final ANTLRv3Parser.option_return option() throws RecognitionException {
+		ANTLRv3Parser.option_return retval = new ANTLRv3Parser.option_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal33=null;
+		ParserRuleReturnScope id32 =null;
+		ParserRuleReturnScope optionValue34 =null;
+
+		CommonTree char_literal33_tree=null;
+		RewriteRuleTokenStream stream_LABEL_ASSIGN=new RewriteRuleTokenStream(adaptor,"token LABEL_ASSIGN");
+		RewriteRuleSubtreeStream stream_optionValue=new RewriteRuleSubtreeStream(adaptor,"rule optionValue");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:143:5: ( id '=' optionValue -> ^( '=' id optionValue ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:143:9: id '=' optionValue
+			{
+			pushFollow(FOLLOW_id_in_option778);
+			id32=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id32.getTree());
+			char_literal33=(Token)match(input,LABEL_ASSIGN,FOLLOW_LABEL_ASSIGN_in_option780); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_LABEL_ASSIGN.add(char_literal33);
+
+			pushFollow(FOLLOW_optionValue_in_option782);
+			optionValue34=optionValue();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_optionValue.add(optionValue34.getTree());
+			// AST REWRITE
+			// elements: id, LABEL_ASSIGN, optionValue
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 143:28: -> ^( '=' id optionValue )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:143:31: ^( '=' id optionValue )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_LABEL_ASSIGN.nextNode(), root_1);
+				adaptor.addChild(root_1, stream_id.nextTree());
+				adaptor.addChild(root_1, stream_optionValue.nextTree());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "option"
+
+
+	public static class optionValue_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "optionValue"
+	// org/antlr/grammar/v3/ANTLRv3.g:146:1: optionValue : ( qid | STRING_LITERAL | CHAR_LITERAL | INT |s= '*' -> STRING_LITERAL[$s] );
+	public final ANTLRv3Parser.optionValue_return optionValue() throws RecognitionException {
+		ANTLRv3Parser.optionValue_return retval = new ANTLRv3Parser.optionValue_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token s=null;
+		Token STRING_LITERAL36=null;
+		Token CHAR_LITERAL37=null;
+		Token INT38=null;
+		ParserRuleReturnScope qid35 =null;
+
+		CommonTree s_tree=null;
+		CommonTree STRING_LITERAL36_tree=null;
+		CommonTree CHAR_LITERAL37_tree=null;
+		CommonTree INT38_tree=null;
+		RewriteRuleTokenStream stream_70=new RewriteRuleTokenStream(adaptor,"token 70");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:147:5: ( qid | STRING_LITERAL | CHAR_LITERAL | INT |s= '*' -> STRING_LITERAL[$s] )
+			int alt14=5;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+			case TOKEN_REF:
+				{
+				alt14=1;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt14=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt14=3;
+				}
+				break;
+			case INT:
+				{
+				alt14=4;
+				}
+				break;
+			case 70:
+				{
+				alt14=5;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 14, 0, input);
+				throw nvae;
+			}
+			switch (alt14) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:147:9: qid
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_qid_in_optionValue811);
+					qid35=qid();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, qid35.getTree());
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:148:9: STRING_LITERAL
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					STRING_LITERAL36=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_optionValue821); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					STRING_LITERAL36_tree = (CommonTree)adaptor.create(STRING_LITERAL36);
+					adaptor.addChild(root_0, STRING_LITERAL36_tree);
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:149:9: CHAR_LITERAL
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					CHAR_LITERAL37=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_optionValue831); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					CHAR_LITERAL37_tree = (CommonTree)adaptor.create(CHAR_LITERAL37);
+					adaptor.addChild(root_0, CHAR_LITERAL37_tree);
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:150:9: INT
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					INT38=(Token)match(input,INT,FOLLOW_INT_in_optionValue841); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					INT38_tree = (CommonTree)adaptor.create(INT38);
+					adaptor.addChild(root_0, INT38_tree);
+					}
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRv3.g:151:7: s= '*'
+					{
+					s=(Token)match(input,70,FOLLOW_70_in_optionValue851); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_70.add(s);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 151:13: -> STRING_LITERAL[$s]
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(STRING_LITERAL, s));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "optionValue"
+
+
+	protected static class rule_scope {
+		String name;
+	}
+	protected Stack<rule_scope> rule_stack = new Stack<rule_scope>();
+
+	public static class rule_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rule"
+	// org/antlr/grammar/v3/ANTLRv3.g:154:1: rule : ( DOC_COMMENT )? (modifier= ( 'protected' | 'public' | 'private' | 'fragment' ) )? id ( '!' )? (arg= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* ':' altList ';' ( exceptionGroup )? -> ^( RULE id ( ^( ARG[$arg] $arg) )? ( ^( 'returns' $rt) )? ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* altList ( exceptionGroup )? EOR[\"EOR\"] ) ;
+	public final ANTLRv3Parser.rule_return rule() throws RecognitionException {
+		rule_stack.push(new rule_scope());
+		ANTLRv3Parser.rule_return retval = new ANTLRv3Parser.rule_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token modifier=null;
+		Token arg=null;
+		Token rt=null;
+		Token DOC_COMMENT39=null;
+		Token char_literal41=null;
+		Token string_literal42=null;
+		Token char_literal47=null;
+		Token char_literal49=null;
+		ParserRuleReturnScope id40 =null;
+		ParserRuleReturnScope throwsSpec43 =null;
+		ParserRuleReturnScope optionsSpec44 =null;
+		ParserRuleReturnScope ruleScopeSpec45 =null;
+		ParserRuleReturnScope ruleAction46 =null;
+		ParserRuleReturnScope altList48 =null;
+		ParserRuleReturnScope exceptionGroup50 =null;
+
+		CommonTree modifier_tree=null;
+		CommonTree arg_tree=null;
+		CommonTree rt_tree=null;
+		CommonTree DOC_COMMENT39_tree=null;
+		CommonTree char_literal41_tree=null;
+		CommonTree string_literal42_tree=null;
+		CommonTree char_literal47_tree=null;
+		CommonTree char_literal49_tree=null;
+		RewriteRuleTokenStream stream_88=new RewriteRuleTokenStream(adaptor,"token 88");
+		RewriteRuleTokenStream stream_RET=new RewriteRuleTokenStream(adaptor,"token RET");
+		RewriteRuleTokenStream stream_BANG=new RewriteRuleTokenStream(adaptor,"token BANG");
+		RewriteRuleTokenStream stream_ARG_ACTION=new RewriteRuleTokenStream(adaptor,"token ARG_ACTION");
+		RewriteRuleTokenStream stream_FRAGMENT=new RewriteRuleTokenStream(adaptor,"token FRAGMENT");
+		RewriteRuleTokenStream stream_DOC_COMMENT=new RewriteRuleTokenStream(adaptor,"token DOC_COMMENT");
+		RewriteRuleTokenStream stream_74=new RewriteRuleTokenStream(adaptor,"token 74");
+		RewriteRuleTokenStream stream_86=new RewriteRuleTokenStream(adaptor,"token 86");
+		RewriteRuleTokenStream stream_76=new RewriteRuleTokenStream(adaptor,"token 76");
+		RewriteRuleTokenStream stream_87=new RewriteRuleTokenStream(adaptor,"token 87");
+		RewriteRuleSubtreeStream stream_ruleAction=new RewriteRuleSubtreeStream(adaptor,"rule ruleAction");
+		RewriteRuleSubtreeStream stream_throwsSpec=new RewriteRuleSubtreeStream(adaptor,"rule throwsSpec");
+		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
+		RewriteRuleSubtreeStream stream_altList=new RewriteRuleSubtreeStream(adaptor,"rule altList");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_ruleScopeSpec=new RewriteRuleSubtreeStream(adaptor,"rule ruleScopeSpec");
+		RewriteRuleSubtreeStream stream_exceptionGroup=new RewriteRuleSubtreeStream(adaptor,"rule exceptionGroup");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:158:2: ( ( DOC_COMMENT )? (modifier= ( 'protected' | 'public' | 'private' | 'fragment' ) )? id ( '!' )? (arg= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* ':' altList ';' ( exceptionGroup )? -> ^( RULE id ( ^( ARG[$arg] $arg) )? ( ^( 'returns' $rt) )? ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* altList ( exceptionGroup )? EOR[\"EOR\"] ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:158:4: ( DOC_COMMENT )? (modifier= ( 'protected' | 'public' | 'private' | 'fragment' ) )? id ( '!' )? (arg= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* ':' altList ';' ( exceptionGroup )?
+			{
+			// org/antlr/grammar/v3/ANTLRv3.g:158:4: ( DOC_COMMENT )?
+			int alt15=2;
+			int LA15_0 = input.LA(1);
+			if ( (LA15_0==DOC_COMMENT) ) {
+				alt15=1;
+			}
+			switch (alt15) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:158:4: DOC_COMMENT
+					{
+					DOC_COMMENT39=(Token)match(input,DOC_COMMENT,FOLLOW_DOC_COMMENT_in_rule876); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_DOC_COMMENT.add(DOC_COMMENT39);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:159:3: (modifier= ( 'protected' | 'public' | 'private' | 'fragment' ) )?
+			int alt17=2;
+			int LA17_0 = input.LA(1);
+			if ( (LA17_0==FRAGMENT||(LA17_0 >= 86 && LA17_0 <= 88)) ) {
+				alt17=1;
+			}
+			switch (alt17) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:159:5: modifier= ( 'protected' | 'public' | 'private' | 'fragment' )
+					{
+					// org/antlr/grammar/v3/ANTLRv3.g:159:14: ( 'protected' | 'public' | 'private' | 'fragment' )
+					int alt16=4;
+					switch ( input.LA(1) ) {
+					case 87:
+						{
+						alt16=1;
+						}
+						break;
+					case 88:
+						{
+						alt16=2;
+						}
+						break;
+					case 86:
+						{
+						alt16=3;
+						}
+						break;
+					case FRAGMENT:
+						{
+						alt16=4;
+						}
+						break;
+					default:
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 16, 0, input);
+						throw nvae;
+					}
+					switch (alt16) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:159:15: 'protected'
+							{
+							modifier=(Token)match(input,87,FOLLOW_87_in_rule886); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_87.add(modifier);
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:159:27: 'public'
+							{
+							modifier=(Token)match(input,88,FOLLOW_88_in_rule888); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_88.add(modifier);
+
+							}
+							break;
+						case 3 :
+							// org/antlr/grammar/v3/ANTLRv3.g:159:36: 'private'
+							{
+							modifier=(Token)match(input,86,FOLLOW_86_in_rule890); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_86.add(modifier);
+
+							}
+							break;
+						case 4 :
+							// org/antlr/grammar/v3/ANTLRv3.g:159:46: 'fragment'
+							{
+							modifier=(Token)match(input,FRAGMENT,FOLLOW_FRAGMENT_in_rule892); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_FRAGMENT.add(modifier);
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_id_in_rule900);
+			id40=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id40.getTree());
+			if ( state.backtracking==0 ) {rule_stack.peek().name = (id40!=null?input.toString(id40.start,id40.stop):null);}
+			// org/antlr/grammar/v3/ANTLRv3.g:161:3: ( '!' )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+			if ( (LA18_0==BANG) ) {
+				alt18=1;
+			}
+			switch (alt18) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:161:3: '!'
+					{
+					char_literal41=(Token)match(input,BANG,FOLLOW_BANG_in_rule906); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_BANG.add(char_literal41);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:162:3: (arg= ARG_ACTION )?
+			int alt19=2;
+			int LA19_0 = input.LA(1);
+			if ( (LA19_0==ARG_ACTION) ) {
+				alt19=1;
+			}
+			switch (alt19) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:162:5: arg= ARG_ACTION
+					{
+					arg=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule915); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ARG_ACTION.add(arg);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:163:3: ( 'returns' rt= ARG_ACTION )?
+			int alt20=2;
+			int LA20_0 = input.LA(1);
+			if ( (LA20_0==RET) ) {
+				alt20=1;
+			}
+			switch (alt20) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:163:5: 'returns' rt= ARG_ACTION
+					{
+					string_literal42=(Token)match(input,RET,FOLLOW_RET_in_rule924); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_RET.add(string_literal42);
+
+					rt=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule928); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ARG_ACTION.add(rt);
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:164:3: ( throwsSpec )?
+			int alt21=2;
+			int LA21_0 = input.LA(1);
+			if ( (LA21_0==89) ) {
+				alt21=1;
+			}
+			switch (alt21) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:164:3: throwsSpec
+					{
+					pushFollow(FOLLOW_throwsSpec_in_rule936);
+					throwsSpec43=throwsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_throwsSpec.add(throwsSpec43.getTree());
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:164:15: ( optionsSpec )?
+			int alt22=2;
+			int LA22_0 = input.LA(1);
+			if ( (LA22_0==OPTIONS) ) {
+				alt22=1;
+			}
+			switch (alt22) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:164:15: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_rule939);
+					optionsSpec44=optionsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_optionsSpec.add(optionsSpec44.getTree());
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:164:28: ( ruleScopeSpec )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+			if ( (LA23_0==SCOPE) ) {
+				alt23=1;
+			}
+			switch (alt23) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:164:28: ruleScopeSpec
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_rule942);
+					ruleScopeSpec45=ruleScopeSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_ruleScopeSpec.add(ruleScopeSpec45.getTree());
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:164:43: ( ruleAction )*
+			loop24:
+			while (true) {
+				int alt24=2;
+				int LA24_0 = input.LA(1);
+				if ( (LA24_0==AT) ) {
+					alt24=1;
+				}
+
+				switch (alt24) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:164:43: ruleAction
+					{
+					pushFollow(FOLLOW_ruleAction_in_rule945);
+					ruleAction46=ruleAction();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_ruleAction.add(ruleAction46.getTree());
+					}
+					break;
+
+				default :
+					break loop24;
+				}
+			}
+
+			char_literal47=(Token)match(input,74,FOLLOW_74_in_rule950); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_74.add(char_literal47);
+
+			pushFollow(FOLLOW_altList_in_rule952);
+			altList48=altList();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_altList.add(altList48.getTree());
+			char_literal49=(Token)match(input,76,FOLLOW_76_in_rule954); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_76.add(char_literal49);
+
+			// org/antlr/grammar/v3/ANTLRv3.g:166:3: ( exceptionGroup )?
+			int alt25=2;
+			int LA25_0 = input.LA(1);
+			if ( ((LA25_0 >= 81 && LA25_0 <= 82)) ) {
+				alt25=1;
+			}
+			switch (alt25) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:166:3: exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_rule958);
+					exceptionGroup50=exceptionGroup();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_exceptionGroup.add(exceptionGroup50.getTree());
+					}
+					break;
+
+			}
+
+			// AST REWRITE
+			// elements: ruleScopeSpec, RET, arg, id, ruleAction, throwsSpec, optionsSpec, altList, rt, exceptionGroup
+			// token labels: rt, arg
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleTokenStream stream_rt=new RewriteRuleTokenStream(adaptor,"token rt",rt);
+			RewriteRuleTokenStream stream_arg=new RewriteRuleTokenStream(adaptor,"token arg",arg);
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 167:6: -> ^( RULE id ( ^( ARG[$arg] $arg) )? ( ^( 'returns' $rt) )? ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* altList ( exceptionGroup )? EOR[\"EOR\"] )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:167:9: ^( RULE id ( ^( ARG[$arg] $arg) )? ( ^( 'returns' $rt) )? ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* altList ( exceptionGroup )? EOR[\"EOR\"] )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(RULE, "RULE"), root_1);
+				adaptor.addChild(root_1, stream_id.nextTree());
+				adaptor.addChild(root_1, modifier!=null?adaptor.create(modifier):null);
+				// org/antlr/grammar/v3/ANTLRv3.g:167:67: ( ^( ARG[$arg] $arg) )?
+				if ( stream_arg.hasNext() ) {
+					// org/antlr/grammar/v3/ANTLRv3.g:167:67: ^( ARG[$arg] $arg)
+					{
+					CommonTree root_2 = (CommonTree)adaptor.nil();
+					root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ARG, arg), root_2);
+					adaptor.addChild(root_2, stream_arg.nextNode());
+					adaptor.addChild(root_1, root_2);
+					}
+
+				}
+				stream_arg.reset();
+
+				// org/antlr/grammar/v3/ANTLRv3.g:167:86: ( ^( 'returns' $rt) )?
+				if ( stream_RET.hasNext()||stream_rt.hasNext() ) {
+					// org/antlr/grammar/v3/ANTLRv3.g:167:86: ^( 'returns' $rt)
+					{
+					CommonTree root_2 = (CommonTree)adaptor.nil();
+					root_2 = (CommonTree)adaptor.becomeRoot(stream_RET.nextNode(), root_2);
+					adaptor.addChild(root_2, stream_rt.nextNode());
+					adaptor.addChild(root_1, root_2);
+					}
+
+				}
+				stream_RET.reset();
+				stream_rt.reset();
+
+				// org/antlr/grammar/v3/ANTLRv3.g:168:9: ( throwsSpec )?
+				if ( stream_throwsSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_throwsSpec.nextTree());
+				}
+				stream_throwsSpec.reset();
+
+				// org/antlr/grammar/v3/ANTLRv3.g:168:21: ( optionsSpec )?
+				if ( stream_optionsSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_optionsSpec.nextTree());
+				}
+				stream_optionsSpec.reset();
+
+				// org/antlr/grammar/v3/ANTLRv3.g:168:34: ( ruleScopeSpec )?
+				if ( stream_ruleScopeSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_ruleScopeSpec.nextTree());
+				}
+				stream_ruleScopeSpec.reset();
+
+				// org/antlr/grammar/v3/ANTLRv3.g:168:49: ( ruleAction )*
+				while ( stream_ruleAction.hasNext() ) {
+					adaptor.addChild(root_1, stream_ruleAction.nextTree());
+				}
+				stream_ruleAction.reset();
+
+				adaptor.addChild(root_1, stream_altList.nextTree());
+				// org/antlr/grammar/v3/ANTLRv3.g:170:9: ( exceptionGroup )?
+				if ( stream_exceptionGroup.hasNext() ) {
+					adaptor.addChild(root_1, stream_exceptionGroup.nextTree());
+				}
+				stream_exceptionGroup.reset();
+
+				adaptor.addChild(root_1, (CommonTree)adaptor.create(EOR, "EOR"));
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+			rule_stack.pop();
+		}
+		return retval;
+	}
+	// $ANTLR end "rule"
+
+
+	public static class ruleAction_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ruleAction"
+	// org/antlr/grammar/v3/ANTLRv3.g:176:1: ruleAction : '@' id ACTION -> ^( '@' id ACTION ) ;
+	public final ANTLRv3Parser.ruleAction_return ruleAction() throws RecognitionException {
+		ANTLRv3Parser.ruleAction_return retval = new ANTLRv3Parser.ruleAction_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal51=null;
+		Token ACTION53=null;
+		ParserRuleReturnScope id52 =null;
+
+		CommonTree char_literal51_tree=null;
+		CommonTree ACTION53_tree=null;
+		RewriteRuleTokenStream stream_AT=new RewriteRuleTokenStream(adaptor,"token AT");
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:177:2: ( '@' id ACTION -> ^( '@' id ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:177:4: '@' id ACTION
+			{
+			char_literal51=(Token)match(input,AT,FOLLOW_AT_in_ruleAction1064); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_AT.add(char_literal51);
+
+			pushFollow(FOLLOW_id_in_ruleAction1066);
+			id52=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id52.getTree());
+			ACTION53=(Token)match(input,ACTION,FOLLOW_ACTION_in_ruleAction1068); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ACTION.add(ACTION53);
+
+			// AST REWRITE
+			// elements: ACTION, AT, id
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 177:18: -> ^( '@' id ACTION )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:177:21: ^( '@' id ACTION )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_AT.nextNode(), root_1);
+				adaptor.addChild(root_1, stream_id.nextTree());
+				adaptor.addChild(root_1, stream_ACTION.nextNode());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleAction"
+
+
+	public static class throwsSpec_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "throwsSpec"
+	// org/antlr/grammar/v3/ANTLRv3.g:180:1: throwsSpec : 'throws' id ( ',' id )* -> ^( 'throws' ( id )+ ) ;
+	public final ANTLRv3Parser.throwsSpec_return throwsSpec() throws RecognitionException {
+		ANTLRv3Parser.throwsSpec_return retval = new ANTLRv3Parser.throwsSpec_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token string_literal54=null;
+		Token char_literal56=null;
+		ParserRuleReturnScope id55 =null;
+		ParserRuleReturnScope id57 =null;
+
+		CommonTree string_literal54_tree=null;
+		CommonTree char_literal56_tree=null;
+		RewriteRuleTokenStream stream_89=new RewriteRuleTokenStream(adaptor,"token 89");
+		RewriteRuleTokenStream stream_72=new RewriteRuleTokenStream(adaptor,"token 72");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:181:2: ( 'throws' id ( ',' id )* -> ^( 'throws' ( id )+ ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:181:4: 'throws' id ( ',' id )*
+			{
+			string_literal54=(Token)match(input,89,FOLLOW_89_in_throwsSpec1089); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_89.add(string_literal54);
+
+			pushFollow(FOLLOW_id_in_throwsSpec1091);
+			id55=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id55.getTree());
+			// org/antlr/grammar/v3/ANTLRv3.g:181:16: ( ',' id )*
+			loop26:
+			while (true) {
+				int alt26=2;
+				int LA26_0 = input.LA(1);
+				if ( (LA26_0==72) ) {
+					alt26=1;
+				}
+
+				switch (alt26) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:181:18: ',' id
+					{
+					char_literal56=(Token)match(input,72,FOLLOW_72_in_throwsSpec1095); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_72.add(char_literal56);
+
+					pushFollow(FOLLOW_id_in_throwsSpec1097);
+					id57=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_id.add(id57.getTree());
+					}
+					break;
+
+				default :
+					break loop26;
+				}
+			}
+
+			// AST REWRITE
+			// elements: 89, id
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 181:28: -> ^( 'throws' ( id )+ )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:181:31: ^( 'throws' ( id )+ )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_89.nextNode(), root_1);
+				if ( !(stream_id.hasNext()) ) {
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_id.hasNext() ) {
+					adaptor.addChild(root_1, stream_id.nextTree());
+				}
+				stream_id.reset();
+
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "throwsSpec"
+
+
+	public static class ruleScopeSpec_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// org/antlr/grammar/v3/ANTLRv3.g:184:1: ruleScopeSpec : ( 'scope' ACTION -> ^( 'scope' ACTION ) | 'scope' id ( ',' id )* ';' -> ^( 'scope' ( id )+ ) | 'scope' ACTION 'scope' id ( ',' id )* ';' -> ^( 'scope' ACTION ( id )+ ) );
+	public final ANTLRv3Parser.ruleScopeSpec_return ruleScopeSpec() throws RecognitionException {
+		ANTLRv3Parser.ruleScopeSpec_return retval = new ANTLRv3Parser.ruleScopeSpec_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token string_literal58=null;
+		Token ACTION59=null;
+		Token string_literal60=null;
+		Token char_literal62=null;
+		Token char_literal64=null;
+		Token string_literal65=null;
+		Token ACTION66=null;
+		Token string_literal67=null;
+		Token char_literal69=null;
+		Token char_literal71=null;
+		ParserRuleReturnScope id61 =null;
+		ParserRuleReturnScope id63 =null;
+		ParserRuleReturnScope id68 =null;
+		ParserRuleReturnScope id70 =null;
+
+		CommonTree string_literal58_tree=null;
+		CommonTree ACTION59_tree=null;
+		CommonTree string_literal60_tree=null;
+		CommonTree char_literal62_tree=null;
+		CommonTree char_literal64_tree=null;
+		CommonTree string_literal65_tree=null;
+		CommonTree ACTION66_tree=null;
+		CommonTree string_literal67_tree=null;
+		CommonTree char_literal69_tree=null;
+		CommonTree char_literal71_tree=null;
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_SCOPE=new RewriteRuleTokenStream(adaptor,"token SCOPE");
+		RewriteRuleTokenStream stream_72=new RewriteRuleTokenStream(adaptor,"token 72");
+		RewriteRuleTokenStream stream_76=new RewriteRuleTokenStream(adaptor,"token 76");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:185:2: ( 'scope' ACTION -> ^( 'scope' ACTION ) | 'scope' id ( ',' id )* ';' -> ^( 'scope' ( id )+ ) | 'scope' ACTION 'scope' id ( ',' id )* ';' -> ^( 'scope' ACTION ( id )+ ) )
+			int alt29=3;
+			int LA29_0 = input.LA(1);
+			if ( (LA29_0==SCOPE) ) {
+				int LA29_1 = input.LA(2);
+				if ( (LA29_1==ACTION) ) {
+					int LA29_2 = input.LA(3);
+					if ( (LA29_2==SCOPE) ) {
+						alt29=3;
+					}
+					else if ( (LA29_2==AT||LA29_2==74) ) {
+						alt29=1;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 29, 2, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+				else if ( (LA29_1==RULE_REF||LA29_1==TOKEN_REF) ) {
+					alt29=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 29, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 29, 0, input);
+				throw nvae;
+			}
+
+			switch (alt29) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:185:4: 'scope' ACTION
+					{
+					string_literal58=(Token)match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec1120); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_SCOPE.add(string_literal58);
+
+					ACTION59=(Token)match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec1122); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ACTION.add(ACTION59);
+
+					// AST REWRITE
+					// elements: SCOPE, ACTION
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 185:19: -> ^( 'scope' ACTION )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:185:22: ^( 'scope' ACTION )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_SCOPE.nextNode(), root_1);
+						adaptor.addChild(root_1, stream_ACTION.nextNode());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:186:4: 'scope' id ( ',' id )* ';'
+					{
+					string_literal60=(Token)match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec1135); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_SCOPE.add(string_literal60);
+
+					pushFollow(FOLLOW_id_in_ruleScopeSpec1137);
+					id61=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_id.add(id61.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:186:15: ( ',' id )*
+					loop27:
+					while (true) {
+						int alt27=2;
+						int LA27_0 = input.LA(1);
+						if ( (LA27_0==72) ) {
+							alt27=1;
+						}
+
+						switch (alt27) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:186:16: ',' id
+							{
+							char_literal62=(Token)match(input,72,FOLLOW_72_in_ruleScopeSpec1140); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_72.add(char_literal62);
+
+							pushFollow(FOLLOW_id_in_ruleScopeSpec1142);
+							id63=id();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_id.add(id63.getTree());
+							}
+							break;
+
+						default :
+							break loop27;
+						}
+					}
+
+					char_literal64=(Token)match(input,76,FOLLOW_76_in_ruleScopeSpec1146); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_76.add(char_literal64);
+
+					// AST REWRITE
+					// elements: SCOPE, id
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 186:29: -> ^( 'scope' ( id )+ )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:186:32: ^( 'scope' ( id )+ )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_SCOPE.nextNode(), root_1);
+						if ( !(stream_id.hasNext()) ) {
+							throw new RewriteEarlyExitException();
+						}
+						while ( stream_id.hasNext() ) {
+							adaptor.addChild(root_1, stream_id.nextTree());
+						}
+						stream_id.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:187:4: 'scope' ACTION 'scope' id ( ',' id )* ';'
+					{
+					string_literal65=(Token)match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec1160); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_SCOPE.add(string_literal65);
+
+					ACTION66=(Token)match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec1162); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ACTION.add(ACTION66);
+
+					string_literal67=(Token)match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec1166); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_SCOPE.add(string_literal67);
+
+					pushFollow(FOLLOW_id_in_ruleScopeSpec1168);
+					id68=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_id.add(id68.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:188:14: ( ',' id )*
+					loop28:
+					while (true) {
+						int alt28=2;
+						int LA28_0 = input.LA(1);
+						if ( (LA28_0==72) ) {
+							alt28=1;
+						}
+
+						switch (alt28) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:188:15: ',' id
+							{
+							char_literal69=(Token)match(input,72,FOLLOW_72_in_ruleScopeSpec1171); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_72.add(char_literal69);
+
+							pushFollow(FOLLOW_id_in_ruleScopeSpec1173);
+							id70=id();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_id.add(id70.getTree());
+							}
+							break;
+
+						default :
+							break loop28;
+						}
+					}
+
+					char_literal71=(Token)match(input,76,FOLLOW_76_in_ruleScopeSpec1177); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_76.add(char_literal71);
+
+					// AST REWRITE
+					// elements: id, SCOPE, ACTION
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 189:3: -> ^( 'scope' ACTION ( id )+ )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:189:6: ^( 'scope' ACTION ( id )+ )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_SCOPE.nextNode(), root_1);
+						adaptor.addChild(root_1, stream_ACTION.nextNode());
+						if ( !(stream_id.hasNext()) ) {
+							throw new RewriteEarlyExitException();
+						}
+						while ( stream_id.hasNext() ) {
+							adaptor.addChild(root_1, stream_id.nextTree());
+						}
+						stream_id.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+
+	public static class block_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "block"
+	// org/antlr/grammar/v3/ANTLRv3.g:192:1: block : lp= '(' ( (opts= optionsSpec )? ':' )? altpair ( '|' altpair )* rp= ')' -> ^( BLOCK[$lp,\"BLOCK\"] ( optionsSpec )? ( altpair )+ EOB[$rp,\"EOB\"] ) ;
+	public final ANTLRv3Parser.block_return block() throws RecognitionException {
+		ANTLRv3Parser.block_return retval = new ANTLRv3Parser.block_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token lp=null;
+		Token rp=null;
+		Token char_literal72=null;
+		Token char_literal74=null;
+		ParserRuleReturnScope opts =null;
+		ParserRuleReturnScope altpair73 =null;
+		ParserRuleReturnScope altpair75 =null;
+
+		CommonTree lp_tree=null;
+		CommonTree rp_tree=null;
+		CommonTree char_literal72_tree=null;
+		CommonTree char_literal74_tree=null;
+		RewriteRuleTokenStream stream_68=new RewriteRuleTokenStream(adaptor,"token 68");
+		RewriteRuleTokenStream stream_69=new RewriteRuleTokenStream(adaptor,"token 69");
+		RewriteRuleTokenStream stream_91=new RewriteRuleTokenStream(adaptor,"token 91");
+		RewriteRuleTokenStream stream_74=new RewriteRuleTokenStream(adaptor,"token 74");
+		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
+		RewriteRuleSubtreeStream stream_altpair=new RewriteRuleSubtreeStream(adaptor,"rule altpair");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:193:5: (lp= '(' ( (opts= optionsSpec )? ':' )? altpair ( '|' altpair )* rp= ')' -> ^( BLOCK[$lp,\"BLOCK\"] ( optionsSpec )? ( altpair )+ EOB[$rp,\"EOB\"] ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:193:9: lp= '(' ( (opts= optionsSpec )? ':' )? altpair ( '|' altpair )* rp= ')'
+			{
+			lp=(Token)match(input,68,FOLLOW_68_in_block1209); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_68.add(lp);
+
+			// org/antlr/grammar/v3/ANTLRv3.g:194:3: ( (opts= optionsSpec )? ':' )?
+			int alt31=2;
+			int LA31_0 = input.LA(1);
+			if ( (LA31_0==OPTIONS||LA31_0==74) ) {
+				alt31=1;
+			}
+			switch (alt31) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:194:5: (opts= optionsSpec )? ':'
+					{
+					// org/antlr/grammar/v3/ANTLRv3.g:194:5: (opts= optionsSpec )?
+					int alt30=2;
+					int LA30_0 = input.LA(1);
+					if ( (LA30_0==OPTIONS) ) {
+						alt30=1;
+					}
+					switch (alt30) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:194:6: opts= optionsSpec
+							{
+							pushFollow(FOLLOW_optionsSpec_in_block1218);
+							opts=optionsSpec();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_optionsSpec.add(opts.getTree());
+							}
+							break;
+
+					}
+
+					char_literal72=(Token)match(input,74,FOLLOW_74_in_block1222); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_74.add(char_literal72);
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_altpair_in_block1229);
+			altpair73=altpair();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_altpair.add(altpair73.getTree());
+			// org/antlr/grammar/v3/ANTLRv3.g:195:11: ( '|' altpair )*
+			loop32:
+			while (true) {
+				int alt32=2;
+				int LA32_0 = input.LA(1);
+				if ( (LA32_0==91) ) {
+					alt32=1;
+				}
+
+				switch (alt32) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:195:13: '|' altpair
+					{
+					char_literal74=(Token)match(input,91,FOLLOW_91_in_block1233); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_91.add(char_literal74);
+
+					pushFollow(FOLLOW_altpair_in_block1235);
+					altpair75=altpair();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_altpair.add(altpair75.getTree());
+					}
+					break;
+
+				default :
+					break loop32;
+				}
+			}
+
+			rp=(Token)match(input,69,FOLLOW_69_in_block1250); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_69.add(rp);
+
+			// AST REWRITE
+			// elements: optionsSpec, altpair
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 197:9: -> ^( BLOCK[$lp,\"BLOCK\"] ( optionsSpec )? ( altpair )+ EOB[$rp,\"EOB\"] )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:197:12: ^( BLOCK[$lp,\"BLOCK\"] ( optionsSpec )? ( altpair )+ EOB[$rp,\"EOB\"] )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(BLOCK, lp, "BLOCK"), root_1);
+				// org/antlr/grammar/v3/ANTLRv3.g:197:34: ( optionsSpec )?
+				if ( stream_optionsSpec.hasNext() ) {
+					adaptor.addChild(root_1, stream_optionsSpec.nextTree());
+				}
+				stream_optionsSpec.reset();
+
+				if ( !(stream_altpair.hasNext()) ) {
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_altpair.hasNext() ) {
+					adaptor.addChild(root_1, stream_altpair.nextTree());
+				}
+				stream_altpair.reset();
+
+				adaptor.addChild(root_1, (CommonTree)adaptor.create(EOB, rp, "EOB"));
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+	public static class altpair_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "altpair"
+	// org/antlr/grammar/v3/ANTLRv3.g:200:1: altpair : alternative rewrite ;
+	public final ANTLRv3Parser.altpair_return altpair() throws RecognitionException {
+		ANTLRv3Parser.altpair_return retval = new ANTLRv3Parser.altpair_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		ParserRuleReturnScope alternative76 =null;
+		ParserRuleReturnScope rewrite77 =null;
+
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:200:9: ( alternative rewrite )
+			// org/antlr/grammar/v3/ANTLRv3.g:200:11: alternative rewrite
+			{
+			root_0 = (CommonTree)adaptor.nil();
+
+
+			pushFollow(FOLLOW_alternative_in_altpair1289);
+			alternative76=alternative();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, alternative76.getTree());
+
+			pushFollow(FOLLOW_rewrite_in_altpair1291);
+			rewrite77=rewrite();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite77.getTree());
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "altpair"
+
+
+	public static class altList_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "altList"
+	// org/antlr/grammar/v3/ANTLRv3.g:202:1: altList : altpair ( '|' altpair )* -> ^( ( altpair )+ EOB[\"EOB\"] ) ;
+	public final ANTLRv3Parser.altList_return altList() throws RecognitionException {
+		ANTLRv3Parser.altList_return retval = new ANTLRv3Parser.altList_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal79=null;
+		ParserRuleReturnScope altpair78 =null;
+		ParserRuleReturnScope altpair80 =null;
+
+		CommonTree char_literal79_tree=null;
+		RewriteRuleTokenStream stream_91=new RewriteRuleTokenStream(adaptor,"token 91");
+		RewriteRuleSubtreeStream stream_altpair=new RewriteRuleSubtreeStream(adaptor,"rule altpair");
+
+
+			// must create root manually as it's used by invoked rules in real antlr tool.
+			// leave here to demonstrate use of {...} in rewrite rule
+			// it's really BLOCK[firstToken,"BLOCK"]; set line/col to previous ( or : token.
+		    CommonTree blkRoot = (CommonTree)adaptor.create(BLOCK,input.LT(-1),"BLOCK");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:209:5: ( altpair ( '|' altpair )* -> ^( ( altpair )+ EOB[\"EOB\"] ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:209:9: altpair ( '|' altpair )*
+			{
+			pushFollow(FOLLOW_altpair_in_altList1311);
+			altpair78=altpair();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_altpair.add(altpair78.getTree());
+			// org/antlr/grammar/v3/ANTLRv3.g:209:17: ( '|' altpair )*
+			loop33:
+			while (true) {
+				int alt33=2;
+				int LA33_0 = input.LA(1);
+				if ( (LA33_0==91) ) {
+					alt33=1;
+				}
+
+				switch (alt33) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:209:19: '|' altpair
+					{
+					char_literal79=(Token)match(input,91,FOLLOW_91_in_altList1315); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_91.add(char_literal79);
+
+					pushFollow(FOLLOW_altpair_in_altList1317);
+					altpair80=altpair();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_altpair.add(altpair80.getTree());
+					}
+					break;
+
+				default :
+					break loop33;
+				}
+			}
+
+			// AST REWRITE
+			// elements: altpair
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 209:34: -> ^( ( altpair )+ EOB[\"EOB\"] )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:209:37: ^( ( altpair )+ EOB[\"EOB\"] )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(blkRoot, root_1);
+				if ( !(stream_altpair.hasNext()) ) {
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_altpair.hasNext() ) {
+					adaptor.addChild(root_1, stream_altpair.nextTree());
+				}
+				stream_altpair.reset();
+
+				adaptor.addChild(root_1, (CommonTree)adaptor.create(EOB, "EOB"));
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "altList"
+
+
+	public static class alternative_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "alternative"
+	// org/antlr/grammar/v3/ANTLRv3.g:212:1: alternative : ( ( element )+ -> ^( ALT[firstToken,\"ALT\"] ( element )+ EOA[\"EOA\"] ) | -> ^( ALT[prevToken,\"ALT\"] EPSILON[prevToken,\"EPSILON\"] EOA[\"EOA\"] ) );
+	public final ANTLRv3Parser.alternative_return alternative() throws RecognitionException {
+		ANTLRv3Parser.alternative_return retval = new ANTLRv3Parser.alternative_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		ParserRuleReturnScope element81 =null;
+
+		RewriteRuleSubtreeStream stream_element=new RewriteRuleSubtreeStream(adaptor,"rule element");
+
+
+			Token firstToken = input.LT(1);
+			Token prevToken = input.LT(-1); // either : or | I think
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:217:5: ( ( element )+ -> ^( ALT[firstToken,\"ALT\"] ( element )+ EOA[\"EOA\"] ) | -> ^( ALT[prevToken,\"ALT\"] EPSILON[prevToken,\"EPSILON\"] EOA[\"EOA\"] ) )
+			int alt35=2;
+			int LA35_0 = input.LA(1);
+			if ( (LA35_0==ACTION||LA35_0==CHAR_LITERAL||LA35_0==RULE_REF||LA35_0==SEMPRED||LA35_0==STRING_LITERAL||(LA35_0 >= TOKEN_REF && LA35_0 <= TREE_BEGIN)||LA35_0==68||LA35_0==73||LA35_0==93) ) {
+				alt35=1;
+			}
+			else if ( (LA35_0==REWRITE||LA35_0==69||LA35_0==76||LA35_0==91) ) {
+				alt35=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 35, 0, input);
+				throw nvae;
+			}
+
+			switch (alt35) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:217:9: ( element )+
+					{
+					// org/antlr/grammar/v3/ANTLRv3.g:217:9: ( element )+
+					int cnt34=0;
+					loop34:
+					while (true) {
+						int alt34=2;
+						int LA34_0 = input.LA(1);
+						if ( (LA34_0==ACTION||LA34_0==CHAR_LITERAL||LA34_0==RULE_REF||LA34_0==SEMPRED||LA34_0==STRING_LITERAL||(LA34_0 >= TOKEN_REF && LA34_0 <= TREE_BEGIN)||LA34_0==68||LA34_0==73||LA34_0==93) ) {
+							alt34=1;
+						}
+
+						switch (alt34) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:217:9: element
+							{
+							pushFollow(FOLLOW_element_in_alternative1358);
+							element81=element();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_element.add(element81.getTree());
+							}
+							break;
+
+						default :
+							if ( cnt34 >= 1 ) break loop34;
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							EarlyExitException eee = new EarlyExitException(34, input);
+							throw eee;
+						}
+						cnt34++;
+					}
+
+					// AST REWRITE
+					// elements: element
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 217:18: -> ^( ALT[firstToken,\"ALT\"] ( element )+ EOA[\"EOA\"] )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:217:21: ^( ALT[firstToken,\"ALT\"] ( element )+ EOA[\"EOA\"] )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ALT, firstToken, "ALT"), root_1);
+						if ( !(stream_element.hasNext()) ) {
+							throw new RewriteEarlyExitException();
+						}
+						while ( stream_element.hasNext() ) {
+							adaptor.addChild(root_1, stream_element.nextTree());
+						}
+						stream_element.reset();
+
+						adaptor.addChild(root_1, (CommonTree)adaptor.create(EOA, "EOA"));
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:218:9: 
+					{
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 218:9: -> ^( ALT[prevToken,\"ALT\"] EPSILON[prevToken,\"EPSILON\"] EOA[\"EOA\"] )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:218:12: ^( ALT[prevToken,\"ALT\"] EPSILON[prevToken,\"EPSILON\"] EOA[\"EOA\"] )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ALT, prevToken, "ALT"), root_1);
+						adaptor.addChild(root_1, (CommonTree)adaptor.create(EPSILON, prevToken, "EPSILON"));
+						adaptor.addChild(root_1, (CommonTree)adaptor.create(EOA, "EOA"));
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "alternative"
+
+
+	public static class exceptionGroup_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "exceptionGroup"
+	// org/antlr/grammar/v3/ANTLRv3.g:221:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	public final ANTLRv3Parser.exceptionGroup_return exceptionGroup() throws RecognitionException {
+		ANTLRv3Parser.exceptionGroup_return retval = new ANTLRv3Parser.exceptionGroup_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		ParserRuleReturnScope exceptionHandler82 =null;
+		ParserRuleReturnScope finallyClause83 =null;
+		ParserRuleReturnScope finallyClause84 =null;
+
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:222:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt38=2;
+			int LA38_0 = input.LA(1);
+			if ( (LA38_0==81) ) {
+				alt38=1;
+			}
+			else if ( (LA38_0==82) ) {
+				alt38=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 38, 0, input);
+				throw nvae;
+			}
+
+			switch (alt38) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:222:4: ( exceptionHandler )+ ( finallyClause )?
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					// org/antlr/grammar/v3/ANTLRv3.g:222:4: ( exceptionHandler )+
+					int cnt36=0;
+					loop36:
+					while (true) {
+						int alt36=2;
+						int LA36_0 = input.LA(1);
+						if ( (LA36_0==81) ) {
+							alt36=1;
+						}
+
+						switch (alt36) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:222:6: exceptionHandler
+							{
+							pushFollow(FOLLOW_exceptionHandler_in_exceptionGroup1409);
+							exceptionHandler82=exceptionHandler();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, exceptionHandler82.getTree());
+
+							}
+							break;
+
+						default :
+							if ( cnt36 >= 1 ) break loop36;
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							EarlyExitException eee = new EarlyExitException(36, input);
+							throw eee;
+						}
+						cnt36++;
+					}
+
+					// org/antlr/grammar/v3/ANTLRv3.g:222:26: ( finallyClause )?
+					int alt37=2;
+					int LA37_0 = input.LA(1);
+					if ( (LA37_0==82) ) {
+						alt37=1;
+					}
+					switch (alt37) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:222:28: finallyClause
+							{
+							pushFollow(FOLLOW_finallyClause_in_exceptionGroup1416);
+							finallyClause83=finallyClause();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) adaptor.addChild(root_0, finallyClause83.getTree());
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:223:4: finallyClause
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_finallyClause_in_exceptionGroup1424);
+					finallyClause84=finallyClause();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, finallyClause84.getTree());
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+	public static class exceptionHandler_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "exceptionHandler"
+	// org/antlr/grammar/v3/ANTLRv3.g:226:1: exceptionHandler : 'catch' ARG_ACTION ACTION -> ^( 'catch' ARG_ACTION ACTION ) ;
+	public final ANTLRv3Parser.exceptionHandler_return exceptionHandler() throws RecognitionException {
+		ANTLRv3Parser.exceptionHandler_return retval = new ANTLRv3Parser.exceptionHandler_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token string_literal85=null;
+		Token ARG_ACTION86=null;
+		Token ACTION87=null;
+
+		CommonTree string_literal85_tree=null;
+		CommonTree ARG_ACTION86_tree=null;
+		CommonTree ACTION87_tree=null;
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_ARG_ACTION=new RewriteRuleTokenStream(adaptor,"token ARG_ACTION");
+		RewriteRuleTokenStream stream_81=new RewriteRuleTokenStream(adaptor,"token 81");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:227:5: ( 'catch' ARG_ACTION ACTION -> ^( 'catch' ARG_ACTION ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:227:10: 'catch' ARG_ACTION ACTION
+			{
+			string_literal85=(Token)match(input,81,FOLLOW_81_in_exceptionHandler1444); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_81.add(string_literal85);
+
+			ARG_ACTION86=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_exceptionHandler1446); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ARG_ACTION.add(ARG_ACTION86);
+
+			ACTION87=(Token)match(input,ACTION,FOLLOW_ACTION_in_exceptionHandler1448); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ACTION.add(ACTION87);
+
+			// AST REWRITE
+			// elements: 81, ARG_ACTION, ACTION
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 227:36: -> ^( 'catch' ARG_ACTION ACTION )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:227:39: ^( 'catch' ARG_ACTION ACTION )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_81.nextNode(), root_1);
+				adaptor.addChild(root_1, stream_ARG_ACTION.nextNode());
+				adaptor.addChild(root_1, stream_ACTION.nextNode());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+	public static class finallyClause_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "finallyClause"
+	// org/antlr/grammar/v3/ANTLRv3.g:230:1: finallyClause : 'finally' ACTION -> ^( 'finally' ACTION ) ;
+	public final ANTLRv3Parser.finallyClause_return finallyClause() throws RecognitionException {
+		ANTLRv3Parser.finallyClause_return retval = new ANTLRv3Parser.finallyClause_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token string_literal88=null;
+		Token ACTION89=null;
+
+		CommonTree string_literal88_tree=null;
+		CommonTree ACTION89_tree=null;
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_82=new RewriteRuleTokenStream(adaptor,"token 82");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:231:5: ( 'finally' ACTION -> ^( 'finally' ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:231:10: 'finally' ACTION
+			{
+			string_literal88=(Token)match(input,82,FOLLOW_82_in_finallyClause1478); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_82.add(string_literal88);
+
+			ACTION89=(Token)match(input,ACTION,FOLLOW_ACTION_in_finallyClause1480); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ACTION.add(ACTION89);
+
+			// AST REWRITE
+			// elements: ACTION, 82
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 231:27: -> ^( 'finally' ACTION )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:231:30: ^( 'finally' ACTION )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_82.nextNode(), root_1);
+				adaptor.addChild(root_1, stream_ACTION.nextNode());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "finallyClause"
+
+
+	public static class element_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "element"
+	// org/antlr/grammar/v3/ANTLRv3.g:234:1: element : ( id (labelOp= '=' |labelOp= '+=' ) atom ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id atom ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> ^( $labelOp id atom ) ) | id (labelOp= '=' |labelOp= '+=' ) block ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id block ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> ^( $labelOp id block ) ) | atom ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] atom EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> atom ) | ebnf | ACTION | SEMPRED (g= '=>' -> GATED_SEMPRED[$g] | -> SEMPRED ) | treeSpec ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] treeSpec EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> treeSpec ) );
+	public final ANTLRv3Parser.element_return element() throws RecognitionException {
+		ANTLRv3Parser.element_return retval = new ANTLRv3Parser.element_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token labelOp=null;
+		Token g=null;
+		Token ACTION99=null;
+		Token SEMPRED100=null;
+		ParserRuleReturnScope id90 =null;
+		ParserRuleReturnScope atom91 =null;
+		ParserRuleReturnScope ebnfSuffix92 =null;
+		ParserRuleReturnScope id93 =null;
+		ParserRuleReturnScope block94 =null;
+		ParserRuleReturnScope ebnfSuffix95 =null;
+		ParserRuleReturnScope atom96 =null;
+		ParserRuleReturnScope ebnfSuffix97 =null;
+		ParserRuleReturnScope ebnf98 =null;
+		ParserRuleReturnScope treeSpec101 =null;
+		ParserRuleReturnScope ebnfSuffix102 =null;
+
+		CommonTree labelOp_tree=null;
+		CommonTree g_tree=null;
+		CommonTree ACTION99_tree=null;
+		CommonTree SEMPRED100_tree=null;
+		RewriteRuleTokenStream stream_LIST_LABEL_ASSIGN=new RewriteRuleTokenStream(adaptor,"token LIST_LABEL_ASSIGN");
+		RewriteRuleTokenStream stream_78=new RewriteRuleTokenStream(adaptor,"token 78");
+		RewriteRuleTokenStream stream_LABEL_ASSIGN=new RewriteRuleTokenStream(adaptor,"token LABEL_ASSIGN");
+		RewriteRuleTokenStream stream_SEMPRED=new RewriteRuleTokenStream(adaptor,"token SEMPRED");
+		RewriteRuleSubtreeStream stream_treeSpec=new RewriteRuleSubtreeStream(adaptor,"rule treeSpec");
+		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");
+		RewriteRuleSubtreeStream stream_ebnfSuffix=new RewriteRuleSubtreeStream(adaptor,"rule ebnfSuffix");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:235:2: ( id (labelOp= '=' |labelOp= '+=' ) atom ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id atom ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> ^( $labelOp id atom ) ) | id (labelOp= '=' |labelOp= '+=' ) block ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id block ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> ^( $labelOp id block ) ) | atom ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] atom EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> atom ) | ebnf | ACTION | SEMPRED (g= '=>' -> GATED_SEMPRED[$g] | -> SEMPRED ) | treeSpec ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] treeSpec EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> treeSpec ) )
+			int alt46=7;
+			switch ( input.LA(1) ) {
+			case TOKEN_REF:
+				{
+				switch ( input.LA(2) ) {
+				case LABEL_ASSIGN:
+					{
+					int LA46_8 = input.LA(3);
+					if ( (LA46_8==CHAR_LITERAL||LA46_8==RULE_REF||LA46_8==STRING_LITERAL||LA46_8==TOKEN_REF||LA46_8==73||LA46_8==93) ) {
+						alt46=1;
+					}
+					else if ( (LA46_8==68) ) {
+						alt46=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 46, 8, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+					}
+					break;
+				case LIST_LABEL_ASSIGN:
+					{
+					int LA46_9 = input.LA(3);
+					if ( (LA46_9==CHAR_LITERAL||LA46_9==RULE_REF||LA46_9==STRING_LITERAL||LA46_9==TOKEN_REF||LA46_9==73||LA46_9==93) ) {
+						alt46=1;
+					}
+					else if ( (LA46_9==68) ) {
+						alt46=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 46, 9, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+					}
+					break;
+				case ACTION:
+				case ARG_ACTION:
+				case BANG:
+				case CHAR_LITERAL:
+				case REWRITE:
+				case ROOT:
+				case RULE_REF:
+				case SEMPRED:
+				case STRING_LITERAL:
+				case TOKEN_REF:
+				case TREE_BEGIN:
+				case 68:
+				case 69:
+				case 70:
+				case 71:
+				case 73:
+				case 76:
+				case 77:
+				case 80:
+				case 91:
+				case 93:
+					{
+					alt46=3;
+					}
+					break;
+				default:
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 46, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+				}
+				break;
+			case RULE_REF:
+				{
+				switch ( input.LA(2) ) {
+				case LABEL_ASSIGN:
+					{
+					int LA46_8 = input.LA(3);
+					if ( (LA46_8==CHAR_LITERAL||LA46_8==RULE_REF||LA46_8==STRING_LITERAL||LA46_8==TOKEN_REF||LA46_8==73||LA46_8==93) ) {
+						alt46=1;
+					}
+					else if ( (LA46_8==68) ) {
+						alt46=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 46, 8, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+					}
+					break;
+				case LIST_LABEL_ASSIGN:
+					{
+					int LA46_9 = input.LA(3);
+					if ( (LA46_9==CHAR_LITERAL||LA46_9==RULE_REF||LA46_9==STRING_LITERAL||LA46_9==TOKEN_REF||LA46_9==73||LA46_9==93) ) {
+						alt46=1;
+					}
+					else if ( (LA46_9==68) ) {
+						alt46=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 46, 9, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+					}
+					break;
+				case ACTION:
+				case ARG_ACTION:
+				case BANG:
+				case CHAR_LITERAL:
+				case REWRITE:
+				case ROOT:
+				case RULE_REF:
+				case SEMPRED:
+				case STRING_LITERAL:
+				case TOKEN_REF:
+				case TREE_BEGIN:
+				case 68:
+				case 69:
+				case 70:
+				case 71:
+				case 73:
+				case 76:
+				case 80:
+				case 91:
+				case 93:
+					{
+					alt46=3;
+					}
+					break;
+				default:
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 46, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+				}
+				break;
+			case CHAR_LITERAL:
+			case STRING_LITERAL:
+			case 73:
+			case 93:
+				{
+				alt46=3;
+				}
+				break;
+			case 68:
+				{
+				alt46=4;
+				}
+				break;
+			case ACTION:
+				{
+				alt46=5;
+				}
+				break;
+			case SEMPRED:
+				{
+				alt46=6;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt46=7;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 46, 0, input);
+				throw nvae;
+			}
+			switch (alt46) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:235:4: id (labelOp= '=' |labelOp= '+=' ) atom ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id atom ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> ^( $labelOp id atom ) )
+					{
+					pushFollow(FOLLOW_id_in_element1502);
+					id90=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_id.add(id90.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:235:7: (labelOp= '=' |labelOp= '+=' )
+					int alt39=2;
+					int LA39_0 = input.LA(1);
+					if ( (LA39_0==LABEL_ASSIGN) ) {
+						alt39=1;
+					}
+					else if ( (LA39_0==LIST_LABEL_ASSIGN) ) {
+						alt39=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 39, 0, input);
+						throw nvae;
+					}
+
+					switch (alt39) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:235:8: labelOp= '='
+							{
+							labelOp=(Token)match(input,LABEL_ASSIGN,FOLLOW_LABEL_ASSIGN_in_element1507); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_LABEL_ASSIGN.add(labelOp);
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:235:20: labelOp= '+='
+							{
+							labelOp=(Token)match(input,LIST_LABEL_ASSIGN,FOLLOW_LIST_LABEL_ASSIGN_in_element1511); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_LIST_LABEL_ASSIGN.add(labelOp);
+
+							}
+							break;
+
+					}
+
+					pushFollow(FOLLOW_atom_in_element1514);
+					atom91=atom();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_atom.add(atom91.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:236:3: ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id atom ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> ^( $labelOp id atom ) )
+					int alt40=2;
+					int LA40_0 = input.LA(1);
+					if ( ((LA40_0 >= 70 && LA40_0 <= 71)||LA40_0==80) ) {
+						alt40=1;
+					}
+					else if ( (LA40_0==ACTION||LA40_0==CHAR_LITERAL||LA40_0==REWRITE||LA40_0==RULE_REF||LA40_0==SEMPRED||LA40_0==STRING_LITERAL||(LA40_0 >= TOKEN_REF && LA40_0 <= TREE_BEGIN)||(LA40_0 >= 68 && LA40_0 <= 69)||LA40_0==73||LA40_0==76||LA40_0==91||LA40_0==93) ) {
+						alt40=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 40, 0, input);
+						throw nvae;
+					}
+
+					switch (alt40) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:236:5: ebnfSuffix
+							{
+							pushFollow(FOLLOW_ebnfSuffix_in_element1520);
+							ebnfSuffix92=ebnfSuffix();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_ebnfSuffix.add(ebnfSuffix92.getTree());
+							// AST REWRITE
+							// elements: id, atom, ebnfSuffix, labelOp
+							// token labels: labelOp
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleTokenStream stream_labelOp=new RewriteRuleTokenStream(adaptor,"token labelOp",labelOp);
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 236:16: -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id atom ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:236:19: ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id atom ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_ebnfSuffix.nextNode(), root_1);
+								// org/antlr/grammar/v3/ANTLRv3.g:236:33: ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id atom ) EOA[\"EOA\"] ) EOB[\"EOB\"] )
+								{
+								CommonTree root_2 = (CommonTree)adaptor.nil();
+								root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(BLOCK, "BLOCK"), root_2);
+								// org/antlr/grammar/v3/ANTLRv3.g:236:50: ^( ALT[\"ALT\"] ^( $labelOp id atom ) EOA[\"EOA\"] )
+								{
+								CommonTree root_3 = (CommonTree)adaptor.nil();
+								root_3 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ALT, "ALT"), root_3);
+								// org/antlr/grammar/v3/ANTLRv3.g:236:63: ^( $labelOp id atom )
+								{
+								CommonTree root_4 = (CommonTree)adaptor.nil();
+								root_4 = (CommonTree)adaptor.becomeRoot(stream_labelOp.nextNode(), root_4);
+								adaptor.addChild(root_4, stream_id.nextTree());
+								adaptor.addChild(root_4, stream_atom.nextTree());
+								adaptor.addChild(root_3, root_4);
+								}
+
+								adaptor.addChild(root_3, (CommonTree)adaptor.create(EOA, "EOA"));
+								adaptor.addChild(root_2, root_3);
+								}
+
+								adaptor.addChild(root_2, (CommonTree)adaptor.create(EOB, "EOB"));
+								adaptor.addChild(root_1, root_2);
+								}
+
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:237:8: 
+							{
+							// AST REWRITE
+							// elements: id, labelOp, atom
+							// token labels: labelOp
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleTokenStream stream_labelOp=new RewriteRuleTokenStream(adaptor,"token labelOp",labelOp);
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 237:8: -> ^( $labelOp id atom )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:237:11: ^( $labelOp id atom )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_labelOp.nextNode(), root_1);
+								adaptor.addChild(root_1, stream_id.nextTree());
+								adaptor.addChild(root_1, stream_atom.nextTree());
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:239:4: id (labelOp= '=' |labelOp= '+=' ) block ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id block ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> ^( $labelOp id block ) )
+					{
+					pushFollow(FOLLOW_id_in_element1579);
+					id93=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_id.add(id93.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:239:7: (labelOp= '=' |labelOp= '+=' )
+					int alt41=2;
+					int LA41_0 = input.LA(1);
+					if ( (LA41_0==LABEL_ASSIGN) ) {
+						alt41=1;
+					}
+					else if ( (LA41_0==LIST_LABEL_ASSIGN) ) {
+						alt41=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 41, 0, input);
+						throw nvae;
+					}
+
+					switch (alt41) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:239:8: labelOp= '='
+							{
+							labelOp=(Token)match(input,LABEL_ASSIGN,FOLLOW_LABEL_ASSIGN_in_element1584); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_LABEL_ASSIGN.add(labelOp);
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:239:20: labelOp= '+='
+							{
+							labelOp=(Token)match(input,LIST_LABEL_ASSIGN,FOLLOW_LIST_LABEL_ASSIGN_in_element1588); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_LIST_LABEL_ASSIGN.add(labelOp);
+
+							}
+							break;
+
+					}
+
+					pushFollow(FOLLOW_block_in_element1591);
+					block94=block();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_block.add(block94.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:240:3: ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id block ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> ^( $labelOp id block ) )
+					int alt42=2;
+					int LA42_0 = input.LA(1);
+					if ( ((LA42_0 >= 70 && LA42_0 <= 71)||LA42_0==80) ) {
+						alt42=1;
+					}
+					else if ( (LA42_0==ACTION||LA42_0==CHAR_LITERAL||LA42_0==REWRITE||LA42_0==RULE_REF||LA42_0==SEMPRED||LA42_0==STRING_LITERAL||(LA42_0 >= TOKEN_REF && LA42_0 <= TREE_BEGIN)||(LA42_0 >= 68 && LA42_0 <= 69)||LA42_0==73||LA42_0==76||LA42_0==91||LA42_0==93) ) {
+						alt42=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 42, 0, input);
+						throw nvae;
+					}
+
+					switch (alt42) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:240:5: ebnfSuffix
+							{
+							pushFollow(FOLLOW_ebnfSuffix_in_element1597);
+							ebnfSuffix95=ebnfSuffix();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_ebnfSuffix.add(ebnfSuffix95.getTree());
+							// AST REWRITE
+							// elements: id, labelOp, ebnfSuffix, block
+							// token labels: labelOp
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleTokenStream stream_labelOp=new RewriteRuleTokenStream(adaptor,"token labelOp",labelOp);
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 240:16: -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id block ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:240:19: ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id block ) EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_ebnfSuffix.nextNode(), root_1);
+								// org/antlr/grammar/v3/ANTLRv3.g:240:33: ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] ^( $labelOp id block ) EOA[\"EOA\"] ) EOB[\"EOB\"] )
+								{
+								CommonTree root_2 = (CommonTree)adaptor.nil();
+								root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(BLOCK, "BLOCK"), root_2);
+								// org/antlr/grammar/v3/ANTLRv3.g:240:50: ^( ALT[\"ALT\"] ^( $labelOp id block ) EOA[\"EOA\"] )
+								{
+								CommonTree root_3 = (CommonTree)adaptor.nil();
+								root_3 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ALT, "ALT"), root_3);
+								// org/antlr/grammar/v3/ANTLRv3.g:240:63: ^( $labelOp id block )
+								{
+								CommonTree root_4 = (CommonTree)adaptor.nil();
+								root_4 = (CommonTree)adaptor.becomeRoot(stream_labelOp.nextNode(), root_4);
+								adaptor.addChild(root_4, stream_id.nextTree());
+								adaptor.addChild(root_4, stream_block.nextTree());
+								adaptor.addChild(root_3, root_4);
+								}
+
+								adaptor.addChild(root_3, (CommonTree)adaptor.create(EOA, "EOA"));
+								adaptor.addChild(root_2, root_3);
+								}
+
+								adaptor.addChild(root_2, (CommonTree)adaptor.create(EOB, "EOB"));
+								adaptor.addChild(root_1, root_2);
+								}
+
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:241:8: 
+							{
+							// AST REWRITE
+							// elements: id, block, labelOp
+							// token labels: labelOp
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleTokenStream stream_labelOp=new RewriteRuleTokenStream(adaptor,"token labelOp",labelOp);
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 241:8: -> ^( $labelOp id block )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:241:11: ^( $labelOp id block )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_labelOp.nextNode(), root_1);
+								adaptor.addChild(root_1, stream_id.nextTree());
+								adaptor.addChild(root_1, stream_block.nextTree());
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:243:4: atom ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] atom EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> atom )
+					{
+					pushFollow(FOLLOW_atom_in_element1656);
+					atom96=atom();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_atom.add(atom96.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:244:3: ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] atom EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> atom )
+					int alt43=2;
+					int LA43_0 = input.LA(1);
+					if ( ((LA43_0 >= 70 && LA43_0 <= 71)||LA43_0==80) ) {
+						alt43=1;
+					}
+					else if ( (LA43_0==ACTION||LA43_0==CHAR_LITERAL||LA43_0==REWRITE||LA43_0==RULE_REF||LA43_0==SEMPRED||LA43_0==STRING_LITERAL||(LA43_0 >= TOKEN_REF && LA43_0 <= TREE_BEGIN)||(LA43_0 >= 68 && LA43_0 <= 69)||LA43_0==73||LA43_0==76||LA43_0==91||LA43_0==93) ) {
+						alt43=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 43, 0, input);
+						throw nvae;
+					}
+
+					switch (alt43) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:244:5: ebnfSuffix
+							{
+							pushFollow(FOLLOW_ebnfSuffix_in_element1662);
+							ebnfSuffix97=ebnfSuffix();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_ebnfSuffix.add(ebnfSuffix97.getTree());
+							// AST REWRITE
+							// elements: ebnfSuffix, atom
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 244:16: -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] atom EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:244:19: ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] atom EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_ebnfSuffix.nextNode(), root_1);
+								// org/antlr/grammar/v3/ANTLRv3.g:244:33: ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] atom EOA[\"EOA\"] ) EOB[\"EOB\"] )
+								{
+								CommonTree root_2 = (CommonTree)adaptor.nil();
+								root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(BLOCK, "BLOCK"), root_2);
+								// org/antlr/grammar/v3/ANTLRv3.g:244:50: ^( ALT[\"ALT\"] atom EOA[\"EOA\"] )
+								{
+								CommonTree root_3 = (CommonTree)adaptor.nil();
+								root_3 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ALT, "ALT"), root_3);
+								adaptor.addChild(root_3, stream_atom.nextTree());
+								adaptor.addChild(root_3, (CommonTree)adaptor.create(EOA, "EOA"));
+								adaptor.addChild(root_2, root_3);
+								}
+
+								adaptor.addChild(root_2, (CommonTree)adaptor.create(EOB, "EOB"));
+								adaptor.addChild(root_1, root_2);
+								}
+
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:245:8: 
+							{
+							// AST REWRITE
+							// elements: atom
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 245:8: -> atom
+							{
+								adaptor.addChild(root_0, stream_atom.nextTree());
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:247:4: ebnf
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_ebnf_in_element1708);
+					ebnf98=ebnf();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, ebnf98.getTree());
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRv3.g:248:6: ACTION
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					ACTION99=(Token)match(input,ACTION,FOLLOW_ACTION_in_element1715); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ACTION99_tree = (CommonTree)adaptor.create(ACTION99);
+					adaptor.addChild(root_0, ACTION99_tree);
+					}
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLRv3.g:249:6: SEMPRED (g= '=>' -> GATED_SEMPRED[$g] | -> SEMPRED )
+					{
+					SEMPRED100=(Token)match(input,SEMPRED,FOLLOW_SEMPRED_in_element1722); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_SEMPRED.add(SEMPRED100);
+
+					// org/antlr/grammar/v3/ANTLRv3.g:249:14: (g= '=>' -> GATED_SEMPRED[$g] | -> SEMPRED )
+					int alt44=2;
+					int LA44_0 = input.LA(1);
+					if ( (LA44_0==78) ) {
+						alt44=1;
+					}
+					else if ( (LA44_0==ACTION||LA44_0==CHAR_LITERAL||LA44_0==REWRITE||LA44_0==RULE_REF||LA44_0==SEMPRED||LA44_0==STRING_LITERAL||(LA44_0 >= TOKEN_REF && LA44_0 <= TREE_BEGIN)||(LA44_0 >= 68 && LA44_0 <= 69)||LA44_0==73||LA44_0==76||LA44_0==91||LA44_0==93) ) {
+						alt44=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 44, 0, input);
+						throw nvae;
+					}
+
+					switch (alt44) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:249:16: g= '=>'
+							{
+							g=(Token)match(input,78,FOLLOW_78_in_element1728); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_78.add(g);
+
+							// AST REWRITE
+							// elements: 
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 249:23: -> GATED_SEMPRED[$g]
+							{
+								adaptor.addChild(root_0, (CommonTree)adaptor.create(GATED_SEMPRED, g));
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:249:46: 
+							{
+							// AST REWRITE
+							// elements: SEMPRED
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 249:46: -> SEMPRED
+							{
+								adaptor.addChild(root_0, stream_SEMPRED.nextNode());
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/ANTLRv3.g:250:6: treeSpec ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] treeSpec EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> treeSpec )
+					{
+					pushFollow(FOLLOW_treeSpec_in_element1748);
+					treeSpec101=treeSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_treeSpec.add(treeSpec101.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:251:3: ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] treeSpec EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> treeSpec )
+					int alt45=2;
+					int LA45_0 = input.LA(1);
+					if ( ((LA45_0 >= 70 && LA45_0 <= 71)||LA45_0==80) ) {
+						alt45=1;
+					}
+					else if ( (LA45_0==ACTION||LA45_0==CHAR_LITERAL||LA45_0==REWRITE||LA45_0==RULE_REF||LA45_0==SEMPRED||LA45_0==STRING_LITERAL||(LA45_0 >= TOKEN_REF && LA45_0 <= TREE_BEGIN)||(LA45_0 >= 68 && LA45_0 <= 69)||LA45_0==73||LA45_0==76||LA45_0==91||LA45_0==93) ) {
+						alt45=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 45, 0, input);
+						throw nvae;
+					}
+
+					switch (alt45) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:251:5: ebnfSuffix
+							{
+							pushFollow(FOLLOW_ebnfSuffix_in_element1754);
+							ebnfSuffix102=ebnfSuffix();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_ebnfSuffix.add(ebnfSuffix102.getTree());
+							// AST REWRITE
+							// elements: treeSpec, ebnfSuffix
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 251:16: -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] treeSpec EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:251:19: ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] treeSpec EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_ebnfSuffix.nextNode(), root_1);
+								// org/antlr/grammar/v3/ANTLRv3.g:251:33: ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] treeSpec EOA[\"EOA\"] ) EOB[\"EOB\"] )
+								{
+								CommonTree root_2 = (CommonTree)adaptor.nil();
+								root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(BLOCK, "BLOCK"), root_2);
+								// org/antlr/grammar/v3/ANTLRv3.g:251:50: ^( ALT[\"ALT\"] treeSpec EOA[\"EOA\"] )
+								{
+								CommonTree root_3 = (CommonTree)adaptor.nil();
+								root_3 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ALT, "ALT"), root_3);
+								adaptor.addChild(root_3, stream_treeSpec.nextTree());
+								adaptor.addChild(root_3, (CommonTree)adaptor.create(EOA, "EOA"));
+								adaptor.addChild(root_2, root_3);
+								}
+
+								adaptor.addChild(root_2, (CommonTree)adaptor.create(EOB, "EOB"));
+								adaptor.addChild(root_1, root_2);
+								}
+
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:252:8: 
+							{
+							// AST REWRITE
+							// elements: treeSpec
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 252:8: -> treeSpec
+							{
+								adaptor.addChild(root_0, stream_treeSpec.nextTree());
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "element"
+
+
+	public static class atom_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "atom"
+	// org/antlr/grammar/v3/ANTLRv3.g:256:1: atom : ( terminal | range ( (op= '^' |op= '!' ) -> ^( $op range ) | -> range ) | notSet ( (op= '^' |op= '!' ) -> ^( $op notSet ) | -> notSet ) | RULE_REF ( ARG_ACTION )? ( (op= '^' |op= '!' ) -> ^( $op RULE_REF ( ARG_ACTION )? ) | -> ^( RULE_REF ( ARG_ACTION )? ) ) );
+	public final ANTLRv3Parser.atom_return atom() throws RecognitionException {
+		ANTLRv3Parser.atom_return retval = new ANTLRv3Parser.atom_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token op=null;
+		Token RULE_REF106=null;
+		Token ARG_ACTION107=null;
+		ParserRuleReturnScope terminal103 =null;
+		ParserRuleReturnScope range104 =null;
+		ParserRuleReturnScope notSet105 =null;
+
+		CommonTree op_tree=null;
+		CommonTree RULE_REF106_tree=null;
+		CommonTree ARG_ACTION107_tree=null;
+		RewriteRuleTokenStream stream_ROOT=new RewriteRuleTokenStream(adaptor,"token ROOT");
+		RewriteRuleTokenStream stream_BANG=new RewriteRuleTokenStream(adaptor,"token BANG");
+		RewriteRuleTokenStream stream_ARG_ACTION=new RewriteRuleTokenStream(adaptor,"token ARG_ACTION");
+		RewriteRuleTokenStream stream_RULE_REF=new RewriteRuleTokenStream(adaptor,"token RULE_REF");
+		RewriteRuleSubtreeStream stream_notSet=new RewriteRuleSubtreeStream(adaptor,"rule notSet");
+		RewriteRuleSubtreeStream stream_range=new RewriteRuleSubtreeStream(adaptor,"rule range");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:256:5: ( terminal | range ( (op= '^' |op= '!' ) -> ^( $op range ) | -> range ) | notSet ( (op= '^' |op= '!' ) -> ^( $op notSet ) | -> notSet ) | RULE_REF ( ARG_ACTION )? ( (op= '^' |op= '!' ) -> ^( $op RULE_REF ( ARG_ACTION )? ) | -> ^( RULE_REF ( ARG_ACTION )? ) ) )
+			int alt54=4;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				int LA54_1 = input.LA(2);
+				if ( (LA54_1==RANGE) ) {
+					alt54=2;
+				}
+				else if ( (LA54_1==ACTION||LA54_1==BANG||LA54_1==CHAR_LITERAL||(LA54_1 >= REWRITE && LA54_1 <= ROOT)||LA54_1==RULE_REF||LA54_1==SEMPRED||LA54_1==STRING_LITERAL||(LA54_1 >= TOKEN_REF && LA54_1 <= TREE_BEGIN)||(LA54_1 >= 68 && LA54_1 <= 71)||LA54_1==73||(LA54_1 >= 76 && LA54_1 <= 77)||LA54_1==80||LA54_1==91||LA54_1==93) ) {
+					alt54=1;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 54, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case 73:
+				{
+				alt54=1;
+				}
+				break;
+			case 93:
+				{
+				alt54=3;
+				}
+				break;
+			case RULE_REF:
+				{
+				alt54=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 54, 0, input);
+				throw nvae;
+			}
+			switch (alt54) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:256:9: terminal
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_terminal_in_atom1806);
+					terminal103=terminal();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, terminal103.getTree());
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:257:4: range ( (op= '^' |op= '!' ) -> ^( $op range ) | -> range )
+					{
+					pushFollow(FOLLOW_range_in_atom1811);
+					range104=range();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_range.add(range104.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:258:3: ( (op= '^' |op= '!' ) -> ^( $op range ) | -> range )
+					int alt48=2;
+					int LA48_0 = input.LA(1);
+					if ( (LA48_0==BANG||LA48_0==ROOT) ) {
+						alt48=1;
+					}
+					else if ( (LA48_0==ACTION||LA48_0==CHAR_LITERAL||LA48_0==REWRITE||LA48_0==RULE_REF||LA48_0==SEMPRED||LA48_0==STRING_LITERAL||(LA48_0 >= TOKEN_REF && LA48_0 <= TREE_BEGIN)||(LA48_0 >= 68 && LA48_0 <= 71)||LA48_0==73||LA48_0==76||LA48_0==80||LA48_0==91||LA48_0==93) ) {
+						alt48=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 48, 0, input);
+						throw nvae;
+					}
+
+					switch (alt48) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:258:5: (op= '^' |op= '!' )
+							{
+							// org/antlr/grammar/v3/ANTLRv3.g:258:5: (op= '^' |op= '!' )
+							int alt47=2;
+							int LA47_0 = input.LA(1);
+							if ( (LA47_0==ROOT) ) {
+								alt47=1;
+							}
+							else if ( (LA47_0==BANG) ) {
+								alt47=2;
+							}
+
+							else {
+								if (state.backtracking>0) {state.failed=true; return retval;}
+								NoViableAltException nvae =
+									new NoViableAltException("", 47, 0, input);
+								throw nvae;
+							}
+
+							switch (alt47) {
+								case 1 :
+									// org/antlr/grammar/v3/ANTLRv3.g:258:6: op= '^'
+									{
+									op=(Token)match(input,ROOT,FOLLOW_ROOT_in_atom1821); if (state.failed) return retval; 
+									if ( state.backtracking==0 ) stream_ROOT.add(op);
+
+									}
+									break;
+								case 2 :
+									// org/antlr/grammar/v3/ANTLRv3.g:258:13: op= '!'
+									{
+									op=(Token)match(input,BANG,FOLLOW_BANG_in_atom1825); if (state.failed) return retval; 
+									if ( state.backtracking==0 ) stream_BANG.add(op);
+
+									}
+									break;
+
+							}
+
+							// AST REWRITE
+							// elements: op, range
+							// token labels: op
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleTokenStream stream_op=new RewriteRuleTokenStream(adaptor,"token op",op);
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 258:21: -> ^( $op range )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:258:24: ^( $op range )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_op.nextNode(), root_1);
+								adaptor.addChild(root_1, stream_range.nextTree());
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:259:9: 
+							{
+							// AST REWRITE
+							// elements: range
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 259:9: -> range
+							{
+								adaptor.addChild(root_0, stream_range.nextTree());
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:261:7: notSet ( (op= '^' |op= '!' ) -> ^( $op notSet ) | -> notSet )
+					{
+					pushFollow(FOLLOW_notSet_in_atom1859);
+					notSet105=notSet();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_notSet.add(notSet105.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:262:3: ( (op= '^' |op= '!' ) -> ^( $op notSet ) | -> notSet )
+					int alt50=2;
+					int LA50_0 = input.LA(1);
+					if ( (LA50_0==BANG||LA50_0==ROOT) ) {
+						alt50=1;
+					}
+					else if ( (LA50_0==ACTION||LA50_0==CHAR_LITERAL||LA50_0==REWRITE||LA50_0==RULE_REF||LA50_0==SEMPRED||LA50_0==STRING_LITERAL||(LA50_0 >= TOKEN_REF && LA50_0 <= TREE_BEGIN)||(LA50_0 >= 68 && LA50_0 <= 71)||LA50_0==73||LA50_0==76||LA50_0==80||LA50_0==91||LA50_0==93) ) {
+						alt50=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 50, 0, input);
+						throw nvae;
+					}
+
+					switch (alt50) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:262:5: (op= '^' |op= '!' )
+							{
+							// org/antlr/grammar/v3/ANTLRv3.g:262:5: (op= '^' |op= '!' )
+							int alt49=2;
+							int LA49_0 = input.LA(1);
+							if ( (LA49_0==ROOT) ) {
+								alt49=1;
+							}
+							else if ( (LA49_0==BANG) ) {
+								alt49=2;
+							}
+
+							else {
+								if (state.backtracking>0) {state.failed=true; return retval;}
+								NoViableAltException nvae =
+									new NoViableAltException("", 49, 0, input);
+								throw nvae;
+							}
+
+							switch (alt49) {
+								case 1 :
+									// org/antlr/grammar/v3/ANTLRv3.g:262:6: op= '^'
+									{
+									op=(Token)match(input,ROOT,FOLLOW_ROOT_in_atom1868); if (state.failed) return retval; 
+									if ( state.backtracking==0 ) stream_ROOT.add(op);
+
+									}
+									break;
+								case 2 :
+									// org/antlr/grammar/v3/ANTLRv3.g:262:13: op= '!'
+									{
+									op=(Token)match(input,BANG,FOLLOW_BANG_in_atom1872); if (state.failed) return retval; 
+									if ( state.backtracking==0 ) stream_BANG.add(op);
+
+									}
+									break;
+
+							}
+
+							// AST REWRITE
+							// elements: notSet, op
+							// token labels: op
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleTokenStream stream_op=new RewriteRuleTokenStream(adaptor,"token op",op);
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 262:21: -> ^( $op notSet )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:262:24: ^( $op notSet )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_op.nextNode(), root_1);
+								adaptor.addChild(root_1, stream_notSet.nextTree());
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:263:9: 
+							{
+							// AST REWRITE
+							// elements: notSet
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 263:9: -> notSet
+							{
+								adaptor.addChild(root_0, stream_notSet.nextTree());
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:265:9: RULE_REF ( ARG_ACTION )? ( (op= '^' |op= '!' ) -> ^( $op RULE_REF ( ARG_ACTION )? ) | -> ^( RULE_REF ( ARG_ACTION )? ) )
+					{
+					RULE_REF106=(Token)match(input,RULE_REF,FOLLOW_RULE_REF_in_atom1908); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_RULE_REF.add(RULE_REF106);
+
+					// org/antlr/grammar/v3/ANTLRv3.g:265:18: ( ARG_ACTION )?
+					int alt51=2;
+					int LA51_0 = input.LA(1);
+					if ( (LA51_0==ARG_ACTION) ) {
+						alt51=1;
+					}
+					switch (alt51) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:265:18: ARG_ACTION
+							{
+							ARG_ACTION107=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1910); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_ARG_ACTION.add(ARG_ACTION107);
+
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/ANTLRv3.g:266:3: ( (op= '^' |op= '!' ) -> ^( $op RULE_REF ( ARG_ACTION )? ) | -> ^( RULE_REF ( ARG_ACTION )? ) )
+					int alt53=2;
+					int LA53_0 = input.LA(1);
+					if ( (LA53_0==BANG||LA53_0==ROOT) ) {
+						alt53=1;
+					}
+					else if ( (LA53_0==ACTION||LA53_0==CHAR_LITERAL||LA53_0==REWRITE||LA53_0==RULE_REF||LA53_0==SEMPRED||LA53_0==STRING_LITERAL||(LA53_0 >= TOKEN_REF && LA53_0 <= TREE_BEGIN)||(LA53_0 >= 68 && LA53_0 <= 71)||LA53_0==73||LA53_0==76||LA53_0==80||LA53_0==91||LA53_0==93) ) {
+						alt53=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 53, 0, input);
+						throw nvae;
+					}
+
+					switch (alt53) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:266:5: (op= '^' |op= '!' )
+							{
+							// org/antlr/grammar/v3/ANTLRv3.g:266:5: (op= '^' |op= '!' )
+							int alt52=2;
+							int LA52_0 = input.LA(1);
+							if ( (LA52_0==ROOT) ) {
+								alt52=1;
+							}
+							else if ( (LA52_0==BANG) ) {
+								alt52=2;
+							}
+
+							else {
+								if (state.backtracking>0) {state.failed=true; return retval;}
+								NoViableAltException nvae =
+									new NoViableAltException("", 52, 0, input);
+								throw nvae;
+							}
+
+							switch (alt52) {
+								case 1 :
+									// org/antlr/grammar/v3/ANTLRv3.g:266:6: op= '^'
+									{
+									op=(Token)match(input,ROOT,FOLLOW_ROOT_in_atom1920); if (state.failed) return retval; 
+									if ( state.backtracking==0 ) stream_ROOT.add(op);
+
+									}
+									break;
+								case 2 :
+									// org/antlr/grammar/v3/ANTLRv3.g:266:13: op= '!'
+									{
+									op=(Token)match(input,BANG,FOLLOW_BANG_in_atom1924); if (state.failed) return retval; 
+									if ( state.backtracking==0 ) stream_BANG.add(op);
+
+									}
+									break;
+
+							}
+
+							// AST REWRITE
+							// elements: op, ARG_ACTION, RULE_REF
+							// token labels: op
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleTokenStream stream_op=new RewriteRuleTokenStream(adaptor,"token op",op);
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 266:21: -> ^( $op RULE_REF ( ARG_ACTION )? )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:266:24: ^( $op RULE_REF ( ARG_ACTION )? )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_op.nextNode(), root_1);
+								adaptor.addChild(root_1, stream_RULE_REF.nextNode());
+								// org/antlr/grammar/v3/ANTLRv3.g:266:39: ( ARG_ACTION )?
+								if ( stream_ARG_ACTION.hasNext() ) {
+									adaptor.addChild(root_1, stream_ARG_ACTION.nextNode());
+								}
+								stream_ARG_ACTION.reset();
+
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:267:9: 
+							{
+							// AST REWRITE
+							// elements: RULE_REF, ARG_ACTION
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 267:9: -> ^( RULE_REF ( ARG_ACTION )? )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:267:12: ^( RULE_REF ( ARG_ACTION )? )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_RULE_REF.nextNode(), root_1);
+								// org/antlr/grammar/v3/ANTLRv3.g:267:23: ( ARG_ACTION )?
+								if ( stream_ARG_ACTION.hasNext() ) {
+									adaptor.addChild(root_1, stream_ARG_ACTION.nextNode());
+								}
+								stream_ARG_ACTION.reset();
+
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "atom"
+
+
+	public static class notSet_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "notSet"
+	// org/antlr/grammar/v3/ANTLRv3.g:271:1: notSet : '~' ( notTerminal ( elementOptions )? -> ^( '~' notTerminal ( elementOptions )? ) | block ( elementOptions )? -> ^( '~' block ( elementOptions )? ) ) ;
+	public final ANTLRv3Parser.notSet_return notSet() throws RecognitionException {
+		ANTLRv3Parser.notSet_return retval = new ANTLRv3Parser.notSet_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal108=null;
+		ParserRuleReturnScope notTerminal109 =null;
+		ParserRuleReturnScope elementOptions110 =null;
+		ParserRuleReturnScope block111 =null;
+		ParserRuleReturnScope elementOptions112 =null;
+
+		CommonTree char_literal108_tree=null;
+		RewriteRuleTokenStream stream_93=new RewriteRuleTokenStream(adaptor,"token 93");
+		RewriteRuleSubtreeStream stream_elementOptions=new RewriteRuleSubtreeStream(adaptor,"rule elementOptions");
+		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
+		RewriteRuleSubtreeStream stream_notTerminal=new RewriteRuleSubtreeStream(adaptor,"rule notTerminal");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:272:2: ( '~' ( notTerminal ( elementOptions )? -> ^( '~' notTerminal ( elementOptions )? ) | block ( elementOptions )? -> ^( '~' block ( elementOptions )? ) ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:272:4: '~' ( notTerminal ( elementOptions )? -> ^( '~' notTerminal ( elementOptions )? ) | block ( elementOptions )? -> ^( '~' block ( elementOptions )? ) )
+			{
+			char_literal108=(Token)match(input,93,FOLLOW_93_in_notSet1972); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_93.add(char_literal108);
+
+			// org/antlr/grammar/v3/ANTLRv3.g:273:3: ( notTerminal ( elementOptions )? -> ^( '~' notTerminal ( elementOptions )? ) | block ( elementOptions )? -> ^( '~' block ( elementOptions )? ) )
+			int alt57=2;
+			int LA57_0 = input.LA(1);
+			if ( (LA57_0==CHAR_LITERAL||LA57_0==STRING_LITERAL||LA57_0==TOKEN_REF) ) {
+				alt57=1;
+			}
+			else if ( (LA57_0==68) ) {
+				alt57=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 57, 0, input);
+				throw nvae;
+			}
+
+			switch (alt57) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:273:5: notTerminal ( elementOptions )?
+					{
+					pushFollow(FOLLOW_notTerminal_in_notSet1978);
+					notTerminal109=notTerminal();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_notTerminal.add(notTerminal109.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:273:17: ( elementOptions )?
+					int alt55=2;
+					int LA55_0 = input.LA(1);
+					if ( (LA55_0==77) ) {
+						alt55=1;
+					}
+					switch (alt55) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:273:17: elementOptions
+							{
+							pushFollow(FOLLOW_elementOptions_in_notSet1980);
+							elementOptions110=elementOptions();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_elementOptions.add(elementOptions110.getTree());
+							}
+							break;
+
+					}
+
+					// AST REWRITE
+					// elements: 93, elementOptions, notTerminal
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 273:33: -> ^( '~' notTerminal ( elementOptions )? )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:273:36: ^( '~' notTerminal ( elementOptions )? )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_93.nextNode(), root_1);
+						adaptor.addChild(root_1, stream_notTerminal.nextTree());
+						// org/antlr/grammar/v3/ANTLRv3.g:273:54: ( elementOptions )?
+						if ( stream_elementOptions.hasNext() ) {
+							adaptor.addChild(root_1, stream_elementOptions.nextTree());
+						}
+						stream_elementOptions.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:274:5: block ( elementOptions )?
+					{
+					pushFollow(FOLLOW_block_in_notSet1998);
+					block111=block();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_block.add(block111.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:274:11: ( elementOptions )?
+					int alt56=2;
+					int LA56_0 = input.LA(1);
+					if ( (LA56_0==77) ) {
+						alt56=1;
+					}
+					switch (alt56) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:274:11: elementOptions
+							{
+							pushFollow(FOLLOW_elementOptions_in_notSet2000);
+							elementOptions112=elementOptions();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_elementOptions.add(elementOptions112.getTree());
+							}
+							break;
+
+					}
+
+					// AST REWRITE
+					// elements: elementOptions, block, 93
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 274:28: -> ^( '~' block ( elementOptions )? )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:274:31: ^( '~' block ( elementOptions )? )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_93.nextNode(), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						// org/antlr/grammar/v3/ANTLRv3.g:274:43: ( elementOptions )?
+						if ( stream_elementOptions.hasNext() ) {
+							adaptor.addChild(root_1, stream_elementOptions.nextTree());
+						}
+						stream_elementOptions.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "notSet"
+
+
+	public static class notTerminal_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "notTerminal"
+	// org/antlr/grammar/v3/ANTLRv3.g:278:1: notTerminal : ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL );
+	public final ANTLRv3Parser.notTerminal_return notTerminal() throws RecognitionException {
+		ANTLRv3Parser.notTerminal_return retval = new ANTLRv3Parser.notTerminal_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token set113=null;
+
+		CommonTree set113_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:279:2: ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL )
+			// org/antlr/grammar/v3/ANTLRv3.g:
+			{
+			root_0 = (CommonTree)adaptor.nil();
+
+
+			set113=input.LT(1);
+			if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL||input.LA(1)==TOKEN_REF ) {
+				input.consume();
+				if ( state.backtracking==0 ) adaptor.addChild(root_0, (CommonTree)adaptor.create(set113));
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "notTerminal"
+
+
+	public static class elementOptions_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "elementOptions"
+	// org/antlr/grammar/v3/ANTLRv3.g:284:1: elementOptions : ( '<' qid '>' -> ^( OPTIONS qid ) | '<' option ( ';' option )* '>' -> ^( OPTIONS ( option )+ ) );
+	public final ANTLRv3Parser.elementOptions_return elementOptions() throws RecognitionException {
+		ANTLRv3Parser.elementOptions_return retval = new ANTLRv3Parser.elementOptions_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal114=null;
+		Token char_literal116=null;
+		Token char_literal117=null;
+		Token char_literal119=null;
+		Token char_literal121=null;
+		ParserRuleReturnScope qid115 =null;
+		ParserRuleReturnScope option118 =null;
+		ParserRuleReturnScope option120 =null;
+
+		CommonTree char_literal114_tree=null;
+		CommonTree char_literal116_tree=null;
+		CommonTree char_literal117_tree=null;
+		CommonTree char_literal119_tree=null;
+		CommonTree char_literal121_tree=null;
+		RewriteRuleTokenStream stream_77=new RewriteRuleTokenStream(adaptor,"token 77");
+		RewriteRuleTokenStream stream_79=new RewriteRuleTokenStream(adaptor,"token 79");
+		RewriteRuleTokenStream stream_76=new RewriteRuleTokenStream(adaptor,"token 76");
+		RewriteRuleSubtreeStream stream_qid=new RewriteRuleSubtreeStream(adaptor,"rule qid");
+		RewriteRuleSubtreeStream stream_option=new RewriteRuleSubtreeStream(adaptor,"rule option");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:285:2: ( '<' qid '>' -> ^( OPTIONS qid ) | '<' option ( ';' option )* '>' -> ^( OPTIONS ( option )+ ) )
+			int alt59=2;
+			int LA59_0 = input.LA(1);
+			if ( (LA59_0==77) ) {
+				int LA59_1 = input.LA(2);
+				if ( (LA59_1==TOKEN_REF) ) {
+					int LA59_2 = input.LA(3);
+					if ( (LA59_2==73||LA59_2==79) ) {
+						alt59=1;
+					}
+					else if ( (LA59_2==LABEL_ASSIGN) ) {
+						alt59=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 59, 2, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+				else if ( (LA59_1==RULE_REF) ) {
+					int LA59_3 = input.LA(3);
+					if ( (LA59_3==73||LA59_3==79) ) {
+						alt59=1;
+					}
+					else if ( (LA59_3==LABEL_ASSIGN) ) {
+						alt59=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 59, 3, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 59, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 59, 0, input);
+				throw nvae;
+			}
+
+			switch (alt59) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:285:4: '<' qid '>'
+					{
+					char_literal114=(Token)match(input,77,FOLLOW_77_in_elementOptions2052); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_77.add(char_literal114);
+
+					pushFollow(FOLLOW_qid_in_elementOptions2054);
+					qid115=qid();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_qid.add(qid115.getTree());
+					char_literal116=(Token)match(input,79,FOLLOW_79_in_elementOptions2056); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_79.add(char_literal116);
+
+					// AST REWRITE
+					// elements: qid
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 285:21: -> ^( OPTIONS qid )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:285:24: ^( OPTIONS qid )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(OPTIONS, "OPTIONS"), root_1);
+						adaptor.addChild(root_1, stream_qid.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:286:4: '<' option ( ';' option )* '>'
+					{
+					char_literal117=(Token)match(input,77,FOLLOW_77_in_elementOptions2074); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_77.add(char_literal117);
+
+					pushFollow(FOLLOW_option_in_elementOptions2076);
+					option118=option();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_option.add(option118.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:286:15: ( ';' option )*
+					loop58:
+					while (true) {
+						int alt58=2;
+						int LA58_0 = input.LA(1);
+						if ( (LA58_0==76) ) {
+							alt58=1;
+						}
+
+						switch (alt58) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:286:16: ';' option
+							{
+							char_literal119=(Token)match(input,76,FOLLOW_76_in_elementOptions2079); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_76.add(char_literal119);
+
+							pushFollow(FOLLOW_option_in_elementOptions2081);
+							option120=option();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_option.add(option120.getTree());
+							}
+							break;
+
+						default :
+							break loop58;
+						}
+					}
+
+					char_literal121=(Token)match(input,79,FOLLOW_79_in_elementOptions2085); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_79.add(char_literal121);
+
+					// AST REWRITE
+					// elements: option
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 286:33: -> ^( OPTIONS ( option )+ )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:286:36: ^( OPTIONS ( option )+ )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(OPTIONS, "OPTIONS"), root_1);
+						if ( !(stream_option.hasNext()) ) {
+							throw new RewriteEarlyExitException();
+						}
+						while ( stream_option.hasNext() ) {
+							adaptor.addChild(root_1, stream_option.nextTree());
+						}
+						stream_option.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "elementOptions"
+
+
+	public static class elementOption_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "elementOption"
+	// org/antlr/grammar/v3/ANTLRv3.g:289:1: elementOption : id '=' optionValue -> ^( '=' id optionValue ) ;
+	public final ANTLRv3Parser.elementOption_return elementOption() throws RecognitionException {
+		ANTLRv3Parser.elementOption_return retval = new ANTLRv3Parser.elementOption_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal123=null;
+		ParserRuleReturnScope id122 =null;
+		ParserRuleReturnScope optionValue124 =null;
+
+		CommonTree char_literal123_tree=null;
+		RewriteRuleTokenStream stream_LABEL_ASSIGN=new RewriteRuleTokenStream(adaptor,"token LABEL_ASSIGN");
+		RewriteRuleSubtreeStream stream_optionValue=new RewriteRuleSubtreeStream(adaptor,"rule optionValue");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:290:2: ( id '=' optionValue -> ^( '=' id optionValue ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:290:4: id '=' optionValue
+			{
+			pushFollow(FOLLOW_id_in_elementOption2105);
+			id122=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id122.getTree());
+			char_literal123=(Token)match(input,LABEL_ASSIGN,FOLLOW_LABEL_ASSIGN_in_elementOption2107); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_LABEL_ASSIGN.add(char_literal123);
+
+			pushFollow(FOLLOW_optionValue_in_elementOption2109);
+			optionValue124=optionValue();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_optionValue.add(optionValue124.getTree());
+			// AST REWRITE
+			// elements: optionValue, LABEL_ASSIGN, id
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 290:23: -> ^( '=' id optionValue )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:290:26: ^( '=' id optionValue )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_LABEL_ASSIGN.nextNode(), root_1);
+				adaptor.addChild(root_1, stream_id.nextTree());
+				adaptor.addChild(root_1, stream_optionValue.nextTree());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "elementOption"
+
+
+	public static class treeSpec_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "treeSpec"
+	// org/antlr/grammar/v3/ANTLRv3.g:293:1: treeSpec : '^(' element ( element )+ ')' -> ^( TREE_BEGIN ( element )+ ) ;
+	public final ANTLRv3Parser.treeSpec_return treeSpec() throws RecognitionException {
+		ANTLRv3Parser.treeSpec_return retval = new ANTLRv3Parser.treeSpec_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token string_literal125=null;
+		Token char_literal128=null;
+		ParserRuleReturnScope element126 =null;
+		ParserRuleReturnScope element127 =null;
+
+		CommonTree string_literal125_tree=null;
+		CommonTree char_literal128_tree=null;
+		RewriteRuleTokenStream stream_69=new RewriteRuleTokenStream(adaptor,"token 69");
+		RewriteRuleTokenStream stream_TREE_BEGIN=new RewriteRuleTokenStream(adaptor,"token TREE_BEGIN");
+		RewriteRuleSubtreeStream stream_element=new RewriteRuleSubtreeStream(adaptor,"rule element");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:294:2: ( '^(' element ( element )+ ')' -> ^( TREE_BEGIN ( element )+ ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:294:4: '^(' element ( element )+ ')'
+			{
+			string_literal125=(Token)match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_treeSpec2131); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_TREE_BEGIN.add(string_literal125);
+
+			pushFollow(FOLLOW_element_in_treeSpec2133);
+			element126=element();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_element.add(element126.getTree());
+			// org/antlr/grammar/v3/ANTLRv3.g:294:17: ( element )+
+			int cnt60=0;
+			loop60:
+			while (true) {
+				int alt60=2;
+				int LA60_0 = input.LA(1);
+				if ( (LA60_0==ACTION||LA60_0==CHAR_LITERAL||LA60_0==RULE_REF||LA60_0==SEMPRED||LA60_0==STRING_LITERAL||(LA60_0 >= TOKEN_REF && LA60_0 <= TREE_BEGIN)||LA60_0==68||LA60_0==73||LA60_0==93) ) {
+					alt60=1;
+				}
+
+				switch (alt60) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:294:19: element
+					{
+					pushFollow(FOLLOW_element_in_treeSpec2137);
+					element127=element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_element.add(element127.getTree());
+					}
+					break;
+
+				default :
+					if ( cnt60 >= 1 ) break loop60;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(60, input);
+					throw eee;
+				}
+				cnt60++;
+			}
+
+			char_literal128=(Token)match(input,69,FOLLOW_69_in_treeSpec2142); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_69.add(char_literal128);
+
+			// AST REWRITE
+			// elements: element
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 294:34: -> ^( TREE_BEGIN ( element )+ )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:294:37: ^( TREE_BEGIN ( element )+ )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(TREE_BEGIN, "TREE_BEGIN"), root_1);
+				if ( !(stream_element.hasNext()) ) {
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_element.hasNext() ) {
+					adaptor.addChild(root_1, stream_element.nextTree());
+				}
+				stream_element.reset();
+
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "treeSpec"
+
+
+	public static class range_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "range"
+	// org/antlr/grammar/v3/ANTLRv3.g:297:1: range : c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL ( elementOptions )? -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2 ( elementOptions )? ) ;
+	public final ANTLRv3Parser.range_return range() throws RecognitionException {
+		ANTLRv3Parser.range_return retval = new ANTLRv3Parser.range_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token c1=null;
+		Token c2=null;
+		Token RANGE129=null;
+		ParserRuleReturnScope elementOptions130 =null;
+
+		CommonTree c1_tree=null;
+		CommonTree c2_tree=null;
+		CommonTree RANGE129_tree=null;
+		RewriteRuleTokenStream stream_CHAR_LITERAL=new RewriteRuleTokenStream(adaptor,"token CHAR_LITERAL");
+		RewriteRuleTokenStream stream_RANGE=new RewriteRuleTokenStream(adaptor,"token RANGE");
+		RewriteRuleSubtreeStream stream_elementOptions=new RewriteRuleSubtreeStream(adaptor,"rule elementOptions");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:298:2: (c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL ( elementOptions )? -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2 ( elementOptions )? ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:298:4: c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL ( elementOptions )?
+			{
+			c1=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_range2165); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_CHAR_LITERAL.add(c1);
+
+			RANGE129=(Token)match(input,RANGE,FOLLOW_RANGE_in_range2167); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_RANGE.add(RANGE129);
+
+			c2=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_range2171); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_CHAR_LITERAL.add(c2);
+
+			// org/antlr/grammar/v3/ANTLRv3.g:298:42: ( elementOptions )?
+			int alt61=2;
+			int LA61_0 = input.LA(1);
+			if ( (LA61_0==77) ) {
+				alt61=1;
+			}
+			switch (alt61) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:298:42: elementOptions
+					{
+					pushFollow(FOLLOW_elementOptions_in_range2173);
+					elementOptions130=elementOptions();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_elementOptions.add(elementOptions130.getTree());
+					}
+					break;
+
+			}
+
+			// AST REWRITE
+			// elements: elementOptions, c1, c2
+			// token labels: c1, c2
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleTokenStream stream_c1=new RewriteRuleTokenStream(adaptor,"token c1",c1);
+			RewriteRuleTokenStream stream_c2=new RewriteRuleTokenStream(adaptor,"token c2",c2);
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 299:3: -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2 ( elementOptions )? )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:299:6: ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2 ( elementOptions )? )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(CHAR_RANGE, c1, ".."), root_1);
+				adaptor.addChild(root_1, stream_c1.nextNode());
+				adaptor.addChild(root_1, stream_c2.nextNode());
+				// org/antlr/grammar/v3/ANTLRv3.g:299:37: ( elementOptions )?
+				if ( stream_elementOptions.hasNext() ) {
+					adaptor.addChild(root_1, stream_elementOptions.nextTree());
+				}
+				stream_elementOptions.reset();
+
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "range"
+
+
+	public static class terminal_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "terminal"
+	// org/antlr/grammar/v3/ANTLRv3.g:302:1: terminal : ( CHAR_LITERAL ( elementOptions )? -> ^( CHAR_LITERAL ( elementOptions )? ) | TOKEN_REF ( ARG_ACTION )? ( elementOptions )? -> ^( TOKEN_REF ( ARG_ACTION )? ( elementOptions )? ) | STRING_LITERAL ( elementOptions )? -> ^( STRING_LITERAL ( elementOptions )? ) | '.' ( elementOptions )? -> ^( '.' ( elementOptions )? ) ) ( '^' -> ^( '^' $terminal) | '!' -> ^( '!' $terminal) )? ;
+	public final ANTLRv3Parser.terminal_return terminal() throws RecognitionException {
+		ANTLRv3Parser.terminal_return retval = new ANTLRv3Parser.terminal_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token CHAR_LITERAL131=null;
+		Token TOKEN_REF133=null;
+		Token ARG_ACTION134=null;
+		Token STRING_LITERAL136=null;
+		Token char_literal138=null;
+		Token char_literal140=null;
+		Token char_literal141=null;
+		ParserRuleReturnScope elementOptions132 =null;
+		ParserRuleReturnScope elementOptions135 =null;
+		ParserRuleReturnScope elementOptions137 =null;
+		ParserRuleReturnScope elementOptions139 =null;
+
+		CommonTree CHAR_LITERAL131_tree=null;
+		CommonTree TOKEN_REF133_tree=null;
+		CommonTree ARG_ACTION134_tree=null;
+		CommonTree STRING_LITERAL136_tree=null;
+		CommonTree char_literal138_tree=null;
+		CommonTree char_literal140_tree=null;
+		CommonTree char_literal141_tree=null;
+		RewriteRuleTokenStream stream_ROOT=new RewriteRuleTokenStream(adaptor,"token ROOT");
+		RewriteRuleTokenStream stream_BANG=new RewriteRuleTokenStream(adaptor,"token BANG");
+		RewriteRuleTokenStream stream_TOKEN_REF=new RewriteRuleTokenStream(adaptor,"token TOKEN_REF");
+		RewriteRuleTokenStream stream_ARG_ACTION=new RewriteRuleTokenStream(adaptor,"token ARG_ACTION");
+		RewriteRuleTokenStream stream_STRING_LITERAL=new RewriteRuleTokenStream(adaptor,"token STRING_LITERAL");
+		RewriteRuleTokenStream stream_CHAR_LITERAL=new RewriteRuleTokenStream(adaptor,"token CHAR_LITERAL");
+		RewriteRuleTokenStream stream_73=new RewriteRuleTokenStream(adaptor,"token 73");
+		RewriteRuleSubtreeStream stream_elementOptions=new RewriteRuleSubtreeStream(adaptor,"rule elementOptions");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:303:5: ( ( CHAR_LITERAL ( elementOptions )? -> ^( CHAR_LITERAL ( elementOptions )? ) | TOKEN_REF ( ARG_ACTION )? ( elementOptions )? -> ^( TOKEN_REF ( ARG_ACTION )? ( elementOptions )? ) | STRING_LITERAL ( elementOptions )? -> ^( STRING_LITERAL ( elementOptions )? ) | '.' ( elementOptions )? -> ^( '.' ( elementOptions )? ) ) ( '^' -> ^( '^' $terminal) | '!' -> ^( '!' $terminal) )? )
+			// org/antlr/grammar/v3/ANTLRv3.g:303:9: ( CHAR_LITERAL ( elementOptions )? -> ^( CHAR_LITERAL ( elementOptions )? ) | TOKEN_REF ( ARG_ACTION )? ( elementOptions )? -> ^( TOKEN_REF ( ARG_ACTION )? ( elementOptions )? ) | STRING_LITERAL ( elementOptions )? -> ^( STRING_LITERAL ( elementOptions )? ) | '.' ( elementOptions )? -> ^( '.' ( elementOptions )? ) ) ( '^' -> ^( '^' $terminal) | '!' -> ^( '!' $terminal) )?
+			{
+			// org/antlr/grammar/v3/ANTLRv3.g:303:9: ( CHAR_LITERAL ( elementOptions )? -> ^( CHAR_LITERAL ( elementOptions )? ) | TOKEN_REF ( ARG_ACTION )? ( elementOptions )? -> ^( TOKEN_REF ( ARG_ACTION )? ( elementOptions )? ) | STRING_LITERAL ( elementOptions )? -> ^( STRING_LITERAL ( elementOptions )? ) | '.' ( elementOptions )? -> ^( '.' ( elementOptions )? ) )
+			int alt67=4;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				alt67=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt67=2;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt67=3;
+				}
+				break;
+			case 73:
+				{
+				alt67=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 67, 0, input);
+				throw nvae;
+			}
+			switch (alt67) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:303:11: CHAR_LITERAL ( elementOptions )?
+					{
+					CHAR_LITERAL131=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_terminal2210); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_CHAR_LITERAL.add(CHAR_LITERAL131);
+
+					// org/antlr/grammar/v3/ANTLRv3.g:303:24: ( elementOptions )?
+					int alt62=2;
+					int LA62_0 = input.LA(1);
+					if ( (LA62_0==77) ) {
+						alt62=1;
+					}
+					switch (alt62) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:303:24: elementOptions
+							{
+							pushFollow(FOLLOW_elementOptions_in_terminal2212);
+							elementOptions132=elementOptions();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_elementOptions.add(elementOptions132.getTree());
+							}
+							break;
+
+					}
+
+					// AST REWRITE
+					// elements: CHAR_LITERAL, elementOptions
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 303:46: -> ^( CHAR_LITERAL ( elementOptions )? )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:303:49: ^( CHAR_LITERAL ( elementOptions )? )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_CHAR_LITERAL.nextNode(), root_1);
+						// org/antlr/grammar/v3/ANTLRv3.g:303:64: ( elementOptions )?
+						if ( stream_elementOptions.hasNext() ) {
+							adaptor.addChild(root_1, stream_elementOptions.nextTree());
+						}
+						stream_elementOptions.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:305:7: TOKEN_REF ( ARG_ACTION )? ( elementOptions )?
+					{
+					TOKEN_REF133=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_terminal2243); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_TOKEN_REF.add(TOKEN_REF133);
+
+					// org/antlr/grammar/v3/ANTLRv3.g:305:17: ( ARG_ACTION )?
+					int alt63=2;
+					int LA63_0 = input.LA(1);
+					if ( (LA63_0==ARG_ACTION) ) {
+						alt63=1;
+					}
+					switch (alt63) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:305:17: ARG_ACTION
+							{
+							ARG_ACTION134=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_terminal2245); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_ARG_ACTION.add(ARG_ACTION134);
+
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/ANTLRv3.g:305:29: ( elementOptions )?
+					int alt64=2;
+					int LA64_0 = input.LA(1);
+					if ( (LA64_0==77) ) {
+						alt64=1;
+					}
+					switch (alt64) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:305:29: elementOptions
+							{
+							pushFollow(FOLLOW_elementOptions_in_terminal2248);
+							elementOptions135=elementOptions();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_elementOptions.add(elementOptions135.getTree());
+							}
+							break;
+
+					}
+
+					// AST REWRITE
+					// elements: elementOptions, ARG_ACTION, TOKEN_REF
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 305:45: -> ^( TOKEN_REF ( ARG_ACTION )? ( elementOptions )? )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:305:48: ^( TOKEN_REF ( ARG_ACTION )? ( elementOptions )? )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_TOKEN_REF.nextNode(), root_1);
+						// org/antlr/grammar/v3/ANTLRv3.g:305:60: ( ARG_ACTION )?
+						if ( stream_ARG_ACTION.hasNext() ) {
+							adaptor.addChild(root_1, stream_ARG_ACTION.nextNode());
+						}
+						stream_ARG_ACTION.reset();
+
+						// org/antlr/grammar/v3/ANTLRv3.g:305:72: ( elementOptions )?
+						if ( stream_elementOptions.hasNext() ) {
+							adaptor.addChild(root_1, stream_elementOptions.nextTree());
+						}
+						stream_elementOptions.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:306:7: STRING_LITERAL ( elementOptions )?
+					{
+					STRING_LITERAL136=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_terminal2269); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_STRING_LITERAL.add(STRING_LITERAL136);
+
+					// org/antlr/grammar/v3/ANTLRv3.g:306:22: ( elementOptions )?
+					int alt65=2;
+					int LA65_0 = input.LA(1);
+					if ( (LA65_0==77) ) {
+						alt65=1;
+					}
+					switch (alt65) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:306:22: elementOptions
+							{
+							pushFollow(FOLLOW_elementOptions_in_terminal2271);
+							elementOptions137=elementOptions();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_elementOptions.add(elementOptions137.getTree());
+							}
+							break;
+
+					}
+
+					// AST REWRITE
+					// elements: elementOptions, STRING_LITERAL
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 306:41: -> ^( STRING_LITERAL ( elementOptions )? )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:306:44: ^( STRING_LITERAL ( elementOptions )? )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_STRING_LITERAL.nextNode(), root_1);
+						// org/antlr/grammar/v3/ANTLRv3.g:306:61: ( elementOptions )?
+						if ( stream_elementOptions.hasNext() ) {
+							adaptor.addChild(root_1, stream_elementOptions.nextTree());
+						}
+						stream_elementOptions.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:307:7: '.' ( elementOptions )?
+					{
+					char_literal138=(Token)match(input,73,FOLLOW_73_in_terminal2292); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_73.add(char_literal138);
+
+					// org/antlr/grammar/v3/ANTLRv3.g:307:11: ( elementOptions )?
+					int alt66=2;
+					int LA66_0 = input.LA(1);
+					if ( (LA66_0==77) ) {
+						alt66=1;
+					}
+					switch (alt66) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:307:11: elementOptions
+							{
+							pushFollow(FOLLOW_elementOptions_in_terminal2294);
+							elementOptions139=elementOptions();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_elementOptions.add(elementOptions139.getTree());
+							}
+							break;
+
+					}
+
+					// AST REWRITE
+					// elements: 73, elementOptions
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 307:34: -> ^( '.' ( elementOptions )? )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:307:37: ^( '.' ( elementOptions )? )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_73.nextNode(), root_1);
+						// org/antlr/grammar/v3/ANTLRv3.g:307:43: ( elementOptions )?
+						if ( stream_elementOptions.hasNext() ) {
+							adaptor.addChild(root_1, stream_elementOptions.nextTree());
+						}
+						stream_elementOptions.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3.g:309:3: ( '^' -> ^( '^' $terminal) | '!' -> ^( '!' $terminal) )?
+			int alt68=3;
+			int LA68_0 = input.LA(1);
+			if ( (LA68_0==ROOT) ) {
+				alt68=1;
+			}
+			else if ( (LA68_0==BANG) ) {
+				alt68=2;
+			}
+			switch (alt68) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:309:5: '^'
+					{
+					char_literal140=(Token)match(input,ROOT,FOLLOW_ROOT_in_terminal2321); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_ROOT.add(char_literal140);
+
+					// AST REWRITE
+					// elements: ROOT, terminal
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 309:15: -> ^( '^' $terminal)
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:309:18: ^( '^' $terminal)
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_ROOT.nextNode(), root_1);
+						adaptor.addChild(root_1, stream_retval.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:310:5: '!'
+					{
+					char_literal141=(Token)match(input,BANG,FOLLOW_BANG_in_terminal2342); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_BANG.add(char_literal141);
+
+					// AST REWRITE
+					// elements: terminal, BANG
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 310:15: -> ^( '!' $terminal)
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:310:18: ^( '!' $terminal)
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_BANG.nextNode(), root_1);
+						adaptor.addChild(root_1, stream_retval.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "terminal"
+
+
+	public static class ebnf_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ebnf"
+	// org/antlr/grammar/v3/ANTLRv3.g:315:1: ebnf : block (op= '?' -> ^( OPTIONAL[op] block ) |op= '*' -> ^( CLOSURE[op] block ) |op= '+' -> ^( POSITIVE_CLOSURE[op] block ) | '=>' -> {gtype==COMBINED_GRAMMAR &&\n\t\t\t\t\t Character.isUpperCase($rule::name.charAt(0))}? ^( SYNPRED[\"=>\"] block ) -> SYN_SEMPRED | -> block ) ;
+	public final ANTLRv3Parser.ebnf_return ebnf() throws RecognitionException {
+		ANTLRv3Parser.ebnf_return retval = new ANTLRv3Parser.ebnf_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token op=null;
+		Token string_literal143=null;
+		ParserRuleReturnScope block142 =null;
+
+		CommonTree op_tree=null;
+		CommonTree string_literal143_tree=null;
+		RewriteRuleTokenStream stream_78=new RewriteRuleTokenStream(adaptor,"token 78");
+		RewriteRuleTokenStream stream_80=new RewriteRuleTokenStream(adaptor,"token 80");
+		RewriteRuleTokenStream stream_70=new RewriteRuleTokenStream(adaptor,"token 70");
+		RewriteRuleTokenStream stream_71=new RewriteRuleTokenStream(adaptor,"token 71");
+		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
+
+
+		    Token firstToken = input.LT(1);
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:323:2: ( block (op= '?' -> ^( OPTIONAL[op] block ) |op= '*' -> ^( CLOSURE[op] block ) |op= '+' -> ^( POSITIVE_CLOSURE[op] block ) | '=>' -> {gtype==COMBINED_GRAMMAR &&\n\t\t\t\t\t Character.isUpperCase($rule::name.charAt(0))}? ^( SYNPRED[\"=>\"] block ) -> SYN_SEMPRED | -> block ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:323:4: block (op= '?' -> ^( OPTIONAL[op] block ) |op= '*' -> ^( CLOSURE[op] block ) |op= '+' -> ^( POSITIVE_CLOSURE[op] block ) | '=>' -> {gtype==COMBINED_GRAMMAR &&\n\t\t\t\t\t Character.isUpperCase($rule::name.charAt(0))}? ^( SYNPRED[\"=>\"] block ) -> SYN_SEMPRED | -> block )
+			{
+			pushFollow(FOLLOW_block_in_ebnf2385);
+			block142=block();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_block.add(block142.getTree());
+			// org/antlr/grammar/v3/ANTLRv3.g:324:3: (op= '?' -> ^( OPTIONAL[op] block ) |op= '*' -> ^( CLOSURE[op] block ) |op= '+' -> ^( POSITIVE_CLOSURE[op] block ) | '=>' -> {gtype==COMBINED_GRAMMAR &&\n\t\t\t\t\t Character.isUpperCase($rule::name.charAt(0))}? ^( SYNPRED[\"=>\"] block ) -> SYN_SEMPRED | -> block )
+			int alt69=5;
+			switch ( input.LA(1) ) {
+			case 80:
+				{
+				alt69=1;
+				}
+				break;
+			case 70:
+				{
+				alt69=2;
+				}
+				break;
+			case 71:
+				{
+				alt69=3;
+				}
+				break;
+			case 78:
+				{
+				alt69=4;
+				}
+				break;
+			case ACTION:
+			case CHAR_LITERAL:
+			case REWRITE:
+			case RULE_REF:
+			case SEMPRED:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case TREE_BEGIN:
+			case 68:
+			case 69:
+			case 73:
+			case 76:
+			case 91:
+			case 93:
+				{
+				alt69=5;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 69, 0, input);
+				throw nvae;
+			}
+			switch (alt69) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:324:5: op= '?'
+					{
+					op=(Token)match(input,80,FOLLOW_80_in_ebnf2393); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_80.add(op);
+
+					// AST REWRITE
+					// elements: block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 324:12: -> ^( OPTIONAL[op] block )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:324:15: ^( OPTIONAL[op] block )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(OPTIONAL, op), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:325:5: op= '*'
+					{
+					op=(Token)match(input,70,FOLLOW_70_in_ebnf2410); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_70.add(op);
+
+					// AST REWRITE
+					// elements: block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 325:12: -> ^( CLOSURE[op] block )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:325:15: ^( CLOSURE[op] block )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(CLOSURE, op), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:326:5: op= '+'
+					{
+					op=(Token)match(input,71,FOLLOW_71_in_ebnf2427); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_71.add(op);
+
+					// AST REWRITE
+					// elements: block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 326:12: -> ^( POSITIVE_CLOSURE[op] block )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:326:15: ^( POSITIVE_CLOSURE[op] block )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(POSITIVE_CLOSURE, op), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:327:7: '=>'
+					{
+					string_literal143=(Token)match(input,78,FOLLOW_78_in_ebnf2444); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_78.add(string_literal143);
+
+					// AST REWRITE
+					// elements: block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 328:6: -> {gtype==COMBINED_GRAMMAR &&\n\t\t\t\t\t Character.isUpperCase($rule::name.charAt(0))}? ^( SYNPRED[\"=>\"] block )
+					if (gtype==COMBINED_GRAMMAR &&
+										    Character.isUpperCase(rule_stack.peek().name.charAt(0))) {
+						// org/antlr/grammar/v3/ANTLRv3.g:331:9: ^( SYNPRED[\"=>\"] block )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(SYNPRED, "=>"), root_1);
+						adaptor.addChild(root_1, stream_block.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+					else // 333:6: -> SYN_SEMPRED
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(SYN_SEMPRED, "SYN_SEMPRED"));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRv3.g:334:13: 
+					{
+					// AST REWRITE
+					// elements: block
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 334:13: -> block
+					{
+						adaptor.addChild(root_0, stream_block.nextTree());
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+			if ( state.backtracking==0 ) {
+				retval.tree.getToken().setLine(firstToken.getLine());
+				retval.tree.getToken().setCharPositionInLine(firstToken.getCharPositionInLine());
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ebnf"
+
+
+	public static class ebnfSuffix_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "ebnfSuffix"
+	// org/antlr/grammar/v3/ANTLRv3.g:338:1: ebnfSuffix : ( '?' -> OPTIONAL[op] | '*' -> CLOSURE[op] | '+' -> POSITIVE_CLOSURE[op] );
+	public final ANTLRv3Parser.ebnfSuffix_return ebnfSuffix() throws RecognitionException {
+		ANTLRv3Parser.ebnfSuffix_return retval = new ANTLRv3Parser.ebnfSuffix_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal144=null;
+		Token char_literal145=null;
+		Token char_literal146=null;
+
+		CommonTree char_literal144_tree=null;
+		CommonTree char_literal145_tree=null;
+		CommonTree char_literal146_tree=null;
+		RewriteRuleTokenStream stream_80=new RewriteRuleTokenStream(adaptor,"token 80");
+		RewriteRuleTokenStream stream_70=new RewriteRuleTokenStream(adaptor,"token 70");
+		RewriteRuleTokenStream stream_71=new RewriteRuleTokenStream(adaptor,"token 71");
+
+
+			Token op = input.LT(1);
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:342:2: ( '?' -> OPTIONAL[op] | '*' -> CLOSURE[op] | '+' -> POSITIVE_CLOSURE[op] )
+			int alt70=3;
+			switch ( input.LA(1) ) {
+			case 80:
+				{
+				alt70=1;
+				}
+				break;
+			case 70:
+				{
+				alt70=2;
+				}
+				break;
+			case 71:
+				{
+				alt70=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 70, 0, input);
+				throw nvae;
+			}
+			switch (alt70) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:342:4: '?'
+					{
+					char_literal144=(Token)match(input,80,FOLLOW_80_in_ebnfSuffix2529); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_80.add(char_literal144);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 342:8: -> OPTIONAL[op]
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(OPTIONAL, op));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:343:6: '*'
+					{
+					char_literal145=(Token)match(input,70,FOLLOW_70_in_ebnfSuffix2541); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_70.add(char_literal145);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 343:10: -> CLOSURE[op]
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(CLOSURE, op));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:344:7: '+'
+					{
+					char_literal146=(Token)match(input,71,FOLLOW_71_in_ebnfSuffix2554); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_71.add(char_literal146);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 344:11: -> POSITIVE_CLOSURE[op]
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(POSITIVE_CLOSURE, op));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ebnfSuffix"
+
+
+	public static class rewrite_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite"
+	// org/antlr/grammar/v3/ANTLRv3.g:351:1: rewrite : ( (rew+= '->' preds+= SEMPRED predicated+= rewrite_alternative )* rew2= '->' last= rewrite_alternative -> ( ^( $rew $preds $predicated) )* ^( $rew2 $last) |);
+	public final ANTLRv3Parser.rewrite_return rewrite() throws RecognitionException {
+		ANTLRv3Parser.rewrite_return retval = new ANTLRv3Parser.rewrite_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token rew2=null;
+		Token rew=null;
+		Token preds=null;
+		List<Object> list_rew=null;
+		List<Object> list_preds=null;
+		List<Object> list_predicated=null;
+		ParserRuleReturnScope last =null;
+		RuleReturnScope predicated = null;
+		CommonTree rew2_tree=null;
+		CommonTree rew_tree=null;
+		CommonTree preds_tree=null;
+		RewriteRuleTokenStream stream_REWRITE=new RewriteRuleTokenStream(adaptor,"token REWRITE");
+		RewriteRuleTokenStream stream_SEMPRED=new RewriteRuleTokenStream(adaptor,"token SEMPRED");
+		RewriteRuleSubtreeStream stream_rewrite_alternative=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_alternative");
+
+
+			Token firstToken = input.LT(1);
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:355:2: ( (rew+= '->' preds+= SEMPRED predicated+= rewrite_alternative )* rew2= '->' last= rewrite_alternative -> ( ^( $rew $preds $predicated) )* ^( $rew2 $last) |)
+			int alt72=2;
+			int LA72_0 = input.LA(1);
+			if ( (LA72_0==REWRITE) ) {
+				alt72=1;
+			}
+			else if ( (LA72_0==69||LA72_0==76||LA72_0==91) ) {
+				alt72=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 72, 0, input);
+				throw nvae;
+			}
+
+			switch (alt72) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:355:4: (rew+= '->' preds+= SEMPRED predicated+= rewrite_alternative )* rew2= '->' last= rewrite_alternative
+					{
+					// org/antlr/grammar/v3/ANTLRv3.g:355:4: (rew+= '->' preds+= SEMPRED predicated+= rewrite_alternative )*
+					loop71:
+					while (true) {
+						int alt71=2;
+						int LA71_0 = input.LA(1);
+						if ( (LA71_0==REWRITE) ) {
+							int LA71_1 = input.LA(2);
+							if ( (LA71_1==SEMPRED) ) {
+								alt71=1;
+							}
+
+						}
+
+						switch (alt71) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:355:5: rew+= '->' preds+= SEMPRED predicated+= rewrite_alternative
+							{
+							rew=(Token)match(input,REWRITE,FOLLOW_REWRITE_in_rewrite2583); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_REWRITE.add(rew);
+
+							if (list_rew==null) list_rew=new ArrayList<Object>();
+							list_rew.add(rew);
+							preds=(Token)match(input,SEMPRED,FOLLOW_SEMPRED_in_rewrite2587); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_SEMPRED.add(preds);
+
+							if (list_preds==null) list_preds=new ArrayList<Object>();
+							list_preds.add(preds);
+							pushFollow(FOLLOW_rewrite_alternative_in_rewrite2591);
+							predicated=rewrite_alternative();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_rewrite_alternative.add(predicated.getTree());
+							if (list_predicated==null) list_predicated=new ArrayList<Object>();
+							list_predicated.add(predicated.getTree());
+							}
+							break;
+
+						default :
+							break loop71;
+						}
+					}
+
+					rew2=(Token)match(input,REWRITE,FOLLOW_REWRITE_in_rewrite2599); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_REWRITE.add(rew2);
+
+					pushFollow(FOLLOW_rewrite_alternative_in_rewrite2603);
+					last=rewrite_alternative();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_alternative.add(last.getTree());
+					// AST REWRITE
+					// elements: predicated, rew, rew2, preds, last
+					// token labels: rew2
+					// rule labels: last, retval
+					// token list labels: rew, preds
+					// rule list labels: predicated
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleTokenStream stream_rew2=new RewriteRuleTokenStream(adaptor,"token rew2",rew2);
+					RewriteRuleTokenStream stream_rew=new RewriteRuleTokenStream(adaptor,"token rew", list_rew);
+					RewriteRuleTokenStream stream_preds=new RewriteRuleTokenStream(adaptor,"token preds", list_preds);
+					RewriteRuleSubtreeStream stream_last=new RewriteRuleSubtreeStream(adaptor,"rule last",last!=null?last.getTree():null);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+					RewriteRuleSubtreeStream stream_predicated=new RewriteRuleSubtreeStream(adaptor,"token predicated",list_predicated);
+					root_0 = (CommonTree)adaptor.nil();
+					// 357:9: -> ( ^( $rew $preds $predicated) )* ^( $rew2 $last)
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:357:12: ( ^( $rew $preds $predicated) )*
+						while ( stream_predicated.hasNext()||stream_rew.hasNext()||stream_preds.hasNext() ) {
+							// org/antlr/grammar/v3/ANTLRv3.g:357:12: ^( $rew $preds $predicated)
+							{
+							CommonTree root_1 = (CommonTree)adaptor.nil();
+							root_1 = (CommonTree)adaptor.becomeRoot(stream_rew.nextNode(), root_1);
+							adaptor.addChild(root_1, stream_preds.nextNode());
+							adaptor.addChild(root_1, stream_predicated.nextTree());
+							adaptor.addChild(root_0, root_1);
+							}
+
+						}
+						stream_predicated.reset();
+						stream_rew.reset();
+						stream_preds.reset();
+
+						// org/antlr/grammar/v3/ANTLRv3.g:357:40: ^( $rew2 $last)
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_rew2.nextNode(), root_1);
+						adaptor.addChild(root_1, stream_last.nextTree());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:359:2: 
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite"
+
+
+	public static class rewrite_alternative_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_alternative"
+	// org/antlr/grammar/v3/ANTLRv3.g:361:1: rewrite_alternative options {backtrack=true; } : ( rewrite_template | rewrite_tree_alternative | -> ^( ALT[\"ALT\"] EPSILON[\"EPSILON\"] EOA[\"EOA\"] ) );
+	public final ANTLRv3Parser.rewrite_alternative_return rewrite_alternative() throws RecognitionException {
+		ANTLRv3Parser.rewrite_alternative_return retval = new ANTLRv3Parser.rewrite_alternative_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		ParserRuleReturnScope rewrite_template147 =null;
+		ParserRuleReturnScope rewrite_tree_alternative148 =null;
+
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:363:2: ( rewrite_template | rewrite_tree_alternative | -> ^( ALT[\"ALT\"] EPSILON[\"EPSILON\"] EOA[\"EOA\"] ) )
+			int alt73=3;
+			switch ( input.LA(1) ) {
+			case TOKEN_REF:
+				{
+				int LA73_1 = input.LA(2);
+				if ( (LA73_1==68) ) {
+					switch ( input.LA(3) ) {
+					case TOKEN_REF:
+						{
+						int LA73_10 = input.LA(4);
+						if ( (LA73_10==LABEL_ASSIGN) ) {
+							alt73=1;
+						}
+						else if ( (LA73_10==ACTION||LA73_10==ARG_ACTION||LA73_10==CHAR_LITERAL||LA73_10==RULE_REF||LA73_10==STRING_LITERAL||(LA73_10 >= TOKEN_REF && LA73_10 <= TREE_BEGIN)||(LA73_10 >= 67 && LA73_10 <= 71)||LA73_10==80) ) {
+							alt73=2;
+						}
+
+						else {
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 73, 10, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+						}
+						break;
+					case RULE_REF:
+						{
+						int LA73_11 = input.LA(4);
+						if ( (LA73_11==LABEL_ASSIGN) ) {
+							alt73=1;
+						}
+						else if ( (LA73_11==ACTION||LA73_11==CHAR_LITERAL||LA73_11==RULE_REF||LA73_11==STRING_LITERAL||(LA73_11 >= TOKEN_REF && LA73_11 <= TREE_BEGIN)||(LA73_11 >= 67 && LA73_11 <= 71)||LA73_11==80) ) {
+							alt73=2;
+						}
+
+						else {
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 73, 11, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+						}
+						break;
+					case 69:
+						{
+						alt73=1;
+						}
+						break;
+					case ACTION:
+					case CHAR_LITERAL:
+					case STRING_LITERAL:
+					case TREE_BEGIN:
+					case 67:
+					case 68:
+						{
+						alt73=2;
+						}
+						break;
+					default:
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 73, 7, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+				}
+				else if ( (LA73_1==ACTION||LA73_1==ARG_ACTION||LA73_1==CHAR_LITERAL||LA73_1==REWRITE||LA73_1==RULE_REF||LA73_1==STRING_LITERAL||(LA73_1 >= TOKEN_REF && LA73_1 <= TREE_BEGIN)||LA73_1==67||(LA73_1 >= 69 && LA73_1 <= 71)||LA73_1==76||LA73_1==80||LA73_1==91) ) {
+					alt73=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 73, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case RULE_REF:
+				{
+				int LA73_2 = input.LA(2);
+				if ( (LA73_2==68) ) {
+					switch ( input.LA(3) ) {
+					case TOKEN_REF:
+						{
+						int LA73_10 = input.LA(4);
+						if ( (LA73_10==LABEL_ASSIGN) ) {
+							alt73=1;
+						}
+						else if ( (LA73_10==ACTION||LA73_10==ARG_ACTION||LA73_10==CHAR_LITERAL||LA73_10==RULE_REF||LA73_10==STRING_LITERAL||(LA73_10 >= TOKEN_REF && LA73_10 <= TREE_BEGIN)||(LA73_10 >= 67 && LA73_10 <= 71)||LA73_10==80) ) {
+							alt73=2;
+						}
+
+						else {
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 73, 10, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+						}
+						break;
+					case RULE_REF:
+						{
+						int LA73_11 = input.LA(4);
+						if ( (LA73_11==LABEL_ASSIGN) ) {
+							alt73=1;
+						}
+						else if ( (LA73_11==ACTION||LA73_11==CHAR_LITERAL||LA73_11==RULE_REF||LA73_11==STRING_LITERAL||(LA73_11 >= TOKEN_REF && LA73_11 <= TREE_BEGIN)||(LA73_11 >= 67 && LA73_11 <= 71)||LA73_11==80) ) {
+							alt73=2;
+						}
+
+						else {
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 73, 11, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+						}
+						break;
+					case 69:
+						{
+						alt73=1;
+						}
+						break;
+					case ACTION:
+					case CHAR_LITERAL:
+					case STRING_LITERAL:
+					case TREE_BEGIN:
+					case 67:
+					case 68:
+						{
+						alt73=2;
+						}
+						break;
+					default:
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 73, 7, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+				}
+				else if ( (LA73_2==ACTION||LA73_2==CHAR_LITERAL||LA73_2==REWRITE||LA73_2==RULE_REF||LA73_2==STRING_LITERAL||(LA73_2 >= TOKEN_REF && LA73_2 <= TREE_BEGIN)||LA73_2==67||(LA73_2 >= 69 && LA73_2 <= 71)||LA73_2==76||LA73_2==80||LA73_2==91) ) {
+					alt73=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 73, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case 68:
+				{
+				int LA73_3 = input.LA(2);
+				if ( (LA73_3==ACTION) ) {
+					int LA73_8 = input.LA(3);
+					if ( (LA73_8==69) ) {
+						int LA73_12 = input.LA(4);
+						if ( (LA73_12==68) ) {
+							alt73=1;
+						}
+						else if ( ((LA73_12 >= 70 && LA73_12 <= 71)||LA73_12==80) ) {
+							alt73=2;
+						}
+
+						else {
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 73, 12, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+					}
+					else if ( (LA73_8==ACTION||LA73_8==CHAR_LITERAL||LA73_8==RULE_REF||LA73_8==STRING_LITERAL||(LA73_8 >= TOKEN_REF && LA73_8 <= TREE_BEGIN)||(LA73_8 >= 67 && LA73_8 <= 68)||(LA73_8 >= 70 && LA73_8 <= 71)||LA73_8==80) ) {
+						alt73=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 73, 8, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+				else if ( (LA73_3==CHAR_LITERAL||LA73_3==RULE_REF||LA73_3==STRING_LITERAL||(LA73_3 >= TOKEN_REF && LA73_3 <= TREE_BEGIN)||(LA73_3 >= 67 && LA73_3 <= 68)) ) {
+					alt73=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 73, 3, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case ACTION:
+				{
+				int LA73_4 = input.LA(2);
+				if ( (synpred1_ANTLRv3()) ) {
+					alt73=1;
+				}
+				else if ( (synpred2_ANTLRv3()) ) {
+					alt73=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 73, 4, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case CHAR_LITERAL:
+			case STRING_LITERAL:
+			case TREE_BEGIN:
+			case 67:
+				{
+				alt73=2;
+				}
+				break;
+			case REWRITE:
+			case 69:
+			case 76:
+			case 91:
+				{
+				alt73=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 73, 0, input);
+				throw nvae;
+			}
+			switch (alt73) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:363:4: rewrite_template
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_rewrite_template_in_rewrite_alternative2654);
+					rewrite_template147=rewrite_template();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_template147.getTree());
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:364:4: rewrite_tree_alternative
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_rewrite_tree_alternative_in_rewrite_alternative2659);
+					rewrite_tree_alternative148=rewrite_tree_alternative();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_tree_alternative148.getTree());
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:365:29: 
+					{
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 365:29: -> ^( ALT[\"ALT\"] EPSILON[\"EPSILON\"] EOA[\"EOA\"] )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:365:32: ^( ALT[\"ALT\"] EPSILON[\"EPSILON\"] EOA[\"EOA\"] )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ALT, "ALT"), root_1);
+						adaptor.addChild(root_1, (CommonTree)adaptor.create(EPSILON, "EPSILON"));
+						adaptor.addChild(root_1, (CommonTree)adaptor.create(EOA, "EOA"));
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_alternative"
+
+
+	public static class rewrite_tree_block_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_tree_block"
+	// org/antlr/grammar/v3/ANTLRv3.g:368:1: rewrite_tree_block : lp= '(' rewrite_tree_alternative ')' -> ^( BLOCK[$lp,\"BLOCK\"] rewrite_tree_alternative EOB[$lp,\"EOB\"] ) ;
+	public final ANTLRv3Parser.rewrite_tree_block_return rewrite_tree_block() throws RecognitionException {
+		ANTLRv3Parser.rewrite_tree_block_return retval = new ANTLRv3Parser.rewrite_tree_block_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token lp=null;
+		Token char_literal150=null;
+		ParserRuleReturnScope rewrite_tree_alternative149 =null;
+
+		CommonTree lp_tree=null;
+		CommonTree char_literal150_tree=null;
+		RewriteRuleTokenStream stream_68=new RewriteRuleTokenStream(adaptor,"token 68");
+		RewriteRuleTokenStream stream_69=new RewriteRuleTokenStream(adaptor,"token 69");
+		RewriteRuleSubtreeStream stream_rewrite_tree_alternative=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree_alternative");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:369:5: (lp= '(' rewrite_tree_alternative ')' -> ^( BLOCK[$lp,\"BLOCK\"] rewrite_tree_alternative EOB[$lp,\"EOB\"] ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:369:9: lp= '(' rewrite_tree_alternative ')'
+			{
+			lp=(Token)match(input,68,FOLLOW_68_in_rewrite_tree_block2701); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_68.add(lp);
+
+			pushFollow(FOLLOW_rewrite_tree_alternative_in_rewrite_tree_block2703);
+			rewrite_tree_alternative149=rewrite_tree_alternative();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite_tree_alternative.add(rewrite_tree_alternative149.getTree());
+			char_literal150=(Token)match(input,69,FOLLOW_69_in_rewrite_tree_block2705); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_69.add(char_literal150);
+
+			// AST REWRITE
+			// elements: rewrite_tree_alternative
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 370:6: -> ^( BLOCK[$lp,\"BLOCK\"] rewrite_tree_alternative EOB[$lp,\"EOB\"] )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:370:9: ^( BLOCK[$lp,\"BLOCK\"] rewrite_tree_alternative EOB[$lp,\"EOB\"] )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(BLOCK, lp, "BLOCK"), root_1);
+				adaptor.addChild(root_1, stream_rewrite_tree_alternative.nextTree());
+				adaptor.addChild(root_1, (CommonTree)adaptor.create(EOB, lp, "EOB"));
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_tree_block"
+
+
+	public static class rewrite_tree_alternative_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_tree_alternative"
+	// org/antlr/grammar/v3/ANTLRv3.g:373:1: rewrite_tree_alternative : ( rewrite_tree_element )+ -> ^( ALT[\"ALT\"] ( rewrite_tree_element )+ EOA[\"EOA\"] ) ;
+	public final ANTLRv3Parser.rewrite_tree_alternative_return rewrite_tree_alternative() throws RecognitionException {
+		ANTLRv3Parser.rewrite_tree_alternative_return retval = new ANTLRv3Parser.rewrite_tree_alternative_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		ParserRuleReturnScope rewrite_tree_element151 =null;
+
+		RewriteRuleSubtreeStream stream_rewrite_tree_element=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree_element");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:374:5: ( ( rewrite_tree_element )+ -> ^( ALT[\"ALT\"] ( rewrite_tree_element )+ EOA[\"EOA\"] ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:374:7: ( rewrite_tree_element )+
+			{
+			// org/antlr/grammar/v3/ANTLRv3.g:374:7: ( rewrite_tree_element )+
+			int cnt74=0;
+			loop74:
+			while (true) {
+				int alt74=2;
+				int LA74_0 = input.LA(1);
+				if ( (LA74_0==ACTION||LA74_0==CHAR_LITERAL||LA74_0==RULE_REF||LA74_0==STRING_LITERAL||(LA74_0 >= TOKEN_REF && LA74_0 <= TREE_BEGIN)||(LA74_0 >= 67 && LA74_0 <= 68)) ) {
+					alt74=1;
+				}
+
+				switch (alt74) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:374:7: rewrite_tree_element
+					{
+					pushFollow(FOLLOW_rewrite_tree_element_in_rewrite_tree_alternative2739);
+					rewrite_tree_element151=rewrite_tree_element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_tree_element.add(rewrite_tree_element151.getTree());
+					}
+					break;
+
+				default :
+					if ( cnt74 >= 1 ) break loop74;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(74, input);
+					throw eee;
+				}
+				cnt74++;
+			}
+
+			// AST REWRITE
+			// elements: rewrite_tree_element
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 374:29: -> ^( ALT[\"ALT\"] ( rewrite_tree_element )+ EOA[\"EOA\"] )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:374:32: ^( ALT[\"ALT\"] ( rewrite_tree_element )+ EOA[\"EOA\"] )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ALT, "ALT"), root_1);
+				if ( !(stream_rewrite_tree_element.hasNext()) ) {
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_rewrite_tree_element.hasNext() ) {
+					adaptor.addChild(root_1, stream_rewrite_tree_element.nextTree());
+				}
+				stream_rewrite_tree_element.reset();
+
+				adaptor.addChild(root_1, (CommonTree)adaptor.create(EOA, "EOA"));
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_tree_alternative"
+
+
+	public static class rewrite_tree_element_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_tree_element"
+	// org/antlr/grammar/v3/ANTLRv3.g:377:1: rewrite_tree_element : ( rewrite_tree_atom | rewrite_tree_atom ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree_atom EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | rewrite_tree ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> rewrite_tree ) | rewrite_tree_ebnf );
+	public final ANTLRv3Parser.rewrite_tree_element_return rewrite_tree_element() throws RecognitionException {
+		ANTLRv3Parser.rewrite_tree_element_return retval = new ANTLRv3Parser.rewrite_tree_element_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		ParserRuleReturnScope rewrite_tree_atom152 =null;
+		ParserRuleReturnScope rewrite_tree_atom153 =null;
+		ParserRuleReturnScope ebnfSuffix154 =null;
+		ParserRuleReturnScope rewrite_tree155 =null;
+		ParserRuleReturnScope ebnfSuffix156 =null;
+		ParserRuleReturnScope rewrite_tree_ebnf157 =null;
+
+		RewriteRuleSubtreeStream stream_rewrite_tree_atom=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree_atom");
+		RewriteRuleSubtreeStream stream_ebnfSuffix=new RewriteRuleSubtreeStream(adaptor,"rule ebnfSuffix");
+		RewriteRuleSubtreeStream stream_rewrite_tree=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:378:2: ( rewrite_tree_atom | rewrite_tree_atom ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree_atom EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | rewrite_tree ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> rewrite_tree ) | rewrite_tree_ebnf )
+			int alt76=4;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				int LA76_1 = input.LA(2);
+				if ( (LA76_1==EOF||LA76_1==ACTION||LA76_1==CHAR_LITERAL||LA76_1==REWRITE||LA76_1==RULE_REF||LA76_1==STRING_LITERAL||(LA76_1 >= TOKEN_REF && LA76_1 <= TREE_BEGIN)||(LA76_1 >= 67 && LA76_1 <= 69)||LA76_1==76||LA76_1==91) ) {
+					alt76=1;
+				}
+				else if ( ((LA76_1 >= 70 && LA76_1 <= 71)||LA76_1==80) ) {
+					alt76=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 76, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case TOKEN_REF:
+				{
+				switch ( input.LA(2) ) {
+				case ARG_ACTION:
+					{
+					int LA76_11 = input.LA(3);
+					if ( (LA76_11==EOF||LA76_11==ACTION||LA76_11==CHAR_LITERAL||LA76_11==REWRITE||LA76_11==RULE_REF||LA76_11==STRING_LITERAL||(LA76_11 >= TOKEN_REF && LA76_11 <= TREE_BEGIN)||(LA76_11 >= 67 && LA76_11 <= 69)||LA76_11==76||LA76_11==91) ) {
+						alt76=1;
+					}
+					else if ( ((LA76_11 >= 70 && LA76_11 <= 71)||LA76_11==80) ) {
+						alt76=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 76, 11, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+					}
+					break;
+				case EOF:
+				case ACTION:
+				case CHAR_LITERAL:
+				case REWRITE:
+				case RULE_REF:
+				case STRING_LITERAL:
+				case TOKEN_REF:
+				case TREE_BEGIN:
+				case 67:
+				case 68:
+				case 69:
+				case 76:
+				case 91:
+					{
+					alt76=1;
+					}
+					break;
+				case 70:
+				case 71:
+				case 80:
+					{
+					alt76=2;
+					}
+					break;
+				default:
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 76, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+				}
+				break;
+			case RULE_REF:
+				{
+				int LA76_3 = input.LA(2);
+				if ( (LA76_3==EOF||LA76_3==ACTION||LA76_3==CHAR_LITERAL||LA76_3==REWRITE||LA76_3==RULE_REF||LA76_3==STRING_LITERAL||(LA76_3 >= TOKEN_REF && LA76_3 <= TREE_BEGIN)||(LA76_3 >= 67 && LA76_3 <= 69)||LA76_3==76||LA76_3==91) ) {
+					alt76=1;
+				}
+				else if ( ((LA76_3 >= 70 && LA76_3 <= 71)||LA76_3==80) ) {
+					alt76=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 76, 3, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				int LA76_4 = input.LA(2);
+				if ( (LA76_4==EOF||LA76_4==ACTION||LA76_4==CHAR_LITERAL||LA76_4==REWRITE||LA76_4==RULE_REF||LA76_4==STRING_LITERAL||(LA76_4 >= TOKEN_REF && LA76_4 <= TREE_BEGIN)||(LA76_4 >= 67 && LA76_4 <= 69)||LA76_4==76||LA76_4==91) ) {
+					alt76=1;
+				}
+				else if ( ((LA76_4 >= 70 && LA76_4 <= 71)||LA76_4==80) ) {
+					alt76=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 76, 4, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case 67:
+				{
+				int LA76_5 = input.LA(2);
+				if ( (LA76_5==TOKEN_REF) ) {
+					int LA76_12 = input.LA(3);
+					if ( (LA76_12==EOF||LA76_12==ACTION||LA76_12==CHAR_LITERAL||LA76_12==REWRITE||LA76_12==RULE_REF||LA76_12==STRING_LITERAL||(LA76_12 >= TOKEN_REF && LA76_12 <= TREE_BEGIN)||(LA76_12 >= 67 && LA76_12 <= 69)||LA76_12==76||LA76_12==91) ) {
+						alt76=1;
+					}
+					else if ( ((LA76_12 >= 70 && LA76_12 <= 71)||LA76_12==80) ) {
+						alt76=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 76, 12, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+				else if ( (LA76_5==RULE_REF) ) {
+					int LA76_13 = input.LA(3);
+					if ( (LA76_13==EOF||LA76_13==ACTION||LA76_13==CHAR_LITERAL||LA76_13==REWRITE||LA76_13==RULE_REF||LA76_13==STRING_LITERAL||(LA76_13 >= TOKEN_REF && LA76_13 <= TREE_BEGIN)||(LA76_13 >= 67 && LA76_13 <= 69)||LA76_13==76||LA76_13==91) ) {
+						alt76=1;
+					}
+					else if ( ((LA76_13 >= 70 && LA76_13 <= 71)||LA76_13==80) ) {
+						alt76=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 76, 13, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 76, 5, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case ACTION:
+				{
+				int LA76_6 = input.LA(2);
+				if ( (LA76_6==EOF||LA76_6==ACTION||LA76_6==CHAR_LITERAL||LA76_6==REWRITE||LA76_6==RULE_REF||LA76_6==STRING_LITERAL||(LA76_6 >= TOKEN_REF && LA76_6 <= TREE_BEGIN)||(LA76_6 >= 67 && LA76_6 <= 69)||LA76_6==76||LA76_6==91) ) {
+					alt76=1;
+				}
+				else if ( ((LA76_6 >= 70 && LA76_6 <= 71)||LA76_6==80) ) {
+					alt76=2;
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 76, 6, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt76=3;
+				}
+				break;
+			case 68:
+				{
+				alt76=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 76, 0, input);
+				throw nvae;
+			}
+			switch (alt76) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:378:4: rewrite_tree_atom
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_rewrite_tree_atom_in_rewrite_tree_element2767);
+					rewrite_tree_atom152=rewrite_tree_atom();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_tree_atom152.getTree());
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:379:4: rewrite_tree_atom ebnfSuffix
+					{
+					pushFollow(FOLLOW_rewrite_tree_atom_in_rewrite_tree_element2772);
+					rewrite_tree_atom153=rewrite_tree_atom();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_tree_atom.add(rewrite_tree_atom153.getTree());
+					pushFollow(FOLLOW_ebnfSuffix_in_rewrite_tree_element2774);
+					ebnfSuffix154=ebnfSuffix();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_ebnfSuffix.add(ebnfSuffix154.getTree());
+					// AST REWRITE
+					// elements: rewrite_tree_atom, ebnfSuffix
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 380:3: -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree_atom EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:380:6: ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree_atom EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_ebnfSuffix.nextNode(), root_1);
+						// org/antlr/grammar/v3/ANTLRv3.g:380:20: ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree_atom EOA[\"EOA\"] ) EOB[\"EOB\"] )
+						{
+						CommonTree root_2 = (CommonTree)adaptor.nil();
+						root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(BLOCK, "BLOCK"), root_2);
+						// org/antlr/grammar/v3/ANTLRv3.g:380:37: ^( ALT[\"ALT\"] rewrite_tree_atom EOA[\"EOA\"] )
+						{
+						CommonTree root_3 = (CommonTree)adaptor.nil();
+						root_3 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ALT, "ALT"), root_3);
+						adaptor.addChild(root_3, stream_rewrite_tree_atom.nextTree());
+						adaptor.addChild(root_3, (CommonTree)adaptor.create(EOA, "EOA"));
+						adaptor.addChild(root_2, root_3);
+						}
+
+						adaptor.addChild(root_2, (CommonTree)adaptor.create(EOB, "EOB"));
+						adaptor.addChild(root_1, root_2);
+						}
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:381:6: rewrite_tree ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> rewrite_tree )
+					{
+					pushFollow(FOLLOW_rewrite_tree_in_rewrite_tree_element2808);
+					rewrite_tree155=rewrite_tree();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_tree.add(rewrite_tree155.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:382:3: ( ebnfSuffix -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree EOA[\"EOA\"] ) EOB[\"EOB\"] ) ) | -> rewrite_tree )
+					int alt75=2;
+					int LA75_0 = input.LA(1);
+					if ( ((LA75_0 >= 70 && LA75_0 <= 71)||LA75_0==80) ) {
+						alt75=1;
+					}
+					else if ( (LA75_0==EOF||LA75_0==ACTION||LA75_0==CHAR_LITERAL||LA75_0==REWRITE||LA75_0==RULE_REF||LA75_0==STRING_LITERAL||(LA75_0 >= TOKEN_REF && LA75_0 <= TREE_BEGIN)||(LA75_0 >= 67 && LA75_0 <= 69)||LA75_0==76||LA75_0==91) ) {
+						alt75=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 75, 0, input);
+						throw nvae;
+					}
+
+					switch (alt75) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:382:5: ebnfSuffix
+							{
+							pushFollow(FOLLOW_ebnfSuffix_in_rewrite_tree_element2814);
+							ebnfSuffix156=ebnfSuffix();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_ebnfSuffix.add(ebnfSuffix156.getTree());
+							// AST REWRITE
+							// elements: ebnfSuffix, rewrite_tree
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 383:4: -> ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+							{
+								// org/antlr/grammar/v3/ANTLRv3.g:383:7: ^( ebnfSuffix ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree EOA[\"EOA\"] ) EOB[\"EOB\"] ) )
+								{
+								CommonTree root_1 = (CommonTree)adaptor.nil();
+								root_1 = (CommonTree)adaptor.becomeRoot(stream_ebnfSuffix.nextNode(), root_1);
+								// org/antlr/grammar/v3/ANTLRv3.g:383:20: ^( BLOCK[\"BLOCK\"] ^( ALT[\"ALT\"] rewrite_tree EOA[\"EOA\"] ) EOB[\"EOB\"] )
+								{
+								CommonTree root_2 = (CommonTree)adaptor.nil();
+								root_2 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(BLOCK, "BLOCK"), root_2);
+								// org/antlr/grammar/v3/ANTLRv3.g:383:37: ^( ALT[\"ALT\"] rewrite_tree EOA[\"EOA\"] )
+								{
+								CommonTree root_3 = (CommonTree)adaptor.nil();
+								root_3 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ALT, "ALT"), root_3);
+								adaptor.addChild(root_3, stream_rewrite_tree.nextTree());
+								adaptor.addChild(root_3, (CommonTree)adaptor.create(EOA, "EOA"));
+								adaptor.addChild(root_2, root_3);
+								}
+
+								adaptor.addChild(root_2, (CommonTree)adaptor.create(EOB, "EOB"));
+								adaptor.addChild(root_1, root_2);
+								}
+
+								adaptor.addChild(root_0, root_1);
+								}
+
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:384:5: 
+							{
+							// AST REWRITE
+							// elements: rewrite_tree
+							// token labels: 
+							// rule labels: retval
+							// token list labels: 
+							// rule list labels: 
+							// wildcard labels: 
+							if ( state.backtracking==0 ) {
+							retval.tree = root_0;
+							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+							root_0 = (CommonTree)adaptor.nil();
+							// 384:5: -> rewrite_tree
+							{
+								adaptor.addChild(root_0, stream_rewrite_tree.nextTree());
+							}
+
+
+							retval.tree = root_0;
+							}
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:386:6: rewrite_tree_ebnf
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_rewrite_tree_ebnf_in_rewrite_tree_element2860);
+					rewrite_tree_ebnf157=rewrite_tree_ebnf();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_tree_ebnf157.getTree());
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_tree_element"
+
+
+	public static class rewrite_tree_atom_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_tree_atom"
+	// org/antlr/grammar/v3/ANTLRv3.g:389:1: rewrite_tree_atom : ( CHAR_LITERAL | TOKEN_REF ( ARG_ACTION )? -> ^( TOKEN_REF ( ARG_ACTION )? ) | RULE_REF | STRING_LITERAL |d= '$' id -> LABEL[$d,$id.text] | ACTION );
+	public final ANTLRv3Parser.rewrite_tree_atom_return rewrite_tree_atom() throws RecognitionException {
+		ANTLRv3Parser.rewrite_tree_atom_return retval = new ANTLRv3Parser.rewrite_tree_atom_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token d=null;
+		Token CHAR_LITERAL158=null;
+		Token TOKEN_REF159=null;
+		Token ARG_ACTION160=null;
+		Token RULE_REF161=null;
+		Token STRING_LITERAL162=null;
+		Token ACTION164=null;
+		ParserRuleReturnScope id163 =null;
+
+		CommonTree d_tree=null;
+		CommonTree CHAR_LITERAL158_tree=null;
+		CommonTree TOKEN_REF159_tree=null;
+		CommonTree ARG_ACTION160_tree=null;
+		CommonTree RULE_REF161_tree=null;
+		CommonTree STRING_LITERAL162_tree=null;
+		CommonTree ACTION164_tree=null;
+		RewriteRuleTokenStream stream_67=new RewriteRuleTokenStream(adaptor,"token 67");
+		RewriteRuleTokenStream stream_TOKEN_REF=new RewriteRuleTokenStream(adaptor,"token TOKEN_REF");
+		RewriteRuleTokenStream stream_ARG_ACTION=new RewriteRuleTokenStream(adaptor,"token ARG_ACTION");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:390:5: ( CHAR_LITERAL | TOKEN_REF ( ARG_ACTION )? -> ^( TOKEN_REF ( ARG_ACTION )? ) | RULE_REF | STRING_LITERAL |d= '$' id -> LABEL[$d,$id.text] | ACTION )
+			int alt78=6;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				alt78=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt78=2;
+				}
+				break;
+			case RULE_REF:
+				{
+				alt78=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt78=4;
+				}
+				break;
+			case 67:
+				{
+				alt78=5;
+				}
+				break;
+			case ACTION:
+				{
+				alt78=6;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 78, 0, input);
+				throw nvae;
+			}
+			switch (alt78) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:390:9: CHAR_LITERAL
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					CHAR_LITERAL158=(Token)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_rewrite_tree_atom2876); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					CHAR_LITERAL158_tree = (CommonTree)adaptor.create(CHAR_LITERAL158);
+					adaptor.addChild(root_0, CHAR_LITERAL158_tree);
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:391:6: TOKEN_REF ( ARG_ACTION )?
+					{
+					TOKEN_REF159=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_rewrite_tree_atom2883); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_TOKEN_REF.add(TOKEN_REF159);
+
+					// org/antlr/grammar/v3/ANTLRv3.g:391:16: ( ARG_ACTION )?
+					int alt77=2;
+					int LA77_0 = input.LA(1);
+					if ( (LA77_0==ARG_ACTION) ) {
+						alt77=1;
+					}
+					switch (alt77) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:391:16: ARG_ACTION
+							{
+							ARG_ACTION160=(Token)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rewrite_tree_atom2885); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_ARG_ACTION.add(ARG_ACTION160);
+
+							}
+							break;
+
+					}
+
+					// AST REWRITE
+					// elements: TOKEN_REF, ARG_ACTION
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 391:28: -> ^( TOKEN_REF ( ARG_ACTION )? )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:391:31: ^( TOKEN_REF ( ARG_ACTION )? )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot(stream_TOKEN_REF.nextNode(), root_1);
+						// org/antlr/grammar/v3/ANTLRv3.g:391:43: ( ARG_ACTION )?
+						if ( stream_ARG_ACTION.hasNext() ) {
+							adaptor.addChild(root_1, stream_ARG_ACTION.nextNode());
+						}
+						stream_ARG_ACTION.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:392:9: RULE_REF
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					RULE_REF161=(Token)match(input,RULE_REF,FOLLOW_RULE_REF_in_rewrite_tree_atom2906); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					RULE_REF161_tree = (CommonTree)adaptor.create(RULE_REF161);
+					adaptor.addChild(root_0, RULE_REF161_tree);
+					}
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:393:6: STRING_LITERAL
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					STRING_LITERAL162=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_rewrite_tree_atom2913); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					STRING_LITERAL162_tree = (CommonTree)adaptor.create(STRING_LITERAL162);
+					adaptor.addChild(root_0, STRING_LITERAL162_tree);
+					}
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRv3.g:394:6: d= '$' id
+					{
+					d=(Token)match(input,67,FOLLOW_67_in_rewrite_tree_atom2922); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_67.add(d);
+
+					pushFollow(FOLLOW_id_in_rewrite_tree_atom2924);
+					id163=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_id.add(id163.getTree());
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 394:15: -> LABEL[$d,$id.text]
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(LABEL, d, (id163!=null?input.toString(id163.start,id163.stop):null)));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLRv3.g:395:4: ACTION
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					ACTION164=(Token)match(input,ACTION,FOLLOW_ACTION_in_rewrite_tree_atom2935); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ACTION164_tree = (CommonTree)adaptor.create(ACTION164);
+					adaptor.addChild(root_0, ACTION164_tree);
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_tree_atom"
+
+
+	public static class rewrite_tree_ebnf_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_tree_ebnf"
+	// org/antlr/grammar/v3/ANTLRv3.g:398:1: rewrite_tree_ebnf : rewrite_tree_block ebnfSuffix -> ^( ebnfSuffix rewrite_tree_block ) ;
+	public final ANTLRv3Parser.rewrite_tree_ebnf_return rewrite_tree_ebnf() throws RecognitionException {
+		ANTLRv3Parser.rewrite_tree_ebnf_return retval = new ANTLRv3Parser.rewrite_tree_ebnf_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		ParserRuleReturnScope rewrite_tree_block165 =null;
+		ParserRuleReturnScope ebnfSuffix166 =null;
+
+		RewriteRuleSubtreeStream stream_rewrite_tree_block=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree_block");
+		RewriteRuleSubtreeStream stream_ebnfSuffix=new RewriteRuleSubtreeStream(adaptor,"rule ebnfSuffix");
+
+
+		    Token firstToken = input.LT(1);
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:406:2: ( rewrite_tree_block ebnfSuffix -> ^( ebnfSuffix rewrite_tree_block ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:406:4: rewrite_tree_block ebnfSuffix
+			{
+			pushFollow(FOLLOW_rewrite_tree_block_in_rewrite_tree_ebnf2956);
+			rewrite_tree_block165=rewrite_tree_block();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite_tree_block.add(rewrite_tree_block165.getTree());
+			pushFollow(FOLLOW_ebnfSuffix_in_rewrite_tree_ebnf2958);
+			ebnfSuffix166=ebnfSuffix();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_ebnfSuffix.add(ebnfSuffix166.getTree());
+			// AST REWRITE
+			// elements: ebnfSuffix, rewrite_tree_block
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 406:34: -> ^( ebnfSuffix rewrite_tree_block )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:406:37: ^( ebnfSuffix rewrite_tree_block )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot(stream_ebnfSuffix.nextNode(), root_1);
+				adaptor.addChild(root_1, stream_rewrite_tree_block.nextTree());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+			if ( state.backtracking==0 ) {
+				retval.tree.getToken().setLine(firstToken.getLine());
+				retval.tree.getToken().setCharPositionInLine(firstToken.getCharPositionInLine());
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_tree_ebnf"
+
+
+	public static class rewrite_tree_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_tree"
+	// org/antlr/grammar/v3/ANTLRv3.g:409:1: rewrite_tree : '^(' rewrite_tree_atom ( rewrite_tree_element )* ')' -> ^( TREE_BEGIN rewrite_tree_atom ( rewrite_tree_element )* ) ;
+	public final ANTLRv3Parser.rewrite_tree_return rewrite_tree() throws RecognitionException {
+		ANTLRv3Parser.rewrite_tree_return retval = new ANTLRv3Parser.rewrite_tree_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token string_literal167=null;
+		Token char_literal170=null;
+		ParserRuleReturnScope rewrite_tree_atom168 =null;
+		ParserRuleReturnScope rewrite_tree_element169 =null;
+
+		CommonTree string_literal167_tree=null;
+		CommonTree char_literal170_tree=null;
+		RewriteRuleTokenStream stream_69=new RewriteRuleTokenStream(adaptor,"token 69");
+		RewriteRuleTokenStream stream_TREE_BEGIN=new RewriteRuleTokenStream(adaptor,"token TREE_BEGIN");
+		RewriteRuleSubtreeStream stream_rewrite_tree_atom=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree_atom");
+		RewriteRuleSubtreeStream stream_rewrite_tree_element=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree_element");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:410:2: ( '^(' rewrite_tree_atom ( rewrite_tree_element )* ')' -> ^( TREE_BEGIN rewrite_tree_atom ( rewrite_tree_element )* ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:410:4: '^(' rewrite_tree_atom ( rewrite_tree_element )* ')'
+			{
+			string_literal167=(Token)match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_rewrite_tree2978); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_TREE_BEGIN.add(string_literal167);
+
+			pushFollow(FOLLOW_rewrite_tree_atom_in_rewrite_tree2980);
+			rewrite_tree_atom168=rewrite_tree_atom();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite_tree_atom.add(rewrite_tree_atom168.getTree());
+			// org/antlr/grammar/v3/ANTLRv3.g:410:27: ( rewrite_tree_element )*
+			loop79:
+			while (true) {
+				int alt79=2;
+				int LA79_0 = input.LA(1);
+				if ( (LA79_0==ACTION||LA79_0==CHAR_LITERAL||LA79_0==RULE_REF||LA79_0==STRING_LITERAL||(LA79_0 >= TOKEN_REF && LA79_0 <= TREE_BEGIN)||(LA79_0 >= 67 && LA79_0 <= 68)) ) {
+					alt79=1;
+				}
+
+				switch (alt79) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:410:27: rewrite_tree_element
+					{
+					pushFollow(FOLLOW_rewrite_tree_element_in_rewrite_tree2982);
+					rewrite_tree_element169=rewrite_tree_element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_tree_element.add(rewrite_tree_element169.getTree());
+					}
+					break;
+
+				default :
+					break loop79;
+				}
+			}
+
+			char_literal170=(Token)match(input,69,FOLLOW_69_in_rewrite_tree2985); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_69.add(char_literal170);
+
+			// AST REWRITE
+			// elements: rewrite_tree_atom, rewrite_tree_element
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 411:3: -> ^( TREE_BEGIN rewrite_tree_atom ( rewrite_tree_element )* )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:411:6: ^( TREE_BEGIN rewrite_tree_atom ( rewrite_tree_element )* )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(TREE_BEGIN, "TREE_BEGIN"), root_1);
+				adaptor.addChild(root_1, stream_rewrite_tree_atom.nextTree());
+				// org/antlr/grammar/v3/ANTLRv3.g:411:37: ( rewrite_tree_element )*
+				while ( stream_rewrite_tree_element.hasNext() ) {
+					adaptor.addChild(root_1, stream_rewrite_tree_element.nextTree());
+				}
+				stream_rewrite_tree_element.reset();
+
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_tree"
+
+
+	public static class rewrite_template_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_template"
+	// org/antlr/grammar/v3/ANTLRv3.g:425:1: rewrite_template : ( id lp= '(' rewrite_template_args ')' (str= DOUBLE_QUOTE_STRING_LITERAL |str= DOUBLE_ANGLE_STRING_LITERAL ) -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args $str) | rewrite_template_ref | rewrite_indirect_template_head | ACTION );
+	public final ANTLRv3Parser.rewrite_template_return rewrite_template() throws RecognitionException {
+		ANTLRv3Parser.rewrite_template_return retval = new ANTLRv3Parser.rewrite_template_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token lp=null;
+		Token str=null;
+		Token char_literal173=null;
+		Token ACTION176=null;
+		ParserRuleReturnScope id171 =null;
+		ParserRuleReturnScope rewrite_template_args172 =null;
+		ParserRuleReturnScope rewrite_template_ref174 =null;
+		ParserRuleReturnScope rewrite_indirect_template_head175 =null;
+
+		CommonTree lp_tree=null;
+		CommonTree str_tree=null;
+		CommonTree char_literal173_tree=null;
+		CommonTree ACTION176_tree=null;
+		RewriteRuleTokenStream stream_DOUBLE_QUOTE_STRING_LITERAL=new RewriteRuleTokenStream(adaptor,"token DOUBLE_QUOTE_STRING_LITERAL");
+		RewriteRuleTokenStream stream_68=new RewriteRuleTokenStream(adaptor,"token 68");
+		RewriteRuleTokenStream stream_69=new RewriteRuleTokenStream(adaptor,"token 69");
+		RewriteRuleTokenStream stream_DOUBLE_ANGLE_STRING_LITERAL=new RewriteRuleTokenStream(adaptor,"token DOUBLE_ANGLE_STRING_LITERAL");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_rewrite_template_args=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_args");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:426:2: ( id lp= '(' rewrite_template_args ')' (str= DOUBLE_QUOTE_STRING_LITERAL |str= DOUBLE_ANGLE_STRING_LITERAL ) -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args $str) | rewrite_template_ref | rewrite_indirect_template_head | ACTION )
+			int alt81=4;
+			alt81 = dfa81.predict(input);
+			switch (alt81) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:427:3: id lp= '(' rewrite_template_args ')' (str= DOUBLE_QUOTE_STRING_LITERAL |str= DOUBLE_ANGLE_STRING_LITERAL )
+					{
+					pushFollow(FOLLOW_id_in_rewrite_template3017);
+					id171=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_id.add(id171.getTree());
+					lp=(Token)match(input,68,FOLLOW_68_in_rewrite_template3021); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_68.add(lp);
+
+					pushFollow(FOLLOW_rewrite_template_args_in_rewrite_template3023);
+					rewrite_template_args172=rewrite_template_args();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_template_args.add(rewrite_template_args172.getTree());
+					char_literal173=(Token)match(input,69,FOLLOW_69_in_rewrite_template3025); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_69.add(char_literal173);
+
+					// org/antlr/grammar/v3/ANTLRv3.g:428:3: (str= DOUBLE_QUOTE_STRING_LITERAL |str= DOUBLE_ANGLE_STRING_LITERAL )
+					int alt80=2;
+					int LA80_0 = input.LA(1);
+					if ( (LA80_0==DOUBLE_QUOTE_STRING_LITERAL) ) {
+						alt80=1;
+					}
+					else if ( (LA80_0==DOUBLE_ANGLE_STRING_LITERAL) ) {
+						alt80=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 80, 0, input);
+						throw nvae;
+					}
+
+					switch (alt80) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:428:5: str= DOUBLE_QUOTE_STRING_LITERAL
+							{
+							str=(Token)match(input,DOUBLE_QUOTE_STRING_LITERAL,FOLLOW_DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template3033); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_DOUBLE_QUOTE_STRING_LITERAL.add(str);
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/ANTLRv3.g:428:39: str= DOUBLE_ANGLE_STRING_LITERAL
+							{
+							str=(Token)match(input,DOUBLE_ANGLE_STRING_LITERAL,FOLLOW_DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template3039); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_DOUBLE_ANGLE_STRING_LITERAL.add(str);
+
+							}
+							break;
+
+					}
+
+					// AST REWRITE
+					// elements: rewrite_template_args, id, str
+					// token labels: str
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleTokenStream stream_str=new RewriteRuleTokenStream(adaptor,"token str",str);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 429:3: -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args $str)
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:429:6: ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args $str)
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(TEMPLATE, lp, "TEMPLATE"), root_1);
+						adaptor.addChild(root_1, stream_id.nextTree());
+						adaptor.addChild(root_1, stream_rewrite_template_args.nextTree());
+						adaptor.addChild(root_1, stream_str.nextNode());
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:432:3: rewrite_template_ref
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_rewrite_template_ref_in_rewrite_template3066);
+					rewrite_template_ref174=rewrite_template_ref();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_template_ref174.getTree());
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3.g:435:3: rewrite_indirect_template_head
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					pushFollow(FOLLOW_rewrite_indirect_template_head_in_rewrite_template3075);
+					rewrite_indirect_template_head175=rewrite_indirect_template_head();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, rewrite_indirect_template_head175.getTree());
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3.g:438:3: ACTION
+					{
+					root_0 = (CommonTree)adaptor.nil();
+
+
+					ACTION176=(Token)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template3084); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ACTION176_tree = (CommonTree)adaptor.create(ACTION176);
+					adaptor.addChild(root_0, ACTION176_tree);
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template"
+
+
+	public static class rewrite_template_ref_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_template_ref"
+	// org/antlr/grammar/v3/ANTLRv3.g:442:1: rewrite_template_ref : id lp= '(' rewrite_template_args ')' -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args ) ;
+	public final ANTLRv3Parser.rewrite_template_ref_return rewrite_template_ref() throws RecognitionException {
+		ANTLRv3Parser.rewrite_template_ref_return retval = new ANTLRv3Parser.rewrite_template_ref_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token lp=null;
+		Token char_literal179=null;
+		ParserRuleReturnScope id177 =null;
+		ParserRuleReturnScope rewrite_template_args178 =null;
+
+		CommonTree lp_tree=null;
+		CommonTree char_literal179_tree=null;
+		RewriteRuleTokenStream stream_68=new RewriteRuleTokenStream(adaptor,"token 68");
+		RewriteRuleTokenStream stream_69=new RewriteRuleTokenStream(adaptor,"token 69");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_rewrite_template_args=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_args");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:443:2: ( id lp= '(' rewrite_template_args ')' -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:443:4: id lp= '(' rewrite_template_args ')'
+			{
+			pushFollow(FOLLOW_id_in_rewrite_template_ref3097);
+			id177=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id177.getTree());
+			lp=(Token)match(input,68,FOLLOW_68_in_rewrite_template_ref3101); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_68.add(lp);
+
+			pushFollow(FOLLOW_rewrite_template_args_in_rewrite_template_ref3103);
+			rewrite_template_args178=rewrite_template_args();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite_template_args.add(rewrite_template_args178.getTree());
+			char_literal179=(Token)match(input,69,FOLLOW_69_in_rewrite_template_ref3105); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_69.add(char_literal179);
+
+			// AST REWRITE
+			// elements: id, rewrite_template_args
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 444:3: -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:444:6: ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(TEMPLATE, lp, "TEMPLATE"), root_1);
+				adaptor.addChild(root_1, stream_id.nextTree());
+				adaptor.addChild(root_1, stream_rewrite_template_args.nextTree());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template_ref"
+
+
+	public static class rewrite_indirect_template_head_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_indirect_template_head"
+	// org/antlr/grammar/v3/ANTLRv3.g:448:1: rewrite_indirect_template_head : lp= '(' ACTION ')' '(' rewrite_template_args ')' -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args ) ;
+	public final ANTLRv3Parser.rewrite_indirect_template_head_return rewrite_indirect_template_head() throws RecognitionException {
+		ANTLRv3Parser.rewrite_indirect_template_head_return retval = new ANTLRv3Parser.rewrite_indirect_template_head_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token lp=null;
+		Token ACTION180=null;
+		Token char_literal181=null;
+		Token char_literal182=null;
+		Token char_literal184=null;
+		ParserRuleReturnScope rewrite_template_args183 =null;
+
+		CommonTree lp_tree=null;
+		CommonTree ACTION180_tree=null;
+		CommonTree char_literal181_tree=null;
+		CommonTree char_literal182_tree=null;
+		CommonTree char_literal184_tree=null;
+		RewriteRuleTokenStream stream_68=new RewriteRuleTokenStream(adaptor,"token 68");
+		RewriteRuleTokenStream stream_69=new RewriteRuleTokenStream(adaptor,"token 69");
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleSubtreeStream stream_rewrite_template_args=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_args");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:449:2: (lp= '(' ACTION ')' '(' rewrite_template_args ')' -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:449:4: lp= '(' ACTION ')' '(' rewrite_template_args ')'
+			{
+			lp=(Token)match(input,68,FOLLOW_68_in_rewrite_indirect_template_head3133); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_68.add(lp);
+
+			ACTION180=(Token)match(input,ACTION,FOLLOW_ACTION_in_rewrite_indirect_template_head3135); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ACTION.add(ACTION180);
+
+			char_literal181=(Token)match(input,69,FOLLOW_69_in_rewrite_indirect_template_head3137); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_69.add(char_literal181);
+
+			char_literal182=(Token)match(input,68,FOLLOW_68_in_rewrite_indirect_template_head3139); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_68.add(char_literal182);
+
+			pushFollow(FOLLOW_rewrite_template_args_in_rewrite_indirect_template_head3141);
+			rewrite_template_args183=rewrite_template_args();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_rewrite_template_args.add(rewrite_template_args183.getTree());
+			char_literal184=(Token)match(input,69,FOLLOW_69_in_rewrite_indirect_template_head3143); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_69.add(char_literal184);
+
+			// AST REWRITE
+			// elements: ACTION, rewrite_template_args
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 450:3: -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:450:6: ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(TEMPLATE, lp, "TEMPLATE"), root_1);
+				adaptor.addChild(root_1, stream_ACTION.nextNode());
+				adaptor.addChild(root_1, stream_rewrite_template_args.nextTree());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_indirect_template_head"
+
+
+	public static class rewrite_template_args_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_template_args"
+	// org/antlr/grammar/v3/ANTLRv3.g:453:1: rewrite_template_args : ( rewrite_template_arg ( ',' rewrite_template_arg )* -> ^( ARGLIST ( rewrite_template_arg )+ ) | -> ARGLIST );
+	public final ANTLRv3Parser.rewrite_template_args_return rewrite_template_args() throws RecognitionException {
+		ANTLRv3Parser.rewrite_template_args_return retval = new ANTLRv3Parser.rewrite_template_args_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal186=null;
+		ParserRuleReturnScope rewrite_template_arg185 =null;
+		ParserRuleReturnScope rewrite_template_arg187 =null;
+
+		CommonTree char_literal186_tree=null;
+		RewriteRuleTokenStream stream_72=new RewriteRuleTokenStream(adaptor,"token 72");
+		RewriteRuleSubtreeStream stream_rewrite_template_arg=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_arg");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:454:2: ( rewrite_template_arg ( ',' rewrite_template_arg )* -> ^( ARGLIST ( rewrite_template_arg )+ ) | -> ARGLIST )
+			int alt83=2;
+			int LA83_0 = input.LA(1);
+			if ( (LA83_0==RULE_REF||LA83_0==TOKEN_REF) ) {
+				alt83=1;
+			}
+			else if ( (LA83_0==69) ) {
+				alt83=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 83, 0, input);
+				throw nvae;
+			}
+
+			switch (alt83) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:454:4: rewrite_template_arg ( ',' rewrite_template_arg )*
+					{
+					pushFollow(FOLLOW_rewrite_template_arg_in_rewrite_template_args3167);
+					rewrite_template_arg185=rewrite_template_arg();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) stream_rewrite_template_arg.add(rewrite_template_arg185.getTree());
+					// org/antlr/grammar/v3/ANTLRv3.g:454:25: ( ',' rewrite_template_arg )*
+					loop82:
+					while (true) {
+						int alt82=2;
+						int LA82_0 = input.LA(1);
+						if ( (LA82_0==72) ) {
+							alt82=1;
+						}
+
+						switch (alt82) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3.g:454:26: ',' rewrite_template_arg
+							{
+							char_literal186=(Token)match(input,72,FOLLOW_72_in_rewrite_template_args3170); if (state.failed) return retval; 
+							if ( state.backtracking==0 ) stream_72.add(char_literal186);
+
+							pushFollow(FOLLOW_rewrite_template_arg_in_rewrite_template_args3172);
+							rewrite_template_arg187=rewrite_template_arg();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) stream_rewrite_template_arg.add(rewrite_template_arg187.getTree());
+							}
+							break;
+
+						default :
+							break loop82;
+						}
+					}
+
+					// AST REWRITE
+					// elements: rewrite_template_arg
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 455:3: -> ^( ARGLIST ( rewrite_template_arg )+ )
+					{
+						// org/antlr/grammar/v3/ANTLRv3.g:455:6: ^( ARGLIST ( rewrite_template_arg )+ )
+						{
+						CommonTree root_1 = (CommonTree)adaptor.nil();
+						root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ARGLIST, "ARGLIST"), root_1);
+						if ( !(stream_rewrite_template_arg.hasNext()) ) {
+							throw new RewriteEarlyExitException();
+						}
+						while ( stream_rewrite_template_arg.hasNext() ) {
+							adaptor.addChild(root_1, stream_rewrite_template_arg.nextTree());
+						}
+						stream_rewrite_template_arg.reset();
+
+						adaptor.addChild(root_0, root_1);
+						}
+
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:456:4: 
+					{
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 456:4: -> ARGLIST
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(ARGLIST, "ARGLIST"));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template_args"
+
+
+	public static class rewrite_template_arg_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "rewrite_template_arg"
+	// org/antlr/grammar/v3/ANTLRv3.g:459:1: rewrite_template_arg : id '=' ACTION -> ^( ARG[$id.start] id ACTION ) ;
+	public final ANTLRv3Parser.rewrite_template_arg_return rewrite_template_arg() throws RecognitionException {
+		ANTLRv3Parser.rewrite_template_arg_return retval = new ANTLRv3Parser.rewrite_template_arg_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal189=null;
+		Token ACTION190=null;
+		ParserRuleReturnScope id188 =null;
+
+		CommonTree char_literal189_tree=null;
+		CommonTree ACTION190_tree=null;
+		RewriteRuleTokenStream stream_ACTION=new RewriteRuleTokenStream(adaptor,"token ACTION");
+		RewriteRuleTokenStream stream_LABEL_ASSIGN=new RewriteRuleTokenStream(adaptor,"token LABEL_ASSIGN");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:460:2: ( id '=' ACTION -> ^( ARG[$id.start] id ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3.g:460:6: id '=' ACTION
+			{
+			pushFollow(FOLLOW_id_in_rewrite_template_arg3205);
+			id188=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) stream_id.add(id188.getTree());
+			char_literal189=(Token)match(input,LABEL_ASSIGN,FOLLOW_LABEL_ASSIGN_in_rewrite_template_arg3207); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_LABEL_ASSIGN.add(char_literal189);
+
+			ACTION190=(Token)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template_arg3209); if (state.failed) return retval; 
+			if ( state.backtracking==0 ) stream_ACTION.add(ACTION190);
+
+			// AST REWRITE
+			// elements: id, ACTION
+			// token labels: 
+			// rule labels: retval
+			// token list labels: 
+			// rule list labels: 
+			// wildcard labels: 
+			if ( state.backtracking==0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+			root_0 = (CommonTree)adaptor.nil();
+			// 460:20: -> ^( ARG[$id.start] id ACTION )
+			{
+				// org/antlr/grammar/v3/ANTLRv3.g:460:23: ^( ARG[$id.start] id ACTION )
+				{
+				CommonTree root_1 = (CommonTree)adaptor.nil();
+				root_1 = (CommonTree)adaptor.becomeRoot((CommonTree)adaptor.create(ARG, (id188!=null?(id188.start):null)), root_1);
+				adaptor.addChild(root_1, stream_id.nextTree());
+				adaptor.addChild(root_1, stream_ACTION.nextNode());
+				adaptor.addChild(root_0, root_1);
+				}
+
+			}
+
+
+			retval.tree = root_0;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template_arg"
+
+
+	public static class qid_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "qid"
+	// org/antlr/grammar/v3/ANTLRv3.g:463:1: qid : id ( '.' id )* ;
+	public final ANTLRv3Parser.qid_return qid() throws RecognitionException {
+		ANTLRv3Parser.qid_return retval = new ANTLRv3Parser.qid_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token char_literal192=null;
+		ParserRuleReturnScope id191 =null;
+		ParserRuleReturnScope id193 =null;
+
+		CommonTree char_literal192_tree=null;
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:463:5: ( id ( '.' id )* )
+			// org/antlr/grammar/v3/ANTLRv3.g:463:7: id ( '.' id )*
+			{
+			root_0 = (CommonTree)adaptor.nil();
+
+
+			pushFollow(FOLLOW_id_in_qid3230);
+			id191=id();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) adaptor.addChild(root_0, id191.getTree());
+
+			// org/antlr/grammar/v3/ANTLRv3.g:463:10: ( '.' id )*
+			loop84:
+			while (true) {
+				int alt84=2;
+				int LA84_0 = input.LA(1);
+				if ( (LA84_0==73) ) {
+					alt84=1;
+				}
+
+				switch (alt84) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:463:11: '.' id
+					{
+					char_literal192=(Token)match(input,73,FOLLOW_73_in_qid3233); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					char_literal192_tree = (CommonTree)adaptor.create(char_literal192);
+					adaptor.addChild(root_0, char_literal192_tree);
+					}
+
+					pushFollow(FOLLOW_id_in_qid3235);
+					id193=id();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) adaptor.addChild(root_0, id193.getTree());
+
+					}
+					break;
+
+				default :
+					break loop84;
+				}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "qid"
+
+
+	public static class id_return extends ParserRuleReturnScope {
+		CommonTree tree;
+		@Override
+		public CommonTree getTree() { return tree; }
+	};
+
+
+	// $ANTLR start "id"
+	// org/antlr/grammar/v3/ANTLRv3.g:465:1: id : ( TOKEN_REF -> ID[$TOKEN_REF] | RULE_REF -> ID[$RULE_REF] );
+	public final ANTLRv3Parser.id_return id() throws RecognitionException {
+		ANTLRv3Parser.id_return retval = new ANTLRv3Parser.id_return();
+		retval.start = input.LT(1);
+
+		CommonTree root_0 = null;
+
+		Token TOKEN_REF194=null;
+		Token RULE_REF195=null;
+
+		CommonTree TOKEN_REF194_tree=null;
+		CommonTree RULE_REF195_tree=null;
+		RewriteRuleTokenStream stream_TOKEN_REF=new RewriteRuleTokenStream(adaptor,"token TOKEN_REF");
+		RewriteRuleTokenStream stream_RULE_REF=new RewriteRuleTokenStream(adaptor,"token RULE_REF");
+
+		try {
+			// org/antlr/grammar/v3/ANTLRv3.g:465:4: ( TOKEN_REF -> ID[$TOKEN_REF] | RULE_REF -> ID[$RULE_REF] )
+			int alt85=2;
+			int LA85_0 = input.LA(1);
+			if ( (LA85_0==TOKEN_REF) ) {
+				alt85=1;
+			}
+			else if ( (LA85_0==RULE_REF) ) {
+				alt85=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 85, 0, input);
+				throw nvae;
+			}
+
+			switch (alt85) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3.g:465:6: TOKEN_REF
+					{
+					TOKEN_REF194=(Token)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_id3247); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_TOKEN_REF.add(TOKEN_REF194);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 465:16: -> ID[$TOKEN_REF]
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(ID, TOKEN_REF194));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3.g:466:4: RULE_REF
+					{
+					RULE_REF195=(Token)match(input,RULE_REF,FOLLOW_RULE_REF_in_id3257); if (state.failed) return retval; 
+					if ( state.backtracking==0 ) stream_RULE_REF.add(RULE_REF195);
+
+					// AST REWRITE
+					// elements: 
+					// token labels: 
+					// rule labels: retval
+					// token list labels: 
+					// rule list labels: 
+					// wildcard labels: 
+					if ( state.backtracking==0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
+
+					root_0 = (CommonTree)adaptor.nil();
+					// 466:14: -> ID[$RULE_REF]
+					{
+						adaptor.addChild(root_0, (CommonTree)adaptor.create(ID, RULE_REF195));
+					}
+
+
+					retval.tree = root_0;
+					}
+
+					}
+					break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking==0 ) {
+			retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
+			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+			retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "id"
+
+	// $ANTLR start synpred1_ANTLRv3
+	public final void synpred1_ANTLRv3_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ANTLRv3.g:363:4: ( rewrite_template )
+		// org/antlr/grammar/v3/ANTLRv3.g:363:4: rewrite_template
+		{
+		pushFollow(FOLLOW_rewrite_template_in_synpred1_ANTLRv32654);
+		rewrite_template();
+		state._fsp--;
+		if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred1_ANTLRv3
+
+	// $ANTLR start synpred2_ANTLRv3
+	public final void synpred2_ANTLRv3_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/ANTLRv3.g:364:4: ( rewrite_tree_alternative )
+		// org/antlr/grammar/v3/ANTLRv3.g:364:4: rewrite_tree_alternative
+		{
+		pushFollow(FOLLOW_rewrite_tree_alternative_in_synpred2_ANTLRv32659);
+		rewrite_tree_alternative();
+		state._fsp--;
+		if (state.failed) return;
+
+		}
+
+	}
+	// $ANTLR end synpred2_ANTLRv3
+
+	// Delegated rules
+
+	public final boolean synpred2_ANTLRv3() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred2_ANTLRv3_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred1_ANTLRv3() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred1_ANTLRv3_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+	protected DFA81 dfa81 = new DFA81(this);
+	static final String DFA81_eotS =
+		"\22\uffff";
+	static final String DFA81_eofS =
+		"\10\uffff\1\13\11\uffff";
+	static final String DFA81_minS =
+		"\1\4\2\104\2\uffff\1\63\2\41\1\25\1\4\2\uffff\1\105\1\63\2\41\1\4\1\105";
+	static final String DFA81_maxS =
+		"\3\104\2\uffff\1\105\2\41\1\133\1\4\2\uffff\1\110\1\75\2\41\1\4\1\110";
+	static final String DFA81_acceptS =
+		"\3\uffff\1\3\1\4\5\uffff\1\1\1\2\6\uffff";
+	static final String DFA81_specialS =
+		"\22\uffff}>";
+	static final String[] DFA81_transitionS = {
+			"\1\4\56\uffff\1\2\11\uffff\1\1\6\uffff\1\3",
+			"\1\5",
+			"\1\5",
+			"",
+			"",
+			"\1\7\11\uffff\1\6\7\uffff\1\10",
+			"\1\11",
+			"\1\11",
+			"\2\12\31\uffff\1\13\24\uffff\1\13\6\uffff\1\13\16\uffff\1\13",
+			"\1\14",
+			"",
+			"",
+			"\1\10\2\uffff\1\15",
+			"\1\17\11\uffff\1\16",
+			"\1\20",
+			"\1\20",
+			"\1\21",
+			"\1\10\2\uffff\1\15"
+	};
+
+	static final short[] DFA81_eot = DFA.unpackEncodedString(DFA81_eotS);
+	static final short[] DFA81_eof = DFA.unpackEncodedString(DFA81_eofS);
+	static final char[] DFA81_min = DFA.unpackEncodedStringToUnsignedChars(DFA81_minS);
+	static final char[] DFA81_max = DFA.unpackEncodedStringToUnsignedChars(DFA81_maxS);
+	static final short[] DFA81_accept = DFA.unpackEncodedString(DFA81_acceptS);
+	static final short[] DFA81_special = DFA.unpackEncodedString(DFA81_specialS);
+	static final short[][] DFA81_transition;
+
+	static {
+		int numStates = DFA81_transitionS.length;
+		DFA81_transition = new short[numStates][];
+		for (int i=0; i<numStates; i++) {
+			DFA81_transition[i] = DFA.unpackEncodedString(DFA81_transitionS[i]);
+		}
+	}
+
+	protected class DFA81 extends DFA {
+
+		public DFA81(BaseRecognizer recognizer) {
+			this.recognizer = recognizer;
+			this.decisionNumber = 81;
+			this.eot = DFA81_eot;
+			this.eof = DFA81_eof;
+			this.min = DFA81_min;
+			this.max = DFA81_max;
+			this.accept = DFA81_accept;
+			this.special = DFA81_special;
+			this.transition = DFA81_transition;
+		}
+		@Override
+		public String getDescription() {
+			return "425:1: rewrite_template : ( id lp= '(' rewrite_template_args ')' (str= DOUBLE_QUOTE_STRING_LITERAL |str= DOUBLE_ANGLE_STRING_LITERAL ) -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args $str) | rewrite_template_ref | rewrite_indirect_template_head | ACTION );";
+		}
+	}
+
+	public static final BitSet FOLLOW_DOC_COMMENT_in_grammarDef373 = new BitSet(new long[]{0x0000000000000000L,0x0000000004380000L});
+	public static final BitSet FOLLOW_84_in_grammarDef383 = new BitSet(new long[]{0x0000000000000000L,0x0000000000080000L});
+	public static final BitSet FOLLOW_85_in_grammarDef401 = new BitSet(new long[]{0x0000000000000000L,0x0000000000080000L});
+	public static final BitSet FOLLOW_90_in_grammarDef417 = new BitSet(new long[]{0x0000000000000000L,0x0000000000080000L});
+	public static final BitSet FOLLOW_83_in_grammarDef458 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_grammarDef460 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
+	public static final BitSet FOLLOW_76_in_grammarDef462 = new BitSet(new long[]{0x3018040010101000L,0x0000000001C00000L});
+	public static final BitSet FOLLOW_optionsSpec_in_grammarDef464 = new BitSet(new long[]{0x3018000010101000L,0x0000000001C00000L});
+	public static final BitSet FOLLOW_tokensSpec_in_grammarDef467 = new BitSet(new long[]{0x2018000010101000L,0x0000000001C00000L});
+	public static final BitSet FOLLOW_attrScope_in_grammarDef470 = new BitSet(new long[]{0x2018000010101000L,0x0000000001C00000L});
+	public static final BitSet FOLLOW_action_in_grammarDef473 = new BitSet(new long[]{0x2008000010101000L,0x0000000001C00000L});
+	public static final BitSet FOLLOW_rule_in_grammarDef481 = new BitSet(new long[]{0x2008000010100000L,0x0000000001C00000L});
+	public static final BitSet FOLLOW_EOF_in_grammarDef489 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKENS_in_tokensSpec550 = new BitSet(new long[]{0x2000000000000000L});
+	public static final BitSet FOLLOW_tokenSpec_in_tokensSpec552 = new BitSet(new long[]{0x2000000000000000L,0x0000000010000000L});
+	public static final BitSet FOLLOW_92_in_tokensSpec555 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec575 = new BitSet(new long[]{0x0000000200000000L,0x0000000000001000L});
+	public static final BitSet FOLLOW_LABEL_ASSIGN_in_tokenSpec581 = new BitSet(new long[]{0x0100000000010000L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_tokenSpec586 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_tokenSpec590 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
+	public static final BitSet FOLLOW_76_in_tokenSpec629 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SCOPE_in_attrScope640 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_attrScope642 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_attrScope644 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_AT_in_action667 = new BitSet(new long[]{0x2008000000000000L,0x0000000000300000L});
+	public static final BitSet FOLLOW_actionScopeName_in_action670 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
+	public static final BitSet FOLLOW_75_in_action672 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_action676 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_action678 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_actionScopeName704 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_84_in_actionScopeName711 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_85_in_actionScopeName728 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONS_in_optionsSpec744 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_option_in_optionsSpec747 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
+	public static final BitSet FOLLOW_76_in_optionsSpec749 = new BitSet(new long[]{0x2008000000000000L,0x0000000010000000L});
+	public static final BitSet FOLLOW_92_in_optionsSpec753 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_option778 = new BitSet(new long[]{0x0000000200000000L});
+	public static final BitSet FOLLOW_LABEL_ASSIGN_in_option780 = new BitSet(new long[]{0x2108000080010000L,0x0000000000000040L});
+	public static final BitSet FOLLOW_optionValue_in_option782 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_qid_in_optionValue811 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_optionValue821 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_optionValue831 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_INT_in_optionValue841 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_70_in_optionValue851 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOC_COMMENT_in_rule876 = new BitSet(new long[]{0x2008000010000000L,0x0000000001C00000L});
+	public static final BitSet FOLLOW_87_in_rule886 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_88_in_rule888 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_86_in_rule890 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_FRAGMENT_in_rule892 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_rule900 = new BitSet(new long[]{0x0010840000005800L,0x0000000002000400L});
+	public static final BitSet FOLLOW_BANG_in_rule906 = new BitSet(new long[]{0x0010840000001800L,0x0000000002000400L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule915 = new BitSet(new long[]{0x0010840000001000L,0x0000000002000400L});
+	public static final BitSet FOLLOW_RET_in_rule924 = new BitSet(new long[]{0x0000000000000800L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule928 = new BitSet(new long[]{0x0010040000001000L,0x0000000002000400L});
+	public static final BitSet FOLLOW_throwsSpec_in_rule936 = new BitSet(new long[]{0x0010040000001000L,0x0000000000000400L});
+	public static final BitSet FOLLOW_optionsSpec_in_rule939 = new BitSet(new long[]{0x0010000000001000L,0x0000000000000400L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_rule942 = new BitSet(new long[]{0x0000000000001000L,0x0000000000000400L});
+	public static final BitSet FOLLOW_ruleAction_in_rule945 = new BitSet(new long[]{0x0000000000001000L,0x0000000000000400L});
+	public static final BitSet FOLLOW_74_in_rule950 = new BitSet(new long[]{0x6129000000010010L,0x0000000020000210L});
+	public static final BitSet FOLLOW_altList_in_rule952 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
+	public static final BitSet FOLLOW_76_in_rule954 = new BitSet(new long[]{0x0000000000000002L,0x0000000000060000L});
+	public static final BitSet FOLLOW_exceptionGroup_in_rule958 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_AT_in_ruleAction1064 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_ruleAction1066 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_ruleAction1068 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_89_in_throwsSpec1089 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_throwsSpec1091 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000100L});
+	public static final BitSet FOLLOW_72_in_throwsSpec1095 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_throwsSpec1097 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000100L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec1120 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec1122 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec1135 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_ruleScopeSpec1137 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001100L});
+	public static final BitSet FOLLOW_72_in_ruleScopeSpec1140 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_ruleScopeSpec1142 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001100L});
+	public static final BitSet FOLLOW_76_in_ruleScopeSpec1146 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec1160 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec1162 = new BitSet(new long[]{0x0010000000000000L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec1166 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_ruleScopeSpec1168 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001100L});
+	public static final BitSet FOLLOW_72_in_ruleScopeSpec1171 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_ruleScopeSpec1173 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001100L});
+	public static final BitSet FOLLOW_76_in_ruleScopeSpec1177 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_68_in_block1209 = new BitSet(new long[]{0x6129040000010010L,0x0000000020000610L});
+	public static final BitSet FOLLOW_optionsSpec_in_block1218 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000400L});
+	public static final BitSet FOLLOW_74_in_block1222 = new BitSet(new long[]{0x6129000000010010L,0x0000000020000210L});
+	public static final BitSet FOLLOW_altpair_in_block1229 = new BitSet(new long[]{0x0000000000000000L,0x0000000008000020L});
+	public static final BitSet FOLLOW_91_in_block1233 = new BitSet(new long[]{0x6129000000010010L,0x0000000020000210L});
+	public static final BitSet FOLLOW_altpair_in_block1235 = new BitSet(new long[]{0x0000000000000000L,0x0000000008000020L});
+	public static final BitSet FOLLOW_69_in_block1250 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_alternative_in_altpair1289 = new BitSet(new long[]{0x0001000000000000L});
+	public static final BitSet FOLLOW_rewrite_in_altpair1291 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_altpair_in_altList1311 = new BitSet(new long[]{0x0000000000000002L,0x0000000008000000L});
+	public static final BitSet FOLLOW_91_in_altList1315 = new BitSet(new long[]{0x6129000000010010L,0x0000000020000210L});
+	public static final BitSet FOLLOW_altpair_in_altList1317 = new BitSet(new long[]{0x0000000000000002L,0x0000000008000000L});
+	public static final BitSet FOLLOW_element_in_alternative1358 = new BitSet(new long[]{0x6128000000010012L,0x0000000020000210L});
+	public static final BitSet FOLLOW_exceptionHandler_in_exceptionGroup1409 = new BitSet(new long[]{0x0000000000000002L,0x0000000000060000L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup1416 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup1424 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_81_in_exceptionHandler1444 = new BitSet(new long[]{0x0000000000000800L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_exceptionHandler1446 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_exceptionHandler1448 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_82_in_finallyClause1478 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_finallyClause1480 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_element1502 = new BitSet(new long[]{0x0000001200000000L});
+	public static final BitSet FOLLOW_LABEL_ASSIGN_in_element1507 = new BitSet(new long[]{0x2108000000010000L,0x0000000020000200L});
+	public static final BitSet FOLLOW_LIST_LABEL_ASSIGN_in_element1511 = new BitSet(new long[]{0x2108000000010000L,0x0000000020000200L});
+	public static final BitSet FOLLOW_atom_in_element1514 = new BitSet(new long[]{0x0000000000000002L,0x00000000000100C0L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_element1520 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_element1579 = new BitSet(new long[]{0x0000001200000000L});
+	public static final BitSet FOLLOW_LABEL_ASSIGN_in_element1584 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000010L});
+	public static final BitSet FOLLOW_LIST_LABEL_ASSIGN_in_element1588 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000010L});
+	public static final BitSet FOLLOW_block_in_element1591 = new BitSet(new long[]{0x0000000000000002L,0x00000000000100C0L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_element1597 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_atom_in_element1656 = new BitSet(new long[]{0x0000000000000002L,0x00000000000100C0L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_element1662 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ebnf_in_element1708 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_element1715 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SEMPRED_in_element1722 = new BitSet(new long[]{0x0000000000000002L,0x0000000000004000L});
+	public static final BitSet FOLLOW_78_in_element1728 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_treeSpec_in_element1748 = new BitSet(new long[]{0x0000000000000002L,0x00000000000100C0L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_element1754 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_terminal_in_atom1806 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_range_in_atom1811 = new BitSet(new long[]{0x0002000000004002L});
+	public static final BitSet FOLLOW_ROOT_in_atom1821 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_atom1825 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_notSet_in_atom1859 = new BitSet(new long[]{0x0002000000004002L});
+	public static final BitSet FOLLOW_ROOT_in_atom1868 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_atom1872 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_RULE_REF_in_atom1908 = new BitSet(new long[]{0x0002000000004802L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1910 = new BitSet(new long[]{0x0002000000004002L});
+	public static final BitSet FOLLOW_ROOT_in_atom1920 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_atom1924 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_93_in_notSet1972 = new BitSet(new long[]{0x2100000000010000L,0x0000000000000010L});
+	public static final BitSet FOLLOW_notTerminal_in_notSet1978 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_elementOptions_in_notSet1980 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_notSet1998 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_elementOptions_in_notSet2000 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_77_in_elementOptions2052 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_qid_in_elementOptions2054 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
+	public static final BitSet FOLLOW_79_in_elementOptions2056 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_77_in_elementOptions2074 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_option_in_elementOptions2076 = new BitSet(new long[]{0x0000000000000000L,0x0000000000009000L});
+	public static final BitSet FOLLOW_76_in_elementOptions2079 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_option_in_elementOptions2081 = new BitSet(new long[]{0x0000000000000000L,0x0000000000009000L});
+	public static final BitSet FOLLOW_79_in_elementOptions2085 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_elementOption2105 = new BitSet(new long[]{0x0000000200000000L});
+	public static final BitSet FOLLOW_LABEL_ASSIGN_in_elementOption2107 = new BitSet(new long[]{0x2108000080010000L,0x0000000000000040L});
+	public static final BitSet FOLLOW_optionValue_in_elementOption2109 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_treeSpec2131 = new BitSet(new long[]{0x6128000000010010L,0x0000000020000210L});
+	public static final BitSet FOLLOW_element_in_treeSpec2133 = new BitSet(new long[]{0x6128000000010010L,0x0000000020000210L});
+	public static final BitSet FOLLOW_element_in_treeSpec2137 = new BitSet(new long[]{0x6128000000010010L,0x0000000020000230L});
+	public static final BitSet FOLLOW_69_in_treeSpec2142 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_range2165 = new BitSet(new long[]{0x0000400000000000L});
+	public static final BitSet FOLLOW_RANGE_in_range2167 = new BitSet(new long[]{0x0000000000010000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_range2171 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_elementOptions_in_range2173 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_terminal2210 = new BitSet(new long[]{0x0002000000004002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_elementOptions_in_terminal2212 = new BitSet(new long[]{0x0002000000004002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_terminal2243 = new BitSet(new long[]{0x0002000000004802L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_terminal2245 = new BitSet(new long[]{0x0002000000004002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_elementOptions_in_terminal2248 = new BitSet(new long[]{0x0002000000004002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_terminal2269 = new BitSet(new long[]{0x0002000000004002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_elementOptions_in_terminal2271 = new BitSet(new long[]{0x0002000000004002L});
+	public static final BitSet FOLLOW_73_in_terminal2292 = new BitSet(new long[]{0x0002000000004002L,0x0000000000002000L});
+	public static final BitSet FOLLOW_elementOptions_in_terminal2294 = new BitSet(new long[]{0x0002000000004002L});
+	public static final BitSet FOLLOW_ROOT_in_terminal2321 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BANG_in_terminal2342 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_ebnf2385 = new BitSet(new long[]{0x0000000000000002L,0x00000000000140C0L});
+	public static final BitSet FOLLOW_80_in_ebnf2393 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_70_in_ebnf2410 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_71_in_ebnf2427 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_78_in_ebnf2444 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_80_in_ebnfSuffix2529 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_70_in_ebnfSuffix2541 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_71_in_ebnfSuffix2554 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite2583 = new BitSet(new long[]{0x0020000000000000L});
+	public static final BitSet FOLLOW_SEMPRED_in_rewrite2587 = new BitSet(new long[]{0x6109000000010010L,0x0000000000000018L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite2591 = new BitSet(new long[]{0x0001000000000000L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite2599 = new BitSet(new long[]{0x6108000000010010L,0x0000000000000018L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite2603 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_template_in_rewrite_alternative2654 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_alternative_in_rewrite_alternative2659 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_68_in_rewrite_tree_block2701 = new BitSet(new long[]{0x6108000000010010L,0x0000000000000018L});
+	public static final BitSet FOLLOW_rewrite_tree_alternative_in_rewrite_tree_block2703 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
+	public static final BitSet FOLLOW_69_in_rewrite_tree_block2705 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_element_in_rewrite_tree_alternative2739 = new BitSet(new long[]{0x6108000000010012L,0x0000000000000018L});
+	public static final BitSet FOLLOW_rewrite_tree_atom_in_rewrite_tree_element2767 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_atom_in_rewrite_tree_element2772 = new BitSet(new long[]{0x0000000000000000L,0x00000000000100C0L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_rewrite_tree_element2774 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_in_rewrite_tree_element2808 = new BitSet(new long[]{0x0000000000000002L,0x00000000000100C0L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_rewrite_tree_element2814 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_ebnf_in_rewrite_tree_element2860 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_rewrite_tree_atom2876 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_rewrite_tree_atom2883 = new BitSet(new long[]{0x0000000000000802L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rewrite_tree_atom2885 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_RULE_REF_in_rewrite_tree_atom2906 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_rewrite_tree_atom2913 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_67_in_rewrite_tree_atom2922 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_rewrite_tree_atom2924 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_tree_atom2935 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_block_in_rewrite_tree_ebnf2956 = new BitSet(new long[]{0x0000000000000000L,0x00000000000100C0L});
+	public static final BitSet FOLLOW_ebnfSuffix_in_rewrite_tree_ebnf2958 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_rewrite_tree2978 = new BitSet(new long[]{0x2108000000010010L,0x0000000000000008L});
+	public static final BitSet FOLLOW_rewrite_tree_atom_in_rewrite_tree2980 = new BitSet(new long[]{0x6108000000010010L,0x0000000000000038L});
+	public static final BitSet FOLLOW_rewrite_tree_element_in_rewrite_tree2982 = new BitSet(new long[]{0x6108000000010010L,0x0000000000000038L});
+	public static final BitSet FOLLOW_69_in_rewrite_tree2985 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_rewrite_template3017 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000010L});
+	public static final BitSet FOLLOW_68_in_rewrite_template3021 = new BitSet(new long[]{0x2008000000000000L,0x0000000000000020L});
+	public static final BitSet FOLLOW_rewrite_template_args_in_rewrite_template3023 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
+	public static final BitSet FOLLOW_69_in_rewrite_template3025 = new BitSet(new long[]{0x0000000000600000L});
+	public static final BitSet FOLLOW_DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template3033 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template3039 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_template_ref_in_rewrite_template3066 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_indirect_template_head_in_rewrite_template3075 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template3084 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_rewrite_template_ref3097 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000010L});
+	public static final BitSet FOLLOW_68_in_rewrite_template_ref3101 = new BitSet(new long[]{0x2008000000000000L,0x0000000000000020L});
+	public static final BitSet FOLLOW_rewrite_template_args_in_rewrite_template_ref3103 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
+	public static final BitSet FOLLOW_69_in_rewrite_template_ref3105 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_68_in_rewrite_indirect_template_head3133 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_indirect_template_head3135 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
+	public static final BitSet FOLLOW_69_in_rewrite_indirect_template_head3137 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000010L});
+	public static final BitSet FOLLOW_68_in_rewrite_indirect_template_head3139 = new BitSet(new long[]{0x2008000000000000L,0x0000000000000020L});
+	public static final BitSet FOLLOW_rewrite_template_args_in_rewrite_indirect_template_head3141 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});
+	public static final BitSet FOLLOW_69_in_rewrite_indirect_template_head3143 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_template_arg_in_rewrite_template_args3167 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000100L});
+	public static final BitSet FOLLOW_72_in_rewrite_template_args3170 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_rewrite_template_arg_in_rewrite_template_args3172 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000100L});
+	public static final BitSet FOLLOW_id_in_rewrite_template_arg3205 = new BitSet(new long[]{0x0000000200000000L});
+	public static final BitSet FOLLOW_LABEL_ASSIGN_in_rewrite_template_arg3207 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template_arg3209 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_id_in_qid3230 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000200L});
+	public static final BitSet FOLLOW_73_in_qid3233 = new BitSet(new long[]{0x2008000000000000L});
+	public static final BitSet FOLLOW_id_in_qid3235 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000200L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_id3247 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_RULE_REF_in_id3257 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_template_in_synpred1_ANTLRv32654 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_alternative_in_synpred2_ANTLRv32659 = new BitSet(new long[]{0x0000000000000002L});
+}
--- tool/src/main/java/org/antlr/grammar/v3/ANTLRv3Tree.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/ANTLRv3Tree.java	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,3771 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/ANTLRv3Tree.g 2019-04-04 15:18:50
+
+package org.antlr.grammar.v3;
+
+
+import org.antlr.runtime.*;
+import org.antlr.runtime.tree.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+
+/** ANTLR v3 tree grammar to walk trees created by ANTLRv3.g */
+@SuppressWarnings("all")
+public class ANTLRv3Tree extends TreeParser {
+	public static final String[] tokenNames = new String[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", 
+		"ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "ARG", "ARGLIST", "ARG_ACTION", 
+		"AT", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CHAR_LITERAL", "CHAR_RANGE", 
+		"CLOSURE", "COMBINED_GRAMMAR", "DOC_COMMENT", "DOUBLE_ANGLE_STRING_LITERAL", 
+		"DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", 
+		"FRAGMENT", "GATED_SEMPRED", "ID", "INT", "LABEL", "LABEL_ASSIGN", "LEXER", 
+		"LEXER_GRAMMAR", "LIST_LABEL_ASSIGN", "LITERAL_CHAR", "ML_COMMENT", "NESTED_ACTION", 
+		"NESTED_ARG_ACTION", "OPTIONAL", "OPTIONS", "PARSER", "PARSER_GRAMMAR", 
+		"POSITIVE_CLOSURE", "RANGE", "RET", "REWRITE", "ROOT", "RULE", "RULE_REF", 
+		"SCOPE", "SEMPRED", "SL_COMMENT", "SRC", "STRING_LITERAL", "SYNPRED", 
+		"SYN_SEMPRED", "TEMPLATE", "TOKENS", "TOKEN_REF", "TREE_BEGIN", "TREE_GRAMMAR", 
+		"WS", "WS_LOOP", "XDIGIT", "'$'", "'('", "')'", "'*'", "'+'", "','", "'.'", 
+		"':'", "'::'", "';'", "'<'", "'=>'", "'>'", "'?'", "'catch'", "'finally'", 
+		"'grammar'", "'lexer'", "'parser'", "'private'", "'protected'", "'public'", 
+		"'throws'", "'tree'", "'|'", "'}'", "'~'"
+	};
+	public static final int EOF=-1;
+	public static final int T__67=67;
+	public static final int T__68=68;
+	public static final int T__69=69;
+	public static final int T__70=70;
+	public static final int T__71=71;
+	public static final int T__72=72;
+	public static final int T__73=73;
+	public static final int T__74=74;
+	public static final int T__75=75;
+	public static final int T__76=76;
+	public static final int T__77=77;
+	public static final int T__78=78;
+	public static final int T__79=79;
+	public static final int T__80=80;
+	public static final int T__81=81;
+	public static final int T__82=82;
+	public static final int T__83=83;
+	public static final int T__84=84;
+	public static final int T__85=85;
+	public static final int T__86=86;
+	public static final int T__87=87;
+	public static final int T__88=88;
+	public static final int T__89=89;
+	public static final int T__90=90;
+	public static final int T__91=91;
+	public static final int T__92=92;
+	public static final int T__93=93;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int ARG=9;
+	public static final int ARGLIST=10;
+	public static final int ARG_ACTION=11;
+	public static final int AT=12;
+	public static final int BACKTRACK_SEMPRED=13;
+	public static final int BANG=14;
+	public static final int BLOCK=15;
+	public static final int CHAR_LITERAL=16;
+	public static final int CHAR_RANGE=17;
+	public static final int CLOSURE=18;
+	public static final int COMBINED_GRAMMAR=19;
+	public static final int DOC_COMMENT=20;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=21;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=22;
+	public static final int EOA=23;
+	public static final int EOB=24;
+	public static final int EOR=25;
+	public static final int EPSILON=26;
+	public static final int ESC=27;
+	public static final int FRAGMENT=28;
+	public static final int GATED_SEMPRED=29;
+	public static final int ID=30;
+	public static final int INT=31;
+	public static final int LABEL=32;
+	public static final int LABEL_ASSIGN=33;
+	public static final int LEXER=34;
+	public static final int LEXER_GRAMMAR=35;
+	public static final int LIST_LABEL_ASSIGN=36;
+	public static final int LITERAL_CHAR=37;
+	public static final int ML_COMMENT=38;
+	public static final int NESTED_ACTION=39;
+	public static final int NESTED_ARG_ACTION=40;
+	public static final int OPTIONAL=41;
+	public static final int OPTIONS=42;
+	public static final int PARSER=43;
+	public static final int PARSER_GRAMMAR=44;
+	public static final int POSITIVE_CLOSURE=45;
+	public static final int RANGE=46;
+	public static final int RET=47;
+	public static final int REWRITE=48;
+	public static final int ROOT=49;
+	public static final int RULE=50;
+	public static final int RULE_REF=51;
+	public static final int SCOPE=52;
+	public static final int SEMPRED=53;
+	public static final int SL_COMMENT=54;
+	public static final int SRC=55;
+	public static final int STRING_LITERAL=56;
+	public static final int SYNPRED=57;
+	public static final int SYN_SEMPRED=58;
+	public static final int TEMPLATE=59;
+	public static final int TOKENS=60;
+	public static final int TOKEN_REF=61;
+	public static final int TREE_BEGIN=62;
+	public static final int TREE_GRAMMAR=63;
+	public static final int WS=64;
+	public static final int WS_LOOP=65;
+	public static final int XDIGIT=66;
+
+	// delegates
+	public TreeParser[] getDelegates() {
+		return new TreeParser[] {};
+	}
+
+	// delegators
+
+
+	public ANTLRv3Tree(TreeNodeStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public ANTLRv3Tree(TreeNodeStream input, RecognizerSharedState state) {
+		super(input, state);
+	}
+
+	@Override public String[] getTokenNames() { return ANTLRv3Tree.tokenNames; }
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/ANTLRv3Tree.g"; }
+
+
+
+	// $ANTLR start "grammarDef"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:42:1: grammarDef : ^( grammarType ID ( DOC_COMMENT )? ( optionsSpec )? ( tokensSpec )? ( attrScope )* ( action )* ( rule )+ ) ;
+	public final void grammarDef() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:43:5: ( ^( grammarType ID ( DOC_COMMENT )? ( optionsSpec )? ( tokensSpec )? ( attrScope )* ( action )* ( rule )+ ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:43:9: ^( grammarType ID ( DOC_COMMENT )? ( optionsSpec )? ( tokensSpec )? ( attrScope )* ( action )* ( rule )+ )
+			{
+			pushFollow(FOLLOW_grammarType_in_grammarDef58);
+			grammarType();
+			state._fsp--;
+
+			match(input, Token.DOWN, null); 
+			match(input,ID,FOLLOW_ID_in_grammarDef60); 
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:43:27: ( DOC_COMMENT )?
+			int alt1=2;
+			int LA1_0 = input.LA(1);
+			if ( (LA1_0==DOC_COMMENT) ) {
+				alt1=1;
+			}
+			switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:43:27: DOC_COMMENT
+					{
+					match(input,DOC_COMMENT,FOLLOW_DOC_COMMENT_in_grammarDef62); 
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:43:40: ( optionsSpec )?
+			int alt2=2;
+			int LA2_0 = input.LA(1);
+			if ( (LA2_0==OPTIONS) ) {
+				alt2=1;
+			}
+			switch (alt2) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:43:40: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_grammarDef65);
+					optionsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:43:53: ( tokensSpec )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+			if ( (LA3_0==TOKENS) ) {
+				alt3=1;
+			}
+			switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:43:53: tokensSpec
+					{
+					pushFollow(FOLLOW_tokensSpec_in_grammarDef68);
+					tokensSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:43:65: ( attrScope )*
+			loop4:
+			while (true) {
+				int alt4=2;
+				int LA4_0 = input.LA(1);
+				if ( (LA4_0==SCOPE) ) {
+					alt4=1;
+				}
+
+				switch (alt4) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:43:65: attrScope
+					{
+					pushFollow(FOLLOW_attrScope_in_grammarDef71);
+					attrScope();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop4;
+				}
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:43:76: ( action )*
+			loop5:
+			while (true) {
+				int alt5=2;
+				int LA5_0 = input.LA(1);
+				if ( (LA5_0==AT) ) {
+					alt5=1;
+				}
+
+				switch (alt5) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:43:76: action
+					{
+					pushFollow(FOLLOW_action_in_grammarDef74);
+					action();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop5;
+				}
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:43:84: ( rule )+
+			int cnt6=0;
+			loop6:
+			while (true) {
+				int alt6=2;
+				int LA6_0 = input.LA(1);
+				if ( (LA6_0==RULE) ) {
+					alt6=1;
+				}
+
+				switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:43:84: rule
+					{
+					pushFollow(FOLLOW_rule_in_grammarDef77);
+					rule();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt6 >= 1 ) break loop6;
+					EarlyExitException eee = new EarlyExitException(6, input);
+					throw eee;
+				}
+				cnt6++;
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammarDef"
+
+
+
+	// $ANTLR start "grammarType"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:46:1: grammarType : ( LEXER_GRAMMAR | PARSER_GRAMMAR | TREE_GRAMMAR | COMBINED_GRAMMAR );
+	public final void grammarType() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:47:2: ( LEXER_GRAMMAR | PARSER_GRAMMAR | TREE_GRAMMAR | COMBINED_GRAMMAR )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:
+			{
+			if ( input.LA(1)==COMBINED_GRAMMAR||input.LA(1)==LEXER_GRAMMAR||input.LA(1)==PARSER_GRAMMAR||input.LA(1)==TREE_GRAMMAR ) {
+				input.consume();
+				state.errorRecovery=false;
+			}
+			else {
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammarType"
+
+
+
+	// $ANTLR start "tokensSpec"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:53:1: tokensSpec : ^( TOKENS ( tokenSpec )+ ) ;
+	public final void tokensSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:54:2: ( ^( TOKENS ( tokenSpec )+ ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:54:4: ^( TOKENS ( tokenSpec )+ )
+			{
+			match(input,TOKENS,FOLLOW_TOKENS_in_tokensSpec133); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:54:13: ( tokenSpec )+
+			int cnt7=0;
+			loop7:
+			while (true) {
+				int alt7=2;
+				int LA7_0 = input.LA(1);
+				if ( (LA7_0==LABEL_ASSIGN||LA7_0==TOKEN_REF) ) {
+					alt7=1;
+				}
+
+				switch (alt7) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:54:13: tokenSpec
+					{
+					pushFollow(FOLLOW_tokenSpec_in_tokensSpec135);
+					tokenSpec();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt7 >= 1 ) break loop7;
+					EarlyExitException eee = new EarlyExitException(7, input);
+					throw eee;
+				}
+				cnt7++;
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tokensSpec"
+
+
+
+	// $ANTLR start "tokenSpec"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:57:1: tokenSpec : ( ^( '=' TOKEN_REF STRING_LITERAL ) | ^( '=' TOKEN_REF CHAR_LITERAL ) | TOKEN_REF );
+	public final void tokenSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:58:2: ( ^( '=' TOKEN_REF STRING_LITERAL ) | ^( '=' TOKEN_REF CHAR_LITERAL ) | TOKEN_REF )
+			int alt8=3;
+			int LA8_0 = input.LA(1);
+			if ( (LA8_0==LABEL_ASSIGN) ) {
+				int LA8_1 = input.LA(2);
+				if ( (LA8_1==DOWN) ) {
+					int LA8_3 = input.LA(3);
+					if ( (LA8_3==TOKEN_REF) ) {
+						int LA8_4 = input.LA(4);
+						if ( (LA8_4==STRING_LITERAL) ) {
+							alt8=1;
+						}
+						else if ( (LA8_4==CHAR_LITERAL) ) {
+							alt8=2;
+						}
+
+						else {
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 8, 4, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+					}
+
+					else {
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 8, 3, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 8, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+			else if ( (LA8_0==TOKEN_REF) ) {
+				alt8=3;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 8, 0, input);
+				throw nvae;
+			}
+
+			switch (alt8) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:58:4: ^( '=' TOKEN_REF STRING_LITERAL )
+					{
+					match(input,LABEL_ASSIGN,FOLLOW_LABEL_ASSIGN_in_tokenSpec149); 
+					match(input, Token.DOWN, null); 
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec151); 
+					match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_tokenSpec153); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:59:4: ^( '=' TOKEN_REF CHAR_LITERAL )
+					{
+					match(input,LABEL_ASSIGN,FOLLOW_LABEL_ASSIGN_in_tokenSpec160); 
+					match(input, Token.DOWN, null); 
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec162); 
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_tokenSpec164); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:60:4: TOKEN_REF
+					{
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec170); 
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tokenSpec"
+
+
+
+	// $ANTLR start "attrScope"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:63:1: attrScope : ^( 'scope' ID ACTION ) ;
+	public final void attrScope() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:64:2: ( ^( 'scope' ID ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:64:4: ^( 'scope' ID ACTION )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_attrScope182); 
+			match(input, Token.DOWN, null); 
+			match(input,ID,FOLLOW_ID_in_attrScope184); 
+			match(input,ACTION,FOLLOW_ACTION_in_attrScope186); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "attrScope"
+
+
+
+	// $ANTLR start "action"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:67:1: action : ( ^( '@' ID ID ACTION ) | ^( '@' ID ACTION ) );
+	public final void action() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:68:2: ( ^( '@' ID ID ACTION ) | ^( '@' ID ACTION ) )
+			int alt9=2;
+			int LA9_0 = input.LA(1);
+			if ( (LA9_0==AT) ) {
+				int LA9_1 = input.LA(2);
+				if ( (LA9_1==DOWN) ) {
+					int LA9_2 = input.LA(3);
+					if ( (LA9_2==ID) ) {
+						int LA9_3 = input.LA(4);
+						if ( (LA9_3==ID) ) {
+							alt9=1;
+						}
+						else if ( (LA9_3==ACTION) ) {
+							alt9=2;
+						}
+
+						else {
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 9, 3, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+					}
+
+					else {
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 9, 2, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 9, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 9, 0, input);
+				throw nvae;
+			}
+
+			switch (alt9) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:68:4: ^( '@' ID ID ACTION )
+					{
+					match(input,AT,FOLLOW_AT_in_action199); 
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_action201); 
+					match(input,ID,FOLLOW_ID_in_action203); 
+					match(input,ACTION,FOLLOW_ACTION_in_action205); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:69:4: ^( '@' ID ACTION )
+					{
+					match(input,AT,FOLLOW_AT_in_action212); 
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_action214); 
+					match(input,ACTION,FOLLOW_ACTION_in_action216); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "action"
+
+
+
+	// $ANTLR start "optionsSpec"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:72:1: optionsSpec : ^( OPTIONS ( option )+ ) ;
+	public final void optionsSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:73:2: ( ^( OPTIONS ( option )+ ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:73:4: ^( OPTIONS ( option )+ )
+			{
+			match(input,OPTIONS,FOLLOW_OPTIONS_in_optionsSpec229); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:73:14: ( option )+
+			int cnt10=0;
+			loop10:
+			while (true) {
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+				if ( (LA10_0==ID||LA10_0==LABEL_ASSIGN) ) {
+					alt10=1;
+				}
+
+				switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:73:14: option
+					{
+					pushFollow(FOLLOW_option_in_optionsSpec231);
+					option();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt10 >= 1 ) break loop10;
+					EarlyExitException eee = new EarlyExitException(10, input);
+					throw eee;
+				}
+				cnt10++;
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "optionsSpec"
+
+
+
+	// $ANTLR start "option"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:76:1: option : ( qid | ^( '=' ID optionValue ) );
+	public final void option() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:77:5: ( qid | ^( '=' ID optionValue ) )
+			int alt11=2;
+			int LA11_0 = input.LA(1);
+			if ( (LA11_0==ID) ) {
+				alt11=1;
+			}
+			else if ( (LA11_0==LABEL_ASSIGN) ) {
+				alt11=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 11, 0, input);
+				throw nvae;
+			}
+
+			switch (alt11) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:77:9: qid
+					{
+					pushFollow(FOLLOW_qid_in_option249);
+					qid();
+					state._fsp--;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:78:7: ^( '=' ID optionValue )
+					{
+					match(input,LABEL_ASSIGN,FOLLOW_LABEL_ASSIGN_in_option259); 
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_option261); 
+					pushFollow(FOLLOW_optionValue_in_option263);
+					optionValue();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "option"
+
+
+
+	// $ANTLR start "optionValue"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:81:1: optionValue : ( ID | STRING_LITERAL | CHAR_LITERAL | INT );
+	public final void optionValue() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:82:5: ( ID | STRING_LITERAL | CHAR_LITERAL | INT )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:
+			{
+			if ( input.LA(1)==CHAR_LITERAL||(input.LA(1) >= ID && input.LA(1) <= INT)||input.LA(1)==STRING_LITERAL ) {
+				input.consume();
+				state.errorRecovery=false;
+			}
+			else {
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "optionValue"
+
+
+
+	// $ANTLR start "rule"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:88:1: rule : ^( RULE ID ( modifier )? ( ^( ARG ARG_ACTION ) )? ( ^( RET ARG_ACTION ) )? ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* altList ( exceptionGroup )? EOR ) ;
+	public final void rule() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:89:2: ( ^( RULE ID ( modifier )? ( ^( ARG ARG_ACTION ) )? ( ^( RET ARG_ACTION ) )? ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* altList ( exceptionGroup )? EOR ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:89:4: ^( RULE ID ( modifier )? ( ^( ARG ARG_ACTION ) )? ( ^( RET ARG_ACTION ) )? ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* altList ( exceptionGroup )? EOR )
+			{
+			match(input,RULE,FOLLOW_RULE_in_rule329); 
+			match(input, Token.DOWN, null); 
+			match(input,ID,FOLLOW_ID_in_rule331); 
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:89:15: ( modifier )?
+			int alt12=2;
+			int LA12_0 = input.LA(1);
+			if ( (LA12_0==FRAGMENT||(LA12_0 >= 86 && LA12_0 <= 88)) ) {
+				alt12=1;
+			}
+			switch (alt12) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:89:15: modifier
+					{
+					pushFollow(FOLLOW_modifier_in_rule333);
+					modifier();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:89:25: ( ^( ARG ARG_ACTION ) )?
+			int alt13=2;
+			int LA13_0 = input.LA(1);
+			if ( (LA13_0==ARG) ) {
+				alt13=1;
+			}
+			switch (alt13) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:89:26: ^( ARG ARG_ACTION )
+					{
+					match(input,ARG,FOLLOW_ARG_in_rule338); 
+					match(input, Token.DOWN, null); 
+					match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule340); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:89:46: ( ^( RET ARG_ACTION ) )?
+			int alt14=2;
+			int LA14_0 = input.LA(1);
+			if ( (LA14_0==RET) ) {
+				alt14=1;
+			}
+			switch (alt14) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:89:47: ^( RET ARG_ACTION )
+					{
+					match(input,RET,FOLLOW_RET_in_rule347); 
+					match(input, Token.DOWN, null); 
+					match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule349); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:90:9: ( throwsSpec )?
+			int alt15=2;
+			int LA15_0 = input.LA(1);
+			if ( (LA15_0==89) ) {
+				alt15=1;
+			}
+			switch (alt15) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:90:9: throwsSpec
+					{
+					pushFollow(FOLLOW_throwsSpec_in_rule362);
+					throwsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:90:21: ( optionsSpec )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+			if ( (LA16_0==OPTIONS) ) {
+				alt16=1;
+			}
+			switch (alt16) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:90:21: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_rule365);
+					optionsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:90:34: ( ruleScopeSpec )?
+			int alt17=2;
+			int LA17_0 = input.LA(1);
+			if ( (LA17_0==SCOPE) ) {
+				alt17=1;
+			}
+			switch (alt17) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:90:34: ruleScopeSpec
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_rule368);
+					ruleScopeSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:90:49: ( ruleAction )*
+			loop18:
+			while (true) {
+				int alt18=2;
+				int LA18_0 = input.LA(1);
+				if ( (LA18_0==AT) ) {
+					alt18=1;
+				}
+
+				switch (alt18) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:90:49: ruleAction
+					{
+					pushFollow(FOLLOW_ruleAction_in_rule371);
+					ruleAction();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop18;
+				}
+			}
+
+			pushFollow(FOLLOW_altList_in_rule382);
+			altList();
+			state._fsp--;
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:92:9: ( exceptionGroup )?
+			int alt19=2;
+			int LA19_0 = input.LA(1);
+			if ( ((LA19_0 >= 81 && LA19_0 <= 82)) ) {
+				alt19=1;
+			}
+			switch (alt19) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:92:9: exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_rule392);
+					exceptionGroup();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			match(input,EOR,FOLLOW_EOR_in_rule395); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rule"
+
+
+
+	// $ANTLR start "modifier"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:96:1: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
+	public final void modifier() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:97:2: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1) >= 86 && input.LA(1) <= 88) ) {
+				input.consume();
+				state.errorRecovery=false;
+			}
+			else {
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "modifier"
+
+
+
+	// $ANTLR start "ruleAction"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:101:1: ruleAction : ^( '@' ID ACTION ) ;
+	public final void ruleAction() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:102:2: ( ^( '@' ID ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:102:4: ^( '@' ID ACTION )
+			{
+			match(input,AT,FOLLOW_AT_in_ruleAction434); 
+			match(input, Token.DOWN, null); 
+			match(input,ID,FOLLOW_ID_in_ruleAction436); 
+			match(input,ACTION,FOLLOW_ACTION_in_ruleAction438); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ruleAction"
+
+
+
+	// $ANTLR start "throwsSpec"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:105:1: throwsSpec : ^( 'throws' ( ID )+ ) ;
+	public final void throwsSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:106:2: ( ^( 'throws' ( ID )+ ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:106:4: ^( 'throws' ( ID )+ )
+			{
+			match(input,89,FOLLOW_89_in_throwsSpec451); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:106:15: ( ID )+
+			int cnt20=0;
+			loop20:
+			while (true) {
+				int alt20=2;
+				int LA20_0 = input.LA(1);
+				if ( (LA20_0==ID) ) {
+					alt20=1;
+				}
+
+				switch (alt20) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:106:15: ID
+					{
+					match(input,ID,FOLLOW_ID_in_throwsSpec453); 
+					}
+					break;
+
+				default :
+					if ( cnt20 >= 1 ) break loop20;
+					EarlyExitException eee = new EarlyExitException(20, input);
+					throw eee;
+				}
+				cnt20++;
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "throwsSpec"
+
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:109:1: ruleScopeSpec : ( ^( 'scope' ACTION ) | ^( 'scope' ACTION ( ID )+ ) | ^( 'scope' ( ID )+ ) );
+	public final void ruleScopeSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:110:2: ( ^( 'scope' ACTION ) | ^( 'scope' ACTION ( ID )+ ) | ^( 'scope' ( ID )+ ) )
+			int alt23=3;
+			int LA23_0 = input.LA(1);
+			if ( (LA23_0==SCOPE) ) {
+				int LA23_1 = input.LA(2);
+				if ( (LA23_1==DOWN) ) {
+					int LA23_2 = input.LA(3);
+					if ( (LA23_2==ACTION) ) {
+						int LA23_3 = input.LA(4);
+						if ( (LA23_3==UP) ) {
+							alt23=1;
+						}
+						else if ( (LA23_3==ID) ) {
+							alt23=2;
+						}
+
+						else {
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 23, 3, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+					}
+					else if ( (LA23_2==ID) ) {
+						alt23=3;
+					}
+
+					else {
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 23, 2, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 23, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 23, 0, input);
+				throw nvae;
+			}
+
+			switch (alt23) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:110:4: ^( 'scope' ACTION )
+					{
+					match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec467); 
+					match(input, Token.DOWN, null); 
+					match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec469); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:111:4: ^( 'scope' ACTION ( ID )+ )
+					{
+					match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec476); 
+					match(input, Token.DOWN, null); 
+					match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec478); 
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:111:21: ( ID )+
+					int cnt21=0;
+					loop21:
+					while (true) {
+						int alt21=2;
+						int LA21_0 = input.LA(1);
+						if ( (LA21_0==ID) ) {
+							alt21=1;
+						}
+
+						switch (alt21) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:111:21: ID
+							{
+							match(input,ID,FOLLOW_ID_in_ruleScopeSpec480); 
+							}
+							break;
+
+						default :
+							if ( cnt21 >= 1 ) break loop21;
+							EarlyExitException eee = new EarlyExitException(21, input);
+							throw eee;
+						}
+						cnt21++;
+					}
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:112:4: ^( 'scope' ( ID )+ )
+					{
+					match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec488); 
+					match(input, Token.DOWN, null); 
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:112:14: ( ID )+
+					int cnt22=0;
+					loop22:
+					while (true) {
+						int alt22=2;
+						int LA22_0 = input.LA(1);
+						if ( (LA22_0==ID) ) {
+							alt22=1;
+						}
+
+						switch (alt22) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:112:14: ID
+							{
+							match(input,ID,FOLLOW_ID_in_ruleScopeSpec490); 
+							}
+							break;
+
+						default :
+							if ( cnt22 >= 1 ) break loop22;
+							EarlyExitException eee = new EarlyExitException(22, input);
+							throw eee;
+						}
+						cnt22++;
+					}
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+
+
+	// $ANTLR start "block"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:115:1: block : ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB ) ;
+	public final void block() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:116:5: ( ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:116:9: ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_block510); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:116:18: ( optionsSpec )?
+			int alt24=2;
+			int LA24_0 = input.LA(1);
+			if ( (LA24_0==OPTIONS) ) {
+				alt24=1;
+			}
+			switch (alt24) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:116:18: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_block512);
+					optionsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:116:31: ( alternative rewrite )+
+			int cnt25=0;
+			loop25:
+			while (true) {
+				int alt25=2;
+				int LA25_0 = input.LA(1);
+				if ( (LA25_0==ALT) ) {
+					alt25=1;
+				}
+
+				switch (alt25) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:116:32: alternative rewrite
+					{
+					pushFollow(FOLLOW_alternative_in_block516);
+					alternative();
+					state._fsp--;
+
+					pushFollow(FOLLOW_rewrite_in_block518);
+					rewrite();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt25 >= 1 ) break loop25;
+					EarlyExitException eee = new EarlyExitException(25, input);
+					throw eee;
+				}
+				cnt25++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_block522); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "block"
+
+
+
+	// $ANTLR start "altList"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:119:1: altList : ^( BLOCK ( alternative rewrite )+ EOB ) ;
+	public final void altList() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:120:5: ( ^( BLOCK ( alternative rewrite )+ EOB ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:120:9: ^( BLOCK ( alternative rewrite )+ EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_altList545); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:120:18: ( alternative rewrite )+
+			int cnt26=0;
+			loop26:
+			while (true) {
+				int alt26=2;
+				int LA26_0 = input.LA(1);
+				if ( (LA26_0==ALT) ) {
+					alt26=1;
+				}
+
+				switch (alt26) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:120:19: alternative rewrite
+					{
+					pushFollow(FOLLOW_alternative_in_altList548);
+					alternative();
+					state._fsp--;
+
+					pushFollow(FOLLOW_rewrite_in_altList550);
+					rewrite();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt26 >= 1 ) break loop26;
+					EarlyExitException eee = new EarlyExitException(26, input);
+					throw eee;
+				}
+				cnt26++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_altList554); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "altList"
+
+
+
+	// $ANTLR start "alternative"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:123:1: alternative : ( ^( ALT ( element )+ EOA ) | ^( ALT EPSILON EOA ) );
+	public final void alternative() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:124:5: ( ^( ALT ( element )+ EOA ) | ^( ALT EPSILON EOA ) )
+			int alt28=2;
+			int LA28_0 = input.LA(1);
+			if ( (LA28_0==ALT) ) {
+				int LA28_1 = input.LA(2);
+				if ( (LA28_1==DOWN) ) {
+					int LA28_2 = input.LA(3);
+					if ( (LA28_2==EPSILON) ) {
+						alt28=2;
+					}
+					else if ( (LA28_2==ACTION||(LA28_2 >= BANG && LA28_2 <= CLOSURE)||LA28_2==GATED_SEMPRED||LA28_2==LABEL_ASSIGN||LA28_2==LIST_LABEL_ASSIGN||LA28_2==OPTIONAL||LA28_2==POSITIVE_CLOSURE||LA28_2==ROOT||LA28_2==RULE_REF||LA28_2==SEMPRED||(LA28_2 >= STRING_LITERAL && LA28_2 <= SYN_SEMPRED)||(LA28_2 >= TOKEN_REF && LA28_2 <= TREE_BEGIN)||LA28_2==73||LA28_2==93) ) {
+						alt28=1;
+					}
+
+					else {
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 28, 2, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 28, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 28, 0, input);
+				throw nvae;
+			}
+
+			switch (alt28) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:124:9: ^( ALT ( element )+ EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_alternative576); 
+					match(input, Token.DOWN, null); 
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:124:15: ( element )+
+					int cnt27=0;
+					loop27:
+					while (true) {
+						int alt27=2;
+						int LA27_0 = input.LA(1);
+						if ( (LA27_0==ACTION||(LA27_0 >= BANG && LA27_0 <= CLOSURE)||LA27_0==GATED_SEMPRED||LA27_0==LABEL_ASSIGN||LA27_0==LIST_LABEL_ASSIGN||LA27_0==OPTIONAL||LA27_0==POSITIVE_CLOSURE||LA27_0==ROOT||LA27_0==RULE_REF||LA27_0==SEMPRED||(LA27_0 >= STRING_LITERAL && LA27_0 <= SYN_SEMPRED)||(LA27_0 >= TOKEN_REF && LA27_0 <= TREE_BEGIN)||LA27_0==73||LA27_0==93) ) {
+							alt27=1;
+						}
+
+						switch (alt27) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:124:15: element
+							{
+							pushFollow(FOLLOW_element_in_alternative578);
+							element();
+							state._fsp--;
+
+							}
+							break;
+
+						default :
+							if ( cnt27 >= 1 ) break loop27;
+							EarlyExitException eee = new EarlyExitException(27, input);
+							throw eee;
+						}
+						cnt27++;
+					}
+
+					match(input,EOA,FOLLOW_EOA_in_alternative581); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:125:9: ^( ALT EPSILON EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_alternative593); 
+					match(input, Token.DOWN, null); 
+					match(input,EPSILON,FOLLOW_EPSILON_in_alternative595); 
+					match(input,EOA,FOLLOW_EOA_in_alternative597); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "alternative"
+
+
+
+	// $ANTLR start "exceptionGroup"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:128:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	public final void exceptionGroup() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:129:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt31=2;
+			int LA31_0 = input.LA(1);
+			if ( (LA31_0==81) ) {
+				alt31=1;
+			}
+			else if ( (LA31_0==82) ) {
+				alt31=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 31, 0, input);
+				throw nvae;
+			}
+
+			switch (alt31) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:129:4: ( exceptionHandler )+ ( finallyClause )?
+					{
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:129:4: ( exceptionHandler )+
+					int cnt29=0;
+					loop29:
+					while (true) {
+						int alt29=2;
+						int LA29_0 = input.LA(1);
+						if ( (LA29_0==81) ) {
+							alt29=1;
+						}
+
+						switch (alt29) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:129:4: exceptionHandler
+							{
+							pushFollow(FOLLOW_exceptionHandler_in_exceptionGroup612);
+							exceptionHandler();
+							state._fsp--;
+
+							}
+							break;
+
+						default :
+							if ( cnt29 >= 1 ) break loop29;
+							EarlyExitException eee = new EarlyExitException(29, input);
+							throw eee;
+						}
+						cnt29++;
+					}
+
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:129:22: ( finallyClause )?
+					int alt30=2;
+					int LA30_0 = input.LA(1);
+					if ( (LA30_0==82) ) {
+						alt30=1;
+					}
+					switch (alt30) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:129:22: finallyClause
+							{
+							pushFollow(FOLLOW_finallyClause_in_exceptionGroup615);
+							finallyClause();
+							state._fsp--;
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:130:4: finallyClause
+					{
+					pushFollow(FOLLOW_finallyClause_in_exceptionGroup621);
+					finallyClause();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+
+	// $ANTLR start "exceptionHandler"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:133:1: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	public final void exceptionHandler() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:134:5: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:134:10: ^( 'catch' ARG_ACTION ACTION )
+			{
+			match(input,81,FOLLOW_81_in_exceptionHandler642); 
+			match(input, Token.DOWN, null); 
+			match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_exceptionHandler644); 
+			match(input,ACTION,FOLLOW_ACTION_in_exceptionHandler646); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+
+	// $ANTLR start "finallyClause"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:137:1: finallyClause : ^( 'finally' ACTION ) ;
+	public final void finallyClause() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:138:5: ( ^( 'finally' ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:138:10: ^( 'finally' ACTION )
+			{
+			match(input,82,FOLLOW_82_in_finallyClause668); 
+			match(input, Token.DOWN, null); 
+			match(input,ACTION,FOLLOW_ACTION_in_finallyClause670); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "finallyClause"
+
+
+
+	// $ANTLR start "element"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:141:1: element : ( ^( ( '=' | '+=' ) ID block ) | ^( ( '=' | '+=' ) ID atom ) | atom | ebnf | ACTION | SEMPRED | GATED_SEMPRED | ^( TREE_BEGIN ( element )+ ) );
+	public final void element() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:142:2: ( ^( ( '=' | '+=' ) ID block ) | ^( ( '=' | '+=' ) ID atom ) | atom | ebnf | ACTION | SEMPRED | GATED_SEMPRED | ^( TREE_BEGIN ( element )+ ) )
+			int alt33=8;
+			switch ( input.LA(1) ) {
+			case LABEL_ASSIGN:
+			case LIST_LABEL_ASSIGN:
+				{
+				int LA33_1 = input.LA(2);
+				if ( (LA33_1==DOWN) ) {
+					int LA33_8 = input.LA(3);
+					if ( (LA33_8==ID) ) {
+						int LA33_9 = input.LA(4);
+						if ( (LA33_9==BLOCK) ) {
+							alt33=1;
+						}
+						else if ( (LA33_9==BANG||(LA33_9 >= CHAR_LITERAL && LA33_9 <= CHAR_RANGE)||LA33_9==ROOT||LA33_9==RULE_REF||LA33_9==STRING_LITERAL||LA33_9==TOKEN_REF||LA33_9==73||LA33_9==93) ) {
+							alt33=2;
+						}
+
+						else {
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 33, 9, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+					}
+
+					else {
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 33, 8, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 33, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case BANG:
+			case CHAR_LITERAL:
+			case CHAR_RANGE:
+			case ROOT:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case 73:
+			case 93:
+				{
+				alt33=3;
+				}
+				break;
+			case BLOCK:
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+			case SYNPRED:
+			case SYN_SEMPRED:
+				{
+				alt33=4;
+				}
+				break;
+			case ACTION:
+				{
+				alt33=5;
+				}
+				break;
+			case SEMPRED:
+				{
+				alt33=6;
+				}
+				break;
+			case GATED_SEMPRED:
+				{
+				alt33=7;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt33=8;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 33, 0, input);
+				throw nvae;
+			}
+			switch (alt33) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:142:4: ^( ( '=' | '+=' ) ID block )
+					{
+					if ( input.LA(1)==LABEL_ASSIGN||input.LA(1)==LIST_LABEL_ASSIGN ) {
+						input.consume();
+						state.errorRecovery=false;
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						throw mse;
+					}
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_element692); 
+					pushFollow(FOLLOW_block_in_element694);
+					block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:143:4: ^( ( '=' | '+=' ) ID atom )
+					{
+					if ( input.LA(1)==LABEL_ASSIGN||input.LA(1)==LIST_LABEL_ASSIGN ) {
+						input.consume();
+						state.errorRecovery=false;
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						throw mse;
+					}
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_element707); 
+					pushFollow(FOLLOW_atom_in_element709);
+					atom();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:144:4: atom
+					{
+					pushFollow(FOLLOW_atom_in_element715);
+					atom();
+					state._fsp--;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:145:4: ebnf
+					{
+					pushFollow(FOLLOW_ebnf_in_element720);
+					ebnf();
+					state._fsp--;
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:146:6: ACTION
+					{
+					match(input,ACTION,FOLLOW_ACTION_in_element727); 
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:147:6: SEMPRED
+					{
+					match(input,SEMPRED,FOLLOW_SEMPRED_in_element734); 
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:148:4: GATED_SEMPRED
+					{
+					match(input,GATED_SEMPRED,FOLLOW_GATED_SEMPRED_in_element739); 
+					}
+					break;
+				case 8 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:149:6: ^( TREE_BEGIN ( element )+ )
+					{
+					match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_element747); 
+					match(input, Token.DOWN, null); 
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:149:19: ( element )+
+					int cnt32=0;
+					loop32:
+					while (true) {
+						int alt32=2;
+						int LA32_0 = input.LA(1);
+						if ( (LA32_0==ACTION||(LA32_0 >= BANG && LA32_0 <= CLOSURE)||LA32_0==GATED_SEMPRED||LA32_0==LABEL_ASSIGN||LA32_0==LIST_LABEL_ASSIGN||LA32_0==OPTIONAL||LA32_0==POSITIVE_CLOSURE||LA32_0==ROOT||LA32_0==RULE_REF||LA32_0==SEMPRED||(LA32_0 >= STRING_LITERAL && LA32_0 <= SYN_SEMPRED)||(LA32_0 >= TOKEN_REF && LA32_0 <= TREE_BEGIN)||LA32_0==73||LA32_0==93) ) {
+							alt32=1;
+						}
+
+						switch (alt32) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:149:19: element
+							{
+							pushFollow(FOLLOW_element_in_element749);
+							element();
+							state._fsp--;
+
+							}
+							break;
+
+						default :
+							if ( cnt32 >= 1 ) break loop32;
+							EarlyExitException eee = new EarlyExitException(32, input);
+							throw eee;
+						}
+						cnt32++;
+					}
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "element"
+
+
+
+	// $ANTLR start "atom"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:152:1: atom : ( ^( ( '^' | '!' ) atom ) | ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ( optionsSpec )? ) | ^( '~' notTerminal ( optionsSpec )? ) | ^( '~' block ( optionsSpec )? ) | ^( RULE_REF ARG_ACTION ) | RULE_REF | CHAR_LITERAL | ^( CHAR_LITERAL optionsSpec ) | TOKEN_REF | ^( TOKEN_REF optionsSpec ) | ^( TOKEN_REF ARG_ACTION optionsSpec ) | ^( TOKEN_REF ARG_ACTION ) | STRING_LITERAL | ^( STRING_LITERAL optionsSpec ) | '.' | ^( '.' ( optionsSpec )? ) );
+	public final void atom() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:152:5: ( ^( ( '^' | '!' ) atom ) | ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ( optionsSpec )? ) | ^( '~' notTerminal ( optionsSpec )? ) | ^( '~' block ( optionsSpec )? ) | ^( RULE_REF ARG_ACTION ) | RULE_REF | CHAR_LITERAL | ^( CHAR_LITERAL optionsSpec ) | TOKEN_REF | ^( TOKEN_REF optionsSpec ) | ^( TOKEN_REF ARG_ACTION optionsSpec ) | ^( TOKEN_REF ARG_ACTION ) | STRING_LITERAL | ^( STRING_LITERAL optionsSpec ) | '.' | ^( '.' ( optionsSpec )? ) )
+			int alt38=16;
+			switch ( input.LA(1) ) {
+			case BANG:
+			case ROOT:
+				{
+				alt38=1;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt38=2;
+				}
+				break;
+			case 93:
+				{
+				int LA38_3 = input.LA(2);
+				if ( (LA38_3==DOWN) ) {
+					int LA38_9 = input.LA(3);
+					if ( (LA38_9==CHAR_LITERAL||LA38_9==STRING_LITERAL||LA38_9==TOKEN_REF) ) {
+						alt38=3;
+					}
+					else if ( (LA38_9==BLOCK) ) {
+						alt38=4;
+					}
+
+					else {
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 38, 9, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 38, 3, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case RULE_REF:
+				{
+				int LA38_4 = input.LA(2);
+				if ( (LA38_4==DOWN) ) {
+					alt38=5;
+				}
+				else if ( ((LA38_4 >= UP && LA38_4 <= ACTION)||(LA38_4 >= BANG && LA38_4 <= CLOSURE)||LA38_4==EOA||LA38_4==GATED_SEMPRED||LA38_4==LABEL_ASSIGN||LA38_4==LIST_LABEL_ASSIGN||LA38_4==OPTIONAL||LA38_4==POSITIVE_CLOSURE||LA38_4==ROOT||LA38_4==RULE_REF||LA38_4==SEMPRED||(LA38_4 >= STRING_LITERAL && LA38_4 <= SYN_SEMPRED)||(LA38_4 >= TOKEN_REF && LA38_4 <= TREE_BEGIN)||LA38_4==73||LA38_4==93) ) {
+					alt38=6;
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 38, 4, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				int LA38_5 = input.LA(2);
+				if ( (LA38_5==DOWN) ) {
+					alt38=8;
+				}
+				else if ( ((LA38_5 >= UP && LA38_5 <= ACTION)||(LA38_5 >= BANG && LA38_5 <= CLOSURE)||LA38_5==EOA||LA38_5==GATED_SEMPRED||LA38_5==LABEL_ASSIGN||LA38_5==LIST_LABEL_ASSIGN||LA38_5==OPTIONAL||LA38_5==POSITIVE_CLOSURE||LA38_5==ROOT||LA38_5==RULE_REF||LA38_5==SEMPRED||(LA38_5 >= STRING_LITERAL && LA38_5 <= SYN_SEMPRED)||(LA38_5 >= TOKEN_REF && LA38_5 <= TREE_BEGIN)||LA38_5==73||LA38_5==93) ) {
+					alt38=7;
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 38, 5, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case TOKEN_REF:
+				{
+				int LA38_6 = input.LA(2);
+				if ( (LA38_6==DOWN) ) {
+					int LA38_14 = input.LA(3);
+					if ( (LA38_14==ARG_ACTION) ) {
+						int LA38_22 = input.LA(4);
+						if ( (LA38_22==UP) ) {
+							alt38=12;
+						}
+						else if ( (LA38_22==OPTIONS) ) {
+							alt38=11;
+						}
+
+						else {
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 38, 22, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+					}
+					else if ( (LA38_14==OPTIONS) ) {
+						alt38=10;
+					}
+
+					else {
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 38, 14, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+				else if ( ((LA38_6 >= UP && LA38_6 <= ACTION)||(LA38_6 >= BANG && LA38_6 <= CLOSURE)||LA38_6==EOA||LA38_6==GATED_SEMPRED||LA38_6==LABEL_ASSIGN||LA38_6==LIST_LABEL_ASSIGN||LA38_6==OPTIONAL||LA38_6==POSITIVE_CLOSURE||LA38_6==ROOT||LA38_6==RULE_REF||LA38_6==SEMPRED||(LA38_6 >= STRING_LITERAL && LA38_6 <= SYN_SEMPRED)||(LA38_6 >= TOKEN_REF && LA38_6 <= TREE_BEGIN)||LA38_6==73||LA38_6==93) ) {
+					alt38=9;
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 38, 6, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				int LA38_7 = input.LA(2);
+				if ( (LA38_7==DOWN) ) {
+					alt38=14;
+				}
+				else if ( ((LA38_7 >= UP && LA38_7 <= ACTION)||(LA38_7 >= BANG && LA38_7 <= CLOSURE)||LA38_7==EOA||LA38_7==GATED_SEMPRED||LA38_7==LABEL_ASSIGN||LA38_7==LIST_LABEL_ASSIGN||LA38_7==OPTIONAL||LA38_7==POSITIVE_CLOSURE||LA38_7==ROOT||LA38_7==RULE_REF||LA38_7==SEMPRED||(LA38_7 >= STRING_LITERAL && LA38_7 <= SYN_SEMPRED)||(LA38_7 >= TOKEN_REF && LA38_7 <= TREE_BEGIN)||LA38_7==73||LA38_7==93) ) {
+					alt38=13;
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 38, 7, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case 73:
+				{
+				int LA38_8 = input.LA(2);
+				if ( (LA38_8==DOWN) ) {
+					alt38=16;
+				}
+				else if ( ((LA38_8 >= UP && LA38_8 <= ACTION)||(LA38_8 >= BANG && LA38_8 <= CLOSURE)||LA38_8==EOA||LA38_8==GATED_SEMPRED||LA38_8==LABEL_ASSIGN||LA38_8==LIST_LABEL_ASSIGN||LA38_8==OPTIONAL||LA38_8==POSITIVE_CLOSURE||LA38_8==ROOT||LA38_8==RULE_REF||LA38_8==SEMPRED||(LA38_8 >= STRING_LITERAL && LA38_8 <= SYN_SEMPRED)||(LA38_8 >= TOKEN_REF && LA38_8 <= TREE_BEGIN)||LA38_8==73||LA38_8==93) ) {
+					alt38=15;
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 38, 8, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 38, 0, input);
+				throw nvae;
+			}
+			switch (alt38) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:152:9: ^( ( '^' | '!' ) atom )
+					{
+					if ( input.LA(1)==BANG||input.LA(1)==ROOT ) {
+						input.consume();
+						state.errorRecovery=false;
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						throw mse;
+					}
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_atom_in_atom769);
+					atom();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:153:4: ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ( optionsSpec )? )
+					{
+					match(input,CHAR_RANGE,FOLLOW_CHAR_RANGE_in_atom776); 
+					match(input, Token.DOWN, null); 
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom778); 
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom780); 
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:153:43: ( optionsSpec )?
+					int alt34=2;
+					int LA34_0 = input.LA(1);
+					if ( (LA34_0==OPTIONS) ) {
+						alt34=1;
+					}
+					switch (alt34) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:153:43: optionsSpec
+							{
+							pushFollow(FOLLOW_optionsSpec_in_atom782);
+							optionsSpec();
+							state._fsp--;
+
+							}
+							break;
+
+					}
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:154:4: ^( '~' notTerminal ( optionsSpec )? )
+					{
+					match(input,93,FOLLOW_93_in_atom790); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_notTerminal_in_atom792);
+					notTerminal();
+					state._fsp--;
+
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:154:22: ( optionsSpec )?
+					int alt35=2;
+					int LA35_0 = input.LA(1);
+					if ( (LA35_0==OPTIONS) ) {
+						alt35=1;
+					}
+					switch (alt35) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:154:22: optionsSpec
+							{
+							pushFollow(FOLLOW_optionsSpec_in_atom794);
+							optionsSpec();
+							state._fsp--;
+
+							}
+							break;
+
+					}
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:155:4: ^( '~' block ( optionsSpec )? )
+					{
+					match(input,93,FOLLOW_93_in_atom802); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_atom804);
+					block();
+					state._fsp--;
+
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:155:16: ( optionsSpec )?
+					int alt36=2;
+					int LA36_0 = input.LA(1);
+					if ( (LA36_0==OPTIONS) ) {
+						alt36=1;
+					}
+					switch (alt36) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:155:16: optionsSpec
+							{
+							pushFollow(FOLLOW_optionsSpec_in_atom806);
+							optionsSpec();
+							state._fsp--;
+
+							}
+							break;
+
+					}
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:156:7: ^( RULE_REF ARG_ACTION )
+					{
+					match(input,RULE_REF,FOLLOW_RULE_REF_in_atom817); 
+					match(input, Token.DOWN, null); 
+					match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom819); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:157:7: RULE_REF
+					{
+					match(input,RULE_REF,FOLLOW_RULE_REF_in_atom828); 
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:158:9: CHAR_LITERAL
+					{
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom838); 
+					}
+					break;
+				case 8 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:159:9: ^( CHAR_LITERAL optionsSpec )
+					{
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom849); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_optionsSpec_in_atom851);
+					optionsSpec();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 9 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:160:7: TOKEN_REF
+					{
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom860); 
+					}
+					break;
+				case 10 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:161:7: ^( TOKEN_REF optionsSpec )
+					{
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom869); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_optionsSpec_in_atom871);
+					optionsSpec();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 11 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:162:7: ^( TOKEN_REF ARG_ACTION optionsSpec )
+					{
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom881); 
+					match(input, Token.DOWN, null); 
+					match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom883); 
+					pushFollow(FOLLOW_optionsSpec_in_atom885);
+					optionsSpec();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 12 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:163:7: ^( TOKEN_REF ARG_ACTION )
+					{
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom895); 
+					match(input, Token.DOWN, null); 
+					match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom897); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 13 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:164:7: STRING_LITERAL
+					{
+					match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_atom906); 
+					}
+					break;
+				case 14 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:165:7: ^( STRING_LITERAL optionsSpec )
+					{
+					match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_atom915); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_optionsSpec_in_atom917);
+					optionsSpec();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 15 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:166:7: '.'
+					{
+					match(input,73,FOLLOW_73_in_atom926); 
+					}
+					break;
+				case 16 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:167:7: ^( '.' ( optionsSpec )? )
+					{
+					match(input,73,FOLLOW_73_in_atom935); 
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); 
+						// org/antlr/grammar/v3/ANTLRv3Tree.g:167:13: ( optionsSpec )?
+						int alt37=2;
+						int LA37_0 = input.LA(1);
+						if ( (LA37_0==OPTIONS) ) {
+							alt37=1;
+						}
+						switch (alt37) {
+							case 1 :
+								// org/antlr/grammar/v3/ANTLRv3Tree.g:167:13: optionsSpec
+								{
+								pushFollow(FOLLOW_optionsSpec_in_atom937);
+								optionsSpec();
+								state._fsp--;
+
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); 
+					}
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "atom"
+
+
+
+	// $ANTLR start "ebnf"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:171:1: ebnf : ( ^( SYNPRED block ) | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) | SYN_SEMPRED | block );
+	public final void ebnf() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:172:2: ( ^( SYNPRED block ) | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) | SYN_SEMPRED | block )
+			int alt39=6;
+			switch ( input.LA(1) ) {
+			case SYNPRED:
+				{
+				alt39=1;
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt39=2;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt39=3;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt39=4;
+				}
+				break;
+			case SYN_SEMPRED:
+				{
+				alt39=5;
+				}
+				break;
+			case BLOCK:
+				{
+				alt39=6;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 39, 0, input);
+				throw nvae;
+			}
+			switch (alt39) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:172:4: ^( SYNPRED block )
+					{
+					match(input,SYNPRED,FOLLOW_SYNPRED_in_ebnf956); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_ebnf958);
+					block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:173:4: ^( OPTIONAL block )
+					{
+					match(input,OPTIONAL,FOLLOW_OPTIONAL_in_ebnf965); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_ebnf967);
+					block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:174:6: ^( CLOSURE block )
+					{
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_ebnf976); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_ebnf978);
+					block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:175:7: ^( POSITIVE_CLOSURE block )
+					{
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_ebnf988); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_ebnf990);
+					block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:176:4: SYN_SEMPRED
+					{
+					match(input,SYN_SEMPRED,FOLLOW_SYN_SEMPRED_in_ebnf996); 
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:177:4: block
+					{
+					pushFollow(FOLLOW_block_in_ebnf1001);
+					block();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ebnf"
+
+
+
+	// $ANTLR start "notTerminal"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:180:1: notTerminal : ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL );
+	public final void notTerminal() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:181:2: ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:
+			{
+			if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL||input.LA(1)==TOKEN_REF ) {
+				input.consume();
+				state.errorRecovery=false;
+			}
+			else {
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "notTerminal"
+
+
+
+	// $ANTLR start "rewrite"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:188:1: rewrite : ( ( ^( '->' SEMPRED rewrite_alternative ) )* ^( '->' rewrite_alternative ) |);
+	public final void rewrite() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:189:2: ( ( ^( '->' SEMPRED rewrite_alternative ) )* ^( '->' rewrite_alternative ) |)
+			int alt41=2;
+			int LA41_0 = input.LA(1);
+			if ( (LA41_0==REWRITE) ) {
+				alt41=1;
+			}
+			else if ( (LA41_0==ALT||LA41_0==EOB) ) {
+				alt41=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 41, 0, input);
+				throw nvae;
+			}
+
+			switch (alt41) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:189:4: ( ^( '->' SEMPRED rewrite_alternative ) )* ^( '->' rewrite_alternative )
+					{
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:189:4: ( ^( '->' SEMPRED rewrite_alternative ) )*
+					loop40:
+					while (true) {
+						int alt40=2;
+						int LA40_0 = input.LA(1);
+						if ( (LA40_0==REWRITE) ) {
+							int LA40_1 = input.LA(2);
+							if ( (LA40_1==DOWN) ) {
+								int LA40_2 = input.LA(3);
+								if ( (LA40_2==SEMPRED) ) {
+									alt40=1;
+								}
+
+							}
+
+						}
+
+						switch (alt40) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:189:5: ^( '->' SEMPRED rewrite_alternative )
+							{
+							match(input,REWRITE,FOLLOW_REWRITE_in_rewrite1041); 
+							match(input, Token.DOWN, null); 
+							match(input,SEMPRED,FOLLOW_SEMPRED_in_rewrite1043); 
+							pushFollow(FOLLOW_rewrite_alternative_in_rewrite1045);
+							rewrite_alternative();
+							state._fsp--;
+
+							match(input, Token.UP, null); 
+
+							}
+							break;
+
+						default :
+							break loop40;
+						}
+					}
+
+					match(input,REWRITE,FOLLOW_REWRITE_in_rewrite1051); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_rewrite_alternative_in_rewrite1053);
+					rewrite_alternative();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:191:2: 
+					{
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite"
+
+
+
+	// $ANTLR start "rewrite_alternative"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:193:1: rewrite_alternative : ( rewrite_template | rewrite_tree_alternative | ^( ALT EPSILON EOA ) );
+	public final void rewrite_alternative() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:194:2: ( rewrite_template | rewrite_tree_alternative | ^( ALT EPSILON EOA ) )
+			int alt42=3;
+			int LA42_0 = input.LA(1);
+			if ( (LA42_0==ACTION||LA42_0==TEMPLATE) ) {
+				alt42=1;
+			}
+			else if ( (LA42_0==ALT) ) {
+				int LA42_2 = input.LA(2);
+				if ( (LA42_2==DOWN) ) {
+					int LA42_3 = input.LA(3);
+					if ( (LA42_3==EPSILON) ) {
+						alt42=3;
+					}
+					else if ( (LA42_3==ACTION||(LA42_3 >= BLOCK && LA42_3 <= CHAR_LITERAL)||LA42_3==CLOSURE||LA42_3==LABEL||LA42_3==OPTIONAL||LA42_3==POSITIVE_CLOSURE||LA42_3==RULE_REF||LA42_3==STRING_LITERAL||(LA42_3 >= TOKEN_REF && LA42_3 <= TREE_BEGIN)) ) {
+						alt42=2;
+					}
+
+					else {
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 42, 3, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 42, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 42, 0, input);
+				throw nvae;
+			}
+
+			switch (alt42) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:194:4: rewrite_template
+					{
+					pushFollow(FOLLOW_rewrite_template_in_rewrite_alternative1068);
+					rewrite_template();
+					state._fsp--;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:195:4: rewrite_tree_alternative
+					{
+					pushFollow(FOLLOW_rewrite_tree_alternative_in_rewrite_alternative1073);
+					rewrite_tree_alternative();
+					state._fsp--;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:196:9: ^( ALT EPSILON EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_rewrite_alternative1084); 
+					match(input, Token.DOWN, null); 
+					match(input,EPSILON,FOLLOW_EPSILON_in_rewrite_alternative1086); 
+					match(input,EOA,FOLLOW_EOA_in_rewrite_alternative1088); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_alternative"
+
+
+
+	// $ANTLR start "rewrite_tree_block"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:199:1: rewrite_tree_block : ^( BLOCK rewrite_tree_alternative EOB ) ;
+	public final void rewrite_tree_block() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:200:5: ( ^( BLOCK rewrite_tree_alternative EOB ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:200:9: ^( BLOCK rewrite_tree_alternative EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_rewrite_tree_block1107); 
+			match(input, Token.DOWN, null); 
+			pushFollow(FOLLOW_rewrite_tree_alternative_in_rewrite_tree_block1109);
+			rewrite_tree_alternative();
+			state._fsp--;
+
+			match(input,EOB,FOLLOW_EOB_in_rewrite_tree_block1111); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_tree_block"
+
+
+
+	// $ANTLR start "rewrite_tree_alternative"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:203:1: rewrite_tree_alternative : ^( ALT ( rewrite_tree_element )+ EOA ) ;
+	public final void rewrite_tree_alternative() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:204:5: ( ^( ALT ( rewrite_tree_element )+ EOA ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:204:7: ^( ALT ( rewrite_tree_element )+ EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_rewrite_tree_alternative1130); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:204:13: ( rewrite_tree_element )+
+			int cnt43=0;
+			loop43:
+			while (true) {
+				int alt43=2;
+				int LA43_0 = input.LA(1);
+				if ( (LA43_0==ACTION||(LA43_0 >= BLOCK && LA43_0 <= CHAR_LITERAL)||LA43_0==CLOSURE||LA43_0==LABEL||LA43_0==OPTIONAL||LA43_0==POSITIVE_CLOSURE||LA43_0==RULE_REF||LA43_0==STRING_LITERAL||(LA43_0 >= TOKEN_REF && LA43_0 <= TREE_BEGIN)) ) {
+					alt43=1;
+				}
+
+				switch (alt43) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:204:13: rewrite_tree_element
+					{
+					pushFollow(FOLLOW_rewrite_tree_element_in_rewrite_tree_alternative1132);
+					rewrite_tree_element();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt43 >= 1 ) break loop43;
+					EarlyExitException eee = new EarlyExitException(43, input);
+					throw eee;
+				}
+				cnt43++;
+			}
+
+			match(input,EOA,FOLLOW_EOA_in_rewrite_tree_alternative1135); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_tree_alternative"
+
+
+
+	// $ANTLR start "rewrite_tree_element"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:207:1: rewrite_tree_element : ( rewrite_tree_atom | rewrite_tree | rewrite_tree_block | rewrite_tree_ebnf );
+	public final void rewrite_tree_element() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:208:2: ( rewrite_tree_atom | rewrite_tree | rewrite_tree_block | rewrite_tree_ebnf )
+			int alt44=4;
+			switch ( input.LA(1) ) {
+			case ACTION:
+			case CHAR_LITERAL:
+			case LABEL:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt44=1;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt44=2;
+				}
+				break;
+			case BLOCK:
+				{
+				alt44=3;
+				}
+				break;
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt44=4;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 44, 0, input);
+				throw nvae;
+			}
+			switch (alt44) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:208:4: rewrite_tree_atom
+					{
+					pushFollow(FOLLOW_rewrite_tree_atom_in_rewrite_tree_element1150);
+					rewrite_tree_atom();
+					state._fsp--;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:209:4: rewrite_tree
+					{
+					pushFollow(FOLLOW_rewrite_tree_in_rewrite_tree_element1155);
+					rewrite_tree();
+					state._fsp--;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:210:6: rewrite_tree_block
+					{
+					pushFollow(FOLLOW_rewrite_tree_block_in_rewrite_tree_element1162);
+					rewrite_tree_block();
+					state._fsp--;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:211:6: rewrite_tree_ebnf
+					{
+					pushFollow(FOLLOW_rewrite_tree_ebnf_in_rewrite_tree_element1169);
+					rewrite_tree_ebnf();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_tree_element"
+
+
+
+	// $ANTLR start "rewrite_tree_atom"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:214:1: rewrite_tree_atom : ( CHAR_LITERAL | TOKEN_REF | ^( TOKEN_REF ARG_ACTION ) | RULE_REF | STRING_LITERAL | LABEL | ACTION );
+	public final void rewrite_tree_atom() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:215:5: ( CHAR_LITERAL | TOKEN_REF | ^( TOKEN_REF ARG_ACTION ) | RULE_REF | STRING_LITERAL | LABEL | ACTION )
+			int alt45=7;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				alt45=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				int LA45_2 = input.LA(2);
+				if ( (LA45_2==DOWN) ) {
+					alt45=3;
+				}
+				else if ( ((LA45_2 >= UP && LA45_2 <= ACTION)||(LA45_2 >= BLOCK && LA45_2 <= CHAR_LITERAL)||LA45_2==CLOSURE||LA45_2==EOA||LA45_2==LABEL||LA45_2==OPTIONAL||LA45_2==POSITIVE_CLOSURE||LA45_2==RULE_REF||LA45_2==STRING_LITERAL||(LA45_2 >= TOKEN_REF && LA45_2 <= TREE_BEGIN)) ) {
+					alt45=2;
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 45, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case RULE_REF:
+				{
+				alt45=4;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt45=5;
+				}
+				break;
+			case LABEL:
+				{
+				alt45=6;
+				}
+				break;
+			case ACTION:
+				{
+				alt45=7;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 45, 0, input);
+				throw nvae;
+			}
+			switch (alt45) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:215:9: CHAR_LITERAL
+					{
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_rewrite_tree_atom1185); 
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:216:6: TOKEN_REF
+					{
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_rewrite_tree_atom1192); 
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:217:6: ^( TOKEN_REF ARG_ACTION )
+					{
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_rewrite_tree_atom1200); 
+					match(input, Token.DOWN, null); 
+					match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rewrite_tree_atom1202); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:218:9: RULE_REF
+					{
+					match(input,RULE_REF,FOLLOW_RULE_REF_in_rewrite_tree_atom1214); 
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:219:6: STRING_LITERAL
+					{
+					match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_rewrite_tree_atom1221); 
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:220:6: LABEL
+					{
+					match(input,LABEL,FOLLOW_LABEL_in_rewrite_tree_atom1228); 
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:221:4: ACTION
+					{
+					match(input,ACTION,FOLLOW_ACTION_in_rewrite_tree_atom1233); 
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_tree_atom"
+
+
+
+	// $ANTLR start "rewrite_tree_ebnf"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:224:1: rewrite_tree_ebnf : ( ^( OPTIONAL rewrite_tree_block ) | ^( CLOSURE rewrite_tree_block ) | ^( POSITIVE_CLOSURE rewrite_tree_block ) );
+	public final void rewrite_tree_ebnf() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:225:2: ( ^( OPTIONAL rewrite_tree_block ) | ^( CLOSURE rewrite_tree_block ) | ^( POSITIVE_CLOSURE rewrite_tree_block ) )
+			int alt46=3;
+			switch ( input.LA(1) ) {
+			case OPTIONAL:
+				{
+				alt46=1;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt46=2;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt46=3;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 46, 0, input);
+				throw nvae;
+			}
+			switch (alt46) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:225:4: ^( OPTIONAL rewrite_tree_block )
+					{
+					match(input,OPTIONAL,FOLLOW_OPTIONAL_in_rewrite_tree_ebnf1245); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_rewrite_tree_block_in_rewrite_tree_ebnf1247);
+					rewrite_tree_block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:226:6: ^( CLOSURE rewrite_tree_block )
+					{
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_rewrite_tree_ebnf1256); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_rewrite_tree_block_in_rewrite_tree_ebnf1258);
+					rewrite_tree_block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:227:7: ^( POSITIVE_CLOSURE rewrite_tree_block )
+					{
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_rewrite_tree_ebnf1268); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_rewrite_tree_block_in_rewrite_tree_ebnf1270);
+					rewrite_tree_block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_tree_ebnf"
+
+
+
+	// $ANTLR start "rewrite_tree"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:230:1: rewrite_tree : ^( TREE_BEGIN rewrite_tree_atom ( rewrite_tree_element )* ) ;
+	public final void rewrite_tree() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:231:2: ( ^( TREE_BEGIN rewrite_tree_atom ( rewrite_tree_element )* ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:231:4: ^( TREE_BEGIN rewrite_tree_atom ( rewrite_tree_element )* )
+			{
+			match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_rewrite_tree1284); 
+			match(input, Token.DOWN, null); 
+			pushFollow(FOLLOW_rewrite_tree_atom_in_rewrite_tree1286);
+			rewrite_tree_atom();
+			state._fsp--;
+
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:231:35: ( rewrite_tree_element )*
+			loop47:
+			while (true) {
+				int alt47=2;
+				int LA47_0 = input.LA(1);
+				if ( (LA47_0==ACTION||(LA47_0 >= BLOCK && LA47_0 <= CHAR_LITERAL)||LA47_0==CLOSURE||LA47_0==LABEL||LA47_0==OPTIONAL||LA47_0==POSITIVE_CLOSURE||LA47_0==RULE_REF||LA47_0==STRING_LITERAL||(LA47_0 >= TOKEN_REF && LA47_0 <= TREE_BEGIN)) ) {
+					alt47=1;
+				}
+
+				switch (alt47) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:231:35: rewrite_tree_element
+					{
+					pushFollow(FOLLOW_rewrite_tree_element_in_rewrite_tree1288);
+					rewrite_tree_element();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop47;
+				}
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_tree"
+
+
+
+	// $ANTLR start "rewrite_template"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:234:1: rewrite_template : ( ^( TEMPLATE ID rewrite_template_args ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL ) ) | rewrite_template_ref | rewrite_indirect_template_head | ACTION );
+	public final void rewrite_template() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:235:2: ( ^( TEMPLATE ID rewrite_template_args ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL ) ) | rewrite_template_ref | rewrite_indirect_template_head | ACTION )
+			int alt48=4;
+			alt48 = dfa48.predict(input);
+			switch (alt48) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:235:6: ^( TEMPLATE ID rewrite_template_args ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL ) )
+					{
+					match(input,TEMPLATE,FOLLOW_TEMPLATE_in_rewrite_template1306); 
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_rewrite_template1308); 
+					pushFollow(FOLLOW_rewrite_template_args_in_rewrite_template1310);
+					rewrite_template_args();
+					state._fsp--;
+
+					if ( (input.LA(1) >= DOUBLE_ANGLE_STRING_LITERAL && input.LA(1) <= DOUBLE_QUOTE_STRING_LITERAL) ) {
+						input.consume();
+						state.errorRecovery=false;
+					}
+					else {
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						throw mse;
+					}
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:238:4: rewrite_template_ref
+					{
+					pushFollow(FOLLOW_rewrite_template_ref_in_rewrite_template1333);
+					rewrite_template_ref();
+					state._fsp--;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:239:4: rewrite_indirect_template_head
+					{
+					pushFollow(FOLLOW_rewrite_indirect_template_head_in_rewrite_template1338);
+					rewrite_indirect_template_head();
+					state._fsp--;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:240:4: ACTION
+					{
+					match(input,ACTION,FOLLOW_ACTION_in_rewrite_template1343); 
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_template"
+
+
+
+	// $ANTLR start "rewrite_template_ref"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:244:1: rewrite_template_ref : ^( TEMPLATE ID rewrite_template_args ) ;
+	public final void rewrite_template_ref() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:245:2: ( ^( TEMPLATE ID rewrite_template_args ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:245:4: ^( TEMPLATE ID rewrite_template_args )
+			{
+			match(input,TEMPLATE,FOLLOW_TEMPLATE_in_rewrite_template_ref1357); 
+			match(input, Token.DOWN, null); 
+			match(input,ID,FOLLOW_ID_in_rewrite_template_ref1359); 
+			pushFollow(FOLLOW_rewrite_template_args_in_rewrite_template_ref1361);
+			rewrite_template_args();
+			state._fsp--;
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_template_ref"
+
+
+
+	// $ANTLR start "rewrite_indirect_template_head"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:249:1: rewrite_indirect_template_head : ^( TEMPLATE ACTION rewrite_template_args ) ;
+	public final void rewrite_indirect_template_head() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:250:2: ( ^( TEMPLATE ACTION rewrite_template_args ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:250:4: ^( TEMPLATE ACTION rewrite_template_args )
+			{
+			match(input,TEMPLATE,FOLLOW_TEMPLATE_in_rewrite_indirect_template_head1376); 
+			match(input, Token.DOWN, null); 
+			match(input,ACTION,FOLLOW_ACTION_in_rewrite_indirect_template_head1378); 
+			pushFollow(FOLLOW_rewrite_template_args_in_rewrite_indirect_template_head1380);
+			rewrite_template_args();
+			state._fsp--;
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_indirect_template_head"
+
+
+
+	// $ANTLR start "rewrite_template_args"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:253:1: rewrite_template_args : ( ^( ARGLIST ( rewrite_template_arg )+ ) | ARGLIST );
+	public final void rewrite_template_args() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:254:2: ( ^( ARGLIST ( rewrite_template_arg )+ ) | ARGLIST )
+			int alt50=2;
+			int LA50_0 = input.LA(1);
+			if ( (LA50_0==ARGLIST) ) {
+				int LA50_1 = input.LA(2);
+				if ( (LA50_1==DOWN) ) {
+					alt50=1;
+				}
+				else if ( (LA50_1==UP||(LA50_1 >= DOUBLE_ANGLE_STRING_LITERAL && LA50_1 <= DOUBLE_QUOTE_STRING_LITERAL)) ) {
+					alt50=2;
+				}
+
+				else {
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 50, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 50, 0, input);
+				throw nvae;
+			}
+
+			switch (alt50) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:254:4: ^( ARGLIST ( rewrite_template_arg )+ )
+					{
+					match(input,ARGLIST,FOLLOW_ARGLIST_in_rewrite_template_args1393); 
+					match(input, Token.DOWN, null); 
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:254:14: ( rewrite_template_arg )+
+					int cnt49=0;
+					loop49:
+					while (true) {
+						int alt49=2;
+						int LA49_0 = input.LA(1);
+						if ( (LA49_0==ARG) ) {
+							alt49=1;
+						}
+
+						switch (alt49) {
+						case 1 :
+							// org/antlr/grammar/v3/ANTLRv3Tree.g:254:14: rewrite_template_arg
+							{
+							pushFollow(FOLLOW_rewrite_template_arg_in_rewrite_template_args1395);
+							rewrite_template_arg();
+							state._fsp--;
+
+							}
+							break;
+
+						default :
+							if ( cnt49 >= 1 ) break loop49;
+							EarlyExitException eee = new EarlyExitException(49, input);
+							throw eee;
+						}
+						cnt49++;
+					}
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:255:4: ARGLIST
+					{
+					match(input,ARGLIST,FOLLOW_ARGLIST_in_rewrite_template_args1402); 
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_template_args"
+
+
+
+	// $ANTLR start "rewrite_template_arg"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:258:1: rewrite_template_arg : ^( ARG ID ACTION ) ;
+	public final void rewrite_template_arg() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:259:2: ( ^( ARG ID ACTION ) )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:259:6: ^( ARG ID ACTION )
+			{
+			match(input,ARG,FOLLOW_ARG_in_rewrite_template_arg1416); 
+			match(input, Token.DOWN, null); 
+			match(input,ID,FOLLOW_ID_in_rewrite_template_arg1418); 
+			match(input,ACTION,FOLLOW_ACTION_in_rewrite_template_arg1420); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_template_arg"
+
+
+
+	// $ANTLR start "qid"
+	// org/antlr/grammar/v3/ANTLRv3Tree.g:262:1: qid : ID ( '.' ID )* ;
+	public final void qid() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:262:5: ( ID ( '.' ID )* )
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:262:7: ID ( '.' ID )*
+			{
+			match(input,ID,FOLLOW_ID_in_qid1431); 
+			// org/antlr/grammar/v3/ANTLRv3Tree.g:262:10: ( '.' ID )*
+			loop51:
+			while (true) {
+				int alt51=2;
+				int LA51_0 = input.LA(1);
+				if ( (LA51_0==73) ) {
+					alt51=1;
+				}
+
+				switch (alt51) {
+				case 1 :
+					// org/antlr/grammar/v3/ANTLRv3Tree.g:262:11: '.' ID
+					{
+					match(input,73,FOLLOW_73_in_qid1434); 
+					match(input,ID,FOLLOW_ID_in_qid1436); 
+					}
+					break;
+
+				default :
+					break loop51;
+				}
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "qid"
+
+	// Delegated rules
+
+
+	protected DFA48 dfa48 = new DFA48(this);
+	static final String DFA48_eotS =
+		"\20\uffff";
+	static final String DFA48_eofS =
+		"\20\uffff";
+	static final String DFA48_minS =
+		"\1\4\1\2\1\uffff\1\4\1\12\1\uffff\1\2\1\11\2\uffff\1\2\1\36\1\4\3\3";
+	static final String DFA48_maxS =
+		"\1\73\1\2\1\uffff\1\36\1\12\1\uffff\1\26\1\11\2\uffff\1\2\1\36\1\4\1\3"+
+		"\1\11\1\26";
+	static final String DFA48_acceptS =
+		"\2\uffff\1\4\2\uffff\1\3\2\uffff\1\1\1\2\6\uffff";
+	static final String DFA48_specialS =
+		"\20\uffff}>";
+	static final String[] DFA48_transitionS = {
+			"\1\2\66\uffff\1\1",
+			"\1\3",
+			"",
+			"\1\5\31\uffff\1\4",
+			"\1\6",
+			"",
+			"\1\7\1\11\21\uffff\2\10",
+			"\1\12",
+			"",
+			"",
+			"\1\13",
+			"\1\14",
+			"\1\15",
+			"\1\16",
+			"\1\17\5\uffff\1\12",
+			"\1\11\21\uffff\2\10"
+	};
+
+	static final short[] DFA48_eot = DFA.unpackEncodedString(DFA48_eotS);
+	static final short[] DFA48_eof = DFA.unpackEncodedString(DFA48_eofS);
+	static final char[] DFA48_min = DFA.unpackEncodedStringToUnsignedChars(DFA48_minS);
+	static final char[] DFA48_max = DFA.unpackEncodedStringToUnsignedChars(DFA48_maxS);
+	static final short[] DFA48_accept = DFA.unpackEncodedString(DFA48_acceptS);
+	static final short[] DFA48_special = DFA.unpackEncodedString(DFA48_specialS);
+	static final short[][] DFA48_transition;
+
+	static {
+		int numStates = DFA48_transitionS.length;
+		DFA48_transition = new short[numStates][];
+		for (int i=0; i<numStates; i++) {
+			DFA48_transition[i] = DFA.unpackEncodedString(DFA48_transitionS[i]);
+		}
+	}
+
+	protected class DFA48 extends DFA {
+
+		public DFA48(BaseRecognizer recognizer) {
+			this.recognizer = recognizer;
+			this.decisionNumber = 48;
+			this.eot = DFA48_eot;
+			this.eof = DFA48_eof;
+			this.min = DFA48_min;
+			this.max = DFA48_max;
+			this.accept = DFA48_accept;
+			this.special = DFA48_special;
+			this.transition = DFA48_transition;
+		}
+		@Override
+		public String getDescription() {
+			return "234:1: rewrite_template : ( ^( TEMPLATE ID rewrite_template_args ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL ) ) | rewrite_template_ref | rewrite_indirect_template_head | ACTION );";
+		}
+	}
+
+	public static final BitSet FOLLOW_grammarType_in_grammarDef58 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_grammarDef60 = new BitSet(new long[]{0x1014040000101000L});
+	public static final BitSet FOLLOW_DOC_COMMENT_in_grammarDef62 = new BitSet(new long[]{0x1014040000001000L});
+	public static final BitSet FOLLOW_optionsSpec_in_grammarDef65 = new BitSet(new long[]{0x1014000000001000L});
+	public static final BitSet FOLLOW_tokensSpec_in_grammarDef68 = new BitSet(new long[]{0x0014000000001000L});
+	public static final BitSet FOLLOW_attrScope_in_grammarDef71 = new BitSet(new long[]{0x0014000000001000L});
+	public static final BitSet FOLLOW_action_in_grammarDef74 = new BitSet(new long[]{0x0004000000001000L});
+	public static final BitSet FOLLOW_rule_in_grammarDef77 = new BitSet(new long[]{0x0004000000000008L});
+	public static final BitSet FOLLOW_TOKENS_in_tokensSpec133 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_tokenSpec_in_tokensSpec135 = new BitSet(new long[]{0x2000000200000008L});
+	public static final BitSet FOLLOW_LABEL_ASSIGN_in_tokenSpec149 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec151 = new BitSet(new long[]{0x0100000000000000L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_tokenSpec153 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_LABEL_ASSIGN_in_tokenSpec160 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec162 = new BitSet(new long[]{0x0000000000010000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_tokenSpec164 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec170 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SCOPE_in_attrScope182 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_attrScope184 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_attrScope186 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_AT_in_action199 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_action201 = new BitSet(new long[]{0x0000000040000000L});
+	public static final BitSet FOLLOW_ID_in_action203 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_action205 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_AT_in_action212 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_action214 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_action216 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_OPTIONS_in_optionsSpec229 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_option_in_optionsSpec231 = new BitSet(new long[]{0x0000000240000008L});
+	public static final BitSet FOLLOW_qid_in_option249 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_LABEL_ASSIGN_in_option259 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_option261 = new BitSet(new long[]{0x01000000C0010000L});
+	public static final BitSet FOLLOW_optionValue_in_option263 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RULE_in_rule329 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rule331 = new BitSet(new long[]{0x0010840010009200L,0x0000000003C00000L});
+	public static final BitSet FOLLOW_modifier_in_rule333 = new BitSet(new long[]{0x0010840000009200L,0x0000000002000000L});
+	public static final BitSet FOLLOW_ARG_in_rule338 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule340 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RET_in_rule347 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule349 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_throwsSpec_in_rule362 = new BitSet(new long[]{0x0010040000009000L});
+	public static final BitSet FOLLOW_optionsSpec_in_rule365 = new BitSet(new long[]{0x0010000000009000L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_rule368 = new BitSet(new long[]{0x0000000000009000L});
+	public static final BitSet FOLLOW_ruleAction_in_rule371 = new BitSet(new long[]{0x0000000000009000L});
+	public static final BitSet FOLLOW_altList_in_rule382 = new BitSet(new long[]{0x0000000002000000L,0x0000000000060000L});
+	public static final BitSet FOLLOW_exceptionGroup_in_rule392 = new BitSet(new long[]{0x0000000002000000L});
+	public static final BitSet FOLLOW_EOR_in_rule395 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_AT_in_ruleAction434 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_ruleAction436 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_ruleAction438 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_89_in_throwsSpec451 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_throwsSpec453 = new BitSet(new long[]{0x0000000040000008L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec467 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec469 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec476 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec478 = new BitSet(new long[]{0x0000000040000000L});
+	public static final BitSet FOLLOW_ID_in_ruleScopeSpec480 = new BitSet(new long[]{0x0000000040000008L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec488 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_ruleScopeSpec490 = new BitSet(new long[]{0x0000000040000008L});
+	public static final BitSet FOLLOW_BLOCK_in_block510 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_optionsSpec_in_block512 = new BitSet(new long[]{0x0000000000000100L});
+	public static final BitSet FOLLOW_alternative_in_block516 = new BitSet(new long[]{0x0001000001000100L});
+	public static final BitSet FOLLOW_rewrite_in_block518 = new BitSet(new long[]{0x0000000001000100L});
+	public static final BitSet FOLLOW_EOB_in_block522 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_altList545 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_alternative_in_altList548 = new BitSet(new long[]{0x0001000001000100L});
+	public static final BitSet FOLLOW_rewrite_in_altList550 = new BitSet(new long[]{0x0000000001000100L});
+	public static final BitSet FOLLOW_EOB_in_altList554 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_alternative576 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_alternative578 = new BitSet(new long[]{0x672A22122087C010L,0x0000000020000200L});
+	public static final BitSet FOLLOW_EOA_in_alternative581 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_alternative593 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_EPSILON_in_alternative595 = new BitSet(new long[]{0x0000000000800000L});
+	public static final BitSet FOLLOW_EOA_in_alternative597 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_exceptionHandler_in_exceptionGroup612 = new BitSet(new long[]{0x0000000000000002L,0x0000000000060000L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup615 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup621 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_81_in_exceptionHandler642 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_exceptionHandler644 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_exceptionHandler646 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_82_in_finallyClause668 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_finallyClause670 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_set_in_element686 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element692 = new BitSet(new long[]{0x0000000000008000L});
+	public static final BitSet FOLLOW_block_in_element694 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_set_in_element701 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element707 = new BitSet(new long[]{0x210A000000034000L,0x0000000020000200L});
+	public static final BitSet FOLLOW_atom_in_element709 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_atom_in_element715 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ebnf_in_element720 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_element727 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SEMPRED_in_element734 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_GATED_SEMPRED_in_element739 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_element747 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element749 = new BitSet(new long[]{0x672A22122007C018L,0x0000000020000200L});
+	public static final BitSet FOLLOW_set_in_atom763 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_atom_in_atom769 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_RANGE_in_atom776 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom778 = new BitSet(new long[]{0x0000000000010000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom780 = new BitSet(new long[]{0x0000040000000008L});
+	public static final BitSet FOLLOW_optionsSpec_in_atom782 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_93_in_atom790 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_notTerminal_in_atom792 = new BitSet(new long[]{0x0000040000000008L});
+	public static final BitSet FOLLOW_optionsSpec_in_atom794 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_93_in_atom802 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_atom804 = new BitSet(new long[]{0x0000040000000008L});
+	public static final BitSet FOLLOW_optionsSpec_in_atom806 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RULE_REF_in_atom817 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom819 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RULE_REF_in_atom828 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom838 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom849 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_optionsSpec_in_atom851 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom860 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom869 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_optionsSpec_in_atom871 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom881 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom883 = new BitSet(new long[]{0x0000040000000000L});
+	public static final BitSet FOLLOW_optionsSpec_in_atom885 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom895 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom897 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_atom906 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_atom915 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_optionsSpec_in_atom917 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_73_in_atom926 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_73_in_atom935 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_optionsSpec_in_atom937 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_SYNPRED_in_ebnf956 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf958 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_OPTIONAL_in_ebnf965 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf967 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_ebnf976 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf978 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_ebnf988 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf990 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_SYN_SEMPRED_in_ebnf996 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_ebnf1001 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite1041 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_SEMPRED_in_rewrite1043 = new BitSet(new long[]{0x0800000000000110L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite1045 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite1051 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite1053 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_rewrite_template_in_rewrite_alternative1068 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_alternative_in_rewrite_alternative1073 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ALT_in_rewrite_alternative1084 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_EPSILON_in_rewrite_alternative1086 = new BitSet(new long[]{0x0000000000800000L});
+	public static final BitSet FOLLOW_EOA_in_rewrite_alternative1088 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_rewrite_tree_block1107 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_tree_alternative_in_rewrite_tree_block1109 = new BitSet(new long[]{0x0000000001000000L});
+	public static final BitSet FOLLOW_EOB_in_rewrite_tree_block1111 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_rewrite_tree_alternative1130 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_tree_element_in_rewrite_tree_alternative1132 = new BitSet(new long[]{0x6108220100858010L});
+	public static final BitSet FOLLOW_EOA_in_rewrite_tree_alternative1135 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_rewrite_tree_atom_in_rewrite_tree_element1150 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_in_rewrite_tree_element1155 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_block_in_rewrite_tree_element1162 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_ebnf_in_rewrite_tree_element1169 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_rewrite_tree_atom1185 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_rewrite_tree_atom1192 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_rewrite_tree_atom1200 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rewrite_tree_atom1202 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RULE_REF_in_rewrite_tree_atom1214 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_rewrite_tree_atom1221 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_LABEL_in_rewrite_tree_atom1228 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_tree_atom1233 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONAL_in_rewrite_tree_ebnf1245 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_tree_block_in_rewrite_tree_ebnf1247 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_rewrite_tree_ebnf1256 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_tree_block_in_rewrite_tree_ebnf1258 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_rewrite_tree_ebnf1268 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_tree_block_in_rewrite_tree_ebnf1270 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_rewrite_tree1284 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_tree_atom_in_rewrite_tree1286 = new BitSet(new long[]{0x6108220100058018L});
+	public static final BitSet FOLLOW_rewrite_tree_element_in_rewrite_tree1288 = new BitSet(new long[]{0x6108220100058018L});
+	public static final BitSet FOLLOW_TEMPLATE_in_rewrite_template1306 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rewrite_template1308 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_rewrite_template_args_in_rewrite_template1310 = new BitSet(new long[]{0x0000000000600000L});
+	public static final BitSet FOLLOW_set_in_rewrite_template1317 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_rewrite_template_ref_in_rewrite_template1333 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_indirect_template_head_in_rewrite_template1338 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template1343 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TEMPLATE_in_rewrite_template_ref1357 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rewrite_template_ref1359 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_rewrite_template_args_in_rewrite_template_ref1361 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TEMPLATE_in_rewrite_indirect_template_head1376 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_indirect_template_head1378 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_rewrite_template_args_in_rewrite_indirect_template_head1380 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ARGLIST_in_rewrite_template_args1393 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_template_arg_in_rewrite_template_args1395 = new BitSet(new long[]{0x0000000000000208L});
+	public static final BitSet FOLLOW_ARGLIST_in_rewrite_template_args1402 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ARG_in_rewrite_template_arg1416 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rewrite_template_arg1418 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template_arg1420 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_qid1431 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000200L});
+	public static final BitSet FOLLOW_73_in_qid1434 = new BitSet(new long[]{0x0000000040000000L});
+	public static final BitSet FOLLOW_ID_in_qid1436 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000200L});
+}
--- tool/src/main/java/org/antlr/grammar/v3/AssignTokenTypesWalker.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/AssignTokenTypesWalker.java	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,2936 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/AssignTokenTypesWalker.g 2019-04-04 15:18:50
+
+package org.antlr.grammar.v3;
+
+import java.util.*;
+import org.antlr.analysis.*;
+import org.antlr.misc.*;
+import org.antlr.tool.*;
+
+import org.antlr.runtime.BitSet;
+
+
+import org.antlr.runtime.*;
+import org.antlr.runtime.tree.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+
+/** [Warning: TJP says that this is probably out of date as of 11/19/2005,
+ *   but since it's probably still useful, I'll leave in.  Don't have energy
+ *   to update at the moment.]
+ *
+ *  Compute the token types for all literals and rules etc..  There are
+ *  a few different cases to consider for grammar types and a few situations
+ *  within.
+ *
+ *  CASE 1 : pure parser grammar
+ *	a) Any reference to a token gets a token type.
+ *  b) The tokens section may alias a token name to a string or char
+ *
+ *  CASE 2 : pure lexer grammar
+ *  a) Import token vocabulary if available. Set token types for any new tokens
+ *     to values above last imported token type
+ *  b) token rule definitions get token types if not already defined
+ *  c) literals do NOT get token types
+ *
+ *  CASE 3 : merged parser / lexer grammar
+ *	a) Any char or string literal gets a token type in a parser rule
+ *  b) Any reference to a token gets a token type if not referencing
+ *     a fragment lexer rule
+ *  c) The tokens section may alias a token name to a string or char
+ *     which must add a rule to the lexer
+ *  d) token rule definitions get token types if not already defined
+ *  e) token rule definitions may also alias a token name to a literal.
+ *     E.g., Rule 'FOR : "for";' will alias FOR to "for" in the sense that
+ *     references to either in the parser grammar will yield the token type
+ *
+ *  What this pass does:
+ *
+ *  0. Collects basic info about the grammar like grammar name and type;
+ *     Oh, I have go get the options in case they affect the token types.
+ *     E.g., tokenVocab option.
+ *     Imports any token vocab name/type pairs into a local hashtable.
+ *  1. Finds a list of all literals and token names.
+ *  2. Finds a list of all token name rule definitions;
+ *     no token rules implies pure parser.
+ *  3. Finds a list of all simple token rule defs of form "&lt;NAME&gt; : &lt;literal&gt;;"
+ *     and aliases them.
+ *  4. Walks token names table and assign types to any unassigned
+ *  5. Walks aliases and assign types to referenced literals
+ *  6. Walks literals, assigning types if untyped
+ *  4. Informs the Grammar object of the type definitions such as:
+ *     g.defineToken(&lt;charliteral&gt;, ttype);
+ *     g.defineToken(&lt;stringliteral&gt;, ttype);
+ *     g.defineToken(&lt;tokenID&gt;, ttype);
+ *     where some of the ttype values will be the same for aliases tokens.
+ */
+@SuppressWarnings("all")
+public class AssignTokenTypesWalker extends TreeParser {
+	public static final String[] tokenNames = new String[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", 
+		"ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", 
+		"ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", 
+		"CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", 
+		"COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", 
+		"DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", 
+		"EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", 
+		"GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", 
+		"LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", 
+		"NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", 
+		"OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", 
+		"PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", 
+		"RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", 
+		"RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", 
+		"SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", 
+		"TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", 
+		"WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT", "CHARSET"
+	};
+	public static final int EOF=-1;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int AMPERSAND=9;
+	public static final int ARG=10;
+	public static final int ARGLIST=11;
+	public static final int ARG_ACTION=12;
+	public static final int ASSIGN=13;
+	public static final int BACKTRACK_SEMPRED=14;
+	public static final int BANG=15;
+	public static final int BLOCK=16;
+	public static final int CATCH=17;
+	public static final int CHAR_LITERAL=18;
+	public static final int CHAR_RANGE=19;
+	public static final int CLOSE_ELEMENT_OPTION=20;
+	public static final int CLOSURE=21;
+	public static final int COLON=22;
+	public static final int COMBINED_GRAMMAR=23;
+	public static final int COMMA=24;
+	public static final int COMMENT=25;
+	public static final int DIGIT=26;
+	public static final int DOC_COMMENT=27;
+	public static final int DOLLAR=28;
+	public static final int DOT=29;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public static final int EOA=32;
+	public static final int EOB=33;
+	public static final int EOR=34;
+	public static final int EPSILON=35;
+	public static final int ESC=36;
+	public static final int ETC=37;
+	public static final int FINALLY=38;
+	public static final int FORCED_ACTION=39;
+	public static final int FRAGMENT=40;
+	public static final int GATED_SEMPRED=41;
+	public static final int GRAMMAR=42;
+	public static final int ID=43;
+	public static final int IMPLIES=44;
+	public static final int IMPORT=45;
+	public static final int INITACTION=46;
+	public static final int INT=47;
+	public static final int LABEL=48;
+	public static final int LEXER=49;
+	public static final int LEXER_GRAMMAR=50;
+	public static final int LPAREN=51;
+	public static final int ML_COMMENT=52;
+	public static final int NESTED_ACTION=53;
+	public static final int NESTED_ARG_ACTION=54;
+	public static final int NOT=55;
+	public static final int OPEN_ELEMENT_OPTION=56;
+	public static final int OPTIONAL=57;
+	public static final int OPTIONS=58;
+	public static final int OR=59;
+	public static final int PARSER=60;
+	public static final int PARSER_GRAMMAR=61;
+	public static final int PLUS=62;
+	public static final int PLUS_ASSIGN=63;
+	public static final int POSITIVE_CLOSURE=64;
+	public static final int PREC_RULE=65;
+	public static final int PRIVATE=66;
+	public static final int PROTECTED=67;
+	public static final int PUBLIC=68;
+	public static final int QUESTION=69;
+	public static final int RANGE=70;
+	public static final int RCURLY=71;
+	public static final int RECURSIVE_RULE_REF=72;
+	public static final int RET=73;
+	public static final int RETURNS=74;
+	public static final int REWRITE=75;
+	public static final int REWRITES=76;
+	public static final int ROOT=77;
+	public static final int RPAREN=78;
+	public static final int RULE=79;
+	public static final int RULE_REF=80;
+	public static final int SCOPE=81;
+	public static final int SEMI=82;
+	public static final int SEMPRED=83;
+	public static final int SL_COMMENT=84;
+	public static final int SRC=85;
+	public static final int STAR=86;
+	public static final int STRAY_BRACKET=87;
+	public static final int STRING_LITERAL=88;
+	public static final int SYNPRED=89;
+	public static final int SYN_SEMPRED=90;
+	public static final int TEMPLATE=91;
+	public static final int THROWS=92;
+	public static final int TOKENS=93;
+	public static final int TOKEN_REF=94;
+	public static final int TREE=95;
+	public static final int TREE_BEGIN=96;
+	public static final int TREE_GRAMMAR=97;
+	public static final int WILDCARD=98;
+	public static final int WS=99;
+	public static final int WS_LOOP=100;
+	public static final int WS_OPT=101;
+	public static final int XDIGIT=102;
+	public static final int CHARSET=103;
+
+	// delegates
+	public TreeParser[] getDelegates() {
+		return new TreeParser[] {};
+	}
+
+	// delegators
+
+
+	public AssignTokenTypesWalker(TreeNodeStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public AssignTokenTypesWalker(TreeNodeStream input, RecognizerSharedState state) {
+		super(input, state);
+	}
+
+	@Override public String[] getTokenNames() { return AssignTokenTypesWalker.tokenNames; }
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/AssignTokenTypesWalker.g"; }
+
+
+	protected Grammar grammar;
+	protected String currentRuleName;
+
+	protected static GrammarAST stringAlias;
+	protected static GrammarAST charAlias;
+	protected static GrammarAST stringAlias2;
+	protected static GrammarAST charAlias2;
+
+	@Override
+	public void reportError(RecognitionException ex)
+	{
+	    Token token = null;
+	    if (ex instanceof MismatchedTokenException) {
+	        token = ((MismatchedTokenException)ex).token;
+	    } else if (ex instanceof NoViableAltException) {
+	        token = ((NoViableAltException)ex).token;
+	    }
+
+	    ErrorManager.syntaxError(
+	        ErrorManager.MSG_SYNTAX_ERROR,
+	        grammar,
+	        token,
+	        "assign.types: " + ex.toString(),
+	        ex);
+	}
+
+	protected void initASTPatterns()
+	{
+	    TreeAdaptor adaptor = new ANTLRParser.grammar_Adaptor(null);
+
+	    /*
+	     * stringAlias = ^(BLOCK[] ^(ALT[] STRING_LITERAL[] EOA[]) EOB[])
+	     */
+	    stringAlias = (GrammarAST)adaptor.create( BLOCK, "BLOCK" );
+	    {
+	        GrammarAST alt = (GrammarAST)adaptor.create( ALT, "ALT" );
+	        adaptor.addChild( alt, adaptor.create( STRING_LITERAL, "STRING_LITERAL" ) );
+	        adaptor.addChild( alt, adaptor.create( EOA, "EOA" ) );
+	        adaptor.addChild( stringAlias, alt );
+	    }
+	    adaptor.addChild( stringAlias, adaptor.create( EOB, "EOB" ) );
+
+	    /*
+	     * charAlias = ^(BLOCK[] ^(ALT[] CHAR_LITERAL[] EOA[]) EOB[])
+	     */
+	    charAlias = (GrammarAST)adaptor.create( BLOCK, "BLOCK" );
+	    {
+	        GrammarAST alt = (GrammarAST)adaptor.create( ALT, "ALT" );
+	        adaptor.addChild( alt, adaptor.create( CHAR_LITERAL, "CHAR_LITERAL" ) );
+	        adaptor.addChild( alt, adaptor.create( EOA, "EOA" ) );
+	        adaptor.addChild( charAlias, alt );
+	    }
+	    adaptor.addChild( charAlias, adaptor.create( EOB, "EOB" ) );
+
+	    /*
+	     * stringAlias2 = ^(BLOCK[] ^(ALT[] STRING_LITERAL[] ACTION[] EOA[]) EOB[])
+	     */
+	    stringAlias2 = (GrammarAST)adaptor.create( BLOCK, "BLOCK" );
+	    {
+	        GrammarAST alt = (GrammarAST)adaptor.create( ALT, "ALT" );
+	        adaptor.addChild( alt, adaptor.create( STRING_LITERAL, "STRING_LITERAL" ) );
+	        adaptor.addChild( alt, adaptor.create( ACTION, "ACTION" ) );
+	        adaptor.addChild( alt, adaptor.create( EOA, "EOA" ) );
+	        adaptor.addChild( stringAlias2, alt );
+	    }
+	    adaptor.addChild( stringAlias2, adaptor.create( EOB, "EOB" ) );
+
+	    /*
+	     * charAlias = ^(BLOCK[] ^(ALT[] CHAR_LITERAL[] ACTION[] EOA[]) EOB[])
+	     */
+	    charAlias2 = (GrammarAST)adaptor.create( BLOCK, "BLOCK" );
+	    {
+	        GrammarAST alt = (GrammarAST)adaptor.create( ALT, "ALT" );
+	        adaptor.addChild( alt, adaptor.create( CHAR_LITERAL, "CHAR_LITERAL" ) );
+	        adaptor.addChild( alt, adaptor.create( ACTION, "ACTION" ) );
+	        adaptor.addChild( alt, adaptor.create( EOA, "EOA" ) );
+	        adaptor.addChild( charAlias2, alt );
+	    }
+	    adaptor.addChild( charAlias2, adaptor.create( EOB, "EOB" ) );
+	}
+
+	// Behavior moved to AssignTokenTypesBehavior
+	protected void trackString(GrammarAST t) {}
+	protected void trackToken( GrammarAST t ) {}
+	protected void trackTokenRule( GrammarAST t, GrammarAST modifier, GrammarAST block ) {}
+	protected void alias( GrammarAST t, GrammarAST s ) {}
+	public void defineTokens( Grammar root ) {}
+	protected void defineStringLiteralsFromDelegates() {}
+	protected void assignStringTypes( Grammar root ) {}
+	protected void aliasTokenIDsAndLiterals( Grammar root ) {}
+	protected void assignTokenIDTypes( Grammar root ) {}
+	protected void defineTokenNamesAndLiteralsInGrammar( Grammar root ) {}
+	protected void init( Grammar root ) {}
+
+
+
+	// $ANTLR start "grammar_"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:199:1: public grammar_[Grammar g] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
+	public final void grammar_(Grammar g) throws RecognitionException {
+
+			if ( state.backtracking == 0 )
+				init(g);
+
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:205:2: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:205:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			{
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:205:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			int alt1=4;
+			switch ( input.LA(1) ) {
+			case LEXER_GRAMMAR:
+				{
+				alt1=1;
+				}
+				break;
+			case PARSER_GRAMMAR:
+				{
+				alt1=2;
+				}
+				break;
+			case TREE_GRAMMAR:
+				{
+				alt1=3;
+				}
+				break;
+			case COMBINED_GRAMMAR:
+				{
+				alt1=4;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 1, 0, input);
+				throw nvae;
+			}
+			switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:205:6: ^( LEXER_GRAMMAR grammarSpec )
+					{
+					match(input,LEXER_GRAMMAR,FOLLOW_LEXER_GRAMMAR_in_grammar_69); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_grammarSpec_in_grammar_74);
+					grammarSpec();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:206:5: ^( PARSER_GRAMMAR grammarSpec )
+					{
+					match(input,PARSER_GRAMMAR,FOLLOW_PARSER_GRAMMAR_in_grammar_84); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_grammarSpec_in_grammar_88);
+					grammarSpec();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:207:5: ^( TREE_GRAMMAR grammarSpec )
+					{
+					match(input,TREE_GRAMMAR,FOLLOW_TREE_GRAMMAR_in_grammar_98); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_grammarSpec_in_grammar_104);
+					grammarSpec();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:208:5: ^( COMBINED_GRAMMAR grammarSpec )
+					{
+					match(input,COMBINED_GRAMMAR,FOLLOW_COMBINED_GRAMMAR_in_grammar_114); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_grammarSpec_in_grammar_116);
+					grammarSpec();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammar_"
+
+
+
+	// $ANTLR start "grammarSpec"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:212:1: grammarSpec : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules ;
+	public final void grammarSpec() throws RecognitionException {
+		GrammarAST id=null;
+		GrammarAST cmt=null;
+
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:213:2: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:213:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules
+			{
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_grammarSpec135); 
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:214:3: (cmt= DOC_COMMENT )?
+			int alt2=2;
+			int LA2_0 = input.LA(1);
+			if ( (LA2_0==DOC_COMMENT) ) {
+				alt2=1;
+			}
+			switch (alt2) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:214:4: cmt= DOC_COMMENT
+					{
+					cmt=(GrammarAST)match(input,DOC_COMMENT,FOLLOW_DOC_COMMENT_in_grammarSpec142); 
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:215:3: ( optionsSpec )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+			if ( (LA3_0==OPTIONS) ) {
+				alt3=1;
+			}
+			switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:215:4: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_grammarSpec149);
+					optionsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:216:3: ( delegateGrammars )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+			if ( (LA4_0==IMPORT) ) {
+				alt4=1;
+			}
+			switch (alt4) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:216:4: delegateGrammars
+					{
+					pushFollow(FOLLOW_delegateGrammars_in_grammarSpec156);
+					delegateGrammars();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:217:3: ( tokensSpec )?
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+			if ( (LA5_0==TOKENS) ) {
+				alt5=1;
+			}
+			switch (alt5) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:217:4: tokensSpec
+					{
+					pushFollow(FOLLOW_tokensSpec_in_grammarSpec163);
+					tokensSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:218:3: ( attrScope )*
+			loop6:
+			while (true) {
+				int alt6=2;
+				int LA6_0 = input.LA(1);
+				if ( (LA6_0==SCOPE) ) {
+					alt6=1;
+				}
+
+				switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:218:4: attrScope
+					{
+					pushFollow(FOLLOW_attrScope_in_grammarSpec170);
+					attrScope();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					break loop6;
+				}
+			}
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:219:3: ( ^( AMPERSAND ( . )* ) )*
+			loop8:
+			while (true) {
+				int alt8=2;
+				int LA8_0 = input.LA(1);
+				if ( (LA8_0==AMPERSAND) ) {
+					alt8=1;
+				}
+
+				switch (alt8) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:219:5: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_grammarSpec179); 
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); 
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:219:17: ( . )*
+						loop7:
+						while (true) {
+							int alt7=2;
+							int LA7_0 = input.LA(1);
+							if ( ((LA7_0 >= ACTION && LA7_0 <= CHARSET)) ) {
+								alt7=1;
+							}
+							else if ( (LA7_0==UP) ) {
+								alt7=2;
+							}
+
+							switch (alt7) {
+							case 1 :
+								// org/antlr/grammar/v3/AssignTokenTypesWalker.g:219:17: .
+								{
+								matchAny(input); 
+								}
+								break;
+
+							default :
+								break loop7;
+							}
+						}
+
+						match(input, Token.UP, null); 
+					}
+
+					}
+					break;
+
+				default :
+					break loop8;
+				}
+			}
+
+			pushFollow(FOLLOW_rules_in_grammarSpec191);
+			rules();
+			state._fsp--;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammarSpec"
+
+
+
+	// $ANTLR start "attrScope"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:223:1: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
+	public final void attrScope() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:224:2: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:224:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_attrScope204); 
+			match(input, Token.DOWN, null); 
+			match(input,ID,FOLLOW_ID_in_attrScope206); 
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:224:18: ( ^( AMPERSAND ( . )* ) )*
+			loop10:
+			while (true) {
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+				if ( (LA10_0==AMPERSAND) ) {
+					alt10=1;
+				}
+
+				switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:224:20: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_attrScope211); 
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); 
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:224:32: ( . )*
+						loop9:
+						while (true) {
+							int alt9=2;
+							int LA9_0 = input.LA(1);
+							if ( ((LA9_0 >= ACTION && LA9_0 <= CHARSET)) ) {
+								alt9=1;
+							}
+							else if ( (LA9_0==UP) ) {
+								alt9=2;
+							}
+
+							switch (alt9) {
+							case 1 :
+								// org/antlr/grammar/v3/AssignTokenTypesWalker.g:224:32: .
+								{
+								matchAny(input); 
+								}
+								break;
+
+							default :
+								break loop9;
+							}
+						}
+
+						match(input, Token.UP, null); 
+					}
+
+					}
+					break;
+
+				default :
+					break loop10;
+				}
+			}
+
+			match(input,ACTION,FOLLOW_ACTION_in_attrScope220); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "attrScope"
+
+
+
+	// $ANTLR start "optionsSpec"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:227:1: optionsSpec returns [Map<Object, Object> opts = new HashMap<Object, Object>()] : ^( OPTIONS ( option[$opts] )+ ) ;
+	public final Map<Object, Object> optionsSpec() throws RecognitionException {
+		Map<Object, Object> opts =  new HashMap<Object, Object>();
+
+
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:228:2: ( ^( OPTIONS ( option[$opts] )+ ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:228:4: ^( OPTIONS ( option[$opts] )+ )
+			{
+			match(input,OPTIONS,FOLLOW_OPTIONS_in_optionsSpec239); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:228:15: ( option[$opts] )+
+			int cnt11=0;
+			loop11:
+			while (true) {
+				int alt11=2;
+				int LA11_0 = input.LA(1);
+				if ( (LA11_0==ASSIGN) ) {
+					alt11=1;
+				}
+
+				switch (alt11) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:228:16: option[$opts]
+					{
+					pushFollow(FOLLOW_option_in_optionsSpec242);
+					option(opts);
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt11 >= 1 ) break loop11;
+					EarlyExitException eee = new EarlyExitException(11, input);
+					throw eee;
+				}
+				cnt11++;
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return opts;
+	}
+	// $ANTLR end "optionsSpec"
+
+
+
+	// $ANTLR start "option"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:231:1: option[Map<Object, Object> opts] : ^( ASSIGN ID optionValue ) ;
+	public final void option(Map<Object, Object> opts) throws RecognitionException {
+		GrammarAST ID1=null;
+		TreeRuleReturnScope optionValue2 =null;
+
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:232:2: ( ^( ASSIGN ID optionValue ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:232:4: ^( ASSIGN ID optionValue )
+			{
+			match(input,ASSIGN,FOLLOW_ASSIGN_in_option261); 
+			match(input, Token.DOWN, null); 
+			ID1=(GrammarAST)match(input,ID,FOLLOW_ID_in_option263); 
+			pushFollow(FOLLOW_optionValue_in_option265);
+			optionValue2=optionValue();
+			state._fsp--;
+
+			match(input, Token.UP, null); 
+
+
+						String key = (ID1!=null?ID1.getText():null);
+						opts.put(key, (optionValue2!=null?((AssignTokenTypesWalker.optionValue_return)optionValue2).value:null));
+						// check for grammar-level option to import vocabulary
+						if ( currentRuleName==null && key.equals("tokenVocab") )
+						{
+							grammar.importTokenVocabulary(ID1,(String)(optionValue2!=null?((AssignTokenTypesWalker.optionValue_return)optionValue2).value:null));
+						}
+					
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "option"
+
+
+	public static class optionValue_return extends TreeRuleReturnScope {
+		public Object value=null;
+	};
+
+
+	// $ANTLR start "optionValue"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:244:1: optionValue returns [Object value=null] : ( ID | STRING_LITERAL | CHAR_LITERAL | INT );
+	public final AssignTokenTypesWalker.optionValue_return optionValue() throws RecognitionException {
+		AssignTokenTypesWalker.optionValue_return retval = new AssignTokenTypesWalker.optionValue_return();
+		retval.start = input.LT(1);
+
+		GrammarAST INT3=null;
+
+
+			if ( state.backtracking == 0 )
+				retval.value = ((GrammarAST)retval.start).getText();
+
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:250:2: ( ID | STRING_LITERAL | CHAR_LITERAL | INT )
+			int alt12=4;
+			switch ( input.LA(1) ) {
+			case ID:
+				{
+				alt12=1;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt12=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt12=3;
+				}
+				break;
+			case INT:
+				{
+				alt12=4;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 12, 0, input);
+				throw nvae;
+			}
+			switch (alt12) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:250:4: ID
+					{
+					match(input,ID,FOLLOW_ID_in_optionValue291); 
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:251:4: STRING_LITERAL
+					{
+					match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_optionValue296); 
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:252:4: CHAR_LITERAL
+					{
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_optionValue301); 
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:253:4: INT
+					{
+					INT3=(GrammarAST)match(input,INT,FOLLOW_INT_in_optionValue306); 
+					retval.value = Integer.parseInt((INT3!=null?INT3.getText():null));
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "optionValue"
+
+
+
+	// $ANTLR start "charSet"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:258:1: charSet : ^( CHARSET charSetElement ) ;
+	public final void charSet() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:259:2: ( ^( CHARSET charSetElement ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:259:4: ^( CHARSET charSetElement )
+			{
+			match(input,CHARSET,FOLLOW_CHARSET_in_charSet324); 
+			match(input, Token.DOWN, null); 
+			pushFollow(FOLLOW_charSetElement_in_charSet326);
+			charSetElement();
+			state._fsp--;
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "charSet"
+
+
+
+	// $ANTLR start "charSetElement"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:262:1: charSetElement : ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) );
+	public final void charSetElement() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:263:2: ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) )
+			int alt13=3;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				alt13=1;
+				}
+				break;
+			case OR:
+				{
+				alt13=2;
+				}
+				break;
+			case RANGE:
+				{
+				alt13=3;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 13, 0, input);
+				throw nvae;
+			}
+			switch (alt13) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:263:4: CHAR_LITERAL
+					{
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_charSetElement339); 
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:264:4: ^( OR CHAR_LITERAL CHAR_LITERAL )
+					{
+					match(input,OR,FOLLOW_OR_in_charSetElement346); 
+					match(input, Token.DOWN, null); 
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_charSetElement348); 
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_charSetElement350); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:265:4: ^( RANGE CHAR_LITERAL CHAR_LITERAL )
+					{
+					match(input,RANGE,FOLLOW_RANGE_in_charSetElement359); 
+					match(input, Token.DOWN, null); 
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_charSetElement361); 
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_charSetElement363); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "charSetElement"
+
+
+
+	// $ANTLR start "delegateGrammars"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:268:1: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
+	public final void delegateGrammars() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:269:2: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:269:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
+			{
+			match(input,IMPORT,FOLLOW_IMPORT_in_delegateGrammars378); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:270:4: ( ^( ASSIGN ID ID ) | ID )+
+			int cnt14=0;
+			loop14:
+			while (true) {
+				int alt14=3;
+				int LA14_0 = input.LA(1);
+				if ( (LA14_0==ASSIGN) ) {
+					alt14=1;
+				}
+				else if ( (LA14_0==ID) ) {
+					alt14=2;
+				}
+
+				switch (alt14) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:270:6: ^( ASSIGN ID ID )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_delegateGrammars386); 
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_delegateGrammars388); 
+					match(input,ID,FOLLOW_ID_in_delegateGrammars390); 
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:271:6: ID
+					{
+					match(input,ID,FOLLOW_ID_in_delegateGrammars398); 
+					}
+					break;
+
+				default :
+					if ( cnt14 >= 1 ) break loop14;
+					EarlyExitException eee = new EarlyExitException(14, input);
+					throw eee;
+				}
+				cnt14++;
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "delegateGrammars"
+
+
+
+	// $ANTLR start "tokensSpec"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:276:1: tokensSpec : ^( TOKENS ( tokenSpec )* ) ;
+	public final void tokensSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:277:2: ( ^( TOKENS ( tokenSpec )* ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:277:4: ^( TOKENS ( tokenSpec )* )
+			{
+			match(input,TOKENS,FOLLOW_TOKENS_in_tokensSpec420); 
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/AssignTokenTypesWalker.g:277:13: ( tokenSpec )*
+				loop15:
+				while (true) {
+					int alt15=2;
+					int LA15_0 = input.LA(1);
+					if ( (LA15_0==ASSIGN||LA15_0==TOKEN_REF) ) {
+						alt15=1;
+					}
+
+					switch (alt15) {
+					case 1 :
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:277:13: tokenSpec
+						{
+						pushFollow(FOLLOW_tokenSpec_in_tokensSpec422);
+						tokenSpec();
+						state._fsp--;
+
+						}
+						break;
+
+					default :
+						break loop15;
+					}
+				}
+
+				match(input, Token.UP, null); 
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tokensSpec"
+
+
+
+	// $ANTLR start "tokenSpec"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:280:1: tokenSpec : (t= TOKEN_REF | ^( ASSIGN t2= TOKEN_REF (s= STRING_LITERAL |c= CHAR_LITERAL ) ) );
+	public final void tokenSpec() throws RecognitionException {
+		GrammarAST t=null;
+		GrammarAST t2=null;
+		GrammarAST s=null;
+		GrammarAST c=null;
+
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:281:2: (t= TOKEN_REF | ^( ASSIGN t2= TOKEN_REF (s= STRING_LITERAL |c= CHAR_LITERAL ) ) )
+			int alt17=2;
+			int LA17_0 = input.LA(1);
+			if ( (LA17_0==TOKEN_REF) ) {
+				alt17=1;
+			}
+			else if ( (LA17_0==ASSIGN) ) {
+				alt17=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 17, 0, input);
+				throw nvae;
+			}
+
+			switch (alt17) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:281:4: t= TOKEN_REF
+					{
+					t=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec437); 
+					trackToken(t);
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:282:4: ^( ASSIGN t2= TOKEN_REF (s= STRING_LITERAL |c= CHAR_LITERAL ) )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_tokenSpec457); 
+					match(input, Token.DOWN, null); 
+					t2=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec464); 
+					trackToken(t2);
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:284:4: (s= STRING_LITERAL |c= CHAR_LITERAL )
+					int alt16=2;
+					int LA16_0 = input.LA(1);
+					if ( (LA16_0==STRING_LITERAL) ) {
+						alt16=1;
+					}
+					else if ( (LA16_0==CHAR_LITERAL) ) {
+						alt16=2;
+					}
+
+					else {
+						NoViableAltException nvae =
+							new NoViableAltException("", 16, 0, input);
+						throw nvae;
+					}
+
+					switch (alt16) {
+						case 1 :
+							// org/antlr/grammar/v3/AssignTokenTypesWalker.g:284:6: s= STRING_LITERAL
+							{
+							s=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_tokenSpec481); 
+							trackString(s); alias(t2,s);
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/AssignTokenTypesWalker.g:285:6: c= CHAR_LITERAL
+							{
+							c=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_tokenSpec492); 
+							trackString(c); alias(t2,c);
+							}
+							break;
+
+					}
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tokenSpec"
+
+
+
+	// $ANTLR start "rules"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:290:1: rules : ( rule )+ ;
+	public final void rules() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:291:2: ( ( rule )+ )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:291:4: ( rule )+
+			{
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:291:4: ( rule )+
+			int cnt18=0;
+			loop18:
+			while (true) {
+				int alt18=2;
+				int LA18_0 = input.LA(1);
+				if ( (LA18_0==PREC_RULE||LA18_0==RULE) ) {
+					alt18=1;
+				}
+
+				switch (alt18) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:291:4: rule
+					{
+					pushFollow(FOLLOW_rule_in_rules516);
+					rule();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt18 >= 1 ) break loop18;
+					EarlyExitException eee = new EarlyExitException(18, input);
+					throw eee;
+				}
+				cnt18++;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rules"
+
+
+
+	// $ANTLR start "rule"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:294:1: rule : ( ^( RULE ruleBody ) | ^( PREC_RULE ruleBody ) );
+	public final void rule() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:295:2: ( ^( RULE ruleBody ) | ^( PREC_RULE ruleBody ) )
+			int alt19=2;
+			int LA19_0 = input.LA(1);
+			if ( (LA19_0==RULE) ) {
+				alt19=1;
+			}
+			else if ( (LA19_0==PREC_RULE) ) {
+				alt19=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 19, 0, input);
+				throw nvae;
+			}
+
+			switch (alt19) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:295:4: ^( RULE ruleBody )
+					{
+					match(input,RULE,FOLLOW_RULE_in_rule529); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_ruleBody_in_rule531);
+					ruleBody();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:296:4: ^( PREC_RULE ruleBody )
+					{
+					match(input,PREC_RULE,FOLLOW_PREC_RULE_in_rule538); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_ruleBody_in_rule540);
+					ruleBody();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rule"
+
+
+
+	// $ANTLR start "ruleBody"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:299:1: ruleBody : id= ID (m= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ;
+	public final void ruleBody() throws RecognitionException {
+		GrammarAST id=null;
+		TreeRuleReturnScope m =null;
+		TreeRuleReturnScope b =null;
+
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:300:2: (id= ID (m= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:300:4: id= ID (m= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR
+			{
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_ruleBody554); 
+			currentRuleName=(id!=null?id.getText():null);
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:301:3: (m= modifier )?
+			int alt20=2;
+			int LA20_0 = input.LA(1);
+			if ( (LA20_0==FRAGMENT||(LA20_0 >= PRIVATE && LA20_0 <= PUBLIC)) ) {
+				alt20=1;
+			}
+			switch (alt20) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:301:4: m= modifier
+					{
+					pushFollow(FOLLOW_modifier_in_ruleBody563);
+					m=modifier();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			match(input,ARG,FOLLOW_ARG_in_ruleBody570); 
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/AssignTokenTypesWalker.g:302:9: ( ARG_ACTION )?
+				int alt21=2;
+				int LA21_0 = input.LA(1);
+				if ( (LA21_0==ARG_ACTION) ) {
+					alt21=1;
+				}
+				switch (alt21) {
+					case 1 :
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:302:10: ARG_ACTION
+						{
+						match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_ruleBody573); 
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); 
+			}
+
+			match(input,RET,FOLLOW_RET_in_ruleBody581); 
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/AssignTokenTypesWalker.g:303:9: ( ARG_ACTION )?
+				int alt22=2;
+				int LA22_0 = input.LA(1);
+				if ( (LA22_0==ARG_ACTION) ) {
+					alt22=1;
+				}
+				switch (alt22) {
+					case 1 :
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:303:10: ARG_ACTION
+						{
+						match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_ruleBody584); 
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); 
+			}
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:304:3: ( throwsSpec )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+			if ( (LA23_0==THROWS) ) {
+				alt23=1;
+			}
+			switch (alt23) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:304:4: throwsSpec
+					{
+					pushFollow(FOLLOW_throwsSpec_in_ruleBody592);
+					throwsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:305:3: ( optionsSpec )?
+			int alt24=2;
+			int LA24_0 = input.LA(1);
+			if ( (LA24_0==OPTIONS) ) {
+				alt24=1;
+			}
+			switch (alt24) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:305:4: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_ruleBody599);
+					optionsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:306:3: ( ruleScopeSpec )?
+			int alt25=2;
+			int LA25_0 = input.LA(1);
+			if ( (LA25_0==SCOPE) ) {
+				alt25=1;
+			}
+			switch (alt25) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:306:4: ruleScopeSpec
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_ruleBody606);
+					ruleScopeSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:307:3: ( ^( AMPERSAND ( . )* ) )*
+			loop27:
+			while (true) {
+				int alt27=2;
+				int LA27_0 = input.LA(1);
+				if ( (LA27_0==AMPERSAND) ) {
+					alt27=1;
+				}
+
+				switch (alt27) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:307:5: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_ruleBody615); 
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); 
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:307:17: ( . )*
+						loop26:
+						while (true) {
+							int alt26=2;
+							int LA26_0 = input.LA(1);
+							if ( ((LA26_0 >= ACTION && LA26_0 <= CHARSET)) ) {
+								alt26=1;
+							}
+							else if ( (LA26_0==UP) ) {
+								alt26=2;
+							}
+
+							switch (alt26) {
+							case 1 :
+								// org/antlr/grammar/v3/AssignTokenTypesWalker.g:307:17: .
+								{
+								matchAny(input); 
+								}
+								break;
+
+							default :
+								break loop26;
+							}
+						}
+
+						match(input, Token.UP, null); 
+					}
+
+					}
+					break;
+
+				default :
+					break loop27;
+				}
+			}
+
+			pushFollow(FOLLOW_block_in_ruleBody628);
+			b=block();
+			state._fsp--;
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:309:3: ( exceptionGroup )?
+			int alt28=2;
+			int LA28_0 = input.LA(1);
+			if ( (LA28_0==CATCH||LA28_0==FINALLY) ) {
+				alt28=1;
+			}
+			switch (alt28) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:309:4: exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_ruleBody633);
+					exceptionGroup();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			match(input,EOR,FOLLOW_EOR_in_ruleBody639); 
+			trackTokenRule(id,(m!=null?((GrammarAST)m.start):null),(b!=null?((GrammarAST)b.start):null));
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ruleBody"
+
+
+	public static class modifier_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "modifier"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:314:1: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
+	public final AssignTokenTypesWalker.modifier_return modifier() throws RecognitionException {
+		AssignTokenTypesWalker.modifier_return retval = new AssignTokenTypesWalker.modifier_return();
+		retval.start = input.LT(1);
+
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:315:2: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) ) {
+				input.consume();
+				state.errorRecovery=false;
+			}
+			else {
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "modifier"
+
+
+
+	// $ANTLR start "throwsSpec"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:321:1: throwsSpec : ^( 'throws' ( ID )+ ) ;
+	public final void throwsSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:322:2: ( ^( 'throws' ( ID )+ ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:322:4: ^( 'throws' ( ID )+ )
+			{
+			match(input,THROWS,FOLLOW_THROWS_in_throwsSpec681); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:322:15: ( ID )+
+			int cnt29=0;
+			loop29:
+			while (true) {
+				int alt29=2;
+				int LA29_0 = input.LA(1);
+				if ( (LA29_0==ID) ) {
+					alt29=1;
+				}
+
+				switch (alt29) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:322:15: ID
+					{
+					match(input,ID,FOLLOW_ID_in_throwsSpec683); 
+					}
+					break;
+
+				default :
+					if ( cnt29 >= 1 ) break loop29;
+					EarlyExitException eee = new EarlyExitException(29, input);
+					throw eee;
+				}
+				cnt29++;
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "throwsSpec"
+
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:325:1: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
+	public final void ruleScopeSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:326:2: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:326:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec698); 
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); 
+				// org/antlr/grammar/v3/AssignTokenTypesWalker.g:326:15: ( ^( AMPERSAND ( . )* ) )*
+				loop31:
+				while (true) {
+					int alt31=2;
+					int LA31_0 = input.LA(1);
+					if ( (LA31_0==AMPERSAND) ) {
+						alt31=1;
+					}
+
+					switch (alt31) {
+					case 1 :
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:326:17: ^( AMPERSAND ( . )* )
+						{
+						match(input,AMPERSAND,FOLLOW_AMPERSAND_in_ruleScopeSpec703); 
+						if ( input.LA(1)==Token.DOWN ) {
+							match(input, Token.DOWN, null); 
+							// org/antlr/grammar/v3/AssignTokenTypesWalker.g:326:29: ( . )*
+							loop30:
+							while (true) {
+								int alt30=2;
+								int LA30_0 = input.LA(1);
+								if ( ((LA30_0 >= ACTION && LA30_0 <= CHARSET)) ) {
+									alt30=1;
+								}
+								else if ( (LA30_0==UP) ) {
+									alt30=2;
+								}
+
+								switch (alt30) {
+								case 1 :
+									// org/antlr/grammar/v3/AssignTokenTypesWalker.g:326:29: .
+									{
+									matchAny(input); 
+									}
+									break;
+
+								default :
+									break loop30;
+								}
+							}
+
+							match(input, Token.UP, null); 
+						}
+
+						}
+						break;
+
+					default :
+						break loop31;
+					}
+				}
+
+				// org/antlr/grammar/v3/AssignTokenTypesWalker.g:326:36: ( ACTION )?
+				int alt32=2;
+				int LA32_0 = input.LA(1);
+				if ( (LA32_0==ACTION) ) {
+					alt32=1;
+				}
+				switch (alt32) {
+					case 1 :
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:326:37: ACTION
+						{
+						match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec713); 
+						}
+						break;
+
+				}
+
+				// org/antlr/grammar/v3/AssignTokenTypesWalker.g:326:46: ( ID )*
+				loop33:
+				while (true) {
+					int alt33=2;
+					int LA33_0 = input.LA(1);
+					if ( (LA33_0==ID) ) {
+						alt33=1;
+					}
+
+					switch (alt33) {
+					case 1 :
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:326:48: ID
+						{
+						match(input,ID,FOLLOW_ID_in_ruleScopeSpec719); 
+						}
+						break;
+
+					default :
+						break loop33;
+					}
+				}
+
+				match(input, Token.UP, null); 
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+
+	public static class block_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "block"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:329:1: block : ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB ) ;
+	public final AssignTokenTypesWalker.block_return block() throws RecognitionException {
+		AssignTokenTypesWalker.block_return retval = new AssignTokenTypesWalker.block_return();
+		retval.start = input.LT(1);
+
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:330:2: ( ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:330:4: ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_block737); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:331:4: ( optionsSpec )?
+			int alt34=2;
+			int LA34_0 = input.LA(1);
+			if ( (LA34_0==OPTIONS) ) {
+				alt34=1;
+			}
+			switch (alt34) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:331:5: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_block743);
+					optionsSpec();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:332:4: ( alternative rewrite )+
+			int cnt35=0;
+			loop35:
+			while (true) {
+				int alt35=2;
+				int LA35_0 = input.LA(1);
+				if ( (LA35_0==ALT) ) {
+					alt35=1;
+				}
+
+				switch (alt35) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:332:6: alternative rewrite
+					{
+					pushFollow(FOLLOW_alternative_in_block752);
+					alternative();
+					state._fsp--;
+
+					pushFollow(FOLLOW_rewrite_in_block754);
+					rewrite();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt35 >= 1 ) break loop35;
+					EarlyExitException eee = new EarlyExitException(35, input);
+					throw eee;
+				}
+				cnt35++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_block762); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+
+	// $ANTLR start "alternative"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:337:1: alternative : ^( ALT ( element )+ EOA ) ;
+	public final void alternative() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:338:2: ( ^( ALT ( element )+ EOA ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:338:4: ^( ALT ( element )+ EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_alternative779); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:338:11: ( element )+
+			int cnt36=0;
+			loop36:
+			while (true) {
+				int alt36=2;
+				int LA36_0 = input.LA(1);
+				if ( (LA36_0==ACTION||(LA36_0 >= ASSIGN && LA36_0 <= BLOCK)||(LA36_0 >= CHAR_LITERAL && LA36_0 <= CHAR_RANGE)||LA36_0==CLOSURE||LA36_0==DOT||LA36_0==EPSILON||LA36_0==FORCED_ACTION||LA36_0==GATED_SEMPRED||LA36_0==NOT||LA36_0==OPTIONAL||(LA36_0 >= PLUS_ASSIGN && LA36_0 <= POSITIVE_CLOSURE)||LA36_0==RANGE||LA36_0==ROOT||LA36_0==RULE_REF||LA36_0==SEMPRED||(LA36_0 >= STRING_LITERAL && LA36_0 <= SYN_SEMPRED)||LA36_0==TOKEN_REF||LA36_0==TREE_BEGIN||LA36_0==WILDCARD) ) {
+					alt36=1;
+				}
+
+				switch (alt36) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:338:12: element
+					{
+					pushFollow(FOLLOW_element_in_alternative782);
+					element();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt36 >= 1 ) break loop36;
+					EarlyExitException eee = new EarlyExitException(36, input);
+					throw eee;
+				}
+				cnt36++;
+			}
+
+			match(input,EOA,FOLLOW_EOA_in_alternative786); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "alternative"
+
+
+
+	// $ANTLR start "exceptionGroup"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:341:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	public final void exceptionGroup() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:342:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt39=2;
+			int LA39_0 = input.LA(1);
+			if ( (LA39_0==CATCH) ) {
+				alt39=1;
+			}
+			else if ( (LA39_0==FINALLY) ) {
+				alt39=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 39, 0, input);
+				throw nvae;
+			}
+
+			switch (alt39) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:342:4: ( exceptionHandler )+ ( finallyClause )?
+					{
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:342:4: ( exceptionHandler )+
+					int cnt37=0;
+					loop37:
+					while (true) {
+						int alt37=2;
+						int LA37_0 = input.LA(1);
+						if ( (LA37_0==CATCH) ) {
+							alt37=1;
+						}
+
+						switch (alt37) {
+						case 1 :
+							// org/antlr/grammar/v3/AssignTokenTypesWalker.g:342:6: exceptionHandler
+							{
+							pushFollow(FOLLOW_exceptionHandler_in_exceptionGroup801);
+							exceptionHandler();
+							state._fsp--;
+
+							}
+							break;
+
+						default :
+							if ( cnt37 >= 1 ) break loop37;
+							EarlyExitException eee = new EarlyExitException(37, input);
+							throw eee;
+						}
+						cnt37++;
+					}
+
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:342:26: ( finallyClause )?
+					int alt38=2;
+					int LA38_0 = input.LA(1);
+					if ( (LA38_0==FINALLY) ) {
+						alt38=1;
+					}
+					switch (alt38) {
+						case 1 :
+							// org/antlr/grammar/v3/AssignTokenTypesWalker.g:342:27: finallyClause
+							{
+							pushFollow(FOLLOW_finallyClause_in_exceptionGroup807);
+							finallyClause();
+							state._fsp--;
+
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:343:4: finallyClause
+					{
+					pushFollow(FOLLOW_finallyClause_in_exceptionGroup814);
+					finallyClause();
+					state._fsp--;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+
+	// $ANTLR start "exceptionHandler"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:346:1: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	public final void exceptionHandler() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:347:2: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:347:4: ^( 'catch' ARG_ACTION ACTION )
+			{
+			match(input,CATCH,FOLLOW_CATCH_in_exceptionHandler826); 
+			match(input, Token.DOWN, null); 
+			match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_exceptionHandler828); 
+			match(input,ACTION,FOLLOW_ACTION_in_exceptionHandler830); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+
+	// $ANTLR start "finallyClause"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:350:1: finallyClause : ^( 'finally' ACTION ) ;
+	public final void finallyClause() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:351:2: ( ^( 'finally' ACTION ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:351:4: ^( 'finally' ACTION )
+			{
+			match(input,FINALLY,FOLLOW_FINALLY_in_finallyClause843); 
+			match(input, Token.DOWN, null); 
+			match(input,ACTION,FOLLOW_ACTION_in_finallyClause845); 
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "finallyClause"
+
+
+
+	// $ANTLR start "rewrite"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:354:1: rewrite : ( ^( REWRITES ( ^( REWRITE ( . )* ) )* ) |);
+	public final void rewrite() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:355:2: ( ^( REWRITES ( ^( REWRITE ( . )* ) )* ) |)
+			int alt42=2;
+			int LA42_0 = input.LA(1);
+			if ( (LA42_0==REWRITES) ) {
+				alt42=1;
+			}
+			else if ( (LA42_0==ALT||LA42_0==EOB) ) {
+				alt42=2;
+			}
+
+			else {
+				NoViableAltException nvae =
+					new NoViableAltException("", 42, 0, input);
+				throw nvae;
+			}
+
+			switch (alt42) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:355:4: ^( REWRITES ( ^( REWRITE ( . )* ) )* )
+					{
+					match(input,REWRITES,FOLLOW_REWRITES_in_rewrite858); 
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); 
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:355:15: ( ^( REWRITE ( . )* ) )*
+						loop41:
+						while (true) {
+							int alt41=2;
+							int LA41_0 = input.LA(1);
+							if ( (LA41_0==REWRITE) ) {
+								alt41=1;
+							}
+
+							switch (alt41) {
+							case 1 :
+								// org/antlr/grammar/v3/AssignTokenTypesWalker.g:355:17: ^( REWRITE ( . )* )
+								{
+								match(input,REWRITE,FOLLOW_REWRITE_in_rewrite863); 
+								if ( input.LA(1)==Token.DOWN ) {
+									match(input, Token.DOWN, null); 
+									// org/antlr/grammar/v3/AssignTokenTypesWalker.g:355:27: ( . )*
+									loop40:
+									while (true) {
+										int alt40=2;
+										int LA40_0 = input.LA(1);
+										if ( ((LA40_0 >= ACTION && LA40_0 <= CHARSET)) ) {
+											alt40=1;
+										}
+										else if ( (LA40_0==UP) ) {
+											alt40=2;
+										}
+
+										switch (alt40) {
+										case 1 :
+											// org/antlr/grammar/v3/AssignTokenTypesWalker.g:355:27: .
+											{
+											matchAny(input); 
+											}
+											break;
+
+										default :
+											break loop40;
+										}
+									}
+
+									match(input, Token.UP, null); 
+								}
+
+								}
+								break;
+
+							default :
+								break loop41;
+							}
+						}
+
+						match(input, Token.UP, null); 
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:357:2: 
+					{
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite"
+
+
+
+	// $ANTLR start "element"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:359:1: element : ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );
+	public final void element() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:360:2: ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON )
+			int alt44=18;
+			switch ( input.LA(1) ) {
+			case ROOT:
+				{
+				alt44=1;
+				}
+				break;
+			case BANG:
+				{
+				alt44=2;
+				}
+				break;
+			case CHAR_LITERAL:
+			case DOT:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case WILDCARD:
+				{
+				alt44=3;
+				}
+				break;
+			case NOT:
+				{
+				alt44=4;
+				}
+				break;
+			case RANGE:
+				{
+				alt44=5;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt44=6;
+				}
+				break;
+			case ASSIGN:
+				{
+				alt44=7;
+				}
+				break;
+			case PLUS_ASSIGN:
+				{
+				alt44=8;
+				}
+				break;
+			case BLOCK:
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt44=9;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt44=10;
+				}
+				break;
+			case SYNPRED:
+				{
+				alt44=11;
+				}
+				break;
+			case FORCED_ACTION:
+				{
+				alt44=12;
+				}
+				break;
+			case ACTION:
+				{
+				alt44=13;
+				}
+				break;
+			case SEMPRED:
+				{
+				alt44=14;
+				}
+				break;
+			case SYN_SEMPRED:
+				{
+				alt44=15;
+				}
+				break;
+			case BACKTRACK_SEMPRED:
+				{
+				alt44=16;
+				}
+				break;
+			case GATED_SEMPRED:
+				{
+				alt44=17;
+				}
+				break;
+			case EPSILON:
+				{
+				alt44=18;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 44, 0, input);
+				throw nvae;
+			}
+			switch (alt44) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:360:4: ^( ROOT element )
+					{
+					match(input,ROOT,FOLLOW_ROOT_in_element887); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_element_in_element889);
+					element();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:361:4: ^( BANG element )
+					{
+					match(input,BANG,FOLLOW_BANG_in_element896); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_element_in_element898);
+					element();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:362:4: atom
+					{
+					pushFollow(FOLLOW_atom_in_element904);
+					atom();
+					state._fsp--;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:363:4: ^( NOT element )
+					{
+					match(input,NOT,FOLLOW_NOT_in_element910); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_element_in_element912);
+					element();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:364:4: ^( RANGE atom atom )
+					{
+					match(input,RANGE,FOLLOW_RANGE_in_element919); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_atom_in_element921);
+					atom();
+					state._fsp--;
+
+					pushFollow(FOLLOW_atom_in_element923);
+					atom();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:365:4: ^( CHAR_RANGE atom atom )
+					{
+					match(input,CHAR_RANGE,FOLLOW_CHAR_RANGE_in_element930); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_atom_in_element932);
+					atom();
+					state._fsp--;
+
+					pushFollow(FOLLOW_atom_in_element934);
+					atom();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:366:4: ^( ASSIGN ID element )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_element941); 
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_element943); 
+					pushFollow(FOLLOW_element_in_element945);
+					element();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 8 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:367:4: ^( PLUS_ASSIGN ID element )
+					{
+					match(input,PLUS_ASSIGN,FOLLOW_PLUS_ASSIGN_in_element952); 
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_element954); 
+					pushFollow(FOLLOW_element_in_element956);
+					element();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 9 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:368:4: ebnf
+					{
+					pushFollow(FOLLOW_ebnf_in_element962);
+					ebnf();
+					state._fsp--;
+
+					}
+					break;
+				case 10 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:369:4: tree_
+					{
+					pushFollow(FOLLOW_tree__in_element967);
+					tree_();
+					state._fsp--;
+
+					}
+					break;
+				case 11 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:370:4: ^( SYNPRED block )
+					{
+					match(input,SYNPRED,FOLLOW_SYNPRED_in_element974); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_element976);
+					block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 12 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:371:4: FORCED_ACTION
+					{
+					match(input,FORCED_ACTION,FOLLOW_FORCED_ACTION_in_element983); 
+					}
+					break;
+				case 13 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:372:4: ACTION
+					{
+					match(input,ACTION,FOLLOW_ACTION_in_element988); 
+					}
+					break;
+				case 14 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:373:4: SEMPRED
+					{
+					match(input,SEMPRED,FOLLOW_SEMPRED_in_element993); 
+					}
+					break;
+				case 15 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:374:4: SYN_SEMPRED
+					{
+					match(input,SYN_SEMPRED,FOLLOW_SYN_SEMPRED_in_element998); 
+					}
+					break;
+				case 16 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:375:4: ^( BACKTRACK_SEMPRED ( . )* )
+					{
+					match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_element1004); 
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); 
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:375:24: ( . )*
+						loop43:
+						while (true) {
+							int alt43=2;
+							int LA43_0 = input.LA(1);
+							if ( ((LA43_0 >= ACTION && LA43_0 <= CHARSET)) ) {
+								alt43=1;
+							}
+							else if ( (LA43_0==UP) ) {
+								alt43=2;
+							}
+
+							switch (alt43) {
+							case 1 :
+								// org/antlr/grammar/v3/AssignTokenTypesWalker.g:375:24: .
+								{
+								matchAny(input); 
+								}
+								break;
+
+							default :
+								break loop43;
+							}
+						}
+
+						match(input, Token.UP, null); 
+					}
+
+					}
+					break;
+				case 17 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:376:4: GATED_SEMPRED
+					{
+					match(input,GATED_SEMPRED,FOLLOW_GATED_SEMPRED_in_element1013); 
+					}
+					break;
+				case 18 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:377:4: EPSILON
+					{
+					match(input,EPSILON,FOLLOW_EPSILON_in_element1018); 
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "element"
+
+
+
+	// $ANTLR start "ebnf"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:380:1: ebnf : ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
+	public final void ebnf() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:381:2: ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
+			int alt45=4;
+			switch ( input.LA(1) ) {
+			case BLOCK:
+				{
+				alt45=1;
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt45=2;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt45=3;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt45=4;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 45, 0, input);
+				throw nvae;
+			}
+			switch (alt45) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:381:4: block
+					{
+					pushFollow(FOLLOW_block_in_ebnf1029);
+					block();
+					state._fsp--;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:382:4: ^( OPTIONAL block )
+					{
+					match(input,OPTIONAL,FOLLOW_OPTIONAL_in_ebnf1036); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_ebnf1038);
+					block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:383:4: ^( CLOSURE block )
+					{
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_ebnf1047); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_ebnf1049);
+					block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:384:4: ^( POSITIVE_CLOSURE block )
+					{
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_ebnf1058); 
+					match(input, Token.DOWN, null); 
+					pushFollow(FOLLOW_block_in_ebnf1060);
+					block();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ebnf"
+
+
+
+	// $ANTLR start "tree_"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:387:1: tree_ : ^( TREE_BEGIN ( element )+ ) ;
+	public final void tree_() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:388:2: ( ^( TREE_BEGIN ( element )+ ) )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:388:4: ^( TREE_BEGIN ( element )+ )
+			{
+			match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_tree_1074); 
+			match(input, Token.DOWN, null); 
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:388:17: ( element )+
+			int cnt46=0;
+			loop46:
+			while (true) {
+				int alt46=2;
+				int LA46_0 = input.LA(1);
+				if ( (LA46_0==ACTION||(LA46_0 >= ASSIGN && LA46_0 <= BLOCK)||(LA46_0 >= CHAR_LITERAL && LA46_0 <= CHAR_RANGE)||LA46_0==CLOSURE||LA46_0==DOT||LA46_0==EPSILON||LA46_0==FORCED_ACTION||LA46_0==GATED_SEMPRED||LA46_0==NOT||LA46_0==OPTIONAL||(LA46_0 >= PLUS_ASSIGN && LA46_0 <= POSITIVE_CLOSURE)||LA46_0==RANGE||LA46_0==ROOT||LA46_0==RULE_REF||LA46_0==SEMPRED||(LA46_0 >= STRING_LITERAL && LA46_0 <= SYN_SEMPRED)||LA46_0==TOKEN_REF||LA46_0==TREE_BEGIN||LA46_0==WILDCARD) ) {
+					alt46=1;
+				}
+
+				switch (alt46) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:388:17: element
+					{
+					pushFollow(FOLLOW_element_in_tree_1076);
+					element();
+					state._fsp--;
+
+					}
+					break;
+
+				default :
+					if ( cnt46 >= 1 ) break loop46;
+					EarlyExitException eee = new EarlyExitException(46, input);
+					throw eee;
+				}
+				cnt46++;
+			}
+
+			match(input, Token.UP, null); 
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tree_"
+
+
+
+	// $ANTLR start "atom"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:391:1: atom : ( ^( RULE_REF ( ARG_ACTION )? ) | ^(t= TOKEN_REF ( ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom ) );
+	public final void atom() throws RecognitionException {
+		GrammarAST t=null;
+		GrammarAST c=null;
+		GrammarAST s=null;
+
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:392:2: ( ^( RULE_REF ( ARG_ACTION )? ) | ^(t= TOKEN_REF ( ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom ) )
+			int alt49=6;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+				{
+				alt49=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt49=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt49=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt49=4;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt49=5;
+				}
+				break;
+			case DOT:
+				{
+				alt49=6;
+				}
+				break;
+			default:
+				NoViableAltException nvae =
+					new NoViableAltException("", 49, 0, input);
+				throw nvae;
+			}
+			switch (alt49) {
+				case 1 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:392:4: ^( RULE_REF ( ARG_ACTION )? )
+					{
+					match(input,RULE_REF,FOLLOW_RULE_REF_in_atom1091); 
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); 
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:392:16: ( ARG_ACTION )?
+						int alt47=2;
+						int LA47_0 = input.LA(1);
+						if ( (LA47_0==ARG_ACTION) ) {
+							alt47=1;
+						}
+						switch (alt47) {
+							case 1 :
+								// org/antlr/grammar/v3/AssignTokenTypesWalker.g:392:17: ARG_ACTION
+								{
+								match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1094); 
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); 
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:393:4: ^(t= TOKEN_REF ( ARG_ACTION )? )
+					{
+					t=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom1107); 
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); 
+						// org/antlr/grammar/v3/AssignTokenTypesWalker.g:393:19: ( ARG_ACTION )?
+						int alt48=2;
+						int LA48_0 = input.LA(1);
+						if ( (LA48_0==ARG_ACTION) ) {
+							alt48=1;
+						}
+						switch (alt48) {
+							case 1 :
+								// org/antlr/grammar/v3/AssignTokenTypesWalker.g:393:20: ARG_ACTION
+								{
+								match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1110); 
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); 
+					}
+
+					trackToken(t);
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:394:4: c= CHAR_LITERAL
+					{
+					c=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom1124); 
+					trackString(c);
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:395:4: s= STRING_LITERAL
+					{
+					s=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_atom1135); 
+					trackString(s);
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:396:4: WILDCARD
+					{
+					match(input,WILDCARD,FOLLOW_WILDCARD_in_atom1142); 
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/AssignTokenTypesWalker.g:397:4: ^( DOT ID atom )
+					{
+					match(input,DOT,FOLLOW_DOT_in_atom1148); 
+					match(input, Token.DOWN, null); 
+					match(input,ID,FOLLOW_ID_in_atom1150); 
+					pushFollow(FOLLOW_atom_in_atom1152);
+					atom();
+					state._fsp--;
+
+					match(input, Token.UP, null); 
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "atom"
+
+
+
+	// $ANTLR start "ast_suffix"
+	// org/antlr/grammar/v3/AssignTokenTypesWalker.g:400:1: ast_suffix : ( ROOT | BANG );
+	public final void ast_suffix() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:401:2: ( ROOT | BANG )
+			// org/antlr/grammar/v3/AssignTokenTypesWalker.g:
+			{
+			if ( input.LA(1)==BANG||input.LA(1)==ROOT ) {
+				input.consume();
+				state.errorRecovery=false;
+			}
+			else {
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ast_suffix"
+
+	// Delegated rules
+
+
+
+	public static final BitSet FOLLOW_LEXER_GRAMMAR_in_grammar_69 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_74 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PARSER_GRAMMAR_in_grammar_84 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_88 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_GRAMMAR_in_grammar_98 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_104 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_COMBINED_GRAMMAR_in_grammar_114 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_116 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_grammarSpec135 = new BitSet(new long[]{0x0400200008000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_DOC_COMMENT_in_grammarSpec142 = new BitSet(new long[]{0x0400200000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_optionsSpec_in_grammarSpec149 = new BitSet(new long[]{0x0000200000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_delegateGrammars_in_grammarSpec156 = new BitSet(new long[]{0x0000000000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_tokensSpec_in_grammarSpec163 = new BitSet(new long[]{0x0000000000000200L,0x0000000000028002L});
+	public static final BitSet FOLLOW_attrScope_in_grammarSpec170 = new BitSet(new long[]{0x0000000000000200L,0x0000000000028002L});
+	public static final BitSet FOLLOW_AMPERSAND_in_grammarSpec179 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rules_in_grammarSpec191 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SCOPE_in_attrScope204 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_attrScope206 = new BitSet(new long[]{0x0000000000000210L});
+	public static final BitSet FOLLOW_AMPERSAND_in_attrScope211 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_attrScope220 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_OPTIONS_in_optionsSpec239 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_option_in_optionsSpec242 = new BitSet(new long[]{0x0000000000002008L});
+	public static final BitSet FOLLOW_ASSIGN_in_option261 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_option263 = new BitSet(new long[]{0x0000880000040000L,0x0000000001000000L});
+	public static final BitSet FOLLOW_optionValue_in_option265 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_optionValue291 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_optionValue296 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_optionValue301 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_INT_in_optionValue306 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHARSET_in_charSet324 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_charSetElement_in_charSet326 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_charSetElement339 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OR_in_charSetElement346 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_charSetElement348 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_charSetElement350 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RANGE_in_charSetElement359 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_charSetElement361 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_charSetElement363 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_IMPORT_in_delegateGrammars378 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ASSIGN_in_delegateGrammars386 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_delegateGrammars388 = new BitSet(new long[]{0x0000080000000000L});
+	public static final BitSet FOLLOW_ID_in_delegateGrammars390 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_delegateGrammars398 = new BitSet(new long[]{0x0000080000002008L});
+	public static final BitSet FOLLOW_TOKENS_in_tokensSpec420 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_tokenSpec_in_tokensSpec422 = new BitSet(new long[]{0x0000000000002008L,0x0000000040000000L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec437 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ASSIGN_in_tokenSpec457 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec464 = new BitSet(new long[]{0x0000000000040000L,0x0000000001000000L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_tokenSpec481 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_tokenSpec492 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_rule_in_rules516 = new BitSet(new long[]{0x0000000000000002L,0x0000000000008002L});
+	public static final BitSet FOLLOW_RULE_in_rule529 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ruleBody_in_rule531 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PREC_RULE_in_rule538 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ruleBody_in_rule540 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_ruleBody554 = new BitSet(new long[]{0x0000010000000400L,0x000000000000001CL});
+	public static final BitSet FOLLOW_modifier_in_ruleBody563 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_ARG_in_ruleBody570 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_ruleBody573 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RET_in_ruleBody581 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_ruleBody584 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_throwsSpec_in_ruleBody592 = new BitSet(new long[]{0x0400000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_optionsSpec_in_ruleBody599 = new BitSet(new long[]{0x0000000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_ruleBody606 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_AMPERSAND_in_ruleBody615 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ruleBody628 = new BitSet(new long[]{0x0000004400020000L});
+	public static final BitSet FOLLOW_exceptionGroup_in_ruleBody633 = new BitSet(new long[]{0x0000000400000000L});
+	public static final BitSet FOLLOW_EOR_in_ruleBody639 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_THROWS_in_throwsSpec681 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_throwsSpec683 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec698 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_AMPERSAND_in_ruleScopeSpec703 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec713 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_ID_in_ruleScopeSpec719 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_block737 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_optionsSpec_in_block743 = new BitSet(new long[]{0x0000000000000100L});
+	public static final BitSet FOLLOW_alternative_in_block752 = new BitSet(new long[]{0x0000000200000100L,0x0000000000001000L});
+	public static final BitSet FOLLOW_rewrite_in_block754 = new BitSet(new long[]{0x0000000200000100L});
+	public static final BitSet FOLLOW_EOB_in_block762 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_alternative779 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_alternative782 = new BitSet(new long[]{0x82800289202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_EOA_in_alternative786 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_exceptionHandler_in_exceptionGroup801 = new BitSet(new long[]{0x0000004000020002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup807 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup814 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CATCH_in_exceptionHandler826 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_exceptionHandler828 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_exceptionHandler830 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_FINALLY_in_finallyClause843 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_finallyClause845 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_REWRITES_in_rewrite858 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite863 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ROOT_in_element887 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element889 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BANG_in_element896 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element898 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_atom_in_element904 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_NOT_in_element910 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element912 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RANGE_in_element919 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_atom_in_element921 = new BitSet(new long[]{0x0000000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_element923 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_RANGE_in_element930 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_atom_in_element932 = new BitSet(new long[]{0x0000000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_element934 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ASSIGN_in_element941 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element943 = new BitSet(new long[]{0x82800288202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_element945 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PLUS_ASSIGN_in_element952 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element954 = new BitSet(new long[]{0x82800288202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_element956 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ebnf_in_element962 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_tree__in_element967 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYNPRED_in_element974 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_element976 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_FORCED_ACTION_in_element983 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_element988 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SEMPRED_in_element993 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYN_SEMPRED_in_element998 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_element1004 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_GATED_SEMPRED_in_element1013 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_EPSILON_in_element1018 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_ebnf1029 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONAL_in_ebnf1036 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1038 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_ebnf1047 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1049 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_ebnf1058 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1060 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_tree_1074 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_tree_1076 = new BitSet(new long[]{0x82800288202DE018L,0x0000000547092041L});
+	public static final BitSet FOLLOW_RULE_REF_in_atom1091 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1094 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom1107 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1110 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom1124 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_atom1135 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_WILDCARD_in_atom1142 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOT_in_atom1148 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_atom1150 = new BitSet(new long[]{0x0000000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_atom1152 = new BitSet(new long[]{0x0000000000000008L});
+}
--- tool/src/main/java/org/antlr/grammar/v3/CodeGenTreeWalker.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/CodeGenTreeWalker.java	2019-04-04 17:22:25.476181469 +0200
@@ -0,0 +1,5303 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/CodeGenTreeWalker.g 2019-04-04 15:18:50
+
+package org.antlr.grammar.v3;
+
+import org.antlr.analysis.*;
+import org.antlr.misc.*;
+import org.antlr.tool.*;
+import org.antlr.codegen.*;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.Collection;
+import org.antlr.runtime.BitSet;
+import org.antlr.runtime.DFA;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;
+
+
+import org.antlr.runtime.*;
+import org.antlr.runtime.tree.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+
+/** Walk a grammar and generate code by gradually building up
+ *  a bigger and bigger ST.
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  June 15, 2004
+ */
+@SuppressWarnings("all")
+public class CodeGenTreeWalker extends TreeParser {
+	public static final String[] tokenNames = new String[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", 
+		"ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", 
+		"ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", 
+		"CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", 
+		"COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", 
+		"DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", 
+		"EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", 
+		"GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", 
+		"LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", 
+		"NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", 
+		"OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", 
+		"PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", 
+		"RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", 
+		"RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", 
+		"SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", 
+		"TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", 
+		"WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public static final int EOF=-1;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int AMPERSAND=9;
+	public static final int ARG=10;
+	public static final int ARGLIST=11;
+	public static final int ARG_ACTION=12;
+	public static final int ASSIGN=13;
+	public static final int BACKTRACK_SEMPRED=14;
+	public static final int BANG=15;
+	public static final int BLOCK=16;
+	public static final int CATCH=17;
+	public static final int CHAR_LITERAL=18;
+	public static final int CHAR_RANGE=19;
+	public static final int CLOSE_ELEMENT_OPTION=20;
+	public static final int CLOSURE=21;
+	public static final int COLON=22;
+	public static final int COMBINED_GRAMMAR=23;
+	public static final int COMMA=24;
+	public static final int COMMENT=25;
+	public static final int DIGIT=26;
+	public static final int DOC_COMMENT=27;
+	public static final int DOLLAR=28;
+	public static final int DOT=29;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public static final int EOA=32;
+	public static final int EOB=33;
+	public static final int EOR=34;
+	public static final int EPSILON=35;
+	public static final int ESC=36;
+	public static final int ETC=37;
+	public static final int FINALLY=38;
+	public static final int FORCED_ACTION=39;
+	public static final int FRAGMENT=40;
+	public static final int GATED_SEMPRED=41;
+	public static final int GRAMMAR=42;
+	public static final int ID=43;
+	public static final int IMPLIES=44;
+	public static final int IMPORT=45;
+	public static final int INITACTION=46;
+	public static final int INT=47;
+	public static final int LABEL=48;
+	public static final int LEXER=49;
+	public static final int LEXER_GRAMMAR=50;
+	public static final int LPAREN=51;
+	public static final int ML_COMMENT=52;
+	public static final int NESTED_ACTION=53;
+	public static final int NESTED_ARG_ACTION=54;
+	public static final int NOT=55;
+	public static final int OPEN_ELEMENT_OPTION=56;
+	public static final int OPTIONAL=57;
+	public static final int OPTIONS=58;
+	public static final int OR=59;
+	public static final int PARSER=60;
+	public static final int PARSER_GRAMMAR=61;
+	public static final int PLUS=62;
+	public static final int PLUS_ASSIGN=63;
+	public static final int POSITIVE_CLOSURE=64;
+	public static final int PREC_RULE=65;
+	public static final int PRIVATE=66;
+	public static final int PROTECTED=67;
+	public static final int PUBLIC=68;
+	public static final int QUESTION=69;
+	public static final int RANGE=70;
+	public static final int RCURLY=71;
+	public static final int RECURSIVE_RULE_REF=72;
+	public static final int RET=73;
+	public static final int RETURNS=74;
+	public static final int REWRITE=75;
+	public static final int REWRITES=76;
+	public static final int ROOT=77;
+	public static final int RPAREN=78;
+	public static final int RULE=79;
+	public static final int RULE_REF=80;
+	public static final int SCOPE=81;
+	public static final int SEMI=82;
+	public static final int SEMPRED=83;
+	public static final int SL_COMMENT=84;
+	public static final int SRC=85;
+	public static final int STAR=86;
+	public static final int STRAY_BRACKET=87;
+	public static final int STRING_LITERAL=88;
+	public static final int SYNPRED=89;
+	public static final int SYN_SEMPRED=90;
+	public static final int TEMPLATE=91;
+	public static final int THROWS=92;
+	public static final int TOKENS=93;
+	public static final int TOKEN_REF=94;
+	public static final int TREE=95;
+	public static final int TREE_BEGIN=96;
+	public static final int TREE_GRAMMAR=97;
+	public static final int WILDCARD=98;
+	public static final int WS=99;
+	public static final int WS_LOOP=100;
+	public static final int WS_OPT=101;
+	public static final int XDIGIT=102;
+
+	// delegates
+	public TreeParser[] getDelegates() {
+		return new TreeParser[] {};
+	}
+
+	// delegators
+
+
+	public CodeGenTreeWalker(TreeNodeStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public CodeGenTreeWalker(TreeNodeStream input, RecognizerSharedState state) {
+		super(input, state);
+	}
+
+	@Override public String[] getTokenNames() { return CodeGenTreeWalker.tokenNames; }
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/CodeGenTreeWalker.g"; }
+
+
+	protected static final int RULE_BLOCK_NESTING_LEVEL = 0;
+	protected static final int OUTER_REWRITE_NESTING_LEVEL = 0;
+
+	private String currentRuleName = null;
+	protected int blockNestingLevel = 0;
+	protected int rewriteBlockNestingLevel = 0;
+	private int outerAltNum = 0;
+	protected ST currentBlockST = null;
+	protected boolean currentAltHasASTRewrite = false;
+	protected int rewriteTreeNestingLevel = 0;
+	protected HashSet<Object> rewriteRuleRefs = null;
+
+	public String getCurrentRuleName() {
+	    return currentRuleName;
+	}
+
+	public void setCurrentRuleName(String value) {
+	    currentRuleName = value;
+	}
+
+	public int getOuterAltNum() {
+	    return outerAltNum;
+	}
+
+	public void setOuterAltNum(int value) {
+	    outerAltNum = value;
+	}
+
+	@Override
+	public void reportError(RecognitionException ex) {
+	    Token token = null;
+	    if (ex instanceof MismatchedTokenException) {
+	        token = ((MismatchedTokenException)ex).token;
+	    } else if (ex instanceof NoViableAltException) {
+	        token = ((NoViableAltException)ex).token;
+	    }
+
+	    ErrorManager.syntaxError(
+	        ErrorManager.MSG_SYNTAX_ERROR,
+	        grammar,
+	        token,
+	        "codegen: " + ex.toString(),
+	        ex );
+	}
+
+	public final void reportError(String s) {
+	    System.out.println("codegen: error: " + s);
+	}
+
+	protected CodeGenerator generator;
+	protected Grammar grammar;
+	protected STGroup templates;
+
+	/** The overall lexer/parser template; simulate dynamically scoped
+	 *  attributes by making this an instance var of the walker.
+	 */
+	protected ST recognizerST;
+
+	protected ST outputFileST;
+	protected ST headerFileST;
+
+	protected String outputOption = "";
+
+	protected final ST getWildcardST(GrammarAST elementAST, GrammarAST ast_suffix, String label) {
+	    String name = "wildcard";
+	    if (grammar.type == Grammar.LEXER) {
+	        name = "wildcardChar";
+	    }
+	    return getTokenElementST(name, name, elementAST, ast_suffix, label);
+	}
+
+	protected final ST getRuleElementST( String name,
+	                                          String ruleTargetName,
+	                                          GrammarAST elementAST,
+	                                          GrammarAST ast_suffix,
+	                                          String label ) {
+		Rule r = grammar.getRule( currentRuleName );
+		String suffix = getSTSuffix(elementAST, ast_suffix, label);
+		if ( !r.isSynPred ) {
+			name += suffix;
+		}
+		// if we're building trees and there is no label, gen a label
+		// unless we're in a synpred rule.
+		if ( ( grammar.buildAST() || suffix.length() > 0 ) && label == null &&
+			 ( r == null || !r.isSynPred ) ) {
+			// we will need a label to do the AST or tracking, make one
+			label = generator.createUniqueLabel( ruleTargetName );
+			CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
+			grammar.defineRuleRefLabel( currentRuleName, labelTok, elementAST );
+		}
+
+		ST elementST = templates.getInstanceOf( name );
+		if ( label != null ) {
+			elementST.add( "label", label );
+		}
+
+
+		return elementST;
+	}
+
+	protected final ST getTokenElementST( String name,
+	                                           String elementName,
+	                                           GrammarAST elementAST,
+	                                           GrammarAST ast_suffix,
+	                                           String label ) {
+	    boolean tryUnchecked = false;
+	    if (name == "matchSet" && elementAST.enclosingRuleName != null && elementAST.enclosingRuleName.length() > 0 && Rule.getRuleType(elementAST.enclosingRuleName) == Grammar.LEXER)
+	    {
+	        if ( ( elementAST.getParent().getType() == ANTLRLexer.ALT && elementAST.getParent().getParent().getParent().getType() == RULE && elementAST.getParent().getParent().getChildCount() == 2 )
+	            || ( elementAST.getParent().getType() == ANTLRLexer.NOT && elementAST.getParent().getParent().getParent().getParent().getType() == RULE && elementAST.getParent().getParent().getParent().getChildCount() == 2 ) ) {
+	            // single alt at the start of the rule needs to be checked
+	        } else {
+	            tryUnchecked = true;
+	        }
+	    }
+
+	    String suffix = getSTSuffix( elementAST, ast_suffix, label );
+	    // if we're building trees and there is no label, gen a label
+	    // unless we're in a synpred rule.
+	    Rule r = grammar.getRule( currentRuleName );
+	    if ( ( grammar.buildAST() || suffix.length() > 0 ) && label == null &&
+	         ( r == null || !r.isSynPred ) )
+	    {
+	        label = generator.createUniqueLabel( elementName );
+	        CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
+	        grammar.defineTokenRefLabel( currentRuleName, labelTok, elementAST );
+	    }
+
+	    ST elementST = null;
+	    if ( tryUnchecked && templates.isDefined( name + "Unchecked" + suffix ) )
+	        elementST = templates.getInstanceOf( name + "Unchecked" + suffix );
+	    if ( elementST == null )
+	        elementST = templates.getInstanceOf( name + suffix );
+
+	    if ( label != null )
+	    {
+	        elementST.add( "label", label );
+	    }
+	    return elementST;
+	}
+
+	public final boolean isListLabel(String label) {
+	    boolean hasListLabel = false;
+	    if ( label != null ) {
+	        Rule r = grammar.getRule( currentRuleName );
+	        //String stName = null;
+	        if ( r != null )
+	        {
+	            Grammar.LabelElementPair pair = r.getLabel( label );
+	            if ( pair != null &&
+	                 ( pair.type == Grammar.TOKEN_LIST_LABEL ||
+	                  pair.type == Grammar.RULE_LIST_LABEL ||
+	                  pair.type == Grammar.WILDCARD_TREE_LIST_LABEL ) )
+	            {
+	                hasListLabel = true;
+	            }
+	        }
+	    }
+	    return hasListLabel;
+	}
+
+	/** Return a non-empty template name suffix if the token is to be
+	 *  tracked, added to a tree, or both.
+	 */
+	protected final String getSTSuffix(GrammarAST elementAST, GrammarAST ast_suffix, String label) {
+	    if ( grammar.type == Grammar.LEXER )
+	    {
+	        return "";
+	    }
+	    // handle list label stuff; make element use "Track"
+
+	    String operatorPart = "";
+	    String rewritePart = "";
+	    String listLabelPart = "";
+	    Rule ruleDescr = grammar.getRule( currentRuleName );
+	    if ( ast_suffix != null && !ruleDescr.isSynPred )
+	    {
+	        if ( ast_suffix.getType() == ANTLRParser.ROOT )
+	        {
+	            operatorPart = "RuleRoot";
+	        }
+	        else if ( ast_suffix.getType() == ANTLRParser.BANG )
+	        {
+	            operatorPart = "Bang";
+	        }
+	    }
+	    if ( currentAltHasASTRewrite && elementAST.getType() != WILDCARD )
+	    {
+	        rewritePart = "Track";
+	    }
+	    if ( isListLabel( label ) )
+	    {
+	        listLabelPart = "AndListLabel";
+	    }
+	    String STsuffix = operatorPart + rewritePart + listLabelPart;
+	    //JSystem.@out.println("suffix = "+STsuffix);
+
+	    return STsuffix;
+	}
+
+	/** Convert rewrite AST lists to target labels list */
+	protected final List<String> getTokenTypesAsTargetLabels(Collection<GrammarAST> refs)
+	{
+	    if ( refs == null || refs.size() == 0 )
+	        return null;
+
+	    List<String> labels = new ArrayList<String>( refs.size() );
+	    for ( GrammarAST t : refs )
+	    {
+	        String label;
+	        if ( t.getType() == ANTLRParser.RULE_REF || t.getType() == ANTLRParser.TOKEN_REF || t.getType() == ANTLRParser.LABEL)
+	        {
+	            label = t.getText();
+	        }
+	        else
+	        {
+	            // must be char or String literal
+	            label = generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.getText()));
+	        }
+	        labels.add( label );
+	    }
+	    return labels;
+	}
+
+	public final void init( Grammar g ) {
+	    this.grammar = g;
+	    this.generator = grammar.getCodeGenerator();
+	    this.templates = generator.getTemplates();
+	}
+
+
+
+	// $ANTLR start "grammar_"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:298:1: public grammar_[Grammar g,\n\t\tST recognizerST,\n\t\tST outputFileST,\n\t\tST headerFileST] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
+	public final void grammar_(Grammar g, ST recognizerST, ST outputFileST, ST headerFileST) throws RecognitionException {
+
+			if ( state.backtracking == 0 )
+			{
+				init(g);
+				this.recognizerST = recognizerST;
+				this.outputFileST = outputFileST;
+				this.headerFileST = headerFileST;
+				String superClass = (String)g.getOption("superClass");
+				outputOption = (String)g.getOption("output");
+				if ( superClass!=null ) recognizerST.add("superClass", superClass);
+				if ( g.type!=Grammar.LEXER ) {
+				    Object lt = g.getOption("ASTLabelType");
+					if ( lt!=null ) recognizerST.add("ASTLabelType", lt);
+				}
+				if ( g.type==Grammar.TREE_PARSER && g.getOption("ASTLabelType")==null ) {
+					ErrorManager.grammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
+											   g,
+											   null,
+											   g.name);
+				}
+				if ( g.type!=Grammar.TREE_PARSER ) {
+				    Object lt = g.getOption("TokenLabelType");
+					if ( lt!=null ) recognizerST.add("labelType", lt);
+				}
+				recognizerST.add("numRules", grammar.getRules().size());
+				outputFileST.add("numRules", grammar.getRules().size());
+				headerFileST.add("numRules", grammar.getRules().size());
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:332:2: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:332:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			{
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:332:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			int alt1=4;
+			switch ( input.LA(1) ) {
+			case LEXER_GRAMMAR:
+				{
+				alt1=1;
+				}
+				break;
+			case PARSER_GRAMMAR:
+				{
+				alt1=2;
+				}
+				break;
+			case TREE_GRAMMAR:
+				{
+				alt1=3;
+				}
+				break;
+			case COMBINED_GRAMMAR:
+				{
+				alt1=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 1, 0, input);
+				throw nvae;
+			}
+			switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:332:6: ^( LEXER_GRAMMAR grammarSpec )
+					{
+					match(input,LEXER_GRAMMAR,FOLLOW_LEXER_GRAMMAR_in_grammar_67); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_69);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:333:5: ^( PARSER_GRAMMAR grammarSpec )
+					{
+					match(input,PARSER_GRAMMAR,FOLLOW_PARSER_GRAMMAR_in_grammar_79); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_81);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:334:5: ^( TREE_GRAMMAR grammarSpec )
+					{
+					match(input,TREE_GRAMMAR,FOLLOW_TREE_GRAMMAR_in_grammar_91); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_93);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:335:5: ^( COMBINED_GRAMMAR grammarSpec )
+					{
+					match(input,COMBINED_GRAMMAR,FOLLOW_COMBINED_GRAMMAR_in_grammar_103); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_105);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammar_"
+
+
+
+	// $ANTLR start "attrScope"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:339:1: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
+	public final void attrScope() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:340:2: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:340:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_attrScope124); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			match(input,ID,FOLLOW_ID_in_attrScope126); if (state.failed) return;
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:340:18: ( ^( AMPERSAND ( . )* ) )*
+			loop3:
+			while (true) {
+				int alt3=2;
+				int LA3_0 = input.LA(1);
+				if ( (LA3_0==AMPERSAND) ) {
+					alt3=1;
+				}
+
+				switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:340:20: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_attrScope131); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:340:32: ( . )*
+						loop2:
+						while (true) {
+							int alt2=2;
+							int LA2_0 = input.LA(1);
+							if ( ((LA2_0 >= ACTION && LA2_0 <= XDIGIT)) ) {
+								alt2=1;
+							}
+							else if ( (LA2_0==UP) ) {
+								alt2=2;
+							}
+
+							switch (alt2) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:340:32: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop2;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+				default :
+					break loop3;
+				}
+			}
+
+			match(input,ACTION,FOLLOW_ACTION_in_attrScope140); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "attrScope"
+
+
+
+	// $ANTLR start "grammarSpec"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:343:1: grammarSpec : name= ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST] ;
+	public final void grammarSpec() throws RecognitionException {
+		GrammarAST name=null;
+		GrammarAST cmt=null;
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:344:2: (name= ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST] )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:344:6: name= ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST]
+			{
+			name=(GrammarAST)match(input,ID,FOLLOW_ID_in_grammarSpec157); if (state.failed) return;
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:345:3: (cmt= DOC_COMMENT )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+			if ( (LA4_0==DOC_COMMENT) ) {
+				alt4=1;
+			}
+			switch (alt4) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:345:5: cmt= DOC_COMMENT
+					{
+					cmt=(GrammarAST)match(input,DOC_COMMENT,FOLLOW_DOC_COMMENT_in_grammarSpec165); if (state.failed) return;
+					if ( state.backtracking==0 ) {
+									outputFileST.add("docComment", (cmt!=null?cmt.getText():null));
+									headerFileST.add("docComment", (cmt!=null?cmt.getText():null));
+								}
+					}
+					break;
+
+			}
+
+			if ( state.backtracking==0 ) {
+						recognizerST.add("name", grammar.getRecognizerName());
+						outputFileST.add("name", grammar.getRecognizerName());
+						headerFileST.add("name", grammar.getRecognizerName());
+						recognizerST.add("scopes", grammar.getGlobalScopes());
+						headerFileST.add("scopes", grammar.getGlobalScopes());
+					}
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:358:3: ( ^( OPTIONS ( . )* ) )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+			if ( (LA6_0==OPTIONS) ) {
+				alt6=1;
+			}
+			switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:358:5: ^( OPTIONS ( . )* )
+					{
+					match(input,OPTIONS,FOLLOW_OPTIONS_in_grammarSpec186); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:358:15: ( . )*
+						loop5:
+						while (true) {
+							int alt5=2;
+							int LA5_0 = input.LA(1);
+							if ( ((LA5_0 >= ACTION && LA5_0 <= XDIGIT)) ) {
+								alt5=1;
+							}
+							else if ( (LA5_0==UP) ) {
+								alt5=2;
+							}
+
+							switch (alt5) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:358:15: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop5;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:359:3: ( ^( IMPORT ( . )* ) )?
+			int alt8=2;
+			int LA8_0 = input.LA(1);
+			if ( (LA8_0==IMPORT) ) {
+				alt8=1;
+			}
+			switch (alt8) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:359:5: ^( IMPORT ( . )* )
+					{
+					match(input,IMPORT,FOLLOW_IMPORT_in_grammarSpec200); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:359:14: ( . )*
+						loop7:
+						while (true) {
+							int alt7=2;
+							int LA7_0 = input.LA(1);
+							if ( ((LA7_0 >= ACTION && LA7_0 <= XDIGIT)) ) {
+								alt7=1;
+							}
+							else if ( (LA7_0==UP) ) {
+								alt7=2;
+							}
+
+							switch (alt7) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:359:14: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop7;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:360:3: ( ^( TOKENS ( . )* ) )?
+			int alt10=2;
+			int LA10_0 = input.LA(1);
+			if ( (LA10_0==TOKENS) ) {
+				alt10=1;
+			}
+			switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:360:5: ^( TOKENS ( . )* )
+					{
+					match(input,TOKENS,FOLLOW_TOKENS_in_grammarSpec214); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:360:14: ( . )*
+						loop9:
+						while (true) {
+							int alt9=2;
+							int LA9_0 = input.LA(1);
+							if ( ((LA9_0 >= ACTION && LA9_0 <= XDIGIT)) ) {
+								alt9=1;
+							}
+							else if ( (LA9_0==UP) ) {
+								alt9=2;
+							}
+
+							switch (alt9) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:360:14: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop9;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:361:3: ( attrScope )*
+			loop11:
+			while (true) {
+				int alt11=2;
+				int LA11_0 = input.LA(1);
+				if ( (LA11_0==SCOPE) ) {
+					alt11=1;
+				}
+
+				switch (alt11) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:361:4: attrScope
+					{
+					pushFollow(FOLLOW_attrScope_in_grammarSpec226);
+					attrScope();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					break loop11;
+				}
+			}
+
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:362:3: ( ^( AMPERSAND ( . )* ) )*
+			loop13:
+			while (true) {
+				int alt13=2;
+				int LA13_0 = input.LA(1);
+				if ( (LA13_0==AMPERSAND) ) {
+					alt13=1;
+				}
+
+				switch (alt13) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:362:5: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_grammarSpec235); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:362:17: ( . )*
+						loop12:
+						while (true) {
+							int alt12=2;
+							int LA12_0 = input.LA(1);
+							if ( ((LA12_0 >= ACTION && LA12_0 <= XDIGIT)) ) {
+								alt12=1;
+							}
+							else if ( (LA12_0==UP) ) {
+								alt12=2;
+							}
+
+							switch (alt12) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:362:17: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop12;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+				default :
+					break loop13;
+				}
+			}
+
+			pushFollow(FOLLOW_rules_in_grammarSpec246);
+			rules(recognizerST);
+			state._fsp--;
+			if (state.failed) return;
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammarSpec"
+
+
+
+	// $ANTLR start "rules"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:366:1: rules[ST recognizerST] : ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) ) )+ ;
+	public final void rules(ST recognizerST) throws RecognitionException {
+		TreeRuleReturnScope rST =null;
+
+
+			String ruleName = ((GrammarAST)input.LT(1)).getChild(0).getText();
+			boolean generated = grammar.generateMethodForRule(ruleName);
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:372:2: ( ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) ) )+ )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:372:4: ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) ) )+
+			{
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:372:4: ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) ) )+
+			int cnt17=0;
+			loop17:
+			while (true) {
+				int alt17=2;
+				int LA17_0 = input.LA(1);
+				if ( (LA17_0==PREC_RULE||LA17_0==RULE) ) {
+					alt17=1;
+				}
+
+				switch (alt17) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:372:6: ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) )
+					{
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:372:6: ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) )
+					int alt16=3;
+					int LA16_0 = input.LA(1);
+					if ( (LA16_0==RULE) ) {
+						int LA16_1 = input.LA(2);
+						if ( ((generated)) ) {
+							alt16=1;
+						}
+						else if ( (true) ) {
+							alt16=2;
+						}
+
+					}
+					else if ( (LA16_0==PREC_RULE) ) {
+						alt16=3;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 16, 0, input);
+						throw nvae;
+					}
+
+					switch (alt16) {
+						case 1 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:373:5: {...}? =>rST= rule
+							{
+							if ( !((generated)) ) {
+								if (state.backtracking>0) {state.failed=true; return;}
+								throw new FailedPredicateException(input, "rules", "generated");
+							}
+							pushFollow(FOLLOW_rule_in_rules291);
+							rST=rule();
+							state._fsp--;
+							if (state.failed) return;
+							if ( state.backtracking==0 ) {
+												if ( (rST!=null?((CodeGenTreeWalker.rule_return)rST).code:null) != null )
+												{
+													recognizerST.add("rules", (rST!=null?((CodeGenTreeWalker.rule_return)rST).code:null));
+													outputFileST.add("rules", (rST!=null?((CodeGenTreeWalker.rule_return)rST).code:null));
+													headerFileST.add("rules", (rST!=null?((CodeGenTreeWalker.rule_return)rST).code:null));
+												}
+											}
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:383:6: ^( RULE ( . )* )
+							{
+							match(input,RULE,FOLLOW_RULE_in_rules305); if (state.failed) return;
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); if (state.failed) return;
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:383:13: ( . )*
+								loop14:
+								while (true) {
+									int alt14=2;
+									int LA14_0 = input.LA(1);
+									if ( ((LA14_0 >= ACTION && LA14_0 <= XDIGIT)) ) {
+										alt14=1;
+									}
+									else if ( (LA14_0==UP) ) {
+										alt14=2;
+									}
+
+									switch (alt14) {
+									case 1 :
+										// org/antlr/grammar/v3/CodeGenTreeWalker.g:383:13: .
+										{
+										matchAny(input); if (state.failed) return;
+										}
+										break;
+
+									default :
+										break loop14;
+									}
+								}
+
+								match(input, Token.UP, null); if (state.failed) return;
+							}
+
+							}
+							break;
+						case 3 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:384:6: ^( PREC_RULE ( . )* )
+							{
+							match(input,PREC_RULE,FOLLOW_PREC_RULE_in_rules317); if (state.failed) return;
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); if (state.failed) return;
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:384:18: ( . )*
+								loop15:
+								while (true) {
+									int alt15=2;
+									int LA15_0 = input.LA(1);
+									if ( ((LA15_0 >= ACTION && LA15_0 <= XDIGIT)) ) {
+										alt15=1;
+									}
+									else if ( (LA15_0==UP) ) {
+										alt15=2;
+									}
+
+									switch (alt15) {
+									case 1 :
+										// org/antlr/grammar/v3/CodeGenTreeWalker.g:384:18: .
+										{
+										matchAny(input); if (state.failed) return;
+										}
+										break;
+
+									default :
+										break loop15;
+									}
+								}
+
+								match(input, Token.UP, null); if (state.failed) return;
+							}
+
+							}
+							break;
+
+					}
+
+
+									if ( input.LA(1) == RULE )
+									{
+										ruleName = ((GrammarAST)input.LT(1)).getChild(0).getText();
+										//System.Diagnostics.Debug.Assert( ruleName == ((GrammarAST)input.LT(1)).enclosingRuleName );
+										generated = grammar.generateMethodForRule(ruleName);
+									}
+								
+					}
+					break;
+
+				default :
+					if ( cnt17 >= 1 ) break loop17;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(17, input);
+					throw eee;
+				}
+				cnt17++;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rules"
+
+
+	public static class rule_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "rule"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:397:1: rule returns [ST code=null] : ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa, null] ( exceptionGroup[$code] )? EOR ) ;
+	public final CodeGenTreeWalker.rule_return rule() throws RecognitionException {
+		CodeGenTreeWalker.rule_return retval = new CodeGenTreeWalker.rule_return();
+		retval.start = input.LT(1);
+
+		GrammarAST id=null;
+		TreeRuleReturnScope mod =null;
+		TreeRuleReturnScope b =null;
+
+
+			String initAction = null;
+			// get the dfa for the BLOCK
+			GrammarAST block2=(GrammarAST)((GrammarAST)retval.start).getFirstChildWithType(BLOCK);
+			org.antlr.analysis.DFA dfa = block2.getLookaheadDFA();
+			// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
+			// for alts of rule
+			blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
+			Rule ruleDescr = grammar.getRule(((GrammarAST)retval.start).getChild(0).getText());
+			currentRuleName = ((GrammarAST)retval.start).getChild(0).getText();
+
+			// For syn preds, we don't want any AST code etc... in there.
+			// Save old templates ptr and restore later.  Base templates include Dbg.
+			STGroup saveGroup = templates;
+			if ( ruleDescr.isSynPred && generator.target.useBaseTemplatesForSynPredFragments() )
+			{
+				templates = generator.getBaseTemplates();
+			}
+
+			String description = "";
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:420:2: ( ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa, null] ( exceptionGroup[$code] )? EOR ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:420:4: ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa, null] ( exceptionGroup[$code] )? EOR )
+			{
+			match(input,RULE,FOLLOW_RULE_in_rule359); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_rule363); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {assert currentRuleName == (id!=null?id.getText():null);}
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:422:4: (mod= modifier )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+			if ( (LA18_0==FRAGMENT||(LA18_0 >= PRIVATE && LA18_0 <= PUBLIC)) ) {
+				alt18=1;
+			}
+			switch (alt18) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:422:5: mod= modifier
+					{
+					pushFollow(FOLLOW_modifier_in_rule376);
+					mod=modifier();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			match(input,ARG,FOLLOW_ARG_in_rule384); if (state.failed) return retval;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return retval;
+				// org/antlr/grammar/v3/CodeGenTreeWalker.g:423:10: ( ARG_ACTION )?
+				int alt19=2;
+				int LA19_0 = input.LA(1);
+				if ( (LA19_0==ARG_ACTION) ) {
+					alt19=1;
+				}
+				switch (alt19) {
+					case 1 :
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:423:11: ARG_ACTION
+						{
+						match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule387); if (state.failed) return retval;
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); if (state.failed) return retval;
+			}
+
+			match(input,RET,FOLLOW_RET_in_rule396); if (state.failed) return retval;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return retval;
+				// org/antlr/grammar/v3/CodeGenTreeWalker.g:424:10: ( ARG_ACTION )?
+				int alt20=2;
+				int LA20_0 = input.LA(1);
+				if ( (LA20_0==ARG_ACTION) ) {
+					alt20=1;
+				}
+				switch (alt20) {
+					case 1 :
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:424:11: ARG_ACTION
+						{
+						match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule399); if (state.failed) return retval;
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); if (state.failed) return retval;
+			}
+
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:425:4: ( throwsSpec )?
+			int alt21=2;
+			int LA21_0 = input.LA(1);
+			if ( (LA21_0==THROWS) ) {
+				alt21=1;
+			}
+			switch (alt21) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:425:5: throwsSpec
+					{
+					pushFollow(FOLLOW_throwsSpec_in_rule408);
+					throwsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:426:4: ( ^( OPTIONS ( . )* ) )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+			if ( (LA23_0==OPTIONS) ) {
+				alt23=1;
+			}
+			switch (alt23) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:426:6: ^( OPTIONS ( . )* )
+					{
+					match(input,OPTIONS,FOLLOW_OPTIONS_in_rule418); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:426:16: ( . )*
+						loop22:
+						while (true) {
+							int alt22=2;
+							int LA22_0 = input.LA(1);
+							if ( ((LA22_0 >= ACTION && LA22_0 <= XDIGIT)) ) {
+								alt22=1;
+							}
+							else if ( (LA22_0==UP) ) {
+								alt22=2;
+							}
+
+							switch (alt22) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:426:16: .
+								{
+								matchAny(input); if (state.failed) return retval;
+								}
+								break;
+
+							default :
+								break loop22;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:427:4: ( ruleScopeSpec )?
+			int alt24=2;
+			int LA24_0 = input.LA(1);
+			if ( (LA24_0==SCOPE) ) {
+				alt24=1;
+			}
+			switch (alt24) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:427:5: ruleScopeSpec
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_rule431);
+					ruleScopeSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:428:4: ( ^( AMPERSAND ( . )* ) )*
+			loop26:
+			while (true) {
+				int alt26=2;
+				int LA26_0 = input.LA(1);
+				if ( (LA26_0==AMPERSAND) ) {
+					alt26=1;
+				}
+
+				switch (alt26) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:428:6: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_rule441); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:428:18: ( . )*
+						loop25:
+						while (true) {
+							int alt25=2;
+							int LA25_0 = input.LA(1);
+							if ( ((LA25_0 >= ACTION && LA25_0 <= XDIGIT)) ) {
+								alt25=1;
+							}
+							else if ( (LA25_0==UP) ) {
+								alt25=2;
+							}
+
+							switch (alt25) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:428:18: .
+								{
+								matchAny(input); if (state.failed) return retval;
+								}
+								break;
+
+							default :
+								break loop25;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+
+				default :
+					break loop26;
+				}
+			}
+
+			pushFollow(FOLLOW_block_in_rule455);
+			b=block("ruleBlock", dfa, null);
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+							description =
+								grammar.grammarTreeToString((GrammarAST)((GrammarAST)retval.start).getFirstChildWithType(BLOCK),
+															false);
+							description =
+								generator.target.getTargetStringLiteralFromString(description);
+							(b!=null?((CodeGenTreeWalker.block_return)b).code:null).add("description", description);
+							// do not generate lexer rules in combined grammar
+							String stName = null;
+							if ( ruleDescr.isSynPred )
+							{
+								stName = "synpredRule";
+							}
+							else if ( grammar.type==Grammar.LEXER )
+							{
+								if ( currentRuleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) )
+								{
+									stName = "tokensRule";
+								}
+								else
+								{
+									stName = "lexerRule";
+								}
+							}
+							else
+							{
+								if ( !(grammar.type==Grammar.COMBINED &&
+									 Rule.getRuleType(currentRuleName) == Grammar.LEXER) )
+								{
+									stName = "rule";
+								}
+							}
+							retval.code = templates.getInstanceOf(stName);
+							if ( retval.code.getName().equals("/rule") )
+							{
+								retval.code.add("emptyRule", grammar.isEmptyRule(block2));
+							}
+							retval.code.add("ruleDescriptor", ruleDescr);
+							String memo = (String)grammar.getBlockOption(((GrammarAST)retval.start),"memoize");
+							if ( memo==null )
+							{
+								memo = (String)grammar.getOption("memoize");
+							}
+							if ( memo!=null && memo.equals("true") &&
+								 (stName.equals("rule")||stName.equals("lexerRule")) )
+							{
+								retval.code.add("memoize", memo!=null && memo.equals("true"));
+							}
+						}
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:480:4: ( exceptionGroup[$code] )?
+			int alt27=2;
+			int LA27_0 = input.LA(1);
+			if ( (LA27_0==CATCH||LA27_0==FINALLY) ) {
+				alt27=1;
+			}
+			switch (alt27) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:480:5: exceptionGroup[$code]
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_rule468);
+					exceptionGroup(retval.code);
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			match(input,EOR,FOLLOW_EOR_in_rule476); if (state.failed) return retval;
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			if ( state.backtracking==0 ) {
+						if ( retval.code!=null )
+						{
+							if ( grammar.type==Grammar.LEXER )
+							{
+								boolean naked =
+									currentRuleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) ||
+									((mod!=null?((GrammarAST)mod.start):null)!=null&&(mod!=null?((GrammarAST)mod.start):null).getText().equals(Grammar.FRAGMENT_RULE_MODIFIER));
+								retval.code.add("nakedBlock", naked);
+							}
+							else
+							{
+								description = grammar.grammarTreeToString(((GrammarAST)retval.start),false);
+								description = generator.target.getTargetStringLiteralFromString(description);
+								retval.code.add("description", description);
+							}
+							Rule theRule = grammar.getRule(currentRuleName);
+							generator.translateActionAttributeReferencesForSingleScope(
+								theRule,
+								theRule.getActions()
+							);
+							retval.code.add("ruleName", currentRuleName);
+							retval.code.add("block", (b!=null?((CodeGenTreeWalker.block_return)b).code:null));
+							if ( initAction!=null )
+							{
+								retval.code.add("initAction", initAction);
+							}
+						}
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+			 templates = saveGroup; 
+		}
+		return retval;
+	}
+	// $ANTLR end "rule"
+
+
+	public static class modifier_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "modifier"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:515:1: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
+	public final CodeGenTreeWalker.modifier_return modifier() throws RecognitionException {
+		CodeGenTreeWalker.modifier_return retval = new CodeGenTreeWalker.modifier_return();
+		retval.start = input.LT(1);
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:516:2: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) ) {
+				input.consume();
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "modifier"
+
+
+
+	// $ANTLR start "throwsSpec"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:522:1: throwsSpec : ^( 'throws' ( ID )+ ) ;
+	public final void throwsSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:523:2: ( ^( 'throws' ( ID )+ ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:523:4: ^( 'throws' ( ID )+ )
+			{
+			match(input,THROWS,FOLLOW_THROWS_in_throwsSpec526); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:523:15: ( ID )+
+			int cnt28=0;
+			loop28:
+			while (true) {
+				int alt28=2;
+				int LA28_0 = input.LA(1);
+				if ( (LA28_0==ID) ) {
+					alt28=1;
+				}
+
+				switch (alt28) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:523:15: ID
+					{
+					match(input,ID,FOLLOW_ID_in_throwsSpec528); if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt28 >= 1 ) break loop28;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(28, input);
+					throw eee;
+				}
+				cnt28++;
+			}
+
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "throwsSpec"
+
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:526:1: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
+	public final void ruleScopeSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:527:2: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:527:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec543); if (state.failed) return;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return;
+				// org/antlr/grammar/v3/CodeGenTreeWalker.g:527:15: ( ^( AMPERSAND ( . )* ) )*
+				loop30:
+				while (true) {
+					int alt30=2;
+					int LA30_0 = input.LA(1);
+					if ( (LA30_0==AMPERSAND) ) {
+						alt30=1;
+					}
+
+					switch (alt30) {
+					case 1 :
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:527:17: ^( AMPERSAND ( . )* )
+						{
+						match(input,AMPERSAND,FOLLOW_AMPERSAND_in_ruleScopeSpec548); if (state.failed) return;
+						if ( input.LA(1)==Token.DOWN ) {
+							match(input, Token.DOWN, null); if (state.failed) return;
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:527:29: ( . )*
+							loop29:
+							while (true) {
+								int alt29=2;
+								int LA29_0 = input.LA(1);
+								if ( ((LA29_0 >= ACTION && LA29_0 <= XDIGIT)) ) {
+									alt29=1;
+								}
+								else if ( (LA29_0==UP) ) {
+									alt29=2;
+								}
+
+								switch (alt29) {
+								case 1 :
+									// org/antlr/grammar/v3/CodeGenTreeWalker.g:527:29: .
+									{
+									matchAny(input); if (state.failed) return;
+									}
+									break;
+
+								default :
+									break loop29;
+								}
+							}
+
+							match(input, Token.UP, null); if (state.failed) return;
+						}
+
+						}
+						break;
+
+					default :
+						break loop30;
+					}
+				}
+
+				// org/antlr/grammar/v3/CodeGenTreeWalker.g:527:36: ( ACTION )?
+				int alt31=2;
+				int LA31_0 = input.LA(1);
+				if ( (LA31_0==ACTION) ) {
+					alt31=1;
+				}
+				switch (alt31) {
+					case 1 :
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:527:37: ACTION
+						{
+						match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec558); if (state.failed) return;
+						}
+						break;
+
+				}
+
+				// org/antlr/grammar/v3/CodeGenTreeWalker.g:527:46: ( ID )*
+				loop32:
+				while (true) {
+					int alt32=2;
+					int LA32_0 = input.LA(1);
+					if ( (LA32_0==ID) ) {
+						alt32=1;
+					}
+
+					switch (alt32) {
+					case 1 :
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:527:48: ID
+						{
+						match(input,ID,FOLLOW_ID_in_ruleScopeSpec564); if (state.failed) return;
+						}
+						break;
+
+					default :
+						break loop32;
+					}
+				}
+
+				match(input, Token.UP, null); if (state.failed) return;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+
+	public static class block_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "block"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:530:1: block[String blockTemplateName, org.antlr.analysis.DFA dfa, GrammarAST label] returns [ST code=null] options {k=1; } : ({...}? => setBlock | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative[$label] rew= rewrite )+ EOB ) );
+	public final CodeGenTreeWalker.block_return block(String blockTemplateName, org.antlr.analysis.DFA dfa, GrammarAST label) throws RecognitionException {
+		CodeGenTreeWalker.block_return retval = new CodeGenTreeWalker.block_return();
+		retval.start = input.LT(1);
+
+		TreeRuleReturnScope alt =null;
+		TreeRuleReturnScope rew =null;
+		TreeRuleReturnScope setBlock1 =null;
+
+
+			int altNum = 0;
+
+			blockNestingLevel++;
+			if ( state.backtracking == 0 )
+			{
+				ST decision = null;
+				if ( dfa != null )
+				{
+					retval.code = templates.getInstanceOf(blockTemplateName);
+					decision = generator.genLookaheadDecision(recognizerST,dfa);
+					retval.code.add("decision", decision);
+					retval.code.add("decisionNumber", dfa.getDecisionNumber());
+					retval.code.add("maxK",dfa.getMaxLookaheadDepth());
+					retval.code.add("maxAlt",dfa.getNumberOfAlts());
+				}
+				else
+				{
+					retval.code = templates.getInstanceOf(blockTemplateName+"SingleAlt");
+				}
+				retval.code.add("blockLevel", blockNestingLevel);
+				retval.code.add("enclosingBlockLevel", blockNestingLevel-1);
+				altNum = 1;
+				if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
+					this.outerAltNum=1;
+				}
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:562:2: ({...}? => setBlock | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative[$label] rew= rewrite )+ EOB ) )
+			int alt36=2;
+			int LA36_0 = input.LA(1);
+			if ( (LA36_0==BLOCK) ) {
+				int LA36_1 = input.LA(2);
+				if ( ((((GrammarAST)retval.start).getSetValue()!=null)) ) {
+					alt36=1;
+				}
+				else if ( (true) ) {
+					alt36=2;
+				}
+
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 36, 0, input);
+				throw nvae;
+			}
+
+			switch (alt36) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:562:4: {...}? => setBlock
+					{
+					if ( !((((GrammarAST)retval.start).getSetValue()!=null)) ) {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						throw new FailedPredicateException(input, "block", "$start.getSetValue()!=null");
+					}
+					pushFollow(FOLLOW_setBlock_in_block605);
+					setBlock1=setBlock();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								retval.code.add("alts",(setBlock1!=null?((CodeGenTreeWalker.setBlock_return)setBlock1).code:null));
+							}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:567:4: ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative[$label] rew= rewrite )+ EOB )
+					{
+					match(input,BLOCK,FOLLOW_BLOCK_in_block618); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:568:4: ( ^( OPTIONS ( . )* ) )?
+					int alt34=2;
+					int LA34_0 = input.LA(1);
+					if ( (LA34_0==OPTIONS) ) {
+						alt34=1;
+					}
+					switch (alt34) {
+						case 1 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:568:6: ^( OPTIONS ( . )* )
+							{
+							match(input,OPTIONS,FOLLOW_OPTIONS_in_block626); if (state.failed) return retval;
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); if (state.failed) return retval;
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:568:16: ( . )*
+								loop33:
+								while (true) {
+									int alt33=2;
+									int LA33_0 = input.LA(1);
+									if ( ((LA33_0 >= ACTION && LA33_0 <= XDIGIT)) ) {
+										alt33=1;
+									}
+									else if ( (LA33_0==UP) ) {
+										alt33=2;
+									}
+
+									switch (alt33) {
+									case 1 :
+										// org/antlr/grammar/v3/CodeGenTreeWalker.g:568:16: .
+										{
+										matchAny(input); if (state.failed) return retval;
+										}
+										break;
+
+									default :
+										break loop33;
+									}
+								}
+
+								match(input, Token.UP, null); if (state.failed) return retval;
+							}
+
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:569:4: (alt= alternative[$label] rew= rewrite )+
+					int cnt35=0;
+					loop35:
+					while (true) {
+						int alt35=2;
+						int LA35_0 = input.LA(1);
+						if ( (LA35_0==ALT) ) {
+							alt35=1;
+						}
+
+						switch (alt35) {
+						case 1 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:569:6: alt= alternative[$label] rew= rewrite
+							{
+							pushFollow(FOLLOW_alternative_in_block643);
+							alt=alternative(label);
+							state._fsp--;
+							if (state.failed) return retval;
+							pushFollow(FOLLOW_rewrite_in_block648);
+							rew=rewrite();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+												if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
+												{
+													this.outerAltNum++;
+												}
+												// add the rewrite code as just another element in the alt :)
+												// (unless it's a " -> ..." rewrite
+												// ( -> ... )
+												GrammarAST firstRewriteAST = (rew!=null?((GrammarAST)rew.start):null).findFirstType(REWRITE);
+												boolean etc =
+													(rew!=null?((GrammarAST)rew.start):null).getType()==REWRITES &&
+													firstRewriteAST.getChild(0)!=null &&
+													firstRewriteAST.getChild(0).getType()==ETC;
+												if ( (rew!=null?((CodeGenTreeWalker.rewrite_return)rew).code:null)!=null && !etc )
+												{
+													(alt!=null?((CodeGenTreeWalker.alternative_return)alt).code:null).add("rew", (rew!=null?((CodeGenTreeWalker.rewrite_return)rew).code:null));
+												}
+												// add this alt to the list of alts for this block
+												retval.code.add("alts",(alt!=null?((CodeGenTreeWalker.alternative_return)alt).code:null));
+												(alt!=null?((CodeGenTreeWalker.alternative_return)alt).code:null).add("altNum", altNum);
+												(alt!=null?((CodeGenTreeWalker.alternative_return)alt).code:null).add("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
+												altNum++;
+											}
+							}
+							break;
+
+						default :
+							if ( cnt35 >= 1 ) break loop35;
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							EarlyExitException eee = new EarlyExitException(35, input);
+							throw eee;
+						}
+						cnt35++;
+					}
+
+					match(input,EOB,FOLLOW_EOB_in_block665); if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+			 blockNestingLevel--; 
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+	public static class setBlock_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "setBlock"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:599:1: setBlock returns [ST code=null] : ^(s= BLOCK ( . )* ) ;
+	public final CodeGenTreeWalker.setBlock_return setBlock() throws RecognitionException {
+		CodeGenTreeWalker.setBlock_return retval = new CodeGenTreeWalker.setBlock_return();
+		retval.start = input.LT(1);
+
+		GrammarAST s=null;
+
+
+			ST setcode = null;
+			if ( state.backtracking == 0 )
+			{
+				if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.buildAST() )
+				{
+					Rule r = grammar.getRule(currentRuleName);
+					currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+					if ( currentAltHasASTRewrite )
+					{
+						r.trackTokenReferenceInAlt(((GrammarAST)retval.start), outerAltNum);
+					}
+				}
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:616:2: ( ^(s= BLOCK ( . )* ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:616:4: ^(s= BLOCK ( . )* )
+			{
+			s=(GrammarAST)match(input,BLOCK,FOLLOW_BLOCK_in_setBlock697); if (state.failed) return retval;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return retval;
+				// org/antlr/grammar/v3/CodeGenTreeWalker.g:616:14: ( . )*
+				loop37:
+				while (true) {
+					int alt37=2;
+					int LA37_0 = input.LA(1);
+					if ( ((LA37_0 >= ACTION && LA37_0 <= XDIGIT)) ) {
+						alt37=1;
+					}
+					else if ( (LA37_0==UP) ) {
+						alt37=2;
+					}
+
+					switch (alt37) {
+					case 1 :
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:616:14: .
+						{
+						matchAny(input); if (state.failed) return retval;
+						}
+						break;
+
+					default :
+						break loop37;
+					}
+				}
+
+				match(input, Token.UP, null); if (state.failed) return retval;
+			}
+
+			if ( state.backtracking==0 ) {
+						int i = ((CommonToken)s.getToken()).getTokenIndex();
+						if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
+						{
+							setcode = getTokenElementST("matchRuleBlockSet", "set", s, null, null);
+						}
+						else
+						{
+							setcode = getTokenElementST("matchSet", "set", s, null, null);
+						}
+						setcode.add("elementIndex", i);
+						//if ( grammar.type!=Grammar.LEXER )
+						//{
+						//	generator.generateLocalFOLLOW(s,"set",currentRuleName,i);
+						//}
+						setcode.add("s",
+							generator.genSetExpr(templates,s.getSetValue(),1,false));
+						ST altcode=templates.getInstanceOf("alt");
+						altcode.addAggr("elements.{el,line,pos}",
+											 setcode,
+											 s.getLine(),
+											 s.getCharPositionInLine() + 1
+											);
+						altcode.add("altNum", 1);
+						altcode.add("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
+						if ( !currentAltHasASTRewrite && grammar.buildAST() )
+						{
+							altcode.add("autoAST", true);
+						}
+						altcode.add("treeLevel", rewriteTreeNestingLevel);
+						retval.code = altcode;
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "setBlock"
+
+
+
+	// $ANTLR start "setAlternative"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:651:1: setAlternative : ^( ALT ( setElement )+ EOA ) ;
+	public final void setAlternative() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:652:2: ( ^( ALT ( setElement )+ EOA ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:652:4: ^( ALT ( setElement )+ EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_setAlternative717); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:652:10: ( setElement )+
+			int cnt38=0;
+			loop38:
+			while (true) {
+				int alt38=2;
+				int LA38_0 = input.LA(1);
+				if ( ((LA38_0 >= CHAR_LITERAL && LA38_0 <= CHAR_RANGE)||LA38_0==STRING_LITERAL||LA38_0==TOKEN_REF) ) {
+					alt38=1;
+				}
+
+				switch (alt38) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:652:10: setElement
+					{
+					pushFollow(FOLLOW_setElement_in_setAlternative719);
+					setElement();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt38 >= 1 ) break loop38;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(38, input);
+					throw eee;
+				}
+				cnt38++;
+			}
+
+			match(input,EOA,FOLLOW_EOA_in_setAlternative722); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "setAlternative"
+
+
+
+	// $ANTLR start "exceptionGroup"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:655:1: exceptionGroup[ST ruleST] : ( ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )? | finallyClause[$ruleST] );
+	public final void exceptionGroup(ST ruleST) throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:656:2: ( ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )? | finallyClause[$ruleST] )
+			int alt41=2;
+			int LA41_0 = input.LA(1);
+			if ( (LA41_0==CATCH) ) {
+				alt41=1;
+			}
+			else if ( (LA41_0==FINALLY) ) {
+				alt41=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 41, 0, input);
+				throw nvae;
+			}
+
+			switch (alt41) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:656:4: ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )?
+					{
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:656:4: ( exceptionHandler[$ruleST] )+
+					int cnt39=0;
+					loop39:
+					while (true) {
+						int alt39=2;
+						int LA39_0 = input.LA(1);
+						if ( (LA39_0==CATCH) ) {
+							alt39=1;
+						}
+
+						switch (alt39) {
+						case 1 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:656:6: exceptionHandler[$ruleST]
+							{
+							pushFollow(FOLLOW_exceptionHandler_in_exceptionGroup737);
+							exceptionHandler(ruleST);
+							state._fsp--;
+							if (state.failed) return;
+							}
+							break;
+
+						default :
+							if ( cnt39 >= 1 ) break loop39;
+							if (state.backtracking>0) {state.failed=true; return;}
+							EarlyExitException eee = new EarlyExitException(39, input);
+							throw eee;
+						}
+						cnt39++;
+					}
+
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:656:35: ( finallyClause[$ruleST] )?
+					int alt40=2;
+					int LA40_0 = input.LA(1);
+					if ( (LA40_0==FINALLY) ) {
+						alt40=1;
+					}
+					switch (alt40) {
+						case 1 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:656:36: finallyClause[$ruleST]
+							{
+							pushFollow(FOLLOW_finallyClause_in_exceptionGroup744);
+							finallyClause(ruleST);
+							state._fsp--;
+							if (state.failed) return;
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:657:4: finallyClause[$ruleST]
+					{
+					pushFollow(FOLLOW_finallyClause_in_exceptionGroup752);
+					finallyClause(ruleST);
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+
+	// $ANTLR start "exceptionHandler"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:660:1: exceptionHandler[ST ruleST] : ^( 'catch' ARG_ACTION ACTION ) ;
+	public final void exceptionHandler(ST ruleST) throws RecognitionException {
+		GrammarAST ACTION2=null;
+		GrammarAST ARG_ACTION3=null;
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:661:2: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:661:4: ^( 'catch' ARG_ACTION ACTION )
+			{
+			match(input,CATCH,FOLLOW_CATCH_in_exceptionHandler766); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			ARG_ACTION3=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_exceptionHandler768); if (state.failed) return;
+			ACTION2=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_exceptionHandler770); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {
+						List<? extends Object> chunks = generator.translateAction(currentRuleName,ACTION2);
+						ruleST.addAggr("exceptions.{decl,action}",(ARG_ACTION3!=null?ARG_ACTION3.getText():null),chunks);
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+
+	// $ANTLR start "finallyClause"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:668:1: finallyClause[ST ruleST] : ^( 'finally' ACTION ) ;
+	public final void finallyClause(ST ruleST) throws RecognitionException {
+		GrammarAST ACTION4=null;
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:669:2: ( ^( 'finally' ACTION ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:669:4: ^( 'finally' ACTION )
+			{
+			match(input,FINALLY,FOLLOW_FINALLY_in_finallyClause788); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			ACTION4=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_finallyClause790); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {
+						List<? extends Object> chunks = generator.translateAction(currentRuleName,ACTION4);
+						ruleST.add("finally",chunks);
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "finallyClause"
+
+
+	public static class alternative_return extends TreeRuleReturnScope {
+		public ST code;
+	};
+
+
+	// $ANTLR start "alternative"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:676:1: alternative[GrammarAST label] returns [ST code] : ^(a= ALT (e= element[$label,null] )+ EOA ) ;
+	public final CodeGenTreeWalker.alternative_return alternative(GrammarAST label) throws RecognitionException {
+		CodeGenTreeWalker.alternative_return retval = new CodeGenTreeWalker.alternative_return();
+		retval.start = input.LT(1);
+
+		GrammarAST a=null;
+		TreeRuleReturnScope e =null;
+
+
+			if ( state.backtracking == 0 )
+			{
+				retval.code = templates.getInstanceOf("alt");
+				if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.buildAST() )
+				{
+					Rule r = grammar.getRule(currentRuleName);
+					currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+				}
+				String description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+				description = generator.target.getTargetStringLiteralFromString(description);
+				retval.code.add("description", description);
+				retval.code.add("treeLevel", rewriteTreeNestingLevel);
+				if ( !currentAltHasASTRewrite && grammar.buildAST() )
+				{
+					retval.code.add("autoAST", true);
+				}
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:697:2: ( ^(a= ALT (e= element[$label,null] )+ EOA ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:697:4: ^(a= ALT (e= element[$label,null] )+ EOA )
+			{
+			a=(GrammarAST)match(input,ALT,FOLLOW_ALT_in_alternative820); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:698:4: (e= element[$label,null] )+
+			int cnt42=0;
+			loop42:
+			while (true) {
+				int alt42=2;
+				int LA42_0 = input.LA(1);
+				if ( (LA42_0==ACTION||(LA42_0 >= ASSIGN && LA42_0 <= BLOCK)||(LA42_0 >= CHAR_LITERAL && LA42_0 <= CHAR_RANGE)||LA42_0==CLOSURE||LA42_0==DOT||LA42_0==EPSILON||LA42_0==FORCED_ACTION||LA42_0==GATED_SEMPRED||LA42_0==NOT||LA42_0==OPTIONAL||(LA42_0 >= PLUS_ASSIGN && LA42_0 <= POSITIVE_CLOSURE)||LA42_0==ROOT||LA42_0==RULE_REF||LA42_0==SEMPRED||(LA42_0 >= STRING_LITERAL && LA42_0 <= SYN_SEMPRED)||LA42_0==TOKEN_REF||LA42_0==TREE_BEGIN||LA42_0==WILDCARD) ) {
+					alt42=1;
+				}
+
+				switch (alt42) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:699:5: e= element[$label,null]
+					{
+					pushFollow(FOLLOW_element_in_alternative833);
+					e=element(label, null);
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+										if ((e!=null?((CodeGenTreeWalker.element_return)e).code:null) != null)
+										{
+											retval.code.addAggr("elements.{el,line,pos}",
+															  (e!=null?((CodeGenTreeWalker.element_return)e).code:null),
+															  (e!=null?((GrammarAST)e.start):null).getLine(),
+															  (e!=null?((GrammarAST)e.start):null).getCharPositionInLine() + 1
+															 );
+										}
+									}
+					}
+					break;
+
+				default :
+					if ( cnt42 >= 1 ) break loop42;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(42, input);
+					throw eee;
+				}
+				cnt42++;
+			}
+
+			match(input,EOA,FOLLOW_EOA_in_alternative851); if (state.failed) return retval;
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "alternative"
+
+
+	public static class element_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "element"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:715:1: element[GrammarAST label, GrammarAST astSuffix] returns [ST code=null] options {k=1; } : ( ^( ROOT e= element[$label,$ROOT] ) | ^( BANG e= element[$label,$BANG] ) | ^(n= NOT ne= notElement[$n, $label, $astSuffix] ) | ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] ) | ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] ) | ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL ) | ({...}? ( BLOCK | OPTIONAL | CLOSURE | POSITIVE_CLOSURE ) )=> ebnf[$label] | atom[null, $label, $astSuffix] | tree_ | element_action | (sp= SEMPRED |sp= GATED_SEMPRED ) | SYN_SEMPRED | ^( SYNPRED ( . )* ) | ^( BACKTRACK_SEMPRED ( . )* ) | EPSILON );
+	public final CodeGenTreeWalker.element_return element(GrammarAST label, GrammarAST astSuffix) throws RecognitionException {
+		CodeGenTreeWalker.element_return retval = new CodeGenTreeWalker.element_return();
+		retval.start = input.LT(1);
+
+		GrammarAST n=null;
+		GrammarAST alabel=null;
+		GrammarAST label2=null;
+		GrammarAST a=null;
+		GrammarAST b=null;
+		GrammarAST sp=null;
+		GrammarAST ROOT5=null;
+		GrammarAST BANG6=null;
+		TreeRuleReturnScope e =null;
+		ST ne =null;
+		TreeRuleReturnScope ebnf7 =null;
+		TreeRuleReturnScope atom8 =null;
+		TreeRuleReturnScope tree_9 =null;
+		TreeRuleReturnScope element_action10 =null;
+
+
+			IntSet elements=null;
+			GrammarAST ast = null;
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:722:2: ( ^( ROOT e= element[$label,$ROOT] ) | ^( BANG e= element[$label,$BANG] ) | ^(n= NOT ne= notElement[$n, $label, $astSuffix] ) | ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] ) | ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] ) | ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL ) | ({...}? ( BLOCK | OPTIONAL | CLOSURE | POSITIVE_CLOSURE ) )=> ebnf[$label] | atom[null, $label, $astSuffix] | tree_ | element_action | (sp= SEMPRED |sp= GATED_SEMPRED ) | SYN_SEMPRED | ^( SYNPRED ( . )* ) | ^( BACKTRACK_SEMPRED ( . )* ) | EPSILON )
+			int alt46=15;
+			int LA46_0 = input.LA(1);
+			if ( (LA46_0==ROOT) ) {
+				alt46=1;
+			}
+			else if ( (LA46_0==BANG) ) {
+				alt46=2;
+			}
+			else if ( (LA46_0==NOT) ) {
+				alt46=3;
+			}
+			else if ( (LA46_0==ASSIGN) ) {
+				alt46=4;
+			}
+			else if ( (LA46_0==PLUS_ASSIGN) ) {
+				alt46=5;
+			}
+			else if ( (LA46_0==CHAR_RANGE) ) {
+				alt46=6;
+			}
+			else if ( (LA46_0==BLOCK) ) {
+				int LA46_7 = input.LA(2);
+				if ( (synpred1_CodeGenTreeWalker()) ) {
+					alt46=7;
+				}
+				else if ( (true) ) {
+					alt46=8;
+				}
+
+			}
+			else if ( (LA46_0==OPTIONAL) && (synpred1_CodeGenTreeWalker())) {
+				alt46=7;
+			}
+			else if ( (LA46_0==CLOSURE) && (synpred1_CodeGenTreeWalker())) {
+				alt46=7;
+			}
+			else if ( (LA46_0==POSITIVE_CLOSURE) && (synpred1_CodeGenTreeWalker())) {
+				alt46=7;
+			}
+			else if ( (LA46_0==CHAR_LITERAL||LA46_0==DOT||LA46_0==RULE_REF||LA46_0==STRING_LITERAL||LA46_0==TOKEN_REF||LA46_0==WILDCARD) ) {
+				alt46=8;
+			}
+			else if ( (LA46_0==TREE_BEGIN) ) {
+				alt46=9;
+			}
+			else if ( (LA46_0==ACTION||LA46_0==FORCED_ACTION) ) {
+				alt46=10;
+			}
+			else if ( (LA46_0==GATED_SEMPRED||LA46_0==SEMPRED) ) {
+				alt46=11;
+			}
+			else if ( (LA46_0==SYN_SEMPRED) ) {
+				alt46=12;
+			}
+			else if ( (LA46_0==SYNPRED) ) {
+				alt46=13;
+			}
+			else if ( (LA46_0==BACKTRACK_SEMPRED) ) {
+				alt46=14;
+			}
+			else if ( (LA46_0==EPSILON) ) {
+				alt46=15;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 46, 0, input);
+				throw nvae;
+			}
+
+			switch (alt46) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:722:4: ^( ROOT e= element[$label,$ROOT] )
+					{
+					ROOT5=(GrammarAST)match(input,ROOT,FOLLOW_ROOT_in_element886); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element890);
+					e=element(label, ROOT5);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = (e!=null?((CodeGenTreeWalker.element_return)e).code:null); }
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:725:4: ^( BANG e= element[$label,$BANG] )
+					{
+					BANG6=(GrammarAST)match(input,BANG,FOLLOW_BANG_in_element903); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element907);
+					e=element(label, BANG6);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = (e!=null?((CodeGenTreeWalker.element_return)e).code:null); }
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:728:4: ^(n= NOT ne= notElement[$n, $label, $astSuffix] )
+					{
+					n=(GrammarAST)match(input,NOT,FOLLOW_NOT_in_element923); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_notElement_in_element927);
+					ne=notElement(n, label, astSuffix);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = ne; }
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:731:4: ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_element942); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					alabel=(GrammarAST)match(input,ID,FOLLOW_ID_in_element946); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element950);
+					e=element(alabel, astSuffix);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = (e!=null?((CodeGenTreeWalker.element_return)e).code:null); }
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:734:4: ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] )
+					{
+					match(input,PLUS_ASSIGN,FOLLOW_PLUS_ASSIGN_in_element965); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					label2=(GrammarAST)match(input,ID,FOLLOW_ID_in_element969); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element973);
+					e=element(label2, astSuffix);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = (e!=null?((CodeGenTreeWalker.element_return)e).code:null); }
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:737:4: ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL )
+					{
+					match(input,CHAR_RANGE,FOLLOW_CHAR_RANGE_in_element987); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					a=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_element991); if (state.failed) return retval;
+					b=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_element995); if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) {
+								retval.code = templates.getInstanceOf("charRangeRef");
+								String low = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,(a!=null?a.getText():null));
+								String high = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,(b!=null?b.getText():null));
+								retval.code.add("a", low);
+								retval.code.add("b", high);
+								if ( label!=null )
+								{
+									retval.code.add("label", label.getText());
+								}
+							}
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:750:4: ({...}? ( BLOCK | OPTIONAL | CLOSURE | POSITIVE_CLOSURE ) )=> ebnf[$label]
+					{
+					pushFollow(FOLLOW_ebnf_in_element1024);
+					ebnf7=ebnf(label);
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) { retval.code = (ebnf7!=null?((CodeGenTreeWalker.ebnf_return)ebnf7).code:null); }
+					}
+					break;
+				case 8 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:753:4: atom[null, $label, $astSuffix]
+					{
+					pushFollow(FOLLOW_atom_in_element1035);
+					atom8=atom(null, label, astSuffix);
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) { retval.code = (atom8!=null?((CodeGenTreeWalker.atom_return)atom8).code:null); }
+					}
+					break;
+				case 9 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:756:4: tree_
+					{
+					pushFollow(FOLLOW_tree__in_element1046);
+					tree_9=tree_();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) { retval.code = (tree_9!=null?((CodeGenTreeWalker.tree__return)tree_9).code:null); }
+					}
+					break;
+				case 10 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:759:4: element_action
+					{
+					pushFollow(FOLLOW_element_action_in_element1056);
+					element_action10=element_action();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) { retval.code = (element_action10!=null?((CodeGenTreeWalker.element_action_return)element_action10).code:null); }
+					}
+					break;
+				case 11 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:762:6: (sp= SEMPRED |sp= GATED_SEMPRED )
+					{
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:762:6: (sp= SEMPRED |sp= GATED_SEMPRED )
+					int alt43=2;
+					int LA43_0 = input.LA(1);
+					if ( (LA43_0==SEMPRED) ) {
+						alt43=1;
+					}
+					else if ( (LA43_0==GATED_SEMPRED) ) {
+						alt43=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 43, 0, input);
+						throw nvae;
+					}
+
+					switch (alt43) {
+						case 1 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:762:7: sp= SEMPRED
+							{
+							sp=(GrammarAST)match(input,SEMPRED,FOLLOW_SEMPRED_in_element1071); if (state.failed) return retval;
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:762:18: sp= GATED_SEMPRED
+							{
+							sp=(GrammarAST)match(input,GATED_SEMPRED,FOLLOW_GATED_SEMPRED_in_element1075); if (state.failed) return retval;
+							}
+							break;
+
+					}
+
+					if ( state.backtracking==0 ) {
+								retval.code = templates.getInstanceOf("validateSemanticPredicate");
+								retval.code.add("pred", generator.translateAction(currentRuleName,sp));
+								String description = generator.target.getTargetStringLiteralFromString((sp!=null?sp.getText():null));
+								retval.code.add("description", description);
+							}
+					}
+					break;
+				case 12 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:770:4: SYN_SEMPRED
+					{
+					match(input,SYN_SEMPRED,FOLLOW_SYN_SEMPRED_in_element1086); if (state.failed) return retval;
+					}
+					break;
+				case 13 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:772:4: ^( SYNPRED ( . )* )
+					{
+					match(input,SYNPRED,FOLLOW_SYNPRED_in_element1094); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:772:14: ( . )*
+						loop44:
+						while (true) {
+							int alt44=2;
+							int LA44_0 = input.LA(1);
+							if ( ((LA44_0 >= ACTION && LA44_0 <= XDIGIT)) ) {
+								alt44=1;
+							}
+							else if ( (LA44_0==UP) ) {
+								alt44=2;
+							}
+
+							switch (alt44) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:772:14: .
+								{
+								matchAny(input); if (state.failed) return retval;
+								}
+								break;
+
+							default :
+								break loop44;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+				case 14 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:774:4: ^( BACKTRACK_SEMPRED ( . )* )
+					{
+					match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_element1105); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:774:24: ( . )*
+						loop45:
+						while (true) {
+							int alt45=2;
+							int LA45_0 = input.LA(1);
+							if ( ((LA45_0 >= ACTION && LA45_0 <= XDIGIT)) ) {
+								alt45=1;
+							}
+							else if ( (LA45_0==UP) ) {
+								alt45=2;
+							}
+
+							switch (alt45) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:774:24: .
+								{
+								matchAny(input); if (state.failed) return retval;
+								}
+								break;
+
+							default :
+								break loop45;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+				case 15 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:776:6: EPSILON
+					{
+					match(input,EPSILON,FOLLOW_EPSILON_in_element1117); if (state.failed) return retval;
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "element"
+
+
+	public static class element_action_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "element_action"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:779:1: element_action returns [ST code=null] : (act= ACTION |act2= FORCED_ACTION );
+	public final CodeGenTreeWalker.element_action_return element_action() throws RecognitionException {
+		CodeGenTreeWalker.element_action_return retval = new CodeGenTreeWalker.element_action_return();
+		retval.start = input.LT(1);
+
+		GrammarAST act=null;
+		GrammarAST act2=null;
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:780:2: (act= ACTION |act2= FORCED_ACTION )
+			int alt47=2;
+			int LA47_0 = input.LA(1);
+			if ( (LA47_0==ACTION) ) {
+				alt47=1;
+			}
+			else if ( (LA47_0==FORCED_ACTION) ) {
+				alt47=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 47, 0, input);
+				throw nvae;
+			}
+
+			switch (alt47) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:780:4: act= ACTION
+					{
+					act=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_element_action1134); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								retval.code = templates.getInstanceOf("execAction");
+								retval.code.add("action", generator.translateAction(currentRuleName,act));
+							}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:785:4: act2= FORCED_ACTION
+					{
+					act2=(GrammarAST)match(input,FORCED_ACTION,FOLLOW_FORCED_ACTION_in_element_action1145); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								retval.code = templates.getInstanceOf("execForcedAction");
+								retval.code.add("action", generator.translateAction(currentRuleName,act2));
+							}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "element_action"
+
+
+
+	// $ANTLR start "notElement"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:792:1: notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [ST code=null] : (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) ) ;
+	public final ST notElement(GrammarAST n, GrammarAST label, GrammarAST astSuffix) throws RecognitionException {
+		ST code = null;
+
+
+		GrammarAST assign_c=null;
+		GrammarAST assign_s=null;
+		GrammarAST assign_t=null;
+		GrammarAST assign_st=null;
+
+
+			IntSet elements=null;
+			String labelText = null;
+			if ( label!=null )
+			{
+				labelText = label.getText();
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:802:2: ( (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:802:4: (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) )
+			{
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:802:4: (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) )
+			int alt49=4;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				alt49=1;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt49=2;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt49=3;
+				}
+				break;
+			case BLOCK:
+				{
+				alt49=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return code;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 49, 0, input);
+				throw nvae;
+			}
+			switch (alt49) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:802:6: assign_c= CHAR_LITERAL
+					{
+					assign_c=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_notElement1174); if (state.failed) return code;
+					if ( state.backtracking==0 ) {
+									int ttype=0;
+									if ( grammar.type==Grammar.LEXER )
+									{
+										ttype = Grammar.getCharValueFromGrammarCharLiteral((assign_c!=null?assign_c.getText():null));
+									}
+									else
+									{
+										ttype = grammar.getTokenType((assign_c!=null?assign_c.getText():null));
+									}
+									elements = grammar.complement(ttype);
+								}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:815:5: assign_s= STRING_LITERAL
+					{
+					assign_s=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_notElement1187); if (state.failed) return code;
+					if ( state.backtracking==0 ) {
+									int ttype=0;
+									if ( grammar.type==Grammar.LEXER )
+									{
+										// TODO: error!
+									}
+									else
+									{
+										ttype = grammar.getTokenType((assign_s!=null?assign_s.getText():null));
+									}
+									elements = grammar.complement(ttype);
+								}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:828:5: assign_t= TOKEN_REF
+					{
+					assign_t=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_notElement1200); if (state.failed) return code;
+					if ( state.backtracking==0 ) {
+									int ttype = grammar.getTokenType((assign_t!=null?assign_t.getText():null));
+									elements = grammar.complement(ttype);
+								}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:833:5: ^(assign_st= BLOCK ( . )* )
+					{
+					assign_st=(GrammarAST)match(input,BLOCK,FOLLOW_BLOCK_in_notElement1214); if (state.failed) return code;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return code;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:833:23: ( . )*
+						loop48:
+						while (true) {
+							int alt48=2;
+							int LA48_0 = input.LA(1);
+							if ( ((LA48_0 >= ACTION && LA48_0 <= XDIGIT)) ) {
+								alt48=1;
+							}
+							else if ( (LA48_0==UP) ) {
+								alt48=2;
+							}
+
+							switch (alt48) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:833:23: .
+								{
+								matchAny(input); if (state.failed) return code;
+								}
+								break;
+
+							default :
+								break loop48;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return code;
+					}
+
+					if ( state.backtracking==0 ) {
+									elements = assign_st.getSetValue();
+									elements = grammar.complement(elements);
+								}
+					}
+					break;
+
+			}
+
+			if ( state.backtracking==0 ) {
+						code = getTokenElementST("matchSet",
+												 "set",
+												 (GrammarAST)n.getChild(0),
+												 astSuffix,
+												 labelText);
+						code.add("s",generator.genSetExpr(templates,elements,1,false));
+						int i = ((CommonToken)n.getToken()).getTokenIndex();
+						code.add("elementIndex", i);
+						if ( grammar.type!=Grammar.LEXER )
+						{
+							generator.generateLocalFOLLOW(n,"set",currentRuleName,i);
+						}
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return code;
+	}
+	// $ANTLR end "notElement"
+
+
+	public static class ebnf_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "ebnf"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:855:1: ebnf[GrammarAST label] returns [ST code=null] : (blk= block[\"block\", dfa, $label] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa, $label] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa, $label] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa, $label] ) ) ;
+	public final CodeGenTreeWalker.ebnf_return ebnf(GrammarAST label) throws RecognitionException {
+		CodeGenTreeWalker.ebnf_return retval = new CodeGenTreeWalker.ebnf_return();
+		retval.start = input.LT(1);
+
+		TreeRuleReturnScope blk =null;
+
+
+			org.antlr.analysis.DFA dfa=null;
+			GrammarAST b = (GrammarAST)((GrammarAST)retval.start).getChild(0);
+			GrammarAST eob = b.getLastChild(); // loops will use EOB DFA
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:862:2: ( (blk= block[\"block\", dfa, $label] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa, $label] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa, $label] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa, $label] ) ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:862:4: (blk= block[\"block\", dfa, $label] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa, $label] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa, $label] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa, $label] ) )
+			{
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:862:4: (blk= block[\"block\", dfa, $label] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa, $label] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa, $label] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa, $label] ) )
+			int alt50=4;
+			switch ( input.LA(1) ) {
+			case BLOCK:
+				{
+				alt50=1;
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt50=2;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt50=3;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt50=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 50, 0, input);
+				throw nvae;
+			}
+			switch (alt50) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:862:6: blk= block[\"block\", dfa, $label]
+					{
+					if ( state.backtracking==0 ) { dfa = ((GrammarAST)retval.start).getLookaheadDFA(); }
+					pushFollow(FOLLOW_block_in_ebnf1261);
+					blk=block("block", dfa, label);
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) { retval.code = (blk!=null?((CodeGenTreeWalker.block_return)blk).code:null); }
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:865:5: ^( OPTIONAL blk= block[\"optionalBlock\", dfa, $label] )
+					{
+					if ( state.backtracking==0 ) { dfa = ((GrammarAST)retval.start).getLookaheadDFA(); }
+					match(input,OPTIONAL,FOLLOW_OPTIONAL_in_ebnf1280); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_block_in_ebnf1284);
+					blk=block("optionalBlock", dfa, label);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = (blk!=null?((CodeGenTreeWalker.block_return)blk).code:null); }
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:868:5: ^( CLOSURE blk= block[\"closureBlock\", dfa, $label] )
+					{
+					if ( state.backtracking==0 ) { dfa = eob.getLookaheadDFA(); }
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_ebnf1305); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_block_in_ebnf1309);
+					blk=block("closureBlock", dfa, label);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = (blk!=null?((CodeGenTreeWalker.block_return)blk).code:null); }
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:871:5: ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa, $label] )
+					{
+					if ( state.backtracking==0 ) { dfa = eob.getLookaheadDFA(); }
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_ebnf1330); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_block_in_ebnf1334);
+					blk=block("positiveClosureBlock", dfa, label);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = (blk!=null?((CodeGenTreeWalker.block_return)blk).code:null); }
+					}
+					break;
+
+			}
+
+			if ( state.backtracking==0 ) {
+						String description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+						description = generator.target.getTargetStringLiteralFromString(description);
+						retval.code.add("description", description);
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ebnf"
+
+
+	public static class tree__return extends TreeRuleReturnScope {
+		public ST code;
+	};
+
+
+	// $ANTLR start "tree_"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:882:1: tree_ returns [ST code] : ^( TREE_BEGIN el= element[null,rootSuffix] ( ( element_action )=>act= element_action )* (el= element[null,null] )* ) ;
+	public final CodeGenTreeWalker.tree__return tree_() throws RecognitionException {
+		CodeGenTreeWalker.tree__return retval = new CodeGenTreeWalker.tree__return();
+		retval.start = input.LT(1);
+
+		TreeRuleReturnScope el =null;
+		TreeRuleReturnScope act =null;
+
+
+			rewriteTreeNestingLevel++;
+			GrammarAST rootSuffix = null;
+			if ( state.backtracking == 0 )
+			{
+				retval.code = templates.getInstanceOf("tree");
+				NFAState afterDOWN = (NFAState)((GrammarAST)retval.start).NFATreeDownState.transition(0).target;
+				LookaheadSet s = grammar.LOOK(afterDOWN);
+				if ( s.member(Label.UP) ) {
+					// nullable child list if we can see the UP as the next token
+					// we need an "if ( input.LA(1)==Token.DOWN )" gate around
+					// the child list.
+					retval.code.add("nullableChildList", "true");
+				}
+				retval.code.add("enclosingTreeLevel", rewriteTreeNestingLevel-1);
+				retval.code.add("treeLevel", rewriteTreeNestingLevel);
+				Rule r = grammar.getRule(currentRuleName);
+				if ( grammar.buildAST() && !r.hasRewrite(outerAltNum) ) {
+					rootSuffix = new GrammarAST(ROOT,"ROOT");
+				}
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:906:2: ( ^( TREE_BEGIN el= element[null,rootSuffix] ( ( element_action )=>act= element_action )* (el= element[null,null] )* ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:906:4: ^( TREE_BEGIN el= element[null,rootSuffix] ( ( element_action )=>act= element_action )* (el= element[null,null] )* )
+			{
+			match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_tree_1372); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			pushFollow(FOLLOW_element_in_tree_1379);
+			el=element(null, rootSuffix);
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+							retval.code.addAggr("root.{el,line,pos}",
+											  (el!=null?((CodeGenTreeWalker.element_return)el).code:null),
+											  (el!=null?((GrammarAST)el.start):null).getLine(),
+											  (el!=null?((GrammarAST)el.start):null).getCharPositionInLine() + 1
+											  );
+						}
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:918:4: ( ( element_action )=>act= element_action )*
+			loop51:
+			while (true) {
+				int alt51=2;
+				int LA51_0 = input.LA(1);
+				if ( (LA51_0==ACTION) ) {
+					int LA51_2 = input.LA(2);
+					if ( (synpred2_CodeGenTreeWalker()) ) {
+						alt51=1;
+					}
+
+				}
+				else if ( (LA51_0==FORCED_ACTION) ) {
+					int LA51_3 = input.LA(2);
+					if ( (synpred2_CodeGenTreeWalker()) ) {
+						alt51=1;
+					}
+
+				}
+
+				switch (alt51) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:918:6: ( element_action )=>act= element_action
+					{
+					pushFollow(FOLLOW_element_action_in_tree_1416);
+					act=element_action();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+										retval.code.addAggr("actionsAfterRoot.{el,line,pos}",
+														  (act!=null?((CodeGenTreeWalker.element_action_return)act).code:null),
+														  (act!=null?((GrammarAST)act.start):null).getLine(),
+														  (act!=null?((GrammarAST)act.start):null).getCharPositionInLine() + 1
+														);
+									}
+					}
+					break;
+
+				default :
+					break loop51;
+				}
+			}
+
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:928:4: (el= element[null,null] )*
+			loop52:
+			while (true) {
+				int alt52=2;
+				int LA52_0 = input.LA(1);
+				if ( (LA52_0==ACTION||(LA52_0 >= ASSIGN && LA52_0 <= BLOCK)||(LA52_0 >= CHAR_LITERAL && LA52_0 <= CHAR_RANGE)||LA52_0==CLOSURE||LA52_0==DOT||LA52_0==EPSILON||LA52_0==FORCED_ACTION||LA52_0==GATED_SEMPRED||LA52_0==NOT||LA52_0==OPTIONAL||(LA52_0 >= PLUS_ASSIGN && LA52_0 <= POSITIVE_CLOSURE)||LA52_0==ROOT||LA52_0==RULE_REF||LA52_0==SEMPRED||(LA52_0 >= STRING_LITERAL && LA52_0 <= SYN_SEMPRED)||LA52_0==TOKEN_REF||LA52_0==TREE_BEGIN||LA52_0==WILDCARD) ) {
+					alt52=1;
+				}
+
+				switch (alt52) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:928:7: el= element[null,null]
+					{
+					pushFollow(FOLLOW_element_in_tree_1438);
+					el=element(null, null);
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+									 retval.code.addAggr("children.{el,line,pos}",
+													  (el!=null?((CodeGenTreeWalker.element_return)el).code:null),
+													  (el!=null?((GrammarAST)el.start):null).getLine(),
+													  (el!=null?((GrammarAST)el.start):null).getCharPositionInLine() + 1
+													  );
+									 }
+					}
+					break;
+
+				default :
+					break loop52;
+				}
+			}
+
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+			 rewriteTreeNestingLevel--; 
+		}
+		return retval;
+	}
+	// $ANTLR end "tree_"
+
+
+	public static class atom_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "atom"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:941:1: atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix] returns [ST code=null] : ( ^(r= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL |w= WILDCARD | ^( DOT ID a= atom[$ID, label, astSuffix] ) | set[label,astSuffix] );
+	public final CodeGenTreeWalker.atom_return atom(GrammarAST scope, GrammarAST label, GrammarAST astSuffix) throws RecognitionException {
+		CodeGenTreeWalker.atom_return retval = new CodeGenTreeWalker.atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST r=null;
+		GrammarAST rarg=null;
+		GrammarAST t=null;
+		GrammarAST targ=null;
+		GrammarAST c=null;
+		GrammarAST s=null;
+		GrammarAST w=null;
+		GrammarAST ID11=null;
+		TreeRuleReturnScope a =null;
+		ST set12 =null;
+
+
+			String labelText=null;
+			if ( state.backtracking == 0 )
+			{
+				if ( label!=null )
+				{
+					labelText = label.getText();
+				}
+				if ( grammar.type!=Grammar.LEXER &&
+					 (((GrammarAST)retval.start).getType()==RULE_REF||((GrammarAST)retval.start).getType()==TOKEN_REF||
+					  ((GrammarAST)retval.start).getType()==CHAR_LITERAL||((GrammarAST)retval.start).getType()==STRING_LITERAL) )
+				{
+					Rule encRule = grammar.getRule(((GrammarAST)retval.start).enclosingRuleName);
+					if ( encRule!=null && encRule.hasRewrite(outerAltNum) && astSuffix!=null )
+					{
+						ErrorManager.grammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
+												  grammar,
+												  ((GrammarAST)retval.start).getToken(),
+												  ((GrammarAST)retval.start).enclosingRuleName,
+												  outerAltNum);
+						astSuffix = null;
+					}
+				}
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:969:2: ( ^(r= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL |w= WILDCARD | ^( DOT ID a= atom[$ID, label, astSuffix] ) | set[label,astSuffix] )
+			int alt55=7;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+				{
+				alt55=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt55=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt55=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt55=4;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt55=5;
+				}
+				break;
+			case DOT:
+				{
+				alt55=6;
+				}
+				break;
+			case BLOCK:
+				{
+				alt55=7;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 55, 0, input);
+				throw nvae;
+			}
+			switch (alt55) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:969:6: ^(r= RULE_REF (rarg= ARG_ACTION )? )
+					{
+					r=(GrammarAST)match(input,RULE_REF,FOLLOW_RULE_REF_in_atom1488); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:969:20: (rarg= ARG_ACTION )?
+						int alt53=2;
+						int LA53_0 = input.LA(1);
+						if ( (LA53_0==ARG_ACTION) ) {
+							alt53=1;
+						}
+						switch (alt53) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:969:21: rarg= ARG_ACTION
+								{
+								rarg=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1493); if (state.failed) return retval;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					if ( state.backtracking==0 ) {
+								grammar.checkRuleReference(scope, r, rarg, currentRuleName);
+								String scopeName = null;
+								if ( scope!=null ) {
+									scopeName = scope.getText();
+								}
+								Rule rdef = grammar.getRule(scopeName, (r!=null?r.getText():null));
+								// don't insert label=r() if label.attr not used, no ret value, ...
+								if ( !rdef.getHasReturnValue() ) {
+									labelText = null;
+								}
+								retval.code = getRuleElementST("ruleRef", (r!=null?r.getText():null), r, astSuffix, labelText);
+								retval.code.add("rule", rdef);
+								if ( scope!=null ) { // scoped rule ref
+									Grammar scopeG = grammar.composite.getGrammar(scope.getText());
+									retval.code.add("scope", scopeG);
+								}
+								else if ( rdef.grammar != this.grammar ) { // nonlocal
+									// if rule definition is not in this grammar, it's nonlocal
+									List<Grammar> rdefDelegates = rdef.grammar.getDelegates();
+									if ( rdefDelegates.contains(this.grammar) ) {
+										retval.code.add("scope", rdef.grammar);
+									}
+									else {
+										// defining grammar is not a delegate, scope all the
+										// back to root, which has delegate methods for all
+										// rules.  Don't use scope if we are root.
+										if ( this.grammar != rdef.grammar.composite.delegateGrammarTreeRoot.grammar ) {
+											retval.code.add("scope",
+															  rdef.grammar.composite.delegateGrammarTreeRoot.grammar);
+										}
+									}
+								}
+
+								if ( rarg!=null ) {
+									List<? extends Object> args = generator.translateAction(currentRuleName,rarg);
+									retval.code.add("args", args);
+								}
+								int i = ((CommonToken)r.getToken()).getTokenIndex();
+								retval.code.add("elementIndex", i);
+								generator.generateLocalFOLLOW(r,(r!=null?r.getText():null),currentRuleName,i);
+								r.code = retval.code;
+							}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1014:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? )
+					{
+					t=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom1511); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:1014:19: (targ= ARG_ACTION )?
+						int alt54=2;
+						int LA54_0 = input.LA(1);
+						if ( (LA54_0==ARG_ACTION) ) {
+							alt54=1;
+						}
+						switch (alt54) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:1014:20: targ= ARG_ACTION
+								{
+								targ=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1516); if (state.failed) return retval;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					if ( state.backtracking==0 ) {
+								if ( currentAltHasASTRewrite && t.terminalOptions!=null &&
+									t.terminalOptions.get(Grammar.defaultTokenOption)!=null )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
+															grammar,
+															t.getToken(),
+															(t!=null?t.getText():null));
+								}
+								grammar.checkRuleReference(scope, t, targ, currentRuleName);
+								if ( grammar.type==Grammar.LEXER )
+								{
+									if ( grammar.getTokenType((t!=null?t.getText():null))==Label.EOF )
+									{
+										retval.code = templates.getInstanceOf("lexerMatchEOF");
+									}
+									else
+									{
+										retval.code = templates.getInstanceOf("lexerRuleRef");
+										if ( isListLabel(labelText) )
+										{
+											retval.code = templates.getInstanceOf("lexerRuleRefAndListLabel");
+										}
+										String scopeName = null;
+										if ( scope!=null )
+										{
+											scopeName = scope.getText();
+										}
+										Rule rdef2 = grammar.getRule(scopeName, (t!=null?t.getText():null));
+										retval.code.add("rule", rdef2);
+										if ( scope!=null )
+										{ // scoped rule ref
+											Grammar scopeG = grammar.composite.getGrammar(scope.getText());
+											retval.code.add("scope", scopeG);
+										}
+										else if ( rdef2.grammar != this.grammar )
+										{ // nonlocal
+											// if rule definition is not in this grammar, it's nonlocal
+											retval.code.add("scope", rdef2.grammar);
+										}
+										if ( targ!=null )
+										{
+											List<? extends Object> args = generator.translateAction(currentRuleName,targ);
+											retval.code.add("args", args);
+										}
+									}
+									int i = ((CommonToken)t.getToken()).getTokenIndex();
+									retval.code.add("elementIndex", i);
+									if ( label!=null )
+										retval.code.add("label", labelText);
+								}
+								else
+								{
+									retval.code = getTokenElementST("tokenRef", (t!=null?t.getText():null), t, astSuffix, labelText);
+									String tokenLabel =
+										generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.getText()));
+									retval.code.add("token",tokenLabel);
+									if ( !currentAltHasASTRewrite && t.terminalOptions!=null )
+									{
+										retval.code.add("terminalOptions", t.terminalOptions);
+									}
+									int i = ((CommonToken)t.getToken()).getTokenIndex();
+									retval.code.add("elementIndex", i);
+									generator.generateLocalFOLLOW(t,tokenLabel,currentRuleName,i);
+								}
+								t.code = retval.code;
+							}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1083:4: c= CHAR_LITERAL
+					{
+					c=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom1532); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								if ( grammar.type==Grammar.LEXER )
+								{
+									retval.code = templates.getInstanceOf("charRef");
+									retval.code.add("char",
+									   generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,(c!=null?c.getText():null)));
+									if ( label!=null )
+									{
+										retval.code.add("label", labelText);
+									}
+								}
+								else { // else it's a token type reference
+									retval.code = getTokenElementST("tokenRef", "char_literal", c, astSuffix, labelText);
+									String tokenLabel = generator.getTokenTypeAsTargetLabel(grammar.getTokenType((c!=null?c.getText():null)));
+									retval.code.add("token",tokenLabel);
+									if ( c.terminalOptions!=null ) {
+										retval.code.add("terminalOptions",c.terminalOptions);
+									}
+									int i = ((CommonToken)c.getToken()).getTokenIndex();
+									retval.code.add("elementIndex", i);
+									generator.generateLocalFOLLOW(c,tokenLabel,currentRuleName,i);
+								}
+							}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1108:4: s= STRING_LITERAL
+					{
+					s=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_atom1544); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								int i = ((CommonToken)s.getToken()).getTokenIndex();
+								if ( grammar.type==Grammar.LEXER )
+								{
+									retval.code = templates.getInstanceOf("lexerStringRef");
+									retval.code.add("string",
+										generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator,(s!=null?s.getText():null)));
+									retval.code.add("elementIndex", i);
+									if ( label!=null )
+									{
+										retval.code.add("label", labelText);
+									}
+								}
+								else
+								{
+									// else it's a token type reference
+									retval.code = getTokenElementST("tokenRef", "string_literal", s, astSuffix, labelText);
+									String tokenLabel =
+										generator.getTokenTypeAsTargetLabel(grammar.getTokenType((s!=null?s.getText():null)));
+									retval.code.add("token",tokenLabel);
+									if ( s.terminalOptions!=null )
+									{
+										retval.code.add("terminalOptions",s.terminalOptions);
+									}
+									retval.code.add("elementIndex", i);
+									generator.generateLocalFOLLOW(s,tokenLabel,currentRuleName,i);
+								}
+							}
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1138:4: w= WILDCARD
+					{
+					w=(GrammarAST)match(input,WILDCARD,FOLLOW_WILDCARD_in_atom1556); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								retval.code = getWildcardST(w,astSuffix,labelText);
+								retval.code.add("elementIndex", ((CommonToken)w.getToken()).getTokenIndex());
+							}
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1144:4: ^( DOT ID a= atom[$ID, label, astSuffix] )
+					{
+					match(input,DOT,FOLLOW_DOT_in_atom1567); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					ID11=(GrammarAST)match(input,ID,FOLLOW_ID_in_atom1569); if (state.failed) return retval;
+					pushFollow(FOLLOW_atom_in_atom1573);
+					a=atom(ID11, label, astSuffix);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = (a!=null?((CodeGenTreeWalker.atom_return)a).code:null); }
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1147:4: set[label,astSuffix]
+					{
+					pushFollow(FOLLOW_set_in_atom1586);
+					set12=set(label, astSuffix);
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) { retval.code = set12; }
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "atom"
+
+
+
+	// $ANTLR start "ast_suffix"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1151:1: ast_suffix : ( ROOT | BANG );
+	public final void ast_suffix() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1152:2: ( ROOT | BANG )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:
+			{
+			if ( input.LA(1)==BANG||input.LA(1)==ROOT ) {
+				input.consume();
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ast_suffix"
+
+
+
+	// $ANTLR start "set"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1156:1: set[GrammarAST label, GrammarAST astSuffix] returns [ST code=null] : ^(s= BLOCK ( . )* ) ;
+	public final ST set(GrammarAST label, GrammarAST astSuffix) throws RecognitionException {
+		ST code = null;
+
+
+		GrammarAST s=null;
+
+
+			String labelText=null;
+			if ( label!=null )
+			{
+				labelText = label.getText();
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1165:2: ( ^(s= BLOCK ( . )* ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1165:4: ^(s= BLOCK ( . )* )
+			{
+			s=(GrammarAST)match(input,BLOCK,FOLLOW_BLOCK_in_set1631); if (state.failed) return code;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return code;
+				// org/antlr/grammar/v3/CodeGenTreeWalker.g:1165:14: ( . )*
+				loop56:
+				while (true) {
+					int alt56=2;
+					int LA56_0 = input.LA(1);
+					if ( ((LA56_0 >= ACTION && LA56_0 <= XDIGIT)) ) {
+						alt56=1;
+					}
+					else if ( (LA56_0==UP) ) {
+						alt56=2;
+					}
+
+					switch (alt56) {
+					case 1 :
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:1165:14: .
+						{
+						matchAny(input); if (state.failed) return code;
+						}
+						break;
+
+					default :
+						break loop56;
+					}
+				}
+
+				match(input, Token.UP, null); if (state.failed) return code;
+			}
+
+			if ( state.backtracking==0 ) {
+						code = getTokenElementST("matchSet", "set", s, astSuffix, labelText);
+						int i = ((CommonToken)s.getToken()).getTokenIndex();
+						code.add("elementIndex", i);
+						if ( grammar.type!=Grammar.LEXER )
+						{
+							generator.generateLocalFOLLOW(s,"set",currentRuleName,i);
+						}
+						code.add("s", generator.genSetExpr(templates,s.getSetValue(),1,false));
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return code;
+	}
+	// $ANTLR end "set"
+
+
+
+	// $ANTLR start "setElement"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1178:1: setElement : ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL | ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ) );
+	public final void setElement() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1179:2: ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL | ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ) )
+			int alt57=4;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				alt57=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt57=2;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt57=3;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt57=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 57, 0, input);
+				throw nvae;
+			}
+			switch (alt57) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1179:4: CHAR_LITERAL
+					{
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_setElement1651); if (state.failed) return;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1180:4: TOKEN_REF
+					{
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_setElement1656); if (state.failed) return;
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1181:4: STRING_LITERAL
+					{
+					match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_setElement1661); if (state.failed) return;
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1182:4: ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL )
+					{
+					match(input,CHAR_RANGE,FOLLOW_CHAR_RANGE_in_setElement1667); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_setElement1669); if (state.failed) return;
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_setElement1671); if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "setElement"
+
+
+	public static class rewrite_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "rewrite"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1187:1: rewrite returns [ST code=null] : ( ^( REWRITES ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )* ) |);
+	public final CodeGenTreeWalker.rewrite_return rewrite() throws RecognitionException {
+		CodeGenTreeWalker.rewrite_return retval = new CodeGenTreeWalker.rewrite_return();
+		retval.start = input.LT(1);
+
+		GrammarAST r=null;
+		GrammarAST pred=null;
+		ST alt =null;
+
+
+			if ( state.backtracking == 0 )
+			{
+				if ( ((GrammarAST)retval.start).getType()==REWRITES )
+				{
+					if ( generator.grammar.buildTemplate() )
+					{
+						retval.code = templates.getInstanceOf("rewriteTemplate");
+					}
+					else
+					{
+						retval.code = templates.getInstanceOf("rewriteCode");
+						retval.code.add("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+						retval.code.add("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+						retval.code.add("referencedElementsDeep",
+										  getTokenTypesAsTargetLabels(((GrammarAST)retval.start).rewriteRefsDeep));
+						Set<String> tokenLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.TOKEN_LABEL);
+						Set<String> tokenListLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.TOKEN_LIST_LABEL);
+						Set<String> ruleLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.RULE_LABEL);
+						Set<String> ruleListLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.RULE_LIST_LABEL);
+						Set<String> wildcardLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.WILDCARD_TREE_LABEL);
+						Set<String> wildcardListLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
+						// just in case they ref r for "previous value", make a stream
+						// from retval.tree
+						ST retvalST = templates.getInstanceOf("prevRuleRootRef");
+						ruleLabels.add(retvalST.render());
+						retval.code.add("referencedTokenLabels", tokenLabels);
+						retval.code.add("referencedTokenListLabels", tokenListLabels);
+						retval.code.add("referencedRuleLabels", ruleLabels);
+						retval.code.add("referencedRuleListLabels", ruleListLabels);
+						retval.code.add("referencedWildcardLabels", wildcardLabels);
+						retval.code.add("referencedWildcardListLabels", wildcardListLabels);
+					}
+				}
+				else
+				{
+						retval.code = templates.getInstanceOf("noRewrite");
+						retval.code.add("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+						retval.code.add("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+				}
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1237:2: ( ^( REWRITES ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )* ) |)
+			int alt60=2;
+			int LA60_0 = input.LA(1);
+			if ( (LA60_0==REWRITES) ) {
+				alt60=1;
+			}
+			else if ( (LA60_0==ALT||LA60_0==EOB) ) {
+				alt60=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 60, 0, input);
+				throw nvae;
+			}
+
+			switch (alt60) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1237:4: ^( REWRITES ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )* )
+					{
+					match(input,REWRITES,FOLLOW_REWRITES_in_rewrite1696); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:1238:4: ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )*
+						loop59:
+						while (true) {
+							int alt59=2;
+							int LA59_0 = input.LA(1);
+							if ( (LA59_0==REWRITE) ) {
+								alt59=1;
+							}
+
+							switch (alt59) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:1239:5: ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative )
+								{
+								if ( state.backtracking==0 ) {rewriteRuleRefs = new HashSet<Object>();}
+								r=(GrammarAST)match(input,REWRITE,FOLLOW_REWRITE_in_rewrite1717); if (state.failed) return retval;
+								match(input, Token.DOWN, null); if (state.failed) return retval;
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:1240:18: (pred= SEMPRED )?
+								int alt58=2;
+								int LA58_0 = input.LA(1);
+								if ( (LA58_0==SEMPRED) ) {
+									alt58=1;
+								}
+								switch (alt58) {
+									case 1 :
+										// org/antlr/grammar/v3/CodeGenTreeWalker.g:1240:19: pred= SEMPRED
+										{
+										pred=(GrammarAST)match(input,SEMPRED,FOLLOW_SEMPRED_in_rewrite1722); if (state.failed) return retval;
+										}
+										break;
+
+								}
+
+								pushFollow(FOLLOW_rewrite_alternative_in_rewrite1728);
+								alt=rewrite_alternative();
+								state._fsp--;
+								if (state.failed) return retval;
+								match(input, Token.UP, null); if (state.failed) return retval;
+
+								if ( state.backtracking==0 ) {
+													rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
+													List<? extends Object> predChunks = null;
+													if ( pred!=null )
+													{
+														//predText = #pred.getText();
+														predChunks = generator.translateAction(currentRuleName,pred);
+													}
+													String description =
+														grammar.grammarTreeToString(r,false);
+													description = generator.target.getTargetStringLiteralFromString(description);
+													retval.code.addAggr("alts.{pred,alt,description}",
+																	  predChunks,
+																	  alt,
+																	  description);
+													pred=null;
+												}
+								}
+								break;
+
+							default :
+								break loop59;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1261:2: 
+					{
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite"
+
+
+
+	// $ANTLR start "rewrite_block"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1263:1: rewrite_block[String blockTemplateName] returns [ST code=null] : ^( BLOCK alt= rewrite_alternative EOB ) ;
+	public final ST rewrite_block(String blockTemplateName) throws RecognitionException {
+		ST code = null;
+
+
+		GrammarAST BLOCK13=null;
+		ST alt =null;
+
+
+			rewriteBlockNestingLevel++;
+			ST save_currentBlockST = currentBlockST;
+			if ( state.backtracking == 0 )
+			{
+				code = templates.getInstanceOf(blockTemplateName);
+				currentBlockST = code;
+				code.add("rewriteBlockLevel", rewriteBlockNestingLevel);
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1275:2: ( ^( BLOCK alt= rewrite_alternative EOB ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1275:4: ^( BLOCK alt= rewrite_alternative EOB )
+			{
+			BLOCK13=(GrammarAST)match(input,BLOCK,FOLLOW_BLOCK_in_rewrite_block1771); if (state.failed) return code;
+			if ( state.backtracking==0 ) {
+							currentBlockST.add("referencedElementsDeep",
+								getTokenTypesAsTargetLabels(BLOCK13.rewriteRefsDeep));
+							currentBlockST.add("referencedElements",
+								getTokenTypesAsTargetLabels(BLOCK13.rewriteRefsShallow));
+						}
+			match(input, Token.DOWN, null); if (state.failed) return code;
+			pushFollow(FOLLOW_rewrite_alternative_in_rewrite_block1783);
+			alt=rewrite_alternative();
+			state._fsp--;
+			if (state.failed) return code;
+			match(input,EOB,FOLLOW_EOB_in_rewrite_block1788); if (state.failed) return code;
+			match(input, Token.UP, null); if (state.failed) return code;
+
+			if ( state.backtracking==0 ) {
+						code.add("alt", alt);
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+			 rewriteBlockNestingLevel--; currentBlockST = save_currentBlockST; 
+		}
+		return code;
+	}
+	// $ANTLR end "rewrite_block"
+
+
+
+	// $ANTLR start "rewrite_alternative"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1291:1: rewrite_alternative returns [ST code=null] : ({...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA ) |{...}? rewrite_template | ETC );
+	public final ST rewrite_alternative() throws RecognitionException {
+		ST code = null;
+
+
+		GrammarAST a=null;
+		TreeRuleReturnScope el =null;
+		ST rewrite_template14 =null;
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1292:2: ({...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA ) |{...}? rewrite_template | ETC )
+			int alt63=3;
+			switch ( input.LA(1) ) {
+			case ALT:
+				{
+				int LA63_1 = input.LA(2);
+				if ( (LA63_1==DOWN) ) {
+					int LA63_4 = input.LA(3);
+					if ( (LA63_4==EPSILON) ) {
+						int LA63_5 = input.LA(4);
+						if ( (LA63_5==EOA) ) {
+							int LA63_7 = input.LA(5);
+							if ( (LA63_7==UP) ) {
+								int LA63_8 = input.LA(6);
+								if ( ((generator.grammar.buildAST())) ) {
+									alt63=1;
+								}
+								else if ( ((generator.grammar.buildTemplate())) ) {
+									alt63=2;
+								}
+
+								else {
+									if (state.backtracking>0) {state.failed=true; return code;}
+									int nvaeMark = input.mark();
+									try {
+										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
+											input.consume();
+										}
+										NoViableAltException nvae =
+											new NoViableAltException("", 63, 8, input);
+										throw nvae;
+									} finally {
+										input.rewind(nvaeMark);
+									}
+								}
+
+							}
+
+							else {
+								if (state.backtracking>0) {state.failed=true; return code;}
+								int nvaeMark = input.mark();
+								try {
+									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
+										input.consume();
+									}
+									NoViableAltException nvae =
+										new NoViableAltException("", 63, 7, input);
+									throw nvae;
+								} finally {
+									input.rewind(nvaeMark);
+								}
+							}
+
+						}
+
+						else {
+							if (state.backtracking>0) {state.failed=true; return code;}
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 63, 5, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+					}
+					else if ( (LA63_4==ACTION||LA63_4==CHAR_LITERAL||LA63_4==CLOSURE||LA63_4==LABEL||LA63_4==OPTIONAL||LA63_4==POSITIVE_CLOSURE||LA63_4==RULE_REF||LA63_4==STRING_LITERAL||LA63_4==TOKEN_REF||LA63_4==TREE_BEGIN) ) {
+						alt63=1;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return code;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 63, 4, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return code;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 63, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case ACTION:
+			case TEMPLATE:
+				{
+				alt63=2;
+				}
+				break;
+			case ETC:
+				{
+				alt63=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return code;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 63, 0, input);
+				throw nvae;
+			}
+			switch (alt63) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1292:4: {...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA )
+					{
+					if ( !((generator.grammar.buildAST())) ) {
+						if (state.backtracking>0) {state.failed=true; return code;}
+						throw new FailedPredicateException(input, "rewrite_alternative", "generator.grammar.buildAST()");
+					}
+					a=(GrammarAST)match(input,ALT,FOLLOW_ALT_in_rewrite_alternative1823); if (state.failed) return code;
+					if ( state.backtracking==0 ) {code =templates.getInstanceOf("rewriteElementList");}
+					match(input, Token.DOWN, null); if (state.failed) return code;
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1294:4: ( (el= rewrite_element )+ | EPSILON )
+					int alt62=2;
+					int LA62_0 = input.LA(1);
+					if ( (LA62_0==ACTION||LA62_0==CHAR_LITERAL||LA62_0==CLOSURE||LA62_0==LABEL||LA62_0==OPTIONAL||LA62_0==POSITIVE_CLOSURE||LA62_0==RULE_REF||LA62_0==STRING_LITERAL||LA62_0==TOKEN_REF||LA62_0==TREE_BEGIN) ) {
+						alt62=1;
+					}
+					else if ( (LA62_0==EPSILON) ) {
+						alt62=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return code;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 62, 0, input);
+						throw nvae;
+					}
+
+					switch (alt62) {
+						case 1 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:1294:6: (el= rewrite_element )+
+							{
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:1294:6: (el= rewrite_element )+
+							int cnt61=0;
+							loop61:
+							while (true) {
+								int alt61=2;
+								int LA61_0 = input.LA(1);
+								if ( (LA61_0==ACTION||LA61_0==CHAR_LITERAL||LA61_0==CLOSURE||LA61_0==LABEL||LA61_0==OPTIONAL||LA61_0==POSITIVE_CLOSURE||LA61_0==RULE_REF||LA61_0==STRING_LITERAL||LA61_0==TOKEN_REF||LA61_0==TREE_BEGIN) ) {
+									alt61=1;
+								}
+
+								switch (alt61) {
+								case 1 :
+									// org/antlr/grammar/v3/CodeGenTreeWalker.g:1295:6: el= rewrite_element
+									{
+									pushFollow(FOLLOW_rewrite_element_in_rewrite_alternative1841);
+									el=rewrite_element();
+									state._fsp--;
+									if (state.failed) return code;
+									if ( state.backtracking==0 ) {code.addAggr("elements.{el,line,pos}",
+																			(el!=null?((CodeGenTreeWalker.rewrite_element_return)el).code:null),
+																			(el!=null?((GrammarAST)el.start):null).getLine(),
+																			(el!=null?((GrammarAST)el.start):null).getCharPositionInLine() + 1
+																			);
+														}
+									}
+									break;
+
+								default :
+									if ( cnt61 >= 1 ) break loop61;
+									if (state.backtracking>0) {state.failed=true; return code;}
+									EarlyExitException eee = new EarlyExitException(61, input);
+									throw eee;
+								}
+								cnt61++;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:1303:6: EPSILON
+							{
+							match(input,EPSILON,FOLLOW_EPSILON_in_rewrite_alternative1862); if (state.failed) return code;
+							if ( state.backtracking==0 ) {code.addAggr("elements.{el,line,pos}",
+															   templates.getInstanceOf("rewriteEmptyAlt"),
+															   a.getLine(),
+															   a.getCharPositionInLine() + 1
+															   );
+											}
+							}
+							break;
+
+					}
+
+					match(input,EOA,FOLLOW_EOA_in_rewrite_alternative1878); if (state.failed) return code;
+					match(input, Token.UP, null); if (state.failed) return code;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1314:4: {...}? rewrite_template
+					{
+					if ( !((generator.grammar.buildTemplate())) ) {
+						if (state.backtracking>0) {state.failed=true; return code;}
+						throw new FailedPredicateException(input, "rewrite_alternative", "generator.grammar.buildTemplate()");
+					}
+					pushFollow(FOLLOW_rewrite_template_in_rewrite_alternative1891);
+					rewrite_template14=rewrite_template();
+					state._fsp--;
+					if (state.failed) return code;
+					if ( state.backtracking==0 ) { code = rewrite_template14; }
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1318:3: ETC
+					{
+					match(input,ETC,FOLLOW_ETC_in_rewrite_alternative1904); if (state.failed) return code;
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return code;
+	}
+	// $ANTLR end "rewrite_alternative"
+
+
+	public static class rewrite_element_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "rewrite_element"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1321:1: rewrite_element returns [ST code=null] : ( rewrite_atom[false] | rewrite_ebnf | rewrite_tree );
+	public final CodeGenTreeWalker.rewrite_element_return rewrite_element() throws RecognitionException {
+		CodeGenTreeWalker.rewrite_element_return retval = new CodeGenTreeWalker.rewrite_element_return();
+		retval.start = input.LT(1);
+
+		TreeRuleReturnScope rewrite_atom15 =null;
+		TreeRuleReturnScope rewrite_ebnf16 =null;
+		TreeRuleReturnScope rewrite_tree17 =null;
+
+
+			IntSet elements=null;
+			GrammarAST ast = null;
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1327:2: ( rewrite_atom[false] | rewrite_ebnf | rewrite_tree )
+			int alt64=3;
+			switch ( input.LA(1) ) {
+			case ACTION:
+			case CHAR_LITERAL:
+			case LABEL:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt64=1;
+				}
+				break;
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt64=2;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt64=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 64, 0, input);
+				throw nvae;
+			}
+			switch (alt64) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1327:4: rewrite_atom[false]
+					{
+					pushFollow(FOLLOW_rewrite_atom_in_rewrite_element1924);
+					rewrite_atom15=rewrite_atom(false);
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) { retval.code = (rewrite_atom15!=null?((CodeGenTreeWalker.rewrite_atom_return)rewrite_atom15).code:null); }
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1329:4: rewrite_ebnf
+					{
+					pushFollow(FOLLOW_rewrite_ebnf_in_rewrite_element1934);
+					rewrite_ebnf16=rewrite_ebnf();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) { retval.code = (rewrite_ebnf16!=null?((CodeGenTreeWalker.rewrite_ebnf_return)rewrite_ebnf16).code:null); }
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1331:4: rewrite_tree
+					{
+					pushFollow(FOLLOW_rewrite_tree_in_rewrite_element1943);
+					rewrite_tree17=rewrite_tree();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) { retval.code = (rewrite_tree17!=null?((CodeGenTreeWalker.rewrite_tree_return)rewrite_tree17).code:null); }
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_element"
+
+
+	public static class rewrite_ebnf_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "rewrite_ebnf"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1335:1: rewrite_ebnf returns [ST code=null] : ( ^( OPTIONAL rewrite_block[\"rewriteOptionalBlock\"] ) | ^( CLOSURE rewrite_block[\"rewriteClosureBlock\"] ) | ^( POSITIVE_CLOSURE rewrite_block[\"rewritePositiveClosureBlock\"] ) );
+	public final CodeGenTreeWalker.rewrite_ebnf_return rewrite_ebnf() throws RecognitionException {
+		CodeGenTreeWalker.rewrite_ebnf_return retval = new CodeGenTreeWalker.rewrite_ebnf_return();
+		retval.start = input.LT(1);
+
+		ST rewrite_block18 =null;
+		ST rewrite_block19 =null;
+		ST rewrite_block20 =null;
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1336:2: ( ^( OPTIONAL rewrite_block[\"rewriteOptionalBlock\"] ) | ^( CLOSURE rewrite_block[\"rewriteClosureBlock\"] ) | ^( POSITIVE_CLOSURE rewrite_block[\"rewritePositiveClosureBlock\"] ) )
+			int alt65=3;
+			switch ( input.LA(1) ) {
+			case OPTIONAL:
+				{
+				alt65=1;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt65=2;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt65=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 65, 0, input);
+				throw nvae;
+			}
+			switch (alt65) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1336:4: ^( OPTIONAL rewrite_block[\"rewriteOptionalBlock\"] )
+					{
+					match(input,OPTIONAL,FOLLOW_OPTIONAL_in_rewrite_ebnf1964); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_rewrite_block_in_rewrite_ebnf1966);
+					rewrite_block18=rewrite_block("rewriteOptionalBlock");
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = rewrite_block18; }
+					if ( state.backtracking==0 ) {
+								String description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+								description = generator.target.getTargetStringLiteralFromString(description);
+								retval.code.add("description", description);
+							}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1343:4: ^( CLOSURE rewrite_block[\"rewriteClosureBlock\"] )
+					{
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_rewrite_ebnf1984); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_rewrite_block_in_rewrite_ebnf1986);
+					rewrite_block19=rewrite_block("rewriteClosureBlock");
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = rewrite_block19; }
+					if ( state.backtracking==0 ) {
+								String description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+								description = generator.target.getTargetStringLiteralFromString(description);
+								retval.code.add("description", description);
+							}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1350:4: ^( POSITIVE_CLOSURE rewrite_block[\"rewritePositiveClosureBlock\"] )
+					{
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_rewrite_ebnf2004); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_rewrite_block_in_rewrite_ebnf2006);
+					rewrite_block20=rewrite_block("rewritePositiveClosureBlock");
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) { retval.code = rewrite_block20; }
+					if ( state.backtracking==0 ) {
+								String description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+								description = generator.target.getTargetStringLiteralFromString(description);
+								retval.code.add("description", description);
+							}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_ebnf"
+
+
+	public static class rewrite_tree_return extends TreeRuleReturnScope {
+		public ST code;
+	};
+
+
+	// $ANTLR start "rewrite_tree"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1359:1: rewrite_tree returns [ST code] : ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* ) ;
+	public final CodeGenTreeWalker.rewrite_tree_return rewrite_tree() throws RecognitionException {
+		CodeGenTreeWalker.rewrite_tree_return retval = new CodeGenTreeWalker.rewrite_tree_return();
+		retval.start = input.LT(1);
+
+		TreeRuleReturnScope r =null;
+		TreeRuleReturnScope el =null;
+
+
+			rewriteTreeNestingLevel++;
+			if ( state.backtracking == 0 )
+			{
+				retval.code = templates.getInstanceOf("rewriteTree");
+				retval.code.add("treeLevel", rewriteTreeNestingLevel);
+				retval.code.add("enclosingTreeLevel", rewriteTreeNestingLevel-1);
+			}
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1370:2: ( ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* ) )
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1370:4: ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* )
+			{
+			match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_rewrite_tree2039); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			pushFollow(FOLLOW_rewrite_atom_in_rewrite_tree2046);
+			r=rewrite_atom(true);
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+							retval.code.addAggr("root.{el,line,pos}",
+											   (r!=null?((CodeGenTreeWalker.rewrite_atom_return)r).code:null),
+											   (r!=null?((GrammarAST)r.start):null).getLine(),
+											   (r!=null?((GrammarAST)r.start):null).getCharPositionInLine() + 1
+											  );
+						}
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1379:4: (el= rewrite_element )*
+			loop66:
+			while (true) {
+				int alt66=2;
+				int LA66_0 = input.LA(1);
+				if ( (LA66_0==ACTION||LA66_0==CHAR_LITERAL||LA66_0==CLOSURE||LA66_0==LABEL||LA66_0==OPTIONAL||LA66_0==POSITIVE_CLOSURE||LA66_0==RULE_REF||LA66_0==STRING_LITERAL||LA66_0==TOKEN_REF||LA66_0==TREE_BEGIN) ) {
+					alt66=1;
+				}
+
+				switch (alt66) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1380:6: el= rewrite_element
+					{
+					pushFollow(FOLLOW_rewrite_element_in_rewrite_tree2066);
+					el=rewrite_element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+									retval.code.addAggr("children.{el,line,pos}",
+														(el!=null?((CodeGenTreeWalker.rewrite_element_return)el).code:null),
+														(el!=null?((GrammarAST)el.start):null).getLine(),
+														(el!=null?((GrammarAST)el.start):null).getCharPositionInLine() + 1
+														);
+								  }
+					}
+					break;
+
+				default :
+					break loop66;
+				}
+			}
+
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			if ( state.backtracking==0 ) {
+						String description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+						description = generator.target.getTargetStringLiteralFromString(description);
+						retval.code.add("description", description);
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+			 rewriteTreeNestingLevel--; 
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_tree"
+
+
+	public static class rewrite_atom_return extends TreeRuleReturnScope {
+		public ST code=null;
+	};
+
+
+	// $ANTLR start "rewrite_atom"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1398:1: rewrite_atom[boolean isRoot] returns [ST code=null] : (r= RULE_REF | ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL ) | LABEL | ACTION );
+	public final CodeGenTreeWalker.rewrite_atom_return rewrite_atom(boolean isRoot) throws RecognitionException {
+		CodeGenTreeWalker.rewrite_atom_return retval = new CodeGenTreeWalker.rewrite_atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST r=null;
+		GrammarAST tk=null;
+		GrammarAST arg=null;
+		GrammarAST cl=null;
+		GrammarAST sl=null;
+		GrammarAST LABEL21=null;
+		GrammarAST ACTION22=null;
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1399:2: (r= RULE_REF | ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL ) | LABEL | ACTION )
+			int alt69=4;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+				{
+				alt69=1;
+				}
+				break;
+			case CHAR_LITERAL:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt69=2;
+				}
+				break;
+			case LABEL:
+				{
+				alt69=3;
+				}
+				break;
+			case ACTION:
+				{
+				alt69=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 69, 0, input);
+				throw nvae;
+			}
+			switch (alt69) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1399:6: r= RULE_REF
+					{
+					r=(GrammarAST)match(input,RULE_REF,FOLLOW_RULE_REF_in_rewrite_atom2111); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								String ruleRefName = (r!=null?r.getText():null);
+								String stName = "rewriteRuleRef";
+								if ( isRoot )
+								{
+									stName += "Root";
+								}
+								retval.code = templates.getInstanceOf(stName);
+								retval.code.add("rule", ruleRefName);
+								if ( grammar.getRule(ruleRefName)==null )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
+															  grammar,
+															  r.getToken(),
+															  ruleRefName);
+									retval.code = new ST(""); // blank; no code gen
+								}
+								else if ( grammar.getRule(currentRuleName)
+											 .getRuleRefsInAlt(ruleRefName,outerAltNum)==null )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
+															  grammar,
+															  r.getToken(),
+															  ruleRefName);
+									retval.code = new ST(""); // blank; no code gen
+								}
+								else
+								{
+									// track all rule refs as we must copy 2nd ref to rule and beyond
+									if ( !rewriteRuleRefs.contains(ruleRefName) )
+									{
+										rewriteRuleRefs.add(ruleRefName);
+									}
+								}
+							}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1437:3: ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL )
+					{
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1437:3: ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL )
+					int alt68=3;
+					switch ( input.LA(1) ) {
+					case TOKEN_REF:
+						{
+						alt68=1;
+						}
+						break;
+					case CHAR_LITERAL:
+						{
+						alt68=2;
+						}
+						break;
+					case STRING_LITERAL:
+						{
+						alt68=3;
+						}
+						break;
+					default:
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 68, 0, input);
+						throw nvae;
+					}
+					switch (alt68) {
+						case 1 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:1437:5: ^(tk= TOKEN_REF (arg= ARG_ACTION )? )
+							{
+							tk=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_rewrite_atom2128); if (state.failed) return retval;
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); if (state.failed) return retval;
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:1437:20: (arg= ARG_ACTION )?
+								int alt67=2;
+								int LA67_0 = input.LA(1);
+								if ( (LA67_0==ARG_ACTION) ) {
+									alt67=1;
+								}
+								switch (alt67) {
+									case 1 :
+										// org/antlr/grammar/v3/CodeGenTreeWalker.g:1437:21: arg= ARG_ACTION
+										{
+										arg=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rewrite_atom2133); if (state.failed) return retval;
+										}
+										break;
+
+								}
+
+								match(input, Token.UP, null); if (state.failed) return retval;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:1438:5: cl= CHAR_LITERAL
+							{
+							cl=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_rewrite_atom2144); if (state.failed) return retval;
+							}
+							break;
+						case 3 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:1439:5: sl= STRING_LITERAL
+							{
+							sl=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_rewrite_atom2152); if (state.failed) return retval;
+							}
+							break;
+
+					}
+
+					if ( state.backtracking==0 ) {
+								GrammarAST term = tk;
+								if (term == null) term = cl;
+								if (term == null) term = sl;
+								String tokenName = ((GrammarAST)retval.start).getToken().getText();
+								String stName = "rewriteTokenRef";
+								Rule rule = grammar.getRule(currentRuleName);
+								Collection<String> tokenRefsInAlt = rule.getTokenRefsInAlt(outerAltNum);
+								boolean createNewNode = !tokenRefsInAlt.contains(tokenName) || arg!=null;
+								if ( createNewNode )
+								{
+									stName = "rewriteImaginaryTokenRef";
+								}
+								if ( isRoot )
+								{
+									stName += "Root";
+								}
+								retval.code = templates.getInstanceOf(stName);
+								if (term.terminalOptions != null) {
+									retval.code.add("terminalOptions",term.terminalOptions);
+								}
+								if ( arg!=null )
+								{
+									List<? extends Object> args = generator.translateAction(currentRuleName,arg);
+									retval.code.add("args", args);
+								}
+								retval.code.add("elementIndex", ((CommonToken)((GrammarAST)retval.start).getToken()).getTokenIndex());
+								int ttype = grammar.getTokenType(tokenName);
+								String tok = generator.getTokenTypeAsTargetLabel(ttype);
+								retval.code.add("token", tok);
+								if ( grammar.getTokenType(tokenName)==Label.INVALID )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
+															  grammar,
+															  ((GrammarAST)retval.start).getToken(),
+															  tokenName);
+									retval.code = new ST(""); // blank; no code gen
+								}
+							}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1481:4: LABEL
+					{
+					LABEL21=(GrammarAST)match(input,LABEL,FOLLOW_LABEL_in_rewrite_atom2166); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								String labelName = (LABEL21!=null?LABEL21.getText():null);
+								Rule rule = grammar.getRule(currentRuleName);
+								Grammar.LabelElementPair pair = rule.getLabel(labelName);
+								if ( labelName.equals(currentRuleName) )
+								{
+									// special case; ref to old value via $ rule
+									if ( rule.hasRewrite(outerAltNum) &&
+										 rule.getRuleRefsInAlt(outerAltNum).contains(labelName) )
+									{
+										ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+																  grammar,
+																  LABEL21.getToken(),
+																  labelName);
+									}
+									ST labelST = templates.getInstanceOf("prevRuleRootRef");
+									retval.code = templates.getInstanceOf("rewriteRuleLabelRef"+(isRoot?"Root":""));
+									retval.code.add("label", labelST);
+								}
+								else if ( pair==null )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
+															  grammar,
+															  LABEL21.getToken(),
+															  labelName);
+									retval.code = new ST("");
+								}
+								else
+								{
+									String stName = null;
+									switch ( pair.type )
+									{
+									case Grammar.TOKEN_LABEL :
+										stName = "rewriteTokenLabelRef";
+										break;
+									case Grammar.WILDCARD_TREE_LABEL :
+										stName = "rewriteWildcardLabelRef";
+										break;
+									case Grammar.WILDCARD_TREE_LIST_LABEL:
+										stName = "rewriteRuleListLabelRef"; // acts like rule ref list for ref
+										break;
+									case Grammar.RULE_LABEL :
+										stName = "rewriteRuleLabelRef";
+										break;
+									case Grammar.TOKEN_LIST_LABEL :
+										stName = "rewriteTokenListLabelRef";
+										break;
+									case Grammar.RULE_LIST_LABEL :
+										stName = "rewriteRuleListLabelRef";
+										break;
+									}
+									if ( isRoot )
+									{
+										stName += "Root";
+									}
+									retval.code = templates.getInstanceOf(stName);
+									retval.code.add("label", labelName);
+								}
+							}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1542:4: ACTION
+					{
+					ACTION22=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_rewrite_atom2176); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								// actions in rewrite rules yield a tree object
+								String actText = (ACTION22!=null?ACTION22.getText():null);
+								List<? extends Object> chunks = generator.translateAction(currentRuleName,ACTION22);
+								retval.code = templates.getInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
+								retval.code.add("action", chunks);
+							}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_atom"
+
+
+
+	// $ANTLR start "rewrite_template"
+	// org/antlr/grammar/v3/CodeGenTreeWalker.g:1553:1: public rewrite_template returns [ST code=null] : ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION );
+	public final ST rewrite_template() throws RecognitionException {
+		ST code = null;
+
+
+		GrammarAST id=null;
+		GrammarAST ind=null;
+		GrammarAST arg=null;
+		GrammarAST a=null;
+		GrammarAST act=null;
+		GrammarAST DOUBLE_QUOTE_STRING_LITERAL23=null;
+		GrammarAST DOUBLE_ANGLE_STRING_LITERAL24=null;
+
+		try {
+			// org/antlr/grammar/v3/CodeGenTreeWalker.g:1554:2: ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION )
+			int alt73=3;
+			switch ( input.LA(1) ) {
+			case ALT:
+				{
+				alt73=1;
+				}
+				break;
+			case TEMPLATE:
+				{
+				alt73=2;
+				}
+				break;
+			case ACTION:
+				{
+				alt73=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return code;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 73, 0, input);
+				throw nvae;
+			}
+			switch (alt73) {
+				case 1 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1554:4: ^( ALT EPSILON EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_rewrite_template2199); if (state.failed) return code;
+					match(input, Token.DOWN, null); if (state.failed) return code;
+					match(input,EPSILON,FOLLOW_EPSILON_in_rewrite_template2201); if (state.failed) return code;
+					match(input,EOA,FOLLOW_EOA_in_rewrite_template2203); if (state.failed) return code;
+					match(input, Token.UP, null); if (state.failed) return code;
+
+					if ( state.backtracking==0 ) {code =templates.getInstanceOf("rewriteEmptyTemplate");}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1555:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
+					{
+					match(input,TEMPLATE,FOLLOW_TEMPLATE_in_rewrite_template2214); if (state.failed) return code;
+					match(input, Token.DOWN, null); if (state.failed) return code;
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1555:16: (id= ID |ind= ACTION )
+					int alt70=2;
+					int LA70_0 = input.LA(1);
+					if ( (LA70_0==ID) ) {
+						alt70=1;
+					}
+					else if ( (LA70_0==ACTION) ) {
+						alt70=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return code;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 70, 0, input);
+						throw nvae;
+					}
+
+					switch (alt70) {
+						case 1 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:1555:17: id= ID
+							{
+							id=(GrammarAST)match(input,ID,FOLLOW_ID_in_rewrite_template2219); if (state.failed) return code;
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:1555:23: ind= ACTION
+							{
+							ind=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template2223); if (state.failed) return code;
+							}
+							break;
+
+					}
+
+					if ( state.backtracking==0 ) {
+									if ( id!=null && (id!=null?id.getText():null).equals("template") )
+									{
+											code = templates.getInstanceOf("rewriteInlineTemplate");
+									}
+									else if ( id!=null )
+									{
+											code = templates.getInstanceOf("rewriteExternalTemplate");
+											code.add("name", (id!=null?id.getText():null));
+									}
+									else if ( ind!=null )
+									{ // must be %({expr})(args)
+										code = templates.getInstanceOf("rewriteIndirectTemplate");
+										List<? extends Object> chunks=generator.translateAction(currentRuleName,ind);
+										code.add("expr", chunks);
+									}
+								}
+					match(input,ARGLIST,FOLLOW_ARGLIST_in_rewrite_template2236); if (state.failed) return code;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return code;
+						// org/antlr/grammar/v3/CodeGenTreeWalker.g:1574:5: ( ^( ARG arg= ID a= ACTION ) )*
+						loop71:
+						while (true) {
+							int alt71=2;
+							int LA71_0 = input.LA(1);
+							if ( (LA71_0==ARG) ) {
+								alt71=1;
+							}
+
+							switch (alt71) {
+							case 1 :
+								// org/antlr/grammar/v3/CodeGenTreeWalker.g:1574:7: ^( ARG arg= ID a= ACTION )
+								{
+								match(input,ARG,FOLLOW_ARG_in_rewrite_template2246); if (state.failed) return code;
+								match(input, Token.DOWN, null); if (state.failed) return code;
+								arg=(GrammarAST)match(input,ID,FOLLOW_ID_in_rewrite_template2250); if (state.failed) return code;
+								a=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template2254); if (state.failed) return code;
+								if ( state.backtracking==0 ) {
+														// must set alt num here rather than in define.g
+														// because actions like %foo(name={$ID.text}) aren't
+														// broken up yet into trees.
+														a.outerAltNum = this.outerAltNum;
+														List<? extends Object> chunks = generator.translateAction(currentRuleName,a);
+														code.addAggr("args.{name,value}", (arg!=null?arg.getText():null), chunks);
+													}
+								match(input, Token.UP, null); if (state.failed) return code;
+
+								}
+								break;
+
+							default :
+								break loop71;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return code;
+					}
+
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1586:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
+					int alt72=3;
+					int LA72_0 = input.LA(1);
+					if ( (LA72_0==DOUBLE_QUOTE_STRING_LITERAL) ) {
+						alt72=1;
+					}
+					else if ( (LA72_0==DOUBLE_ANGLE_STRING_LITERAL) ) {
+						alt72=2;
+					}
+					switch (alt72) {
+						case 1 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:1586:6: DOUBLE_QUOTE_STRING_LITERAL
+							{
+							DOUBLE_QUOTE_STRING_LITERAL23=(GrammarAST)match(input,DOUBLE_QUOTE_STRING_LITERAL,FOLLOW_DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template2287); if (state.failed) return code;
+							if ( state.backtracking==0 ) {
+												String sl = (DOUBLE_QUOTE_STRING_LITERAL23!=null?DOUBLE_QUOTE_STRING_LITERAL23.getText():null);
+												String t = sl.substring( 1, sl.length() - 1 ); // strip quotes
+												t = generator.target.getTargetStringLiteralFromString(t);
+												code.add("template",t);
+											}
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/CodeGenTreeWalker.g:1593:6: DOUBLE_ANGLE_STRING_LITERAL
+							{
+							DOUBLE_ANGLE_STRING_LITERAL24=(GrammarAST)match(input,DOUBLE_ANGLE_STRING_LITERAL,FOLLOW_DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template2300); if (state.failed) return code;
+							if ( state.backtracking==0 ) {
+												String sl = (DOUBLE_ANGLE_STRING_LITERAL24!=null?DOUBLE_ANGLE_STRING_LITERAL24.getText():null);
+												String t = sl.substring( 2, sl.length() - 2 ); // strip double angle quotes
+												t = generator.target.getTargetStringLiteralFromString(t);
+												code.add("template",t);
+											}
+							}
+							break;
+
+					}
+
+					match(input, Token.UP, null); if (state.failed) return code;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/CodeGenTreeWalker.g:1603:4: act= ACTION
+					{
+					act=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template2324); if (state.failed) return code;
+					if ( state.backtracking==0 ) {
+								// set alt num for same reason as ARGLIST above
+								act.outerAltNum = this.outerAltNum;
+								code =templates.getInstanceOf("rewriteAction");
+								code.add("action",
+												  generator.translateAction(currentRuleName,act));
+							}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return code;
+	}
+	// $ANTLR end "rewrite_template"
+
+	// $ANTLR start synpred1_CodeGenTreeWalker
+	public final void synpred1_CodeGenTreeWalker_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/CodeGenTreeWalker.g:750:4: ({...}? ( BLOCK | OPTIONAL | CLOSURE | POSITIVE_CLOSURE ) )
+		// org/antlr/grammar/v3/CodeGenTreeWalker.g:750:5: {...}? ( BLOCK | OPTIONAL | CLOSURE | POSITIVE_CLOSURE )
+		{
+		if ( !((((GrammarAST)input.LT(1)).getSetValue()==null)) ) {
+			if (state.backtracking>0) {state.failed=true; return;}
+			throw new FailedPredicateException(input, "synpred1_CodeGenTreeWalker", "((GrammarAST)input.LT(1)).getSetValue()==null");
+		}
+		if ( input.LA(1)==BLOCK||input.LA(1)==CLOSURE||input.LA(1)==OPTIONAL||input.LA(1)==POSITIVE_CLOSURE ) {
+			input.consume();
+			state.errorRecovery=false;
+			state.failed=false;
+		}
+		else {
+			if (state.backtracking>0) {state.failed=true; return;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			throw mse;
+		}
+		}
+
+	}
+	// $ANTLR end synpred1_CodeGenTreeWalker
+
+	// $ANTLR start synpred2_CodeGenTreeWalker
+	public final void synpred2_CodeGenTreeWalker_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/CodeGenTreeWalker.g:918:6: ( element_action )
+		// org/antlr/grammar/v3/CodeGenTreeWalker.g:918:7: element_action
+		{
+		pushFollow(FOLLOW_element_action_in_synpred2_CodeGenTreeWalker1405);
+		element_action();
+		state._fsp--;
+		if (state.failed) return;
+		}
+
+	}
+	// $ANTLR end synpred2_CodeGenTreeWalker
+
+	// Delegated rules
+
+	public final boolean synpred2_CodeGenTreeWalker() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred2_CodeGenTreeWalker_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred1_CodeGenTreeWalker() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred1_CodeGenTreeWalker_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+
+	public static final BitSet FOLLOW_LEXER_GRAMMAR_in_grammar_67 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_69 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PARSER_GRAMMAR_in_grammar_79 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_81 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_GRAMMAR_in_grammar_91 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_93 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_COMBINED_GRAMMAR_in_grammar_103 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_105 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_attrScope124 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_attrScope126 = new BitSet(new long[]{0x0000000000000210L});
+	public static final BitSet FOLLOW_AMPERSAND_in_attrScope131 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_attrScope140 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_grammarSpec157 = new BitSet(new long[]{0x0400200008000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_DOC_COMMENT_in_grammarSpec165 = new BitSet(new long[]{0x0400200000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_OPTIONS_in_grammarSpec186 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_IMPORT_in_grammarSpec200 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_TOKENS_in_grammarSpec214 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_attrScope_in_grammarSpec226 = new BitSet(new long[]{0x0000000000000200L,0x0000000000028002L});
+	public static final BitSet FOLLOW_AMPERSAND_in_grammarSpec235 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rules_in_grammarSpec246 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rule_in_rules291 = new BitSet(new long[]{0x0000000000000002L,0x0000000000008002L});
+	public static final BitSet FOLLOW_RULE_in_rules305 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_PREC_RULE_in_rules317 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_RULE_in_rule359 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rule363 = new BitSet(new long[]{0x0000010000000400L,0x000000000000001CL});
+	public static final BitSet FOLLOW_modifier_in_rule376 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_ARG_in_rule384 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule387 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RET_in_rule396 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule399 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_throwsSpec_in_rule408 = new BitSet(new long[]{0x0400000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_OPTIONS_in_rule418 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_rule431 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_AMPERSAND_in_rule441 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_rule455 = new BitSet(new long[]{0x0000004400020000L});
+	public static final BitSet FOLLOW_exceptionGroup_in_rule468 = new BitSet(new long[]{0x0000000400000000L});
+	public static final BitSet FOLLOW_EOR_in_rule476 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_THROWS_in_throwsSpec526 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_throwsSpec528 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec543 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_AMPERSAND_in_ruleScopeSpec548 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec558 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_ID_in_ruleScopeSpec564 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_setBlock_in_block605 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BLOCK_in_block618 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_OPTIONS_in_block626 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_alternative_in_block643 = new BitSet(new long[]{0x0000000200000100L,0x0000000000001000L});
+	public static final BitSet FOLLOW_rewrite_in_block648 = new BitSet(new long[]{0x0000000200000100L});
+	public static final BitSet FOLLOW_EOB_in_block665 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_setBlock697 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ALT_in_setAlternative717 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_setElement_in_setAlternative719 = new BitSet(new long[]{0x00000001000C0000L,0x0000000041000000L});
+	public static final BitSet FOLLOW_EOA_in_setAlternative722 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_exceptionHandler_in_exceptionGroup737 = new BitSet(new long[]{0x0000004000020002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup744 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup752 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CATCH_in_exceptionHandler766 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_exceptionHandler768 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_exceptionHandler770 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_FINALLY_in_finallyClause788 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_finallyClause790 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_alternative820 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_alternative833 = new BitSet(new long[]{0x82800289202DE010L,0x0000000547092001L});
+	public static final BitSet FOLLOW_EOA_in_alternative851 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ROOT_in_element886 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element890 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BANG_in_element903 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element907 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_NOT_in_element923 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_notElement_in_element927 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ASSIGN_in_element942 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element946 = new BitSet(new long[]{0x82800288202DE010L,0x0000000547092001L});
+	public static final BitSet FOLLOW_element_in_element950 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PLUS_ASSIGN_in_element965 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element969 = new BitSet(new long[]{0x82800288202DE010L,0x0000000547092001L});
+	public static final BitSet FOLLOW_element_in_element973 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_RANGE_in_element987 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_element991 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_element995 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ebnf_in_element1024 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_atom_in_element1035 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_tree__in_element1046 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_element_action_in_element1056 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SEMPRED_in_element1071 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_GATED_SEMPRED_in_element1075 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYN_SEMPRED_in_element1086 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYNPRED_in_element1094 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_element1105 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_EPSILON_in_element1117 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_element_action1134 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_FORCED_ACTION_in_element_action1145 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_notElement1174 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_notElement1187 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_notElement1200 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BLOCK_in_notElement1214 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1261 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONAL_in_ebnf1280 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1284 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_ebnf1305 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1309 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_ebnf1330 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1334 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_tree_1372 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_tree_1379 = new BitSet(new long[]{0x82800288202DE018L,0x0000000547092001L});
+	public static final BitSet FOLLOW_element_action_in_tree_1416 = new BitSet(new long[]{0x82800288202DE018L,0x0000000547092001L});
+	public static final BitSet FOLLOW_element_in_tree_1438 = new BitSet(new long[]{0x82800288202DE018L,0x0000000547092001L});
+	public static final BitSet FOLLOW_RULE_REF_in_atom1488 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1493 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom1511 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1516 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom1532 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_atom1544 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_WILDCARD_in_atom1556 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOT_in_atom1567 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_atom1569 = new BitSet(new long[]{0x0000000020050000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_atom1573 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_set_in_atom1586 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BLOCK_in_set1631 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_setElement1651 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_setElement1656 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_setElement1661 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_RANGE_in_setElement1667 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_setElement1669 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_setElement1671 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_REWRITES_in_rewrite1696 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite1717 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_SEMPRED_in_rewrite1722 = new BitSet(new long[]{0x0000002000000110L,0x0000000008000000L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite1728 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_rewrite_block1771 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite_block1783 = new BitSet(new long[]{0x0000000200000000L});
+	public static final BitSet FOLLOW_EOB_in_rewrite_block1788 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_rewrite_alternative1823 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_element_in_rewrite_alternative1841 = new BitSet(new long[]{0x0201000100240010L,0x0000000141010001L});
+	public static final BitSet FOLLOW_EPSILON_in_rewrite_alternative1862 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_rewrite_alternative1878 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_rewrite_template_in_rewrite_alternative1891 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ETC_in_rewrite_alternative1904 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_atom_in_rewrite_element1924 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_ebnf_in_rewrite_element1934 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_in_rewrite_element1943 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONAL_in_rewrite_ebnf1964 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_block_in_rewrite_ebnf1966 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_rewrite_ebnf1984 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_block_in_rewrite_ebnf1986 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_rewrite_ebnf2004 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_block_in_rewrite_ebnf2006 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_rewrite_tree2039 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_atom_in_rewrite_tree2046 = new BitSet(new long[]{0x0201000000240018L,0x0000000141010001L});
+	public static final BitSet FOLLOW_rewrite_element_in_rewrite_tree2066 = new BitSet(new long[]{0x0201000000240018L,0x0000000141010001L});
+	public static final BitSet FOLLOW_RULE_REF_in_rewrite_atom2111 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_rewrite_atom2128 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rewrite_atom2133 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_rewrite_atom2144 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_rewrite_atom2152 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_LABEL_in_rewrite_atom2166 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_atom2176 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ALT_in_rewrite_template2199 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_EPSILON_in_rewrite_template2201 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_rewrite_template2203 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TEMPLATE_in_rewrite_template2214 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rewrite_template2219 = new BitSet(new long[]{0x0000000000000800L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template2223 = new BitSet(new long[]{0x0000000000000800L});
+	public static final BitSet FOLLOW_ARGLIST_in_rewrite_template2236 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_in_rewrite_template2246 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rewrite_template2250 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template2254 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template2287 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template2300 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template2324 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_set_in_synpred1_CodeGenTreeWalker1009 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_element_action_in_synpred2_CodeGenTreeWalker1405 = new BitSet(new long[]{0x0000000000000002L});
+}
--- tool/src/main/java/org/antlr/grammar/v3/DefineGrammarItemsWalker.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/DefineGrammarItemsWalker.java	2019-04-04 17:22:25.476181469 +0200
@@ -0,0 +1,4468 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/DefineGrammarItemsWalker.g 2019-04-04 15:18:50
+
+package org.antlr.grammar.v3;
+import org.antlr.tool.*;
+import java.util.HashSet;
+import java.util.Set;
+
+
+import org.antlr.runtime.*;
+import org.antlr.runtime.tree.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+
+@SuppressWarnings("all")
+public class DefineGrammarItemsWalker extends TreeParser {
+	public static final String[] tokenNames = new String[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", 
+		"ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", 
+		"ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", 
+		"CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", 
+		"COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", 
+		"DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", 
+		"EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", 
+		"GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", 
+		"LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", 
+		"NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", 
+		"OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", 
+		"PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", 
+		"RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", 
+		"RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", 
+		"SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", 
+		"TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", 
+		"WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public static final int EOF=-1;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int AMPERSAND=9;
+	public static final int ARG=10;
+	public static final int ARGLIST=11;
+	public static final int ARG_ACTION=12;
+	public static final int ASSIGN=13;
+	public static final int BACKTRACK_SEMPRED=14;
+	public static final int BANG=15;
+	public static final int BLOCK=16;
+	public static final int CATCH=17;
+	public static final int CHAR_LITERAL=18;
+	public static final int CHAR_RANGE=19;
+	public static final int CLOSE_ELEMENT_OPTION=20;
+	public static final int CLOSURE=21;
+	public static final int COLON=22;
+	public static final int COMBINED_GRAMMAR=23;
+	public static final int COMMA=24;
+	public static final int COMMENT=25;
+	public static final int DIGIT=26;
+	public static final int DOC_COMMENT=27;
+	public static final int DOLLAR=28;
+	public static final int DOT=29;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public static final int EOA=32;
+	public static final int EOB=33;
+	public static final int EOR=34;
+	public static final int EPSILON=35;
+	public static final int ESC=36;
+	public static final int ETC=37;
+	public static final int FINALLY=38;
+	public static final int FORCED_ACTION=39;
+	public static final int FRAGMENT=40;
+	public static final int GATED_SEMPRED=41;
+	public static final int GRAMMAR=42;
+	public static final int ID=43;
+	public static final int IMPLIES=44;
+	public static final int IMPORT=45;
+	public static final int INITACTION=46;
+	public static final int INT=47;
+	public static final int LABEL=48;
+	public static final int LEXER=49;
+	public static final int LEXER_GRAMMAR=50;
+	public static final int LPAREN=51;
+	public static final int ML_COMMENT=52;
+	public static final int NESTED_ACTION=53;
+	public static final int NESTED_ARG_ACTION=54;
+	public static final int NOT=55;
+	public static final int OPEN_ELEMENT_OPTION=56;
+	public static final int OPTIONAL=57;
+	public static final int OPTIONS=58;
+	public static final int OR=59;
+	public static final int PARSER=60;
+	public static final int PARSER_GRAMMAR=61;
+	public static final int PLUS=62;
+	public static final int PLUS_ASSIGN=63;
+	public static final int POSITIVE_CLOSURE=64;
+	public static final int PREC_RULE=65;
+	public static final int PRIVATE=66;
+	public static final int PROTECTED=67;
+	public static final int PUBLIC=68;
+	public static final int QUESTION=69;
+	public static final int RANGE=70;
+	public static final int RCURLY=71;
+	public static final int RECURSIVE_RULE_REF=72;
+	public static final int RET=73;
+	public static final int RETURNS=74;
+	public static final int REWRITE=75;
+	public static final int REWRITES=76;
+	public static final int ROOT=77;
+	public static final int RPAREN=78;
+	public static final int RULE=79;
+	public static final int RULE_REF=80;
+	public static final int SCOPE=81;
+	public static final int SEMI=82;
+	public static final int SEMPRED=83;
+	public static final int SL_COMMENT=84;
+	public static final int SRC=85;
+	public static final int STAR=86;
+	public static final int STRAY_BRACKET=87;
+	public static final int STRING_LITERAL=88;
+	public static final int SYNPRED=89;
+	public static final int SYN_SEMPRED=90;
+	public static final int TEMPLATE=91;
+	public static final int THROWS=92;
+	public static final int TOKENS=93;
+	public static final int TOKEN_REF=94;
+	public static final int TREE=95;
+	public static final int TREE_BEGIN=96;
+	public static final int TREE_GRAMMAR=97;
+	public static final int WILDCARD=98;
+	public static final int WS=99;
+	public static final int WS_LOOP=100;
+	public static final int WS_OPT=101;
+	public static final int XDIGIT=102;
+
+	// delegates
+	public TreeParser[] getDelegates() {
+		return new TreeParser[] {};
+	}
+
+	// delegators
+
+	protected static class AttributeScopeActions_scope {
+		HashMap<GrammarAST, GrammarAST> actions;
+	}
+	protected Stack<AttributeScopeActions_scope> AttributeScopeActions_stack = new Stack<AttributeScopeActions_scope>();
+
+
+	public DefineGrammarItemsWalker(TreeNodeStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public DefineGrammarItemsWalker(TreeNodeStream input, RecognizerSharedState state) {
+		super(input, state);
+	}
+
+	@Override public String[] getTokenNames() { return DefineGrammarItemsWalker.tokenNames; }
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/DefineGrammarItemsWalker.g"; }
+
+
+	protected Grammar grammar;
+	protected GrammarAST root;
+	protected String currentRuleName;
+	protected GrammarAST currentRewriteBlock;
+	protected GrammarAST currentRewriteRule;
+	protected int outerAltNum = 0;
+	protected int blockLevel = 0;
+
+	public final int countAltsForRule( CommonTree t ) {
+	    CommonTree block = (CommonTree)t.getFirstChildWithType(BLOCK);
+	    int altCount = 0;
+	    for (int i = 0; i < block.getChildCount(); i++) {
+	        if (block.getChild(i).getType() == ALT)
+	            altCount++;
+	    }
+	    return altCount;
+	}
+
+	protected final void finish() {
+	    trimGrammar();
+	}
+
+	/** Remove any lexer rules from a COMBINED; already passed to lexer */
+	protected final void trimGrammar() {
+	    if ( grammar.type != Grammar.COMBINED ) {
+	        return;
+	    }
+	    // form is (header ... ) ( grammar ID (scope ...) ... ( rule ... ) ( rule ... ) ... )
+	    GrammarAST p = root;
+	    // find the grammar spec
+	    while ( !p.getText().equals( "grammar" ) ) {
+	        p = p.getNextSibling();
+	    }
+	    for ( int i = 0; i < p.getChildCount(); i++ ) {
+	        if ( p.getChild( i ).getType() != RULE )
+	            continue;
+
+	        String ruleName = p.getChild(i).getChild(0).getText();
+	        //Console.Out.WriteLine( "rule " + ruleName + " prev=" + prev.getText() );
+	        if (Rule.getRuleType(ruleName) == Grammar.LEXER) {
+	            // remove lexer rule
+	            p.deleteChild( i );
+	            i--;
+	        }
+	    }
+	    //Console.Out.WriteLine( "root after removal is: " + root.ToStringList() );
+	}
+
+	protected final void trackInlineAction( GrammarAST actionAST ) {
+	    Rule r = grammar.getRule( currentRuleName );
+	    if ( r != null ) {
+	        r.trackInlineAction( actionAST );
+	    }
+	}
+
+
+	public static class grammar__return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "grammar_"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:109:1: public grammar_[Grammar g] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) );
+	public final DefineGrammarItemsWalker.grammar__return grammar_(Grammar g) throws RecognitionException {
+		DefineGrammarItemsWalker.grammar__return retval = new DefineGrammarItemsWalker.grammar__return();
+		retval.start = input.LT(1);
+
+
+		grammar = g;
+		root = ((GrammarAST)retval.start);
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:119:2: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			int alt1=4;
+			switch ( input.LA(1) ) {
+			case LEXER_GRAMMAR:
+				{
+				alt1=1;
+				}
+				break;
+			case PARSER_GRAMMAR:
+				{
+				alt1=2;
+				}
+				break;
+			case TREE_GRAMMAR:
+				{
+				alt1=3;
+				}
+				break;
+			case COMBINED_GRAMMAR:
+				{
+				alt1=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 1, 0, input);
+				throw nvae;
+			}
+			switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:119:4: ^( LEXER_GRAMMAR grammarSpec )
+					{
+					match(input,LEXER_GRAMMAR,FOLLOW_LEXER_GRAMMAR_in_grammar_76); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {grammar.type = Grammar.LEXER;}
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_82);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:120:4: ^( PARSER_GRAMMAR grammarSpec )
+					{
+					match(input,PARSER_GRAMMAR,FOLLOW_PARSER_GRAMMAR_in_grammar_91); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {grammar.type = Grammar.PARSER;}
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_96);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:121:4: ^( TREE_GRAMMAR grammarSpec )
+					{
+					match(input,TREE_GRAMMAR,FOLLOW_TREE_GRAMMAR_in_grammar_105); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {grammar.type = Grammar.TREE_PARSER;}
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_110);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:122:4: ^( COMBINED_GRAMMAR grammarSpec )
+					{
+					match(input,COMBINED_GRAMMAR,FOLLOW_COMBINED_GRAMMAR_in_grammar_119); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {grammar.type = Grammar.COMBINED;}
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_124);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+
+			}
+			if ( state.backtracking==0 ) {
+			finish();
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "grammar_"
+
+
+
+	// $ANTLR start "attrScope"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:125:1: attrScope : ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION ) ;
+	public final void attrScope() throws RecognitionException {
+		AttributeScopeActions_stack.push(new AttributeScopeActions_scope());
+
+		GrammarAST name=null;
+		GrammarAST attrs=null;
+
+
+			AttributeScopeActions_stack.peek().actions = new HashMap<GrammarAST, GrammarAST>();
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:131:2: ( ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:131:4: ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_attrScope149); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			name=(GrammarAST)match(input,ID,FOLLOW_ID_in_attrScope153); if (state.failed) return;
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:131:23: ( attrScopeAction )*
+			loop2:
+			while (true) {
+				int alt2=2;
+				int LA2_0 = input.LA(1);
+				if ( (LA2_0==AMPERSAND) ) {
+					alt2=1;
+				}
+
+				switch (alt2) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:131:23: attrScopeAction
+					{
+					pushFollow(FOLLOW_attrScopeAction_in_attrScope155);
+					attrScopeAction();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					break loop2;
+				}
+			}
+
+			attrs=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_attrScope160); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {
+						AttributeScope scope = grammar.defineGlobalScope((name!=null?name.getText():null),attrs.getToken());
+						scope.isDynamicGlobalScope = true;
+						scope.addAttributes((attrs!=null?attrs.getText():null), ';');
+						for (GrammarAST action : AttributeScopeActions_stack.peek().actions.keySet())
+							scope.defineNamedAction(action, AttributeScopeActions_stack.peek().actions.get(action));
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+			AttributeScopeActions_stack.pop();
+
+		}
+	}
+	// $ANTLR end "attrScope"
+
+
+
+	// $ANTLR start "attrScopeAction"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:141:1: attrScopeAction : ^( AMPERSAND ID ACTION ) ;
+	public final void attrScopeAction() throws RecognitionException {
+		GrammarAST ID1=null;
+		GrammarAST ACTION2=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:142:2: ( ^( AMPERSAND ID ACTION ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:142:4: ^( AMPERSAND ID ACTION )
+			{
+			match(input,AMPERSAND,FOLLOW_AMPERSAND_in_attrScopeAction178); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			ID1=(GrammarAST)match(input,ID,FOLLOW_ID_in_attrScopeAction180); if (state.failed) return;
+			ACTION2=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_attrScopeAction182); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {
+						AttributeScopeActions_stack.peek().actions.put( ID1, ACTION2 );
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "attrScopeAction"
+
+
+
+	// $ANTLR start "grammarSpec"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:148:1: grammarSpec : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules ;
+	public final void grammarSpec() throws RecognitionException {
+		GrammarAST id=null;
+		GrammarAST cmt=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:149:2: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:149:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules
+			{
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_grammarSpec200); if (state.failed) return;
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:150:3: (cmt= DOC_COMMENT )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+			if ( (LA3_0==DOC_COMMENT) ) {
+				alt3=1;
+			}
+			switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:150:4: cmt= DOC_COMMENT
+					{
+					cmt=(GrammarAST)match(input,DOC_COMMENT,FOLLOW_DOC_COMMENT_in_grammarSpec207); if (state.failed) return;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:151:3: ( optionsSpec )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+			if ( (LA4_0==OPTIONS) ) {
+				alt4=1;
+			}
+			switch (alt4) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:151:5: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_grammarSpec215);
+					optionsSpec();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:152:3: ( delegateGrammars )?
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+			if ( (LA5_0==IMPORT) ) {
+				alt5=1;
+			}
+			switch (alt5) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:152:4: delegateGrammars
+					{
+					pushFollow(FOLLOW_delegateGrammars_in_grammarSpec223);
+					delegateGrammars();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:153:3: ( tokensSpec )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+			if ( (LA6_0==TOKENS) ) {
+				alt6=1;
+			}
+			switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:153:4: tokensSpec
+					{
+					pushFollow(FOLLOW_tokensSpec_in_grammarSpec230);
+					tokensSpec();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:154:3: ( attrScope )*
+			loop7:
+			while (true) {
+				int alt7=2;
+				int LA7_0 = input.LA(1);
+				if ( (LA7_0==SCOPE) ) {
+					alt7=1;
+				}
+
+				switch (alt7) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:154:4: attrScope
+					{
+					pushFollow(FOLLOW_attrScope_in_grammarSpec237);
+					attrScope();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					break loop7;
+				}
+			}
+
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:155:3: ( actions )?
+			int alt8=2;
+			int LA8_0 = input.LA(1);
+			if ( (LA8_0==AMPERSAND) ) {
+				alt8=1;
+			}
+			switch (alt8) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:155:4: actions
+					{
+					pushFollow(FOLLOW_actions_in_grammarSpec244);
+					actions();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_rules_in_grammarSpec250);
+			rules();
+			state._fsp--;
+			if (state.failed) return;
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammarSpec"
+
+
+
+	// $ANTLR start "actions"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:159:1: actions : ( action )+ ;
+	public final void actions() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:160:2: ( ( action )+ )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:160:4: ( action )+
+			{
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:160:4: ( action )+
+			int cnt9=0;
+			loop9:
+			while (true) {
+				int alt9=2;
+				int LA9_0 = input.LA(1);
+				if ( (LA9_0==AMPERSAND) ) {
+					alt9=1;
+				}
+
+				switch (alt9) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:160:6: action
+					{
+					pushFollow(FOLLOW_action_in_actions263);
+					action();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt9 >= 1 ) break loop9;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(9, input);
+					throw eee;
+				}
+				cnt9++;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "actions"
+
+
+
+	// $ANTLR start "action"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:163:1: action : ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) ;
+	public final void action() throws RecognitionException {
+		GrammarAST amp=null;
+		GrammarAST id1=null;
+		GrammarAST id2=null;
+		GrammarAST a1=null;
+		GrammarAST a2=null;
+
+
+			String scope=null;
+			GrammarAST nameAST=null, actionAST=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:169:2: ( ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:169:4: ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) )
+			{
+			amp=(GrammarAST)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_action285); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			id1=(GrammarAST)match(input,ID,FOLLOW_ID_in_action289); if (state.failed) return;
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:170:4: (id2= ID a1= ACTION |a2= ACTION )
+			int alt10=2;
+			int LA10_0 = input.LA(1);
+			if ( (LA10_0==ID) ) {
+				alt10=1;
+			}
+			else if ( (LA10_0==ACTION) ) {
+				alt10=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 10, 0, input);
+				throw nvae;
+			}
+
+			switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:170:6: id2= ID a1= ACTION
+					{
+					id2=(GrammarAST)match(input,ID,FOLLOW_ID_in_action298); if (state.failed) return;
+					a1=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_action302); if (state.failed) return;
+					if ( state.backtracking==0 ) {scope=(id1!=null?id1.getText():null); nameAST=id2; actionAST=a1;}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:172:6: a2= ACTION
+					{
+					a2=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_action318); if (state.failed) return;
+					if ( state.backtracking==0 ) {scope=null; nameAST=id1; actionAST=a2;}
+					}
+					break;
+
+			}
+
+			match(input, Token.UP, null); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {
+					 grammar.defineNamedAction(amp,scope,nameAST,actionAST);
+					 }
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "action"
+
+
+
+	// $ANTLR start "optionsSpec"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:181:1: optionsSpec : ^( OPTIONS ( . )* ) ;
+	public final void optionsSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:182:2: ( ^( OPTIONS ( . )* ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:182:4: ^( OPTIONS ( . )* )
+			{
+			match(input,OPTIONS,FOLLOW_OPTIONS_in_optionsSpec352); if (state.failed) return;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return;
+				// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:182:14: ( . )*
+				loop11:
+				while (true) {
+					int alt11=2;
+					int LA11_0 = input.LA(1);
+					if ( ((LA11_0 >= ACTION && LA11_0 <= XDIGIT)) ) {
+						alt11=1;
+					}
+					else if ( (LA11_0==UP) ) {
+						alt11=2;
+					}
+
+					switch (alt11) {
+					case 1 :
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:182:14: .
+						{
+						matchAny(input); if (state.failed) return;
+						}
+						break;
+
+					default :
+						break loop11;
+					}
+				}
+
+				match(input, Token.UP, null); if (state.failed) return;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "optionsSpec"
+
+
+
+	// $ANTLR start "delegateGrammars"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:185:1: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
+	public final void delegateGrammars() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:186:2: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:186:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
+			{
+			match(input,IMPORT,FOLLOW_IMPORT_in_delegateGrammars369); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:186:16: ( ^( ASSIGN ID ID ) | ID )+
+			int cnt12=0;
+			loop12:
+			while (true) {
+				int alt12=3;
+				int LA12_0 = input.LA(1);
+				if ( (LA12_0==ASSIGN) ) {
+					alt12=1;
+				}
+				else if ( (LA12_0==ID) ) {
+					alt12=2;
+				}
+
+				switch (alt12) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:186:18: ^( ASSIGN ID ID )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_delegateGrammars374); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,ID,FOLLOW_ID_in_delegateGrammars376); if (state.failed) return;
+					match(input,ID,FOLLOW_ID_in_delegateGrammars378); if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:186:36: ID
+					{
+					match(input,ID,FOLLOW_ID_in_delegateGrammars383); if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt12 >= 1 ) break loop12;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(12, input);
+					throw eee;
+				}
+				cnt12++;
+			}
+
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "delegateGrammars"
+
+
+
+	// $ANTLR start "tokensSpec"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:189:1: tokensSpec : ^( TOKENS ( tokenSpec )* ) ;
+	public final void tokensSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:190:2: ( ^( TOKENS ( tokenSpec )* ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:190:4: ^( TOKENS ( tokenSpec )* )
+			{
+			match(input,TOKENS,FOLLOW_TOKENS_in_tokensSpec400); if (state.failed) return;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return;
+				// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:190:13: ( tokenSpec )*
+				loop13:
+				while (true) {
+					int alt13=2;
+					int LA13_0 = input.LA(1);
+					if ( (LA13_0==ASSIGN||LA13_0==TOKEN_REF) ) {
+						alt13=1;
+					}
+
+					switch (alt13) {
+					case 1 :
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:190:13: tokenSpec
+						{
+						pushFollow(FOLLOW_tokenSpec_in_tokensSpec402);
+						tokenSpec();
+						state._fsp--;
+						if (state.failed) return;
+						}
+						break;
+
+					default :
+						break loop13;
+					}
+				}
+
+				match(input, Token.UP, null); if (state.failed) return;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tokensSpec"
+
+
+
+	// $ANTLR start "tokenSpec"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:193:1: tokenSpec : (t= TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) );
+	public final void tokenSpec() throws RecognitionException {
+		GrammarAST t=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:194:2: (t= TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) )
+			int alt14=2;
+			int LA14_0 = input.LA(1);
+			if ( (LA14_0==TOKEN_REF) ) {
+				alt14=1;
+			}
+			else if ( (LA14_0==ASSIGN) ) {
+				alt14=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 14, 0, input);
+				throw nvae;
+			}
+
+			switch (alt14) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:194:4: t= TOKEN_REF
+					{
+					t=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec417); if (state.failed) return;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:195:4: ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_tokenSpec424); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_tokenSpec429); if (state.failed) return;
+					if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL ) {
+						input.consume();
+						state.errorRecovery=false;
+						state.failed=false;
+					}
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						throw mse;
+					}
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tokenSpec"
+
+
+
+	// $ANTLR start "rules"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:203:1: rules : ( rule | ^( PREC_RULE ( . )* ) )+ ;
+	public final void rules() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:204:2: ( ( rule | ^( PREC_RULE ( . )* ) )+ )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:204:4: ( rule | ^( PREC_RULE ( . )* ) )+
+			{
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:204:4: ( rule | ^( PREC_RULE ( . )* ) )+
+			int cnt16=0;
+			loop16:
+			while (true) {
+				int alt16=3;
+				int LA16_0 = input.LA(1);
+				if ( (LA16_0==RULE) ) {
+					alt16=1;
+				}
+				else if ( (LA16_0==PREC_RULE) ) {
+					alt16=2;
+				}
+
+				switch (alt16) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:204:5: rule
+					{
+					pushFollow(FOLLOW_rule_in_rules465);
+					rule();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:204:12: ^( PREC_RULE ( . )* )
+					{
+					match(input,PREC_RULE,FOLLOW_PREC_RULE_in_rules470); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:204:24: ( . )*
+						loop15:
+						while (true) {
+							int alt15=2;
+							int LA15_0 = input.LA(1);
+							if ( ((LA15_0 >= ACTION && LA15_0 <= XDIGIT)) ) {
+								alt15=1;
+							}
+							else if ( (LA15_0==UP) ) {
+								alt15=2;
+							}
+
+							switch (alt15) {
+							case 1 :
+								// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:204:24: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop15;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+				default :
+					if ( cnt16 >= 1 ) break loop16;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(16, input);
+					throw eee;
+				}
+				cnt16++;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rules"
+
+
+	public static class rule_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "rule"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:207:1: rule : ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR ) ;
+	public final DefineGrammarItemsWalker.rule_return rule() throws RecognitionException {
+		DefineGrammarItemsWalker.rule_return retval = new DefineGrammarItemsWalker.rule_return();
+		retval.start = input.LT(1);
+
+		GrammarAST id=null;
+		GrammarAST args=null;
+		GrammarAST ret=null;
+		GrammarAST RULE3=null;
+		TreeRuleReturnScope b =null;
+		TreeRuleReturnScope modifier4 =null;
+		HashSet<String> throwsSpec5 =null;
+
+
+			String name=null;
+			Map<String, Object> opts=null;
+			Rule r = null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:214:2: ( ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:214:5: ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR )
+			{
+			RULE3=(GrammarAST)match(input,RULE,FOLLOW_RULE_in_rule495); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_rule499); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {opts = RULE3.getBlockOptions();}
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:215:4: ( modifier )?
+			int alt17=2;
+			int LA17_0 = input.LA(1);
+			if ( (LA17_0==FRAGMENT||(LA17_0 >= PRIVATE && LA17_0 <= PUBLIC)) ) {
+				alt17=1;
+			}
+			switch (alt17) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:215:5: modifier
+					{
+					pushFollow(FOLLOW_modifier_in_rule507);
+					modifier4=modifier();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			match(input,ARG,FOLLOW_ARG_in_rule516); if (state.failed) return retval;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return retval;
+				// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:216:11: (args= ARG_ACTION )?
+				int alt18=2;
+				int LA18_0 = input.LA(1);
+				if ( (LA18_0==ARG_ACTION) ) {
+					alt18=1;
+				}
+				switch (alt18) {
+					case 1 :
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:216:12: args= ARG_ACTION
+						{
+						args=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule521); if (state.failed) return retval;
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); if (state.failed) return retval;
+			}
+
+			match(input,RET,FOLLOW_RET_in_rule532); if (state.failed) return retval;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return retval;
+				// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:217:11: (ret= ARG_ACTION )?
+				int alt19=2;
+				int LA19_0 = input.LA(1);
+				if ( (LA19_0==ARG_ACTION) ) {
+					alt19=1;
+				}
+				switch (alt19) {
+					case 1 :
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:217:12: ret= ARG_ACTION
+						{
+						ret=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule537); if (state.failed) return retval;
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); if (state.failed) return retval;
+			}
+
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:218:4: ( throwsSpec )?
+			int alt20=2;
+			int LA20_0 = input.LA(1);
+			if ( (LA20_0==THROWS) ) {
+				alt20=1;
+			}
+			switch (alt20) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:218:5: throwsSpec
+					{
+					pushFollow(FOLLOW_throwsSpec_in_rule547);
+					throwsSpec5=throwsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:219:4: ( optionsSpec )?
+			int alt21=2;
+			int LA21_0 = input.LA(1);
+			if ( (LA21_0==OPTIONS) ) {
+				alt21=1;
+			}
+			switch (alt21) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:219:5: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_rule555);
+					optionsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			if ( state.backtracking==0 ) {
+							name = (id!=null?id.getText():null);
+							currentRuleName = name;
+							if ( Rule.getRuleType(name) == Grammar.LEXER && grammar.type==Grammar.COMBINED )
+							{
+								// a merged grammar spec, track lexer rules and send to another grammar
+								grammar.defineLexerRuleFoundInParser(id.getToken(), ((GrammarAST)retval.start));
+							}
+							else
+							{
+								int numAlts = countAltsForRule(((GrammarAST)retval.start));
+								grammar.defineRule(id.getToken(), (modifier4!=null?((DefineGrammarItemsWalker.modifier_return)modifier4).mod:null), opts, ((GrammarAST)retval.start), args, numAlts);
+								r = grammar.getRule(name);
+								if ( args!=null )
+								{
+									r.parameterScope = grammar.createParameterScope(name,args.getToken());
+									r.parameterScope.addAttributes((args!=null?args.getText():null), ',');
+								}
+								if ( ret!=null )
+								{
+									r.returnScope = grammar.createReturnScope(name,ret.getToken());
+									r.returnScope.addAttributes((ret!=null?ret.getText():null), ',');
+								}
+								if ( throwsSpec5 != null )
+								{
+									for (String exception : throwsSpec5)
+										r.throwsSpec.add( exception );
+								}
+							}
+						}
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:250:4: ( ruleScopeSpec[r] )?
+			int alt22=2;
+			int LA22_0 = input.LA(1);
+			if ( (LA22_0==SCOPE) ) {
+				alt22=1;
+			}
+			switch (alt22) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:250:5: ruleScopeSpec[r]
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_rule568);
+					ruleScopeSpec(r);
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:251:4: ( ruleAction[r] )*
+			loop23:
+			while (true) {
+				int alt23=2;
+				int LA23_0 = input.LA(1);
+				if ( (LA23_0==AMPERSAND) ) {
+					alt23=1;
+				}
+
+				switch (alt23) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:251:5: ruleAction[r]
+					{
+					pushFollow(FOLLOW_ruleAction_in_rule577);
+					ruleAction(r);
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+				default :
+					break loop23;
+				}
+			}
+
+			if ( state.backtracking==0 ) { this.blockLevel=0; }
+			pushFollow(FOLLOW_block_in_rule592);
+			b=block();
+			state._fsp--;
+			if (state.failed) return retval;
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:254:4: ( exceptionGroup )?
+			int alt24=2;
+			int LA24_0 = input.LA(1);
+			if ( (LA24_0==CATCH||LA24_0==FINALLY) ) {
+				alt24=1;
+			}
+			switch (alt24) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:254:5: exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_rule598);
+					exceptionGroup();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			match(input,EOR,FOLLOW_EOR_in_rule605); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+							// copy rule options into the block AST, which is where
+							// the analysis will look for k option etc...
+							(b!=null?((GrammarAST)b.start):null).setBlockOptions(opts);
+						}
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rule"
+
+
+
+	// $ANTLR start "ruleAction"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:264:1: ruleAction[Rule r] : ^(amp= AMPERSAND id= ID a= ACTION ) ;
+	public final void ruleAction(Rule r) throws RecognitionException {
+		GrammarAST amp=null;
+		GrammarAST id=null;
+		GrammarAST a=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:265:2: ( ^(amp= AMPERSAND id= ID a= ACTION ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:265:4: ^(amp= AMPERSAND id= ID a= ACTION )
+			{
+			amp=(GrammarAST)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_ruleAction629); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_ruleAction633); if (state.failed) return;
+			a=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_ruleAction637); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {if (r!=null) r.defineNamedAction(amp,id,a);}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ruleAction"
+
+
+	public static class modifier_return extends TreeRuleReturnScope {
+		public String mod;
+	};
+
+
+	// $ANTLR start "modifier"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:268:1: modifier returns [String mod] : ( 'protected' | 'public' | 'private' | 'fragment' );
+	public final DefineGrammarItemsWalker.modifier_return modifier() throws RecognitionException {
+		DefineGrammarItemsWalker.modifier_return retval = new DefineGrammarItemsWalker.modifier_return();
+		retval.start = input.LT(1);
+
+
+			retval.mod = ((GrammarAST)retval.start).getToken().getText();
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:273:2: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) ) {
+				input.consume();
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "modifier"
+
+
+
+	// $ANTLR start "throwsSpec"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:279:1: throwsSpec returns [HashSet<String> exceptions] : ^( 'throws' ( ID )+ ) ;
+	public final HashSet<String> throwsSpec() throws RecognitionException {
+		HashSet<String> exceptions = null;
+
+
+		GrammarAST ID6=null;
+
+
+			exceptions = new HashSet<String>();
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:284:2: ( ^( 'throws' ( ID )+ ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:284:4: ^( 'throws' ( ID )+ )
+			{
+			match(input,THROWS,FOLLOW_THROWS_in_throwsSpec697); if (state.failed) return exceptions;
+			match(input, Token.DOWN, null); if (state.failed) return exceptions;
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:284:15: ( ID )+
+			int cnt25=0;
+			loop25:
+			while (true) {
+				int alt25=2;
+				int LA25_0 = input.LA(1);
+				if ( (LA25_0==ID) ) {
+					alt25=1;
+				}
+
+				switch (alt25) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:284:16: ID
+					{
+					ID6=(GrammarAST)match(input,ID,FOLLOW_ID_in_throwsSpec700); if (state.failed) return exceptions;
+					if ( state.backtracking==0 ) {exceptions.add((ID6!=null?ID6.getText():null));}
+					}
+					break;
+
+				default :
+					if ( cnt25 >= 1 ) break loop25;
+					if (state.backtracking>0) {state.failed=true; return exceptions;}
+					EarlyExitException eee = new EarlyExitException(25, input);
+					throw eee;
+				}
+				cnt25++;
+			}
+
+			match(input, Token.UP, null); if (state.failed) return exceptions;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return exceptions;
+	}
+	// $ANTLR end "throwsSpec"
+
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:287:1: ruleScopeSpec[Rule r] : ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* ) ;
+	public final void ruleScopeSpec(Rule r) throws RecognitionException {
+		AttributeScopeActions_stack.push(new AttributeScopeActions_scope());
+
+		GrammarAST attrs=null;
+		GrammarAST uses=null;
+
+
+			AttributeScopeActions_stack.peek().actions = new HashMap<GrammarAST, GrammarAST>();
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:293:2: ( ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:293:4: ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec730); if (state.failed) return;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return;
+				// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:294:4: ( ( attrScopeAction )* attrs= ACTION )?
+				int alt27=2;
+				int LA27_0 = input.LA(1);
+				if ( (LA27_0==ACTION||LA27_0==AMPERSAND) ) {
+					alt27=1;
+				}
+				switch (alt27) {
+					case 1 :
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:294:6: ( attrScopeAction )* attrs= ACTION
+						{
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:294:6: ( attrScopeAction )*
+						loop26:
+						while (true) {
+							int alt26=2;
+							int LA26_0 = input.LA(1);
+							if ( (LA26_0==AMPERSAND) ) {
+								alt26=1;
+							}
+
+							switch (alt26) {
+							case 1 :
+								// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:294:6: attrScopeAction
+								{
+								pushFollow(FOLLOW_attrScopeAction_in_ruleScopeSpec737);
+								attrScopeAction();
+								state._fsp--;
+								if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop26;
+							}
+						}
+
+						attrs=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec742); if (state.failed) return;
+						if ( state.backtracking==0 ) {
+											r.ruleScope = grammar.createRuleScope(r.name,attrs.getToken());
+											r.ruleScope.isDynamicRuleScope = true;
+											r.ruleScope.addAttributes((attrs!=null?attrs.getText():null), ';');
+											for (GrammarAST action : AttributeScopeActions_stack.peek().actions.keySet())
+												r.ruleScope.defineNamedAction(action, AttributeScopeActions_stack.peek().actions.get(action));
+										}
+						}
+						break;
+
+				}
+
+				// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:303:4: (uses= ID )*
+				loop28:
+				while (true) {
+					int alt28=2;
+					int LA28_0 = input.LA(1);
+					if ( (LA28_0==ID) ) {
+						alt28=1;
+					}
+
+					switch (alt28) {
+					case 1 :
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:303:6: uses= ID
+						{
+						uses=(GrammarAST)match(input,ID,FOLLOW_ID_in_ruleScopeSpec763); if (state.failed) return;
+						if ( state.backtracking==0 ) {
+											if ( grammar.getGlobalScope((uses!=null?uses.getText():null))==null ) {
+											ErrorManager.grammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
+											grammar,
+											uses.getToken(),
+											(uses!=null?uses.getText():null));
+											}
+											else {
+											if ( r.useScopes==null ) {r.useScopes=new ArrayList<String>();}
+											r.useScopes.add((uses!=null?uses.getText():null));
+											}
+										}
+						}
+						break;
+
+					default :
+						break loop28;
+					}
+				}
+
+				match(input, Token.UP, null); if (state.failed) return;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+			AttributeScopeActions_stack.pop();
+
+		}
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+
+	public static class block_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "block"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:320:1: block : ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB ) ;
+	public final DefineGrammarItemsWalker.block_return block() throws RecognitionException {
+		DefineGrammarItemsWalker.block_return retval = new DefineGrammarItemsWalker.block_return();
+		retval.start = input.LT(1);
+
+
+			// must run during backtracking
+			this.blockLevel++;
+			if ( blockLevel == 1 )
+				this.outerAltNum=1;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:328:2: ( ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:328:4: ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_block797); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:329:4: ( optionsSpec )?
+			int alt29=2;
+			int LA29_0 = input.LA(1);
+			if ( (LA29_0==OPTIONS) ) {
+				alt29=1;
+			}
+			switch (alt29) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:329:5: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_block803);
+					optionsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:330:4: ( blockAction )*
+			loop30:
+			while (true) {
+				int alt30=2;
+				int LA30_0 = input.LA(1);
+				if ( (LA30_0==AMPERSAND) ) {
+					alt30=1;
+				}
+
+				switch (alt30) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:330:5: blockAction
+					{
+					pushFollow(FOLLOW_blockAction_in_block811);
+					blockAction();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+				default :
+					break loop30;
+				}
+			}
+
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:331:4: ( alternative rewrite )+
+			int cnt31=0;
+			loop31:
+			while (true) {
+				int alt31=2;
+				int LA31_0 = input.LA(1);
+				if ( (LA31_0==ALT) ) {
+					alt31=1;
+				}
+
+				switch (alt31) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:331:6: alternative rewrite
+					{
+					pushFollow(FOLLOW_alternative_in_block820);
+					alternative();
+					state._fsp--;
+					if (state.failed) return retval;
+					pushFollow(FOLLOW_rewrite_in_block822);
+					rewrite();
+					state._fsp--;
+					if (state.failed) return retval;
+
+										if ( this.blockLevel == 1 )
+											this.outerAltNum++;
+									
+					}
+					break;
+
+				default :
+					if ( cnt31 >= 1 ) break loop31;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(31, input);
+					throw eee;
+				}
+				cnt31++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_block839); if (state.failed) return retval;
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+			 blockLevel--; 
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+
+	// $ANTLR start "blockAction"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:343:1: blockAction : ^(amp= AMPERSAND id= ID a= ACTION ) ;
+	public final void blockAction() throws RecognitionException {
+		GrammarAST amp=null;
+		GrammarAST id=null;
+		GrammarAST a=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:344:2: ( ^(amp= AMPERSAND id= ID a= ACTION ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:344:4: ^(amp= AMPERSAND id= ID a= ACTION )
+			{
+			amp=(GrammarAST)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_blockAction863); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_blockAction867); if (state.failed) return;
+			a=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_blockAction871); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "blockAction"
+
+
+
+	// $ANTLR start "alternative"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:347:1: alternative : ^( ALT ( element )+ EOA ) ;
+	public final void alternative() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:370:2: ( ^( ALT ( element )+ EOA ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:370:4: ^( ALT ( element )+ EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_alternative909); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:370:11: ( element )+
+			int cnt32=0;
+			loop32:
+			while (true) {
+				int alt32=2;
+				int LA32_0 = input.LA(1);
+				if ( (LA32_0==ACTION||(LA32_0 >= ASSIGN && LA32_0 <= BLOCK)||(LA32_0 >= CHAR_LITERAL && LA32_0 <= CHAR_RANGE)||LA32_0==CLOSURE||LA32_0==DOT||LA32_0==EPSILON||LA32_0==FORCED_ACTION||LA32_0==GATED_SEMPRED||LA32_0==NOT||LA32_0==OPTIONAL||(LA32_0 >= PLUS_ASSIGN && LA32_0 <= POSITIVE_CLOSURE)||LA32_0==RANGE||LA32_0==ROOT||LA32_0==RULE_REF||LA32_0==SEMPRED||(LA32_0 >= STRING_LITERAL && LA32_0 <= SYN_SEMPRED)||LA32_0==TOKEN_REF||LA32_0==TREE_BEGIN||LA32_0==WILDCARD) ) {
+					alt32=1;
+				}
+
+				switch (alt32) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:370:12: element
+					{
+					pushFollow(FOLLOW_element_in_alternative912);
+					element();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt32 >= 1 ) break loop32;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(32, input);
+					throw eee;
+				}
+				cnt32++;
+			}
+
+			match(input,EOA,FOLLOW_EOA_in_alternative916); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "alternative"
+
+
+
+	// $ANTLR start "exceptionGroup"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:373:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	public final void exceptionGroup() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:374:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt35=2;
+			int LA35_0 = input.LA(1);
+			if ( (LA35_0==CATCH) ) {
+				alt35=1;
+			}
+			else if ( (LA35_0==FINALLY) ) {
+				alt35=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 35, 0, input);
+				throw nvae;
+			}
+
+			switch (alt35) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:374:4: ( exceptionHandler )+ ( finallyClause )?
+					{
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:374:4: ( exceptionHandler )+
+					int cnt33=0;
+					loop33:
+					while (true) {
+						int alt33=2;
+						int LA33_0 = input.LA(1);
+						if ( (LA33_0==CATCH) ) {
+							alt33=1;
+						}
+
+						switch (alt33) {
+						case 1 :
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:374:6: exceptionHandler
+							{
+							pushFollow(FOLLOW_exceptionHandler_in_exceptionGroup931);
+							exceptionHandler();
+							state._fsp--;
+							if (state.failed) return;
+							}
+							break;
+
+						default :
+							if ( cnt33 >= 1 ) break loop33;
+							if (state.backtracking>0) {state.failed=true; return;}
+							EarlyExitException eee = new EarlyExitException(33, input);
+							throw eee;
+						}
+						cnt33++;
+					}
+
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:374:26: ( finallyClause )?
+					int alt34=2;
+					int LA34_0 = input.LA(1);
+					if ( (LA34_0==FINALLY) ) {
+						alt34=1;
+					}
+					switch (alt34) {
+						case 1 :
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:374:27: finallyClause
+							{
+							pushFollow(FOLLOW_finallyClause_in_exceptionGroup937);
+							finallyClause();
+							state._fsp--;
+							if (state.failed) return;
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:375:4: finallyClause
+					{
+					pushFollow(FOLLOW_finallyClause_in_exceptionGroup944);
+					finallyClause();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+
+	// $ANTLR start "exceptionHandler"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:378:1: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	public final void exceptionHandler() throws RecognitionException {
+		GrammarAST ACTION7=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:379:2: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:379:6: ^( 'catch' ARG_ACTION ACTION )
+			{
+			match(input,CATCH,FOLLOW_CATCH_in_exceptionHandler958); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_exceptionHandler960); if (state.failed) return;
+			ACTION7=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_exceptionHandler962); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {trackInlineAction(ACTION7);}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+
+	// $ANTLR start "finallyClause"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:382:1: finallyClause : ^( 'finally' ACTION ) ;
+	public final void finallyClause() throws RecognitionException {
+		GrammarAST ACTION8=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:383:2: ( ^( 'finally' ACTION ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:383:7: ^( 'finally' ACTION )
+			{
+			match(input,FINALLY,FOLLOW_FINALLY_in_finallyClause980); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			ACTION8=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_finallyClause982); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {trackInlineAction(ACTION8);}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "finallyClause"
+
+
+	public static class element_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "element"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:386:1: element : ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );
+	public final DefineGrammarItemsWalker.element_return element() throws RecognitionException {
+		DefineGrammarItemsWalker.element_return retval = new DefineGrammarItemsWalker.element_return();
+		retval.start = input.LT(1);
+
+		GrammarAST id=null;
+		GrammarAST id2=null;
+		GrammarAST act=null;
+		GrammarAST act2=null;
+		GrammarAST SEMPRED9=null;
+		GrammarAST GATED_SEMPRED10=null;
+		TreeRuleReturnScope el =null;
+		TreeRuleReturnScope a2 =null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:387:2: ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON )
+			int alt37=18;
+			switch ( input.LA(1) ) {
+			case ROOT:
+				{
+				alt37=1;
+				}
+				break;
+			case BANG:
+				{
+				alt37=2;
+				}
+				break;
+			case CHAR_LITERAL:
+			case DOT:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case WILDCARD:
+				{
+				alt37=3;
+				}
+				break;
+			case NOT:
+				{
+				alt37=4;
+				}
+				break;
+			case RANGE:
+				{
+				alt37=5;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt37=6;
+				}
+				break;
+			case ASSIGN:
+				{
+				alt37=7;
+				}
+				break;
+			case PLUS_ASSIGN:
+				{
+				alt37=8;
+				}
+				break;
+			case BLOCK:
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt37=9;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt37=10;
+				}
+				break;
+			case SYNPRED:
+				{
+				alt37=11;
+				}
+				break;
+			case ACTION:
+				{
+				alt37=12;
+				}
+				break;
+			case FORCED_ACTION:
+				{
+				alt37=13;
+				}
+				break;
+			case SEMPRED:
+				{
+				alt37=14;
+				}
+				break;
+			case SYN_SEMPRED:
+				{
+				alt37=15;
+				}
+				break;
+			case BACKTRACK_SEMPRED:
+				{
+				alt37=16;
+				}
+				break;
+			case GATED_SEMPRED:
+				{
+				alt37=17;
+				}
+				break;
+			case EPSILON:
+				{
+				alt37=18;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 37, 0, input);
+				throw nvae;
+			}
+			switch (alt37) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:387:6: ^( ROOT element )
+					{
+					match(input,ROOT,FOLLOW_ROOT_in_element999); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element1001);
+					element();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:388:6: ^( BANG element )
+					{
+					match(input,BANG,FOLLOW_BANG_in_element1010); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element1012);
+					element();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:389:6: atom[null]
+					{
+					pushFollow(FOLLOW_atom_in_element1020);
+					atom(null);
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:390:6: ^( NOT element )
+					{
+					match(input,NOT,FOLLOW_NOT_in_element1029); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element1031);
+					element();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:391:6: ^( RANGE atom[null] atom[null] )
+					{
+					match(input,RANGE,FOLLOW_RANGE_in_element1040); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_atom_in_element1042);
+					atom(null);
+					state._fsp--;
+					if (state.failed) return retval;
+					pushFollow(FOLLOW_atom_in_element1045);
+					atom(null);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:392:6: ^( CHAR_RANGE atom[null] atom[null] )
+					{
+					match(input,CHAR_RANGE,FOLLOW_CHAR_RANGE_in_element1055); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_atom_in_element1057);
+					atom(null);
+					state._fsp--;
+					if (state.failed) return retval;
+					pushFollow(FOLLOW_atom_in_element1060);
+					atom(null);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:393:4: ^( ASSIGN id= ID el= element )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_element1069); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					id=(GrammarAST)match(input,ID,FOLLOW_ID_in_element1073); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element1077);
+					el=element();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) {
+									GrammarAST e = (el!=null?((GrammarAST)el.start):null);
+									if ( e.getType()==ANTLRParser.ROOT || e.getType()==ANTLRParser.BANG )
+									{
+										e = (GrammarAST)e.getChild(0);
+									}
+									if ( e.getType()==RULE_REF)
+									{
+										grammar.defineRuleRefLabel(currentRuleName,id.getToken(),e);
+									}
+									else if ( e.getType()==WILDCARD && grammar.type==Grammar.TREE_PARSER )
+									{
+										grammar.defineWildcardTreeLabel(currentRuleName,id.getToken(),e);
+									}
+									else
+									{
+										grammar.defineTokenRefLabel(currentRuleName,id.getToken(),e);
+									}
+								}
+					}
+					break;
+				case 8 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:413:4: ^( PLUS_ASSIGN id2= ID a2= element )
+					{
+					match(input,PLUS_ASSIGN,FOLLOW_PLUS_ASSIGN_in_element1090); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					id2=(GrammarAST)match(input,ID,FOLLOW_ID_in_element1094); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element1098);
+					a2=element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+									GrammarAST a = (a2!=null?((GrammarAST)a2.start):null);
+									if ( a.getType()==ANTLRParser.ROOT || a.getType()==ANTLRParser.BANG )
+									{
+										a = (GrammarAST)a.getChild(0);
+									}
+									if ( a.getType()==RULE_REF )
+									{
+										grammar.defineRuleListLabel(currentRuleName,id2.getToken(),a);
+									}
+									else if ( a.getType() == WILDCARD && grammar.type == Grammar.TREE_PARSER )
+									{
+										grammar.defineWildcardTreeListLabel( currentRuleName, id2.getToken(), a );
+									}
+									else
+									{
+										grammar.defineTokenListLabel(currentRuleName,id2.getToken(),a);
+									}
+								}
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 9 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:434:6: ebnf
+					{
+					pushFollow(FOLLOW_ebnf_in_element1115);
+					ebnf();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+				case 10 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:435:6: tree_
+					{
+					pushFollow(FOLLOW_tree__in_element1122);
+					tree_();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+				case 11 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:436:6: ^( SYNPRED block )
+					{
+					match(input,SYNPRED,FOLLOW_SYNPRED_in_element1131); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_block_in_element1133);
+					block();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 12 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:437:6: act= ACTION
+					{
+					act=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_element1144); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								act.outerAltNum = this.outerAltNum;
+								trackInlineAction(act);
+							}
+					}
+					break;
+				case 13 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:442:6: act2= FORCED_ACTION
+					{
+					act2=(GrammarAST)match(input,FORCED_ACTION,FOLLOW_FORCED_ACTION_in_element1157); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								act2.outerAltNum = this.outerAltNum;
+								trackInlineAction(act2);
+							}
+					}
+					break;
+				case 14 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:447:6: SEMPRED
+					{
+					SEMPRED9=(GrammarAST)match(input,SEMPRED,FOLLOW_SEMPRED_in_element1168); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								SEMPRED9.outerAltNum = this.outerAltNum;
+								trackInlineAction(SEMPRED9);
+							}
+					}
+					break;
+				case 15 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:452:6: SYN_SEMPRED
+					{
+					match(input,SYN_SEMPRED,FOLLOW_SYN_SEMPRED_in_element1179); if (state.failed) return retval;
+					}
+					break;
+				case 16 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:453:6: ^( BACKTRACK_SEMPRED ( . )* )
+					{
+					match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_element1187); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:453:26: ( . )*
+						loop36:
+						while (true) {
+							int alt36=2;
+							int LA36_0 = input.LA(1);
+							if ( ((LA36_0 >= ACTION && LA36_0 <= XDIGIT)) ) {
+								alt36=1;
+							}
+							else if ( (LA36_0==UP) ) {
+								alt36=2;
+							}
+
+							switch (alt36) {
+							case 1 :
+								// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:453:26: .
+								{
+								matchAny(input); if (state.failed) return retval;
+								}
+								break;
+
+							default :
+								break loop36;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+				case 17 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:454:6: GATED_SEMPRED
+					{
+					GATED_SEMPRED10=(GrammarAST)match(input,GATED_SEMPRED,FOLLOW_GATED_SEMPRED_in_element1198); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								GATED_SEMPRED10.outerAltNum = this.outerAltNum;
+								trackInlineAction(GATED_SEMPRED10);
+							}
+					}
+					break;
+				case 18 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:459:6: EPSILON
+					{
+					match(input,EPSILON,FOLLOW_EPSILON_in_element1209); if (state.failed) return retval;
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "element"
+
+
+
+	// $ANTLR start "ebnf"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:462:1: ebnf : ( ( dotLoop )=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
+	public final void ebnf() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:463:2: ( ( dotLoop )=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
+			int alt38=5;
+			switch ( input.LA(1) ) {
+			case CLOSURE:
+				{
+				int LA38_1 = input.LA(2);
+				if ( (LA38_1==DOWN) ) {
+					int LA38_5 = input.LA(3);
+					if ( (LA38_5==BLOCK) ) {
+						int LA38_7 = input.LA(4);
+						if ( (LA38_7==DOWN) ) {
+							int LA38_9 = input.LA(5);
+							if ( (LA38_9==ALT) ) {
+								int LA38_11 = input.LA(6);
+								if ( (LA38_11==DOWN) ) {
+									int LA38_15 = input.LA(7);
+									if ( (LA38_15==WILDCARD) ) {
+										int LA38_17 = input.LA(8);
+										if ( (LA38_17==EOA) ) {
+											int LA38_19 = input.LA(9);
+											if ( (LA38_19==UP) ) {
+												int LA38_21 = input.LA(10);
+												if ( (LA38_21==EOB) ) {
+													int LA38_23 = input.LA(11);
+													if ( (LA38_23==UP) ) {
+														int LA38_25 = input.LA(12);
+														if ( (LA38_25==UP) ) {
+															int LA38_27 = input.LA(13);
+															if ( (synpred1_DefineGrammarItemsWalker()) ) {
+																alt38=1;
+															}
+															else if ( (true) ) {
+																alt38=4;
+															}
+
+														}
+
+														else {
+															if (state.backtracking>0) {state.failed=true; return;}
+															int nvaeMark = input.mark();
+															try {
+																for (int nvaeConsume = 0; nvaeConsume < 12 - 1; nvaeConsume++) {
+																	input.consume();
+																}
+																NoViableAltException nvae =
+																	new NoViableAltException("", 38, 25, input);
+																throw nvae;
+															} finally {
+																input.rewind(nvaeMark);
+															}
+														}
+
+													}
+
+													else {
+														if (state.backtracking>0) {state.failed=true; return;}
+														int nvaeMark = input.mark();
+														try {
+															for (int nvaeConsume = 0; nvaeConsume < 11 - 1; nvaeConsume++) {
+																input.consume();
+															}
+															NoViableAltException nvae =
+																new NoViableAltException("", 38, 23, input);
+															throw nvae;
+														} finally {
+															input.rewind(nvaeMark);
+														}
+													}
+
+												}
+												else if ( (LA38_21==ALT||LA38_21==REWRITES) ) {
+													alt38=4;
+												}
+
+												else {
+													if (state.backtracking>0) {state.failed=true; return;}
+													int nvaeMark = input.mark();
+													try {
+														for (int nvaeConsume = 0; nvaeConsume < 10 - 1; nvaeConsume++) {
+															input.consume();
+														}
+														NoViableAltException nvae =
+															new NoViableAltException("", 38, 21, input);
+														throw nvae;
+													} finally {
+														input.rewind(nvaeMark);
+													}
+												}
+
+											}
+
+											else {
+												if (state.backtracking>0) {state.failed=true; return;}
+												int nvaeMark = input.mark();
+												try {
+													for (int nvaeConsume = 0; nvaeConsume < 9 - 1; nvaeConsume++) {
+														input.consume();
+													}
+													NoViableAltException nvae =
+														new NoViableAltException("", 38, 19, input);
+													throw nvae;
+												} finally {
+													input.rewind(nvaeMark);
+												}
+											}
+
+										}
+										else if ( (LA38_17==ACTION||(LA38_17 >= ASSIGN && LA38_17 <= BLOCK)||(LA38_17 >= CHAR_LITERAL && LA38_17 <= CHAR_RANGE)||LA38_17==CLOSURE||LA38_17==DOT||LA38_17==EPSILON||LA38_17==FORCED_ACTION||LA38_17==GATED_SEMPRED||LA38_17==NOT||LA38_17==OPTIONAL||(LA38_17 >= PLUS_ASSIGN && LA38_17 <= POSITIVE_CLOSURE)||LA38_17==RANGE||LA38_17==ROOT||LA38_17==RULE_REF||LA38_17==SEMPRED||(LA38_17 >= STRING_LITERAL && LA38_17 <= SYN_SEMPRED)||LA38_17==TOKEN_REF||LA38_17==TREE_BEGIN||LA38_17==WILDCARD) ) {
+											alt38=4;
+										}
+
+										else {
+											if (state.backtracking>0) {state.failed=true; return;}
+											int nvaeMark = input.mark();
+											try {
+												for (int nvaeConsume = 0; nvaeConsume < 8 - 1; nvaeConsume++) {
+													input.consume();
+												}
+												NoViableAltException nvae =
+													new NoViableAltException("", 38, 17, input);
+												throw nvae;
+											} finally {
+												input.rewind(nvaeMark);
+											}
+										}
+
+									}
+									else if ( (LA38_15==ACTION||(LA38_15 >= ASSIGN && LA38_15 <= BLOCK)||(LA38_15 >= CHAR_LITERAL && LA38_15 <= CHAR_RANGE)||LA38_15==CLOSURE||LA38_15==DOT||LA38_15==EPSILON||LA38_15==FORCED_ACTION||LA38_15==GATED_SEMPRED||LA38_15==NOT||LA38_15==OPTIONAL||(LA38_15 >= PLUS_ASSIGN && LA38_15 <= POSITIVE_CLOSURE)||LA38_15==RANGE||LA38_15==ROOT||LA38_15==RULE_REF||LA38_15==SEMPRED||(LA38_15 >= STRING_LITERAL && LA38_15 <= SYN_SEMPRED)||LA38_15==TOKEN_REF||LA38_15==TREE_BEGIN) ) {
+										alt38=4;
+									}
+
+									else {
+										if (state.backtracking>0) {state.failed=true; return;}
+										int nvaeMark = input.mark();
+										try {
+											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
+												input.consume();
+											}
+											NoViableAltException nvae =
+												new NoViableAltException("", 38, 15, input);
+											throw nvae;
+										} finally {
+											input.rewind(nvaeMark);
+										}
+									}
+
+								}
+
+								else {
+									if (state.backtracking>0) {state.failed=true; return;}
+									int nvaeMark = input.mark();
+									try {
+										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
+											input.consume();
+										}
+										NoViableAltException nvae =
+											new NoViableAltException("", 38, 11, input);
+										throw nvae;
+									} finally {
+										input.rewind(nvaeMark);
+									}
+								}
+
+							}
+							else if ( (LA38_9==AMPERSAND||LA38_9==OPTIONS) ) {
+								alt38=4;
+							}
+
+							else {
+								if (state.backtracking>0) {state.failed=true; return;}
+								int nvaeMark = input.mark();
+								try {
+									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
+										input.consume();
+									}
+									NoViableAltException nvae =
+										new NoViableAltException("", 38, 9, input);
+									throw nvae;
+								} finally {
+									input.rewind(nvaeMark);
+								}
+							}
+
+						}
+
+						else {
+							if (state.backtracking>0) {state.failed=true; return;}
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 38, 7, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 38, 5, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 38, 1, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				int LA38_2 = input.LA(2);
+				if ( (LA38_2==DOWN) ) {
+					int LA38_6 = input.LA(3);
+					if ( (LA38_6==BLOCK) ) {
+						int LA38_8 = input.LA(4);
+						if ( (LA38_8==DOWN) ) {
+							int LA38_10 = input.LA(5);
+							if ( (LA38_10==ALT) ) {
+								int LA38_13 = input.LA(6);
+								if ( (LA38_13==DOWN) ) {
+									int LA38_16 = input.LA(7);
+									if ( (LA38_16==WILDCARD) ) {
+										int LA38_18 = input.LA(8);
+										if ( (LA38_18==EOA) ) {
+											int LA38_20 = input.LA(9);
+											if ( (LA38_20==UP) ) {
+												int LA38_22 = input.LA(10);
+												if ( (LA38_22==EOB) ) {
+													int LA38_24 = input.LA(11);
+													if ( (LA38_24==UP) ) {
+														int LA38_26 = input.LA(12);
+														if ( (LA38_26==UP) ) {
+															int LA38_28 = input.LA(13);
+															if ( (synpred1_DefineGrammarItemsWalker()) ) {
+																alt38=1;
+															}
+															else if ( (true) ) {
+																alt38=5;
+															}
+
+														}
+
+														else {
+															if (state.backtracking>0) {state.failed=true; return;}
+															int nvaeMark = input.mark();
+															try {
+																for (int nvaeConsume = 0; nvaeConsume < 12 - 1; nvaeConsume++) {
+																	input.consume();
+																}
+																NoViableAltException nvae =
+																	new NoViableAltException("", 38, 26, input);
+																throw nvae;
+															} finally {
+																input.rewind(nvaeMark);
+															}
+														}
+
+													}
+
+													else {
+														if (state.backtracking>0) {state.failed=true; return;}
+														int nvaeMark = input.mark();
+														try {
+															for (int nvaeConsume = 0; nvaeConsume < 11 - 1; nvaeConsume++) {
+																input.consume();
+															}
+															NoViableAltException nvae =
+																new NoViableAltException("", 38, 24, input);
+															throw nvae;
+														} finally {
+															input.rewind(nvaeMark);
+														}
+													}
+
+												}
+												else if ( (LA38_22==ALT||LA38_22==REWRITES) ) {
+													alt38=5;
+												}
+
+												else {
+													if (state.backtracking>0) {state.failed=true; return;}
+													int nvaeMark = input.mark();
+													try {
+														for (int nvaeConsume = 0; nvaeConsume < 10 - 1; nvaeConsume++) {
+															input.consume();
+														}
+														NoViableAltException nvae =
+															new NoViableAltException("", 38, 22, input);
+														throw nvae;
+													} finally {
+														input.rewind(nvaeMark);
+													}
+												}
+
+											}
+
+											else {
+												if (state.backtracking>0) {state.failed=true; return;}
+												int nvaeMark = input.mark();
+												try {
+													for (int nvaeConsume = 0; nvaeConsume < 9 - 1; nvaeConsume++) {
+														input.consume();
+													}
+													NoViableAltException nvae =
+														new NoViableAltException("", 38, 20, input);
+													throw nvae;
+												} finally {
+													input.rewind(nvaeMark);
+												}
+											}
+
+										}
+										else if ( (LA38_18==ACTION||(LA38_18 >= ASSIGN && LA38_18 <= BLOCK)||(LA38_18 >= CHAR_LITERAL && LA38_18 <= CHAR_RANGE)||LA38_18==CLOSURE||LA38_18==DOT||LA38_18==EPSILON||LA38_18==FORCED_ACTION||LA38_18==GATED_SEMPRED||LA38_18==NOT||LA38_18==OPTIONAL||(LA38_18 >= PLUS_ASSIGN && LA38_18 <= POSITIVE_CLOSURE)||LA38_18==RANGE||LA38_18==ROOT||LA38_18==RULE_REF||LA38_18==SEMPRED||(LA38_18 >= STRING_LITERAL && LA38_18 <= SYN_SEMPRED)||LA38_18==TOKEN_REF||LA38_18==TREE_BEGIN||LA38_18==WILDCARD) ) {
+											alt38=5;
+										}
+
+										else {
+											if (state.backtracking>0) {state.failed=true; return;}
+											int nvaeMark = input.mark();
+											try {
+												for (int nvaeConsume = 0; nvaeConsume < 8 - 1; nvaeConsume++) {
+													input.consume();
+												}
+												NoViableAltException nvae =
+													new NoViableAltException("", 38, 18, input);
+												throw nvae;
+											} finally {
+												input.rewind(nvaeMark);
+											}
+										}
+
+									}
+									else if ( (LA38_16==ACTION||(LA38_16 >= ASSIGN && LA38_16 <= BLOCK)||(LA38_16 >= CHAR_LITERAL && LA38_16 <= CHAR_RANGE)||LA38_16==CLOSURE||LA38_16==DOT||LA38_16==EPSILON||LA38_16==FORCED_ACTION||LA38_16==GATED_SEMPRED||LA38_16==NOT||LA38_16==OPTIONAL||(LA38_16 >= PLUS_ASSIGN && LA38_16 <= POSITIVE_CLOSURE)||LA38_16==RANGE||LA38_16==ROOT||LA38_16==RULE_REF||LA38_16==SEMPRED||(LA38_16 >= STRING_LITERAL && LA38_16 <= SYN_SEMPRED)||LA38_16==TOKEN_REF||LA38_16==TREE_BEGIN) ) {
+										alt38=5;
+									}
+
+									else {
+										if (state.backtracking>0) {state.failed=true; return;}
+										int nvaeMark = input.mark();
+										try {
+											for (int nvaeConsume = 0; nvaeConsume < 7 - 1; nvaeConsume++) {
+												input.consume();
+											}
+											NoViableAltException nvae =
+												new NoViableAltException("", 38, 16, input);
+											throw nvae;
+										} finally {
+											input.rewind(nvaeMark);
+										}
+									}
+
+								}
+
+								else {
+									if (state.backtracking>0) {state.failed=true; return;}
+									int nvaeMark = input.mark();
+									try {
+										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
+											input.consume();
+										}
+										NoViableAltException nvae =
+											new NoViableAltException("", 38, 13, input);
+										throw nvae;
+									} finally {
+										input.rewind(nvaeMark);
+									}
+								}
+
+							}
+							else if ( (LA38_10==AMPERSAND||LA38_10==OPTIONS) ) {
+								alt38=5;
+							}
+
+							else {
+								if (state.backtracking>0) {state.failed=true; return;}
+								int nvaeMark = input.mark();
+								try {
+									for (int nvaeConsume = 0; nvaeConsume < 5 - 1; nvaeConsume++) {
+										input.consume();
+									}
+									NoViableAltException nvae =
+										new NoViableAltException("", 38, 10, input);
+									throw nvae;
+								} finally {
+									input.rewind(nvaeMark);
+								}
+							}
+
+						}
+
+						else {
+							if (state.backtracking>0) {state.failed=true; return;}
+							int nvaeMark = input.mark();
+							try {
+								for (int nvaeConsume = 0; nvaeConsume < 4 - 1; nvaeConsume++) {
+									input.consume();
+								}
+								NoViableAltException nvae =
+									new NoViableAltException("", 38, 8, input);
+								throw nvae;
+							} finally {
+								input.rewind(nvaeMark);
+							}
+						}
+
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						int nvaeMark = input.mark();
+						try {
+							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
+								input.consume();
+							}
+							NoViableAltException nvae =
+								new NoViableAltException("", 38, 6, input);
+							throw nvae;
+						} finally {
+							input.rewind(nvaeMark);
+						}
+					}
+
+				}
+
+				else {
+					if (state.backtracking>0) {state.failed=true; return;}
+					int nvaeMark = input.mark();
+					try {
+						input.consume();
+						NoViableAltException nvae =
+							new NoViableAltException("", 38, 2, input);
+						throw nvae;
+					} finally {
+						input.rewind(nvaeMark);
+					}
+				}
+
+				}
+				break;
+			case BLOCK:
+				{
+				alt38=2;
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt38=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 38, 0, input);
+				throw nvae;
+			}
+			switch (alt38) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:463:4: ( dotLoop )=> dotLoop
+					{
+					pushFollow(FOLLOW_dotLoop_in_ebnf1227);
+					dotLoop();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:464:4: block
+					{
+					pushFollow(FOLLOW_block_in_ebnf1233);
+					block();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:465:4: ^( OPTIONAL block )
+					{
+					match(input,OPTIONAL,FOLLOW_OPTIONAL_in_ebnf1240); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_block_in_ebnf1242);
+					block();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:466:4: ^( CLOSURE block )
+					{
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_ebnf1251); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_block_in_ebnf1253);
+					block();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:467:4: ^( POSITIVE_CLOSURE block )
+					{
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_ebnf1262); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_block_in_ebnf1264);
+					block();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ebnf"
+
+
+	public static class dotLoop_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "dotLoop"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:472:1: dotLoop : ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) ) ;
+	public final DefineGrammarItemsWalker.dotLoop_return dotLoop() throws RecognitionException {
+		DefineGrammarItemsWalker.dotLoop_return retval = new DefineGrammarItemsWalker.dotLoop_return();
+		retval.start = input.LT(1);
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:473:2: ( ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:473:4: ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) )
+			{
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:473:4: ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) )
+			int alt39=2;
+			int LA39_0 = input.LA(1);
+			if ( (LA39_0==CLOSURE) ) {
+				alt39=1;
+			}
+			else if ( (LA39_0==POSITIVE_CLOSURE) ) {
+				alt39=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 39, 0, input);
+				throw nvae;
+			}
+
+			switch (alt39) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:473:6: ^( CLOSURE dotBlock )
+					{
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_dotLoop1283); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_dotBlock_in_dotLoop1285);
+					dotBlock();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:474:5: ^( POSITIVE_CLOSURE dotBlock )
+					{
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_dotLoop1295); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_dotBlock_in_dotLoop1297);
+					dotBlock();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+
+			}
+
+			if ( state.backtracking==0 ) {
+						GrammarAST block = (GrammarAST)((GrammarAST)retval.start).getChild(0);
+						Map<String, Object> opts = new HashMap<String, Object>();
+						opts.put("greedy", "false");
+						if ( grammar.type!=Grammar.LEXER )
+						{
+							// parser grammars assume k=1 for .* loops
+							// otherwise they (analysis?) look til EOF!
+							opts.put("k", 1);
+						}
+						block.setOptions(grammar,opts);
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "dotLoop"
+
+
+
+	// $ANTLR start "dotBlock"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:490:1: dotBlock : ^( BLOCK ^( ALT WILDCARD EOA ) EOB ) ;
+	public final void dotBlock() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:491:2: ( ^( BLOCK ^( ALT WILDCARD EOA ) EOB ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:491:4: ^( BLOCK ^( ALT WILDCARD EOA ) EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_dotBlock1320); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			match(input,ALT,FOLLOW_ALT_in_dotBlock1324); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			match(input,WILDCARD,FOLLOW_WILDCARD_in_dotBlock1326); if (state.failed) return;
+			match(input,EOA,FOLLOW_EOA_in_dotBlock1328); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			match(input,EOB,FOLLOW_EOB_in_dotBlock1332); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "dotBlock"
+
+
+
+	// $ANTLR start "tree_"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:494:1: tree_ : ^( TREE_BEGIN ( element )+ ) ;
+	public final void tree_() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:495:2: ( ^( TREE_BEGIN ( element )+ ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:495:4: ^( TREE_BEGIN ( element )+ )
+			{
+			match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_tree_1346); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:495:17: ( element )+
+			int cnt40=0;
+			loop40:
+			while (true) {
+				int alt40=2;
+				int LA40_0 = input.LA(1);
+				if ( (LA40_0==ACTION||(LA40_0 >= ASSIGN && LA40_0 <= BLOCK)||(LA40_0 >= CHAR_LITERAL && LA40_0 <= CHAR_RANGE)||LA40_0==CLOSURE||LA40_0==DOT||LA40_0==EPSILON||LA40_0==FORCED_ACTION||LA40_0==GATED_SEMPRED||LA40_0==NOT||LA40_0==OPTIONAL||(LA40_0 >= PLUS_ASSIGN && LA40_0 <= POSITIVE_CLOSURE)||LA40_0==RANGE||LA40_0==ROOT||LA40_0==RULE_REF||LA40_0==SEMPRED||(LA40_0 >= STRING_LITERAL && LA40_0 <= SYN_SEMPRED)||LA40_0==TOKEN_REF||LA40_0==TREE_BEGIN||LA40_0==WILDCARD) ) {
+					alt40=1;
+				}
+
+				switch (alt40) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:495:17: element
+					{
+					pushFollow(FOLLOW_element_in_tree_1348);
+					element();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt40 >= 1 ) break loop40;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(40, input);
+					throw eee;
+				}
+				cnt40++;
+			}
+
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tree_"
+
+
+
+	// $ANTLR start "atom"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:498:1: atom[GrammarAST scope_] : ( ^(rr= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom[$ID] ) );
+	public final void atom(GrammarAST scope_) throws RecognitionException {
+		GrammarAST rr=null;
+		GrammarAST rarg=null;
+		GrammarAST t=null;
+		GrammarAST targ=null;
+		GrammarAST c=null;
+		GrammarAST s=null;
+		GrammarAST ID11=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:499:2: ( ^(rr= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom[$ID] ) )
+			int alt43=6;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+				{
+				alt43=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt43=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt43=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt43=4;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt43=5;
+				}
+				break;
+			case DOT:
+				{
+				alt43=6;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 43, 0, input);
+				throw nvae;
+			}
+			switch (alt43) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:499:4: ^(rr= RULE_REF (rarg= ARG_ACTION )? )
+					{
+					rr=(GrammarAST)match(input,RULE_REF,FOLLOW_RULE_REF_in_atom1366); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:499:19: (rarg= ARG_ACTION )?
+						int alt41=2;
+						int LA41_0 = input.LA(1);
+						if ( (LA41_0==ARG_ACTION) ) {
+							alt41=1;
+						}
+						switch (alt41) {
+							case 1 :
+								// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:499:20: rarg= ARG_ACTION
+								{
+								rarg=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1371); if (state.failed) return;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					if ( state.backtracking==0 ) {
+								grammar.altReferencesRule( currentRuleName, scope_, rr, this.outerAltNum );
+								if ( rarg != null )
+								{
+									rarg.outerAltNum = this.outerAltNum;
+									trackInlineAction(rarg);
+								}
+							}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:508:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? )
+					{
+					t=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom1388); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:508:19: (targ= ARG_ACTION )?
+						int alt42=2;
+						int LA42_0 = input.LA(1);
+						if ( (LA42_0==ARG_ACTION) ) {
+							alt42=1;
+						}
+						switch (alt42) {
+							case 1 :
+								// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:508:20: targ= ARG_ACTION
+								{
+								targ=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1393); if (state.failed) return;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					if ( state.backtracking==0 ) {
+								if ( targ != null )
+								{
+									targ.outerAltNum = this.outerAltNum;
+									trackInlineAction(targ);
+								}
+								if ( grammar.type == Grammar.LEXER )
+								{
+									grammar.altReferencesRule( currentRuleName, scope_, t, this.outerAltNum );
+								}
+								else
+								{
+									grammar.altReferencesTokenID( currentRuleName, t, this.outerAltNum );
+								}
+							}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:524:4: c= CHAR_LITERAL
+					{
+					c=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom1409); if (state.failed) return;
+					if ( state.backtracking==0 ) {
+								if ( grammar.type != Grammar.LEXER )
+								{
+									Rule rule = grammar.getRule(currentRuleName);
+									if ( rule != null )
+										rule.trackTokenReferenceInAlt(c, outerAltNum);
+								}
+							}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:533:4: s= STRING_LITERAL
+					{
+					s=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_atom1420); if (state.failed) return;
+					if ( state.backtracking==0 ) {
+								if ( grammar.type != Grammar.LEXER )
+								{
+									Rule rule = grammar.getRule(currentRuleName);
+									if ( rule!=null )
+										rule.trackTokenReferenceInAlt(s, outerAltNum);
+								}
+							}
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:542:4: WILDCARD
+					{
+					match(input,WILDCARD,FOLLOW_WILDCARD_in_atom1430); if (state.failed) return;
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:543:4: ^( DOT ID atom[$ID] )
+					{
+					match(input,DOT,FOLLOW_DOT_in_atom1436); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					ID11=(GrammarAST)match(input,ID,FOLLOW_ID_in_atom1438); if (state.failed) return;
+					pushFollow(FOLLOW_atom_in_atom1440);
+					atom(ID11);
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "atom"
+
+
+
+	// $ANTLR start "ast_suffix"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:546:1: ast_suffix : ( ROOT | BANG );
+	public final void ast_suffix() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:547:2: ( ROOT | BANG )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:
+			{
+			if ( input.LA(1)==BANG||input.LA(1)==ROOT ) {
+				input.consume();
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ast_suffix"
+
+
+	public static class rewrite_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "rewrite"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:551:1: rewrite : ( ^( REWRITES ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* ) |);
+	public final DefineGrammarItemsWalker.rewrite_return rewrite() throws RecognitionException {
+		DefineGrammarItemsWalker.rewrite_return retval = new DefineGrammarItemsWalker.rewrite_return();
+		retval.start = input.LT(1);
+
+		GrammarAST pred=null;
+
+
+			// track top level REWRITES node, store stuff there
+			currentRewriteRule = ((GrammarAST)retval.start); // has to execute during backtracking
+			if ( state.backtracking == 0 )
+			{
+				if ( grammar.buildAST() )
+					currentRewriteRule.rewriteRefsDeep = new HashSet<GrammarAST>();
+			}
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:562:2: ( ^( REWRITES ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* ) |)
+			int alt46=2;
+			int LA46_0 = input.LA(1);
+			if ( (LA46_0==REWRITES) ) {
+				alt46=1;
+			}
+			else if ( (LA46_0==ALT||LA46_0==EOB) ) {
+				alt46=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 46, 0, input);
+				throw nvae;
+			}
+
+			switch (alt46) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:562:4: ^( REWRITES ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* )
+					{
+					match(input,REWRITES,FOLLOW_REWRITES_in_rewrite1477); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:563:4: ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )*
+						loop45:
+						while (true) {
+							int alt45=2;
+							int LA45_0 = input.LA(1);
+							if ( (LA45_0==REWRITE) ) {
+								alt45=1;
+							}
+
+							switch (alt45) {
+							case 1 :
+								// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:563:6: ^( REWRITE (pred= SEMPRED )? rewrite_alternative )
+								{
+								match(input,REWRITE,FOLLOW_REWRITE_in_rewrite1486); if (state.failed) return retval;
+								match(input, Token.DOWN, null); if (state.failed) return retval;
+								// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:563:17: (pred= SEMPRED )?
+								int alt44=2;
+								int LA44_0 = input.LA(1);
+								if ( (LA44_0==SEMPRED) ) {
+									alt44=1;
+								}
+								switch (alt44) {
+									case 1 :
+										// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:563:18: pred= SEMPRED
+										{
+										pred=(GrammarAST)match(input,SEMPRED,FOLLOW_SEMPRED_in_rewrite1491); if (state.failed) return retval;
+										}
+										break;
+
+								}
+
+								pushFollow(FOLLOW_rewrite_alternative_in_rewrite1495);
+								rewrite_alternative();
+								state._fsp--;
+								if (state.failed) return retval;
+								match(input, Token.UP, null); if (state.failed) return retval;
+
+								if ( state.backtracking==0 ) {
+													if ( pred != null )
+													{
+														pred.outerAltNum = this.outerAltNum;
+														trackInlineAction(pred);
+													}
+												}
+								}
+								break;
+
+							default :
+								break loop45;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:575:2: 
+					{
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite"
+
+
+	public static class rewrite_block_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "rewrite_block"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:577:1: rewrite_block : ^( BLOCK rewrite_alternative EOB ) ;
+	public final DefineGrammarItemsWalker.rewrite_block_return rewrite_block() throws RecognitionException {
+		DefineGrammarItemsWalker.rewrite_block_return retval = new DefineGrammarItemsWalker.rewrite_block_return();
+		retval.start = input.LT(1);
+
+
+			GrammarAST enclosingBlock = currentRewriteBlock;
+			if ( state.backtracking == 0 )
+			{
+				// don't do if guessing
+				currentRewriteBlock=((GrammarAST)retval.start); // pts to BLOCK node
+				currentRewriteBlock.rewriteRefsShallow = new HashSet<GrammarAST>();
+				currentRewriteBlock.rewriteRefsDeep = new HashSet<GrammarAST>();
+			}
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:589:2: ( ^( BLOCK rewrite_alternative EOB ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:589:6: ^( BLOCK rewrite_alternative EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_rewrite_block1539); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			pushFollow(FOLLOW_rewrite_alternative_in_rewrite_block1541);
+			rewrite_alternative();
+			state._fsp--;
+			if (state.failed) return retval;
+			match(input,EOB,FOLLOW_EOB_in_rewrite_block1543); if (state.failed) return retval;
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			if ( state.backtracking==0 ) {
+						// copy the element refs in this block to the surrounding block
+						if ( enclosingBlock != null )
+						{
+							for (GrammarAST item : currentRewriteBlock.rewriteRefsShallow)
+								enclosingBlock.rewriteRefsDeep.add( item );
+						}
+						//currentRewriteBlock = enclosingBlock; // restore old BLOCK ptr
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+			 currentRewriteBlock = enclosingBlock; 
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_block"
+
+
+
+	// $ANTLR start "rewrite_alternative"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:603:1: rewrite_alternative : ({...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA ) |{...}? => rewrite_template | ETC {...}?);
+	public final void rewrite_alternative() throws RecognitionException {
+		GrammarAST a=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:604:2: ({...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA ) |{...}? => rewrite_template | ETC {...}?)
+			int alt49=3;
+			int LA49_0 = input.LA(1);
+			if ( (LA49_0==ALT) && (((grammar.buildTemplate())||(grammar.buildAST())))) {
+				int LA49_1 = input.LA(2);
+				if ( (LA49_1==DOWN) && (((grammar.buildTemplate())||(grammar.buildAST())))) {
+					int LA49_4 = input.LA(3);
+					if ( (LA49_4==EPSILON) && (((grammar.buildTemplate())||(grammar.buildAST())))) {
+						int LA49_5 = input.LA(4);
+						if ( (LA49_5==EOA) && (((grammar.buildTemplate())||(grammar.buildAST())))) {
+							int LA49_7 = input.LA(5);
+							if ( (LA49_7==UP) && (((grammar.buildTemplate())||(grammar.buildAST())))) {
+								int LA49_8 = input.LA(6);
+								if ( ((grammar.buildAST())) ) {
+									alt49=1;
+								}
+								else if ( ((grammar.buildTemplate())) ) {
+									alt49=2;
+								}
+
+								else {
+									if (state.backtracking>0) {state.failed=true; return;}
+									int nvaeMark = input.mark();
+									try {
+										for (int nvaeConsume = 0; nvaeConsume < 6 - 1; nvaeConsume++) {
+											input.consume();
+										}
+										NoViableAltException nvae =
+											new NoViableAltException("", 49, 8, input);
+										throw nvae;
+									} finally {
+										input.rewind(nvaeMark);
+									}
+								}
+
+							}
+
+						}
+
+					}
+					else if ( (LA49_4==ACTION||LA49_4==CHAR_LITERAL||LA49_4==CLOSURE||LA49_4==LABEL||LA49_4==OPTIONAL||LA49_4==POSITIVE_CLOSURE||LA49_4==RULE_REF||LA49_4==STRING_LITERAL||LA49_4==TOKEN_REF||LA49_4==TREE_BEGIN) && ((grammar.buildAST()))) {
+						alt49=1;
+					}
+
+				}
+
+			}
+			else if ( (LA49_0==ACTION||LA49_0==TEMPLATE) && ((grammar.buildTemplate()))) {
+				alt49=2;
+			}
+			else if ( (LA49_0==ETC) ) {
+				alt49=3;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 49, 0, input);
+				throw nvae;
+			}
+
+			switch (alt49) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:604:4: {...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA )
+					{
+					if ( !((grammar.buildAST())) ) {
+						if (state.backtracking>0) {state.failed=true; return;}
+						throw new FailedPredicateException(input, "rewrite_alternative", "grammar.buildAST()");
+					}
+					a=(GrammarAST)match(input,ALT,FOLLOW_ALT_in_rewrite_alternative1575); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:604:38: ( ( rewrite_element )+ | EPSILON )
+					int alt48=2;
+					int LA48_0 = input.LA(1);
+					if ( (LA48_0==ACTION||LA48_0==CHAR_LITERAL||LA48_0==CLOSURE||LA48_0==LABEL||LA48_0==OPTIONAL||LA48_0==POSITIVE_CLOSURE||LA48_0==RULE_REF||LA48_0==STRING_LITERAL||LA48_0==TOKEN_REF||LA48_0==TREE_BEGIN) ) {
+						alt48=1;
+					}
+					else if ( (LA48_0==EPSILON) ) {
+						alt48=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 48, 0, input);
+						throw nvae;
+					}
+
+					switch (alt48) {
+						case 1 :
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:604:40: ( rewrite_element )+
+							{
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:604:40: ( rewrite_element )+
+							int cnt47=0;
+							loop47:
+							while (true) {
+								int alt47=2;
+								int LA47_0 = input.LA(1);
+								if ( (LA47_0==ACTION||LA47_0==CHAR_LITERAL||LA47_0==CLOSURE||LA47_0==LABEL||LA47_0==OPTIONAL||LA47_0==POSITIVE_CLOSURE||LA47_0==RULE_REF||LA47_0==STRING_LITERAL||LA47_0==TOKEN_REF||LA47_0==TREE_BEGIN) ) {
+									alt47=1;
+								}
+
+								switch (alt47) {
+								case 1 :
+									// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:604:42: rewrite_element
+									{
+									pushFollow(FOLLOW_rewrite_element_in_rewrite_alternative1581);
+									rewrite_element();
+									state._fsp--;
+									if (state.failed) return;
+									}
+									break;
+
+								default :
+									if ( cnt47 >= 1 ) break loop47;
+									if (state.backtracking>0) {state.failed=true; return;}
+									EarlyExitException eee = new EarlyExitException(47, input);
+									throw eee;
+								}
+								cnt47++;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:604:63: EPSILON
+							{
+							match(input,EPSILON,FOLLOW_EPSILON_in_rewrite_alternative1588); if (state.failed) return;
+							}
+							break;
+
+					}
+
+					match(input,EOA,FOLLOW_EOA_in_rewrite_alternative1592); if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:605:4: {...}? => rewrite_template
+					{
+					if ( !((grammar.buildTemplate())) ) {
+						if (state.backtracking>0) {state.failed=true; return;}
+						throw new FailedPredicateException(input, "rewrite_alternative", "grammar.buildTemplate()");
+					}
+					pushFollow(FOLLOW_rewrite_template_in_rewrite_alternative1603);
+					rewrite_template();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:606:4: ETC {...}?
+					{
+					match(input,ETC,FOLLOW_ETC_in_rewrite_alternative1608); if (state.failed) return;
+					if ( !((this.blockLevel==1)) ) {
+						if (state.backtracking>0) {state.failed=true; return;}
+						throw new FailedPredicateException(input, "rewrite_alternative", "this.blockLevel==1");
+					}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_alternative"
+
+
+
+	// $ANTLR start "rewrite_element"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:609:1: rewrite_element : ( rewrite_atom | rewrite_ebnf | rewrite_tree );
+	public final void rewrite_element() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:610:2: ( rewrite_atom | rewrite_ebnf | rewrite_tree )
+			int alt50=3;
+			switch ( input.LA(1) ) {
+			case ACTION:
+			case CHAR_LITERAL:
+			case LABEL:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt50=1;
+				}
+				break;
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt50=2;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt50=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 50, 0, input);
+				throw nvae;
+			}
+			switch (alt50) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:610:4: rewrite_atom
+					{
+					pushFollow(FOLLOW_rewrite_atom_in_rewrite_element1622);
+					rewrite_atom();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:611:4: rewrite_ebnf
+					{
+					pushFollow(FOLLOW_rewrite_ebnf_in_rewrite_element1627);
+					rewrite_ebnf();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:612:4: rewrite_tree
+					{
+					pushFollow(FOLLOW_rewrite_tree_in_rewrite_element1632);
+					rewrite_tree();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_element"
+
+
+
+	// $ANTLR start "rewrite_ebnf"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:615:1: rewrite_ebnf : ( ^( OPTIONAL rewrite_block ) | ^( CLOSURE rewrite_block ) | ^( POSITIVE_CLOSURE rewrite_block ) );
+	public final void rewrite_ebnf() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:616:2: ( ^( OPTIONAL rewrite_block ) | ^( CLOSURE rewrite_block ) | ^( POSITIVE_CLOSURE rewrite_block ) )
+			int alt51=3;
+			switch ( input.LA(1) ) {
+			case OPTIONAL:
+				{
+				alt51=1;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt51=2;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt51=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 51, 0, input);
+				throw nvae;
+			}
+			switch (alt51) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:616:4: ^( OPTIONAL rewrite_block )
+					{
+					match(input,OPTIONAL,FOLLOW_OPTIONAL_in_rewrite_ebnf1645); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_rewrite_block_in_rewrite_ebnf1647);
+					rewrite_block();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:617:4: ^( CLOSURE rewrite_block )
+					{
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_rewrite_ebnf1656); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_rewrite_block_in_rewrite_ebnf1658);
+					rewrite_block();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:618:4: ^( POSITIVE_CLOSURE rewrite_block )
+					{
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_rewrite_ebnf1667); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_rewrite_block_in_rewrite_ebnf1669);
+					rewrite_block();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_ebnf"
+
+
+
+	// $ANTLR start "rewrite_tree"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:621:1: rewrite_tree : ^( TREE_BEGIN rewrite_atom ( rewrite_element )* ) ;
+	public final void rewrite_tree() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:622:2: ( ^( TREE_BEGIN rewrite_atom ( rewrite_element )* ) )
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:622:6: ^( TREE_BEGIN rewrite_atom ( rewrite_element )* )
+			{
+			match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_rewrite_tree1686); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			pushFollow(FOLLOW_rewrite_atom_in_rewrite_tree1688);
+			rewrite_atom();
+			state._fsp--;
+			if (state.failed) return;
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:622:33: ( rewrite_element )*
+			loop52:
+			while (true) {
+				int alt52=2;
+				int LA52_0 = input.LA(1);
+				if ( (LA52_0==ACTION||LA52_0==CHAR_LITERAL||LA52_0==CLOSURE||LA52_0==LABEL||LA52_0==OPTIONAL||LA52_0==POSITIVE_CLOSURE||LA52_0==RULE_REF||LA52_0==STRING_LITERAL||LA52_0==TOKEN_REF||LA52_0==TREE_BEGIN) ) {
+					alt52=1;
+				}
+
+				switch (alt52) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:622:35: rewrite_element
+					{
+					pushFollow(FOLLOW_rewrite_element_in_rewrite_tree1692);
+					rewrite_element();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					break loop52;
+				}
+			}
+
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_tree"
+
+
+	public static class rewrite_atom_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "rewrite_atom"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:625:1: rewrite_atom : ( RULE_REF | ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL ) | LABEL | ACTION );
+	public final DefineGrammarItemsWalker.rewrite_atom_return rewrite_atom() throws RecognitionException {
+		DefineGrammarItemsWalker.rewrite_atom_return retval = new DefineGrammarItemsWalker.rewrite_atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST ARG_ACTION12=null;
+		GrammarAST ACTION13=null;
+
+
+			if ( state.backtracking == 0 )
+			{
+				Rule r = grammar.getRule(currentRuleName);
+				Set<String> tokenRefsInAlt = r.getTokenRefsInAlt(outerAltNum);
+				boolean imaginary =
+					((GrammarAST)retval.start).getType()==TOKEN_REF &&
+					!tokenRefsInAlt.contains(((GrammarAST)retval.start).getText());
+				if ( !imaginary && grammar.buildAST() &&
+					 (((GrammarAST)retval.start).getType()==RULE_REF ||
+					  ((GrammarAST)retval.start).getType()==LABEL ||
+					  ((GrammarAST)retval.start).getType()==TOKEN_REF ||
+					  ((GrammarAST)retval.start).getType()==CHAR_LITERAL ||
+					  ((GrammarAST)retval.start).getType()==STRING_LITERAL) )
+				{
+					// track per block and for entire rewrite rule
+					if ( currentRewriteBlock!=null )
+					{
+						currentRewriteBlock.rewriteRefsShallow.add(((GrammarAST)retval.start));
+						currentRewriteBlock.rewriteRefsDeep.add(((GrammarAST)retval.start));
+					}
+
+					//System.out.println("adding "+((GrammarAST)retval.start).getText()+" to "+currentRewriteRule.getText());
+					currentRewriteRule.rewriteRefsDeep.add(((GrammarAST)retval.start));
+				}
+			}
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:654:2: ( RULE_REF | ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL ) | LABEL | ACTION )
+			int alt55=4;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+				{
+				alt55=1;
+				}
+				break;
+			case CHAR_LITERAL:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt55=2;
+				}
+				break;
+			case LABEL:
+				{
+				alt55=3;
+				}
+				break;
+			case ACTION:
+				{
+				alt55=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 55, 0, input);
+				throw nvae;
+			}
+			switch (alt55) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:654:4: RULE_REF
+					{
+					match(input,RULE_REF,FOLLOW_RULE_REF_in_rewrite_atom1713); if (state.failed) return retval;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:655:4: ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL )
+					{
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:655:4: ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL )
+					int alt54=3;
+					switch ( input.LA(1) ) {
+					case TOKEN_REF:
+						{
+						alt54=1;
+						}
+						break;
+					case CHAR_LITERAL:
+						{
+						alt54=2;
+						}
+						break;
+					case STRING_LITERAL:
+						{
+						alt54=3;
+						}
+						break;
+					default:
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 54, 0, input);
+						throw nvae;
+					}
+					switch (alt54) {
+						case 1 :
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:655:6: ^( TOKEN_REF ( ARG_ACTION )? )
+							{
+							match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_rewrite_atom1723); if (state.failed) return retval;
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); if (state.failed) return retval;
+								// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:656:5: ( ARG_ACTION )?
+								int alt53=2;
+								int LA53_0 = input.LA(1);
+								if ( (LA53_0==ARG_ACTION) ) {
+									alt53=1;
+								}
+								switch (alt53) {
+									case 1 :
+										// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:656:7: ARG_ACTION
+										{
+										ARG_ACTION12=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rewrite_atom1731); if (state.failed) return retval;
+										if ( state.backtracking==0 ) {
+																ARG_ACTION12.outerAltNum = this.outerAltNum;
+																trackInlineAction(ARG_ACTION12);
+															}
+										}
+										break;
+
+								}
+
+								match(input, Token.UP, null); if (state.failed) return retval;
+							}
+
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:663:5: CHAR_LITERAL
+							{
+							match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_rewrite_atom1756); if (state.failed) return retval;
+							}
+							break;
+						case 3 :
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:664:5: STRING_LITERAL
+							{
+							match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_rewrite_atom1762); if (state.failed) return retval;
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:666:4: LABEL
+					{
+					match(input,LABEL,FOLLOW_LABEL_in_rewrite_atom1771); if (state.failed) return retval;
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:667:4: ACTION
+					{
+					ACTION13=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_rewrite_atom1776); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								ACTION13.outerAltNum = this.outerAltNum;
+								trackInlineAction(ACTION13);
+							}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_atom"
+
+
+
+	// $ANTLR start "rewrite_template"
+	// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:674:1: rewrite_template : ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION );
+	public final void rewrite_template() throws RecognitionException {
+		GrammarAST id=null;
+		GrammarAST ind=null;
+		GrammarAST arg=null;
+		GrammarAST a=null;
+		GrammarAST act=null;
+
+		try {
+			// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:675:2: ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION )
+			int alt59=3;
+			switch ( input.LA(1) ) {
+			case ALT:
+				{
+				alt59=1;
+				}
+				break;
+			case TEMPLATE:
+				{
+				alt59=2;
+				}
+				break;
+			case ACTION:
+				{
+				alt59=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 59, 0, input);
+				throw nvae;
+			}
+			switch (alt59) {
+				case 1 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:675:4: ^( ALT EPSILON EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_rewrite_template1793); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,EPSILON,FOLLOW_EPSILON_in_rewrite_template1795); if (state.failed) return;
+					match(input,EOA,FOLLOW_EOA_in_rewrite_template1797); if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:676:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
+					{
+					match(input,TEMPLATE,FOLLOW_TEMPLATE_in_rewrite_template1806); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:676:16: (id= ID |ind= ACTION )
+					int alt56=2;
+					int LA56_0 = input.LA(1);
+					if ( (LA56_0==ID) ) {
+						alt56=1;
+					}
+					else if ( (LA56_0==ACTION) ) {
+						alt56=2;
+					}
+
+					else {
+						if (state.backtracking>0) {state.failed=true; return;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 56, 0, input);
+						throw nvae;
+					}
+
+					switch (alt56) {
+						case 1 :
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:676:17: id= ID
+							{
+							id=(GrammarAST)match(input,ID,FOLLOW_ID_in_rewrite_template1811); if (state.failed) return;
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:676:23: ind= ACTION
+							{
+							ind=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template1815); if (state.failed) return;
+							}
+							break;
+
+					}
+
+					match(input,ARGLIST,FOLLOW_ARGLIST_in_rewrite_template1823); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:678:5: ( ^( ARG arg= ID a= ACTION ) )*
+						loop57:
+						while (true) {
+							int alt57=2;
+							int LA57_0 = input.LA(1);
+							if ( (LA57_0==ARG) ) {
+								alt57=1;
+							}
+
+							switch (alt57) {
+							case 1 :
+								// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:678:7: ^( ARG arg= ID a= ACTION )
+								{
+								match(input,ARG,FOLLOW_ARG_in_rewrite_template1833); if (state.failed) return;
+								match(input, Token.DOWN, null); if (state.failed) return;
+								arg=(GrammarAST)match(input,ID,FOLLOW_ID_in_rewrite_template1837); if (state.failed) return;
+								a=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template1841); if (state.failed) return;
+								match(input, Token.UP, null); if (state.failed) return;
+
+								if ( state.backtracking==0 ) {
+														a.outerAltNum = this.outerAltNum;
+														trackInlineAction(a);
+													}
+								}
+								break;
+
+							default :
+								break loop57;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					if ( state.backtracking==0 ) {
+									if ( ind!=null )
+									{
+										ind.outerAltNum = this.outerAltNum;
+										trackInlineAction(ind);
+									}
+								}
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:692:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
+					int alt58=2;
+					int LA58_0 = input.LA(1);
+					if ( ((LA58_0 >= DOUBLE_ANGLE_STRING_LITERAL && LA58_0 <= DOUBLE_QUOTE_STRING_LITERAL)) ) {
+						alt58=1;
+					}
+					switch (alt58) {
+						case 1 :
+							// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:
+							{
+							if ( (input.LA(1) >= DOUBLE_ANGLE_STRING_LITERAL && input.LA(1) <= DOUBLE_QUOTE_STRING_LITERAL) ) {
+								input.consume();
+								state.errorRecovery=false;
+								state.failed=false;
+							}
+							else {
+								if (state.backtracking>0) {state.failed=true; return;}
+								MismatchedSetException mse = new MismatchedSetException(null,input);
+								throw mse;
+							}
+							}
+							break;
+
+					}
+
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:696:4: act= ACTION
+					{
+					act=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_rewrite_template1898); if (state.failed) return;
+					if ( state.backtracking==0 ) {
+								act.outerAltNum = this.outerAltNum;
+								trackInlineAction(act);
+							}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite_template"
+
+	// $ANTLR start synpred1_DefineGrammarItemsWalker
+	public final void synpred1_DefineGrammarItemsWalker_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:463:4: ( dotLoop )
+		// org/antlr/grammar/v3/DefineGrammarItemsWalker.g:463:5: dotLoop
+		{
+		pushFollow(FOLLOW_dotLoop_in_synpred1_DefineGrammarItemsWalker1222);
+		dotLoop();
+		state._fsp--;
+		if (state.failed) return;
+		}
+
+	}
+	// $ANTLR end synpred1_DefineGrammarItemsWalker
+
+	// Delegated rules
+
+	public final boolean synpred1_DefineGrammarItemsWalker() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred1_DefineGrammarItemsWalker_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+
+	public static final BitSet FOLLOW_LEXER_GRAMMAR_in_grammar_76 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_82 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PARSER_GRAMMAR_in_grammar_91 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_96 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_GRAMMAR_in_grammar_105 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_110 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_COMBINED_GRAMMAR_in_grammar_119 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_124 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_attrScope149 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_attrScope153 = new BitSet(new long[]{0x0000000000000210L});
+	public static final BitSet FOLLOW_attrScopeAction_in_attrScope155 = new BitSet(new long[]{0x0000000000000210L});
+	public static final BitSet FOLLOW_ACTION_in_attrScope160 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_AMPERSAND_in_attrScopeAction178 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_attrScopeAction180 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_attrScopeAction182 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_grammarSpec200 = new BitSet(new long[]{0x0400200008000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_DOC_COMMENT_in_grammarSpec207 = new BitSet(new long[]{0x0400200000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_optionsSpec_in_grammarSpec215 = new BitSet(new long[]{0x0000200000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_delegateGrammars_in_grammarSpec223 = new BitSet(new long[]{0x0000000000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_tokensSpec_in_grammarSpec230 = new BitSet(new long[]{0x0000000000000200L,0x0000000000028002L});
+	public static final BitSet FOLLOW_attrScope_in_grammarSpec237 = new BitSet(new long[]{0x0000000000000200L,0x0000000000028002L});
+	public static final BitSet FOLLOW_actions_in_grammarSpec244 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008002L});
+	public static final BitSet FOLLOW_rules_in_grammarSpec250 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_action_in_actions263 = new BitSet(new long[]{0x0000000000000202L});
+	public static final BitSet FOLLOW_AMPERSAND_in_action285 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_action289 = new BitSet(new long[]{0x0000080000000010L});
+	public static final BitSet FOLLOW_ID_in_action298 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_action302 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ACTION_in_action318 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_OPTIONS_in_optionsSpec352 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_IMPORT_in_delegateGrammars369 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ASSIGN_in_delegateGrammars374 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_delegateGrammars376 = new BitSet(new long[]{0x0000080000000000L});
+	public static final BitSet FOLLOW_ID_in_delegateGrammars378 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_delegateGrammars383 = new BitSet(new long[]{0x0000080000002008L});
+	public static final BitSet FOLLOW_TOKENS_in_tokensSpec400 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_tokenSpec_in_tokensSpec402 = new BitSet(new long[]{0x0000000000002008L,0x0000000040000000L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec417 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ASSIGN_in_tokenSpec424 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_tokenSpec429 = new BitSet(new long[]{0x0000000000040000L,0x0000000001000000L});
+	public static final BitSet FOLLOW_set_in_tokenSpec434 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_rule_in_rules465 = new BitSet(new long[]{0x0000000000000002L,0x0000000000008002L});
+	public static final BitSet FOLLOW_PREC_RULE_in_rules470 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_RULE_in_rule495 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rule499 = new BitSet(new long[]{0x0000010000000400L,0x000000000000001CL});
+	public static final BitSet FOLLOW_modifier_in_rule507 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_ARG_in_rule516 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule521 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RET_in_rule532 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule537 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_throwsSpec_in_rule547 = new BitSet(new long[]{0x0400000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_optionsSpec_in_rule555 = new BitSet(new long[]{0x0000000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_rule568 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_ruleAction_in_rule577 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_block_in_rule592 = new BitSet(new long[]{0x0000004400020000L});
+	public static final BitSet FOLLOW_exceptionGroup_in_rule598 = new BitSet(new long[]{0x0000000400000000L});
+	public static final BitSet FOLLOW_EOR_in_rule605 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_AMPERSAND_in_ruleAction629 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_ruleAction633 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_ruleAction637 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_THROWS_in_throwsSpec697 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_throwsSpec700 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec730 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_attrScopeAction_in_ruleScopeSpec737 = new BitSet(new long[]{0x0000000000000210L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec742 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_ID_in_ruleScopeSpec763 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_block797 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_optionsSpec_in_block803 = new BitSet(new long[]{0x0000000000000300L});
+	public static final BitSet FOLLOW_blockAction_in_block811 = new BitSet(new long[]{0x0000000000000300L});
+	public static final BitSet FOLLOW_alternative_in_block820 = new BitSet(new long[]{0x0000000200000100L,0x0000000000001000L});
+	public static final BitSet FOLLOW_rewrite_in_block822 = new BitSet(new long[]{0x0000000200000100L});
+	public static final BitSet FOLLOW_EOB_in_block839 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_AMPERSAND_in_blockAction863 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_blockAction867 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_blockAction871 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_alternative909 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_alternative912 = new BitSet(new long[]{0x82800289202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_EOA_in_alternative916 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_exceptionHandler_in_exceptionGroup931 = new BitSet(new long[]{0x0000004000020002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup937 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup944 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CATCH_in_exceptionHandler958 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_exceptionHandler960 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_exceptionHandler962 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_FINALLY_in_finallyClause980 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_finallyClause982 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ROOT_in_element999 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element1001 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BANG_in_element1010 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element1012 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_atom_in_element1020 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_NOT_in_element1029 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element1031 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RANGE_in_element1040 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_atom_in_element1042 = new BitSet(new long[]{0x0000000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_element1045 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_RANGE_in_element1055 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_atom_in_element1057 = new BitSet(new long[]{0x0000000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_element1060 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ASSIGN_in_element1069 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element1073 = new BitSet(new long[]{0x82800288202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_element1077 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PLUS_ASSIGN_in_element1090 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element1094 = new BitSet(new long[]{0x82800288202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_element1098 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ebnf_in_element1115 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_tree__in_element1122 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYNPRED_in_element1131 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_element1133 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ACTION_in_element1144 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_FORCED_ACTION_in_element1157 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SEMPRED_in_element1168 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYN_SEMPRED_in_element1179 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_element1187 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_GATED_SEMPRED_in_element1198 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_EPSILON_in_element1209 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_dotLoop_in_ebnf1227 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_ebnf1233 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONAL_in_ebnf1240 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1242 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_ebnf1251 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1253 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_ebnf1262 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1264 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_dotLoop1283 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_dotBlock_in_dotLoop1285 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_dotLoop1295 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_dotBlock_in_dotLoop1297 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_dotBlock1320 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ALT_in_dotBlock1324 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_WILDCARD_in_dotBlock1326 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_dotBlock1328 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_EOB_in_dotBlock1332 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_tree_1346 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_tree_1348 = new BitSet(new long[]{0x82800288202DE018L,0x0000000547092041L});
+	public static final BitSet FOLLOW_RULE_REF_in_atom1366 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1371 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom1388 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1393 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom1409 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_atom1420 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_WILDCARD_in_atom1430 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOT_in_atom1436 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_atom1438 = new BitSet(new long[]{0x0000000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_atom1440 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_REWRITES_in_rewrite1477 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite1486 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_SEMPRED_in_rewrite1491 = new BitSet(new long[]{0x0000002000000110L,0x0000000008000000L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite1495 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_rewrite_block1539 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_alternative_in_rewrite_block1541 = new BitSet(new long[]{0x0000000200000000L});
+	public static final BitSet FOLLOW_EOB_in_rewrite_block1543 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_rewrite_alternative1575 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_element_in_rewrite_alternative1581 = new BitSet(new long[]{0x0201000100240010L,0x0000000141010001L});
+	public static final BitSet FOLLOW_EPSILON_in_rewrite_alternative1588 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_rewrite_alternative1592 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_rewrite_template_in_rewrite_alternative1603 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ETC_in_rewrite_alternative1608 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_atom_in_rewrite_element1622 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_ebnf_in_rewrite_element1627 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rewrite_tree_in_rewrite_element1632 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONAL_in_rewrite_ebnf1645 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_block_in_rewrite_ebnf1647 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_rewrite_ebnf1656 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_block_in_rewrite_ebnf1658 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_rewrite_ebnf1667 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_block_in_rewrite_ebnf1669 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_rewrite_tree1686 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rewrite_atom_in_rewrite_tree1688 = new BitSet(new long[]{0x0201000000240018L,0x0000000141010001L});
+	public static final BitSet FOLLOW_rewrite_element_in_rewrite_tree1692 = new BitSet(new long[]{0x0201000000240018L,0x0000000141010001L});
+	public static final BitSet FOLLOW_RULE_REF_in_rewrite_atom1713 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_rewrite_atom1723 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rewrite_atom1731 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_rewrite_atom1756 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_rewrite_atom1762 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_LABEL_in_rewrite_atom1771 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_atom1776 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ALT_in_rewrite_template1793 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_EPSILON_in_rewrite_template1795 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_rewrite_template1797 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TEMPLATE_in_rewrite_template1806 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rewrite_template1811 = new BitSet(new long[]{0x0000000000000800L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template1815 = new BitSet(new long[]{0x0000000000000800L});
+	public static final BitSet FOLLOW_ARGLIST_in_rewrite_template1823 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_in_rewrite_template1833 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rewrite_template1837 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template1841 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite_template1898 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_dotLoop_in_synpred1_DefineGrammarItemsWalker1222 = new BitSet(new long[]{0x0000000000000002L});
+}
--- tool/src/main/java/org/antlr/grammar/v3/LeftRecursiveRuleWalker.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/LeftRecursiveRuleWalker.java	2019-04-04 17:22:25.476181469 +0200
@@ -0,0 +1,3240 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/LeftRecursiveRuleWalker.g 2019-04-04 15:18:50
+
+package org.antlr.grammar.v3;
+
+import org.antlr.analysis.*;
+import org.antlr.misc.*;
+import org.antlr.tool.*;
+
+import org.antlr.runtime.BitSet;
+import org.antlr.runtime.DFA;
+
+
+import org.antlr.runtime.*;
+import org.antlr.runtime.tree.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+
+/** Find left-recursive rules */
+@SuppressWarnings("all")
+public class LeftRecursiveRuleWalker extends TreeParser {
+	public static final String[] tokenNames = new String[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", 
+		"ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", 
+		"ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", 
+		"CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", 
+		"COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", 
+		"DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", 
+		"EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", 
+		"GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", 
+		"LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", 
+		"NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", 
+		"OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", 
+		"PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", 
+		"RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", 
+		"RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", 
+		"SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", 
+		"TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", 
+		"WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public static final int EOF=-1;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int AMPERSAND=9;
+	public static final int ARG=10;
+	public static final int ARGLIST=11;
+	public static final int ARG_ACTION=12;
+	public static final int ASSIGN=13;
+	public static final int BACKTRACK_SEMPRED=14;
+	public static final int BANG=15;
+	public static final int BLOCK=16;
+	public static final int CATCH=17;
+	public static final int CHAR_LITERAL=18;
+	public static final int CHAR_RANGE=19;
+	public static final int CLOSE_ELEMENT_OPTION=20;
+	public static final int CLOSURE=21;
+	public static final int COLON=22;
+	public static final int COMBINED_GRAMMAR=23;
+	public static final int COMMA=24;
+	public static final int COMMENT=25;
+	public static final int DIGIT=26;
+	public static final int DOC_COMMENT=27;
+	public static final int DOLLAR=28;
+	public static final int DOT=29;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public static final int EOA=32;
+	public static final int EOB=33;
+	public static final int EOR=34;
+	public static final int EPSILON=35;
+	public static final int ESC=36;
+	public static final int ETC=37;
+	public static final int FINALLY=38;
+	public static final int FORCED_ACTION=39;
+	public static final int FRAGMENT=40;
+	public static final int GATED_SEMPRED=41;
+	public static final int GRAMMAR=42;
+	public static final int ID=43;
+	public static final int IMPLIES=44;
+	public static final int IMPORT=45;
+	public static final int INITACTION=46;
+	public static final int INT=47;
+	public static final int LABEL=48;
+	public static final int LEXER=49;
+	public static final int LEXER_GRAMMAR=50;
+	public static final int LPAREN=51;
+	public static final int ML_COMMENT=52;
+	public static final int NESTED_ACTION=53;
+	public static final int NESTED_ARG_ACTION=54;
+	public static final int NOT=55;
+	public static final int OPEN_ELEMENT_OPTION=56;
+	public static final int OPTIONAL=57;
+	public static final int OPTIONS=58;
+	public static final int OR=59;
+	public static final int PARSER=60;
+	public static final int PARSER_GRAMMAR=61;
+	public static final int PLUS=62;
+	public static final int PLUS_ASSIGN=63;
+	public static final int POSITIVE_CLOSURE=64;
+	public static final int PREC_RULE=65;
+	public static final int PRIVATE=66;
+	public static final int PROTECTED=67;
+	public static final int PUBLIC=68;
+	public static final int QUESTION=69;
+	public static final int RANGE=70;
+	public static final int RCURLY=71;
+	public static final int RECURSIVE_RULE_REF=72;
+	public static final int RET=73;
+	public static final int RETURNS=74;
+	public static final int REWRITE=75;
+	public static final int REWRITES=76;
+	public static final int ROOT=77;
+	public static final int RPAREN=78;
+	public static final int RULE=79;
+	public static final int RULE_REF=80;
+	public static final int SCOPE=81;
+	public static final int SEMI=82;
+	public static final int SEMPRED=83;
+	public static final int SL_COMMENT=84;
+	public static final int SRC=85;
+	public static final int STAR=86;
+	public static final int STRAY_BRACKET=87;
+	public static final int STRING_LITERAL=88;
+	public static final int SYNPRED=89;
+	public static final int SYN_SEMPRED=90;
+	public static final int TEMPLATE=91;
+	public static final int THROWS=92;
+	public static final int TOKENS=93;
+	public static final int TOKEN_REF=94;
+	public static final int TREE=95;
+	public static final int TREE_BEGIN=96;
+	public static final int TREE_GRAMMAR=97;
+	public static final int WILDCARD=98;
+	public static final int WS=99;
+	public static final int WS_LOOP=100;
+	public static final int WS_OPT=101;
+	public static final int XDIGIT=102;
+
+	// delegates
+	public TreeParser[] getDelegates() {
+		return new TreeParser[] {};
+	}
+
+	// delegators
+
+
+	public LeftRecursiveRuleWalker(TreeNodeStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public LeftRecursiveRuleWalker(TreeNodeStream input, RecognizerSharedState state) {
+		super(input, state);
+	}
+
+	@Override public String[] getTokenNames() { return LeftRecursiveRuleWalker.tokenNames; }
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/LeftRecursiveRuleWalker.g"; }
+
+
+	protected Grammar grammar;
+	private String ruleName;
+	private int outerAlt; // which outer alt of rule?
+	public int numAlts;  // how many alts for this rule total?
+
+	@Override
+	public void reportError(RecognitionException ex)
+	{
+	    Token token = null;
+	    if (ex instanceof MismatchedTokenException)
+	    {
+	        token = ((MismatchedTokenException)ex).token;
+	    }
+	    else if (ex instanceof NoViableAltException)
+	    {
+	        token = ((NoViableAltException)ex).token;
+	    }
+
+	    ErrorManager.syntaxError(
+	        ErrorManager.MSG_SYNTAX_ERROR,
+	        grammar,
+	        token,
+	        "assign.types: " + ex.toString(),
+	        ex);
+	}
+
+	public void setTokenPrec(GrammarAST t, int alt) {}
+	public void binaryAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {}
+	public void ternaryAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {}
+	public void prefixAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {}
+	public void suffixAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {}
+	public void otherAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {}
+	public void setReturnValues(GrammarAST t) {}
+
+
+
+	// $ANTLR start "optionsSpec"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:89:1: optionsSpec : ^( OPTIONS ( option )+ ) ;
+	public final void optionsSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:90:2: ( ^( OPTIONS ( option )+ ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:90:4: ^( OPTIONS ( option )+ )
+			{
+			match(input,OPTIONS,FOLLOW_OPTIONS_in_optionsSpec57); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:90:14: ( option )+
+			int cnt1=0;
+			loop1:
+			while (true) {
+				int alt1=2;
+				int LA1_0 = input.LA(1);
+				if ( (LA1_0==ASSIGN) ) {
+					alt1=1;
+				}
+
+				switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:90:14: option
+					{
+					pushFollow(FOLLOW_option_in_optionsSpec59);
+					option();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt1 >= 1 ) break loop1;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(1, input);
+					throw eee;
+				}
+				cnt1++;
+			}
+
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "optionsSpec"
+
+
+
+	// $ANTLR start "option"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:93:1: option : ^( ASSIGN ID optionValue ) ;
+	public final void option() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:94:2: ( ^( ASSIGN ID optionValue ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:94:4: ^( ASSIGN ID optionValue )
+			{
+			match(input,ASSIGN,FOLLOW_ASSIGN_in_option73); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			match(input,ID,FOLLOW_ID_in_option75); if (state.failed) return;
+			pushFollow(FOLLOW_optionValue_in_option77);
+			optionValue();
+			state._fsp--;
+			if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "option"
+
+
+
+	// $ANTLR start "optionValue"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:97:1: optionValue : ( ID | STRING_LITERAL | CHAR_LITERAL | INT );
+	public final void optionValue() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:98:2: ( ID | STRING_LITERAL | CHAR_LITERAL | INT )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:
+			{
+			if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==ID||input.LA(1)==INT||input.LA(1)==STRING_LITERAL ) {
+				input.consume();
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "optionValue"
+
+
+
+	// $ANTLR start "charSetElement"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:104:1: charSetElement : ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) );
+	public final void charSetElement() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:105:2: ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) )
+			int alt2=3;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				alt2=1;
+				}
+				break;
+			case OR:
+				{
+				alt2=2;
+				}
+				break;
+			case RANGE:
+				{
+				alt2=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 2, 0, input);
+				throw nvae;
+			}
+			switch (alt2) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:105:4: CHAR_LITERAL
+					{
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_charSetElement115); if (state.failed) return;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:106:4: ^( OR CHAR_LITERAL CHAR_LITERAL )
+					{
+					match(input,OR,FOLLOW_OR_in_charSetElement121); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_charSetElement123); if (state.failed) return;
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_charSetElement125); if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:107:4: ^( RANGE CHAR_LITERAL CHAR_LITERAL )
+					{
+					match(input,RANGE,FOLLOW_RANGE_in_charSetElement132); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_charSetElement134); if (state.failed) return;
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_charSetElement136); if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "charSetElement"
+
+
+
+	// $ANTLR start "rec_rule"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:111:1: public rec_rule[Grammar g] returns [boolean isLeftRec] : ^(r= RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ruleBlock ( exceptionGroup )? EOR ) ;
+	public final boolean rec_rule(Grammar g) throws RecognitionException {
+		boolean isLeftRec = false;
+
+
+		GrammarAST r=null;
+		GrammarAST id=null;
+		TreeRuleReturnScope ruleBlock1 =null;
+
+
+			grammar = g;
+			outerAlt = 1;
+
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:117:2: ( ^(r= RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ruleBlock ( exceptionGroup )? EOR ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:117:4: ^(r= RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ruleBlock ( exceptionGroup )? EOR )
+			{
+			r=(GrammarAST)match(input,RULE,FOLLOW_RULE_in_rec_rule164); if (state.failed) return isLeftRec;
+			match(input, Token.DOWN, null); if (state.failed) return isLeftRec;
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_rec_rule168); if (state.failed) return isLeftRec;
+			if ( state.backtracking==0 ) {ruleName=id.getText();}
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:118:4: ( modifier )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+			if ( (LA3_0==FRAGMENT||(LA3_0 >= PRIVATE && LA3_0 <= PUBLIC)) ) {
+				alt3=1;
+			}
+			switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:118:4: modifier
+					{
+					pushFollow(FOLLOW_modifier_in_rec_rule175);
+					modifier();
+					state._fsp--;
+					if (state.failed) return isLeftRec;
+					}
+					break;
+
+			}
+
+			match(input,ARG,FOLLOW_ARG_in_rec_rule182); if (state.failed) return isLeftRec;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return isLeftRec;
+				// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:119:10: ( ARG_ACTION )?
+				int alt4=2;
+				int LA4_0 = input.LA(1);
+				if ( (LA4_0==ARG_ACTION) ) {
+					alt4=1;
+				}
+				switch (alt4) {
+					case 1 :
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:119:10: ARG_ACTION
+						{
+						match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rec_rule184); if (state.failed) return isLeftRec;
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); if (state.failed) return isLeftRec;
+			}
+
+			match(input,RET,FOLLOW_RET_in_rec_rule192); if (state.failed) return isLeftRec;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return isLeftRec;
+				// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:120:10: ( ARG_ACTION )?
+				int alt5=2;
+				int LA5_0 = input.LA(1);
+				if ( (LA5_0==ARG_ACTION) ) {
+					alt5=1;
+				}
+				switch (alt5) {
+					case 1 :
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:120:10: ARG_ACTION
+						{
+						match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rec_rule194); if (state.failed) return isLeftRec;
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); if (state.failed) return isLeftRec;
+			}
+
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:121:4: ( optionsSpec )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+			if ( (LA6_0==OPTIONS) ) {
+				alt6=1;
+			}
+			switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:121:4: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_rec_rule201);
+					optionsSpec();
+					state._fsp--;
+					if (state.failed) return isLeftRec;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:122:4: ( ruleScopeSpec )?
+			int alt7=2;
+			int LA7_0 = input.LA(1);
+			if ( (LA7_0==SCOPE) ) {
+				alt7=1;
+			}
+			switch (alt7) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:122:4: ruleScopeSpec
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_rec_rule207);
+					ruleScopeSpec();
+					state._fsp--;
+					if (state.failed) return isLeftRec;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:123:4: ( ^( AMPERSAND ( . )* ) )*
+			loop9:
+			while (true) {
+				int alt9=2;
+				int LA9_0 = input.LA(1);
+				if ( (LA9_0==AMPERSAND) ) {
+					alt9=1;
+				}
+
+				switch (alt9) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:123:5: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_rec_rule215); if (state.failed) return isLeftRec;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return isLeftRec;
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:123:17: ( . )*
+						loop8:
+						while (true) {
+							int alt8=2;
+							int LA8_0 = input.LA(1);
+							if ( ((LA8_0 >= ACTION && LA8_0 <= XDIGIT)) ) {
+								alt8=1;
+							}
+							else if ( (LA8_0==UP) ) {
+								alt8=2;
+							}
+
+							switch (alt8) {
+							case 1 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:123:17: .
+								{
+								matchAny(input); if (state.failed) return isLeftRec;
+								}
+								break;
+
+							default :
+								break loop8;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return isLeftRec;
+					}
+
+					}
+					break;
+
+				default :
+					break loop9;
+				}
+			}
+
+			pushFollow(FOLLOW_ruleBlock_in_rec_rule226);
+			ruleBlock1=ruleBlock();
+			state._fsp--;
+			if (state.failed) return isLeftRec;
+			if ( state.backtracking==0 ) {isLeftRec = (ruleBlock1!=null?((LeftRecursiveRuleWalker.ruleBlock_return)ruleBlock1).isLeftRec:false);}
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:125:4: ( exceptionGroup )?
+			int alt10=2;
+			int LA10_0 = input.LA(1);
+			if ( (LA10_0==CATCH||LA10_0==FINALLY) ) {
+				alt10=1;
+			}
+			switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:125:4: exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_rec_rule233);
+					exceptionGroup();
+					state._fsp--;
+					if (state.failed) return isLeftRec;
+					}
+					break;
+
+			}
+
+			match(input,EOR,FOLLOW_EOR_in_rec_rule239); if (state.failed) return isLeftRec;
+			match(input, Token.UP, null); if (state.failed) return isLeftRec;
+
+			if ( state.backtracking==0 ) {if ((ruleBlock1!=null?((LeftRecursiveRuleWalker.ruleBlock_return)ruleBlock1).isLeftRec:false)) r.setType(PREC_RULE);}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return isLeftRec;
+	}
+	// $ANTLR end "rec_rule"
+
+
+
+	// $ANTLR start "modifier"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:131:1: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
+	public final void modifier() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:132:2: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) ) {
+				input.consume();
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "modifier"
+
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:138:1: ruleScopeSpec : ^( 'scope' ( ACTION )? ( ID )* ) ;
+	public final void ruleScopeSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:139:3: ( ^( 'scope' ( ACTION )? ( ID )* ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:139:5: ^( 'scope' ( ACTION )? ( ID )* )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec286); if (state.failed) return;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return;
+				// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:139:15: ( ACTION )?
+				int alt11=2;
+				int LA11_0 = input.LA(1);
+				if ( (LA11_0==ACTION) ) {
+					alt11=1;
+				}
+				switch (alt11) {
+					case 1 :
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:139:15: ACTION
+						{
+						match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec288); if (state.failed) return;
+						}
+						break;
+
+				}
+
+				// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:139:23: ( ID )*
+				loop12:
+				while (true) {
+					int alt12=2;
+					int LA12_0 = input.LA(1);
+					if ( (LA12_0==ID) ) {
+						alt12=1;
+					}
+
+					switch (alt12) {
+					case 1 :
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:139:23: ID
+						{
+						match(input,ID,FOLLOW_ID_in_ruleScopeSpec291); if (state.failed) return;
+						}
+						break;
+
+					default :
+						break loop12;
+					}
+				}
+
+				match(input, Token.UP, null); if (state.failed) return;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+
+	public static class ruleBlock_return extends TreeRuleReturnScope {
+		public boolean isLeftRec;
+	};
+
+
+	// $ANTLR start "ruleBlock"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:142:1: ruleBlock returns [boolean isLeftRec] : ^( BLOCK ( optionsSpec )? ( outerAlternative ( rewrite )? )+ EOB ) ;
+	public final LeftRecursiveRuleWalker.ruleBlock_return ruleBlock() throws RecognitionException {
+		LeftRecursiveRuleWalker.ruleBlock_return retval = new LeftRecursiveRuleWalker.ruleBlock_return();
+		retval.start = input.LT(1);
+
+		TreeRuleReturnScope outerAlternative2 =null;
+
+		boolean lr=false; this.numAlts = ((GrammarAST)retval.start).getChildCount();
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:144:2: ( ^( BLOCK ( optionsSpec )? ( outerAlternative ( rewrite )? )+ EOB ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:144:4: ^( BLOCK ( optionsSpec )? ( outerAlternative ( rewrite )? )+ EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_ruleBlock315); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:145:4: ( optionsSpec )?
+			int alt13=2;
+			int LA13_0 = input.LA(1);
+			if ( (LA13_0==OPTIONS) ) {
+				alt13=1;
+			}
+			switch (alt13) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:145:4: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_ruleBlock320);
+					optionsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:146:4: ( outerAlternative ( rewrite )? )+
+			int cnt15=0;
+			loop15:
+			while (true) {
+				int alt15=2;
+				int LA15_0 = input.LA(1);
+				if ( (LA15_0==ALT) ) {
+					alt15=1;
+				}
+
+				switch (alt15) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:146:6: outerAlternative ( rewrite )?
+					{
+					pushFollow(FOLLOW_outerAlternative_in_ruleBlock328);
+					outerAlternative2=outerAlternative();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {if ((outerAlternative2!=null?((LeftRecursiveRuleWalker.outerAlternative_return)outerAlternative2).isLeftRec:false)) retval.isLeftRec = true;}
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:148:5: ( rewrite )?
+					int alt14=2;
+					int LA14_0 = input.LA(1);
+					if ( (LA14_0==REWRITES) ) {
+						alt14=1;
+					}
+					switch (alt14) {
+						case 1 :
+							// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:148:5: rewrite
+							{
+							pushFollow(FOLLOW_rewrite_in_ruleBlock340);
+							rewrite();
+							state._fsp--;
+							if (state.failed) return retval;
+							}
+							break;
+
+					}
+
+					if ( state.backtracking==0 ) {outerAlt++;}
+					}
+					break;
+
+				default :
+					if ( cnt15 >= 1 ) break loop15;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(15, input);
+					throw eee;
+				}
+				cnt15++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_ruleBlock358); if (state.failed) return retval;
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleBlock"
+
+
+
+	// $ANTLR start "block"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:155:1: block : ^( BLOCK ( optionsSpec )? ( ^( ALT ( element )+ EOA ) ( rewrite )? )+ EOB ) ;
+	public final void block() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:156:5: ( ^( BLOCK ( optionsSpec )? ( ^( ALT ( element )+ EOA ) ( rewrite )? )+ EOB ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:156:9: ^( BLOCK ( optionsSpec )? ( ^( ALT ( element )+ EOA ) ( rewrite )? )+ EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_block381); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:157:13: ( optionsSpec )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+			if ( (LA16_0==OPTIONS) ) {
+				alt16=1;
+			}
+			switch (alt16) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:157:13: optionsSpec
+					{
+					pushFollow(FOLLOW_optionsSpec_in_block395);
+					optionsSpec();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:158:13: ( ^( ALT ( element )+ EOA ) ( rewrite )? )+
+			int cnt19=0;
+			loop19:
+			while (true) {
+				int alt19=2;
+				int LA19_0 = input.LA(1);
+				if ( (LA19_0==ALT) ) {
+					alt19=1;
+				}
+
+				switch (alt19) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:158:15: ^( ALT ( element )+ EOA ) ( rewrite )?
+					{
+					match(input,ALT,FOLLOW_ALT_in_block413); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:158:21: ( element )+
+					int cnt17=0;
+					loop17:
+					while (true) {
+						int alt17=2;
+						int LA17_0 = input.LA(1);
+						if ( (LA17_0==ACTION||(LA17_0 >= ASSIGN && LA17_0 <= BLOCK)||LA17_0==CHAR_LITERAL||LA17_0==CLOSURE||LA17_0==DOT||LA17_0==EPSILON||LA17_0==FORCED_ACTION||LA17_0==GATED_SEMPRED||LA17_0==NOT||LA17_0==OPTIONAL||(LA17_0 >= PLUS_ASSIGN && LA17_0 <= POSITIVE_CLOSURE)||LA17_0==RANGE||LA17_0==ROOT||LA17_0==RULE_REF||LA17_0==SEMPRED||(LA17_0 >= STRING_LITERAL && LA17_0 <= SYN_SEMPRED)||LA17_0==TOKEN_REF||LA17_0==TREE_BEGIN||LA17_0==WILDCARD) ) {
+							alt17=1;
+						}
+
+						switch (alt17) {
+						case 1 :
+							// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:158:21: element
+							{
+							pushFollow(FOLLOW_element_in_block415);
+							element();
+							state._fsp--;
+							if (state.failed) return;
+							}
+							break;
+
+						default :
+							if ( cnt17 >= 1 ) break loop17;
+							if (state.backtracking>0) {state.failed=true; return;}
+							EarlyExitException eee = new EarlyExitException(17, input);
+							throw eee;
+						}
+						cnt17++;
+					}
+
+					match(input,EOA,FOLLOW_EOA_in_block418); if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:158:35: ( rewrite )?
+					int alt18=2;
+					int LA18_0 = input.LA(1);
+					if ( (LA18_0==REWRITES) ) {
+						alt18=1;
+					}
+					switch (alt18) {
+						case 1 :
+							// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:158:35: rewrite
+							{
+							pushFollow(FOLLOW_rewrite_in_block421);
+							rewrite();
+							state._fsp--;
+							if (state.failed) return;
+							}
+							break;
+
+					}
+
+					}
+					break;
+
+				default :
+					if ( cnt19 >= 1 ) break loop19;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(19, input);
+					throw eee;
+				}
+				cnt19++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_block439); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "block"
+
+
+	public static class outerAlternative_return extends TreeRuleReturnScope {
+		public boolean isLeftRec;
+	};
+
+
+	// $ANTLR start "outerAlternative"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:164:1: outerAlternative returns [boolean isLeftRec] : ( ( binaryMultipleOp )=> binaryMultipleOp | ( binary )=> binary | ( ternary )=> ternary | ( prefix )=> prefix | ( suffix )=> suffix | ^( ALT ( element )+ EOA ) );
+	public final LeftRecursiveRuleWalker.outerAlternative_return outerAlternative() throws RecognitionException {
+		LeftRecursiveRuleWalker.outerAlternative_return retval = new LeftRecursiveRuleWalker.outerAlternative_return();
+		retval.start = input.LT(1);
+
+
+		GrammarAST rew = ((GrammarAST)retval.start).getNextSibling();
+		if (rew.getType() != REWRITES)
+			rew = null;
+
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:171:5: ( ( binaryMultipleOp )=> binaryMultipleOp | ( binary )=> binary | ( ternary )=> ternary | ( prefix )=> prefix | ( suffix )=> suffix | ^( ALT ( element )+ EOA ) )
+			int alt21=6;
+			int LA21_0 = input.LA(1);
+			if ( (LA21_0==ALT) ) {
+				int LA21_1 = input.LA(2);
+				if ( (synpred1_LeftRecursiveRuleWalker()) ) {
+					alt21=1;
+				}
+				else if ( (synpred2_LeftRecursiveRuleWalker()) ) {
+					alt21=2;
+				}
+				else if ( (synpred3_LeftRecursiveRuleWalker()) ) {
+					alt21=3;
+				}
+				else if ( (synpred4_LeftRecursiveRuleWalker()) ) {
+					alt21=4;
+				}
+				else if ( (synpred5_LeftRecursiveRuleWalker()) ) {
+					alt21=5;
+				}
+				else if ( (true) ) {
+					alt21=6;
+				}
+
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 21, 0, input);
+				throw nvae;
+			}
+
+			switch (alt21) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:171:9: ( binaryMultipleOp )=> binaryMultipleOp
+					{
+					pushFollow(FOLLOW_binaryMultipleOp_in_outerAlternative488);
+					binaryMultipleOp();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {binaryAlt(((GrammarAST)retval.start), rew, outerAlt); retval.isLeftRec =true;}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:173:9: ( binary )=> binary
+					{
+					pushFollow(FOLLOW_binary_in_outerAlternative544);
+					binary();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {binaryAlt(((GrammarAST)retval.start), rew, outerAlt); retval.isLeftRec =true;}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:175:9: ( ternary )=> ternary
+					{
+					pushFollow(FOLLOW_ternary_in_outerAlternative606);
+					ternary();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {ternaryAlt(((GrammarAST)retval.start), rew, outerAlt); retval.isLeftRec =true;}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:177:9: ( prefix )=> prefix
+					{
+					pushFollow(FOLLOW_prefix_in_outerAlternative662);
+					prefix();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {prefixAlt(((GrammarAST)retval.start), rew, outerAlt);}
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:179:9: ( suffix )=> suffix
+					{
+					pushFollow(FOLLOW_suffix_in_outerAlternative718);
+					suffix();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {suffixAlt(((GrammarAST)retval.start), rew, outerAlt); retval.isLeftRec =true;}
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:181:9: ^( ALT ( element )+ EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_outerAlternative760); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:181:15: ( element )+
+					int cnt20=0;
+					loop20:
+					while (true) {
+						int alt20=2;
+						int LA20_0 = input.LA(1);
+						if ( (LA20_0==ACTION||(LA20_0 >= ASSIGN && LA20_0 <= BLOCK)||LA20_0==CHAR_LITERAL||LA20_0==CLOSURE||LA20_0==DOT||LA20_0==EPSILON||LA20_0==FORCED_ACTION||LA20_0==GATED_SEMPRED||LA20_0==NOT||LA20_0==OPTIONAL||(LA20_0 >= PLUS_ASSIGN && LA20_0 <= POSITIVE_CLOSURE)||LA20_0==RANGE||LA20_0==ROOT||LA20_0==RULE_REF||LA20_0==SEMPRED||(LA20_0 >= STRING_LITERAL && LA20_0 <= SYN_SEMPRED)||LA20_0==TOKEN_REF||LA20_0==TREE_BEGIN||LA20_0==WILDCARD) ) {
+							alt20=1;
+						}
+
+						switch (alt20) {
+						case 1 :
+							// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:181:15: element
+							{
+							pushFollow(FOLLOW_element_in_outerAlternative762);
+							element();
+							state._fsp--;
+							if (state.failed) return retval;
+							}
+							break;
+
+						default :
+							if ( cnt20 >= 1 ) break loop20;
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							EarlyExitException eee = new EarlyExitException(20, input);
+							throw eee;
+						}
+						cnt20++;
+					}
+
+					match(input,EOA,FOLLOW_EOA_in_outerAlternative765); if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) {otherAlt(((GrammarAST)retval.start), rew, outerAlt);}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "outerAlternative"
+
+
+
+	// $ANTLR start "binary"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:185:1: binary : ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse EOA ) ;
+	public final void binary() throws RecognitionException {
+		GrammarAST op =null;
+
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:186:2: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse EOA ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:186:4: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_binary814); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:186:11: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+			if ( (LA23_0==BACKTRACK_SEMPRED) ) {
+				alt23=1;
+			}
+			switch (alt23) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:186:12: ^( BACKTRACK_SEMPRED ( . )* )
+					{
+					match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_binary818); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:186:32: ( . )*
+						loop22:
+						while (true) {
+							int alt22=2;
+							int LA22_0 = input.LA(1);
+							if ( ((LA22_0 >= ACTION && LA22_0 <= XDIGIT)) ) {
+								alt22=1;
+							}
+							else if ( (LA22_0==UP) ) {
+								alt22=2;
+							}
+
+							switch (alt22) {
+							case 1 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:186:32: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop22;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_recurseNoLabel_in_binary826);
+			recurseNoLabel();
+			state._fsp--;
+			if (state.failed) return;
+			pushFollow(FOLLOW_token_in_binary830);
+			op=token();
+			state._fsp--;
+			if (state.failed) return;
+			pushFollow(FOLLOW_recurse_in_binary832);
+			recurse();
+			state._fsp--;
+			if (state.failed) return;
+			match(input,EOA,FOLLOW_EOA_in_binary834); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {setTokenPrec(op, outerAlt);}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "binary"
+
+
+
+	// $ANTLR start "binaryMultipleOp"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:189:1: binaryMultipleOp : ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ^( BLOCK ( ^( ALT op= token EOA ) )+ EOB ) recurse EOA ) ;
+	public final void binaryMultipleOp() throws RecognitionException {
+		GrammarAST op =null;
+
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:190:2: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ^( BLOCK ( ^( ALT op= token EOA ) )+ EOB ) recurse EOA ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:190:4: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ^( BLOCK ( ^( ALT op= token EOA ) )+ EOB ) recurse EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_binaryMultipleOp851); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:190:11: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
+			int alt25=2;
+			int LA25_0 = input.LA(1);
+			if ( (LA25_0==BACKTRACK_SEMPRED) ) {
+				alt25=1;
+			}
+			switch (alt25) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:190:12: ^( BACKTRACK_SEMPRED ( . )* )
+					{
+					match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_binaryMultipleOp855); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:190:32: ( . )*
+						loop24:
+						while (true) {
+							int alt24=2;
+							int LA24_0 = input.LA(1);
+							if ( ((LA24_0 >= ACTION && LA24_0 <= XDIGIT)) ) {
+								alt24=1;
+							}
+							else if ( (LA24_0==UP) ) {
+								alt24=2;
+							}
+
+							switch (alt24) {
+							case 1 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:190:32: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop24;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_recurseNoLabel_in_binaryMultipleOp863);
+			recurseNoLabel();
+			state._fsp--;
+			if (state.failed) return;
+			match(input,BLOCK,FOLLOW_BLOCK_in_binaryMultipleOp867); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:190:62: ( ^( ALT op= token EOA ) )+
+			int cnt26=0;
+			loop26:
+			while (true) {
+				int alt26=2;
+				int LA26_0 = input.LA(1);
+				if ( (LA26_0==ALT) ) {
+					alt26=1;
+				}
+
+				switch (alt26) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:190:64: ^( ALT op= token EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_binaryMultipleOp873); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_token_in_binaryMultipleOp877);
+					op=token();
+					state._fsp--;
+					if (state.failed) return;
+					match(input,EOA,FOLLOW_EOA_in_binaryMultipleOp879); if (state.failed) return;
+					if ( state.backtracking==0 ) {setTokenPrec(op, outerAlt);}
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+				default :
+					if ( cnt26 >= 1 ) break loop26;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(26, input);
+					throw eee;
+				}
+				cnt26++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_binaryMultipleOp888); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			pushFollow(FOLLOW_recurse_in_binaryMultipleOp892);
+			recurse();
+			state._fsp--;
+			if (state.failed) return;
+			match(input,EOA,FOLLOW_EOA_in_binaryMultipleOp894); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "binaryMultipleOp"
+
+
+
+	// $ANTLR start "ternary"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:193:1: ternary : ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse token recurse EOA ) ;
+	public final void ternary() throws RecognitionException {
+		GrammarAST op =null;
+
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:194:2: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse token recurse EOA ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:194:4: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse token recurse EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_ternary909); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:194:11: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
+			int alt28=2;
+			int LA28_0 = input.LA(1);
+			if ( (LA28_0==BACKTRACK_SEMPRED) ) {
+				alt28=1;
+			}
+			switch (alt28) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:194:12: ^( BACKTRACK_SEMPRED ( . )* )
+					{
+					match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_ternary913); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:194:32: ( . )*
+						loop27:
+						while (true) {
+							int alt27=2;
+							int LA27_0 = input.LA(1);
+							if ( ((LA27_0 >= ACTION && LA27_0 <= XDIGIT)) ) {
+								alt27=1;
+							}
+							else if ( (LA27_0==UP) ) {
+								alt27=2;
+							}
+
+							switch (alt27) {
+							case 1 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:194:32: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop27;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_recurseNoLabel_in_ternary921);
+			recurseNoLabel();
+			state._fsp--;
+			if (state.failed) return;
+			pushFollow(FOLLOW_token_in_ternary925);
+			op=token();
+			state._fsp--;
+			if (state.failed) return;
+			pushFollow(FOLLOW_recurse_in_ternary927);
+			recurse();
+			state._fsp--;
+			if (state.failed) return;
+			pushFollow(FOLLOW_token_in_ternary929);
+			token();
+			state._fsp--;
+			if (state.failed) return;
+			pushFollow(FOLLOW_recurse_in_ternary931);
+			recurse();
+			state._fsp--;
+			if (state.failed) return;
+			match(input,EOA,FOLLOW_EOA_in_ternary933); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			if ( state.backtracking==0 ) {setTokenPrec(op, outerAlt);}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ternary"
+
+
+
+	// $ANTLR start "prefix"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:197:1: prefix : ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? ({...}? element )+ recurse EOA ) ;
+	public final void prefix() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:197:8: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? ({...}? element )+ recurse EOA ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:197:10: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? ({...}? element )+ recurse EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_prefix949); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:197:17: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
+			int alt30=2;
+			int LA30_0 = input.LA(1);
+			if ( (LA30_0==BACKTRACK_SEMPRED) ) {
+				int LA30_1 = input.LA(2);
+				if ( (LA30_1==DOWN) ) {
+					alt30=1;
+				}
+			}
+			switch (alt30) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:197:18: ^( BACKTRACK_SEMPRED ( . )* )
+					{
+					match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_prefix953); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:197:38: ( . )*
+						loop29:
+						while (true) {
+							int alt29=2;
+							int LA29_0 = input.LA(1);
+							if ( ((LA29_0 >= ACTION && LA29_0 <= XDIGIT)) ) {
+								alt29=1;
+							}
+							else if ( (LA29_0==UP) ) {
+								alt29=2;
+							}
+
+							switch (alt29) {
+							case 1 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:197:38: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop29;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			if ( state.backtracking==0 ) {setTokenPrec((GrammarAST)input.LT(1), outerAlt);}
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:197:95: ({...}? element )+
+			int cnt31=0;
+			loop31:
+			while (true) {
+				int alt31=2;
+				switch ( input.LA(1) ) {
+				case ASSIGN:
+					{
+					int LA31_1 = input.LA(2);
+					if ( (LA31_1==DOWN) ) {
+						int LA31_5 = input.LA(3);
+						if ( (LA31_5==ID) ) {
+							int LA31_8 = input.LA(4);
+							if ( (LA31_8==RULE_REF) ) {
+								int LA31_10 = input.LA(5);
+								if ( (LA31_10==DOWN) ) {
+									alt31=1;
+								}
+
+							}
+							else if ( (LA31_8==ACTION||(LA31_8 >= ASSIGN && LA31_8 <= BLOCK)||LA31_8==CHAR_LITERAL||LA31_8==CLOSURE||LA31_8==DOT||LA31_8==EPSILON||LA31_8==FORCED_ACTION||LA31_8==GATED_SEMPRED||LA31_8==NOT||LA31_8==OPTIONAL||(LA31_8 >= PLUS_ASSIGN && LA31_8 <= POSITIVE_CLOSURE)||LA31_8==RANGE||LA31_8==ROOT||LA31_8==SEMPRED||(LA31_8 >= STRING_LITERAL && LA31_8 <= SYN_SEMPRED)||LA31_8==TOKEN_REF||LA31_8==TREE_BEGIN||LA31_8==WILDCARD) ) {
+								alt31=1;
+							}
+
+						}
+
+					}
+
+					}
+					break;
+				case PLUS_ASSIGN:
+					{
+					int LA31_2 = input.LA(2);
+					if ( (LA31_2==DOWN) ) {
+						int LA31_6 = input.LA(3);
+						if ( (LA31_6==ID) ) {
+							int LA31_9 = input.LA(4);
+							if ( (LA31_9==RULE_REF) ) {
+								int LA31_11 = input.LA(5);
+								if ( (LA31_11==DOWN) ) {
+									alt31=1;
+								}
+
+							}
+							else if ( (LA31_9==ACTION||(LA31_9 >= ASSIGN && LA31_9 <= BLOCK)||LA31_9==CHAR_LITERAL||LA31_9==CLOSURE||LA31_9==DOT||LA31_9==EPSILON||LA31_9==FORCED_ACTION||LA31_9==GATED_SEMPRED||LA31_9==NOT||LA31_9==OPTIONAL||(LA31_9 >= PLUS_ASSIGN && LA31_9 <= POSITIVE_CLOSURE)||LA31_9==RANGE||LA31_9==ROOT||LA31_9==SEMPRED||(LA31_9 >= STRING_LITERAL && LA31_9 <= SYN_SEMPRED)||LA31_9==TOKEN_REF||LA31_9==TREE_BEGIN||LA31_9==WILDCARD) ) {
+								alt31=1;
+							}
+
+						}
+
+					}
+
+					}
+					break;
+				case RULE_REF:
+					{
+					int LA31_3 = input.LA(2);
+					if ( (LA31_3==DOWN) ) {
+						alt31=1;
+					}
+
+					}
+					break;
+				case ACTION:
+				case BACKTRACK_SEMPRED:
+				case BANG:
+				case BLOCK:
+				case CHAR_LITERAL:
+				case CLOSURE:
+				case DOT:
+				case EPSILON:
+				case FORCED_ACTION:
+				case GATED_SEMPRED:
+				case NOT:
+				case OPTIONAL:
+				case POSITIVE_CLOSURE:
+				case RANGE:
+				case ROOT:
+				case SEMPRED:
+				case STRING_LITERAL:
+				case SYNPRED:
+				case SYN_SEMPRED:
+				case TOKEN_REF:
+				case TREE_BEGIN:
+				case WILDCARD:
+					{
+					alt31=1;
+					}
+					break;
+				}
+				switch (alt31) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:197:96: {...}? element
+					{
+					if ( !((!((CommonTree)input.LT(1)).getText().equals(ruleName))) ) {
+						if (state.backtracking>0) {state.failed=true; return;}
+						throw new FailedPredicateException(input, "prefix", "!((CommonTree)input.LT(1)).getText().equals(ruleName)");
+					}
+					pushFollow(FOLLOW_element_in_prefix966);
+					element();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt31 >= 1 ) break loop31;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(31, input);
+					throw eee;
+				}
+				cnt31++;
+			}
+
+			pushFollow(FOLLOW_recurse_in_prefix970);
+			recurse();
+			state._fsp--;
+			if (state.failed) return;
+			match(input,EOA,FOLLOW_EOA_in_prefix972); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "prefix"
+
+
+
+	// $ANTLR start "suffix"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:199:1: suffix : ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ( element )+ EOA ) ;
+	public final void suffix() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:199:8: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ( element )+ EOA ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:199:10: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ( element )+ EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_suffix985); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:199:17: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
+			int alt33=2;
+			int LA33_0 = input.LA(1);
+			if ( (LA33_0==BACKTRACK_SEMPRED) ) {
+				alt33=1;
+			}
+			switch (alt33) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:199:18: ^( BACKTRACK_SEMPRED ( . )* )
+					{
+					match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_suffix989); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:199:38: ( . )*
+						loop32:
+						while (true) {
+							int alt32=2;
+							int LA32_0 = input.LA(1);
+							if ( ((LA32_0 >= ACTION && LA32_0 <= XDIGIT)) ) {
+								alt32=1;
+							}
+							else if ( (LA32_0==UP) ) {
+								alt32=2;
+							}
+
+							switch (alt32) {
+							case 1 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:199:38: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop32;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			pushFollow(FOLLOW_recurseNoLabel_in_suffix997);
+			recurseNoLabel();
+			state._fsp--;
+			if (state.failed) return;
+			if ( state.backtracking==0 ) {setTokenPrec((GrammarAST)input.LT(1), outerAlt);}
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:199:110: ( element )+
+			int cnt34=0;
+			loop34:
+			while (true) {
+				int alt34=2;
+				int LA34_0 = input.LA(1);
+				if ( (LA34_0==ACTION||(LA34_0 >= ASSIGN && LA34_0 <= BLOCK)||LA34_0==CHAR_LITERAL||LA34_0==CLOSURE||LA34_0==DOT||LA34_0==EPSILON||LA34_0==FORCED_ACTION||LA34_0==GATED_SEMPRED||LA34_0==NOT||LA34_0==OPTIONAL||(LA34_0 >= PLUS_ASSIGN && LA34_0 <= POSITIVE_CLOSURE)||LA34_0==RANGE||LA34_0==ROOT||LA34_0==RULE_REF||LA34_0==SEMPRED||(LA34_0 >= STRING_LITERAL && LA34_0 <= SYN_SEMPRED)||LA34_0==TOKEN_REF||LA34_0==TREE_BEGIN||LA34_0==WILDCARD) ) {
+					alt34=1;
+				}
+
+				switch (alt34) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:199:110: element
+					{
+					pushFollow(FOLLOW_element_in_suffix1001);
+					element();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt34 >= 1 ) break loop34;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(34, input);
+					throw eee;
+				}
+				cnt34++;
+			}
+
+			match(input,EOA,FOLLOW_EOA_in_suffix1005); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "suffix"
+
+
+
+	// $ANTLR start "recurse"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:201:1: recurse : ( ^( ASSIGN ID recurseNoLabel ) | ^( PLUS_ASSIGN ID recurseNoLabel ) | recurseNoLabel );
+	public final void recurse() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:202:2: ( ^( ASSIGN ID recurseNoLabel ) | ^( PLUS_ASSIGN ID recurseNoLabel ) | recurseNoLabel )
+			int alt35=3;
+			switch ( input.LA(1) ) {
+			case ASSIGN:
+				{
+				alt35=1;
+				}
+				break;
+			case PLUS_ASSIGN:
+				{
+				alt35=2;
+				}
+				break;
+			case RULE_REF:
+				{
+				alt35=3;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 35, 0, input);
+				throw nvae;
+			}
+			switch (alt35) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:202:4: ^( ASSIGN ID recurseNoLabel )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_recurse1018); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,ID,FOLLOW_ID_in_recurse1020); if (state.failed) return;
+					pushFollow(FOLLOW_recurseNoLabel_in_recurse1022);
+					recurseNoLabel();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:203:4: ^( PLUS_ASSIGN ID recurseNoLabel )
+					{
+					match(input,PLUS_ASSIGN,FOLLOW_PLUS_ASSIGN_in_recurse1029); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,ID,FOLLOW_ID_in_recurse1031); if (state.failed) return;
+					pushFollow(FOLLOW_recurseNoLabel_in_recurse1033);
+					recurseNoLabel();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:204:4: recurseNoLabel
+					{
+					pushFollow(FOLLOW_recurseNoLabel_in_recurse1039);
+					recurseNoLabel();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "recurse"
+
+
+
+	// $ANTLR start "recurseNoLabel"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:207:1: recurseNoLabel :{...}? RULE_REF ;
+	public final void recurseNoLabel() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:207:16: ({...}? RULE_REF )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:207:18: {...}? RULE_REF
+			{
+			if ( !((((CommonTree)input.LT(1)).getText().equals(ruleName))) ) {
+				if (state.backtracking>0) {state.failed=true; return;}
+				throw new FailedPredicateException(input, "recurseNoLabel", "((CommonTree)input.LT(1)).getText().equals(ruleName)");
+			}
+			match(input,RULE_REF,FOLLOW_RULE_REF_in_recurseNoLabel1051); if (state.failed) return;
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "recurseNoLabel"
+
+
+
+	// $ANTLR start "token"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:216:1: token returns [GrammarAST t=null] : ( ^( ASSIGN ID s= token ) | ^( PLUS_ASSIGN ID s= token ) | ^( ROOT s= token ) | ^( BANG s= token ) |a= CHAR_LITERAL |b= STRING_LITERAL |c= TOKEN_REF );
+	public final GrammarAST token() throws RecognitionException {
+		GrammarAST t = null;
+
+
+		GrammarAST a=null;
+		GrammarAST b=null;
+		GrammarAST c=null;
+		GrammarAST s =null;
+
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:217:2: ( ^( ASSIGN ID s= token ) | ^( PLUS_ASSIGN ID s= token ) | ^( ROOT s= token ) | ^( BANG s= token ) |a= CHAR_LITERAL |b= STRING_LITERAL |c= TOKEN_REF )
+			int alt36=7;
+			switch ( input.LA(1) ) {
+			case ASSIGN:
+				{
+				alt36=1;
+				}
+				break;
+			case PLUS_ASSIGN:
+				{
+				alt36=2;
+				}
+				break;
+			case ROOT:
+				{
+				alt36=3;
+				}
+				break;
+			case BANG:
+				{
+				alt36=4;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt36=5;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt36=6;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt36=7;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return t;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 36, 0, input);
+				throw nvae;
+			}
+			switch (alt36) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:217:4: ^( ASSIGN ID s= token )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_token1068); if (state.failed) return t;
+					match(input, Token.DOWN, null); if (state.failed) return t;
+					match(input,ID,FOLLOW_ID_in_token1070); if (state.failed) return t;
+					pushFollow(FOLLOW_token_in_token1074);
+					s=token();
+					state._fsp--;
+					if (state.failed) return t;
+					if ( state.backtracking==0 ) {t = s;}
+					match(input, Token.UP, null); if (state.failed) return t;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:218:4: ^( PLUS_ASSIGN ID s= token )
+					{
+					match(input,PLUS_ASSIGN,FOLLOW_PLUS_ASSIGN_in_token1083); if (state.failed) return t;
+					match(input, Token.DOWN, null); if (state.failed) return t;
+					match(input,ID,FOLLOW_ID_in_token1085); if (state.failed) return t;
+					pushFollow(FOLLOW_token_in_token1089);
+					s=token();
+					state._fsp--;
+					if (state.failed) return t;
+					if ( state.backtracking==0 ) {t = s;}
+					match(input, Token.UP, null); if (state.failed) return t;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:219:4: ^( ROOT s= token )
+					{
+					match(input,ROOT,FOLLOW_ROOT_in_token1098); if (state.failed) return t;
+					match(input, Token.DOWN, null); if (state.failed) return t;
+					pushFollow(FOLLOW_token_in_token1102);
+					s=token();
+					state._fsp--;
+					if (state.failed) return t;
+					if ( state.backtracking==0 ) {t = s;}
+					match(input, Token.UP, null); if (state.failed) return t;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:220:4: ^( BANG s= token )
+					{
+					match(input,BANG,FOLLOW_BANG_in_token1111); if (state.failed) return t;
+					match(input, Token.DOWN, null); if (state.failed) return t;
+					pushFollow(FOLLOW_token_in_token1115);
+					s=token();
+					state._fsp--;
+					if (state.failed) return t;
+					if ( state.backtracking==0 ) {t = s;}
+					match(input, Token.UP, null); if (state.failed) return t;
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:221:4: a= CHAR_LITERAL
+					{
+					a=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_token1125); if (state.failed) return t;
+					if ( state.backtracking==0 ) {t = a;}
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:222:4: b= STRING_LITERAL
+					{
+					b=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_token1139); if (state.failed) return t;
+					if ( state.backtracking==0 ) {t = b;}
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:223:4: c= TOKEN_REF
+					{
+					c=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_token1151); if (state.failed) return t;
+					if ( state.backtracking==0 ) {t = c;}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return t;
+	}
+	// $ANTLR end "token"
+
+
+
+	// $ANTLR start "exceptionGroup"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:226:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	public final void exceptionGroup() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:227:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt39=2;
+			int LA39_0 = input.LA(1);
+			if ( (LA39_0==CATCH) ) {
+				alt39=1;
+			}
+			else if ( (LA39_0==FINALLY) ) {
+				alt39=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 39, 0, input);
+				throw nvae;
+			}
+
+			switch (alt39) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:227:4: ( exceptionHandler )+ ( finallyClause )?
+					{
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:227:4: ( exceptionHandler )+
+					int cnt37=0;
+					loop37:
+					while (true) {
+						int alt37=2;
+						int LA37_0 = input.LA(1);
+						if ( (LA37_0==CATCH) ) {
+							alt37=1;
+						}
+
+						switch (alt37) {
+						case 1 :
+							// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:227:4: exceptionHandler
+							{
+							pushFollow(FOLLOW_exceptionHandler_in_exceptionGroup1172);
+							exceptionHandler();
+							state._fsp--;
+							if (state.failed) return;
+							}
+							break;
+
+						default :
+							if ( cnt37 >= 1 ) break loop37;
+							if (state.backtracking>0) {state.failed=true; return;}
+							EarlyExitException eee = new EarlyExitException(37, input);
+							throw eee;
+						}
+						cnt37++;
+					}
+
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:227:22: ( finallyClause )?
+					int alt38=2;
+					int LA38_0 = input.LA(1);
+					if ( (LA38_0==FINALLY) ) {
+						alt38=1;
+					}
+					switch (alt38) {
+						case 1 :
+							// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:227:22: finallyClause
+							{
+							pushFollow(FOLLOW_finallyClause_in_exceptionGroup1175);
+							finallyClause();
+							state._fsp--;
+							if (state.failed) return;
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:228:4: finallyClause
+					{
+					pushFollow(FOLLOW_finallyClause_in_exceptionGroup1181);
+					finallyClause();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+
+	// $ANTLR start "exceptionHandler"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:231:1: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	public final void exceptionHandler() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:232:2: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:232:4: ^( 'catch' ARG_ACTION ACTION )
+			{
+			match(input,CATCH,FOLLOW_CATCH_in_exceptionHandler1196); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_exceptionHandler1198); if (state.failed) return;
+			match(input,ACTION,FOLLOW_ACTION_in_exceptionHandler1200); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+
+	// $ANTLR start "finallyClause"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:235:1: finallyClause : ^( 'finally' ACTION ) ;
+	public final void finallyClause() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:236:2: ( ^( 'finally' ACTION ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:236:4: ^( 'finally' ACTION )
+			{
+			match(input,FINALLY,FOLLOW_FINALLY_in_finallyClause1213); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			match(input,ACTION,FOLLOW_ACTION_in_finallyClause1215); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "finallyClause"
+
+
+
+	// $ANTLR start "rewrite"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:239:1: rewrite : ^( REWRITES ( ^( REWRITE ( SEMPRED )? ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC ) ) )* ) ;
+	public final void rewrite() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:2: ( ^( REWRITES ( ^( REWRITE ( SEMPRED )? ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC ) ) )* ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:4: ^( REWRITES ( ^( REWRITE ( SEMPRED )? ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC ) ) )* )
+			{
+			match(input,REWRITES,FOLLOW_REWRITES_in_rewrite1228); if (state.failed) return;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return;
+				// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:15: ( ^( REWRITE ( SEMPRED )? ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC ) ) )*
+				loop44:
+				while (true) {
+					int alt44=2;
+					int LA44_0 = input.LA(1);
+					if ( (LA44_0==REWRITE) ) {
+						alt44=1;
+					}
+
+					switch (alt44) {
+					case 1 :
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:17: ^( REWRITE ( SEMPRED )? ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC ) )
+						{
+						match(input,REWRITE,FOLLOW_REWRITE_in_rewrite1234); if (state.failed) return;
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:28: ( SEMPRED )?
+						int alt40=2;
+						int LA40_0 = input.LA(1);
+						if ( (LA40_0==SEMPRED) ) {
+							alt40=1;
+						}
+						switch (alt40) {
+							case 1 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:28: SEMPRED
+								{
+								match(input,SEMPRED,FOLLOW_SEMPRED_in_rewrite1236); if (state.failed) return;
+								}
+								break;
+
+						}
+
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:37: ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC )
+						int alt43=4;
+						switch ( input.LA(1) ) {
+						case ALT:
+							{
+							alt43=1;
+							}
+							break;
+						case TEMPLATE:
+							{
+							alt43=2;
+							}
+							break;
+						case ACTION:
+							{
+							alt43=3;
+							}
+							break;
+						case ETC:
+							{
+							alt43=4;
+							}
+							break;
+						default:
+							if (state.backtracking>0) {state.failed=true; return;}
+							NoViableAltException nvae =
+								new NoViableAltException("", 43, 0, input);
+							throw nvae;
+						}
+						switch (alt43) {
+							case 1 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:38: ^( ALT ( . )* )
+								{
+								match(input,ALT,FOLLOW_ALT_in_rewrite1241); if (state.failed) return;
+								if ( input.LA(1)==Token.DOWN ) {
+									match(input, Token.DOWN, null); if (state.failed) return;
+									// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:44: ( . )*
+									loop41:
+									while (true) {
+										int alt41=2;
+										int LA41_0 = input.LA(1);
+										if ( ((LA41_0 >= ACTION && LA41_0 <= XDIGIT)) ) {
+											alt41=1;
+										}
+										else if ( (LA41_0==UP) ) {
+											alt41=2;
+										}
+
+										switch (alt41) {
+										case 1 :
+											// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:44: .
+											{
+											matchAny(input); if (state.failed) return;
+											}
+											break;
+
+										default :
+											break loop41;
+										}
+									}
+
+									match(input, Token.UP, null); if (state.failed) return;
+								}
+
+								}
+								break;
+							case 2 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:48: ^( TEMPLATE ( . )* )
+								{
+								match(input,TEMPLATE,FOLLOW_TEMPLATE_in_rewrite1248); if (state.failed) return;
+								if ( input.LA(1)==Token.DOWN ) {
+									match(input, Token.DOWN, null); if (state.failed) return;
+									// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:59: ( . )*
+									loop42:
+									while (true) {
+										int alt42=2;
+										int LA42_0 = input.LA(1);
+										if ( ((LA42_0 >= ACTION && LA42_0 <= XDIGIT)) ) {
+											alt42=1;
+										}
+										else if ( (LA42_0==UP) ) {
+											alt42=2;
+										}
+
+										switch (alt42) {
+										case 1 :
+											// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:59: .
+											{
+											matchAny(input); if (state.failed) return;
+											}
+											break;
+
+										default :
+											break loop42;
+										}
+									}
+
+									match(input, Token.UP, null); if (state.failed) return;
+								}
+
+								}
+								break;
+							case 3 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:63: ACTION
+								{
+								match(input,ACTION,FOLLOW_ACTION_in_rewrite1254); if (state.failed) return;
+								}
+								break;
+							case 4 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:240:70: ETC
+								{
+								match(input,ETC,FOLLOW_ETC_in_rewrite1256); if (state.failed) return;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+
+						}
+						break;
+
+					default :
+						break loop44;
+					}
+				}
+
+				match(input, Token.UP, null); if (state.failed) return;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rewrite"
+
+
+
+	// $ANTLR start "element"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:243:1: element : ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | BACKTRACK_SEMPRED | GATED_SEMPRED | EPSILON );
+	public final void element() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:244:2: ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | BACKTRACK_SEMPRED | GATED_SEMPRED | EPSILON )
+			int alt45=17;
+			switch ( input.LA(1) ) {
+			case ROOT:
+				{
+				alt45=1;
+				}
+				break;
+			case BANG:
+				{
+				alt45=2;
+				}
+				break;
+			case CHAR_LITERAL:
+			case DOT:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case WILDCARD:
+				{
+				alt45=3;
+				}
+				break;
+			case NOT:
+				{
+				alt45=4;
+				}
+				break;
+			case RANGE:
+				{
+				alt45=5;
+				}
+				break;
+			case ASSIGN:
+				{
+				alt45=6;
+				}
+				break;
+			case PLUS_ASSIGN:
+				{
+				alt45=7;
+				}
+				break;
+			case BLOCK:
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt45=8;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt45=9;
+				}
+				break;
+			case SYNPRED:
+				{
+				alt45=10;
+				}
+				break;
+			case FORCED_ACTION:
+				{
+				alt45=11;
+				}
+				break;
+			case ACTION:
+				{
+				alt45=12;
+				}
+				break;
+			case SEMPRED:
+				{
+				alt45=13;
+				}
+				break;
+			case SYN_SEMPRED:
+				{
+				alt45=14;
+				}
+				break;
+			case BACKTRACK_SEMPRED:
+				{
+				alt45=15;
+				}
+				break;
+			case GATED_SEMPRED:
+				{
+				alt45=16;
+				}
+				break;
+			case EPSILON:
+				{
+				alt45=17;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 45, 0, input);
+				throw nvae;
+			}
+			switch (alt45) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:244:4: ^( ROOT element )
+					{
+					match(input,ROOT,FOLLOW_ROOT_in_element1276); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_element_in_element1278);
+					element();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:245:4: ^( BANG element )
+					{
+					match(input,BANG,FOLLOW_BANG_in_element1285); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_element_in_element1287);
+					element();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:246:4: atom
+					{
+					pushFollow(FOLLOW_atom_in_element1293);
+					atom();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:247:4: ^( NOT element )
+					{
+					match(input,NOT,FOLLOW_NOT_in_element1299); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_element_in_element1301);
+					element();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:248:4: ^( RANGE atom atom )
+					{
+					match(input,RANGE,FOLLOW_RANGE_in_element1308); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_atom_in_element1310);
+					atom();
+					state._fsp--;
+					if (state.failed) return;
+					pushFollow(FOLLOW_atom_in_element1312);
+					atom();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:249:4: ^( ASSIGN ID element )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_element1319); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,ID,FOLLOW_ID_in_element1321); if (state.failed) return;
+					pushFollow(FOLLOW_element_in_element1323);
+					element();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:250:4: ^( PLUS_ASSIGN ID element )
+					{
+					match(input,PLUS_ASSIGN,FOLLOW_PLUS_ASSIGN_in_element1330); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,ID,FOLLOW_ID_in_element1332); if (state.failed) return;
+					pushFollow(FOLLOW_element_in_element1334);
+					element();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 8 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:251:4: ebnf
+					{
+					pushFollow(FOLLOW_ebnf_in_element1340);
+					ebnf();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 9 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:252:4: tree_
+					{
+					pushFollow(FOLLOW_tree__in_element1345);
+					tree_();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 10 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:253:4: ^( SYNPRED block )
+					{
+					match(input,SYNPRED,FOLLOW_SYNPRED_in_element1351); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_block_in_element1353);
+					block();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 11 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:254:4: FORCED_ACTION
+					{
+					match(input,FORCED_ACTION,FOLLOW_FORCED_ACTION_in_element1360); if (state.failed) return;
+					}
+					break;
+				case 12 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:255:4: ACTION
+					{
+					match(input,ACTION,FOLLOW_ACTION_in_element1365); if (state.failed) return;
+					}
+					break;
+				case 13 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:256:4: SEMPRED
+					{
+					match(input,SEMPRED,FOLLOW_SEMPRED_in_element1370); if (state.failed) return;
+					}
+					break;
+				case 14 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:257:4: SYN_SEMPRED
+					{
+					match(input,SYN_SEMPRED,FOLLOW_SYN_SEMPRED_in_element1375); if (state.failed) return;
+					}
+					break;
+				case 15 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:258:4: BACKTRACK_SEMPRED
+					{
+					match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_element1380); if (state.failed) return;
+					}
+					break;
+				case 16 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:259:4: GATED_SEMPRED
+					{
+					match(input,GATED_SEMPRED,FOLLOW_GATED_SEMPRED_in_element1385); if (state.failed) return;
+					}
+					break;
+				case 17 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:260:4: EPSILON
+					{
+					match(input,EPSILON,FOLLOW_EPSILON_in_element1390); if (state.failed) return;
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "element"
+
+
+
+	// $ANTLR start "ebnf"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:263:1: ebnf : ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
+	public final void ebnf() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:263:5: ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
+			int alt46=4;
+			switch ( input.LA(1) ) {
+			case BLOCK:
+				{
+				alt46=1;
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt46=2;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt46=3;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt46=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 46, 0, input);
+				throw nvae;
+			}
+			switch (alt46) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:263:9: block
+					{
+					pushFollow(FOLLOW_block_in_ebnf1402);
+					block();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:264:9: ^( OPTIONAL block )
+					{
+					match(input,OPTIONAL,FOLLOW_OPTIONAL_in_ebnf1414); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_block_in_ebnf1416);
+					block();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:265:9: ^( CLOSURE block )
+					{
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_ebnf1431); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_block_in_ebnf1433);
+					block();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:266:9: ^( POSITIVE_CLOSURE block )
+					{
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_ebnf1449); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_block_in_ebnf1451);
+					block();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ebnf"
+
+
+
+	// $ANTLR start "tree_"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:269:1: tree_ : ^( TREE_BEGIN ( element )+ ) ;
+	public final void tree_() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:270:2: ( ^( TREE_BEGIN ( element )+ ) )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:270:4: ^( TREE_BEGIN ( element )+ )
+			{
+			match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_tree_1469); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:270:17: ( element )+
+			int cnt47=0;
+			loop47:
+			while (true) {
+				int alt47=2;
+				int LA47_0 = input.LA(1);
+				if ( (LA47_0==ACTION||(LA47_0 >= ASSIGN && LA47_0 <= BLOCK)||LA47_0==CHAR_LITERAL||LA47_0==CLOSURE||LA47_0==DOT||LA47_0==EPSILON||LA47_0==FORCED_ACTION||LA47_0==GATED_SEMPRED||LA47_0==NOT||LA47_0==OPTIONAL||(LA47_0 >= PLUS_ASSIGN && LA47_0 <= POSITIVE_CLOSURE)||LA47_0==RANGE||LA47_0==ROOT||LA47_0==RULE_REF||LA47_0==SEMPRED||(LA47_0 >= STRING_LITERAL && LA47_0 <= SYN_SEMPRED)||LA47_0==TOKEN_REF||LA47_0==TREE_BEGIN||LA47_0==WILDCARD) ) {
+					alt47=1;
+				}
+
+				switch (alt47) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:270:17: element
+					{
+					pushFollow(FOLLOW_element_in_tree_1471);
+					element();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt47 >= 1 ) break loop47;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(47, input);
+					throw eee;
+				}
+				cnt47++;
+			}
+
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "tree_"
+
+
+
+	// $ANTLR start "atom"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:273:1: atom : ( ^( RULE_REF ( ARG_ACTION )? ) | ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL | WILDCARD | ^( DOT ID atom ) );
+	public final void atom() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:274:2: ( ^( RULE_REF ( ARG_ACTION )? ) | ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL | WILDCARD | ^( DOT ID atom ) )
+			int alt50=6;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+				{
+				alt50=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt50=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt50=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt50=4;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt50=5;
+				}
+				break;
+			case DOT:
+				{
+				alt50=6;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 50, 0, input);
+				throw nvae;
+			}
+			switch (alt50) {
+				case 1 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:274:4: ^( RULE_REF ( ARG_ACTION )? )
+					{
+					match(input,RULE_REF,FOLLOW_RULE_REF_in_atom1485); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:274:15: ( ARG_ACTION )?
+						int alt48=2;
+						int LA48_0 = input.LA(1);
+						if ( (LA48_0==ARG_ACTION) ) {
+							alt48=1;
+						}
+						switch (alt48) {
+							case 1 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:274:15: ARG_ACTION
+								{
+								match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1487); if (state.failed) return;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:275:4: ^( TOKEN_REF ( ARG_ACTION )? )
+					{
+					match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom1495); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:275:16: ( ARG_ACTION )?
+						int alt49=2;
+						int LA49_0 = input.LA(1);
+						if ( (LA49_0==ARG_ACTION) ) {
+							alt49=1;
+						}
+						switch (alt49) {
+							case 1 :
+								// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:275:16: ARG_ACTION
+								{
+								match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1497); if (state.failed) return;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:276:4: CHAR_LITERAL
+					{
+					match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom1504); if (state.failed) return;
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:277:4: STRING_LITERAL
+					{
+					match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_atom1509); if (state.failed) return;
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:278:4: WILDCARD
+					{
+					match(input,WILDCARD,FOLLOW_WILDCARD_in_atom1514); if (state.failed) return;
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:279:4: ^( DOT ID atom )
+					{
+					match(input,DOT,FOLLOW_DOT_in_atom1520); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					match(input,ID,FOLLOW_ID_in_atom1522); if (state.failed) return;
+					pushFollow(FOLLOW_atom_in_atom1524);
+					atom();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "atom"
+
+
+
+	// $ANTLR start "ast_suffix"
+	// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:282:1: ast_suffix : ( ROOT | BANG );
+	public final void ast_suffix() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:283:2: ( ROOT | BANG )
+			// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:
+			{
+			if ( input.LA(1)==BANG||input.LA(1)==ROOT ) {
+				input.consume();
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ast_suffix"
+
+	// $ANTLR start synpred1_LeftRecursiveRuleWalker
+	public final void synpred1_LeftRecursiveRuleWalker_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:171:9: ( binaryMultipleOp )
+		// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:171:10: binaryMultipleOp
+		{
+		pushFollow(FOLLOW_binaryMultipleOp_in_synpred1_LeftRecursiveRuleWalker484);
+		binaryMultipleOp();
+		state._fsp--;
+		if (state.failed) return;
+		}
+
+	}
+	// $ANTLR end synpred1_LeftRecursiveRuleWalker
+
+	// $ANTLR start synpred2_LeftRecursiveRuleWalker
+	public final void synpred2_LeftRecursiveRuleWalker_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:173:9: ( binary )
+		// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:173:10: binary
+		{
+		pushFollow(FOLLOW_binary_in_synpred2_LeftRecursiveRuleWalker530);
+		binary();
+		state._fsp--;
+		if (state.failed) return;
+		}
+
+	}
+	// $ANTLR end synpred2_LeftRecursiveRuleWalker
+
+	// $ANTLR start synpred3_LeftRecursiveRuleWalker
+	public final void synpred3_LeftRecursiveRuleWalker_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:175:9: ( ternary )
+		// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:175:10: ternary
+		{
+		pushFollow(FOLLOW_ternary_in_synpred3_LeftRecursiveRuleWalker593);
+		ternary();
+		state._fsp--;
+		if (state.failed) return;
+		}
+
+	}
+	// $ANTLR end synpred3_LeftRecursiveRuleWalker
+
+	// $ANTLR start synpred4_LeftRecursiveRuleWalker
+	public final void synpred4_LeftRecursiveRuleWalker_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:177:9: ( prefix )
+		// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:177:10: prefix
+		{
+		pushFollow(FOLLOW_prefix_in_synpred4_LeftRecursiveRuleWalker648);
+		prefix();
+		state._fsp--;
+		if (state.failed) return;
+		}
+
+	}
+	// $ANTLR end synpred4_LeftRecursiveRuleWalker
+
+	// $ANTLR start synpred5_LeftRecursiveRuleWalker
+	public final void synpred5_LeftRecursiveRuleWalker_fragment() throws RecognitionException {
+		// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:179:9: ( suffix )
+		// org/antlr/grammar/v3/LeftRecursiveRuleWalker.g:179:10: suffix
+		{
+		pushFollow(FOLLOW_suffix_in_synpred5_LeftRecursiveRuleWalker704);
+		suffix();
+		state._fsp--;
+		if (state.failed) return;
+		}
+
+	}
+	// $ANTLR end synpred5_LeftRecursiveRuleWalker
+
+	// Delegated rules
+
+	public final boolean synpred1_LeftRecursiveRuleWalker() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred1_LeftRecursiveRuleWalker_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred2_LeftRecursiveRuleWalker() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred2_LeftRecursiveRuleWalker_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred4_LeftRecursiveRuleWalker() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred4_LeftRecursiveRuleWalker_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred3_LeftRecursiveRuleWalker() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred3_LeftRecursiveRuleWalker_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public final boolean synpred5_LeftRecursiveRuleWalker() {
+		state.backtracking++;
+		int start = input.mark();
+		try {
+			synpred5_LeftRecursiveRuleWalker_fragment(); // can never throw exception
+		} catch (RecognitionException re) {
+			System.err.println("impossible: "+re);
+		}
+		boolean success = !state.failed;
+		input.rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+
+	public static final BitSet FOLLOW_OPTIONS_in_optionsSpec57 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_option_in_optionsSpec59 = new BitSet(new long[]{0x0000000000002008L});
+	public static final BitSet FOLLOW_ASSIGN_in_option73 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_option75 = new BitSet(new long[]{0x0000880000040000L,0x0000000001000000L});
+	public static final BitSet FOLLOW_optionValue_in_option77 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_charSetElement115 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OR_in_charSetElement121 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_charSetElement123 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_charSetElement125 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RANGE_in_charSetElement132 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_charSetElement134 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_charSetElement136 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RULE_in_rec_rule164 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rec_rule168 = new BitSet(new long[]{0x0000010000000400L,0x000000000000001CL});
+	public static final BitSet FOLLOW_modifier_in_rec_rule175 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_ARG_in_rec_rule182 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rec_rule184 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RET_in_rec_rule192 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rec_rule194 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_optionsSpec_in_rec_rule201 = new BitSet(new long[]{0x0000000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_rec_rule207 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_AMPERSAND_in_rec_rule215 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ruleBlock_in_rec_rule226 = new BitSet(new long[]{0x0000004400020000L});
+	public static final BitSet FOLLOW_exceptionGroup_in_rec_rule233 = new BitSet(new long[]{0x0000000400000000L});
+	public static final BitSet FOLLOW_EOR_in_rec_rule239 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec286 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec288 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_ID_in_ruleScopeSpec291 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_ruleBlock315 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_optionsSpec_in_ruleBlock320 = new BitSet(new long[]{0x0000000000000100L});
+	public static final BitSet FOLLOW_outerAlternative_in_ruleBlock328 = new BitSet(new long[]{0x0000000200000100L,0x0000000000001000L});
+	public static final BitSet FOLLOW_rewrite_in_ruleBlock340 = new BitSet(new long[]{0x0000000200000100L});
+	public static final BitSet FOLLOW_EOB_in_ruleBlock358 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_block381 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_optionsSpec_in_block395 = new BitSet(new long[]{0x0000000000000100L});
+	public static final BitSet FOLLOW_ALT_in_block413 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_block415 = new BitSet(new long[]{0x828002892025E010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_EOA_in_block418 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_rewrite_in_block421 = new BitSet(new long[]{0x0000000200000100L});
+	public static final BitSet FOLLOW_EOB_in_block439 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_binaryMultipleOp_in_outerAlternative488 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_binary_in_outerAlternative544 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ternary_in_outerAlternative606 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_prefix_in_outerAlternative662 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_suffix_in_outerAlternative718 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ALT_in_outerAlternative760 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_outerAlternative762 = new BitSet(new long[]{0x828002892025E010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_EOA_in_outerAlternative765 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_binary814 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_binary818 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_recurseNoLabel_in_binary826 = new BitSet(new long[]{0x800000000004A000L,0x0000000041002000L});
+	public static final BitSet FOLLOW_token_in_binary830 = new BitSet(new long[]{0x8000000000002000L,0x0000000000010000L});
+	public static final BitSet FOLLOW_recurse_in_binary832 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_binary834 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_binaryMultipleOp851 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_binaryMultipleOp855 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_recurseNoLabel_in_binaryMultipleOp863 = new BitSet(new long[]{0x0000000000010000L});
+	public static final BitSet FOLLOW_BLOCK_in_binaryMultipleOp867 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ALT_in_binaryMultipleOp873 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_token_in_binaryMultipleOp877 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_binaryMultipleOp879 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_EOB_in_binaryMultipleOp888 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_recurse_in_binaryMultipleOp892 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_binaryMultipleOp894 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_ternary909 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_ternary913 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_recurseNoLabel_in_ternary921 = new BitSet(new long[]{0x800000000004A000L,0x0000000041002000L});
+	public static final BitSet FOLLOW_token_in_ternary925 = new BitSet(new long[]{0x8000000000002000L,0x0000000000010000L});
+	public static final BitSet FOLLOW_recurse_in_ternary927 = new BitSet(new long[]{0x800000000004A000L,0x0000000041002000L});
+	public static final BitSet FOLLOW_token_in_ternary929 = new BitSet(new long[]{0x8000000000002000L,0x0000000000010000L});
+	public static final BitSet FOLLOW_recurse_in_ternary931 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_ternary933 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_prefix949 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_prefix953 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_prefix966 = new BitSet(new long[]{0x828002882025E010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_recurse_in_prefix970 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_prefix972 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_suffix985 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_suffix989 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_recurseNoLabel_in_suffix997 = new BitSet(new long[]{0x828002882025E010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_suffix1001 = new BitSet(new long[]{0x828002892025E010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_EOA_in_suffix1005 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ASSIGN_in_recurse1018 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_recurse1020 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010000L});
+	public static final BitSet FOLLOW_recurseNoLabel_in_recurse1022 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PLUS_ASSIGN_in_recurse1029 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_recurse1031 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010000L});
+	public static final BitSet FOLLOW_recurseNoLabel_in_recurse1033 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_recurseNoLabel_in_recurse1039 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_RULE_REF_in_recurseNoLabel1051 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ASSIGN_in_token1068 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_token1070 = new BitSet(new long[]{0x800000000004A000L,0x0000000041002000L});
+	public static final BitSet FOLLOW_token_in_token1074 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PLUS_ASSIGN_in_token1083 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_token1085 = new BitSet(new long[]{0x800000000004A000L,0x0000000041002000L});
+	public static final BitSet FOLLOW_token_in_token1089 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ROOT_in_token1098 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_token_in_token1102 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BANG_in_token1111 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_token_in_token1115 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_token1125 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_token1139 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_token1151 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_exceptionHandler_in_exceptionGroup1172 = new BitSet(new long[]{0x0000004000020002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup1175 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup1181 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CATCH_in_exceptionHandler1196 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_exceptionHandler1198 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_exceptionHandler1200 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_FINALLY_in_finallyClause1213 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_finallyClause1215 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_REWRITES_in_rewrite1228 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite1234 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_SEMPRED_in_rewrite1236 = new BitSet(new long[]{0x0000002000000110L,0x0000000008000000L});
+	public static final BitSet FOLLOW_ALT_in_rewrite1241 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_TEMPLATE_in_rewrite1248 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_rewrite1254 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ETC_in_rewrite1256 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ROOT_in_element1276 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element1278 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BANG_in_element1285 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element1287 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_atom_in_element1293 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_NOT_in_element1299 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element1301 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RANGE_in_element1308 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_atom_in_element1310 = new BitSet(new long[]{0x0000000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_element1312 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ASSIGN_in_element1319 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element1321 = new BitSet(new long[]{0x828002882025E010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_element1323 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PLUS_ASSIGN_in_element1330 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element1332 = new BitSet(new long[]{0x828002882025E010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_element1334 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ebnf_in_element1340 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_tree__in_element1345 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYNPRED_in_element1351 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_element1353 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_FORCED_ACTION_in_element1360 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ACTION_in_element1365 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SEMPRED_in_element1370 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYN_SEMPRED_in_element1375 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_element1380 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_GATED_SEMPRED_in_element1385 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_EPSILON_in_element1390 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_ebnf1402 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONAL_in_ebnf1414 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1416 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_ebnf1431 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1433 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_ebnf1449 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1451 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_tree_1469 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_tree_1471 = new BitSet(new long[]{0x828002882025E018L,0x0000000547092041L});
+	public static final BitSet FOLLOW_RULE_REF_in_atom1485 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1487 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom1495 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1497 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom1504 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_atom1509 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_WILDCARD_in_atom1514 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_DOT_in_atom1520 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_atom1522 = new BitSet(new long[]{0x0000000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_atom1524 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_binaryMultipleOp_in_synpred1_LeftRecursiveRuleWalker484 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_binary_in_synpred2_LeftRecursiveRuleWalker530 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ternary_in_synpred3_LeftRecursiveRuleWalker593 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_prefix_in_synpred4_LeftRecursiveRuleWalker648 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_suffix_in_synpred5_LeftRecursiveRuleWalker704 = new BitSet(new long[]{0x0000000000000002L});
+}
--- tool/src/main/java/org/antlr/grammar/v3/TreeToNFAConverter.java	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/org/antlr/grammar/v3/TreeToNFAConverter.java	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,4395 @@
+// $ANTLR 3.5.2 org/antlr/grammar/v3/TreeToNFAConverter.g 2019-04-04 15:18:50
+
+package org.antlr.grammar.v3;
+
+import org.antlr.analysis.*;
+import org.antlr.misc.*;
+import org.antlr.tool.*;
+
+import org.antlr.runtime.BitSet;
+import org.antlr.runtime.DFA;
+
+
+import org.antlr.runtime.*;
+import org.antlr.runtime.tree.*;
+import java.util.Stack;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+
+/** Build an NFA from a tree representing an ANTLR grammar. */
+@SuppressWarnings("all")
+public class TreeToNFAConverter extends TreeParser {
+	public static final String[] tokenNames = new String[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", 
+		"ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", 
+		"ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", 
+		"CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", 
+		"COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", 
+		"DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", 
+		"EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", 
+		"GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", 
+		"LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", 
+		"NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", 
+		"OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", 
+		"PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", 
+		"RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", 
+		"RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", 
+		"SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", 
+		"TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", 
+		"WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public static final int EOF=-1;
+	public static final int ACTION=4;
+	public static final int ACTION_CHAR_LITERAL=5;
+	public static final int ACTION_ESC=6;
+	public static final int ACTION_STRING_LITERAL=7;
+	public static final int ALT=8;
+	public static final int AMPERSAND=9;
+	public static final int ARG=10;
+	public static final int ARGLIST=11;
+	public static final int ARG_ACTION=12;
+	public static final int ASSIGN=13;
+	public static final int BACKTRACK_SEMPRED=14;
+	public static final int BANG=15;
+	public static final int BLOCK=16;
+	public static final int CATCH=17;
+	public static final int CHAR_LITERAL=18;
+	public static final int CHAR_RANGE=19;
+	public static final int CLOSE_ELEMENT_OPTION=20;
+	public static final int CLOSURE=21;
+	public static final int COLON=22;
+	public static final int COMBINED_GRAMMAR=23;
+	public static final int COMMA=24;
+	public static final int COMMENT=25;
+	public static final int DIGIT=26;
+	public static final int DOC_COMMENT=27;
+	public static final int DOLLAR=28;
+	public static final int DOT=29;
+	public static final int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public static final int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public static final int EOA=32;
+	public static final int EOB=33;
+	public static final int EOR=34;
+	public static final int EPSILON=35;
+	public static final int ESC=36;
+	public static final int ETC=37;
+	public static final int FINALLY=38;
+	public static final int FORCED_ACTION=39;
+	public static final int FRAGMENT=40;
+	public static final int GATED_SEMPRED=41;
+	public static final int GRAMMAR=42;
+	public static final int ID=43;
+	public static final int IMPLIES=44;
+	public static final int IMPORT=45;
+	public static final int INITACTION=46;
+	public static final int INT=47;
+	public static final int LABEL=48;
+	public static final int LEXER=49;
+	public static final int LEXER_GRAMMAR=50;
+	public static final int LPAREN=51;
+	public static final int ML_COMMENT=52;
+	public static final int NESTED_ACTION=53;
+	public static final int NESTED_ARG_ACTION=54;
+	public static final int NOT=55;
+	public static final int OPEN_ELEMENT_OPTION=56;
+	public static final int OPTIONAL=57;
+	public static final int OPTIONS=58;
+	public static final int OR=59;
+	public static final int PARSER=60;
+	public static final int PARSER_GRAMMAR=61;
+	public static final int PLUS=62;
+	public static final int PLUS_ASSIGN=63;
+	public static final int POSITIVE_CLOSURE=64;
+	public static final int PREC_RULE=65;
+	public static final int PRIVATE=66;
+	public static final int PROTECTED=67;
+	public static final int PUBLIC=68;
+	public static final int QUESTION=69;
+	public static final int RANGE=70;
+	public static final int RCURLY=71;
+	public static final int RECURSIVE_RULE_REF=72;
+	public static final int RET=73;
+	public static final int RETURNS=74;
+	public static final int REWRITE=75;
+	public static final int REWRITES=76;
+	public static final int ROOT=77;
+	public static final int RPAREN=78;
+	public static final int RULE=79;
+	public static final int RULE_REF=80;
+	public static final int SCOPE=81;
+	public static final int SEMI=82;
+	public static final int SEMPRED=83;
+	public static final int SL_COMMENT=84;
+	public static final int SRC=85;
+	public static final int STAR=86;
+	public static final int STRAY_BRACKET=87;
+	public static final int STRING_LITERAL=88;
+	public static final int SYNPRED=89;
+	public static final int SYN_SEMPRED=90;
+	public static final int TEMPLATE=91;
+	public static final int THROWS=92;
+	public static final int TOKENS=93;
+	public static final int TOKEN_REF=94;
+	public static final int TREE=95;
+	public static final int TREE_BEGIN=96;
+	public static final int TREE_GRAMMAR=97;
+	public static final int WILDCARD=98;
+	public static final int WS=99;
+	public static final int WS_LOOP=100;
+	public static final int WS_OPT=101;
+	public static final int XDIGIT=102;
+
+	// delegates
+	public TreeParser[] getDelegates() {
+		return new TreeParser[] {};
+	}
+
+	// delegators
+
+
+	public TreeToNFAConverter(TreeNodeStream input) {
+		this(input, new RecognizerSharedState());
+	}
+	public TreeToNFAConverter(TreeNodeStream input, RecognizerSharedState state) {
+		super(input, state);
+	}
+
+	@Override public String[] getTokenNames() { return TreeToNFAConverter.tokenNames; }
+	@Override public String getGrammarFileName() { return "org/antlr/grammar/v3/TreeToNFAConverter.g"; }
+
+
+	/** Factory used to create nodes and submachines */
+	protected NFAFactory factory = null;
+
+	/** Which NFA object are we filling in? */
+	protected NFA nfa = null;
+
+	/** Which grammar are we converting an NFA for? */
+	protected Grammar grammar = null;
+
+	protected String currentRuleName = null;
+
+	protected int outerAltNum = 0;
+	protected int blockLevel = 0;
+
+	protected int inTest = 0;
+
+	public TreeToNFAConverter(TreeNodeStream input, Grammar g, NFA nfa, NFAFactory factory) {
+	    this(input);
+	    this.grammar = g;
+	    this.nfa = nfa;
+	    this.factory = factory;
+	}
+
+	public final IntSet setRule(GrammarAST t) throws RecognitionException {
+	    TreeToNFAConverter other = new TreeToNFAConverter( new CommonTreeNodeStream( t ), grammar, nfa, factory );
+
+	    other.currentRuleName = currentRuleName;
+	    other.outerAltNum = outerAltNum;
+	    other.blockLevel = blockLevel;
+
+	    return other.setRule();
+	}
+
+	public final int testBlockAsSet( GrammarAST t ) throws RecognitionException {
+	    Rule r = grammar.getLocallyDefinedRule( currentRuleName );
+	    if ( r.hasRewrite( outerAltNum ) )
+	        return -1;
+
+	    TreeToNFAConverter other = new TreeToNFAConverter( new CommonTreeNodeStream( t ), grammar, nfa, factory );
+
+	    other.state.backtracking++;
+	    other.currentRuleName = currentRuleName;
+	    other.outerAltNum = outerAltNum;
+	    other.blockLevel = blockLevel;
+
+	    int result = other.testBlockAsSet();
+	    if ( other.state.failed )
+	        return -1;
+
+	    return result;
+	}
+
+	public final int testSetRule( GrammarAST t ) throws RecognitionException {
+	    TreeToNFAConverter other = new TreeToNFAConverter( new CommonTreeNodeStream( t ), grammar, nfa, factory );
+
+	    other.state.backtracking++;
+	    other.currentRuleName = currentRuleName;
+	    other.outerAltNum = outerAltNum;
+	    other.blockLevel = blockLevel;
+
+	    int result = other.testSetRule();
+	    if ( other.state.failed )
+	        state.failed = true;
+
+	    return result;
+	}
+
+	protected void addFollowTransition( String ruleName, NFAState following ) {
+	    //System.Console.Out.WriteLine( "adding follow link to rule " + ruleName );
+	    // find last link in FOLLOW chain emanating from rule
+	    Rule r = grammar.getRule( ruleName );
+	    NFAState end = r.stopState;
+	    while ( end.transition( 1 ) != null )
+	    {
+	        end = (NFAState)end.transition( 1 ).target;
+	    }
+	    if ( end.transition( 0 ) != null )
+	    {
+	        // already points to a following node
+	        // gotta add another node to keep edges to a max of 2
+	        NFAState n = factory.newState();
+	        Transition e = new Transition( Label.EPSILON, n );
+	        end.addTransition( e );
+	        end = n;
+	    }
+	    Transition followEdge = new Transition( Label.EPSILON, following );
+	    end.addTransition( followEdge );
+	}
+
+	protected void finish() {
+	    int numEntryPoints = factory.build_EOFStates( grammar.getRules() );
+	    if ( numEntryPoints == 0 )
+	    {
+	        ErrorManager.grammarWarning( ErrorManager.MSG_NO_GRAMMAR_START_RULE,
+	                                   grammar,
+	                                   null,
+	                                   grammar.name );
+	    }
+	}
+
+	@Override
+	public void reportError(RecognitionException ex) {
+	    if ( inTest > 0 )
+	        throw new IllegalStateException(ex);
+
+	    Token token = null;
+	    if ( ex instanceof MismatchedTokenException )
+	    {
+	        token = ( (MismatchedTokenException)ex ).token;
+	    }
+	    else if ( ex instanceof NoViableAltException )
+	    {
+	        token = ( (NoViableAltException)ex ).token;
+	    }
+
+	    ErrorManager.syntaxError(
+	        ErrorManager.MSG_SYNTAX_ERROR,
+	        grammar,
+	        token,
+	        "buildnfa: " + ex.toString(),
+	        ex );
+	}
+
+	private boolean hasElementOptions(GrammarAST node) {
+	    if (node == null)
+	        throw new NullPointerException("node");
+	    return node.terminalOptions != null && node.terminalOptions.size() > 0;
+	}
+
+
+
+	// $ANTLR start "grammar_"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:185:1: public grammar_ : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
+	public final void grammar_() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:190:2: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:190:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			{
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:190:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			int alt1=4;
+			switch ( input.LA(1) ) {
+			case LEXER_GRAMMAR:
+				{
+				alt1=1;
+				}
+				break;
+			case PARSER_GRAMMAR:
+				{
+				alt1=2;
+				}
+				break;
+			case TREE_GRAMMAR:
+				{
+				alt1=3;
+				}
+				break;
+			case COMBINED_GRAMMAR:
+				{
+				alt1=4;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 1, 0, input);
+				throw nvae;
+			}
+			switch (alt1) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:190:6: ^( LEXER_GRAMMAR grammarSpec )
+					{
+					match(input,LEXER_GRAMMAR,FOLLOW_LEXER_GRAMMAR_in_grammar_68); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_70);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:191:5: ^( PARSER_GRAMMAR grammarSpec )
+					{
+					match(input,PARSER_GRAMMAR,FOLLOW_PARSER_GRAMMAR_in_grammar_80); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_82);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:192:5: ^( TREE_GRAMMAR grammarSpec )
+					{
+					match(input,TREE_GRAMMAR,FOLLOW_TREE_GRAMMAR_in_grammar_92); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_94);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:193:5: ^( COMBINED_GRAMMAR grammarSpec )
+					{
+					match(input,COMBINED_GRAMMAR,FOLLOW_COMBINED_GRAMMAR_in_grammar_104); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_grammarSpec_in_grammar_106);
+					grammarSpec();
+					state._fsp--;
+					if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+
+			}
+
+			if ( state.backtracking==0 ) {
+				finish();
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammar_"
+
+
+
+	// $ANTLR start "attrScope"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:197:1: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
+	public final void attrScope() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:198:2: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:198:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_attrScope125); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			match(input,ID,FOLLOW_ID_in_attrScope127); if (state.failed) return;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:198:18: ( ^( AMPERSAND ( . )* ) )*
+			loop3:
+			while (true) {
+				int alt3=2;
+				int LA3_0 = input.LA(1);
+				if ( (LA3_0==AMPERSAND) ) {
+					alt3=1;
+				}
+
+				switch (alt3) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:198:20: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_attrScope132); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:198:32: ( . )*
+						loop2:
+						while (true) {
+							int alt2=2;
+							int LA2_0 = input.LA(1);
+							if ( ((LA2_0 >= ACTION && LA2_0 <= XDIGIT)) ) {
+								alt2=1;
+							}
+							else if ( (LA2_0==UP) ) {
+								alt2=2;
+							}
+
+							switch (alt2) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:198:32: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop2;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+				default :
+					break loop3;
+				}
+			}
+
+			match(input,ACTION,FOLLOW_ACTION_in_attrScope141); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "attrScope"
+
+
+
+	// $ANTLR start "grammarSpec"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:201:1: grammarSpec : ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules ;
+	public final void grammarSpec() throws RecognitionException {
+		GrammarAST cmt=null;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:202:2: ( ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:202:4: ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules
+			{
+			match(input,ID,FOLLOW_ID_in_grammarSpec154); if (state.failed) return;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:203:3: (cmt= DOC_COMMENT )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+			if ( (LA4_0==DOC_COMMENT) ) {
+				alt4=1;
+			}
+			switch (alt4) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:203:4: cmt= DOC_COMMENT
+					{
+					cmt=(GrammarAST)match(input,DOC_COMMENT,FOLLOW_DOC_COMMENT_in_grammarSpec161); if (state.failed) return;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:204:3: ( ^( OPTIONS ( . )* ) )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+			if ( (LA6_0==OPTIONS) ) {
+				alt6=1;
+			}
+			switch (alt6) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:204:5: ^( OPTIONS ( . )* )
+					{
+					match(input,OPTIONS,FOLLOW_OPTIONS_in_grammarSpec170); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:204:15: ( . )*
+						loop5:
+						while (true) {
+							int alt5=2;
+							int LA5_0 = input.LA(1);
+							if ( ((LA5_0 >= ACTION && LA5_0 <= XDIGIT)) ) {
+								alt5=1;
+							}
+							else if ( (LA5_0==UP) ) {
+								alt5=2;
+							}
+
+							switch (alt5) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:204:15: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop5;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:205:3: ( ^( IMPORT ( . )* ) )?
+			int alt8=2;
+			int LA8_0 = input.LA(1);
+			if ( (LA8_0==IMPORT) ) {
+				alt8=1;
+			}
+			switch (alt8) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:205:5: ^( IMPORT ( . )* )
+					{
+					match(input,IMPORT,FOLLOW_IMPORT_in_grammarSpec184); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:205:14: ( . )*
+						loop7:
+						while (true) {
+							int alt7=2;
+							int LA7_0 = input.LA(1);
+							if ( ((LA7_0 >= ACTION && LA7_0 <= XDIGIT)) ) {
+								alt7=1;
+							}
+							else if ( (LA7_0==UP) ) {
+								alt7=2;
+							}
+
+							switch (alt7) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:205:14: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop7;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:206:3: ( ^( TOKENS ( . )* ) )?
+			int alt10=2;
+			int LA10_0 = input.LA(1);
+			if ( (LA10_0==TOKENS) ) {
+				alt10=1;
+			}
+			switch (alt10) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:206:5: ^( TOKENS ( . )* )
+					{
+					match(input,TOKENS,FOLLOW_TOKENS_in_grammarSpec198); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:206:14: ( . )*
+						loop9:
+						while (true) {
+							int alt9=2;
+							int LA9_0 = input.LA(1);
+							if ( ((LA9_0 >= ACTION && LA9_0 <= XDIGIT)) ) {
+								alt9=1;
+							}
+							else if ( (LA9_0==UP) ) {
+								alt9=2;
+							}
+
+							switch (alt9) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:206:14: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop9;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:207:3: ( attrScope )*
+			loop11:
+			while (true) {
+				int alt11=2;
+				int LA11_0 = input.LA(1);
+				if ( (LA11_0==SCOPE) ) {
+					alt11=1;
+				}
+
+				switch (alt11) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:207:4: attrScope
+					{
+					pushFollow(FOLLOW_attrScope_in_grammarSpec210);
+					attrScope();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+				default :
+					break loop11;
+				}
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:208:3: ( ^( AMPERSAND ( . )* ) )*
+			loop13:
+			while (true) {
+				int alt13=2;
+				int LA13_0 = input.LA(1);
+				if ( (LA13_0==AMPERSAND) ) {
+					alt13=1;
+				}
+
+				switch (alt13) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:208:5: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_grammarSpec219); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:208:17: ( . )*
+						loop12:
+						while (true) {
+							int alt12=2;
+							int LA12_0 = input.LA(1);
+							if ( ((LA12_0 >= ACTION && LA12_0 <= XDIGIT)) ) {
+								alt12=1;
+							}
+							else if ( (LA12_0==UP) ) {
+								alt12=2;
+							}
+
+							switch (alt12) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:208:17: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop12;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+				default :
+					break loop13;
+				}
+			}
+
+			pushFollow(FOLLOW_rules_in_grammarSpec231);
+			rules();
+			state._fsp--;
+			if (state.failed) return;
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "grammarSpec"
+
+
+
+	// $ANTLR start "rules"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:212:1: rules : ( rule | ^( PREC_RULE ( . )* ) )+ ;
+	public final void rules() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:213:2: ( ( rule | ^( PREC_RULE ( . )* ) )+ )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:213:4: ( rule | ^( PREC_RULE ( . )* ) )+
+			{
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:213:4: ( rule | ^( PREC_RULE ( . )* ) )+
+			int cnt15=0;
+			loop15:
+			while (true) {
+				int alt15=3;
+				int LA15_0 = input.LA(1);
+				if ( (LA15_0==RULE) ) {
+					alt15=1;
+				}
+				else if ( (LA15_0==PREC_RULE) ) {
+					alt15=2;
+				}
+
+				switch (alt15) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:213:5: rule
+					{
+					pushFollow(FOLLOW_rule_in_rules243);
+					rule();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:213:12: ^( PREC_RULE ( . )* )
+					{
+					match(input,PREC_RULE,FOLLOW_PREC_RULE_in_rules248); if (state.failed) return;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:213:24: ( . )*
+						loop14:
+						while (true) {
+							int alt14=2;
+							int LA14_0 = input.LA(1);
+							if ( ((LA14_0 >= ACTION && LA14_0 <= XDIGIT)) ) {
+								alt14=1;
+							}
+							else if ( (LA14_0==UP) ) {
+								alt14=2;
+							}
+
+							switch (alt14) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:213:24: .
+								{
+								matchAny(input); if (state.failed) return;
+								}
+								break;
+
+							default :
+								break loop14;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return;
+					}
+
+					}
+					break;
+
+				default :
+					if ( cnt15 >= 1 ) break loop15;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(15, input);
+					throw eee;
+				}
+				cnt15++;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "rules"
+
+
+	public static class rule_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "rule"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:216:1: rule : ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) ;
+	public final TreeToNFAConverter.rule_return rule() throws RecognitionException {
+		TreeToNFAConverter.rule_return retval = new TreeToNFAConverter.rule_return();
+		retval.start = input.LT(1);
+
+		GrammarAST id=null;
+		TreeRuleReturnScope b =null;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:217:2: ( ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:217:4: ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR )
+			{
+			match(input,RULE,FOLLOW_RULE_in_rule267); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_rule271); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+							currentRuleName = (id!=null?id.getText():null);
+							factory.setCurrentRule(grammar.getLocallyDefinedRule(currentRuleName));
+						}
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:222:4: ( modifier )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+			if ( (LA16_0==FRAGMENT||(LA16_0 >= PRIVATE && LA16_0 <= PUBLIC)) ) {
+				alt16=1;
+			}
+			switch (alt16) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:222:5: modifier
+					{
+					pushFollow(FOLLOW_modifier_in_rule282);
+					modifier();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			match(input,ARG,FOLLOW_ARG_in_rule290); if (state.failed) return retval;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return retval;
+				// org/antlr/grammar/v3/TreeToNFAConverter.g:223:10: ( ARG_ACTION )?
+				int alt17=2;
+				int LA17_0 = input.LA(1);
+				if ( (LA17_0==ARG_ACTION) ) {
+					alt17=1;
+				}
+				switch (alt17) {
+					case 1 :
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:223:11: ARG_ACTION
+						{
+						match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule293); if (state.failed) return retval;
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); if (state.failed) return retval;
+			}
+
+			match(input,RET,FOLLOW_RET_in_rule302); if (state.failed) return retval;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return retval;
+				// org/antlr/grammar/v3/TreeToNFAConverter.g:224:10: ( ARG_ACTION )?
+				int alt18=2;
+				int LA18_0 = input.LA(1);
+				if ( (LA18_0==ARG_ACTION) ) {
+					alt18=1;
+				}
+				switch (alt18) {
+					case 1 :
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:224:11: ARG_ACTION
+						{
+						match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_rule305); if (state.failed) return retval;
+						}
+						break;
+
+				}
+
+				match(input, Token.UP, null); if (state.failed) return retval;
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:225:4: ( throwsSpec )?
+			int alt19=2;
+			int LA19_0 = input.LA(1);
+			if ( (LA19_0==THROWS) ) {
+				alt19=1;
+			}
+			switch (alt19) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:225:5: throwsSpec
+					{
+					pushFollow(FOLLOW_throwsSpec_in_rule314);
+					throwsSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:226:4: ( ^( OPTIONS ( . )* ) )?
+			int alt21=2;
+			int LA21_0 = input.LA(1);
+			if ( (LA21_0==OPTIONS) ) {
+				alt21=1;
+			}
+			switch (alt21) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:226:6: ^( OPTIONS ( . )* )
+					{
+					match(input,OPTIONS,FOLLOW_OPTIONS_in_rule324); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:226:16: ( . )*
+						loop20:
+						while (true) {
+							int alt20=2;
+							int LA20_0 = input.LA(1);
+							if ( ((LA20_0 >= ACTION && LA20_0 <= XDIGIT)) ) {
+								alt20=1;
+							}
+							else if ( (LA20_0==UP) ) {
+								alt20=2;
+							}
+
+							switch (alt20) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:226:16: .
+								{
+								matchAny(input); if (state.failed) return retval;
+								}
+								break;
+
+							default :
+								break loop20;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:227:4: ( ruleScopeSpec )?
+			int alt22=2;
+			int LA22_0 = input.LA(1);
+			if ( (LA22_0==SCOPE) ) {
+				alt22=1;
+			}
+			switch (alt22) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:227:6: ruleScopeSpec
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_rule338);
+					ruleScopeSpec();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:228:4: ( ^( AMPERSAND ( . )* ) )*
+			loop24:
+			while (true) {
+				int alt24=2;
+				int LA24_0 = input.LA(1);
+				if ( (LA24_0==AMPERSAND) ) {
+					alt24=1;
+				}
+
+				switch (alt24) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:228:6: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_rule349); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:228:18: ( . )*
+						loop23:
+						while (true) {
+							int alt23=2;
+							int LA23_0 = input.LA(1);
+							if ( ((LA23_0 >= ACTION && LA23_0 <= XDIGIT)) ) {
+								alt23=1;
+							}
+							else if ( (LA23_0==UP) ) {
+								alt23=2;
+							}
+
+							switch (alt23) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:228:18: .
+								{
+								matchAny(input); if (state.failed) return retval;
+								}
+								break;
+
+							default :
+								break loop23;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+
+				default :
+					break loop24;
+				}
+			}
+
+			pushFollow(FOLLOW_block_in_rule363);
+			b=block();
+			state._fsp--;
+			if (state.failed) return retval;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:230:4: ( exceptionGroup )?
+			int alt25=2;
+			int LA25_0 = input.LA(1);
+			if ( (LA25_0==CATCH||LA25_0==FINALLY) ) {
+				alt25=1;
+			}
+			switch (alt25) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:230:5: exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_rule369);
+					exceptionGroup();
+					state._fsp--;
+					if (state.failed) return retval;
+					}
+					break;
+
+			}
+
+			match(input,EOR,FOLLOW_EOR_in_rule376); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+							StateCluster g = (b!=null?((TreeToNFAConverter.block_return)b).g:null);
+							if ((b!=null?((GrammarAST)b.start):null).getSetValue() != null)
+							{
+								// if block comes back as a set not BLOCK, make it
+								// a single ALT block
+								g = factory.build_AlternativeBlockFromSet(g);
+							}
+							if (Rule.getRuleType(currentRuleName) == Grammar.PARSER || grammar.type==Grammar.LEXER)
+							{
+								// attach start node to block for this rule
+								Rule thisR = grammar.getLocallyDefinedRule(currentRuleName);
+								NFAState start = thisR.startState;
+								start.associatedASTNode = id;
+								start.addTransition(new Transition(Label.EPSILON, g.left));
+
+								// track decision if > 1 alts
+								if ( grammar.getNumberOfAltsForDecisionNFA(g.left)>1 )
+								{
+									g.left.setDescription(grammar.grammarTreeToString(((GrammarAST)retval.start), false));
+									g.left.setDecisionASTNode((b!=null?((GrammarAST)b.start):null));
+									int d = grammar.assignDecisionNumber( g.left );
+									grammar.setDecisionNFA( d, g.left );
+									grammar.setDecisionBlockAST(d, (b!=null?((GrammarAST)b.start):null));
+								}
+
+								// hook to end of rule node
+								NFAState end = thisR.stopState;
+								g.right.addTransition(new Transition(Label.EPSILON,end));
+							}
+						}
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rule"
+
+
+
+	// $ANTLR start "modifier"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:266:1: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
+	public final void modifier() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:267:2: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) ) {
+				input.consume();
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "modifier"
+
+
+
+	// $ANTLR start "throwsSpec"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:273:1: throwsSpec : ^( 'throws' ( ID )+ ) ;
+	public final void throwsSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:274:2: ( ^( 'throws' ( ID )+ ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:274:4: ^( 'throws' ( ID )+ )
+			{
+			match(input,THROWS,FOLLOW_THROWS_in_throwsSpec423); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:274:15: ( ID )+
+			int cnt26=0;
+			loop26:
+			while (true) {
+				int alt26=2;
+				int LA26_0 = input.LA(1);
+				if ( (LA26_0==ID) ) {
+					alt26=1;
+				}
+
+				switch (alt26) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:274:15: ID
+					{
+					match(input,ID,FOLLOW_ID_in_throwsSpec425); if (state.failed) return;
+					}
+					break;
+
+				default :
+					if ( cnt26 >= 1 ) break loop26;
+					if (state.backtracking>0) {state.failed=true; return;}
+					EarlyExitException eee = new EarlyExitException(26, input);
+					throw eee;
+				}
+				cnt26++;
+			}
+
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "throwsSpec"
+
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:277:1: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
+	public final void ruleScopeSpec() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:278:2: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:278:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
+			{
+			match(input,SCOPE,FOLLOW_SCOPE_in_ruleScopeSpec440); if (state.failed) return;
+			if ( input.LA(1)==Token.DOWN ) {
+				match(input, Token.DOWN, null); if (state.failed) return;
+				// org/antlr/grammar/v3/TreeToNFAConverter.g:278:15: ( ^( AMPERSAND ( . )* ) )*
+				loop28:
+				while (true) {
+					int alt28=2;
+					int LA28_0 = input.LA(1);
+					if ( (LA28_0==AMPERSAND) ) {
+						alt28=1;
+					}
+
+					switch (alt28) {
+					case 1 :
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:278:17: ^( AMPERSAND ( . )* )
+						{
+						match(input,AMPERSAND,FOLLOW_AMPERSAND_in_ruleScopeSpec445); if (state.failed) return;
+						if ( input.LA(1)==Token.DOWN ) {
+							match(input, Token.DOWN, null); if (state.failed) return;
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:278:29: ( . )*
+							loop27:
+							while (true) {
+								int alt27=2;
+								int LA27_0 = input.LA(1);
+								if ( ((LA27_0 >= ACTION && LA27_0 <= XDIGIT)) ) {
+									alt27=1;
+								}
+								else if ( (LA27_0==UP) ) {
+									alt27=2;
+								}
+
+								switch (alt27) {
+								case 1 :
+									// org/antlr/grammar/v3/TreeToNFAConverter.g:278:29: .
+									{
+									matchAny(input); if (state.failed) return;
+									}
+									break;
+
+								default :
+									break loop27;
+								}
+							}
+
+							match(input, Token.UP, null); if (state.failed) return;
+						}
+
+						}
+						break;
+
+					default :
+						break loop28;
+					}
+				}
+
+				// org/antlr/grammar/v3/TreeToNFAConverter.g:278:36: ( ACTION )?
+				int alt29=2;
+				int LA29_0 = input.LA(1);
+				if ( (LA29_0==ACTION) ) {
+					alt29=1;
+				}
+				switch (alt29) {
+					case 1 :
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:278:37: ACTION
+						{
+						match(input,ACTION,FOLLOW_ACTION_in_ruleScopeSpec455); if (state.failed) return;
+						}
+						break;
+
+				}
+
+				// org/antlr/grammar/v3/TreeToNFAConverter.g:278:46: ( ID )*
+				loop30:
+				while (true) {
+					int alt30=2;
+					int LA30_0 = input.LA(1);
+					if ( (LA30_0==ID) ) {
+						alt30=1;
+					}
+
+					switch (alt30) {
+					case 1 :
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:278:48: ID
+						{
+						match(input,ID,FOLLOW_ID_in_ruleScopeSpec461); if (state.failed) return;
+						}
+						break;
+
+					default :
+						break loop30;
+					}
+				}
+
+				match(input, Token.UP, null); if (state.failed) return;
+			}
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+
+	public static class block_return extends TreeRuleReturnScope {
+		public StateCluster g = null;
+	};
+
+
+	// $ANTLR start "block"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:281:1: block returns [StateCluster g = null] : ({...}? => set | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB ) );
+	public final TreeToNFAConverter.block_return block() throws RecognitionException {
+		TreeToNFAConverter.block_return retval = new TreeToNFAConverter.block_return();
+		retval.start = input.LT(1);
+
+		StateCluster a =null;
+		TreeRuleReturnScope set1 =null;
+
+
+			List<StateCluster> alts = new ArrayList<StateCluster>();
+			this.blockLevel++;
+			if ( this.blockLevel==1 )
+				this.outerAltNum=1;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:289:2: ({...}? => set | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB ) )
+			int alt34=2;
+			int LA34_0 = input.LA(1);
+			if ( (LA34_0==BLOCK) ) {
+				int LA34_1 = input.LA(2);
+				if ( ((grammar.isValidSet(this,((GrammarAST)retval.start)) &&
+						 !currentRuleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME))) ) {
+					alt34=1;
+				}
+				else if ( (true) ) {
+					alt34=2;
+				}
+
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 34, 0, input);
+				throw nvae;
+			}
+
+			switch (alt34) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:289:4: {...}? => set
+					{
+					if ( !((grammar.isValidSet(this,((GrammarAST)retval.start)) &&
+							 !currentRuleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME))) ) {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						throw new FailedPredicateException(input, "block", "grammar.isValidSet(this,$start) &&\n\t\t !currentRuleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME)");
+					}
+					pushFollow(FOLLOW_set_in_block492);
+					set1=set();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = (set1!=null?((TreeToNFAConverter.set_return)set1).g:null);}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:293:4: ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB )
+					{
+					match(input,BLOCK,FOLLOW_BLOCK_in_block502); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:293:13: ( ^( OPTIONS ( . )* ) )?
+					int alt32=2;
+					int LA32_0 = input.LA(1);
+					if ( (LA32_0==OPTIONS) ) {
+						alt32=1;
+					}
+					switch (alt32) {
+						case 1 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:293:15: ^( OPTIONS ( . )* )
+							{
+							match(input,OPTIONS,FOLLOW_OPTIONS_in_block507); if (state.failed) return retval;
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); if (state.failed) return retval;
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:293:25: ( . )*
+								loop31:
+								while (true) {
+									int alt31=2;
+									int LA31_0 = input.LA(1);
+									if ( ((LA31_0 >= ACTION && LA31_0 <= XDIGIT)) ) {
+										alt31=1;
+									}
+									else if ( (LA31_0==UP) ) {
+										alt31=2;
+									}
+
+									switch (alt31) {
+									case 1 :
+										// org/antlr/grammar/v3/TreeToNFAConverter.g:293:25: .
+										{
+										matchAny(input); if (state.failed) return retval;
+										}
+										break;
+
+									default :
+										break loop31;
+									}
+								}
+
+								match(input, Token.UP, null); if (state.failed) return retval;
+							}
+
+							}
+							break;
+
+					}
+
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:294:4: (a= alternative rewrite )+
+					int cnt33=0;
+					loop33:
+					while (true) {
+						int alt33=2;
+						int LA33_0 = input.LA(1);
+						if ( (LA33_0==ALT) ) {
+							alt33=1;
+						}
+
+						switch (alt33) {
+						case 1 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:294:6: a= alternative rewrite
+							{
+							pushFollow(FOLLOW_alternative_in_block523);
+							a=alternative();
+							state._fsp--;
+							if (state.failed) return retval;
+							pushFollow(FOLLOW_rewrite_in_block525);
+							rewrite();
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+												alts.add(a);
+											}
+
+												if ( blockLevel == 1 )
+													outerAltNum++;
+											
+							}
+							break;
+
+						default :
+							if ( cnt33 >= 1 ) break loop33;
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							EarlyExitException eee = new EarlyExitException(33, input);
+							throw eee;
+						}
+						cnt33++;
+					}
+
+					match(input,EOB,FOLLOW_EOB_in_block548); if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) {retval.g = factory.build_AlternativeBlock(alts);}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+			 blockLevel--; 
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+
+	// $ANTLR start "alternative"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:309:1: alternative returns [StateCluster g=null] : ^( ALT (e= element )+ EOA ) ;
+	public final StateCluster alternative() throws RecognitionException {
+		StateCluster g = null;
+
+
+		TreeRuleReturnScope e =null;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:310:2: ( ^( ALT (e= element )+ EOA ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:310:4: ^( ALT (e= element )+ EOA )
+			{
+			match(input,ALT,FOLLOW_ALT_in_alternative577); if (state.failed) return g;
+			match(input, Token.DOWN, null); if (state.failed) return g;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:310:11: (e= element )+
+			int cnt35=0;
+			loop35:
+			while (true) {
+				int alt35=2;
+				int LA35_0 = input.LA(1);
+				if ( (LA35_0==ACTION||(LA35_0 >= ASSIGN && LA35_0 <= BLOCK)||(LA35_0 >= CHAR_LITERAL && LA35_0 <= CHAR_RANGE)||LA35_0==CLOSURE||LA35_0==DOT||LA35_0==EPSILON||LA35_0==FORCED_ACTION||LA35_0==GATED_SEMPRED||LA35_0==NOT||LA35_0==OPTIONAL||(LA35_0 >= PLUS_ASSIGN && LA35_0 <= POSITIVE_CLOSURE)||LA35_0==RANGE||LA35_0==ROOT||LA35_0==RULE_REF||LA35_0==SEMPRED||(LA35_0 >= STRING_LITERAL && LA35_0 <= SYN_SEMPRED)||LA35_0==TOKEN_REF||LA35_0==TREE_BEGIN||LA35_0==WILDCARD) ) {
+					alt35=1;
+				}
+
+				switch (alt35) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:310:12: e= element
+					{
+					pushFollow(FOLLOW_element_in_alternative582);
+					e=element();
+					state._fsp--;
+					if (state.failed) return g;
+					if ( state.backtracking==0 ) {g = factory.build_AB(g,(e!=null?((TreeToNFAConverter.element_return)e).g:null));}
+					}
+					break;
+
+				default :
+					if ( cnt35 >= 1 ) break loop35;
+					if (state.backtracking>0) {state.failed=true; return g;}
+					EarlyExitException eee = new EarlyExitException(35, input);
+					throw eee;
+				}
+				cnt35++;
+			}
+
+			match(input,EOA,FOLLOW_EOA_in_alternative589); if (state.failed) return g;
+			match(input, Token.UP, null); if (state.failed) return g;
+
+			if ( state.backtracking==0 ) {
+						if (g==null) { // if alt was a list of actions or whatever
+							g = factory.build_Epsilon();
+						}
+						else {
+							factory.optimizeAlternative(g);
+						}
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return g;
+	}
+	// $ANTLR end "alternative"
+
+
+
+	// $ANTLR start "exceptionGroup"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:321:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	public final void exceptionGroup() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:322:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt38=2;
+			int LA38_0 = input.LA(1);
+			if ( (LA38_0==CATCH) ) {
+				alt38=1;
+			}
+			else if ( (LA38_0==FINALLY) ) {
+				alt38=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 38, 0, input);
+				throw nvae;
+			}
+
+			switch (alt38) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:322:4: ( exceptionHandler )+ ( finallyClause )?
+					{
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:322:4: ( exceptionHandler )+
+					int cnt36=0;
+					loop36:
+					while (true) {
+						int alt36=2;
+						int LA36_0 = input.LA(1);
+						if ( (LA36_0==CATCH) ) {
+							alt36=1;
+						}
+
+						switch (alt36) {
+						case 1 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:322:6: exceptionHandler
+							{
+							pushFollow(FOLLOW_exceptionHandler_in_exceptionGroup608);
+							exceptionHandler();
+							state._fsp--;
+							if (state.failed) return;
+							}
+							break;
+
+						default :
+							if ( cnt36 >= 1 ) break loop36;
+							if (state.backtracking>0) {state.failed=true; return;}
+							EarlyExitException eee = new EarlyExitException(36, input);
+							throw eee;
+						}
+						cnt36++;
+					}
+
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:322:26: ( finallyClause )?
+					int alt37=2;
+					int LA37_0 = input.LA(1);
+					if ( (LA37_0==FINALLY) ) {
+						alt37=1;
+					}
+					switch (alt37) {
+						case 1 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:322:27: finallyClause
+							{
+							pushFollow(FOLLOW_finallyClause_in_exceptionGroup614);
+							finallyClause();
+							state._fsp--;
+							if (state.failed) return;
+							}
+							break;
+
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:323:4: finallyClause
+					{
+					pushFollow(FOLLOW_finallyClause_in_exceptionGroup621);
+					finallyClause();
+					state._fsp--;
+					if (state.failed) return;
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+
+	// $ANTLR start "exceptionHandler"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:326:1: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	public final void exceptionHandler() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:327:2: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:327:7: ^( 'catch' ARG_ACTION ACTION )
+			{
+			match(input,CATCH,FOLLOW_CATCH_in_exceptionHandler636); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_exceptionHandler638); if (state.failed) return;
+			match(input,ACTION,FOLLOW_ACTION_in_exceptionHandler640); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+
+	// $ANTLR start "finallyClause"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:330:1: finallyClause : ^( 'finally' ACTION ) ;
+	public final void finallyClause() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:331:2: ( ^( 'finally' ACTION ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:331:7: ^( 'finally' ACTION )
+			{
+			match(input,FINALLY,FOLLOW_FINALLY_in_finallyClause656); if (state.failed) return;
+			match(input, Token.DOWN, null); if (state.failed) return;
+			match(input,ACTION,FOLLOW_ACTION_in_finallyClause658); if (state.failed) return;
+			match(input, Token.UP, null); if (state.failed) return;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "finallyClause"
+
+
+	public static class rewrite_return extends TreeRuleReturnScope {
+	};
+
+
+	// $ANTLR start "rewrite"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:334:1: rewrite : ( ^( REWRITES ( ^( REWRITE ( . )* ) )* ) |);
+	public final TreeToNFAConverter.rewrite_return rewrite() throws RecognitionException {
+		TreeToNFAConverter.rewrite_return retval = new TreeToNFAConverter.rewrite_return();
+		retval.start = input.LT(1);
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:335:2: ( ^( REWRITES ( ^( REWRITE ( . )* ) )* ) |)
+			int alt41=2;
+			int LA41_0 = input.LA(1);
+			if ( (LA41_0==REWRITES) ) {
+				alt41=1;
+			}
+			else if ( (LA41_0==ALT||LA41_0==EOB) ) {
+				alt41=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 41, 0, input);
+				throw nvae;
+			}
+
+			switch (alt41) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:335:4: ^( REWRITES ( ^( REWRITE ( . )* ) )* )
+					{
+					match(input,REWRITES,FOLLOW_REWRITES_in_rewrite672); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:336:4: ( ^( REWRITE ( . )* ) )*
+						loop40:
+						while (true) {
+							int alt40=2;
+							int LA40_0 = input.LA(1);
+							if ( (LA40_0==REWRITE) ) {
+								alt40=1;
+							}
+
+							switch (alt40) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:337:5: ^( REWRITE ( . )* )
+								{
+								if ( state.backtracking==0 ) {
+													if ( grammar.getOption("output")==null )
+													{
+														ErrorManager.grammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
+																				  grammar, ((GrammarAST)retval.start).getToken(), currentRuleName);
+													}
+												}
+								match(input,REWRITE,FOLLOW_REWRITE_in_rewrite690); if (state.failed) return retval;
+								if ( input.LA(1)==Token.DOWN ) {
+									match(input, Token.DOWN, null); if (state.failed) return retval;
+									// org/antlr/grammar/v3/TreeToNFAConverter.g:344:15: ( . )*
+									loop39:
+									while (true) {
+										int alt39=2;
+										int LA39_0 = input.LA(1);
+										if ( ((LA39_0 >= ACTION && LA39_0 <= XDIGIT)) ) {
+											alt39=1;
+										}
+										else if ( (LA39_0==UP) ) {
+											alt39=2;
+										}
+
+										switch (alt39) {
+										case 1 :
+											// org/antlr/grammar/v3/TreeToNFAConverter.g:344:15: .
+											{
+											matchAny(input); if (state.failed) return retval;
+											}
+											break;
+
+										default :
+											break loop39;
+										}
+									}
+
+									match(input, Token.UP, null); if (state.failed) return retval;
+								}
+
+								}
+								break;
+
+							default :
+								break loop40;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:348:2: 
+					{
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite"
+
+
+	public static class element_return extends TreeRuleReturnScope {
+		public StateCluster g=null;
+	};
+
+
+	// $ANTLR start "element"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:350:1: element returns [StateCluster g=null] : ( ^( ROOT e= element ) | ^( BANG e= element ) | ^( ASSIGN ID e= element ) | ^( PLUS_ASSIGN ID e= element ) | ^( RANGE a= atom[null] b= atom[null] ) | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | atom_or_notatom | ebnf | tree_ | ^( SYNPRED block ) | ACTION | FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^(bpred= BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON );
+	public final TreeToNFAConverter.element_return element() throws RecognitionException {
+		TreeToNFAConverter.element_return retval = new TreeToNFAConverter.element_return();
+		retval.start = input.LT(1);
+
+		GrammarAST c1=null;
+		GrammarAST c2=null;
+		GrammarAST pred=null;
+		GrammarAST spred=null;
+		GrammarAST bpred=null;
+		GrammarAST gpred=null;
+		GrammarAST ACTION5=null;
+		GrammarAST FORCED_ACTION6=null;
+		TreeRuleReturnScope e =null;
+		TreeRuleReturnScope a =null;
+		TreeRuleReturnScope b =null;
+		StateCluster atom_or_notatom2 =null;
+		TreeRuleReturnScope ebnf3 =null;
+		TreeRuleReturnScope tree_4 =null;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:351:2: ( ^( ROOT e= element ) | ^( BANG e= element ) | ^( ASSIGN ID e= element ) | ^( PLUS_ASSIGN ID e= element ) | ^( RANGE a= atom[null] b= atom[null] ) | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | atom_or_notatom | ebnf | tree_ | ^( SYNPRED block ) | ACTION | FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^(bpred= BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON )
+			int alt43=17;
+			switch ( input.LA(1) ) {
+			case ROOT:
+				{
+				alt43=1;
+				}
+				break;
+			case BANG:
+				{
+				alt43=2;
+				}
+				break;
+			case ASSIGN:
+				{
+				alt43=3;
+				}
+				break;
+			case PLUS_ASSIGN:
+				{
+				alt43=4;
+				}
+				break;
+			case RANGE:
+				{
+				alt43=5;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt43=6;
+				}
+				break;
+			case CHAR_LITERAL:
+			case DOT:
+			case NOT:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case WILDCARD:
+				{
+				alt43=7;
+				}
+				break;
+			case BLOCK:
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt43=8;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt43=9;
+				}
+				break;
+			case SYNPRED:
+				{
+				alt43=10;
+				}
+				break;
+			case ACTION:
+				{
+				alt43=11;
+				}
+				break;
+			case FORCED_ACTION:
+				{
+				alt43=12;
+				}
+				break;
+			case SEMPRED:
+				{
+				alt43=13;
+				}
+				break;
+			case SYN_SEMPRED:
+				{
+				alt43=14;
+				}
+				break;
+			case BACKTRACK_SEMPRED:
+				{
+				alt43=15;
+				}
+				break;
+			case GATED_SEMPRED:
+				{
+				alt43=16;
+				}
+				break;
+			case EPSILON:
+				{
+				alt43=17;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 43, 0, input);
+				throw nvae;
+			}
+			switch (alt43) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:351:6: ^( ROOT e= element )
+					{
+					match(input,ROOT,FOLLOW_ROOT_in_element725); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element729);
+					e=element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = (e!=null?((TreeToNFAConverter.element_return)e).g:null);}
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:352:6: ^( BANG e= element )
+					{
+					match(input,BANG,FOLLOW_BANG_in_element740); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element744);
+					e=element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = (e!=null?((TreeToNFAConverter.element_return)e).g:null);}
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:353:4: ^( ASSIGN ID e= element )
+					{
+					match(input,ASSIGN,FOLLOW_ASSIGN_in_element753); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					match(input,ID,FOLLOW_ID_in_element755); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element759);
+					e=element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = (e!=null?((TreeToNFAConverter.element_return)e).g:null);}
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:354:4: ^( PLUS_ASSIGN ID e= element )
+					{
+					match(input,PLUS_ASSIGN,FOLLOW_PLUS_ASSIGN_in_element768); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					match(input,ID,FOLLOW_ID_in_element770); if (state.failed) return retval;
+					pushFollow(FOLLOW_element_in_element774);
+					e=element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = (e!=null?((TreeToNFAConverter.element_return)e).g:null);}
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:355:6: ^( RANGE a= atom[null] b= atom[null] )
+					{
+					match(input,RANGE,FOLLOW_RANGE_in_element785); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_atom_in_element789);
+					a=atom(null);
+					state._fsp--;
+					if (state.failed) return retval;
+					pushFollow(FOLLOW_atom_in_element794);
+					b=atom(null);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) {retval.g = factory.build_Range(grammar.getTokenType((a!=null?(input.getTokenStream().toString(input.getTreeAdaptor().getTokenStartIndex(a.start),input.getTreeAdaptor().getTokenStopIndex(a.start))):null)),
+													 grammar.getTokenType((b!=null?(input.getTokenStream().toString(input.getTreeAdaptor().getTokenStartIndex(b.start),input.getTreeAdaptor().getTokenStopIndex(b.start))):null)));}
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:358:6: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
+					{
+					match(input,CHAR_RANGE,FOLLOW_CHAR_RANGE_in_element808); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					c1=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_element812); if (state.failed) return retval;
+					c2=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_element816); if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) {
+							if ( grammar.type==Grammar.LEXER ) {
+								retval.g = factory.build_CharRange((c1!=null?c1.getText():null), (c2!=null?c2.getText():null));
+							}
+							}
+					}
+					break;
+				case 7 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:364:6: atom_or_notatom
+					{
+					pushFollow(FOLLOW_atom_or_notatom_in_element828);
+					atom_or_notatom2=atom_or_notatom();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = atom_or_notatom2;}
+					}
+					break;
+				case 8 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:365:6: ebnf
+					{
+					pushFollow(FOLLOW_ebnf_in_element837);
+					ebnf3=ebnf();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = (ebnf3!=null?((TreeToNFAConverter.ebnf_return)ebnf3).g:null);}
+					}
+					break;
+				case 9 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:366:6: tree_
+					{
+					pushFollow(FOLLOW_tree__in_element846);
+					tree_4=tree_();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = (tree_4!=null?((TreeToNFAConverter.tree__return)tree_4).g:null);}
+					}
+					break;
+				case 10 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:367:6: ^( SYNPRED block )
+					{
+					match(input,SYNPRED,FOLLOW_SYNPRED_in_element857); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_block_in_element859);
+					block();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+				case 11 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:368:6: ACTION
+					{
+					ACTION5=(GrammarAST)match(input,ACTION,FOLLOW_ACTION_in_element868); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = factory.build_Action(ACTION5);}
+					}
+					break;
+				case 12 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:369:6: FORCED_ACTION
+					{
+					FORCED_ACTION6=(GrammarAST)match(input,FORCED_ACTION,FOLLOW_FORCED_ACTION_in_element877); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = factory.build_Action(FORCED_ACTION6);}
+					}
+					break;
+				case 13 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:370:6: pred= SEMPRED
+					{
+					pred=(GrammarAST)match(input,SEMPRED,FOLLOW_SEMPRED_in_element888); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = factory.build_SemanticPredicate(pred);}
+					}
+					break;
+				case 14 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:371:6: spred= SYN_SEMPRED
+					{
+					spred=(GrammarAST)match(input,SYN_SEMPRED,FOLLOW_SYN_SEMPRED_in_element899); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = factory.build_SemanticPredicate(spred);}
+					}
+					break;
+				case 15 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:372:6: ^(bpred= BACKTRACK_SEMPRED ( . )* )
+					{
+					bpred=(GrammarAST)match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_element911); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:372:32: ( . )*
+						loop42:
+						while (true) {
+							int alt42=2;
+							int LA42_0 = input.LA(1);
+							if ( ((LA42_0 >= ACTION && LA42_0 <= XDIGIT)) ) {
+								alt42=1;
+							}
+							else if ( (LA42_0==UP) ) {
+								alt42=2;
+							}
+
+							switch (alt42) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:372:32: .
+								{
+								matchAny(input); if (state.failed) return retval;
+								}
+								break;
+
+							default :
+								break loop42;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					if ( state.backtracking==0 ) {retval.g = factory.build_SemanticPredicate(bpred);}
+					}
+					break;
+				case 16 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:373:6: gpred= GATED_SEMPRED
+					{
+					gpred=(GrammarAST)match(input,GATED_SEMPRED,FOLLOW_GATED_SEMPRED_in_element926); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = factory.build_SemanticPredicate(gpred);}
+					}
+					break;
+				case 17 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:374:6: EPSILON
+					{
+					match(input,EPSILON,FOLLOW_EPSILON_in_element935); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = factory.build_Epsilon();}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "element"
+
+
+	public static class ebnf_return extends TreeRuleReturnScope {
+		public StateCluster g=null;
+	};
+
+
+	// $ANTLR start "ebnf"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:377:1: ebnf returns [StateCluster g=null] : ({...}? => set |b= block | ^( OPTIONAL b= block ) | ^( CLOSURE b= block ) | ^( POSITIVE_CLOSURE b= block ) );
+	public final TreeToNFAConverter.ebnf_return ebnf() throws RecognitionException {
+		TreeToNFAConverter.ebnf_return retval = new TreeToNFAConverter.ebnf_return();
+		retval.start = input.LT(1);
+
+		TreeRuleReturnScope b =null;
+		TreeRuleReturnScope set7 =null;
+
+
+			GrammarAST blk = ((GrammarAST)retval.start);
+			if (blk.getType() != BLOCK) {
+				blk = (GrammarAST)blk.getChild(0);
+			}
+			GrammarAST eob = blk.getLastChild();
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:386:2: ({...}? => set |b= block | ^( OPTIONAL b= block ) | ^( CLOSURE b= block ) | ^( POSITIVE_CLOSURE b= block ) )
+			int alt44=5;
+			switch ( input.LA(1) ) {
+			case BLOCK:
+				{
+				int LA44_1 = input.LA(2);
+				if ( ((grammar.isValidSet(this,((GrammarAST)retval.start)))) ) {
+					alt44=1;
+				}
+				else if ( (true) ) {
+					alt44=2;
+				}
+
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt44=3;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt44=4;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt44=5;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 44, 0, input);
+				throw nvae;
+			}
+			switch (alt44) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:386:4: {...}? => set
+					{
+					if ( !((grammar.isValidSet(this,((GrammarAST)retval.start)))) ) {
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						throw new FailedPredicateException(input, "ebnf", "grammar.isValidSet(this,$start)");
+					}
+					pushFollow(FOLLOW_set_in_ebnf961);
+					set7=set();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = (set7!=null?((TreeToNFAConverter.set_return)set7).g:null);}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:388:4: b= block
+					{
+					pushFollow(FOLLOW_block_in_ebnf971);
+					b=block();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+								// track decision if > 1 alts
+								if ( grammar.getNumberOfAltsForDecisionNFA((b!=null?((TreeToNFAConverter.block_return)b).g:null).left)>1 )
+								{
+									(b!=null?((TreeToNFAConverter.block_return)b).g:null).left.setDescription(grammar.grammarTreeToString(blk, false));
+									(b!=null?((TreeToNFAConverter.block_return)b).g:null).left.setDecisionASTNode(blk);
+									int d = grammar.assignDecisionNumber( (b!=null?((TreeToNFAConverter.block_return)b).g:null).left );
+									grammar.setDecisionNFA( d, (b!=null?((TreeToNFAConverter.block_return)b).g:null).left );
+									grammar.setDecisionBlockAST(d, blk);
+								}
+								retval.g = (b!=null?((TreeToNFAConverter.block_return)b).g:null);
+							}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:401:4: ^( OPTIONAL b= block )
+					{
+					match(input,OPTIONAL,FOLLOW_OPTIONAL_in_ebnf982); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_block_in_ebnf986);
+					b=block();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) {
+								StateCluster bg = (b!=null?((TreeToNFAConverter.block_return)b).g:null);
+								if ( blk.getSetValue()!=null )
+								{
+									// if block comes back SET not BLOCK, make it
+									// a single ALT block
+									bg = factory.build_AlternativeBlockFromSet(bg);
+								}
+								retval.g = factory.build_Aoptional(bg);
+								retval.g.left.setDescription(grammar.grammarTreeToString(((GrammarAST)retval.start), false));
+								// there is always at least one alt even if block has just 1 alt
+								int d = grammar.assignDecisionNumber( retval.g.left );
+								grammar.setDecisionNFA(d, retval.g.left);
+								grammar.setDecisionBlockAST(d, blk);
+								retval.g.left.setDecisionASTNode(((GrammarAST)retval.start));
+							}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:418:4: ^( CLOSURE b= block )
+					{
+					match(input,CLOSURE,FOLLOW_CLOSURE_in_ebnf999); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_block_in_ebnf1003);
+					b=block();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) {
+								StateCluster bg = (b!=null?((TreeToNFAConverter.block_return)b).g:null);
+								if ( blk.getSetValue()!=null )
+								{
+									bg = factory.build_AlternativeBlockFromSet(bg);
+								}
+								retval.g = factory.build_Astar(bg);
+								// track the loop back / exit decision point
+								bg.right.setDescription("()* loopback of "+grammar.grammarTreeToString(((GrammarAST)retval.start), false));
+								int d = grammar.assignDecisionNumber( bg.right );
+								grammar.setDecisionNFA(d, bg.right);
+								grammar.setDecisionBlockAST(d, blk);
+								bg.right.setDecisionASTNode(eob);
+								// make block entry state also have same decision for interpreting grammar
+								NFAState altBlockState = (NFAState)retval.g.left.transition(0).target;
+								altBlockState.setDecisionASTNode(((GrammarAST)retval.start));
+								altBlockState.setDecisionNumber(d);
+								retval.g.left.setDecisionNumber(d); // this is the bypass decision (2 alts)
+								retval.g.left.setDecisionASTNode(((GrammarAST)retval.start));
+							}
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:439:4: ^( POSITIVE_CLOSURE b= block )
+					{
+					match(input,POSITIVE_CLOSURE,FOLLOW_POSITIVE_CLOSURE_in_ebnf1016); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					pushFollow(FOLLOW_block_in_ebnf1020);
+					b=block();
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					if ( state.backtracking==0 ) {
+								StateCluster bg = (b!=null?((TreeToNFAConverter.block_return)b).g:null);
+								if ( blk.getSetValue()!=null )
+								{
+									bg = factory.build_AlternativeBlockFromSet(bg);
+								}
+								retval.g = factory.build_Aplus(bg);
+								// don't make a decision on left edge, can reuse loop end decision
+								// track the loop back / exit decision point
+								bg.right.setDescription("()+ loopback of "+grammar.grammarTreeToString(((GrammarAST)retval.start), false));
+								int d = grammar.assignDecisionNumber( bg.right );
+								grammar.setDecisionNFA(d, bg.right);
+								grammar.setDecisionBlockAST(d, blk);
+								bg.right.setDecisionASTNode(eob);
+								// make block entry state also have same decision for interpreting grammar
+								NFAState altBlockState = (NFAState)retval.g.left.transition(0).target;
+								altBlockState.setDecisionASTNode(((GrammarAST)retval.start));
+								altBlockState.setDecisionNumber(d);
+							}
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "ebnf"
+
+
+	public static class tree__return extends TreeRuleReturnScope {
+		public StateCluster g=null;
+	};
+
+
+	// $ANTLR start "tree_"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:461:1: tree_ returns [StateCluster g=null] : ^( TREE_BEGIN e= element (e= element )* ) ;
+	public final TreeToNFAConverter.tree__return tree_() throws RecognitionException {
+		TreeToNFAConverter.tree__return retval = new TreeToNFAConverter.tree__return();
+		retval.start = input.LT(1);
+
+		TreeRuleReturnScope e =null;
+
+
+			StateCluster down=null, up=null;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:466:2: ( ^( TREE_BEGIN e= element (e= element )* ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:466:4: ^( TREE_BEGIN e= element (e= element )* )
+			{
+			match(input,TREE_BEGIN,FOLLOW_TREE_BEGIN_in_tree_1048); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			pushFollow(FOLLOW_element_in_tree_1055);
+			e=element();
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking==0 ) { retval.g = (e!=null?((TreeToNFAConverter.element_return)e).g:null); }
+			if ( state.backtracking==0 ) {
+							down = factory.build_Atom(Label.DOWN, (e!=null?((GrammarAST)e.start):null));
+							// TODO set following states for imaginary nodes?
+							//el.followingNFAState = down.right;
+							retval.g = factory.build_AB(retval.g,down);
+						}
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:474:4: (e= element )*
+			loop45:
+			while (true) {
+				int alt45=2;
+				int LA45_0 = input.LA(1);
+				if ( (LA45_0==ACTION||(LA45_0 >= ASSIGN && LA45_0 <= BLOCK)||(LA45_0 >= CHAR_LITERAL && LA45_0 <= CHAR_RANGE)||LA45_0==CLOSURE||LA45_0==DOT||LA45_0==EPSILON||LA45_0==FORCED_ACTION||LA45_0==GATED_SEMPRED||LA45_0==NOT||LA45_0==OPTIONAL||(LA45_0 >= PLUS_ASSIGN && LA45_0 <= POSITIVE_CLOSURE)||LA45_0==RANGE||LA45_0==ROOT||LA45_0==RULE_REF||LA45_0==SEMPRED||(LA45_0 >= STRING_LITERAL && LA45_0 <= SYN_SEMPRED)||LA45_0==TOKEN_REF||LA45_0==TREE_BEGIN||LA45_0==WILDCARD) ) {
+					alt45=1;
+				}
+
+				switch (alt45) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:474:6: e= element
+					{
+					pushFollow(FOLLOW_element_in_tree_1071);
+					e=element();
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = factory.build_AB(retval.g,(e!=null?((TreeToNFAConverter.element_return)e).g:null));}
+					}
+					break;
+
+				default :
+					break loop45;
+				}
+			}
+
+			if ( state.backtracking==0 ) {
+							up = factory.build_Atom(Label.UP, (e!=null?((GrammarAST)e.start):null));
+							//el.followingNFAState = up.right;
+							retval.g = factory.build_AB(retval.g,up);
+							// tree roots point at right edge of DOWN for LOOK computation later
+							((GrammarAST)retval.start).NFATreeDownState = down.left;
+						}
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "tree_"
+
+
+
+	// $ANTLR start "atom_or_notatom"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:485:1: atom_or_notatom returns [StateCluster g=null] : ( atom[null] | ^(n= NOT (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set ) ) );
+	public final StateCluster atom_or_notatom() throws RecognitionException {
+		StateCluster g = null;
+
+
+		GrammarAST n=null;
+		GrammarAST c=null;
+		GrammarAST t=null;
+		TreeRuleReturnScope atom8 =null;
+		TreeRuleReturnScope set9 =null;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:486:2: ( atom[null] | ^(n= NOT (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set ) ) )
+			int alt49=2;
+			int LA49_0 = input.LA(1);
+			if ( (LA49_0==CHAR_LITERAL||LA49_0==DOT||LA49_0==RULE_REF||LA49_0==STRING_LITERAL||LA49_0==TOKEN_REF||LA49_0==WILDCARD) ) {
+				alt49=1;
+			}
+			else if ( (LA49_0==NOT) ) {
+				alt49=2;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return g;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 49, 0, input);
+				throw nvae;
+			}
+
+			switch (alt49) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:486:4: atom[null]
+					{
+					pushFollow(FOLLOW_atom_in_atom_or_notatom1100);
+					atom8=atom(null);
+					state._fsp--;
+					if (state.failed) return g;
+					if ( state.backtracking==0 ) {g = (atom8!=null?((TreeToNFAConverter.atom_return)atom8).g:null);}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:487:4: ^(n= NOT (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set ) )
+					{
+					n=(GrammarAST)match(input,NOT,FOLLOW_NOT_in_atom_or_notatom1112); if (state.failed) return g;
+					match(input, Token.DOWN, null); if (state.failed) return g;
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:488:4: (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set )
+					int alt48=3;
+					switch ( input.LA(1) ) {
+					case CHAR_LITERAL:
+						{
+						alt48=1;
+						}
+						break;
+					case TOKEN_REF:
+						{
+						alt48=2;
+						}
+						break;
+					case BLOCK:
+						{
+						alt48=3;
+						}
+						break;
+					default:
+						if (state.backtracking>0) {state.failed=true; return g;}
+						NoViableAltException nvae =
+							new NoViableAltException("", 48, 0, input);
+						throw nvae;
+					}
+					switch (alt48) {
+						case 1 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:488:6: c= CHAR_LITERAL (ast1= ast_suffix )?
+							{
+							c=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom_or_notatom1121); if (state.failed) return g;
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:488:21: (ast1= ast_suffix )?
+							int alt46=2;
+							int LA46_0 = input.LA(1);
+							if ( (LA46_0==BANG||LA46_0==ROOT) ) {
+								alt46=1;
+							}
+							switch (alt46) {
+								case 1 :
+									// org/antlr/grammar/v3/TreeToNFAConverter.g:488:22: ast1= ast_suffix
+									{
+									pushFollow(FOLLOW_ast_suffix_in_atom_or_notatom1126);
+									ast_suffix();
+									state._fsp--;
+									if (state.failed) return g;
+									}
+									break;
+
+							}
+
+							if ( state.backtracking==0 ) {
+												int ttype=0;
+												if ( grammar.type==Grammar.LEXER )
+												{
+													ttype = Grammar.getCharValueFromGrammarCharLiteral((c!=null?c.getText():null));
+												}
+												else
+												{
+													ttype = grammar.getTokenType((c!=null?c.getText():null));
+												}
+												IntSet notAtom = grammar.complement(ttype);
+												if ( notAtom.isNil() )
+												{
+													ErrorManager.grammarError(
+														ErrorManager.MSG_EMPTY_COMPLEMENT,
+														grammar,
+														c.getToken(),
+														(c!=null?c.getText():null));
+												}
+												g =factory.build_Set(notAtom,n);
+											}
+							}
+							break;
+						case 2 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:510:6: t= TOKEN_REF (ast3= ast_suffix )?
+							{
+							t=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom_or_notatom1143); if (state.failed) return g;
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:510:18: (ast3= ast_suffix )?
+							int alt47=2;
+							int LA47_0 = input.LA(1);
+							if ( (LA47_0==BANG||LA47_0==ROOT) ) {
+								alt47=1;
+							}
+							switch (alt47) {
+								case 1 :
+									// org/antlr/grammar/v3/TreeToNFAConverter.g:510:19: ast3= ast_suffix
+									{
+									pushFollow(FOLLOW_ast_suffix_in_atom_or_notatom1148);
+									ast_suffix();
+									state._fsp--;
+									if (state.failed) return g;
+									}
+									break;
+
+							}
+
+							if ( state.backtracking==0 ) {
+												int ttype=0;
+												IntSet notAtom = null;
+												if ( grammar.type==Grammar.LEXER )
+												{
+													notAtom = grammar.getSetFromRule(this,(t!=null?t.getText():null));
+													if ( notAtom==null )
+													{
+														ErrorManager.grammarError(
+															ErrorManager.MSG_RULE_INVALID_SET,
+															grammar,
+															t.getToken(),
+															(t!=null?t.getText():null));
+													}
+													else
+													{
+														notAtom = grammar.complement(notAtom);
+													}
+												}
+												else
+												{
+													ttype = grammar.getTokenType((t!=null?t.getText():null));
+													notAtom = grammar.complement(ttype);
+												}
+												if ( notAtom==null || notAtom.isNil() )
+												{
+													ErrorManager.grammarError(
+														ErrorManager.MSG_EMPTY_COMPLEMENT,
+														grammar,
+														t.getToken(),
+														(t!=null?t.getText():null));
+												}
+												g =factory.build_Set(notAtom,n);
+											}
+							}
+							break;
+						case 3 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:545:6: set
+							{
+							pushFollow(FOLLOW_set_in_atom_or_notatom1163);
+							set9=set();
+							state._fsp--;
+							if (state.failed) return g;
+							if ( state.backtracking==0 ) {g = (set9!=null?((TreeToNFAConverter.set_return)set9).g:null);}
+							if ( state.backtracking==0 ) {
+												GrammarAST stNode = (GrammarAST)n.getChild(0);
+												//IntSet notSet = grammar.complement(stNode.getSetValue());
+												// let code generator complement the sets
+												IntSet s = stNode.getSetValue();
+												stNode.setSetValue(s);
+												// let code gen do the complement again; here we compute
+												// for NFA construction
+												s = grammar.complement(s);
+												if ( s.isNil() )
+												{
+													ErrorManager.grammarError(
+														ErrorManager.MSG_EMPTY_COMPLEMENT,
+														grammar,
+														n.getToken());
+												}
+												g =factory.build_Set(s,n);
+											}
+							}
+							break;
+
+					}
+
+					if ( state.backtracking==0 ) {n.followingNFAState = g.right;}
+					match(input, Token.UP, null); if (state.failed) return g;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return g;
+	}
+	// $ANTLR end "atom_or_notatom"
+
+
+	public static class atom_return extends TreeRuleReturnScope {
+		public StateCluster g=null;
+	};
+
+
+	// $ANTLR start "atom"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:569:1: atom[String scopeName] returns [StateCluster g=null] : ( ^(r= RULE_REF (rarg= ARG_ACTION )? (as1= ast_suffix )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? (as2= ast_suffix )? ) | ^(c= CHAR_LITERAL (as3= ast_suffix )? ) | ^(s= STRING_LITERAL (as4= ast_suffix )? ) | ^(w= WILDCARD (as5= ast_suffix )? ) | ^( DOT scope_= ID a= atom[$scope_.text] ) );
+	public final TreeToNFAConverter.atom_return atom(String scopeName) throws RecognitionException {
+		TreeToNFAConverter.atom_return retval = new TreeToNFAConverter.atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST r=null;
+		GrammarAST rarg=null;
+		GrammarAST t=null;
+		GrammarAST targ=null;
+		GrammarAST c=null;
+		GrammarAST s=null;
+		GrammarAST w=null;
+		GrammarAST scope_=null;
+		TreeRuleReturnScope a =null;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:570:2: ( ^(r= RULE_REF (rarg= ARG_ACTION )? (as1= ast_suffix )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? (as2= ast_suffix )? ) | ^(c= CHAR_LITERAL (as3= ast_suffix )? ) | ^(s= STRING_LITERAL (as4= ast_suffix )? ) | ^(w= WILDCARD (as5= ast_suffix )? ) | ^( DOT scope_= ID a= atom[$scope_.text] ) )
+			int alt57=6;
+			switch ( input.LA(1) ) {
+			case RULE_REF:
+				{
+				alt57=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt57=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt57=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt57=4;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt57=5;
+				}
+				break;
+			case DOT:
+				{
+				alt57=6;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 57, 0, input);
+				throw nvae;
+			}
+			switch (alt57) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:570:4: ^(r= RULE_REF (rarg= ARG_ACTION )? (as1= ast_suffix )? )
+					{
+					r=(GrammarAST)match(input,RULE_REF,FOLLOW_RULE_REF_in_atom1205); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:570:18: (rarg= ARG_ACTION )?
+						int alt50=2;
+						int LA50_0 = input.LA(1);
+						if ( (LA50_0==ARG_ACTION) ) {
+							alt50=1;
+						}
+						switch (alt50) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:570:19: rarg= ARG_ACTION
+								{
+								rarg=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1210); if (state.failed) return retval;
+								}
+								break;
+
+						}
+
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:570:37: (as1= ast_suffix )?
+						int alt51=2;
+						int LA51_0 = input.LA(1);
+						if ( (LA51_0==BANG||LA51_0==ROOT) ) {
+							alt51=1;
+						}
+						switch (alt51) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:570:38: as1= ast_suffix
+								{
+								pushFollow(FOLLOW_ast_suffix_in_atom1217);
+								ast_suffix();
+								state._fsp--;
+								if (state.failed) return retval;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					if ( state.backtracking==0 ) {
+								NFAState start = grammar.getRuleStartState(scopeName,(r!=null?r.getText():null));
+								if ( start!=null )
+								{
+									Rule rr = grammar.getRule(scopeName,(r!=null?r.getText():null));
+									retval.g = factory.build_RuleRef(rr, start);
+									r.followingNFAState = retval.g.right;
+									r.NFAStartState = retval.g.left;
+									if ( retval.g.left.transition(0) instanceof RuleClosureTransition
+										&& grammar.type!=Grammar.LEXER )
+									{
+										addFollowTransition((r!=null?r.getText():null), retval.g.right);
+									}
+									// else rule ref got inlined to a set
+								}
+							}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:588:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? (as2= ast_suffix )? )
+					{
+					t=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_atom1235); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:588:20: (targ= ARG_ACTION )?
+						int alt52=2;
+						int LA52_0 = input.LA(1);
+						if ( (LA52_0==ARG_ACTION) ) {
+							alt52=1;
+						}
+						switch (alt52) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:588:21: targ= ARG_ACTION
+								{
+								targ=(GrammarAST)match(input,ARG_ACTION,FOLLOW_ARG_ACTION_in_atom1241); if (state.failed) return retval;
+								}
+								break;
+
+						}
+
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:588:39: (as2= ast_suffix )?
+						int alt53=2;
+						int LA53_0 = input.LA(1);
+						if ( (LA53_0==BANG||LA53_0==ROOT) ) {
+							alt53=1;
+						}
+						switch (alt53) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:588:40: as2= ast_suffix
+								{
+								pushFollow(FOLLOW_ast_suffix_in_atom1248);
+								ast_suffix();
+								state._fsp--;
+								if (state.failed) return retval;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					if ( state.backtracking==0 ) {
+								if ( grammar.type==Grammar.LEXER )
+								{
+									NFAState start = grammar.getRuleStartState(scopeName,(t!=null?t.getText():null));
+									if ( start!=null )
+									{
+										Rule rr = grammar.getRule(scopeName,t.getText());
+										retval.g = factory.build_RuleRef(rr, start);
+										t.NFAStartState = retval.g.left;
+										// don't add FOLLOW transitions in the lexer;
+										// only exact context should be used.
+									}
+								}
+								else
+								{
+									retval.g = factory.build_Atom(t);
+									t.followingNFAState = retval.g.right;
+								}
+							}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:609:4: ^(c= CHAR_LITERAL (as3= ast_suffix )? )
+					{
+					c=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_atom1266); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:609:23: (as3= ast_suffix )?
+						int alt54=2;
+						int LA54_0 = input.LA(1);
+						if ( (LA54_0==BANG||LA54_0==ROOT) ) {
+							alt54=1;
+						}
+						switch (alt54) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:609:24: as3= ast_suffix
+								{
+								pushFollow(FOLLOW_ast_suffix_in_atom1272);
+								ast_suffix();
+								state._fsp--;
+								if (state.failed) return retval;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					if ( state.backtracking==0 ) {
+								if ( grammar.type==Grammar.LEXER )
+								{
+									retval.g = factory.build_CharLiteralAtom(c);
+								}
+								else
+								{
+									retval.g = factory.build_Atom(c);
+									c.followingNFAState = retval.g.right;
+								}
+							}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:622:4: ^(s= STRING_LITERAL (as4= ast_suffix )? )
+					{
+					s=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_atom1290); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:622:25: (as4= ast_suffix )?
+						int alt55=2;
+						int LA55_0 = input.LA(1);
+						if ( (LA55_0==BANG||LA55_0==ROOT) ) {
+							alt55=1;
+						}
+						switch (alt55) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:622:26: as4= ast_suffix
+								{
+								pushFollow(FOLLOW_ast_suffix_in_atom1296);
+								ast_suffix();
+								state._fsp--;
+								if (state.failed) return retval;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					if ( state.backtracking==0 ) {
+								if ( grammar.type==Grammar.LEXER )
+								{
+									retval.g = factory.build_StringLiteralAtom(s);
+								}
+								else
+								{
+									retval.g = factory.build_Atom(s);
+									s.followingNFAState = retval.g.right;
+								}
+							}
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:635:4: ^(w= WILDCARD (as5= ast_suffix )? )
+					{
+					w=(GrammarAST)match(input,WILDCARD,FOLLOW_WILDCARD_in_atom1314); if (state.failed) return retval;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return retval;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:635:18: (as5= ast_suffix )?
+						int alt56=2;
+						int LA56_0 = input.LA(1);
+						if ( (LA56_0==BANG||LA56_0==ROOT) ) {
+							alt56=1;
+						}
+						switch (alt56) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:635:19: as5= ast_suffix
+								{
+								pushFollow(FOLLOW_ast_suffix_in_atom1319);
+								ast_suffix();
+								state._fsp--;
+								if (state.failed) return retval;
+								}
+								break;
+
+						}
+
+						match(input, Token.UP, null); if (state.failed) return retval;
+					}
+
+					if ( state.backtracking==0 ) {
+									if ( nfa.grammar.type == Grammar.TREE_PARSER
+										&& (w.getChildIndex() > 0 || w.getParent().getChild(1).getType() == EOA) )
+									{
+										retval.g = factory.build_WildcardTree( w );
+									}
+									else
+									{
+										retval.g = factory.build_Wildcard( w );
+									}
+								}
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:648:4: ^( DOT scope_= ID a= atom[$scope_.text] )
+					{
+					match(input,DOT,FOLLOW_DOT_in_atom1336); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					scope_=(GrammarAST)match(input,ID,FOLLOW_ID_in_atom1340); if (state.failed) return retval;
+					pushFollow(FOLLOW_atom_in_atom1344);
+					a=atom((scope_!=null?scope_.getText():null));
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking==0 ) {retval.g = (a!=null?((TreeToNFAConverter.atom_return)a).g:null);}
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "atom"
+
+
+
+	// $ANTLR start "ast_suffix"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:651:1: ast_suffix : ( ROOT | BANG );
+	public final void ast_suffix() throws RecognitionException {
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:652:2: ( ROOT | BANG )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:
+			{
+			if ( input.LA(1)==BANG||input.LA(1)==ROOT ) {
+				input.consume();
+				state.errorRecovery=false;
+				state.failed=false;
+			}
+			else {
+				if (state.backtracking>0) {state.failed=true; return;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "ast_suffix"
+
+
+	public static class set_return extends TreeRuleReturnScope {
+		public StateCluster g=null;
+	};
+
+
+	// $ANTLR start "set"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:656:1: set returns [StateCluster g=null] : ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB ) ;
+	public final TreeToNFAConverter.set_return set() throws RecognitionException {
+		TreeToNFAConverter.set_return retval = new TreeToNFAConverter.set_return();
+		retval.start = input.LT(1);
+
+		GrammarAST b=null;
+
+
+			IntSet elements=new IntervalSet();
+			if ( state.backtracking == 0 )
+				((GrammarAST)retval.start).setSetValue(elements); // track set for use by code gen
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:663:2: ( ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:663:4: ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB )
+			{
+			b=(GrammarAST)match(input,BLOCK,FOLLOW_BLOCK_in_set1390); if (state.failed) return retval;
+			match(input, Token.DOWN, null); if (state.failed) return retval;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:664:6: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+
+			int cnt60=0;
+			loop60:
+			while (true) {
+				int alt60=2;
+				int LA60_0 = input.LA(1);
+				if ( (LA60_0==ALT) ) {
+					alt60=1;
+				}
+
+				switch (alt60) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:664:7: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_set1399); if (state.failed) return retval;
+					match(input, Token.DOWN, null); if (state.failed) return retval;
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:664:13: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
+					int alt59=2;
+					int LA59_0 = input.LA(1);
+					if ( (LA59_0==BACKTRACK_SEMPRED) ) {
+						alt59=1;
+					}
+					switch (alt59) {
+						case 1 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:664:15: ^( BACKTRACK_SEMPRED ( . )* )
+							{
+							match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_set1404); if (state.failed) return retval;
+							if ( input.LA(1)==Token.DOWN ) {
+								match(input, Token.DOWN, null); if (state.failed) return retval;
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:664:35: ( . )*
+								loop58:
+								while (true) {
+									int alt58=2;
+									int LA58_0 = input.LA(1);
+									if ( ((LA58_0 >= ACTION && LA58_0 <= XDIGIT)) ) {
+										alt58=1;
+									}
+									else if ( (LA58_0==UP) ) {
+										alt58=2;
+									}
+
+									switch (alt58) {
+									case 1 :
+										// org/antlr/grammar/v3/TreeToNFAConverter.g:664:35: .
+										{
+										matchAny(input); if (state.failed) return retval;
+										}
+										break;
+
+									default :
+										break loop58;
+									}
+								}
+
+								match(input, Token.UP, null); if (state.failed) return retval;
+							}
+
+							}
+							break;
+
+					}
+
+					pushFollow(FOLLOW_setElement_in_set1413);
+					setElement(elements);
+					state._fsp--;
+					if (state.failed) return retval;
+					match(input,EOA,FOLLOW_EOA_in_set1416); if (state.failed) return retval;
+					match(input, Token.UP, null); if (state.failed) return retval;
+
+					}
+					break;
+
+				default :
+					if ( cnt60 >= 1 ) break loop60;
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee = new EarlyExitException(60, input);
+					throw eee;
+				}
+				cnt60++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_set1426); if (state.failed) return retval;
+			match(input, Token.UP, null); if (state.failed) return retval;
+
+			if ( state.backtracking==0 ) {
+					retval.g = factory.build_Set(elements,b);
+					b.followingNFAState = retval.g.right;
+					b.setSetValue(elements); // track set value of this block
+					}
+			}
+
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+		return retval;
+	}
+	// $ANTLR end "set"
+
+
+
+	// $ANTLR start "setRule"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:675:1: setRule returns [IntSet elements=new IntervalSet()] : ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR ) ;
+	public final IntSet setRule() throws RecognitionException {
+		IntSet elements = new IntervalSet();
+
+
+		GrammarAST id=null;
+
+
+			IntSet s=null;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:680:2: ( ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:680:4: ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR )
+			{
+			match(input,RULE,FOLLOW_RULE_in_setRule1460); if (state.failed) return elements;
+			match(input, Token.DOWN, null); if (state.failed) return elements;
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_setRule1464); if (state.failed) return elements;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:680:18: ( modifier )?
+			int alt61=2;
+			int LA61_0 = input.LA(1);
+			if ( (LA61_0==FRAGMENT||(LA61_0 >= PRIVATE && LA61_0 <= PUBLIC)) ) {
+				alt61=1;
+			}
+			switch (alt61) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:680:19: modifier
+					{
+					pushFollow(FOLLOW_modifier_in_setRule1467);
+					modifier();
+					state._fsp--;
+					if (state.failed) return elements;
+					}
+					break;
+
+			}
+
+			match(input,ARG,FOLLOW_ARG_in_setRule1471); if (state.failed) return elements;
+			match(input,RET,FOLLOW_RET_in_setRule1473); if (state.failed) return elements;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:680:38: ( ^( OPTIONS ( . )* ) )?
+			int alt63=2;
+			int LA63_0 = input.LA(1);
+			if ( (LA63_0==OPTIONS) ) {
+				alt63=1;
+			}
+			switch (alt63) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:680:40: ^( OPTIONS ( . )* )
+					{
+					match(input,OPTIONS,FOLLOW_OPTIONS_in_setRule1478); if (state.failed) return elements;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return elements;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:680:50: ( . )*
+						loop62:
+						while (true) {
+							int alt62=2;
+							int LA62_0 = input.LA(1);
+							if ( ((LA62_0 >= ACTION && LA62_0 <= XDIGIT)) ) {
+								alt62=1;
+							}
+							else if ( (LA62_0==UP) ) {
+								alt62=2;
+							}
+
+							switch (alt62) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:680:50: .
+								{
+								matchAny(input); if (state.failed) return elements;
+								}
+								break;
+
+							default :
+								break loop62;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return elements;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:680:57: ( ruleScopeSpec )?
+			int alt64=2;
+			int LA64_0 = input.LA(1);
+			if ( (LA64_0==SCOPE) ) {
+				alt64=1;
+			}
+			switch (alt64) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:680:59: ruleScopeSpec
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_setRule1489);
+					ruleScopeSpec();
+					state._fsp--;
+					if (state.failed) return elements;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:681:4: ( ^( AMPERSAND ( . )* ) )*
+			loop66:
+			while (true) {
+				int alt66=2;
+				int LA66_0 = input.LA(1);
+				if ( (LA66_0==AMPERSAND) ) {
+					alt66=1;
+				}
+
+				switch (alt66) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:681:6: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_setRule1500); if (state.failed) return elements;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return elements;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:681:18: ( . )*
+						loop65:
+						while (true) {
+							int alt65=2;
+							int LA65_0 = input.LA(1);
+							if ( ((LA65_0 >= ACTION && LA65_0 <= XDIGIT)) ) {
+								alt65=1;
+							}
+							else if ( (LA65_0==UP) ) {
+								alt65=2;
+							}
+
+							switch (alt65) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:681:18: .
+								{
+								matchAny(input); if (state.failed) return elements;
+								}
+								break;
+
+							default :
+								break loop65;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return elements;
+					}
+
+					}
+					break;
+
+				default :
+					break loop66;
+				}
+			}
+
+			match(input,BLOCK,FOLLOW_BLOCK_in_setRule1514); if (state.failed) return elements;
+			match(input, Token.DOWN, null); if (state.failed) return elements;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:682:13: ( ^( OPTIONS ( . )* ) )?
+			int alt68=2;
+			int LA68_0 = input.LA(1);
+			if ( (LA68_0==OPTIONS) ) {
+				alt68=1;
+			}
+			switch (alt68) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:682:15: ^( OPTIONS ( . )* )
+					{
+					match(input,OPTIONS,FOLLOW_OPTIONS_in_setRule1519); if (state.failed) return elements;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return elements;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:682:25: ( . )*
+						loop67:
+						while (true) {
+							int alt67=2;
+							int LA67_0 = input.LA(1);
+							if ( ((LA67_0 >= ACTION && LA67_0 <= XDIGIT)) ) {
+								alt67=1;
+							}
+							else if ( (LA67_0==UP) ) {
+								alt67=2;
+							}
+
+							switch (alt67) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:682:25: .
+								{
+								matchAny(input); if (state.failed) return elements;
+								}
+								break;
+
+							default :
+								break loop67;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return elements;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:683:7: ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+
+			int cnt70=0;
+			loop70:
+			while (true) {
+				int alt70=2;
+				int LA70_0 = input.LA(1);
+				if ( (LA70_0==ALT) ) {
+					alt70=1;
+				}
+
+				switch (alt70) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:683:9: ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_setRule1537); if (state.failed) return elements;
+					match(input, Token.DOWN, null); if (state.failed) return elements;
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:683:15: ( BACKTRACK_SEMPRED )?
+					int alt69=2;
+					int LA69_0 = input.LA(1);
+					if ( (LA69_0==BACKTRACK_SEMPRED) ) {
+						alt69=1;
+					}
+					switch (alt69) {
+						case 1 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:683:16: BACKTRACK_SEMPRED
+							{
+							match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_setRule1540); if (state.failed) return elements;
+							}
+							break;
+
+					}
+
+					pushFollow(FOLLOW_setElement_in_setRule1544);
+					setElement(elements);
+					state._fsp--;
+					if (state.failed) return elements;
+					match(input,EOA,FOLLOW_EOA_in_setRule1547); if (state.failed) return elements;
+					match(input, Token.UP, null); if (state.failed) return elements;
+
+					}
+					break;
+
+				default :
+					if ( cnt70 >= 1 ) break loop70;
+					if (state.backtracking>0) {state.failed=true; return elements;}
+					EarlyExitException eee = new EarlyExitException(70, input);
+					throw eee;
+				}
+				cnt70++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_setRule1559); if (state.failed) return elements;
+			match(input, Token.UP, null); if (state.failed) return elements;
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:686:4: ( exceptionGroup )?
+			int alt71=2;
+			int LA71_0 = input.LA(1);
+			if ( (LA71_0==CATCH||LA71_0==FINALLY) ) {
+				alt71=1;
+			}
+			switch (alt71) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:686:5: exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_setRule1571);
+					exceptionGroup();
+					state._fsp--;
+					if (state.failed) return elements;
+					}
+					break;
+
+			}
+
+			match(input,EOR,FOLLOW_EOR_in_setRule1578); if (state.failed) return elements;
+			match(input, Token.UP, null); if (state.failed) return elements;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			 throw re; 
+		}
+
+		finally {
+			// do for sure before leaving
+		}
+		return elements;
+	}
+	// $ANTLR end "setRule"
+
+
+
+	// $ANTLR start "setElement"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:692:1: setElement[IntSet elements] : (c= CHAR_LITERAL |t= TOKEN_REF |s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) |gset= set | ^( NOT setElement[ns] ) );
+	public final void setElement(IntSet elements) throws RecognitionException {
+		GrammarAST c=null;
+		GrammarAST t=null;
+		GrammarAST s=null;
+		GrammarAST c1=null;
+		GrammarAST c2=null;
+		TreeRuleReturnScope gset =null;
+
+
+			int ttype;
+			IntSet ns=null;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:698:2: (c= CHAR_LITERAL |t= TOKEN_REF |s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) |gset= set | ^( NOT setElement[ns] ) )
+			int alt72=6;
+			switch ( input.LA(1) ) {
+			case CHAR_LITERAL:
+				{
+				alt72=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt72=2;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt72=3;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt72=4;
+				}
+				break;
+			case BLOCK:
+				{
+				alt72=5;
+				}
+				break;
+			case NOT:
+				{
+				alt72=6;
+				}
+				break;
+			default:
+				if (state.backtracking>0) {state.failed=true; return;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 72, 0, input);
+				throw nvae;
+			}
+			switch (alt72) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:698:4: c= CHAR_LITERAL
+					{
+					c=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_setElement1607); if (state.failed) return;
+					if ( state.backtracking==0 ) {
+								if ( grammar.type==Grammar.LEXER )
+								{
+									ttype = Grammar.getCharValueFromGrammarCharLiteral((c!=null?c.getText():null));
+								}
+								else
+								{
+									ttype = grammar.getTokenType((c!=null?c.getText():null));
+								}
+								if ( elements.member(ttype) )
+								{
+									ErrorManager.grammarError(
+										ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+										grammar,
+										c.getToken(),
+										(c!=null?c.getText():null));
+								}
+								elements.add(ttype);
+							}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:718:4: t= TOKEN_REF
+					{
+					t=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_setElement1618); if (state.failed) return;
+					if ( state.backtracking==0 ) {
+								if ( grammar.type==Grammar.LEXER )
+								{
+									// recursively will invoke this rule to match elements in target rule ref
+									IntSet ruleSet = grammar.getSetFromRule(this,(t!=null?t.getText():null));
+									if ( ruleSet==null )
+									{
+										ErrorManager.grammarError(
+											ErrorManager.MSG_RULE_INVALID_SET,
+											grammar,
+											t.getToken(),
+											(t!=null?t.getText():null));
+									}
+									else
+									{
+										elements.addAll(ruleSet);
+									}
+								}
+								else
+								{
+									ttype = grammar.getTokenType((t!=null?t.getText():null));
+									if ( elements.member(ttype) )
+									{
+										ErrorManager.grammarError(
+											ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+											grammar,
+											t.getToken(),
+											(t!=null?t.getText():null));
+									}
+									elements.add(ttype);
+								}
+							}
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:752:4: s= STRING_LITERAL
+					{
+					s=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_setElement1630); if (state.failed) return;
+					if ( state.backtracking==0 ) {
+								ttype = grammar.getTokenType((s!=null?s.getText():null));
+								if ( elements.member(ttype) )
+								{
+									ErrorManager.grammarError(
+										ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+										grammar,
+										s.getToken(),
+										(s!=null?s.getText():null));
+								}
+								elements.add(ttype);
+							}
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:765:4: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
+					{
+					match(input,CHAR_RANGE,FOLLOW_CHAR_RANGE_in_setElement1640); if (state.failed) return;
+					match(input, Token.DOWN, null); if (state.failed) return;
+					c1=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_setElement1644); if (state.failed) return;
+					c2=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_setElement1648); if (state.failed) return;
+					match(input, Token.UP, null); if (state.failed) return;
+
+					if ( state.backtracking==0 ) {
+								if ( grammar.type==Grammar.LEXER )
+								{
+									int a = Grammar.getCharValueFromGrammarCharLiteral((c1!=null?c1.getText():null));
+									int b = Grammar.getCharValueFromGrammarCharLiteral((c2!=null?c2.getText():null));
+									elements.addAll(IntervalSet.of(a,b));
+								}
+							}
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:775:4: gset= set
+					{
+					pushFollow(FOLLOW_set_in_setElement1661);
+					gset=set();
+					state._fsp--;
+					if (state.failed) return;
+					if ( state.backtracking==0 ) {
+								Transition setTrans = (gset!=null?((TreeToNFAConverter.set_return)gset).g:null).left.transition(0);
+								elements.addAll(setTrans.label.getSet());
+							}
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:781:4: ^( NOT setElement[ns] )
+					{
+					match(input,NOT,FOLLOW_NOT_in_setElement1673); if (state.failed) return;
+					if ( state.backtracking==0 ) {ns=new IntervalSet();}
+					match(input, Token.DOWN, null); if (state.failed) return;
+					pushFollow(FOLLOW_setElement_in_setElement1680);
+					setElement(ns);
+					state._fsp--;
+					if (state.failed) return;
+					if ( state.backtracking==0 ) {
+									IntSet not = grammar.complement(ns);
+									elements.addAll(not);
+								}
+					match(input, Token.UP, null); if (state.failed) return;
+
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			reportError(re);
+			recover(input,re);
+		}
+		finally {
+			// do for sure before leaving
+		}
+	}
+	// $ANTLR end "setElement"
+
+
+
+	// $ANTLR start "testBlockAsSet"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:797:1: testBlockAsSet returns [int alts=0] options {backtrack=true; } : ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ;
+	public final int testBlockAsSet() throws RecognitionException {
+		int alts = 0;
+
+
+		int testSetElement10 =0;
+
+
+			inTest++;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:803:2: ( ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:803:4: ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB )
+			{
+			match(input,BLOCK,FOLLOW_BLOCK_in_testBlockAsSet1725); if (state.failed) return alts;
+			match(input, Token.DOWN, null); if (state.failed) return alts;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:804:4: ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+
+			int cnt74=0;
+			loop74:
+			while (true) {
+				int alt74=2;
+				int LA74_0 = input.LA(1);
+				if ( (LA74_0==ALT) ) {
+					alt74=1;
+				}
+
+				switch (alt74) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:804:6: ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_testBlockAsSet1733); if (state.failed) return alts;
+					match(input, Token.DOWN, null); if (state.failed) return alts;
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:804:12: ( BACKTRACK_SEMPRED )?
+					int alt73=2;
+					int LA73_0 = input.LA(1);
+					if ( (LA73_0==BACKTRACK_SEMPRED) ) {
+						alt73=1;
+					}
+					switch (alt73) {
+						case 1 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:804:13: BACKTRACK_SEMPRED
+							{
+							match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_testBlockAsSet1736); if (state.failed) return alts;
+							}
+							break;
+
+					}
+
+					pushFollow(FOLLOW_testSetElement_in_testBlockAsSet1740);
+					testSetElement10=testSetElement();
+					state._fsp--;
+					if (state.failed) return alts;
+					alts += testSetElement10;
+					match(input,EOA,FOLLOW_EOA_in_testBlockAsSet1744); if (state.failed) return alts;
+					match(input, Token.UP, null); if (state.failed) return alts;
+
+					}
+					break;
+
+				default :
+					if ( cnt74 >= 1 ) break loop74;
+					if (state.backtracking>0) {state.failed=true; return alts;}
+					EarlyExitException eee = new EarlyExitException(74, input);
+					throw eee;
+				}
+				cnt74++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_testBlockAsSet1756); if (state.failed) return alts;
+			match(input, Token.UP, null); if (state.failed) return alts;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			 throw re; 
+		}
+
+		finally {
+			// do for sure before leaving
+			 inTest--; 
+		}
+		return alts;
+	}
+	// $ANTLR end "testBlockAsSet"
+
+
+
+	// $ANTLR start "testSetRule"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:812:1: testSetRule returns [int alts=0] : ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR ) ;
+	public final int testSetRule() throws RecognitionException {
+		int alts = 0;
+
+
+		GrammarAST id=null;
+		int testSetElement11 =0;
+
+
+			inTest++;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:817:2: ( ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR ) )
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:817:4: ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR )
+			{
+			match(input,RULE,FOLLOW_RULE_in_testSetRule1791); if (state.failed) return alts;
+			match(input, Token.DOWN, null); if (state.failed) return alts;
+			id=(GrammarAST)match(input,ID,FOLLOW_ID_in_testSetRule1795); if (state.failed) return alts;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:817:18: ( modifier )?
+			int alt75=2;
+			int LA75_0 = input.LA(1);
+			if ( (LA75_0==FRAGMENT||(LA75_0 >= PRIVATE && LA75_0 <= PUBLIC)) ) {
+				alt75=1;
+			}
+			switch (alt75) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:817:19: modifier
+					{
+					pushFollow(FOLLOW_modifier_in_testSetRule1798);
+					modifier();
+					state._fsp--;
+					if (state.failed) return alts;
+					}
+					break;
+
+			}
+
+			match(input,ARG,FOLLOW_ARG_in_testSetRule1802); if (state.failed) return alts;
+			match(input,RET,FOLLOW_RET_in_testSetRule1804); if (state.failed) return alts;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:817:38: ( ^( OPTIONS ( . )* ) )?
+			int alt77=2;
+			int LA77_0 = input.LA(1);
+			if ( (LA77_0==OPTIONS) ) {
+				alt77=1;
+			}
+			switch (alt77) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:817:40: ^( OPTIONS ( . )* )
+					{
+					match(input,OPTIONS,FOLLOW_OPTIONS_in_testSetRule1809); if (state.failed) return alts;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return alts;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:817:50: ( . )*
+						loop76:
+						while (true) {
+							int alt76=2;
+							int LA76_0 = input.LA(1);
+							if ( ((LA76_0 >= ACTION && LA76_0 <= XDIGIT)) ) {
+								alt76=1;
+							}
+							else if ( (LA76_0==UP) ) {
+								alt76=2;
+							}
+
+							switch (alt76) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:817:50: .
+								{
+								matchAny(input); if (state.failed) return alts;
+								}
+								break;
+
+							default :
+								break loop76;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return alts;
+					}
+
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:817:57: ( ruleScopeSpec )?
+			int alt78=2;
+			int LA78_0 = input.LA(1);
+			if ( (LA78_0==SCOPE) ) {
+				alt78=1;
+			}
+			switch (alt78) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:817:59: ruleScopeSpec
+					{
+					pushFollow(FOLLOW_ruleScopeSpec_in_testSetRule1820);
+					ruleScopeSpec();
+					state._fsp--;
+					if (state.failed) return alts;
+					}
+					break;
+
+			}
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:818:4: ( ^( AMPERSAND ( . )* ) )*
+			loop80:
+			while (true) {
+				int alt80=2;
+				int LA80_0 = input.LA(1);
+				if ( (LA80_0==AMPERSAND) ) {
+					alt80=1;
+				}
+
+				switch (alt80) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:818:6: ^( AMPERSAND ( . )* )
+					{
+					match(input,AMPERSAND,FOLLOW_AMPERSAND_in_testSetRule1831); if (state.failed) return alts;
+					if ( input.LA(1)==Token.DOWN ) {
+						match(input, Token.DOWN, null); if (state.failed) return alts;
+						// org/antlr/grammar/v3/TreeToNFAConverter.g:818:18: ( . )*
+						loop79:
+						while (true) {
+							int alt79=2;
+							int LA79_0 = input.LA(1);
+							if ( ((LA79_0 >= ACTION && LA79_0 <= XDIGIT)) ) {
+								alt79=1;
+							}
+							else if ( (LA79_0==UP) ) {
+								alt79=2;
+							}
+
+							switch (alt79) {
+							case 1 :
+								// org/antlr/grammar/v3/TreeToNFAConverter.g:818:18: .
+								{
+								matchAny(input); if (state.failed) return alts;
+								}
+								break;
+
+							default :
+								break loop79;
+							}
+						}
+
+						match(input, Token.UP, null); if (state.failed) return alts;
+					}
+
+					}
+					break;
+
+				default :
+					break loop80;
+				}
+			}
+
+			match(input,BLOCK,FOLLOW_BLOCK_in_testSetRule1845); if (state.failed) return alts;
+			match(input, Token.DOWN, null); if (state.failed) return alts;
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:820:5: ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+
+			int cnt82=0;
+			loop82:
+			while (true) {
+				int alt82=2;
+				int LA82_0 = input.LA(1);
+				if ( (LA82_0==ALT) ) {
+					alt82=1;
+				}
+
+				switch (alt82) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:820:7: ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA )
+					{
+					match(input,ALT,FOLLOW_ALT_in_testSetRule1854); if (state.failed) return alts;
+					match(input, Token.DOWN, null); if (state.failed) return alts;
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:820:13: ( BACKTRACK_SEMPRED )?
+					int alt81=2;
+					int LA81_0 = input.LA(1);
+					if ( (LA81_0==BACKTRACK_SEMPRED) ) {
+						alt81=1;
+					}
+					switch (alt81) {
+						case 1 :
+							// org/antlr/grammar/v3/TreeToNFAConverter.g:820:14: BACKTRACK_SEMPRED
+							{
+							match(input,BACKTRACK_SEMPRED,FOLLOW_BACKTRACK_SEMPRED_in_testSetRule1857); if (state.failed) return alts;
+							}
+							break;
+
+					}
+
+					pushFollow(FOLLOW_testSetElement_in_testSetRule1861);
+					testSetElement11=testSetElement();
+					state._fsp--;
+					if (state.failed) return alts;
+					alts += testSetElement11;
+					match(input,EOA,FOLLOW_EOA_in_testSetRule1865); if (state.failed) return alts;
+					match(input, Token.UP, null); if (state.failed) return alts;
+
+					}
+					break;
+
+				default :
+					if ( cnt82 >= 1 ) break loop82;
+					if (state.backtracking>0) {state.failed=true; return alts;}
+					EarlyExitException eee = new EarlyExitException(82, input);
+					throw eee;
+				}
+				cnt82++;
+			}
+
+			match(input,EOB,FOLLOW_EOB_in_testSetRule1879); if (state.failed) return alts;
+			match(input, Token.UP, null); if (state.failed) return alts;
+
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:824:4: ( exceptionGroup )?
+			int alt83=2;
+			int LA83_0 = input.LA(1);
+			if ( (LA83_0==CATCH||LA83_0==FINALLY) ) {
+				alt83=1;
+			}
+			switch (alt83) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:824:5: exceptionGroup
+					{
+					pushFollow(FOLLOW_exceptionGroup_in_testSetRule1890);
+					exceptionGroup();
+					state._fsp--;
+					if (state.failed) return alts;
+					}
+					break;
+
+			}
+
+			match(input,EOR,FOLLOW_EOR_in_testSetRule1897); if (state.failed) return alts;
+			match(input, Token.UP, null); if (state.failed) return alts;
+
+			}
+
+		}
+		catch (RecognitionException re) {
+			 throw re; 
+		}
+
+		finally {
+			// do for sure before leaving
+			 inTest--; 
+		}
+		return alts;
+	}
+	// $ANTLR end "testSetRule"
+
+
+
+	// $ANTLR start "testSetElement"
+	// org/antlr/grammar/v3/TreeToNFAConverter.g:832:1: testSetElement returns [int alts=1] : (c= CHAR_LITERAL {...}?|t= TOKEN_REF {...}?|{...}? =>s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | testBlockAsSet | ^( NOT tse= testSetElement ) );
+	public final int testSetElement() throws RecognitionException {
+		int alts = 1;
+
+
+		GrammarAST c=null;
+		GrammarAST t=null;
+		GrammarAST s=null;
+		GrammarAST c1=null;
+		GrammarAST c2=null;
+		int tse =0;
+		int testBlockAsSet12 =0;
+
+		try {
+			// org/antlr/grammar/v3/TreeToNFAConverter.g:833:2: (c= CHAR_LITERAL {...}?|t= TOKEN_REF {...}?|{...}? =>s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | testBlockAsSet | ^( NOT tse= testSetElement ) )
+			int alt84=6;
+			int LA84_0 = input.LA(1);
+			if ( (LA84_0==CHAR_LITERAL) ) {
+				alt84=1;
+			}
+			else if ( (LA84_0==TOKEN_REF) ) {
+				alt84=2;
+			}
+			else if ( (LA84_0==STRING_LITERAL) && ((grammar.type!=Grammar.LEXER))) {
+				alt84=3;
+			}
+			else if ( (LA84_0==CHAR_RANGE) ) {
+				alt84=4;
+			}
+			else if ( (LA84_0==BLOCK) ) {
+				alt84=5;
+			}
+			else if ( (LA84_0==NOT) ) {
+				alt84=6;
+			}
+
+			else {
+				if (state.backtracking>0) {state.failed=true; return alts;}
+				NoViableAltException nvae =
+					new NoViableAltException("", 84, 0, input);
+				throw nvae;
+			}
+
+			switch (alt84) {
+				case 1 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:833:4: c= CHAR_LITERAL {...}?
+					{
+					c=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_testSetElement1929); if (state.failed) return alts;
+					if ( !((!hasElementOptions(c))) ) {
+						if (state.backtracking>0) {state.failed=true; return alts;}
+						throw new FailedPredicateException(input, "testSetElement", "!hasElementOptions($c)");
+					}
+					}
+					break;
+				case 2 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:834:4: t= TOKEN_REF {...}?
+					{
+					t=(GrammarAST)match(input,TOKEN_REF,FOLLOW_TOKEN_REF_in_testSetElement1938); if (state.failed) return alts;
+					if ( !((!hasElementOptions(t))) ) {
+						if (state.backtracking>0) {state.failed=true; return alts;}
+						throw new FailedPredicateException(input, "testSetElement", "!hasElementOptions($t)");
+					}
+
+								if ( grammar.type==Grammar.LEXER )
+								{
+									Rule rule = grammar.getRule((t!=null?t.getText():null));
+									if ( rule==null )
+									{
+										//throw new RecognitionException("invalid rule");
+										throw new RecognitionException();
+									}
+									// recursively will invoke this rule to match elements in target rule ref
+									alts += testSetRule(rule.tree);
+								}
+							
+					}
+					break;
+				case 3 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:848:6: {...}? =>s= STRING_LITERAL
+					{
+					if ( !((grammar.type!=Grammar.LEXER)) ) {
+						if (state.backtracking>0) {state.failed=true; return alts;}
+						throw new FailedPredicateException(input, "testSetElement", "grammar.type!=Grammar.LEXER");
+					}
+					s=(GrammarAST)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_testSetElement1957); if (state.failed) return alts;
+					}
+					break;
+				case 4 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:849:4: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
+					{
+					match(input,CHAR_RANGE,FOLLOW_CHAR_RANGE_in_testSetElement1963); if (state.failed) return alts;
+					match(input, Token.DOWN, null); if (state.failed) return alts;
+					c1=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_testSetElement1967); if (state.failed) return alts;
+					c2=(GrammarAST)match(input,CHAR_LITERAL,FOLLOW_CHAR_LITERAL_in_testSetElement1971); if (state.failed) return alts;
+					match(input, Token.UP, null); if (state.failed) return alts;
+
+					 alts = IntervalSet.of( Grammar.getCharValueFromGrammarCharLiteral((c1!=null?c1.getText():null)), Grammar.getCharValueFromGrammarCharLiteral((c2!=null?c2.getText():null)) ).size(); 
+					}
+					break;
+				case 5 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:851:6: testBlockAsSet
+					{
+					pushFollow(FOLLOW_testBlockAsSet_in_testSetElement1983);
+					testBlockAsSet12=testBlockAsSet();
+					state._fsp--;
+					if (state.failed) return alts;
+					 alts = testBlockAsSet12; 
+					}
+					break;
+				case 6 :
+					// org/antlr/grammar/v3/TreeToNFAConverter.g:853:6: ^( NOT tse= testSetElement )
+					{
+					match(input,NOT,FOLLOW_NOT_in_testSetElement1996); if (state.failed) return alts;
+					match(input, Token.DOWN, null); if (state.failed) return alts;
+					pushFollow(FOLLOW_testSetElement_in_testSetElement2000);
+					tse=testSetElement();
+					state._fsp--;
+					if (state.failed) return alts;
+					match(input, Token.UP, null); if (state.failed) return alts;
+
+					 alts = grammar.getTokenTypes().size() - tse; 
+					}
+					break;
+
+			}
+		}
+		catch (RecognitionException re) {
+			 throw re; 
+		}
+
+		finally {
+			// do for sure before leaving
+		}
+		return alts;
+	}
+	// $ANTLR end "testSetElement"
+
+	// Delegated rules
+
+
+
+	public static final BitSet FOLLOW_LEXER_GRAMMAR_in_grammar_68 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_70 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PARSER_GRAMMAR_in_grammar_80 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_82 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_GRAMMAR_in_grammar_92 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_94 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_COMBINED_GRAMMAR_in_grammar_104 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_grammarSpec_in_grammar_106 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_attrScope125 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_attrScope127 = new BitSet(new long[]{0x0000000000000210L});
+	public static final BitSet FOLLOW_AMPERSAND_in_attrScope132 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_attrScope141 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ID_in_grammarSpec154 = new BitSet(new long[]{0x0400200008000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_DOC_COMMENT_in_grammarSpec161 = new BitSet(new long[]{0x0400200000000200L,0x0000000020028002L});
+	public static final BitSet FOLLOW_OPTIONS_in_grammarSpec170 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_IMPORT_in_grammarSpec184 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_TOKENS_in_grammarSpec198 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_attrScope_in_grammarSpec210 = new BitSet(new long[]{0x0000000000000200L,0x0000000000028002L});
+	public static final BitSet FOLLOW_AMPERSAND_in_grammarSpec219 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_rules_in_grammarSpec231 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_rule_in_rules243 = new BitSet(new long[]{0x0000000000000002L,0x0000000000008002L});
+	public static final BitSet FOLLOW_PREC_RULE_in_rules248 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_RULE_in_rule267 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_rule271 = new BitSet(new long[]{0x0000010000000400L,0x000000000000001CL});
+	public static final BitSet FOLLOW_modifier_in_rule282 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_ARG_in_rule290 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule293 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RET_in_rule302 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_rule305 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_throwsSpec_in_rule314 = new BitSet(new long[]{0x0400000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_OPTIONS_in_rule324 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_rule338 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_AMPERSAND_in_rule349 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_rule363 = new BitSet(new long[]{0x0000004400020000L});
+	public static final BitSet FOLLOW_exceptionGroup_in_rule369 = new BitSet(new long[]{0x0000000400000000L});
+	public static final BitSet FOLLOW_EOR_in_rule376 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_THROWS_in_throwsSpec423 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_throwsSpec425 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_SCOPE_in_ruleScopeSpec440 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_AMPERSAND_in_ruleScopeSpec445 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_ruleScopeSpec455 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_ID_in_ruleScopeSpec461 = new BitSet(new long[]{0x0000080000000008L});
+	public static final BitSet FOLLOW_set_in_block492 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BLOCK_in_block502 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_OPTIONS_in_block507 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_alternative_in_block523 = new BitSet(new long[]{0x0000000200000100L,0x0000000000001000L});
+	public static final BitSet FOLLOW_rewrite_in_block525 = new BitSet(new long[]{0x0000000200000100L});
+	public static final BitSet FOLLOW_EOB_in_block548 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ALT_in_alternative577 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_alternative582 = new BitSet(new long[]{0x82800289202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_EOA_in_alternative589 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_exceptionHandler_in_exceptionGroup608 = new BitSet(new long[]{0x0000004000020002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup614 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_finallyClause_in_exceptionGroup621 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CATCH_in_exceptionHandler636 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_exceptionHandler638 = new BitSet(new long[]{0x0000000000000010L});
+	public static final BitSet FOLLOW_ACTION_in_exceptionHandler640 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_FINALLY_in_finallyClause656 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ACTION_in_finallyClause658 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_REWRITES_in_rewrite672 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_REWRITE_in_rewrite690 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ROOT_in_element725 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element729 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BANG_in_element740 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_element744 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ASSIGN_in_element753 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element755 = new BitSet(new long[]{0x82800288202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_element759 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_PLUS_ASSIGN_in_element768 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_element770 = new BitSet(new long[]{0x82800288202DE010L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_element774 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RANGE_in_element785 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_atom_in_element789 = new BitSet(new long[]{0x0000000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_element794 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_RANGE_in_element808 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_element812 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_element816 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_atom_or_notatom_in_element828 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_ebnf_in_element837 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_tree__in_element846 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYNPRED_in_element857 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_element859 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_ACTION_in_element868 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_FORCED_ACTION_in_element877 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SEMPRED_in_element888 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_SYN_SEMPRED_in_element899 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_element911 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_GATED_SEMPRED_in_element926 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_EPSILON_in_element935 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_set_in_ebnf961 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_block_in_ebnf971 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_OPTIONAL_in_ebnf982 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf986 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CLOSURE_in_ebnf999 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1003 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_POSITIVE_CLOSURE_in_ebnf1016 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_block_in_ebnf1020 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TREE_BEGIN_in_tree_1048 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_element_in_tree_1055 = new BitSet(new long[]{0x82800288202DE018L,0x0000000547092041L});
+	public static final BitSet FOLLOW_element_in_tree_1071 = new BitSet(new long[]{0x82800288202DE018L,0x0000000547092041L});
+	public static final BitSet FOLLOW_atom_in_atom_or_notatom1100 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_NOT_in_atom_or_notatom1112 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom_or_notatom1121 = new BitSet(new long[]{0x0000000000008008L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom_or_notatom1126 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom_or_notatom1143 = new BitSet(new long[]{0x0000000000008008L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom_or_notatom1148 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_set_in_atom_or_notatom1163 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RULE_REF_in_atom1205 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1210 = new BitSet(new long[]{0x0000000000008008L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom1217 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_atom1235 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ARG_ACTION_in_atom1241 = new BitSet(new long[]{0x0000000000008008L,0x0000000000002000L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom1248 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_atom1266 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom1272 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_atom1290 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom1296 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_WILDCARD_in_atom1314 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ast_suffix_in_atom1319 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_DOT_in_atom1336 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_atom1340 = new BitSet(new long[]{0x0000000020040000L,0x0000000441010000L});
+	public static final BitSet FOLLOW_atom_in_atom1344 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_set1390 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ALT_in_set1399 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_set1404 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_setElement_in_set1413 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_set1416 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_EOB_in_set1426 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RULE_in_setRule1460 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_setRule1464 = new BitSet(new long[]{0x0000010000000400L,0x000000000000001CL});
+	public static final BitSet FOLLOW_modifier_in_setRule1467 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_ARG_in_setRule1471 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000200L});
+	public static final BitSet FOLLOW_RET_in_setRule1473 = new BitSet(new long[]{0x0400000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_OPTIONS_in_setRule1478 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_setRule1489 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_AMPERSAND_in_setRule1500 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BLOCK_in_setRule1514 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_OPTIONS_in_setRule1519 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ALT_in_setRule1537 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_setRule1540 = new BitSet(new long[]{0x00800000000D0000L,0x0000000041000000L});
+	public static final BitSet FOLLOW_setElement_in_setRule1544 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_setRule1547 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_EOB_in_setRule1559 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_exceptionGroup_in_setRule1571 = new BitSet(new long[]{0x0000000400000000L});
+	public static final BitSet FOLLOW_EOR_in_setRule1578 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_setElement1607 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_setElement1618 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_setElement1630 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_RANGE_in_setElement1640 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_setElement1644 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_setElement1648 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_set_in_setElement1661 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_NOT_in_setElement1673 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_setElement_in_setElement1680 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_BLOCK_in_testBlockAsSet1725 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ALT_in_testBlockAsSet1733 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_testBlockAsSet1736 = new BitSet(new long[]{0x00800000000D0000L,0x0000000041000000L});
+	public static final BitSet FOLLOW_testSetElement_in_testBlockAsSet1740 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_testBlockAsSet1744 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_EOB_in_testBlockAsSet1756 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_RULE_in_testSetRule1791 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ID_in_testSetRule1795 = new BitSet(new long[]{0x0000010000000400L,0x000000000000001CL});
+	public static final BitSet FOLLOW_modifier_in_testSetRule1798 = new BitSet(new long[]{0x0000000000000400L});
+	public static final BitSet FOLLOW_ARG_in_testSetRule1802 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000200L});
+	public static final BitSet FOLLOW_RET_in_testSetRule1804 = new BitSet(new long[]{0x0400000000010200L,0x0000000000020000L});
+	public static final BitSet FOLLOW_OPTIONS_in_testSetRule1809 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ruleScopeSpec_in_testSetRule1820 = new BitSet(new long[]{0x0000000000010200L});
+	public static final BitSet FOLLOW_AMPERSAND_in_testSetRule1831 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BLOCK_in_testSetRule1845 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_ALT_in_testSetRule1854 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_BACKTRACK_SEMPRED_in_testSetRule1857 = new BitSet(new long[]{0x00800000000D0000L,0x0000000041000000L});
+	public static final BitSet FOLLOW_testSetElement_in_testSetRule1861 = new BitSet(new long[]{0x0000000100000000L});
+	public static final BitSet FOLLOW_EOA_in_testSetRule1865 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_EOB_in_testSetRule1879 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_exceptionGroup_in_testSetRule1890 = new BitSet(new long[]{0x0000000400000000L});
+	public static final BitSet FOLLOW_EOR_in_testSetRule1897 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_testSetElement1929 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_TOKEN_REF_in_testSetElement1938 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_STRING_LITERAL_in_testSetElement1957 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_CHAR_RANGE_in_testSetElement1963 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_testSetElement1967 = new BitSet(new long[]{0x0000000000040000L});
+	public static final BitSet FOLLOW_CHAR_LITERAL_in_testSetElement1971 = new BitSet(new long[]{0x0000000000000008L});
+	public static final BitSet FOLLOW_testBlockAsSet_in_testSetElement1983 = new BitSet(new long[]{0x0000000000000002L});
+	public static final BitSet FOLLOW_NOT_in_testSetElement1996 = new BitSet(new long[]{0x0000000000000004L});
+	public static final BitSet FOLLOW_testSetElement_in_testSetElement2000 = new BitSet(new long[]{0x0000000000000008L});
+}
--- tool/src/main/java/TreeToNFAConverter.tokens	1970-01-01 01:00:00.000000000 +0100
+++ tool/src/main/java/TreeToNFAConverter.tokens	2019-04-04 17:22:25.480181488 +0200
@@ -0,0 +1,114 @@
+ACTION=4
+ACTION_CHAR_LITERAL=5
+ACTION_ESC=6
+ACTION_STRING_LITERAL=7
+ALT=8
+AMPERSAND=9
+ARG=10
+ARGLIST=11
+ARG_ACTION=12
+ASSIGN=13
+BACKTRACK_SEMPRED=14
+BANG=15
+BLOCK=16
+CATCH=17
+CHAR_LITERAL=18
+CHAR_RANGE=19
+CLOSE_ELEMENT_OPTION=20
+CLOSURE=21
+COLON=22
+COMBINED_GRAMMAR=23
+COMMA=24
+COMMENT=25
+DIGIT=26
+DOC_COMMENT=27
+DOLLAR=28
+DOT=29
+DOUBLE_ANGLE_STRING_LITERAL=30
+DOUBLE_QUOTE_STRING_LITERAL=31
+EOA=32
+EOB=33
+EOR=34
+EPSILON=35
+ESC=36
+ETC=37
+FINALLY=38
+FORCED_ACTION=39
+FRAGMENT=40
+GATED_SEMPRED=41
+GRAMMAR=42
+ID=43
+IMPLIES=44
+IMPORT=45
+INITACTION=46
+INT=47
+LABEL=48
+LEXER=49
+LEXER_GRAMMAR=50
+LPAREN=51
+ML_COMMENT=52
+NESTED_ACTION=53
+NESTED_ARG_ACTION=54
+NOT=55
+OPEN_ELEMENT_OPTION=56
+OPTIONAL=57
+OPTIONS=58
+OR=59
+PARSER=60
+PARSER_GRAMMAR=61
+PLUS=62
+PLUS_ASSIGN=63
+POSITIVE_CLOSURE=64
+PREC_RULE=65
+PRIVATE=66
+PROTECTED=67
+PUBLIC=68
+QUESTION=69
+RANGE=70
+RCURLY=71
+RECURSIVE_RULE_REF=72
+RET=73
+RETURNS=74
+REWRITE=75
+REWRITES=76
+ROOT=77
+RPAREN=78
+RULE=79
+RULE_REF=80
+SCOPE=81
+SEMI=82
+SEMPRED=83
+SL_COMMENT=84
+SRC=85
+STAR=86
+STRAY_BRACKET=87
+STRING_LITERAL=88
+SYNPRED=89
+SYN_SEMPRED=90
+TEMPLATE=91
+THROWS=92
+TOKENS=93
+TOKEN_REF=94
+TREE=95
+TREE_BEGIN=96
+TREE_GRAMMAR=97
+WILDCARD=98
+WS=99
+WS_LOOP=100
+WS_OPT=101
+XDIGIT=102
+'.'=98
+'catch'=17
+'finally'=38
+'fragment'=40
+'grammar'=42
+'import'=45
+'lexer'=49
+'parser'=60
+'private'=66
+'protected'=67
+'public'=68
+'returns'=74
+'scope'=81
+'throws'=92
+'tree'=95
