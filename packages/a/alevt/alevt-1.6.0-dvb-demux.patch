Index: alevt-1.6.2/alevt-date.c
===================================================================
--- alevt-1.6.2.orig/alevt-date.c
+++ alevt-1.6.2/alevt-date.c
@@ -136,6 +136,8 @@ option(int argc, char **argv, int *ind,
 	{ "--help", "-h", 0 },
 	{ "-newbttv", "-new", 0 },
 	{ "-oldbttv", "-old", 0 },
+	{ "-progname", "-pn", 1 },
+	{ "-pid", "--pid", 1 },
     };
     int i;
 
@@ -172,6 +174,8 @@ main(int argc, char **argv)
     struct vbi *vbi;
     int opt, ind;
     char *arg;
+    char *progname = NULL;
+    int txtpid = -1;
 
     setprgname(argv[0]);
 
@@ -216,6 +220,12 @@ main(int argc, char **argv)
 	    case 9:	// oldbttv
 		big_buf = 0;
 		break;
+  	    case 10:    // progname
+		progname = arg;
+		break;
+  	    case 11:    // pid
+		txtpid = strtoul(arg, NULL, 0);
+		break;
 	    case -1:
 		usage(stderr, 1);
 		break;
@@ -229,7 +239,7 @@ main(int argc, char **argv)
 	alarm(timeout);
     }
 
-    vbi = vbi_open(vbi_name, 0, 1, big_buf);	// open device
+    vbi = vbi_open(vbi_name, 0, 1, big_buf, progname, txtpid);	// open device
     if (not vbi)
 	fatal_ioerror(vbi_name);
 
Index: alevt-1.6.2/main.c
===================================================================
--- alevt-1.6.2.orig/main.c
+++ alevt-1.6.2/main.c
@@ -22,7 +22,8 @@ static struct vbi *vbi;
 static int fine_tune = 1; // auto = 999;
 static int erc = 1;
 static int newbttv = -1;
-
+static char *progname;
+static int txtpid = -1;
 
 static void
 usage(FILE *fp, int exitval)
@@ -43,6 +44,8 @@ usage(FILE *fp, int exitval)
 	    "    -[no]erc\t\t\tenabled\n"
 	    "    -[no]bell\t\t\tenabled\n"
 	    "    -charset latin-1/2\t\tlatin-1\n"
+	    "    -progname name\n"
+	    "    -pid pid\n"
 	    "\n"
 	    "  Order is important!  Each page number\n"
 	    "  opens a new window with the previously\n"
@@ -56,6 +59,13 @@ usage(FILE *fp, int exitval)
 	    "  The -child option requires a parent\n"
 	    "  window.  So, it must be preceeded by\n"
 	    "  a parent or another child window.\n"
+	    "\n"
+	    "  To use the DVB interface, use\n"
+	    "  -vbi /dev/dvb/adapter0/demux0\n"
+	    "\n"
+	    "  The -progname or -pid option specify\n"
+	    "  the program or teletext PID if using\n"
+	    "  the DVB interface.\n"
 	);
     exit(exitval);
 }
@@ -86,7 +96,7 @@ static struct vtwin *
 start(int argc, char **argv, struct vtwin *parent, int pgno, int subno)
 {
     if (vbi == 0)
-	vbi = vbi_open(vbi_name, cache_open(), fine_tune, newbttv);
+	vbi = vbi_open(vbi_name, cache_open(), fine_tune, newbttv, progname, txtpid);
     if (vbi == 0)
 	fatal("cannot open %s", vbi_name);
     if (vbi->cache)
@@ -126,6 +136,8 @@ option(int argc, char **argv, int *ind,
 	{ "-bell", "-b", 0 },
 	{ "-nobell", "-nb", 0 },
 	{ "-charset", "-latin", 1 },
+	{ "-progname", "-pn", 1 },
+	{ "-pid", "--pid", 1 },
     };
     int i;
 
@@ -238,6 +250,12 @@ main(int argc, char **argv)
 	    case 12:	// debug
 		debug++;
 		break;
+  	    case 19:    // progname
+		progname = arg;
+		break;
+  	    case 20:    // pid
+		txtpid = strtoul(arg, NULL, 0);
+		break;
 	    case 6:	// parent
 	    case -1:	// non-option arg
 		pgno = arg_pgno(arg, &subno);
Index: alevt-1.6.2/vbi.c
===================================================================
--- alevt-1.6.2.orig/vbi.c
+++ alevt-1.6.2/vbi.c
@@ -1,9 +1,12 @@
+#define _GNU_SOURCE
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
+#include <errno.h>
 #include <sys/ioctl.h>
+#include <sys/poll.h>
 #include "os.h"
 #include "vt.h"
 #include "misc.h"
@@ -12,6 +15,10 @@
 #include "hamm.h"
 #include "lang.h"
 
+
+static int vbi_dvb_open(struct vbi *vbi, const char *vbi_name, const char *progname, int txtpid);
+static void dvb_handler(struct vbi *vbi, int fd);
+
 #define FAC	(1<<16)		// factor for fix-point arithmetic
 
 static u8 *rawbuf;		// one common buffer for raw vbi data.
@@ -580,7 +587,7 @@ setup_dev(struct vbi *vbi)
 
 
 struct vbi *
-vbi_open(char *vbi_name, struct cache *ca, int fine_tune, int big_buf)
+vbi_open(char *vbi_name, struct cache *ca, int fine_tune, int big_buf, const char *progname, int txtpid)
 {
     static int inited = 0;
     struct vbi *vbi;
@@ -595,17 +602,29 @@ vbi_open(char *vbi_name, struct cache *c
 	goto fail1;
     }
 
-    if ((vbi->fd = open(vbi_name, O_RDONLY)) == -1)
-    {
-	ioerror(vbi_name);
-	goto fail2;
-    }
+    if (!vbi_dvb_open(vbi, vbi_name, progname, txtpid)) {
+	    vbi->cache = ca;
 
+	    dl_init(vbi->clients);
+	    vbi->seq = 0;
+	    out_of_sync(vbi);
+	    vbi->ppage = vbi->rpage;
+
+	    //vbi_pll_reset(vbi, fine_tune);
+	    fdset_add_fd(fds, vbi->fd, dvb_handler, vbi);
+	    return vbi;
+    }
+    if ((vbi->fd = open(vbi_name, O_RDONLY)) == -1)
+	    {
+		    ioerror(vbi_name);
+		    goto fail2;
+	    }
+	    
     if (big_buf != -1)
-	error("-oldbttv/-newbttv is obsolete.  option ignored.");
-
+	    error("-oldbttv/-newbttv is obsolete.  option ignored.");
+	    
     if (setup_dev(vbi) == -1)
-	goto fail3;
+	    goto fail3;
 
     vbi->cache = ca;
 
@@ -663,3 +682,394 @@ vbi_reset(struct vbi *vbi)
 	vbi->cache->op->reset(vbi->cache);
     vbi_send(vbi, EV_RESET, 0, 0, 0, 0);
 }
+
+
+
+/*
+ * Starting from here: DVB
+ */
+
+/* DVB API */
+#include "dvb/dmx.h"
+#include "dvb/frontend.h"
+/*#include "dvb/sec.h"*/
+#include "dvb/video.h"
+
+static int dvb_get_table(int fd, u_int16_t pid, u_int8_t tblid, u_int8_t *buf, size_t bufsz)
+{
+        struct dmx_sct_filter_params sctFilterParams;
+	struct pollfd pfd;
+	int r;
+
+	memset(&sctFilterParams, 0, sizeof(sctFilterParams));
+        sctFilterParams.pid = pid;
+        sctFilterParams.timeout = 10000;
+        sctFilterParams.flags = DMX_ONESHOT | DMX_IMMEDIATE_START | DMX_CHECK_CRC;
+        sctFilterParams.filter.filter[0] = tblid;
+        sctFilterParams.filter.mask[0] = 0xff;
+	if (ioctl(fd, DMX_SET_FILTER, &sctFilterParams)) {
+		perror("DMX_SET_FILTER");
+		return -1;
+	}
+	pfd.fd = fd;
+	pfd.events = POLLIN;
+	r = poll(&pfd, 1, 10000);
+	if (r < 0) {
+		perror("poll");
+		goto out;
+	}
+	if (r > 0) {
+		r = read(fd, buf, bufsz);
+		if (r < 0) {
+			perror("read");
+			goto out;
+		}
+	}
+ out:
+	ioctl(fd, DMX_STOP, 0);
+	return r;
+}
+
+static const u_int8_t byterev8[256] = {
+        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 
+        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 
+        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 
+        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
+        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 
+        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
+        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 
+        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
+        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 
+        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
+        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 
+        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
+        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 
+        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
+        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 
+        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
+        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 
+        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
+        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 
+        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
+        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 
+        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
+        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 
+        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
+        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 
+        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
+        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 
+        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
+        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 
+        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
+        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 
+        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
+};
+
+static void dvb_handle_pes_payload(struct vbi *vbi, const u_int8_t *buf, unsigned int len)
+{
+	unsigned int p, i;
+	u_int8_t data[42];
+
+	if (buf[0] < 0x10 || buf[0] > 0x1f)
+		return;  /* no EBU teletext data */
+	for (p = 1; p < len; p += /*6 + 40*/ 2 + buf[p + 1]) {
+#if 0
+		printf("Txt Line:\n"
+		       "  data_unit_id             0x%02x\n"
+		       "  data_unit_length         0x%02x\n"
+		       "  reserved_for_future_use  0x%01x\n"
+		       "  field_parity             0x%01x\n"
+		       "  line_offset              0x%02x\n"
+		       "  framing_code             0x%02x\n"
+		       "  magazine_and_packet_addr 0x%04x\n"
+		       "  data_block               0x%02x 0x%02x 0x%02x 0x%02x\n",
+		       buf[p], buf[p+1],
+		       buf[p+2] >> 6,
+		       (buf[p+2] >> 5) & 1,
+		       buf[p+2] & 0x1f,
+		       buf[p+3],
+		       (buf[p+4] << 8) | buf[p+5],
+		       buf[p+6], buf[p+7], buf[p+8], buf[p+9]);
+#endif
+		for (i = 0; i < sizeof(data); i++)
+			data[i] = byterev8[buf[p+4+i]];
+		/*
+		 * note: we should probably check for missing lines and then
+		 * call out_of_sync(vbi); and/or vbi_reset(vbi);
+		 */
+		vt_line(vbi, data);
+	}
+}
+
+static unsigned int rawptr;
+
+static void dvb_handler(struct vbi *vbi, int fd)
+{
+	/* PES packet start code prefix and stream_id == private_stream_1 */
+	static const u_int8_t peshdr[4] = { 0x00, 0x00, 0x01, 0xbd };
+	u_int8_t *bp;
+	int n;
+	unsigned int p, i, len;
+        u_int16_t rpid;
+        u_int32_t crc, crccomp;
+
+	if (rawptr >= (unsigned int)rawbuf_size)
+		rawptr = 0;
+	n = read(vbi->fd, rawbuf + rawptr, rawbuf_size - rawptr);
+	if (n <= 0)
+		return;
+	rawptr += n;
+	if (rawptr < 6)
+		return;
+	if (memcmp(rawbuf, peshdr, sizeof(peshdr))) {
+		bp = memmem(rawbuf, rawptr, peshdr, sizeof(peshdr));
+		if (!bp)
+			return;
+		rawptr -= (bp - rawbuf);
+		memmove(rawbuf, bp, rawptr);
+		if (rawptr < 6)
+			return;
+	}
+	len = (rawbuf[4] << 8) | rawbuf[5];
+	if (len < 9) {
+		rawptr = 0;
+		return;
+	}
+	if (rawptr < len + 6)
+		return;
+	p = 9 + rawbuf[8];
+#if 0
+	for (i = 0; i < len - p; i++) {
+		if (!(i & 15))
+			printf("\n%04x:", i);
+		printf(" %02x", rawbuf[p + i]);
+	}
+	printf("\n");
+#endif
+	if (!dl_empty(vbi->clients))
+		dvb_handle_pes_payload(vbi, rawbuf + p, len - p);
+	rawptr -= len;
+	if (rawptr)
+		memmove(rawbuf, rawbuf + len, rawptr);
+}
+
+static int vbi_dvb_open(struct vbi *vbi, const char *vbi_name, const char *progname, int txtpid)
+{
+	struct {
+		u_int16_t pmtpid;
+		u_int16_t txtpid;
+		u_int16_t service_id;
+		u_int8_t service_type;
+		char service_provider_name[64];
+		char service_name[64];
+		u_int8_t txtlang[3];
+		u_int8_t txttype;
+		u_int8_t txtmagazine;
+		u_int8_t txtpage;
+	} progtbl[16], *progp;
+	u_int8_t tbl[4096];
+	int r;
+	unsigned int i, j, k, l, progcnt = 0;
+	struct dmx_pes_filter_params filterpar;
+
+	/* open DVB demux device */
+	if (!vbi_name)
+		vbi_name = "/dev/dvb/adapter0/demux0";
+	if ((vbi->fd = open(vbi_name, O_RDWR)) == -1) {
+		error("cannot open demux device %s", vbi_name);
+		return -1;
+	}
+	memset(progtbl, 0, sizeof(progtbl));
+	if (txtpid >= 0x15 && txtpid < 0x1fff) {
+		vbi->txtpid = txtpid;
+		printf("Using command line specified teletext PID 0x%x\n", vbi->txtpid);
+		goto txtpidfound;
+	}
+	/* parse PAT to enumerate services and to find the PMT PIDs */
+	r = dvb_get_table(vbi->fd, 0, 0, tbl, sizeof(tbl));
+	if (r == -1)
+		goto outerr;
+	if (!(tbl[5] & 1)) {
+		error("PAT not active (current_next_indicator == 0)");
+		goto outerr;
+	}
+	if (tbl[6] != 0 || tbl[7] != 0) {
+		error("PAT has multiple sections");
+		goto outerr;
+	}
+	if (r < 13) {
+		error("PAT too short\n");
+		goto outerr;
+	}
+	r -= 13;
+	for (i = 0; i < (unsigned)r; i += 4) {
+		if (progcnt >= sizeof(progtbl)/sizeof(progtbl[0])) {
+			error("Program table overflow");
+			goto outerr;
+		}
+		progtbl[progcnt].service_id = (tbl[8 + i] << 8) | tbl[9 + i];
+		if (!progtbl[progcnt].service_id)  /* this is the NIT pointer */
+			continue;
+		progtbl[progcnt].pmtpid = ((tbl[10 + i] << 8) | tbl[11 + i]) & 0x1fff;
+		progcnt++;
+	}
+	/* find the SDT to get the station names */
+	r = dvb_get_table(vbi->fd, 0x11, 0x42, tbl, sizeof(tbl));
+	if (r == -1)
+		goto outerr;
+	if (!(tbl[5] & 1)) {
+		error("SDT not active (current_next_indicator == 0)");
+		goto outerr;
+	}
+	if (tbl[6] != 0 || tbl[7] != 0) {
+		error("SDT has multiple sections");
+		goto outerr;
+	}
+	if (r < 12) {
+		error("SDT too short\n");
+		goto outerr;
+	}
+	i = 11;
+	while (i < (unsigned)r - 1) {
+		k = (tbl[i] << 8) | tbl[i+1]; /* service ID */
+		progp = NULL;
+		for (j = 0; j < progcnt; j++)
+			if (progtbl[j].service_id == k) {
+				progp = &progtbl[j];
+				break;
+			}
+		j = i + 5;
+		i = j + (((tbl[i+3] << 8) | tbl[i+4]) & 0x0fff);
+		if (!progp) {
+			error("SDT: service_id 0x%x not in PAT\n", k);
+			continue;
+		}
+		while (j < i) {
+			switch (tbl[j]) {
+			case 0x48:  /* service descriptor */
+				k = j + 4 + tbl[j + 3];
+				progp->service_type = tbl[j+2];
+				snprintf(progp->service_provider_name, sizeof(progp->service_provider_name),
+					 "%.*s", tbl[j+3], tbl + j + 4);
+				snprintf(progp->service_name, sizeof(progp->service_name),
+					 "%.*s", tbl[k], tbl + k + 1);
+				break;
+			}
+			j += 2 + tbl[j + 1];
+		}
+	}
+	/* parse PMT's to find Teletext Services */
+	for (l = 0; l < progcnt; l++) {
+		progtbl[l].txtpid = 0x1fff;
+		if (progtbl[l].service_type != 0x01 || /* service is not digital TV */
+		    progtbl[l].pmtpid < 0x15 ||        /* PMT PID sanity check */
+		    progtbl[l].pmtpid >= 0x1fff)
+			continue;
+		r = dvb_get_table(vbi->fd, progtbl[l].pmtpid, 0x02, tbl, sizeof(tbl));
+		if (r == -1)
+			goto outerr;
+		if (!(tbl[5] & 1)) {
+			error("PMT pid 0x%x not active (current_next_indicator == 0)", progtbl[l].pmtpid);
+			goto outerr;
+		}
+		if (tbl[6] != 0 || tbl[7] != 0) {
+			error("PMT pid 0x%x has multiple sections", progtbl[l].pmtpid);
+			goto outerr;
+		}
+		if (r < 13) {
+			error("PMT pid 0x%x too short\n", progtbl[l].pmtpid);
+			goto outerr;
+		}
+		i = 12 + (((tbl[10] << 8) | tbl[11]) & 0x0fff); /* skip program info section */
+		while (i <= (unsigned)r-6) {
+			j = i + 5;
+			i = j + (((tbl[i + 3] << 8) | tbl[i + 4]) & 0x0fff);
+			if (tbl[j - 5] != 0x06)   /* teletext streams have type 0x06 */
+				continue;
+			k = ((tbl[j - 4] << 8) | tbl[j - 3]) & 0x1fff;  /* elementary PID - save until we know if it's the teletext PID */
+			while (j < i) {
+				switch (tbl[j]) {
+				case 0x56:  /* EBU teletext descriptor */
+					progtbl[l].txtlang[0] = tbl[j + 2];
+					progtbl[l].txtlang[1] = tbl[j + 3];
+					progtbl[l].txtlang[2] = tbl[j + 4];
+					progtbl[l].txttype = tbl[j + 5] >> 3;
+					progtbl[l].txtmagazine = tbl[j + 5] & 7;
+					progtbl[l].txtpage = tbl[j + 6];
+					progtbl[l].txtpid = k;
+					break;
+				}
+				j += 2 + tbl[j + 1];
+			}
+		}
+	}
+
+	for (i = 0; i < progcnt; i++) {
+		printf("Service ID 0x%04x Type 0x%02x Provider Name \"%s\" Name \"%s\"\n"
+		       "  PMT PID 0x%04x TXT: PID 0x%04x lang %.3s type 0x%02x magazine %1u page %3u\n", 
+		       progtbl[i].service_id, progtbl[i].service_type, progtbl[i].service_provider_name,
+		       progtbl[i].service_name, progtbl[i].pmtpid, progtbl[i].txtpid, progtbl[i].txtlang,
+		       progtbl[i].txttype, progtbl[i].txtmagazine, progtbl[i].txtpage);
+	}
+
+	progp = NULL;
+	if (progname) {
+		j = strlen(progname);
+		for (i = 0; i < progcnt; i++)
+			if (!strncmp(progtbl[i].service_name, progname, j) && progtbl[i].txtpid != 0x1fff) {
+				progp = &progtbl[i];
+				break;
+			}
+	}
+	if (progname && !progp) {
+		j = strlen(progname);
+		for (i = 0; i < progcnt; i++)
+			if (!strncasecmp(progtbl[i].service_name, progname, j) && progtbl[i].txtpid != 0x1fff) {
+				progp = &progtbl[i];
+				break;
+			}
+	}
+	if (!progp) {
+		for (i = 0; i < progcnt; i++)
+			if (progtbl[i].txtpid != 0x1fff) {
+				progp = &progtbl[i];
+				break;
+			}
+	}
+
+	printf("Using: Service ID 0x%04x Type 0x%02x Provider Name \"%s\" Name \"%s\"\n"
+	       "  PMT PID 0x%04x TXT: PID 0x%04x lang %.3s type 0x%02x magazine %1u page %3u\n", 
+	       progp->service_id, progp->service_type, progp->service_provider_name,
+	       progp->service_name, progp->pmtpid, progp->txtpid, progp->txtlang,
+	       progp->txttype, progp->txtmagazine, progp->txtpage);
+	
+	vbi->txtpid = progp->txtpid;
+ txtpidfound:
+	rawbuf = malloc(rawbuf_size = 8192);
+	if (!rawbuf)
+		goto outerr;
+	rawptr = 0;
+#if 0
+	close(vbi->fd);
+	if ((vbi->fd = open(vbi_name, O_RDWR)) == -1) {
+		error("cannot open demux device %s", vbi_name);
+		return -1;
+	}
+#endif
+	memset(&filterpar, 0, sizeof(filterpar));
+	filterpar.pid = vbi->txtpid;
+        filterpar.input = DMX_IN_FRONTEND;
+        filterpar.output = DMX_OUT_TAP;
+        filterpar.pes_type = DMX_PES_OTHER;
+        filterpar.flags = DMX_IMMEDIATE_START;
+        if (ioctl(vbi->fd, DMX_SET_PES_FILTER, &filterpar) < 0) {
+                error("ioctl: DMX_SET_PES_FILTER %s (%u)", strerror(errno), errno);
+                goto outerr;
+        }
+	return 0;
+
+ outerr:
+	close(vbi->fd);
+	vbi->fd = -1;
+	return -1;
+}
Index: alevt-1.6.2/vbi.h
===================================================================
--- alevt-1.6.2.orig/vbi.h
+++ alevt-1.6.2/vbi.h
@@ -36,6 +36,11 @@ struct vbi
     int bpb;			// bytes per bit * 2^16
     int bp8bl, bp8bh;		// bytes per 8-bit low/high
     int soc, eoc;		// start/end of clock run-in
+
+	// DVB stuff
+	unsigned int txtpid;
+	
+
 };
 
 struct vbi_client
@@ -46,7 +51,7 @@ struct vbi_client
 };
 
 struct vbi *vbi_open(char *vbi_dev_name, struct cache *ca, int fine_tune,
-								int big_buf);
+		     int big_buf, const char *progname, int txtpid);
 void vbi_close(struct vbi *vbi);
 void vbi_reset(struct vbi *vbi);
 int vbi_add_handler(struct vbi *vbi, void *handler, void *data);
Index: alevt-1.6.2/alevt-cap.c
===================================================================
--- alevt-1.6.2.orig/alevt-cap.c
+++ alevt-1.6.2/alevt-cap.c
@@ -44,12 +44,21 @@ usage(FILE *fp, int exitval)
 	    "    -name <filename>\t\tttext-%%s.%%e\n"
 	    "    -format <fmt[,options]>\tascii\n"
 	    "    -format help\n"
+	    "    -progname name\n"
+	    "    -pid pid\n"
 	    "\n"
 	    "  ppp[.ss] stands for a page number and an\n"
 	    "  optional subpage number (ie 123.4).  If\n"
 	    "  the subpage number is omitted the first\n"
 	    "  transmitted subpage is captured.\n"
 	    "\n"
+	    "\n"
+	    "  To use the DVB interface, use\n"
+	    "  -vbi /dev/dvb/adapter0/demux0\n"
+	    "\n"
+	    "  The -progname or -pid option specify\n"
+	    "  the program or teletext PID if using\n"
+	    "  the DVB interface.\n"
 	);
     exit(exitval);
 }
@@ -130,6 +139,8 @@ option(int argc, char **argv, int *ind,
 	{ "-format", "-fmt", 1 },
 	{ "-name", "-o", 1 },
 	{ "-timeout", "-t", 1 },
+	{ "-progname", "-pn", 1 },
+	{ "-pid", "--pid", 1 },
     };
     int i;
 
@@ -204,6 +215,8 @@ main(int argc, char **argv)
     struct vbi *vbi;
     struct req *req;
     struct dl_head reqs[2];	// simple linear lists of requests & captures
+    char *progname = NULL;
+    int txtpid = -1;
 
     setprgname(argv[0]);
 
@@ -264,6 +277,12 @@ main(int argc, char **argv)
 		if (timeout < 1 || timeout > 999999)
 		    fatal("bad timeout value", timeout);
 		break;
+  	    case 13:    // progname
+		progname = arg;
+		break;
+  	    case 14:    // pid
+		txtpid = strtoul(arg, NULL, 0);
+		break;
 	    case -1:	// non-option arg
 		if (not fmt)
 		    fmt = export_open(out_fmt);
@@ -283,7 +302,7 @@ main(int argc, char **argv)
 	fatal("no pages requested");
 
     // setup device
-    if (not(vbi = vbi_open(vbi_name, 0, fine_tune, newbttv)))
+    if (not(vbi = vbi_open(vbi_name, 0, fine_tune, newbttv, progname, txtpid)))
 	fatal("cannot open %s", vbi_name);
     vbi_add_handler(vbi, event, reqs); // register event handler
 
Index: alevt-1.6.2/dvb/audio.h
===================================================================
--- /dev/null
+++ alevt-1.6.2/dvb/audio.h
@@ -0,0 +1,124 @@
+/* 
+ * audio.h
+ *
+ * Copyright (C) 2000 Ralph  Metzler <ralph@convergence.de>
+ *                  & Marcus Metzler <marcus@convergence.de>
+                      for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Lesser Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBAUDIO_H_
+#define _DVBAUDIO_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+
+typedef enum {
+        AUDIO_SOURCE_DEMUX, /* Select the demux as the main source */ 
+	AUDIO_SOURCE_MEMORY /* Select internal memory as the main source */ 
+} audio_stream_source_t;
+
+
+typedef enum { 
+	AUDIO_STOPPED,      /* Device is stopped */ 
+        AUDIO_PLAYING,      /* Device is currently playing */ 
+	AUDIO_PAUSED        /* Device is paused */ 
+} audio_play_state_t;
+
+
+typedef enum {
+        AUDIO_STEREO,
+        AUDIO_MONO_LEFT, 
+	AUDIO_MONO_RIGHT, 
+} audio_channel_select_t;
+
+
+typedef struct audio_status { 
+        int                    AV_sync_state;  /* sync audio and video? */
+        int                    mute_state;     /* audio is muted */ 
+        audio_play_state_t     play_state;     /* current playback state */
+        audio_stream_source_t  stream_source;  /* current stream source */
+        audio_channel_select_t channel_select; /* currently selected channel */
+        int                    bypass_mode;    /* pass on audio data to */
+} audio_status_t;                              /* separate decoder hardware */
+
+
+typedef struct audio_mixer { 
+        unsigned int volume_left;
+        unsigned int volume_right;
+  // what else do we need? bass, pass-through, ...
+} audio_mixer_t;
+
+
+typedef
+struct audio_karaoke{  /* if Vocal1 or Vocal2 are non-zero, they get mixed  */
+	int vocal1;    /* into left and right t at 70% each */
+	int vocal2;    /* if both, Vocal1 and Vocal2 are non-zero, Vocal1 gets*/
+	int melody;    /* mixed into the left channel and */
+                       /* Vocal2 into the right channel at 100% each. */
+                       /* if Melody is non-zero, the melody channel gets mixed*/
+} audio_karaoke_t;     /* into left and right  */
+
+
+typedef uint16_t audio_attributes_t;
+/*   bits: descr. */
+/*   15-13 audio coding mode (0=ac3, 2=mpeg1, 3=mpeg2ext, 4=LPCM, 6=DTS, */
+/*   12    multichannel extension */
+/*   11-10 audio type (0=not spec, 1=language included) */
+/*    9- 8 audio application mode (0=not spec, 1=karaoke, 2=surround) */
+/*    7- 6 Quantization / DRC (mpeg audio: 1=DRC exists)(lpcm: 0=16bit,  */
+/*    5- 4 Sample frequency fs (0=48kHz, 1=96kHz) */
+/*    2- 0 number of audio channels (n+1 channels) */
+ 
+
+/* for GET_CAPABILITIES and SET_FORMAT, the latter should only set one bit */
+#define AUDIO_CAP_DTS    1
+#define AUDIO_CAP_LPCM   2
+#define AUDIO_CAP_MP1    4
+#define AUDIO_CAP_MP2    8
+#define AUDIO_CAP_MP3   16
+#define AUDIO_CAP_AAC   32
+#define AUDIO_CAP_OGG   64
+#define AUDIO_CAP_SDDS 128
+#define AUDIO_CAP_AC3  256
+
+#define AUDIO_STOP                 _IO('o', 1) 
+#define AUDIO_PLAY                 _IO('o', 2)
+#define AUDIO_PAUSE                _IO('o', 3)
+#define AUDIO_CONTINUE             _IO('o', 4)
+#define AUDIO_SELECT_SOURCE        _IO('o', 5)
+#define AUDIO_SET_MUTE             _IO('o', 6)
+#define AUDIO_SET_AV_SYNC          _IO('o', 7)
+#define AUDIO_SET_BYPASS_MODE      _IO('o', 8)
+#define AUDIO_CHANNEL_SELECT       _IO('o', 9)
+#define AUDIO_GET_STATUS           _IOR('o', 10, audio_status_t)
+
+#define AUDIO_GET_CAPABILITIES     _IOR('o', 11, unsigned int)
+#define AUDIO_CLEAR_BUFFER         _IO('o',  12)
+#define AUDIO_SET_ID               _IO('o', 13)
+#define AUDIO_SET_MIXER            _IOW('o', 14, audio_mixer_t)
+#define AUDIO_SET_STREAMTYPE       _IO('o', 15)
+#define AUDIO_SET_EXT_ID           _IO('o', 16)
+#define AUDIO_SET_ATTRIBUTES       _IOW('o', 17, audio_attributes_t)
+#define AUDIO_SET_KARAOKE          _IOW('o', 18, audio_karaoke_t)
+
+#endif /* _DVBAUDIO_H_ */
+
Index: alevt-1.6.2/dvb/ca.h
===================================================================
--- /dev/null
+++ alevt-1.6.2/dvb/ca.h
@@ -0,0 +1,84 @@
+/* 
+ * ca.h
+ *
+ * Copyright (C) 2000 Ralph  Metzler <ralph@convergence.de>
+ *                  & Marcus Metzler <marcus@convergence.de>
+                      for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Lesser Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _CA_H_
+#define _CA_H_
+
+/* slot interface types and info */
+
+typedef struct ca_slot_info_s {
+        int num;               /* slot number */
+
+        int type;              /* CA interface this slot supports */
+#define CA_CI            1     /* CI high level interface */
+#define CA_CI_LINK       2     /* CI link layer level interface */
+#define CA_CI_PHYS       4     /* CI physical layer level interface */
+#define CA_SC          128     /* simple smart card interface */
+
+        unsigned int flags;
+#define CA_CI_MODULE_PRESENT 1 /* module (or card) inserted */
+#define CA_CI_MODULE_READY   2
+} ca_slot_info_t;
+
+
+/* descrambler types and info */
+
+typedef struct ca_descr_info_s {
+        unsigned int num;          /* number of available descramblers (keys) */ 
+        unsigned int type;         /* type of supported scrambling system */
+#define CA_ECD           1
+#define CA_NDS           2
+#define CA_DSS           4
+} ca_descr_info_t;
+
+typedef struct ca_cap_s {
+        unsigned int slot_num;     /* total number of CA card and module slots */
+        unsigned int slot_type;    /* OR of all supported types */
+        unsigned int descr_num;    /* total number of descrambler slots (keys) */
+        unsigned int descr_type;   /* OR of all supported types */
+} ca_cap_t;
+
+/* a message to/from a CI-CAM */
+typedef struct ca_msg_s {   
+        unsigned int index;         
+        unsigned int type;
+        unsigned int length;
+        unsigned char msg[256];
+} ca_msg_t;
+
+typedef struct ca_descr_s {
+        unsigned int index;    
+        unsigned int parity;
+        unsigned char cw[8];
+} ca_descr_t;
+
+#define CA_RESET          _IO('o', 128)
+#define CA_GET_CAP        _IOR('o', 129, ca_cap_t)
+#define CA_GET_SLOT_INFO  _IOR('o', 130, ca_slot_info_t)
+#define CA_GET_DESCR_INFO _IOR('o', 131, ca_descr_info_t)
+#define CA_GET_MSG        _IOR('o', 132, ca_msg_t)
+#define CA_SEND_MSG       _IOW('o', 133, ca_msg_t)
+#define CA_SET_DESCR      _IOW('o', 134, ca_descr_t)
+
+#endif
+
Index: alevt-1.6.2/dvb/dmx.h
===================================================================
--- /dev/null
+++ alevt-1.6.2/dvb/dmx.h
@@ -0,0 +1,172 @@
+/* 
+ * dmx.h
+ *
+ * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
+ *                  & Ralph  Metzler <ralph@convergence.de>
+                      for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DMX_H_
+#define _DMX_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+#define DMX_FILTER_SIZE 16
+
+typedef enum
+{
+	DMX_OUT_DECODER, /* Streaming directly to decoder. */
+	DMX_OUT_TAP,     /* Output going to a memory buffer */
+	                 /* (to be retrieved via the read command).*/
+	DMX_OUT_TS_TAP   /* Output multiplexed into a new TS  */
+	                 /* (to be retrieved by reading from the */
+	                 /* logical DVR device).                 */
+} dmx_output_t;
+
+
+typedef enum
+{
+	DMX_IN_FRONTEND, /* Input from a front-end device.  */
+	DMX_IN_DVR       /* Input from the logical DVR device.  */
+} dmx_input_t;
+
+
+typedef enum
+{
+        DMX_PES_AUDIO0,
+	DMX_PES_VIDEO0,
+	DMX_PES_TELETEXT0,
+	DMX_PES_SUBTITLE0,
+	DMX_PES_PCR0,
+
+        DMX_PES_AUDIO1,
+	DMX_PES_VIDEO1,
+	DMX_PES_TELETEXT1,
+	DMX_PES_SUBTITLE1,
+	DMX_PES_PCR1,
+
+        DMX_PES_AUDIO2,
+	DMX_PES_VIDEO2,
+	DMX_PES_TELETEXT2,
+	DMX_PES_SUBTITLE2,
+	DMX_PES_PCR2,
+
+        DMX_PES_AUDIO3,
+	DMX_PES_VIDEO3,
+	DMX_PES_TELETEXT3,
+	DMX_PES_SUBTITLE3,
+	DMX_PES_PCR3,
+
+	DMX_PES_OTHER
+} dmx_pes_type_t;
+
+#define DMX_PES_AUDIO    DMX_PES_AUDIO0
+#define DMX_PES_VIDEO    DMX_PES_VIDEO0
+#define DMX_PES_TELETEXT DMX_PES_TELETEXT0
+#define DMX_PES_SUBTITLE DMX_PES_SUBTITLE0
+#define DMX_PES_PCR      DMX_PES_PCR0
+
+
+typedef enum
+{
+        DMX_SCRAMBLING_EV,
+        DMX_FRONTEND_EV
+} dmx_event_t;
+
+
+typedef enum
+{
+	DMX_SCRAMBLING_OFF,
+	DMX_SCRAMBLING_ON
+} dmx_scrambling_status_t;
+
+
+typedef struct dmx_filter
+{
+	uint8_t         filter[DMX_FILTER_SIZE];
+	uint8_t         mask[DMX_FILTER_SIZE];
+	uint8_t         mode[DMX_FILTER_SIZE];
+} dmx_filter_t;
+
+
+struct dmx_sct_filter_params
+{
+	uint16_t            pid;
+	dmx_filter_t        filter;
+	uint32_t            timeout;
+	uint32_t            flags;
+#define DMX_CHECK_CRC       1
+#define DMX_ONESHOT         2
+#define DMX_IMMEDIATE_START 4
+#define DMX_KERNEL_CLIENT   0x8000
+};
+
+
+struct dmx_pes_filter_params
+{
+	uint16_t            pid;
+	dmx_input_t         input;
+	dmx_output_t        output;
+	dmx_pes_type_t      pes_type;
+	uint32_t            flags;
+};
+
+
+struct dmx_event
+{
+	dmx_event_t         event;
+	time_t              timeStamp;
+	union
+	{
+		dmx_scrambling_status_t scrambling;
+	} u;
+};
+
+typedef struct dmx_caps {
+	uint32_t caps;
+	int num_decoders; 
+} dmx_caps_t;
+
+typedef enum {
+	DMX_SOURCE_FRONT0 = 0,
+	DMX_SOURCE_FRONT1,
+	DMX_SOURCE_FRONT2,
+	DMX_SOURCE_FRONT3,
+	DMX_SOURCE_DVR0   = 16,
+	DMX_SOURCE_DVR1,
+	DMX_SOURCE_DVR2,
+	DMX_SOURCE_DVR3,
+} dmx_source_t;
+
+
+#define DMX_START                _IO('o',41) 
+#define DMX_STOP                 _IO('o',42)
+#define DMX_SET_FILTER           _IOW('o',43,struct dmx_sct_filter_params)
+#define DMX_SET_PES_FILTER       _IOW('o',44,struct dmx_pes_filter_params)
+#define DMX_SET_BUFFER_SIZE      _IO('o',45)
+#define DMX_GET_EVENT            _IOR('o',46,struct dmx_event)
+#define DMX_GET_PES_PIDS         _IOR('o',47,uint16_t)
+#define DMX_GET_CAPS             _IOR('o',48,dmx_caps_t)
+#define DMX_SET_SOURCE           _IOW('o',49,dmx_source_t)
+
+#endif /*_DMX_H_*/
+
Index: alevt-1.6.2/dvb/frontend.h
===================================================================
--- /dev/null
+++ alevt-1.6.2/dvb/frontend.h
@@ -0,0 +1,261 @@
+/*
+ * frontend.h
+ *
+ * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
+ *                    Ralph  Metzler <ralph@convergence.de>
+ *                    Holger Waechtler <holger@convergence.de>
+ *                    Andre Draszik <ad@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _FRONTEND_H_
+#define _FRONTEND_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+
+typedef enum {
+        FE_QPSK,
+        FE_QAM,
+        FE_OFDM
+} fe_type_t;
+
+
+typedef enum {
+	FE_IS_STUPID                  = 0,
+	FE_CAN_INVERSION_AUTO         = 0x1,
+	FE_CAN_FEC_1_2                = 0x2,
+	FE_CAN_FEC_2_3                = 0x4,
+	FE_CAN_FEC_3_4                = 0x8,
+	FE_CAN_FEC_4_5                = 0x10,
+	FE_CAN_FEC_5_6                = 0x20,
+	FE_CAN_FEC_6_7                = 0x40,
+	FE_CAN_FEC_7_8                = 0x80,
+	FE_CAN_FEC_8_9                = 0x100,
+	FE_CAN_FEC_AUTO               = 0x200,
+	FE_CAN_QPSK                   = 0x400,
+	FE_CAN_QAM_16                 = 0x800,
+	FE_CAN_QAM_32                 = 0x1000,
+	FE_CAN_QAM_64                 = 0x2000,
+	FE_CAN_QAM_128                = 0x4000,
+	FE_CAN_QAM_256                = 0x8000,
+	FE_CAN_QAM_AUTO               = 0x10000,
+	FE_CAN_TRANSMISSION_MODE_AUTO = 0x20000,
+	FE_CAN_BANDWIDTH_AUTO         = 0x40000,
+	FE_CAN_GUARD_INTERVAL_AUTO    = 0x80000,
+	FE_CAN_HIERARCHY_AUTO         = 0x100000,
+	FE_CAN_MUTE_TS                = 0x80000000
+} fe_caps_t;
+
+
+struct dvb_frontend_info {
+	char       name[128];
+        fe_type_t  type;
+        uint32_t   frequency_min;
+        uint32_t   frequency_max;
+	uint32_t   frequency_stepsize;
+	uint32_t   frequency_tolerance;
+	uint32_t   symbol_rate_min;
+        uint32_t   symbol_rate_max;
+	uint32_t   symbol_rate_tolerance;     /* ppm */
+	uint32_t   notifier_delay;            /* ms */
+	fe_caps_t  caps;
+};
+
+
+/**
+ *  Check out the DiSEqC bus spec available on http://www.eutelsat.org/ for
+ *  the meaning of this struct...
+ */
+struct dvb_diseqc_master_cmd {
+        uint8_t msg [6];        /*  { framing, address, command, data [3] } */
+        uint8_t msg_len;        /*  valid values are 3...6  */
+};
+
+
+struct dvb_diseqc_slave_reply {
+	uint8_t msg [4];        /*  { framing, data [3] } */
+	uint8_t msg_len;        /*  valid values are 0...4, 0 means no msg  */
+	int     timeout;        /*  return from ioctl after timeout ms with */
+};                              /*  errorcode when no message was received  */
+
+
+typedef enum {
+        SEC_VOLTAGE_13,
+        SEC_VOLTAGE_18
+} fe_sec_voltage_t;
+
+
+typedef enum {
+        SEC_TONE_ON,
+        SEC_TONE_OFF
+} fe_sec_tone_mode_t;
+
+
+typedef enum {
+        SEC_MINI_A,
+        SEC_MINI_B
+} fe_sec_mini_cmd_t;
+
+
+typedef enum {
+	FE_HAS_SIGNAL     = 0x01,   /*  found something above the noise level */
+	FE_HAS_CARRIER    = 0x02,   /*  found a DVB signal  */
+	FE_HAS_VITERBI    = 0x04,   /*  FEC is stable  */
+	FE_HAS_SYNC       = 0x08,   /*  found sync bytes  */
+	FE_HAS_LOCK       = 0x10,   /*  everything's working... */
+	FE_TIMEDOUT       = 0x20,   /*  no lock within the last ~2 seconds */
+	FE_REINIT         = 0x40    /*  frontend was reinitialized,  */
+} fe_status_t;                      /*  application is recommned to reset */
+                                    /*  DiSEqC, tone and parameters */
+
+typedef enum {
+        INVERSION_OFF,
+        INVERSION_ON,
+        INVERSION_AUTO
+} fe_spectral_inversion_t;
+
+
+typedef enum {
+        FEC_NONE = 0,
+        FEC_1_2,
+        FEC_2_3,
+        FEC_3_4,
+        FEC_4_5,
+        FEC_5_6,
+        FEC_6_7,
+        FEC_7_8,
+        FEC_8_9,
+        FEC_AUTO
+} fe_code_rate_t;
+
+
+typedef enum {
+        QPSK,
+        QAM_16,
+        QAM_32,
+        QAM_64,
+        QAM_128,
+        QAM_256,
+	QAM_AUTO
+} fe_modulation_t;
+
+
+typedef enum {
+	TRANSMISSION_MODE_2K,
+	TRANSMISSION_MODE_8K,
+	TRANSMISSION_MODE_AUTO
+} fe_transmit_mode_t;
+
+typedef enum {
+	BANDWIDTH_8_MHZ,
+	BANDWIDTH_7_MHZ,
+	BANDWIDTH_6_MHZ,
+	BANDWIDTH_AUTO
+} fe_bandwidth_t;
+
+
+typedef enum {
+	GUARD_INTERVAL_1_32,
+	GUARD_INTERVAL_1_16,
+	GUARD_INTERVAL_1_8,
+	GUARD_INTERVAL_1_4,
+	GUARD_INTERVAL_AUTO
+} fe_guard_interval_t;
+
+
+typedef enum {
+	HIERARCHY_NONE,
+	HIERARCHY_1,
+	HIERARCHY_2,
+	HIERARCHY_4,
+	HIERARCHY_AUTO
+} fe_hierarchy_t;
+
+
+struct dvb_qpsk_parameters {
+        uint32_t        symbol_rate;  /* symbol rate in Symbols per second */
+        fe_code_rate_t  fec_inner;    /* forward error correction (see above) */
+};
+
+
+struct dvb_qam_parameters {
+        uint32_t         symbol_rate; /* symbol rate in Symbols per second */
+        fe_code_rate_t   fec_inner;   /* forward error correction (see above) */
+        fe_modulation_t  modulation;  /* modulation type (see above) */
+};
+
+
+struct dvb_ofdm_parameters {
+        fe_bandwidth_t      bandwidth;
+        fe_code_rate_t      code_rate_HP;  /* high priority stream code rate */
+        fe_code_rate_t      code_rate_LP;  /* low priority stream code rate */
+        fe_modulation_t     constellation; /* modulation type (see above) */
+        fe_transmit_mode_t  transmission_mode;
+        fe_guard_interval_t guard_interval;
+        fe_hierarchy_t      hierarchy_information;
+};
+
+
+struct dvb_frontend_parameters {
+        uint32_t frequency;       /* (absolute) frequency in Hz for QAM/OFDM */
+                                  /* intermediate frequency in kHz for QPSK */
+	fe_spectral_inversion_t inversion;
+	union {
+		struct dvb_qpsk_parameters qpsk;
+		struct dvb_qam_parameters  qam;
+		struct dvb_ofdm_parameters ofdm;
+	} u;
+};
+
+
+struct dvb_frontend_event {
+	fe_status_t status;
+	struct dvb_frontend_parameters parameters;
+};
+
+
+
+#define FE_GET_INFO                _IOR('o', 61, struct dvb_frontend_info)
+
+#define FE_DISEQC_RESET_OVERLOAD   _IO('o', 62)
+#define FE_DISEQC_SEND_MASTER_CMD  _IOW('o', 63, struct dvb_diseqc_master_cmd)
+#define FE_DISEQC_RECV_SLAVE_REPLY _IOR('o', 64, struct dvb_diseqc_slave_reply)
+#define FE_DISEQC_SEND_BURST       _IO('o', 65)  /* fe_sec_mini_cmd_t */
+
+#define FE_SET_TONE                _IO('o', 66)  /* fe_sec_tone_mode_t */
+#define FE_SET_VOLTAGE             _IO('o', 67)  /* fe_sec_voltage_t */
+#define FE_ENABLE_HIGH_LNB_VOLTAGE _IO('o', 68)  /* int */
+
+#define FE_READ_STATUS             _IOR('o', 69, fe_status_t)
+#define FE_READ_BER                _IOR('o', 70, uint32_t)
+#define FE_READ_SIGNAL_STRENGTH    _IOR('o', 71, uint16_t)
+#define FE_READ_SNR                _IOR('o', 72, uint16_t)
+#define FE_READ_UNCORRECTED_BLOCKS _IOR('o', 73, uint32_t)
+
+#define FE_SET_FRONTEND            _IOW('o', 76, struct dvb_frontend_parameters)
+#define FE_GET_FRONTEND            _IOR('o', 77, struct dvb_frontend_parameters)
+#define FE_GET_EVENT               _IOR('o', 78, struct dvb_frontend_event)
+
+
+#endif /*_FRONTEND_H_*/
+
Index: alevt-1.6.2/dvb/net.h
===================================================================
--- /dev/null
+++ alevt-1.6.2/dvb/net.h
@@ -0,0 +1,44 @@
+/* 
+ * net.h
+ *
+ * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
+ *                  & Ralph  Metzler <ralph@convergence.de>
+                      for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBNET_H_
+#define _DVBNET_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+
+struct dvb_net_if {
+	uint16_t pid;
+	uint16_t if_num;
+};
+
+
+#define NET_ADD_IF                 _IOWR('o', 52, struct dvb_net_if)
+#define NET_REMOVE_IF              _IO('o', 53)
+
+#endif /*_DVBNET_H_*/
+
Index: alevt-1.6.2/dvb/osd.h
===================================================================
--- /dev/null
+++ alevt-1.6.2/dvb/osd.h
@@ -0,0 +1,111 @@
+/* 
+ * osd.h
+ *
+ * Copyright (C) 2001 Ralph  Metzler <ralph@convergence.de>
+ *                  & Marcus Metzler <marcus@convergence.de>
+                      for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Lesser Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBOSD_H_
+#define _DVBOSD_H_
+
+typedef enum {
+  // All functions return -2 on "not open"
+  OSD_Close=1,    // ()
+  // Disables OSD and releases the buffers
+  // returns 0 on success
+  OSD_Open,       // (x0,y0,x1,y1,BitPerPixel[2/4/8](color&0x0F),mix[0..15](color&0xF0))
+  // Opens OSD with this size and bit depth
+  // returns 0 on success, -1 on DRAM allocation error, -2 on "already open"
+  OSD_Show,       // ()
+  // enables OSD mode
+  // returns 0 on success
+  OSD_Hide,       // ()
+  // disables OSD mode
+  // returns 0 on success
+  OSD_Clear,      // ()
+  // Sets all pixel to color 0
+  // returns 0 on success
+  OSD_Fill,       // (color)
+  // Sets all pixel to color <col>
+  // returns 0 on success
+  OSD_SetColor,   // (color,R{x0},G{y0},B{x1},opacity{y1})
+  // set palette entry <num> to <r,g,b>, <mix> and <trans> apply
+  // R,G,B: 0..255
+  // R=Red, G=Green, B=Blue
+  // opacity=0:      pixel opacity 0% (only video pixel shows)
+  // opacity=1..254: pixel opacity as specified in header
+  // opacity=255:    pixel opacity 100% (only OSD pixel shows)
+  // returns 0 on success, -1 on error
+  OSD_SetPalette, // (firstcolor{color},lastcolor{x0},data)
+  // Set a number of entries in the palette
+  // sets the entries "firstcolor" through "lastcolor" from the array "data"
+  // data has 4 byte for each color:
+  // R,G,B, and a opacity value: 0->transparent, 1..254->mix, 255->pixel
+  OSD_SetTrans,   // (transparency{color})
+  // Sets transparency of mixed pixel (0..15)
+  // returns 0 on success
+  OSD_SetPixel,   // (x0,y0,color)
+  // sets pixel <x>,<y> to color number <col>
+  // returns 0 on success, -1 on error
+  OSD_GetPixel,   // (x0,y0)
+  // returns color number of pixel <x>,<y>,  or -1
+  OSD_SetRow,     // (x0,y0,x1,data)
+  // fills pixels x0,y through  x1,y with the content of data[]
+  // returns 0 on success, -1 on clipping all pixel (no pixel drawn)
+  OSD_SetBlock,   // (x0,y0,x1,y1,increment{color},data)
+  // fills pixels x0,y0 through  x1,y1 with the content of data[]
+  // inc contains the width of one line in the data block,
+  // inc<=0 uses blockwidth as linewidth
+  // returns 0 on success, -1 on clipping all pixel
+  OSD_FillRow,    // (x0,y0,x1,color)
+  // fills pixels x0,y through  x1,y with the color <col>
+  // returns 0 on success, -1 on clipping all pixel
+  OSD_FillBlock,  // (x0,y0,x1,y1,color)
+  // fills pixels x0,y0 through  x1,y1 with the color <col>
+  // returns 0 on success, -1 on clipping all pixel
+  OSD_Line,       // (x0,y0,x1,y1,color)
+  // draw a line from x0,y0 to x1,y1 with the color <col>
+  // returns 0 on success
+  OSD_Query,      // (x0,y0,x1,y1,xasp{color}}), yasp=11
+  // fills parameters with the picture dimensions and the pixel aspect ratio
+  // returns 0 on success
+  OSD_Test,       // ()
+  // draws a test picture. for debugging purposes only
+  // returns 0 on success
+// TODO: remove "test" in final version
+  OSD_Text,       // (x0,y0,size,color,text)
+  OSD_SetWindow, //  (x0) set window with number 0<x0<8 as current
+  OSD_MoveWindow, //  move current window to (x0, y0)  
+} OSD_Command;
+
+typedef struct osd_cmd_s {
+        OSD_Command cmd;
+        int x0;
+        int y0;
+        int x1;
+        int y1;
+        int color;
+        void *data;
+} osd_cmd_t;
+
+
+#define OSD_SEND_CMD       _IOW('o', 160, osd_cmd_t)
+
+#endif
+
Index: alevt-1.6.2/dvb/version.h
===================================================================
--- /dev/null
+++ alevt-1.6.2/dvb/version.h
@@ -0,0 +1,29 @@
+/*
+ * version.h
+ *
+ * Copyright (C) 2000 Holger Waechtler <holger@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _VERSION_H_
+#define _VERSION_H_
+
+#define DVB_API_VERSION 3
+
+#endif /*_VERSION_H_*/
+
Index: alevt-1.6.2/dvb/video.h
===================================================================
--- /dev/null
+++ alevt-1.6.2/dvb/video.h
@@ -0,0 +1,190 @@
+/* 
+ * video.h
+ *
+ * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
+ *                  & Ralph  Metzler <ralph@convergence.de>
+                      for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBVIDEO_H_
+#define _DVBVIDEO_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+
+typedef enum {
+	VIDEO_FORMAT_4_3,     /* Select 4:3 format */ 
+        VIDEO_FORMAT_16_9     /* Select 16:9 format. */ 
+} video_format_t;
+
+
+typedef enum {
+	 VIDEO_SYSTEM_PAL, 
+	 VIDEO_SYSTEM_NTSC, 
+	 VIDEO_SYSTEM_PALN, 
+	 VIDEO_SYSTEM_PALNc, 
+	 VIDEO_SYSTEM_PALM, 
+	 VIDEO_SYSTEM_NTSC60, 
+	 VIDEO_SYSTEM_PAL60,
+	 VIDEO_SYSTEM_PALM60
+} video_system_t;
+
+
+typedef enum {   
+        VIDEO_PAN_SCAN,       /* use pan and scan format */
+	VIDEO_LETTER_BOX,     /* use letterbox format */
+	VIDEO_CENTER_CUT_OUT  /* use center cut out format */
+} video_displayformat_t;
+
+
+typedef enum {
+        VIDEO_SOURCE_DEMUX, /* Select the demux as the main source */ 
+	VIDEO_SOURCE_MEMORY /* If this source is selected, the stream 
+			       comes from the user through the write 
+			       system call */ 
+} video_stream_source_t;
+
+
+typedef enum {
+	VIDEO_STOPPED, /* Video is stopped */ 
+        VIDEO_PLAYING, /* Video is currently playing */ 
+	VIDEO_FREEZED  /* Video is freezed */ 
+} video_play_state_t; 
+
+
+struct video_event { 
+        int32_t type; 
+        time_t timestamp;
+	union { 
+	        video_format_t video_format;
+	} u; 
+};
+
+
+struct video_status { 
+        int                   video_blank;   /* blank video on freeze? */
+        video_play_state_t    play_state;    /* current state of playback */  
+        video_stream_source_t stream_source; /* current source (demux/memory) */
+        video_format_t        video_format;  /* current aspect ratio of stream*/
+        video_displayformat_t display_format;/* selected cropping mode */
+};
+
+
+struct video_still_picture {
+        char *iFrame;        /* pointer to a single iframe in memory */
+        int32_t size; 
+};
+
+
+typedef 
+struct video_highlight {
+	int     active;      /*    1=show highlight, 0=hide highlight */
+	uint8_t contrast1;   /*    7- 4  Pattern pixel contrast */
+                             /*    3- 0  Background pixel contrast */
+	uint8_t contrast2;   /*    7- 4  Emphasis pixel-2 contrast */
+                             /*    3- 0  Emphasis pixel-1 contrast */
+	uint8_t color1;      /*    7- 4  Pattern pixel color */
+                             /*    3- 0  Background pixel color */
+	uint8_t color2;      /*    7- 4  Emphasis pixel-2 color */
+                             /*    3- 0  Emphasis pixel-1 color */
+ 	uint32_t ypos;       /*   23-22  auto action mode */
+                             /*   21-12  start y */
+                             /*    9- 0  end y */
+	uint32_t xpos;       /*   23-22  button color number */
+                             /*   21-12  start x */
+                             /*    9- 0  end x */
+} video_highlight_t;
+
+
+typedef struct video_spu {
+	int active;
+	int stream_id;
+} video_spu_t;
+
+
+typedef struct video_spu_palette {      /* SPU Palette information */
+	int length;
+	uint8_t *palette;
+} video_spu_palette_t;
+
+
+typedef struct video_navi_pack {
+	int length;          /* 0 ... 1024 */
+	uint8_t data[1024];
+} video_navi_pack_t;
+
+
+typedef uint16_t video_attributes_t;
+/*   bits: descr. */
+/*   15-14 Video compression mode (0=MPEG-1, 1=MPEG-2) */
+/*   13-12 TV system (0=525/60, 1=625/50) */
+/*   11-10 Aspect ratio (0=4:3, 3=16:9) */
+/*    9- 8 permitted display mode on 4:3 monitor (0=both, 1=only pan-sca */
+/*    7    line 21-1 data present in GOP (1=yes, 0=no) */
+/*    6    line 21-2 data present in GOP (1=yes, 0=no) */
+/*    5- 3 source resolution (0=720x480/576, 1=704x480/576, 2=352x480/57 */
+/*    2    source letterboxed (1=yes, 0=no) */
+/*    0    film/camera mode (0=camera, 1=film (625/50 only)) */
+
+
+/* bit definitions for capabilities: */
+/* can the hardware decode MPEG1 and/or MPEG2? */
+#define VIDEO_CAP_MPEG1   1 
+#define VIDEO_CAP_MPEG2   2
+/* can you send a system and/or program stream to video device?
+   (you still have to open the video and the audio device but only 
+    send the stream to the video device) */
+#define VIDEO_CAP_SYS     4
+#define VIDEO_CAP_PROG    8
+/* can the driver also handle SPU, NAVI and CSS encoded data? 
+   (CSS API is not present yet) */
+#define VIDEO_CAP_SPU    16
+#define VIDEO_CAP_NAVI   32
+#define VIDEO_CAP_CSS    64
+
+
+#define VIDEO_STOP                 _IO('o', 21) 
+#define VIDEO_PLAY                 _IO('o', 22)
+#define VIDEO_FREEZE               _IO('o', 23)
+#define VIDEO_CONTINUE             _IO('o', 24)
+#define VIDEO_SELECT_SOURCE        _IO('o', 25)
+#define VIDEO_SET_BLANK            _IO('o', 26)
+#define VIDEO_GET_STATUS           _IOR('o', 27, struct video_status)
+#define VIDEO_GET_EVENT            _IOR('o', 28, struct video_event)
+#define VIDEO_SET_DISPLAY_FORMAT   _IO('o', 29)
+#define VIDEO_STILLPICTURE         _IOW('o', 30, struct video_still_picture)
+#define VIDEO_FAST_FORWARD         _IO('o', 31)
+#define VIDEO_SLOWMOTION           _IO('o', 32)
+#define VIDEO_GET_CAPABILITIES     _IOR('o', 33, unsigned int)
+#define VIDEO_CLEAR_BUFFER         _IO('o',  34)
+#define VIDEO_SET_ID               _IO('o', 35)
+#define VIDEO_SET_STREAMTYPE       _IO('o', 36)
+#define VIDEO_SET_FORMAT           _IO('o', 37)
+#define VIDEO_SET_SYSTEM           _IO('o', 38)
+#define VIDEO_SET_HIGHLIGHT        _IOW('o', 39, video_highlight_t)
+#define VIDEO_SET_SPU              _IOW('o', 50, video_spu_t)
+#define VIDEO_SET_SPU_PALETTE      _IOW('o', 51, video_spu_palette_t)
+#define VIDEO_GET_NAVI             _IOR('o', 52, video_navi_pack_t)
+#define VIDEO_SET_ATTRIBUTES       _IO('o', 53)
+
+#endif /*_DVBVIDEO_H_*/
+
