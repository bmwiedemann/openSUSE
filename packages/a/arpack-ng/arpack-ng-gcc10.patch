From 9418632214acf6d387896ab29a8f5bdff2d4e38a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?David=20Schw=C3=B6rer?= <davidsch@fedoraproject.org>
Date: Wed, 19 Feb 2020 20:07:47 +0000
Subject: [PATCH 1/3] ?vout expects a vector, so make sure to pass a vector

gcc10 throws an error otherwise
---
 SRC/cgetv0.f |  6 +++---
 SRC/cnaitr.f |  8 ++++----
 SRC/cnapps.f | 14 +++++++-------
 SRC/cnaup2.f | 14 +++++++-------
 SRC/cnaupd.f |  4 ++--
 SRC/cneupd.f |  4 ++--
 SRC/cngets.f |  4 ++--
 SRC/dgetv0.f |  6 +++---
 SRC/dnaitr.f |  8 ++++----
 SRC/dnapps.f | 16 ++++++++--------
 SRC/dnaup2.f | 14 +++++++-------
 SRC/dnaupd.f |  4 ++--
 SRC/dneupd.f |  4 ++--
 SRC/dngets.f |  4 ++--
 SRC/dsaitr.f |  8 ++++----
 SRC/dsapps.f |  6 +++---
 SRC/dsaup2.f | 14 +++++++-------
 SRC/dsaupd.f |  4 ++--
 SRC/dseupd.f |  4 ++--
 SRC/dsgets.f |  4 ++--
 SRC/sgetv0.f |  6 +++---
 SRC/snaitr.f |  8 ++++----
 SRC/snapps.f | 16 ++++++++--------
 SRC/snaup2.f | 14 +++++++-------
 SRC/snaupd.f |  4 ++--
 SRC/sneupd.f |  4 ++--
 SRC/sngets.f |  4 ++--
 SRC/ssaitr.f |  8 ++++----
 SRC/ssapps.f |  6 +++---
 SRC/ssaup2.f | 14 +++++++-------
 SRC/ssaupd.f |  4 ++--
 SRC/sseupd.f |  4 ++--
 SRC/ssgets.f |  4 ++--
 SRC/zgetv0.f |  6 +++---
 SRC/znaitr.f |  8 ++++----
 SRC/znapps.f | 14 +++++++-------
 SRC/znaup2.f | 14 +++++++-------
 SRC/znaupd.f |  4 ++--
 SRC/zneupd.f |  4 ++--
 SRC/zngets.f |  4 ++--
 40 files changed, 150 insertions(+), 150 deletions(-)

Index: arpack-ng-3.7.0/SRC/cgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/cgetv0.f
+++ arpack-ng-3.7.0/SRC/cgetv0.f
@@ -361,9 +361,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call svout (logfil, 1, rnorm0, ndigit,
+          call svout (logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call svout (logfil, 1, rnorm, ndigit,
+          call svout (logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -394,7 +394,7 @@ c
    50 continue
 c
       if (msglvl .gt. 0) then
-         call svout (logfil, 1, rnorm, ndigit,
+         call svout (logfil, 1, [rnorm], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 2) then
Index: arpack-ng-3.7.0/SRC/cnaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/cnaitr.f
+++ arpack-ng-3.7.0/SRC/cnaitr.f
@@ -378,9 +378,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call svout (logfil, 1, rnorm, ndigit,
+            call svout (logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -400,7 +400,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
+               call ivout (logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -729,7 +729,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 rtemp(1) = rnorm
Index: arpack-ng-3.7.0/SRC/cnapps.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/cnapps.f
+++ arpack-ng-3.7.0/SRC/cnapps.f
@@ -268,9 +268,9 @@ c
          sigma = shift(jj)
 c
          if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit,
+            call ivout (logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call cvout (logfil, 1, sigma, ndigit,
+            call cvout (logfil, 1, [sigma], ndigit,
      &               '_napps: Value of the shift ')
          end if
 c
@@ -291,9 +291,9 @@ c
             if ( abs(real(h(i+1,i)))
      &           .le. max(ulp*tst1, smlnum) )  then
                if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit,
+                  call ivout (logfil, 1, [i], ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit,
+                  call ivout (logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call cvout (logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -307,9 +307,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit,
+             call ivout (logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit,
+             call ivout (logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -485,7 +485,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call cvout (logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit,
+         call ivout (logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call cmout (logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/SRC/cnaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/cnaup2.f
+++ arpack-ng-3.7.0/SRC/cnaup2.f
@@ -389,7 +389,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
+            call ivout (logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -402,9 +402,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
+            call ivout (logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -430,7 +430,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call svout (logfil, 1, rnorm, ndigit,
+            call svout (logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -658,7 +658,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
+            call ivout (logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -698,7 +698,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call cvout (logfil, np, ritz, ndigit,
      &                  '_naup2: values of the shifts')
@@ -762,7 +762,7 @@ c
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call svout (logfil, 1, rnorm, ndigit,
+            call svout (logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call cmout (logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/SRC/cnaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/cnaupd.f
+++ arpack-ng-3.7.0/SRC/cnaupd.f
@@ -601,9 +601,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
+         call ivout (logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
+         call ivout (logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call cvout (logfil, np, workl(ritz), ndigit,
      &               '_naupd: The final Ritz values')
Index: arpack-ng-3.7.0/SRC/cneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/cneupd.f
+++ arpack-ng-3.7.0/SRC/cneupd.f
@@ -536,9 +536,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
+             call ivout(logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
+             call ivout(logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/SRC/cngets.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/cngets.f
+++ arpack-ng-3.7.0/SRC/cngets.f
@@ -161,8 +161,8 @@ c
       tcgets = tcgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
+         call ivout (logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call ivout (logfil, 1, [np], ndigit, '_ngets: NP is')
          call cvout (logfil, kev+np, ritz, ndigit,
      &        '_ngets: Eigenvalues of current H matrix ')
          call cvout (logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/SRC/dgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dgetv0.f
+++ arpack-ng-3.7.0/SRC/dgetv0.f
@@ -366,9 +366,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call dvout (logfil, 1, rnorm0, ndigit,
+          call dvout (logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call dvout (logfil, 1, rnorm, ndigit,
+          call dvout (logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -399,7 +399,7 @@ c
    50 continue
 c
       if (msglvl .gt. 0) then
-         call dvout (logfil, 1, rnorm, ndigit,
+         call dvout (logfil, 1, [rnorm], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 3) then
Index: arpack-ng-3.7.0/SRC/dnaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dnaitr.f
+++ arpack-ng-3.7.0/SRC/dnaitr.f
@@ -371,9 +371,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call dvout (logfil, 1, rnorm, ndigit,
+            call dvout (logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -393,7 +393,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
+               call ivout (logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -721,7 +721,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/SRC/dnapps.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dnapps.f
+++ arpack-ng-3.7.0/SRC/dnapps.f
@@ -266,11 +266,11 @@ c
          sigmai = shifti(jj)
 c
          if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit,
+            call ivout (logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call dvout (logfil, 1, sigmar, ndigit,
+            call dvout (logfil, 1, [sigmar], ndigit,
      &               '_napps: The real part of the shift ')
-            call dvout (logfil, 1, sigmai, ndigit,
+            call dvout (logfil, 1, [sigmai], ndigit,
      &               '_napps: The imaginary part of the shift ')
          end if
 c
@@ -335,9 +335,9 @@ c
      &         tst1 = dlanhs( '1', kplusp-jj+1, h, ldh, workl )
             if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) then
                if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit,
+                  call ivout (logfil, 1, [i], ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit,
+                  call ivout (logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call dvout (logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -351,9 +351,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit,
+             call ivout (logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit,
+             call ivout (logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -627,7 +627,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call dvout (logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit,
+         call ivout (logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call dmout (logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/SRC/dnaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dnaup2.f
+++ arpack-ng-3.7.0/SRC/dnaup2.f
@@ -388,7 +388,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
+            call ivout (logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -401,9 +401,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
+            call ivout (logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -435,7 +435,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call dvout  (logfil, 1, rnorm, ndigit,
+            call dvout  (logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -689,7 +689,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
+            call ivout (logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -741,7 +741,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call dvout  (logfil, np, ritzr, ndigit,
      &                  '_naup2: Real part of the shifts')
@@ -807,7 +807,7 @@ c
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call dvout  (logfil, 1, rnorm, ndigit,
+            call dvout  (logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call dmout  (logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/SRC/dnaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dnaupd.f
+++ arpack-ng-3.7.0/SRC/dnaupd.f
@@ -628,9 +628,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
+         call ivout (logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
+         call ivout (logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call dvout  (logfil, np, workl(ritzr), ndigit,
      &               '_naupd: Real part of the final Ritz values')
Index: arpack-ng-3.7.0/SRC/dneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dneupd.f
+++ arpack-ng-3.7.0/SRC/dneupd.f
@@ -601,9 +601,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
+             call ivout(logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
+             call ivout(logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/SRC/dngets.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dngets.f
+++ arpack-ng-3.7.0/SRC/dngets.f
@@ -212,8 +212,8 @@ c
       tngets = tngets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
+         call ivout (logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call ivout (logfil, 1, [np], ndigit, '_ngets: NP is')
          call dvout (logfil, kev+np, ritzr, ndigit,
      &        '_ngets: Eigenvalues of current H matrix -- real part')
          call dvout (logfil, kev+np, ritzi, ndigit,
Index: arpack-ng-3.7.0/SRC/dsaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dsaitr.f
+++ arpack-ng-3.7.0/SRC/dsaitr.f
@@ -364,9 +364,9 @@ c
  1000 continue
 c
          if (msglvl .gt. 2) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &                  '_saitr: generating Arnoldi vector no.')
-            call dvout (logfil, 1, rnorm, ndigit,
+            call dvout (logfil, 1, [rnorm], ndigit,
      &                  '_saitr: B-norm of the current residual =')
          end if
 c
@@ -384,7 +384,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
+               call ivout (logfil, 1, [j], ndigit,
      &                     '_saitr: ****** restart at step ******')
             end if
 c
@@ -735,7 +735,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &           '_saitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/SRC/dsapps.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dsapps.f
+++ arpack-ng-3.7.0/SRC/dsapps.f
@@ -261,9 +261,9 @@ c
             big   = abs(h(i,2)) + abs(h(i+1,2))
             if (h(i+1,1) .le. epsmch*big) then
                if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit,
+                  call ivout (logfil, 1, [i], ndigit,
      &                 '_sapps: deflation at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit,
+                  call ivout (logfil, 1, [jj], ndigit,
      &                 '_sapps: occurred before shift number.')
                   call dvout (logfil, 1, h(i+1,1), ndigit,
      &                 '_sapps: the corresponding off diagonal element')
@@ -432,7 +432,7 @@ c
          big   = abs(h(i,2)) + abs(h(i+1,2))
          if (h(i+1,1) .le. epsmch*big) then
             if (msglvl .gt. 0) then
-               call ivout (logfil, 1, i, ndigit,
+               call ivout (logfil, 1, [i], ndigit,
      &              '_sapps: deflation at row/column no.')
                call dvout (logfil, 1, h(i+1,1), ndigit,
      &              '_sapps: the corresponding off diagonal element')
Index: arpack-ng-3.7.0/SRC/dsaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dsaup2.f
+++ arpack-ng-3.7.0/SRC/dsaup2.f
@@ -402,13 +402,13 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
+            call ivout (logfil, 1, [iter], ndigit,
      &           '_saup2: **** Start of major iteration number ****')
          end if
          if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
+            call ivout (logfil, 1, [nev], ndigit,
      &     '_saup2: The length of the current Lanczos factorization')
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &           '_saup2: Extend the Lanczos factorization by')
          end if
 c
@@ -446,7 +446,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call dvout (logfil, 1, rnorm, ndigit,
+            call dvout (logfil, 1, [rnorm], ndigit,
      &           '_saup2: Current B-norm of residual for factorization')
          end if
 c
@@ -695,7 +695,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
+            call ivout (logfil, 1, [nconv], ndigit,
      &           '_saup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -743,7 +743,7 @@ c
          if (ishift .eq. 0) call dcopy (np, workl, 1, ritz, 1)
 c
          if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &                  '_saup2: The number of shifts to apply ')
             call dvout (logfil, np, workl, ndigit,
      &                  '_saup2: shifts selected')
@@ -810,7 +810,7 @@ c
   130    continue
 c
          if (msglvl .gt. 2) then
-            call dvout (logfil, 1, rnorm, ndigit,
+            call dvout (logfil, 1, [rnorm], ndigit,
      &      '_saup2: B-norm of residual for NEV factorization')
             call dvout (logfil, nev, h(1,2), ndigit,
      &           '_saup2: main diagonal of compressed H matrix')
Index: arpack-ng-3.7.0/SRC/dsaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dsaupd.f
+++ arpack-ng-3.7.0/SRC/dsaupd.f
@@ -628,9 +628,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
+         call ivout (logfil, 1, [mxiter], ndigit,
      &               '_saupd: number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
+         call ivout (logfil, 1, [np], ndigit,
      &               '_saupd: number of "converged" Ritz values')
          call dvout  (logfil, np, workl(Ritz), ndigit,
      &               '_saupd: final Ritz values')
Index: arpack-ng-3.7.0/SRC/dseupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dseupd.f
+++ arpack-ng-3.7.0/SRC/dseupd.f
@@ -513,9 +513,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
+             call ivout(logfil, 1, [numcnv], ndigit,
      &            '_seupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
+             call ivout(logfil, 1, [nconv], ndigit,
      &            '_seupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/SRC/dsgets.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/dsgets.f
+++ arpack-ng-3.7.0/SRC/dsgets.f
@@ -202,8 +202,8 @@ c
       tsgets = tsgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_sgets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_sgets: NP is')
+         call ivout (logfil, 1, [kev], ndigit, '_sgets: KEV is')
+         call ivout (logfil, 1, [np], ndigit, '_sgets: NP is')
          call dvout (logfil, kev+np, ritz, ndigit,
      &        '_sgets: Eigenvalues of current H matrix')
          call dvout (logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/SRC/sgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/sgetv0.f
+++ arpack-ng-3.7.0/SRC/sgetv0.f
@@ -366,9 +366,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call svout (logfil, 1, rnorm0, ndigit,
+          call svout (logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call svout (logfil, 1, rnorm, ndigit,
+          call svout (logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -399,7 +399,7 @@ c
    50 continue
 c
       if (msglvl .gt. 0) then
-         call svout (logfil, 1, rnorm, ndigit,
+         call svout (logfil, 1, [rnorm], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 3) then
Index: arpack-ng-3.7.0/SRC/snaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/snaitr.f
+++ arpack-ng-3.7.0/SRC/snaitr.f
@@ -371,9 +371,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call svout (logfil, 1, rnorm, ndigit,
+            call svout (logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -393,7 +393,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
+               call ivout (logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -721,7 +721,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/SRC/snapps.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/snapps.f
+++ arpack-ng-3.7.0/SRC/snapps.f
@@ -266,11 +266,11 @@ c
          sigmai = shifti(jj)
 c
          if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit,
+            call ivout (logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call svout (logfil, 1, sigmar, ndigit,
+            call svout (logfil, 1, [sigmar], ndigit,
      &               '_napps: The real part of the shift ')
-            call svout (logfil, 1, sigmai, ndigit,
+            call svout (logfil, 1, [sigmai], ndigit,
      &               '_napps: The imaginary part of the shift ')
          end if
 c
@@ -335,9 +335,9 @@ c
      &         tst1 = slanhs( '1', kplusp-jj+1, h, ldh, workl )
             if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) then
                if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit,
+                  call ivout (logfil, 1, [i], ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit,
+                  call ivout (logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call svout (logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -351,9 +351,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit,
+             call ivout (logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit,
+             call ivout (logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -625,7 +625,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call svout (logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit,
+         call ivout (logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call smout (logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/SRC/snaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/snaup2.f
+++ arpack-ng-3.7.0/SRC/snaup2.f
@@ -388,7 +388,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
+            call ivout (logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -401,9 +401,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
+            call ivout (logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -435,7 +435,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call svout (logfil, 1, rnorm, ndigit,
+            call svout (logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -690,7 +690,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
+            call ivout (logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -742,7 +742,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call svout (logfil, np, ritzr, ndigit,
      &                  '_naup2: Real part of the shifts')
@@ -808,7 +808,7 @@ c
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call svout (logfil, 1, rnorm, ndigit,
+            call svout (logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call smout (logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/SRC/snaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/snaupd.f
+++ arpack-ng-3.7.0/SRC/snaupd.f
@@ -628,9 +628,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
+         call ivout (logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
+         call ivout (logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call svout (logfil, np, workl(ritzr), ndigit,
      &               '_naupd: Real part of the final Ritz values')
Index: arpack-ng-3.7.0/SRC/sneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/sneupd.f
+++ arpack-ng-3.7.0/SRC/sneupd.f
@@ -601,9 +601,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
+             call ivout(logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
+             call ivout(logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/SRC/sngets.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/sngets.f
+++ arpack-ng-3.7.0/SRC/sngets.f
@@ -212,8 +212,8 @@ c
       tngets = tngets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
+         call ivout (logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call ivout (logfil, 1, [np], ndigit, '_ngets: NP is')
          call svout (logfil, kev+np, ritzr, ndigit,
      &        '_ngets: Eigenvalues of current H matrix -- real part')
          call svout (logfil, kev+np, ritzi, ndigit,
Index: arpack-ng-3.7.0/SRC/ssaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/ssaitr.f
+++ arpack-ng-3.7.0/SRC/ssaitr.f
@@ -364,9 +364,9 @@ c
  1000 continue
 c
          if (msglvl .gt. 2) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &                  '_saitr: generating Arnoldi vector no.')
-            call svout (logfil, 1, rnorm, ndigit,
+            call svout (logfil, 1, [rnorm], ndigit,
      &                  '_saitr: B-norm of the current residual =')
          end if
 c
@@ -384,7 +384,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
+               call ivout (logfil, 1, [j], ndigit,
      &                     '_saitr: ****** restart at step ******')
             end if
 c
@@ -735,7 +735,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &           '_saitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/SRC/ssapps.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/ssapps.f
+++ arpack-ng-3.7.0/SRC/ssapps.f
@@ -261,9 +261,9 @@ c
             big   = abs(h(i,2)) + abs(h(i+1,2))
             if (h(i+1,1) .le. epsmch*big) then
                if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit,
+                  call ivout (logfil, 1, [i], ndigit,
      &                 '_sapps: deflation at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit,
+                  call ivout (logfil, 1, [jj], ndigit,
      &                 '_sapps: occurred before shift number.')
                   call svout (logfil, 1, h(i+1,1), ndigit,
      &                 '_sapps: the corresponding off diagonal element')
@@ -432,7 +432,7 @@ c
          big   = abs(h(i,2)) + abs(h(i+1,2))
          if (h(i+1,1) .le. epsmch*big) then
             if (msglvl .gt. 0) then
-               call ivout (logfil, 1, i, ndigit,
+               call ivout (logfil, 1, [i], ndigit,
      &              '_sapps: deflation at row/column no.')
                call svout (logfil, 1, h(i+1,1), ndigit,
      &              '_sapps: the corresponding off diagonal element')
Index: arpack-ng-3.7.0/SRC/ssaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/ssaup2.f
+++ arpack-ng-3.7.0/SRC/ssaup2.f
@@ -402,13 +402,13 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
+            call ivout (logfil, 1, [iter], ndigit,
      &           '_saup2: **** Start of major iteration number ****')
          end if
          if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
+            call ivout (logfil, 1, [nev], ndigit,
      &     '_saup2: The length of the current Lanczos factorization')
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &           '_saup2: Extend the Lanczos factorization by')
          end if
 c
@@ -446,7 +446,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call svout (logfil, 1, rnorm, ndigit,
+            call svout (logfil, 1, [rnorm], ndigit,
      &           '_saup2: Current B-norm of residual for factorization')
          end if
 c
@@ -694,7 +694,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
+            call ivout (logfil, 1, [nconv], ndigit,
      &           '_saup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -742,7 +742,7 @@ c
          if (ishift .eq. 0) call scopy (np, workl, 1, ritz, 1)
 c
          if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &                  '_saup2: The number of shifts to apply ')
             call svout (logfil, np, workl, ndigit,
      &                  '_saup2: shifts selected')
@@ -809,7 +809,7 @@ c
   130    continue
 c
          if (msglvl .gt. 2) then
-            call svout (logfil, 1, rnorm, ndigit,
+            call svout (logfil, 1, [rnorm], ndigit,
      &      '_saup2: B-norm of residual for NEV factorization')
             call svout (logfil, nev, h(1,2), ndigit,
      &           '_saup2: main diagonal of compressed H matrix')
Index: arpack-ng-3.7.0/SRC/ssaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/ssaupd.f
+++ arpack-ng-3.7.0/SRC/ssaupd.f
@@ -628,9 +628,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
+         call ivout (logfil, 1, [mxiter], ndigit,
      &               '_saupd: number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
+         call ivout (logfil, 1, [np], ndigit,
      &               '_saupd: number of "converged" Ritz values')
          call svout (logfil, np, workl(Ritz), ndigit,
      &               '_saupd: final Ritz values')
Index: arpack-ng-3.7.0/SRC/sseupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/sseupd.f
+++ arpack-ng-3.7.0/SRC/sseupd.f
@@ -513,9 +513,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
+             call ivout(logfil, 1, [numcnv], ndigit,
      &            '_seupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
+             call ivout(logfil, 1, [nconv], ndigit,
      &            '_seupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/SRC/ssgets.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/ssgets.f
+++ arpack-ng-3.7.0/SRC/ssgets.f
@@ -202,8 +202,8 @@ c
       tsgets = tsgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_sgets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_sgets: NP is')
+         call ivout (logfil, 1, [kev], ndigit, '_sgets: KEV is')
+         call ivout (logfil, 1, [np], ndigit, '_sgets: NP is')
          call svout (logfil, kev+np, ritz, ndigit,
      &        '_sgets: Eigenvalues of current H matrix')
          call svout (logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/SRC/zgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/zgetv0.f
+++ arpack-ng-3.7.0/SRC/zgetv0.f
@@ -361,9 +361,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call dvout (logfil, 1, rnorm0, ndigit,
+          call dvout (logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call dvout (logfil, 1, rnorm, ndigit,
+          call dvout (logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -394,7 +394,7 @@ c
    50 continue
 c
       if (msglvl .gt. 0) then
-         call dvout (logfil, 1, rnorm, ndigit,
+         call dvout (logfil, 1, [rnorm], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 2) then
Index: arpack-ng-3.7.0/SRC/znaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/znaitr.f
+++ arpack-ng-3.7.0/SRC/znaitr.f
@@ -378,9 +378,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call dvout (logfil, 1, rnorm, ndigit,
+            call dvout (logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -400,7 +400,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
+               call ivout (logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -729,7 +729,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call ivout (logfil, 1, j, ndigit,
+            call ivout (logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 rtemp(1) = rnorm
Index: arpack-ng-3.7.0/SRC/znapps.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/znapps.f
+++ arpack-ng-3.7.0/SRC/znapps.f
@@ -268,9 +268,9 @@ c
          sigma = shift(jj)
 c
          if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit,
+            call ivout (logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call zvout (logfil, 1, sigma, ndigit,
+            call zvout (logfil, 1, [sigma], ndigit,
      &               '_napps: Value of the shift ')
          end if
 c
@@ -291,9 +291,9 @@ c
             if ( abs(dble(h(i+1,i)))
      &           .le. max(ulp*tst1, smlnum) )  then
                if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit,
+                  call ivout (logfil, 1, [i], ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit,
+                  call ivout (logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call zvout (logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -307,9 +307,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit,
+             call ivout (logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit,
+             call ivout (logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -485,7 +485,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call zvout (logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit,
+         call ivout (logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call zmout (logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/SRC/znaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/znaup2.f
+++ arpack-ng-3.7.0/SRC/znaup2.f
@@ -389,7 +389,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
+            call ivout (logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -402,9 +402,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
+            call ivout (logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -430,7 +430,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call dvout  (logfil, 1, rnorm, ndigit,
+            call dvout  (logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -658,7 +658,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
+            call ivout (logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -698,7 +698,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
+            call ivout (logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call zvout  (logfil, np, ritz, ndigit,
      &                  '_naup2: values of the shifts')
@@ -762,7 +762,7 @@ c
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call dvout  (logfil, 1, rnorm, ndigit,
+            call dvout  (logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call zmout  (logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/SRC/znaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/znaupd.f
+++ arpack-ng-3.7.0/SRC/znaupd.f
@@ -601,9 +601,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
+         call ivout (logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
+         call ivout (logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call zvout  (logfil, np, workl(ritz), ndigit,
      &               '_naupd: The final Ritz values')
Index: arpack-ng-3.7.0/SRC/zneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/zneupd.f
+++ arpack-ng-3.7.0/SRC/zneupd.f
@@ -536,9 +536,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
+             call ivout(logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
+             call ivout(logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/SRC/zngets.f
===================================================================
--- arpack-ng-3.7.0.orig/SRC/zngets.f
+++ arpack-ng-3.7.0/SRC/zngets.f
@@ -161,8 +161,8 @@ c
       tcgets = tcgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
+         call ivout (logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call ivout (logfil, 1, [np], ndigit, '_ngets: NP is')
          call zvout (logfil, kev+np, ritz, ndigit,
      &        '_ngets: Eigenvalues of current H matrix ')
          call zvout (logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/.gitignore
===================================================================
--- arpack-ng-3.7.0.orig/.gitignore
+++ arpack-ng-3.7.0/.gitignore
@@ -71,3 +71,7 @@ PARPACK/TESTS/MPI/issue46
 *.suo
 VISUAL_STUDIO/Release MKL/
 VISUAL_STUDIO/bin/
+
+# Temporary files
+*~
+\#*#
\ No newline at end of file
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pcgetv0.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcgetv0.f
@@ -406,9 +406,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call psvout (comm, logfil, 1, rnorm0, ndigit,
+          call psvout (comm, logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call psvout (comm, logfil, 1, rnorm, ndigit,
+          call psvout (comm, logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcnaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pcnaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcnaitr.f
@@ -401,9 +401,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call pcvout (comm, logfil, 1, rnorm, ndigit,
+            call pcvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -423,7 +423,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -757,7 +757,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 rtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcnapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pcnapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcnapps.f
@@ -284,9 +284,9 @@ c
          sigma = shift(jj)
 c
          if (msglvl .gt. 2 ) then
-            call pivout (comm, logfil, 1, jj, ndigit,
+            call pivout (comm, logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call pcvout (comm, logfil, 1, sigma, ndigit,
+            call pcvout (comm, logfil, 1, [sigma], ndigit,
      &               '_napps: Value of the shift ')
          end if
 c
@@ -307,9 +307,9 @@ c
             if ( abs(real(h(i+1,i)))
      &           .le. max(ulp*tst1, smlnum) )  then
                if (msglvl .gt. 0) then
-                  call pivout (comm, logfil, 1, i, ndigit,
+                  call pivout (comm, logfil, 1, [i], ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call pcvout (comm, logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -323,9 +323,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call pivout (comm, logfil, 1, istart, ndigit,
+             call pivout (comm, logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call pivout (comm, logfil, 1, iend, ndigit,
+             call pivout (comm, logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -501,7 +501,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call pcvout (comm, logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call pivout (comm, logfil, 1, kev, ndigit,
+         call pivout (comm, logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call pcmout (comm, logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcnaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pcnaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcnaup2.f
@@ -398,7 +398,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -411,9 +411,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -440,7 +440,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -671,7 +671,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -711,7 +711,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call pcvout (comm, logfil, np, ritz, ndigit,
      &                  '_naup2: values of the shifts')
@@ -776,7 +776,7 @@ c
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call pcmout (comm, logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcnaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pcnaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcnaupd.f
@@ -618,9 +618,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call pcvout (comm, logfil, np, workl(ritz), ndigit,
      &               '_naupd: The final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pcneupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcneupd.f
@@ -558,9 +558,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcngets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pcngets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pcngets.f
@@ -177,8 +177,8 @@ c
       tcgets = tcgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_ngets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_ngets: NP is')
          call pcvout (comm, logfil, kev+np, ritz, ndigit,
      &        '_ngets: Eigenvalues of current H matrix ')
          call pcvout (comm, logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdgetv0.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdgetv0.f
@@ -385,9 +385,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call pdvout (comm, logfil, 1, rnorm0, ndigit,
+          call pdvout (comm, logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call pdvout (comm, logfil, 1, rnorm, ndigit,
+          call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -418,7 +418,7 @@ c
    50 continue
 c
       if (msglvl .gt. 0) then
-         call pdvout (comm, logfil, 1, rnorm, ndigit,
+         call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 2) then
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdnaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdnaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdnaitr.f
@@ -390,9 +390,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -412,7 +412,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -745,7 +745,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdnapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdnapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdnapps.f
@@ -276,11 +276,11 @@ c
          sigmai = shifti(jj)
 c
          if (msglvl .gt. 2 ) then
-            call pivout (comm, logfil, 1, jj, ndigit,
+            call pivout (comm, logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call pdvout (comm, logfil, 1, sigmar, ndigit,
+            call pdvout (comm, logfil, 1, [sigmar], ndigit,
      &               '_napps: The real part of the shift ')
-            call pdvout (comm, logfil, 1, sigmai, ndigit,
+            call pdvout (comm, logfil, 1, [sigmai], ndigit,
      &               '_napps: The imaginary part of the shift ')
          end if
 c
@@ -347,7 +347,7 @@ c
                if (msglvl .gt. 0) then
                   call pivout (comm, logfil, 1, i, ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call pdvout (comm, logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -361,9 +361,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call pivout (comm, logfil, 1, istart, ndigit,
+             call pivout (comm, logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call pivout (comm, logfil, 1, iend, ndigit,
+             call pivout (comm, logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -635,7 +635,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call pdvout (comm, logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call pivout (comm, logfil, 1, kev, ndigit,
+         call pivout (comm, logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call pdmout (comm, logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdnaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdnaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdnaup2.f
@@ -405,7 +405,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -418,9 +418,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -452,7 +452,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call pdvout  (comm, logfil, 1, rnorm, ndigit,
+            call pdvout  (comm, logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -696,7 +696,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -748,7 +748,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call pdvout  (comm, logfil, np, ritzr, ndigit,
      &                  '_naup2: Real part of the shifts')
@@ -815,7 +815,7 @@ c
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call pdvout  (comm, logfil, 1, rnorm, ndigit,
+            call pdvout  (comm, logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call pdmout  (comm, logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdnaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdnaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdnaupd.f
@@ -642,9 +642,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call pdvout  (comm, logfil, np, workl(ritzr), ndigit,
      &               '_naupd: Real part of the final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdneupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdneupd.f
@@ -617,9 +617,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdngets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdngets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdngets.f
@@ -226,8 +226,8 @@ c
       tngets = tngets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_ngets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_ngets: NP is')
          call pdvout (comm, logfil, kev+np, ritzr, ndigit,
      &        '_ngets: Eigenvalues of current H matrix -- real part')
          call pdvout (comm, logfil, kev+np, ritzi, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdsaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdsaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdsaitr.f
@@ -389,9 +389,9 @@ c
  1000 continue
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_saitr: generating Arnoldi vector no.')
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_saitr: B-norm of the current residual =')
          end if
 c
@@ -409,7 +409,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_saitr: ****** restart at step ******')
             end if
 c
@@ -767,7 +767,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdsapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdsapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdsapps.f
@@ -272,9 +272,9 @@ c
             big   = abs(h(i,2)) + abs(h(i+1,2))
             if (h(i+1,1) .le. epsmch*big) then
                if (msglvl .gt. 0) then
-                  call pivout (comm, logfil, 1, i, ndigit,
+                  call pivout (comm, logfil, 1, [i], ndigit,
      &                 '_sapps: deflation at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_sapps: occurred before shift number.')
                   call pdvout (comm, logfil, 1, h(i+1,1), ndigit,
      &                 '_sapps: the corresponding off diagonal element')
@@ -443,7 +443,7 @@ c
          big   = abs(h(i,2)) + abs(h(i+1,2))
          if (h(i+1,1) .le. epsmch*big) then
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, i, ndigit,
+               call pivout (comm, logfil, 1, [i], ndigit,
      &              '_sapps: deflation at row/column no.')
                call pdvout (comm, logfil, 1, h(i+1,1), ndigit,
      &              '_sapps: the corresponding off diagonal element')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdsaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdsaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdsaup2.f
@@ -421,13 +421,13 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_saup2: **** Start of major iteration number ****')
          end if
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_saup2: The length of the current Lanczos factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_saup2: Extend the Lanczos factorization by')
          end if
 c
@@ -466,7 +466,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &           '_saup2: Current B-norm of residual for factorization')
          end if
 c
@@ -716,7 +716,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_saup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -763,7 +763,7 @@ c
          if (ishift .eq. 0) call dcopy (np, workl, 1, ritz, 1)
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_saup2: The number of shifts to apply ')
             call pdvout (comm, logfil, np, workl, ndigit,
      &                  '_saup2: shifts selected')
@@ -831,7 +831,7 @@ c
   130    continue
 c
          if (msglvl .gt. 2) then
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &      '_saup2: B-norm of residual for NEV factorization')
             call pdvout (comm, logfil, nev, h(1,2), ndigit,
      &           '_saup2: main diagonal of compressed H matrix')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdsaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdsaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdsaupd.f
@@ -644,9 +644,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_saupd: number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_saupd: number of "converged" Ritz values')
          call pdvout  (comm, logfil, np, workl(Ritz), ndigit,
      &               '_saupd: final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdseupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdseupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdseupd.f
@@ -523,9 +523,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdsgets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pdsgets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pdsgets.f
@@ -216,8 +216,8 @@ c
       tsgets = tsgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_sgets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_sgets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_sgets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_sgets: NP is')
          call pdvout (comm, logfil, kev+np, ritz, ndigit,
      &        '_sgets: Eigenvalues of current H matrix')
          call pdvout (comm, logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/psgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/psgetv0.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/psgetv0.f
@@ -385,9 +385,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call psvout (comm, logfil, 1, rnorm0, ndigit,
+          call psvout (comm, logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call psvout (comm, logfil, 1, rnorm, ndigit,
+          call psvout (comm, logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -418,7 +418,7 @@ c
    50 continue
 c
       if (msglvl .gt. 0) then
-         call psvout (comm, logfil, 1, rnorm, ndigit,
+         call psvout (comm, logfil, 1, [rnorm], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 2) then
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/psnaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/psnaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/psnaitr.f
@@ -390,9 +390,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -412,7 +412,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -745,7 +745,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/psnapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/psnapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/psnapps.f
@@ -276,11 +276,11 @@ c
          sigmai = shifti(jj)
 c
          if (msglvl .gt. 2 ) then
-            call pivout (comm, logfil, 1, jj, ndigit,
+            call pivout (comm, logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call psvout (comm, logfil, 1, sigmar, ndigit,
+            call psvout (comm, logfil, 1, [sigmar], ndigit,
      &               '_napps: The real part of the shift ')
-            call psvout (comm, logfil, 1, sigmai, ndigit,
+            call psvout (comm, logfil, 1, [sigmai], ndigit,
      &               '_napps: The imaginary part of the shift ')
          end if
 c
@@ -347,7 +347,7 @@ c
                if (msglvl .gt. 0) then
                   call pivout (comm, logfil, 1, i, ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call psvout (comm, logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -361,9 +361,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call pivout (comm, logfil, 1, istart, ndigit,
+             call pivout (comm, logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call pivout (comm, logfil, 1, iend, ndigit,
+             call pivout (comm, logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -635,7 +635,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call psvout (comm, logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call pivout (comm, logfil, 1, kev, ndigit,
+         call pivout (comm, logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call psmout (comm, logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/psnaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/psnaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/psnaup2.f
@@ -405,7 +405,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -418,9 +418,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -452,7 +452,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -696,7 +696,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -748,7 +748,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call psvout (comm, logfil, np, ritzr, ndigit,
      &                  '_naup2: Real part of the shifts')
@@ -815,7 +815,7 @@ c
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call psmout (comm, logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/psnaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/psnaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/psnaupd.f
@@ -642,9 +642,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call psvout (comm, logfil, np, workl(ritzr), ndigit,
      &               '_naupd: Real part of the final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/psneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/psneupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/psneupd.f
@@ -617,9 +617,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/psngets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/psngets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/psngets.f
@@ -226,8 +226,8 @@ c
       tngets = tngets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_ngets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_ngets: NP is')
          call psvout (comm, logfil, kev+np, ritzr, ndigit,
      &        '_ngets: Eigenvalues of current H matrix -- real part')
          call psvout (comm, logfil, kev+np, ritzi, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pssaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pssaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pssaitr.f
@@ -389,9 +389,9 @@ c
  1000 continue
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_saitr: generating Arnoldi vector no.')
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_saitr: B-norm of the current residual =')
          end if
 c
@@ -409,7 +409,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_saitr: ****** restart at step ******')
             end if
 c
@@ -767,7 +767,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pssapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pssapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pssapps.f
@@ -272,9 +272,9 @@ c
             big   = abs(h(i,2)) + abs(h(i+1,2))
             if (h(i+1,1) .le. epsmch*big) then
                if (msglvl .gt. 0) then
-                  call pivout (comm, logfil, 1, i, ndigit,
+                  call pivout (comm, logfil, 1, [i], ndigit,
      &                 '_sapps: deflation at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_sapps: occurred before shift number.')
                   call psvout (comm, logfil, 1, h(i+1,1), ndigit,
      &                 '_sapps: the corresponding off diagonal element')
@@ -443,7 +443,7 @@ c
          big   = abs(h(i,2)) + abs(h(i+1,2))
          if (h(i+1,1) .le. epsmch*big) then
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, i, ndigit,
+               call pivout (comm, logfil, 1, [i], ndigit,
      &              '_sapps: deflation at row/column no.')
                call psvout (comm, logfil, 1, h(i+1,1), ndigit,
      &              '_sapps: the corresponding off diagonal element')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pssaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pssaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pssaup2.f
@@ -421,13 +421,13 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_saup2: **** Start of major iteration number ****')
          end if
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_saup2: The length of the current Lanczos factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_saup2: Extend the Lanczos factorization by')
          end if
 c
@@ -466,7 +466,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &           '_saup2: Current B-norm of residual for factorization')
          end if
 c
@@ -716,7 +716,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_saup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -763,7 +763,7 @@ c
          if (ishift .eq. 0) call scopy (np, workl, 1, ritz, 1)
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_saup2: The number of shifts to apply ')
             call psvout (comm, logfil, np, workl, ndigit,
      &                  '_saup2: shifts selected')
@@ -831,7 +831,7 @@ c
   130    continue
 c
          if (msglvl .gt. 2) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &      '_saup2: B-norm of residual for NEV factorization')
             call psvout (comm, logfil, nev, h(1,2), ndigit,
      &           '_saup2: main diagonal of compressed H matrix')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pssaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pssaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pssaupd.f
@@ -644,9 +644,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_saupd: number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_saupd: number of "converged" Ritz values')
          call psvout (comm, logfil, np, workl(Ritz), ndigit,
      &               '_saupd: final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/psseupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/psseupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/psseupd.f
@@ -523,9 +523,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pssgets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pssgets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pssgets.f
@@ -216,8 +216,8 @@ c
       tsgets = tsgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_sgets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_sgets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_sgets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_sgets: NP is')
          call psvout (comm, logfil, kev+np, ritz, ndigit,
      &        '_sgets: Eigenvalues of current H matrix')
          call psvout (comm, logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pzgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pzgetv0.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pzgetv0.f
@@ -406,9 +406,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call pdvout  (comm, logfil, 1, rnorm0, ndigit,
+          call pdvout  (comm, logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call pdvout  (comm, logfil, 1, rnorm, ndigit,
+          call pdvout  (comm, logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -440,7 +440,7 @@ c
 c
       if (msglvl .gt. 0) then
          cnorm2 = dcmplx (rnorm,rzero)
-         call pzvout  (comm, logfil, 1, cnorm2, ndigit,
+         call pzvout  (comm, logfil, 1, [cnorm2], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 2) then
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pznaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pznaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pznaitr.f
@@ -401,9 +401,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call pzvout (comm, logfil, 1, rnorm, ndigit,
+            call pzvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -423,7 +423,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -757,7 +757,7 @@ c
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 rtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pznapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pznapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pznapps.f
@@ -284,9 +284,9 @@ c
          sigma = shift(jj)
 c
          if (msglvl .gt. 2 ) then
-            call pivout (comm, logfil, 1, jj, ndigit,
+            call pivout (comm, logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call pzvout (comm, logfil, 1, sigma, ndigit,
+            call pzvout (comm, logfil, 1, [sigma], ndigit,
      &               '_napps: Value of the shift ')
          end if
 c
@@ -307,9 +307,9 @@ c
             if ( abs(dble(h(i+1,i)))
      &           .le. max(ulp*tst1, smlnum) )  then
                if (msglvl .gt. 0) then
-                  call pivout (comm, logfil, 1, i, ndigit,
+                  call pivout (comm, logfil, 1, [i], ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call pzvout (comm, logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -323,9 +323,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call pivout (comm, logfil, 1, istart, ndigit,
+             call pivout (comm, logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call pivout (comm, logfil, 1, iend, ndigit,
+             call pivout (comm, logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -501,7 +501,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call pzvout (comm, logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call pivout (comm, logfil, 1, kev, ndigit,
+         call pivout (comm, logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call pzmout (comm, logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pznaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pznaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pznaup2.f
@@ -398,7 +398,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -411,9 +411,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -440,7 +440,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -671,7 +671,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -711,7 +711,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call pzvout (comm, logfil, np, ritz, ndigit,
      &                  '_naup2: values of the shifts')
@@ -776,7 +776,7 @@ c
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call pzmout (comm, logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pznaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pznaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pznaupd.f
@@ -618,9 +618,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call pzvout  (comm, logfil, np, workl(ritz), ndigit,
      &               '_naupd: The final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pzneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pzneupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pzneupd.f
@@ -558,9 +558,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/BLACS/pzngets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/BLACS/pzngets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/BLACS/pzngets.f
@@ -177,8 +177,8 @@ c
       tcgets = tcgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_ngets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_ngets: NP is')
          call pzvout (comm, logfil, kev+np, ritz, ndigit,
      &        '_ngets: Eigenvalues of current H matrix ')
          call pzvout (comm, logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pcgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pcgetv0.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pcgetv0.f
@@ -185,7 +185,7 @@ c
       save       first, iseed, inits, iter, msglvl, orth, rnorm0
 c
       Complex
-     &           cnorm_buf
+     &           cnorm_buf, buf2(1)
 c
 c     %----------------------%
 c     | External Subroutines |
@@ -332,8 +332,9 @@ c
       first = .FALSE.
       if (bmat .eq. 'G') then
           cnorm_buf = cdotc (n, resid, 1, workd, 1)
-          call MPI_ALLREDUCE( cnorm_buf, cnorm, 1,
+          call MPI_ALLREDUCE( [cnorm_buf], buf2, 1,
      &          MPI_COMPLEX, MPI_SUM, comm, ierr )
+          cnorm = buf2(1)
           rnorm0 = sqrt(slapy2(real (cnorm),aimag(cnorm)))
       else if (bmat .eq. 'I') then
            rnorm0 = pscnorm2( comm, n, resid, 1)
@@ -393,8 +394,9 @@ c
 c
       if (bmat .eq. 'G') then
          cnorm_buf = cdotc (n, resid, 1, workd, 1)
-         call MPI_ALLREDUCE( cnorm_buf, cnorm, 1,
+         call MPI_ALLREDUCE( [cnorm_buf], buf2, 1,
      &            MPI_COMPLEX, MPI_SUM, comm, ierr )
+         cnorm = buf2(1)
          rnorm = sqrt(slapy2(real (cnorm),aimag(cnorm)))
       else if (bmat .eq. 'I') then
          rnorm = pscnorm2(comm, n, resid, 1)
@@ -405,9 +407,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call psvout (comm, logfil, 1, rnorm0, ndigit,
+          call psvout (comm, logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call psvout (comm, logfil, 1, rnorm, ndigit,
+          call psvout (comm, logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -439,7 +441,7 @@ c
 c
       if (msglvl .gt. 0) then
          cnorm2 = cmplx(rnorm,rzero)
-         call pcvout (comm, logfil, 1, cnorm2, ndigit,
+         call pcvout (comm, logfil, 1, [cnorm2], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 2) then
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pcnaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pcnaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pcnaitr.f
@@ -293,7 +293,7 @@ c
      &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
 c
       Complex
-     &           cnorm_buf
+     &           cnorm_buf, buf2(1)
 c
 c     %----------------------%
 c     | External Subroutines |
@@ -404,9 +404,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call pcvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -426,7 +426,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -577,8 +577,9 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
              cnorm_buf = cdotc (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( cnorm_buf, cnorm, 1,
+            call MPI_ALLREDUCE( [cnorm_buf], buf2, 1,
      &           MPI_COMPLEX, MPI_SUM, comm, ierr )
+             cnorm = buf2(1)
              wnorm = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
          else if (bmat .eq. 'I') then
              wnorm = pscnorm2(comm, n, resid, 1)
@@ -653,8 +654,9 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
             cnorm_buf = cdotc (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( cnorm_buf, cnorm, 1,
+            call MPI_ALLREDUCE( [cnorm_buf], buf2, 1,
      &           MPI_COMPLEX, MPI_SUM, comm, ierr )
+            cnorm = buf2(1)
             rnorm = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
          else if (bmat .eq. 'I') then
             rnorm = pscnorm2(comm, n, resid, 1)
@@ -757,15 +759,16 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
              cnorm_buf = cdotc (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( cnorm_buf, cnorm, 1,
+            call MPI_ALLREDUCE( [cnorm_buf], buf2, 1,
      &           MPI_COMPLEX, MPI_SUM, comm, ierr )
+             cnorm = buf2(1)
              rnorm1 = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
          else if (bmat .eq. 'I') then
              rnorm1 = pscnorm2(comm, n, resid, 1)
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 rtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pcnapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pcnapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pcnapps.f
@@ -283,9 +283,9 @@ c
          sigma = shift(jj)
 c
          if (msglvl .gt. 2 ) then
-            call pivout (comm, logfil, 1, jj, ndigit,
+            call pivout (comm, logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call pcvout (comm, logfil, 1, sigma, ndigit,
+            call pcvout (comm, logfil, 1, [sigma], ndigit,
      &               '_napps: Value of the shift ')
          end if
 c
@@ -306,9 +306,9 @@ c
             if ( abs(real(h(i+1,i)))
      &           .le. max(ulp*tst1, smlnum) )  then
                if (msglvl .gt. 0) then
-                  call pivout (comm, logfil, 1, i, ndigit,
+                  call pivout (comm, logfil, 1, [i], ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call pcvout (comm, logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -322,9 +322,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call pivout (comm, logfil, 1, istart, ndigit,
+             call pivout (comm, logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call pivout (comm, logfil, 1, iend, ndigit,
+             call pivout (comm, logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -500,7 +500,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call pcvout (comm, logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call pivout (comm, logfil, 1, kev, ndigit,
+         call pivout (comm, logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call pcmout (comm, logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pcnaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pcnaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pcnaup2.f
@@ -237,7 +237,7 @@ c
      &           nevbef, nev0 , np0,    eps23
 c
       Real
-     &           cmpnorm_buf
+     &           cmpnorm_buf, buf2(1)
 c
 c     %-----------------------%
 c     | Local array arguments |
@@ -401,7 +401,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -414,9 +414,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -443,7 +443,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -674,7 +674,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -714,7 +714,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call pcvout (comm, logfil, np, ritz, ndigit,
      &                  '_naup2: values of the shifts')
@@ -771,8 +771,9 @@ c
 c
          if (bmat .eq. 'G') then
             cmpnorm_buf = cdotc (n, resid, 1, workd, 1)
-            call MPI_ALLREDUCE( cmpnorm_buf, cmpnorm, 1,
+            call MPI_ALLREDUCE( [cmpnorm_buf], buf2, 1,
      &               MPI_COMPLEX, MPI_SUM, comm, ierr )
+            cmpnorm = buf2(1)
             rnorm = sqrt(slapy2(real(cmpnorm),aimag(cmpnorm)))
          else if (bmat .eq. 'I') then
             rnorm = pscnorm2(comm, n, resid, 1)
@@ -780,7 +781,7 @@ c
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call pcmout (comm, logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pcnaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pcnaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pcnaupd.f
@@ -626,9 +626,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call pcvout (comm, logfil, np, workl(ritz), ndigit,
      &               '_naupd: The final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pcneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pcneupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pcneupd.f
@@ -558,9 +558,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pcngets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pcngets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pcngets.f
@@ -177,8 +177,8 @@ c
       tcgets = tcgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_ngets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_ngets: NP is')
          call pcvout (comm, logfil, kev+np, ritz, ndigit,
      &        '_ngets: Eigenvalues of current H matrix ')
          call pcvout (comm, logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdgetv0.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdgetv0.f
@@ -180,7 +180,7 @@ c
       logical    first, inits, orth
       integer    idist, iseed(4), iter, msglvl, jj
       Double precision
-     &           rnorm0
+     &           rnorm0, buf2(1)
       save       first, iseed, inits, iter, msglvl, orth, rnorm0
 c
       Double precision
@@ -318,9 +318,9 @@ c
       first = .FALSE.
       if (bmat .eq. 'G') then
           rnorm_buf = ddot (n, resid, 1, workd, 1)
-          call MPI_ALLREDUCE( rnorm_buf, rnorm0, 1,
+          call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &          MPI_DOUBLE_PRECISION, MPI_SUM, comm, ierr )
-          rnorm0 = sqrt(abs(rnorm0))
+          rnorm0 = sqrt(abs(buf2(1)))
       else if (bmat .eq. 'I') then
           rnorm0 = pdnorm2( comm, n, resid, 1 )
       end if
@@ -379,9 +379,9 @@ c
 c
       if (bmat .eq. 'G') then
          rnorm_buf = ddot (n, resid, 1, workd, 1)
-         call MPI_ALLREDUCE( rnorm_buf, rnorm, 1,
+         call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &            MPI_DOUBLE_PRECISION, MPI_SUM, comm, ierr )
-         rnorm = sqrt(abs(rnorm))
+         rnorm = sqrt(abs(buf2(1)))
       else if (bmat .eq. 'I') then
          rnorm = pdnorm2( comm, n, resid, 1 )
       end if
@@ -391,9 +391,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call pdvout (comm, logfil, 1, rnorm0, ndigit,
+          call pdvout (comm, logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call pdvout (comm, logfil, 1, rnorm, ndigit,
+          call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -424,7 +424,7 @@ c
    50 continue
 c
       if (msglvl .gt. 0) then
-         call pdvout (comm, logfil, 1, rnorm, ndigit,
+         call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 2) then
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdlamch10.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdlamch10.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdlamch10.f
@@ -57,7 +57,7 @@
 *
 *     .. Local Scalars ..
       INTEGER            IDUMM
-      DOUBLE PRECISION   TEMP, TEMP1
+      DOUBLE PRECISION   TEMP, TEMP1, buf2(1)
 *     ..
 *     .. External Subroutines ..
 *      EXTERNAL           DGAMN2D, DGAMX2D
@@ -73,19 +73,20 @@
 *
       IF( LSAME( CMACH, 'E' ).OR.LSAME( CMACH, 'S' ).OR.
      $    LSAME( CMACH, 'M' ).OR.LSAME( CMACH, 'U' ) ) THEN
-          CALL MPI_ALLREDUCE( TEMP1, TEMP, 1, MPI_DOUBLE_PRECISION,
+          CALL MPI_ALLREDUCE( [TEMP1], buf2, 1, MPI_DOUBLE_PRECISION,
      $                        MPI_MAX, ICTXT, IDUMM )
-*         CALL DGAMX2D( ICTXT, 'All', ' ', 1, 1, TEMP, 1, IDUMM,
+*         CALL DGAMX2D( ICTXT, 'All', ' ', 1, 1, buf2(1), 1, IDUMM,
 *     $                 IDUMM, 1, -1, IDUMM )
       ELSE IF( LSAME( CMACH, 'L' ).OR.LSAME( CMACH, 'O' ) ) THEN
-          CALL MPI_ALLREDUCE( TEMP1, TEMP, 1, MPI_DOUBLE_PRECISION,
+          CALL MPI_ALLREDUCE( [TEMP1], buf2, 1, MPI_DOUBLE_PRECISION,
      $                        MPI_MIN, ICTXT, IDUMM )
-*         CALL DGAMN2D( ICTXT, 'All', ' ', 1, 1, TEMP, 1, IDUMM,
+*         CALL DGAMN2D( ICTXT, 'All', ' ', 1, 1, buf2(1), 1, IDUMM,
 *     $                 IDUMM, 1, -1, IDUMM )
       ELSE
-          TEMP = TEMP1
+          buf2(1) = TEMP1
       END IF
 *
+      TEMP = buf2(1)
       PDLAMCH10 = TEMP
 *
 *     End of PDLAMCH10
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdnaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdnaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdnaitr.f
@@ -276,7 +276,7 @@ c
      &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
 c
       Double precision
-     &           rnorm_buf
+     &           rnorm_buf, buf2(1)
 c
 c
 c     %-----------------------%
@@ -393,9 +393,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -415,7 +415,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -566,9 +566,9 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
             rnorm_buf = ddot (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( rnorm_buf, wnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &           MPI_DOUBLE_PRECISION, MPI_SUM, comm, ierr )
-            wnorm = sqrt(abs(wnorm))
+            wnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
             wnorm = pdnorm2( comm, n, resid, 1 )
          end if
@@ -642,9 +642,9 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
             rnorm_buf = ddot (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( rnorm_buf, rnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &           MPI_DOUBLE_PRECISION, MPI_SUM, comm, ierr )
-            rnorm = sqrt(abs(rnorm))
+            rnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
             rnorm = pdnorm2( comm, n, resid, 1 )
          end if
@@ -745,15 +745,15 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
            rnorm_buf = ddot (n, resid, 1, workd(ipj), 1)
-           call MPI_ALLREDUCE( rnorm_buf, rnorm1, 1,
+           call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &          MPI_DOUBLE_PRECISION, MPI_SUM, comm, ierr )
-           rnorm1 = sqrt(abs(rnorm1))
+           rnorm1 = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
            rnorm1 = pdnorm2( comm, n, resid, 1 )
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdnapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdnapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdnapps.f
@@ -276,11 +276,11 @@ c
          sigmai = shifti(jj)
 c
          if (msglvl .gt. 2 ) then
-            call pivout (comm, logfil, 1, jj, ndigit,
+            call pivout (comm, logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call pdvout (comm, logfil, 1, sigmar, ndigit,
+            call pdvout (comm, logfil, 1, [sigmar], ndigit,
      &               '_napps: The real part of the shift ')
-            call pdvout (comm, logfil, 1, sigmai, ndigit,
+            call pdvout (comm, logfil, 1, [sigmai], ndigit,
      &               '_napps: The imaginary part of the shift ')
          end if
 c
@@ -345,9 +345,9 @@ c
      &         tst1 = dlanhs( '1', kplusp-jj+1, h, ldh, workl )
             if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) then
                if (msglvl .gt. 0) then
-                  call pivout (comm, logfil, 1, i, ndigit,
+                  call pivout (comm, logfil, 1, [i], ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call pdvout (comm, logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -361,9 +361,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call pivout (comm, logfil, 1, istart, ndigit,
+             call pivout (comm, logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call pivout (comm, logfil, 1, iend, ndigit,
+             call pivout (comm, logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -635,7 +635,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call pdvout (comm, logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call pivout (comm, logfil, 1, kev, ndigit,
+         call pivout (comm, logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call pdmout (comm, logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdnaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdnaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdnaup2.f
@@ -234,7 +234,7 @@ c
      &           nevbef, nev0 , np0   , nptemp, numcnv,
      &           j
       Double precision
-     &           rnorm , temp , eps23
+     &           rnorm , temp , eps23, buf2(1)
       save       cnorm , getv0, initv , update, ushift,
      &           rnorm , iter , kplusp, msglvl, nconv,
      &           nevbef, nev0 , np0   , eps23 , numcnv
@@ -408,7 +408,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -421,9 +421,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -455,7 +455,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call pdvout  (comm, logfil, 1, rnorm, ndigit,
+            call pdvout  (comm, logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -699,7 +699,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -751,7 +751,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call pdvout  (comm, logfil, np, ritzr, ndigit,
      &                  '_naup2: Real part of the shifts')
@@ -810,16 +810,16 @@ c
 c
          if (bmat .eq. 'G') then
             rnorm_buf = ddot  (n, resid, 1, workd, 1)
-            call MPI_ALLREDUCE( rnorm_buf, rnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &                MPI_DOUBLE_PRECISION , MPI_SUM, comm, ierr )
-            rnorm = sqrt(abs(rnorm))
+            rnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
             rnorm = pdnorm2 ( comm, n, resid, 1 )
          end if
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call pdvout  (comm, logfil, 1, rnorm, ndigit,
+            call pdvout  (comm, logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call pdmout  (comm, logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdnaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdnaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdnaupd.f
@@ -650,9 +650,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call pdvout  (comm, logfil, np, workl(ritzr), ndigit,
      &               '_naupd: Real part of the final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdneupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdneupd.f
@@ -617,9 +617,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdngets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdngets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdngets.f
@@ -226,8 +226,8 @@ c
       tngets = tngets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_ngets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_ngets: NP is')
          call pdvout (comm, logfil, kev+np, ritzr, ndigit,
      &        '_ngets: Eigenvalues of current H matrix -- real part')
          call pdvout (comm, logfil, kev+np, ritzi, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdnorm2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdnorm2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdnorm2.f
@@ -45,7 +45,7 @@ c     | Local Scalars |
 c     %---------------%
 c
       Double precision
-     &             max, buf, zero
+     &             max, buf, zero, buf2(1)
       parameter    ( zero = 0.0 )
 c
 c     %---------------------%
@@ -69,15 +69,16 @@ c
       pdnorm2 = dnrm2( n, x, inc)
 c
       buf = pdnorm2
-      call MPI_ALLREDUCE( buf, max, 1, MPI_DOUBLE_PRECISION,
+      call MPI_ALLREDUCE( [buf], buf2, 1, MPI_DOUBLE_PRECISION,
      &                    MPI_MAX, comm, ierr )
+      max = buf2(1)
       if ( max .eq. zero ) then
          pdnorm2 = zero
       else
          buf = (pdnorm2/max)**2.0
-         call MPI_ALLREDUCE( buf, pdnorm2, 1, MPI_DOUBLE_PRECISION,
+         call MPI_ALLREDUCE( [buf], buf2, 1, MPI_DOUBLE_PRECISION,
      &                       MPI_SUM, comm, ierr )
-         pdnorm2 = max * sqrt(abs(pdnorm2))
+         pdnorm2 = max * sqrt(abs(buf2(1)))
       endif
 c
 c     %----------------%
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdsaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdsaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdsaitr.f
@@ -264,7 +264,7 @@ c
       integer    i, ierr, ipj, irj, ivj, iter, itry, j, msglvl, infol,
      &           jj
       Double precision
-     &           rnorm1, wnorm, safmin, temp1
+     &           rnorm1, wnorm, safmin, temp1, buf2(1)
       save       orth1, orth2, rstart, step3, step4,
      &           ierr, ipj, irj, ivj, iter, itry, j, msglvl,
      &           rnorm1, safmin, wnorm
@@ -392,9 +392,9 @@ c
  1000 continue
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_saitr: generating Arnoldi vector no.')
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_saitr: B-norm of the current residual =')
          end if
 c
@@ -412,7 +412,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_saitr: ****** restart at step ******')
             end if
 c
@@ -572,14 +572,14 @@ c           | is the inv(B)-norm of A*v_
 c           %----------------------------------%
 c
             rnorm_buf = ddot (n, resid, 1, workd(ivj), 1)
-            call MPI_ALLREDUCE( rnorm_buf, wnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &           MPI_DOUBLE_PRECISION, MPI_SUM, comm, ierr )
-            wnorm = sqrt(abs(wnorm))
+            wnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'G') then
             rnorm_buf = ddot (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( rnorm_buf, wnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &           MPI_DOUBLE_PRECISION, MPI_SUM, comm, ierr )
-            wnorm = sqrt(abs(wnorm))
+            wnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
             wnorm = pdnorm2( comm, n, resid, 1 )
          end if
@@ -669,9 +669,9 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
             rnorm_buf = ddot (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( rnorm_buf, rnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &           MPI_DOUBLE_PRECISION, MPI_SUM, comm, ierr )
-            rnorm = sqrt(abs(rnorm))
+            rnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
             rnorm = pdnorm2( comm, n, resid, 1 )
          end if
@@ -769,15 +769,15 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
            rnorm_buf = ddot (n, resid, 1, workd(ipj), 1)
-           call MPI_ALLREDUCE( rnorm_buf, rnorm1, 1,
+           call MPI_ALLREDUCE( [rnorm_buf], buf2(1), 1,
      &          MPI_DOUBLE_PRECISION, MPI_SUM, comm, ierr )
-           rnorm1 = sqrt(abs(rnorm1))
+           rnorm1 = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
            rnorm1 = pdnorm2( comm, n, resid, 1 )
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdsapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdsapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdsapps.f
@@ -272,9 +272,9 @@ c
             big   = abs(h(i,2)) + abs(h(i+1,2))
             if (h(i+1,1) .le. epsmch*big) then
                if (msglvl .gt. 0) then
-                  call pivout (comm, logfil, 1, i, ndigit,
+                  call pivout (comm, logfil, 1, [i], ndigit,
      &                 '_sapps: deflation at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_sapps: occurred before shift number.')
                   call pdvout (comm, logfil, 1, h(i+1,1), ndigit,
      &                 '_sapps: the corresponding off diagonal element')
@@ -443,7 +443,7 @@ c
          big   = abs(h(i,2)) + abs(h(i+1,2))
          if (h(i+1,1) .le. epsmch*big) then
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, i, ndigit,
+               call pivout (comm, logfil, 1, [i], ndigit,
      &              '_sapps: deflation at row/column no.')
                call pdvout (comm, logfil, 1, h(i+1,1), ndigit,
      &              '_sapps: the corresponding off diagonal element')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdsaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdsaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdsaup2.f
@@ -212,7 +212,7 @@ c
       integer    ido, info, ishift, iupd, ldh, ldq, ldv, mxiter,
      &           n, mode, nev, np
       Double precision
-     &           tol
+     &           tol, buf2(1)
 c
 c     %-----------------%
 c     | Array Arguments |
@@ -424,13 +424,13 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_saup2: **** Start of major iteration number ****')
          end if
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_saup2: The length of the current Lanczos factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_saup2: Extend the Lanczos factorization by')
          end if
 c
@@ -469,7 +469,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &           '_saup2: Current B-norm of residual for factorization')
          end if
 c
@@ -719,7 +719,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_saup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -766,7 +766,7 @@ c
          if (ishift .eq. 0) call dcopy (np, workl, 1, ritz, 1)
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_saup2: The number of shifts to apply ')
             call pdvout (comm, logfil, np, workl, ndigit,
      &                  '_saup2: shifts selected')
@@ -825,9 +825,9 @@ c
 c
          if (bmat .eq. 'G') then
             rnorm_buf = ddot (n, resid, 1, workd, 1)
-            call MPI_ALLREDUCE( rnorm_buf, rnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &                MPI_DOUBLE_PRECISION, MPI_SUM, comm, ierr )
-            rnorm = sqrt(abs(rnorm))
+            rnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
             rnorm = pdnorm2( comm, n, resid, 1 )
          end if
@@ -835,7 +835,7 @@ c
   130    continue
 c
          if (msglvl .gt. 2) then
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &      '_saup2: B-norm of residual for NEV factorization')
             call pdvout (comm, logfil, nev, h(1,2), ndigit,
      &           '_saup2: main diagonal of compressed H matrix')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdsaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdsaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdsaupd.f
@@ -652,9 +652,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_saupd: number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_saupd: number of "converged" Ritz values')
          call pdvout  (comm, logfil, np, workl(Ritz), ndigit,
      &               '_saupd: final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdseupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdseupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdseupd.f
@@ -523,9 +523,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdsgets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdsgets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdsgets.f
@@ -216,8 +216,8 @@ c
       tsgets = tsgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_sgets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_sgets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_sgets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_sgets: NP is')
          call pdvout (comm, logfil, kev+np, ritz, ndigit,
      &        '_sgets: Eigenvalues of current H matrix')
          call pdvout (comm, logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pdznorm2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pdznorm2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pdznorm2.f
@@ -45,7 +45,7 @@ c     | Local Scalars |
 c     %---------------%
 c
       Double precision
-     &             max, buf, zero
+     &             max(1), buf, zero
       parameter    ( zero = 0.0 )
 c
 c     %---------------------%
@@ -59,7 +59,7 @@ c     | External Functions |
 c     %--------------------%
 c
       Double precision
-     &             dznrm2
+     &             dznrm2, buf2(1)
       External     dznrm2
 c
 c     %-----------------------%
@@ -69,15 +69,15 @@ c
       pdznorm2 = dznrm2( n, x, inc)
 c
       buf = pdznorm2
-      call MPI_ALLREDUCE( buf, max, 1, MPI_DOUBLE_PRECISION,
+      call MPI_ALLREDUCE( [buf], max, 1, MPI_DOUBLE_PRECISION,
      &                    MPI_MAX, comm, ierr )
-      if ( max .eq. zero ) then
+      if ( max(1) .eq. zero ) then
          pdznorm2 = zero
       else
-         buf = (pdznorm2/max)**2.0
-         call MPI_ALLREDUCE( buf, pdznorm2, 1, MPI_DOUBLE_PRECISION,
+         buf = (pdznorm2/max(1))**2.0
+         call MPI_ALLREDUCE( [buf], buf2, 1, MPI_DOUBLE_PRECISION,
      &                       MPI_SUM, comm, ierr )
-         pdznorm2 = max * sqrt(abs(pdznorm2))
+         pdznorm2 = max(1) * sqrt(abs(buf2(1)))
       endif
 c
 c     %-----------------%
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pscnorm2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pscnorm2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pscnorm2.f
@@ -45,7 +45,7 @@ c     | Local Scalars |
 c     %---------------%
 c
       Real
-     &             max, buf, zero
+     &             max(1), buf, zero
       parameter    ( zero = 0.0 )
 c
 c     %---------------------%
@@ -61,6 +61,7 @@ c
       Real
      &             scnrm2
       External     scnrm2
+      Real         buf2(1)
 c
 c     %-----------------------%
 c     | Executable Statements |
@@ -69,15 +70,15 @@ c
       pscnorm2 = scnrm2( n, x, inc)
 c
       buf = pscnorm2
-      call MPI_ALLREDUCE( buf, max, 1, MPI_REAL,
+      call MPI_ALLREDUCE( [buf], max, 1, MPI_REAL,
      &                    MPI_MAX, comm, ierr )
-      if ( max .eq. zero ) then
+      if ( max(1) .eq. zero ) then
          pscnorm2 = zero
       else
-         buf = (pscnorm2/max)**2.0
-         call MPI_ALLREDUCE( buf, pscnorm2, 1, MPI_REAL,
+         buf = (pscnorm2/max(1))**2.0
+         call MPI_ALLREDUCE( [buf], buf2, 1, MPI_REAL,
      &                       MPI_SUM, comm, ierr )
-         pscnorm2 = max * sqrt(abs(pscnorm2))
+         pscnorm2 = max(1) * sqrt(abs(buf2(1)))
       endif
 c
 c     %-----------------%
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/psgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/psgetv0.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/psgetv0.f
@@ -163,7 +163,7 @@ c     %-----------------%
 c
       integer    ipntr(3)
       Real
-     &           resid(n), v(ldv,j), workd(2*n), workl(2*j)
+     &           resid(n), v(ldv,j), workd(2*n), workl(2*j), buf2(1)
 c
 c     %------------%
 c     | Parameters |
@@ -318,9 +318,9 @@ c
       first = .FALSE.
       if (bmat .eq. 'G') then
           rnorm_buf = sdot (n, resid, 1, workd, 1)
-          call MPI_ALLREDUCE( rnorm_buf, rnorm0, 1,
+          call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &          MPI_REAL, MPI_SUM, comm, ierr )
-          rnorm0 = sqrt(abs(rnorm0))
+          rnorm0 = sqrt(abs(buf2(1)))
       else if (bmat .eq. 'I') then
           rnorm0 = psnorm2( comm, n, resid, 1 )
       end if
@@ -379,9 +379,9 @@ c
 c
       if (bmat .eq. 'G') then
          rnorm_buf = sdot (n, resid, 1, workd, 1)
-         call MPI_ALLREDUCE( rnorm_buf, rnorm, 1,
+         call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &            MPI_REAL, MPI_SUM, comm, ierr )
-         rnorm = sqrt(abs(rnorm))
+         rnorm = sqrt(abs(buf2(1)))
       else if (bmat .eq. 'I') then
          rnorm = psnorm2( comm, n, resid, 1 )
       end if
@@ -391,9 +391,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call psvout (comm, logfil, 1, rnorm0, ndigit,
+          call psvout (comm, logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call psvout (comm, logfil, 1, rnorm, ndigit,
+          call psvout (comm, logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -424,7 +424,7 @@ c
    50 continue
 c
       if (msglvl .gt. 0) then
-         call psvout (comm, logfil, 1, rnorm, ndigit,
+         call psvout (comm, logfil, 1, [rnorm], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 2) then
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pslamch10.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pslamch10.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pslamch10.f
@@ -53,7 +53,7 @@
 *
 *     .. Local Scalars ..
       INTEGER            IDUMM
-      REAL               TEMP, TEMP1
+      REAL               TEMP, TEMP1, buf2(1)
 *     ..
 *     .. External Subroutines ..
 *      EXTERNAL           SGAMN2D, SGAMX2D
@@ -69,14 +69,16 @@
 *
       IF( LSAME( CMACH, 'E' ).OR.LSAME( CMACH, 'S' ).OR.
      $    LSAME( CMACH, 'M' ).OR.LSAME( CMACH, 'U' ) ) THEN
-          CALL MPI_ALLREDUCE( TEMP1, TEMP, 1, MPI_REAL,
+          CALL MPI_ALLREDUCE( [TEMP1], buf2, 1, MPI_REAL,
      $                        MPI_MAX, ICTXT, IDUMM )
-*         CALL SGAMX2D( ICTXT, 'All', ' ', 1, 1, TEMP, 1, IDUMM,
+          TEMP = buf2(1)
+*     CALL SGAMX2D( ICTXT, 'All', ' ', 1, 1, TEMP, 1, IDUMM,
 *     $                 IDUMM, 1, -1, IDUMM )
       ELSE IF( LSAME( CMACH, 'L' ).OR.LSAME( CMACH, 'O' ) ) THEN
-          CALL MPI_ALLREDUCE( TEMP1, TEMP, 1, MPI_REAL,
+          CALL MPI_ALLREDUCE( [TEMP1], buf2, 1, MPI_REAL,
      $                        MPI_MIN, ICTXT, IDUMM )
-*         CALL SGAMN2D( ICTXT, 'All', ' ', 1, 1, TEMP, 1, IDUMM,
+          TEMP = buf2(1)
+*     CALL SGAMN2D( ICTXT, 'All', ' ', 1, 1, TEMP, 1, IDUMM,
 *     $                 IDUMM, 1, -1, IDUMM )
       ELSE
           TEMP = TEMP1
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/psnaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/psnaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/psnaitr.f
@@ -276,7 +276,7 @@ c
      &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
 c
       Real
-     &           rnorm_buf
+     &           rnorm_buf, buf2(1)
 c
 c
 c     %-----------------------%
@@ -393,9 +393,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -415,7 +415,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -566,9 +566,9 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
             rnorm_buf = sdot (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( rnorm_buf, wnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &           MPI_REAL, MPI_SUM, comm, ierr )
-            wnorm = sqrt(abs(wnorm))
+            wnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
             wnorm = psnorm2( comm, n, resid, 1 )
          end if
@@ -642,9 +642,9 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
             rnorm_buf = sdot (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( rnorm_buf, rnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &           MPI_REAL, MPI_SUM, comm, ierr )
-            rnorm = sqrt(abs(rnorm))
+            rnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
             rnorm = psnorm2( comm, n, resid, 1 )
          end if
@@ -745,15 +745,15 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
            rnorm_buf = sdot (n, resid, 1, workd(ipj), 1)
-           call MPI_ALLREDUCE( rnorm_buf, rnorm1, 1,
+           call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &          MPI_REAL, MPI_SUM, comm, ierr )
-           rnorm1 = sqrt(abs(rnorm1))
+           rnorm1 = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
            rnorm1 = psnorm2( comm, n, resid, 1 )
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/psnapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/psnapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/psnapps.f
@@ -276,11 +276,11 @@ c
          sigmai = shifti(jj)
 c
          if (msglvl .gt. 2 ) then
-            call pivout (comm, logfil, 1, jj, ndigit,
+            call pivout (comm, logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call psvout (comm, logfil, 1, sigmar, ndigit,
+            call psvout (comm, logfil, 1, [sigmar], ndigit,
      &               '_napps: The real part of the shift ')
-            call psvout (comm, logfil, 1, sigmai, ndigit,
+            call psvout (comm, logfil, 1, [sigmai], ndigit,
      &               '_napps: The imaginary part of the shift ')
          end if
 c
@@ -345,9 +345,9 @@ c
      &         tst1 = slanhs( '1', kplusp-jj+1, h, ldh, workl )
             if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) then
                if (msglvl .gt. 0) then
-                  call pivout (comm, logfil, 1, i, ndigit,
+                  call pivout (comm, logfil, 1, [i], ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call psvout (comm, logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -361,9 +361,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call pivout (comm, logfil, 1, istart, ndigit,
+             call pivout (comm, logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call pivout (comm, logfil, 1, iend, ndigit,
+             call pivout (comm, logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -635,7 +635,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call psvout (comm, logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call pivout (comm, logfil, 1, kev, ndigit,
+         call pivout (comm, logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call psmout (comm, logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/psnaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/psnaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/psnaup2.f
@@ -241,7 +241,7 @@ c
 c
 
       Real
-     &           rnorm_buf
+     &           rnorm_buf, buf2(1)
 c
 c     %-----------------------%
 c     | Local array arguments |
@@ -408,7 +408,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -421,9 +421,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -455,7 +455,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -699,7 +699,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -751,7 +751,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call psvout (comm, logfil, np, ritzr, ndigit,
      &                  '_naup2: Real part of the shifts')
@@ -810,16 +810,16 @@ c
 c
          if (bmat .eq. 'G') then
             rnorm_buf = sdot (n, resid, 1, workd, 1)
-            call MPI_ALLREDUCE( rnorm_buf, rnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &                MPI_REAL, MPI_SUM, comm, ierr )
-            rnorm = sqrt(abs(rnorm))
+            rnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
             rnorm = psnorm2( comm, n, resid, 1 )
          end if
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call psmout (comm, logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/psnaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/psnaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/psnaupd.f
@@ -650,9 +650,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call psvout (comm, logfil, np, workl(ritzr), ndigit,
      &               '_naupd: Real part of the final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/psneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/psneupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/psneupd.f
@@ -617,9 +617,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/psngets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/psngets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/psngets.f
@@ -226,8 +226,8 @@ c
       tngets = tngets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_ngets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_ngets: NP is')
          call psvout (comm, logfil, kev+np, ritzr, ndigit,
      &        '_ngets: Eigenvalues of current H matrix -- real part')
          call psvout (comm, logfil, kev+np, ritzi, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/psnorm2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/psnorm2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/psnorm2.f
@@ -45,7 +45,7 @@ c     | Local Scalars |
 c     %---------------%
 c
       Real
-     &             max, buf, zero
+     &             max, buf, zero, buf2(1)
       parameter    ( zero = 0.0 )
 c
 c     %---------------------%
@@ -69,15 +69,16 @@ c
       psnorm2 = snrm2( n, x, inc)
 c
       buf = psnorm2
-      call MPI_ALLREDUCE( buf, max, 1, MPI_REAL,
+      call MPI_ALLREDUCE( [buf], buf2, 1, MPI_REAL,
      &                    MPI_MAX, comm, ierr )
+      max = buf2(1)
       if ( max .eq. zero ) then
          psnorm2 = zero
       else
          buf = (psnorm2/max)**2.0
-         call MPI_ALLREDUCE( buf, psnorm2, 1, MPI_REAL,
+         call MPI_ALLREDUCE( [buf], buf2, 1, MPI_REAL,
      &                       MPI_SUM, comm, ierr )
-         psnorm2 = max * sqrt(abs(psnorm2))
+         psnorm2 = max * sqrt(abs(buf2(1)))
       endif
 c
 c     %----------------%
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pssaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pssaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pssaitr.f
@@ -264,7 +264,7 @@ c
       integer    i, ierr, ipj, irj, ivj, iter, itry, j, msglvl, infol,
      &           jj
       Real
-     &           rnorm1, wnorm, safmin, temp1
+     &           rnorm1, wnorm(1), safmin, temp1, temp2(1)
       save       orth1, orth2, rstart, step3, step4,
      &           ierr, ipj, irj, ivj, iter, itry, j, msglvl,
      &           rnorm1, safmin, wnorm
@@ -392,9 +392,9 @@ c
  1000 continue
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_saitr: generating Arnoldi vector no.')
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_saitr: B-norm of the current residual =')
          end if
 c
@@ -412,7 +412,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_saitr: ****** restart at step ******')
             end if
 c
@@ -572,16 +572,16 @@ c           | is the inv(B)-norm of A*v_
 c           %----------------------------------%
 c
             rnorm_buf = sdot (n, resid, 1, workd(ivj), 1)
-            call MPI_ALLREDUCE( rnorm_buf, wnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], wnorm, 1,
      &           MPI_REAL, MPI_SUM, comm, ierr )
-            wnorm = sqrt(abs(wnorm))
+            wnorm(1) = sqrt(abs(wnorm(1)))
          else if (bmat .eq. 'G') then
             rnorm_buf = sdot (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( rnorm_buf, wnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], wnorm, 1,
      &           MPI_REAL, MPI_SUM, comm, ierr )
             wnorm = sqrt(abs(wnorm))
          else if (bmat .eq. 'I') then
-            wnorm = psnorm2( comm, n, resid, 1 )
+            wnorm(1) = psnorm2( comm, n, resid, 1 )
          end if
 c
 c        %-----------------------------------------%
@@ -669,9 +669,9 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
             rnorm_buf = sdot (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( rnorm_buf, rnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], temp2, 1,
      &           MPI_REAL, MPI_SUM, comm, ierr )
-            rnorm = sqrt(abs(rnorm))
+            rnorm = sqrt(abs(temp2(1)))
          else if (bmat .eq. 'I') then
             rnorm = psnorm2( comm, n, resid, 1 )
          end if
@@ -691,7 +691,7 @@ c        | Determine if we need to corre
 c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
 c        %-----------------------------------------------------------%
 c
-         if (rnorm .gt. 0.717*wnorm) go to 100
+         if (rnorm .gt. 0.717*wnorm(1)) go to 100
          nrorth = nrorth + 1
 c
 c        %---------------------------------------------------%
@@ -704,7 +704,7 @@ c
    80    continue
 c
          if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
+            xtemp(1) = wnorm(1)
             xtemp(2) = rnorm
             call psvout (comm, logfil, 2, xtemp, ndigit,
      &           '_naitr: re-orthonalization ; wnorm and rnorm are')
@@ -769,15 +769,15 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
            rnorm_buf = sdot (n, resid, 1, workd(ipj), 1)
-           call MPI_ALLREDUCE( rnorm_buf, rnorm1, 1,
+           call MPI_ALLREDUCE( [rnorm_buf], temp2, 1,
      &          MPI_REAL, MPI_SUM, comm, ierr )
-           rnorm1 = sqrt(abs(rnorm1))
+           rnorm1 = sqrt(abs(temp2(1)))
          else if (bmat .eq. 'I') then
            rnorm1 = psnorm2( comm, n, resid, 1 )
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 xtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pssapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pssapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pssapps.f
@@ -271,9 +271,9 @@ c
             big   = abs(h(i,2)) + abs(h(i+1,2))
             if (h(i+1,1) .le. epsmch*big) then
                if (msglvl .gt. 0) then
-                  call pivout (comm, logfil, 1, i, ndigit,
+                  call pivout (comm, logfil, 1, [i], ndigit,
      &                 '_sapps: deflation at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_sapps: occurred before shift number.')
                   call psvout (comm, logfil, 1, h(i+1,1), ndigit,
      &                 '_sapps: the corresponding off diagonal element')
@@ -442,7 +442,7 @@ c
          big   = abs(h(i,2)) + abs(h(i+1,2))
          if (h(i+1,1) .le. epsmch*big) then
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, i, ndigit,
+               call pivout (comm, logfil, 1, [i], ndigit,
      &              '_sapps: deflation at row/column no.')
                call psvout (comm, logfil, 1, h(i+1,1), ndigit,
      &              '_sapps: the corresponding off diagonal element')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pssaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pssaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pssaup2.f
@@ -241,7 +241,7 @@ c
       integer    ierr, iter, j, kplusp, msglvl, nconv, nevbef, nev0,
      &           np0, nptemp, nevd2, nevm2, kp(3)
       Real
-     &           rnorm, temp, eps23
+     &           rnorm, temp, eps23, buf2(1)
       save       cnorm, getv0, initv, update, ushift,
      &           iter, kplusp, msglvl, nconv, nev0, np0,
      &           rnorm, eps23
@@ -424,13 +424,13 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_saup2: **** Start of major iteration number ****')
          end if
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_saup2: The length of the current Lanczos factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_saup2: Extend the Lanczos factorization by')
          end if
 c
@@ -469,7 +469,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &           '_saup2: Current B-norm of residual for factorization')
          end if
 c
@@ -719,7 +719,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_saup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -766,7 +766,7 @@ c
          if (ishift .eq. 0) call scopy (np, workl, 1, ritz, 1)
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_saup2: The number of shifts to apply ')
             call psvout (comm, logfil, np, workl, ndigit,
      &                  '_saup2: shifts selected')
@@ -825,9 +825,9 @@ c
 c
          if (bmat .eq. 'G') then
             rnorm_buf = sdot (n, resid, 1, workd, 1)
-            call MPI_ALLREDUCE( rnorm_buf, rnorm, 1,
+            call MPI_ALLREDUCE( [rnorm_buf], buf2, 1,
      &                MPI_REAL, MPI_SUM, comm, ierr )
-            rnorm = sqrt(abs(rnorm))
+            rnorm = sqrt(abs(buf2(1)))
          else if (bmat .eq. 'I') then
             rnorm = psnorm2( comm, n, resid, 1 )
          end if
@@ -835,7 +835,7 @@ c
   130    continue
 c
          if (msglvl .gt. 2) then
-            call psvout (comm, logfil, 1, rnorm, ndigit,
+            call psvout (comm, logfil, 1, [rnorm], ndigit,
      &      '_saup2: B-norm of residual for NEV factorization')
             call psvout (comm, logfil, nev, h(1,2), ndigit,
      &           '_saup2: main diagonal of compressed H matrix')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pssaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pssaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pssaupd.f
@@ -652,9 +652,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_saupd: number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_saupd: number of "converged" Ritz values')
          call psvout (comm, logfil, np, workl(Ritz), ndigit,
      &               '_saupd: final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/psseupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/psseupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/psseupd.f
@@ -523,9 +523,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pssgets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pssgets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pssgets.f
@@ -216,8 +216,8 @@ c
       tsgets = tsgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_sgets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_sgets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_sgets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_sgets: NP is')
          call psvout (comm, logfil, kev+np, ritz, ndigit,
      &        '_sgets: Eigenvalues of current H matrix')
          call psvout (comm, logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pzgetv0.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pzgetv0.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pzgetv0.f
@@ -185,7 +185,7 @@ c
       save       first, iseed, inits, iter, msglvl, orth, rnorm0
 c
       Complex*16
-     &           cnorm_buf
+     &           cnorm_buf, buf2(1)
 c
 c     %----------------------%
 c     | External Subroutines |
@@ -332,8 +332,9 @@ c
       first = .FALSE.
       if (bmat .eq. 'G') then
           cnorm_buf = zdotc  (n, resid, 1, workd, 1)
-          call MPI_ALLREDUCE( cnorm_buf, cnorm, 1,
+          call MPI_ALLREDUCE( [cnorm_buf], buf2, 1,
      &          MPI_DOUBLE_COMPLEX , MPI_SUM, comm, ierr )
+          cnorm = buf2(1)
           rnorm0 = sqrt(dlapy2 (dble (cnorm),dimag (cnorm)))
       else if (bmat .eq. 'I') then
            rnorm0 = pdznorm2 ( comm, n, resid, 1)
@@ -393,8 +394,9 @@ c
 c
       if (bmat .eq. 'G') then
          cnorm_buf = zdotc  (n, resid, 1, workd, 1)
-         call MPI_ALLREDUCE( cnorm_buf, cnorm, 1,
+         call MPI_ALLREDUCE( [cnorm_buf], buf2, 1,
      &            MPI_DOUBLE_COMPLEX , MPI_SUM, comm, ierr )
+         cnorm = buf2(1)
          rnorm = sqrt(dlapy2 (dble (cnorm),dimag (cnorm)))
       else if (bmat .eq. 'I') then
          rnorm = pdznorm2 (comm, n, resid, 1)
@@ -405,9 +407,9 @@ c     | Check for further orthogonalizat
 c     %--------------------------------------%
 c
       if (msglvl .gt. 2) then
-          call pdvout  (comm, logfil, 1, rnorm0, ndigit,
+          call pdvout  (comm, logfil, 1, [rnorm0], ndigit,
      &                '_getv0: re-orthonalization ; rnorm0 is')
-          call pdvout  (comm, logfil, 1, rnorm, ndigit,
+          call pdvout  (comm, logfil, 1, [rnorm], ndigit,
      &                '_getv0: re-orthonalization ; rnorm is')
       end if
 c
@@ -439,7 +441,7 @@ c
 c
       if (msglvl .gt. 0) then
          cnorm2 = dcmplx (rnorm,rzero)
-         call pzvout  (comm, logfil, 1, cnorm2, ndigit,
+         call pzvout  (comm, logfil, 1, [cnorm2], ndigit,
      &        '_getv0: B-norm of initial / restarted starting vector')
       end if
       if (msglvl .gt. 2) then
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pznaitr.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pznaitr.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pznaitr.f
@@ -293,7 +293,7 @@ c
      &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
 c
       Complex*16
-     &           cnorm_buf
+     &           cnorm_buf, buf2(1)
 c
 c     %----------------------%
 c     | External Subroutines |
@@ -404,9 +404,9 @@ c     %---------------------------------
  1000 continue
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &                  '_naitr: generating Arnoldi vector number')
-            call pzvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &                  '_naitr: B-norm of the current residual is')
          end if
 c
@@ -426,7 +426,7 @@ c           | basis and continue the ite
 c           %---------------------------------------------------%
 c
             if (msglvl .gt. 0) then
-               call pivout (comm, logfil, 1, j, ndigit,
+               call pivout (comm, logfil, 1, [j], ndigit,
      &                     '_naitr: ****** RESTART AT STEP ******')
             end if
 c
@@ -577,9 +577,10 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
              cnorm_buf = zdotc (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( cnorm_buf, cnorm, 1,
+            call MPI_ALLREDUCE( [cnorm_buf], buf2, 1,
      &           MPI_DOUBLE_COMPLEX, MPI_SUM, comm, ierr )
-             wnorm = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
+            cnorm = buf2(1)
+            wnorm = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
          else if (bmat .eq. 'I') then
              wnorm = pdznorm2(comm, n, resid, 1)
          end if
@@ -653,8 +654,9 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
             cnorm_buf = zdotc (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( cnorm_buf, cnorm, 1,
+            call MPI_ALLREDUCE( [cnorm_buf], buf2, 1,
      &           MPI_DOUBLE_COMPLEX, MPI_SUM, comm, ierr )
+            cnorm = buf2(1)
             rnorm = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
          else if (bmat .eq. 'I') then
             rnorm = pdznorm2(comm, n, resid, 1)
@@ -757,15 +759,16 @@ c        %------------------------------
 c
          if (bmat .eq. 'G') then
              cnorm_buf = zdotc (n, resid, 1, workd(ipj), 1)
-            call MPI_ALLREDUCE( cnorm_buf, cnorm, 1,
+            call MPI_ALLREDUCE( [cnorm_buf], buf2, 1,
      &           MPI_DOUBLE_COMPLEX, MPI_SUM, comm, ierr )
-             rnorm1 = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
+            cnorm = buf2(1)
+            rnorm1 = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
          else if (bmat .eq. 'I') then
              rnorm1 = pdznorm2(comm, n, resid, 1)
          end if
 c
          if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call pivout (comm, logfil, 1, j, ndigit,
+            call pivout (comm, logfil, 1, [j], ndigit,
      &           '_naitr: Iterative refinement for Arnoldi residual')
             if (msglvl .gt. 2) then
                 rtemp(1) = rnorm
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pznapps.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pznapps.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pznapps.f
@@ -283,9 +283,9 @@ c
          sigma = shift(jj)
 c
          if (msglvl .gt. 2 ) then
-            call pivout (comm, logfil, 1, jj, ndigit,
+            call pivout (comm, logfil, 1, [jj], ndigit,
      &               '_napps: shift number.')
-            call pzvout (comm, logfil, 1, sigma, ndigit,
+            call pzvout (comm, logfil, 1, [sigma], ndigit,
      &               '_napps: Value of the shift ')
          end if
 c
@@ -306,9 +306,9 @@ c
             if ( abs(dble(h(i+1,i)))
      &           .le. max(ulp*tst1, smlnum) )  then
                if (msglvl .gt. 0) then
-                  call pivout (comm, logfil, 1, i, ndigit,
+                  call pivout (comm, logfil, 1, [i], ndigit,
      &                 '_napps: matrix splitting at row/column no.')
-                  call pivout (comm, logfil, 1, jj, ndigit,
+                  call pivout (comm, logfil, 1, [jj], ndigit,
      &                 '_napps: matrix splitting with shift number.')
                   call pzvout (comm, logfil, 1, h(i+1,i), ndigit,
      &                 '_napps: off diagonal element.')
@@ -322,9 +322,9 @@ c
    40    continue
 c
          if (msglvl .gt. 2) then
-             call pivout (comm, logfil, 1, istart, ndigit,
+             call pivout (comm, logfil, 1, [istart], ndigit,
      &                   '_napps: Start of current block ')
-             call pivout (comm, logfil, 1, iend, ndigit,
+             call pivout (comm, logfil, 1, [iend], ndigit,
      &                   '_napps: End of current block ')
          end if
 c
@@ -500,7 +500,7 @@ c
      &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
          call pzvout (comm, logfil, 1, h(kev+1,kev), ndigit,
      &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call pivout (comm, logfil, 1, kev, ndigit,
+         call pivout (comm, logfil, 1, [kev], ndigit,
      &               '_napps: Order of the final Hessenberg matrix ')
          if (msglvl .gt. 2) then
             call pzmout (comm, logfil, kev, kev, h, ldh, ndigit,
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pznaup2.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pznaup2.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pznaup2.f
@@ -237,7 +237,7 @@ c
      &           nevbef, nev0 , np0,    eps23
 c
       Double precision
-     &           cmpnorm_buf
+     &           cmpnorm_buf, buf2(1)
 c
 c     %-----------------------%
 c     | Local array arguments |
@@ -401,7 +401,7 @@ c
          iter = iter + 1
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, iter, ndigit,
+            call pivout (comm, logfil, 1, [iter], ndigit,
      &           '_naup2: **** Start of major iteration number ****')
          end if
 c
@@ -414,9 +414,9 @@ c
          np  = kplusp - nev
 c
          if (msglvl .gt. 1) then
-            call pivout (comm, logfil, 1, nev, ndigit,
+            call pivout (comm, logfil, 1, [nev], ndigit,
      &     '_naup2: The length of the current Arnoldi factorization')
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &           '_naup2: Extend the Arnoldi factorization by')
          end if
 c
@@ -443,7 +443,7 @@ c
          update = .false.
 c
          if (msglvl .gt. 1) then
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &           '_naup2: Corresponding B-norm of the residual')
          end if
 c
@@ -674,7 +674,7 @@ c
          end if
 c
          if (msglvl .gt. 0) then
-            call pivout (comm, logfil, 1, nconv, ndigit,
+            call pivout (comm, logfil, 1, [nconv], ndigit,
      &           '_naup2: no. of "converged" Ritz values at this iter.')
             if (msglvl .gt. 1) then
                kp(1) = nev
@@ -714,7 +714,7 @@ c
          end if
 c
          if (msglvl .gt. 2) then
-            call pivout (comm, logfil, 1, np, ndigit,
+            call pivout (comm, logfil, 1, [np], ndigit,
      &                  '_naup2: The number of shifts to apply ')
             call pzvout (comm, logfil, np, ritz, ndigit,
      &                  '_naup2: values of the shifts')
@@ -771,8 +771,9 @@ c
 c
          if (bmat .eq. 'G') then
             cmpnorm_buf = zdotc (n, resid, 1, workd, 1)
-            call MPI_ALLREDUCE( cmpnorm_buf, cmpnorm, 1,
+            call MPI_ALLREDUCE( [cmpnorm_buf], buf2, 1,
      &               MPI_DOUBLE_COMPLEX, MPI_SUM, comm, ierr )
+            cmpnorm = buf2(1)
             rnorm = sqrt(dlapy2(dble(cmpnorm),dimag(cmpnorm)))
          else if (bmat .eq. 'I') then
             rnorm = pdznorm2(comm, n, resid, 1)
@@ -780,7 +781,7 @@ c
          cnorm = .false.
 c
          if (msglvl .gt. 2) then
-            call pdvout (comm, logfil, 1, rnorm, ndigit,
+            call pdvout (comm, logfil, 1, [rnorm], ndigit,
      &      '_naup2: B-norm of residual for compressed factorization')
             call pzmout (comm, logfil, nev, nev, h, ldh, ndigit,
      &        '_naup2: Compressed upper Hessenberg matrix H')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pznaupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pznaupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pznaupd.f
@@ -626,9 +626,9 @@ c
       if (info .eq. 2) info = 3
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, mxiter, ndigit,
+         call pivout (comm, logfil, 1, [mxiter], ndigit,
      &               '_naupd: Number of update iterations taken')
-         call pivout (comm, logfil, 1, np, ndigit,
+         call pivout (comm, logfil, 1, [np], ndigit,
      &               '_naupd: Number of wanted "converged" Ritz values')
          call pzvout  (comm, logfil, np, workl(ritz), ndigit,
      &               '_naupd: The final Ritz values')
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pzneupd.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pzneupd.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pzneupd.f
@@ -558,9 +558,9 @@ c        | caused by incorrect passing o
 c        %-----------------------------------------------------------%
 c
          if (msglvl .gt. 2) then
-             call pivout(comm, logfil, 1, numcnv, ndigit,
+             call pivout(comm, logfil, 1, [numcnv], ndigit,
      &            '_neupd: Number of specified eigenvalues')
-             call pivout(comm, logfil, 1, nconv, ndigit,
+             call pivout(comm, logfil, 1, [nconv], ndigit,
      &            '_neupd: Number of "converged" eigenvalues')
          end if
 c
Index: arpack-ng-3.7.0/PARPACK/SRC/MPI/pzngets.f
===================================================================
--- arpack-ng-3.7.0.orig/PARPACK/SRC/MPI/pzngets.f
+++ arpack-ng-3.7.0/PARPACK/SRC/MPI/pzngets.f
@@ -177,8 +177,8 @@ c
       tcgets = tcgets + (t1 - t0)
 c
       if (msglvl .gt. 0) then
-         call pivout (comm, logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call pivout (comm, logfil, 1, np, ndigit, '_ngets: NP is')
+         call pivout (comm, logfil, 1, [kev], ndigit, '_ngets: KEV is')
+         call pivout (comm, logfil, 1, [np], ndigit, '_ngets: NP is')
          call pzvout (comm, logfil, kev+np, ritz, ndigit,
      &        '_ngets: Eigenvalues of current H matrix ')
          call pzvout (comm, logfil, kev+np, bounds, ndigit,
Index: arpack-ng-3.7.0/scripts/travis_fedora.sh
===================================================================
--- /dev/null
+++ arpack-ng-3.7.0/scripts/travis_fedora.sh
@@ -0,0 +1,51 @@
+#!/bin/sh
+## -e : Make sure all errors cause the script to fail
+## -x be verbose; write what we are doing, as we do it
+set -ex
+## Should we init a container?
+if [ ".$1" = .setup ]
+then
+  # fedora
+  #   note: when you PR, docker-cp provides, in the container, the branch associated with the PR (not master where there's nothing new)
+  #         1. docker create --name mobydick IMAGE CMD        <=> create a container (= instance of image) but container is NOT yet started
+  #         2. docker cp -a ${TRAVIS_BUILD_DIR} mobydick:/tmp <=> copy git repository (CI worker, checkout-ed on PR branch) into the container
+  #                                                               note: docker-cp works only if copy from/to containers (not images)
+  #         3. docker start -a mobydick                       <=> start to run the container (initialized with docker-cp)
+    test . != ".$2" && mpi="$2" || mpi=openmpi
+    test . != ".$3" && version="$3" || version=latest
+    time sudo docker pull registry.fedoraproject.org/fedora:$version ||
+	sudo docker pull fedora:$version
+    time sudo docker create --name mobydick fedora:$version \
+	/tmp/arpack-ng/scripts/travis_fedora.sh $mpi
+    time sudo docker cp -a ${TRAVIS_BUILD_DIR} mobydick:/tmp
+    time sudo docker start -a mobydick ; e=$?
+    exit $e
+fi
+
+test . != ".$1" && mpi="$1" || mpi=openmpi
+
+## If we are called as root, setup everything
+if [ $UID -eq 0 ]
+then
+    time dnf -y upgrade
+    time dnf -y install environment-modules git \
+        gfortran openblas-devel cmake ${mpi}-devel make gcc-c++
+    useradd test
+    chown -R test /tmp
+    sudo -u test $0 $mpi
+## If we are called as normal user, run test
+else
+    . /etc/profile.d/modules.sh
+    module load mpi
+    export OMPI_MCA_rmaps_base_oversubscribe=yes
+    cd /tmp
+    cd arpack-ng
+    git status
+    git log -2
+    mkdir -p build && cd build
+    time cmake -DEXAMPLES=ON -DMPI=ON -DICB=ON ..
+    export VERBOSE=1
+    time make all
+    time make test
+    tail -n 300 ./Testing/Temporary/LastTest.log
+fi
