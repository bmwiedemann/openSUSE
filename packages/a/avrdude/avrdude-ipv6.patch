Index: ser_posix.c
===================================================================
--- ser_posix.c.orig	2013-09-03 13:05:13.078632000 +0200
+++ ser_posix.c	2014-02-10 18:11:24.519081223 +0100
@@ -160,67 +160,76 @@
 static int
 net_open(const char *port, union filedescriptor *fdp)
 {
-  char *hstr, *pstr, *end;
-  unsigned int pnum;
-  int fd;
-  struct sockaddr_in sockaddr;
-  struct hostent *hp;
+  char *hp, *hstr, *pstr;
+  int s, fd, ret = -1;
+  struct addrinfo hints;
+  struct addrinfo *result, *rp;
 
-  if ((hstr = strdup(port)) == NULL) {
+  if ((hstr = hp = strdup(port)) == NULL) {
     fprintf(stderr, "%s: net_open(): Out of memory!\n",
 	    progname);
     return -1;
   }
 
-  if (((pstr = strchr(hstr, ':')) == NULL) || (pstr == hstr)) {
+  /*
+   * As numeric IPv6 addresses use colons as separators, we need to
+   * look for the last colon here, which separates the port number or
+   * service name from the host or IP address.
+   */
+  if (((pstr = strrchr(hstr, ':')) == NULL) || (pstr == hstr)) {
     fprintf(stderr, "%s: net_open(): Mangled host:port string \"%s\"\n",
 	    progname, hstr);
-    free(hstr);
-    return -1;
+    goto error;
   }
 
   /*
-   * Terminate the host section of the description.
+   * Remove brackets from the host part, if present.
    */
-  *pstr++ = '\0';
-
-  pnum = strtoul(pstr, &end, 10);
-
-  if ((*pstr == '\0') || (*end != '\0') || (pnum == 0) || (pnum > 65535)) {
-    fprintf(stderr, "%s: net_open(): Bad port number \"%s\"\n",
-	    progname, pstr);
-    free(hstr);
-    return -1;
-  }
-
-  if ((hp = gethostbyname(hstr)) == NULL) {
-    fprintf(stderr, "%s: net_open(): unknown host \"%s\"\n",
-	    progname, hstr);
-    free(hstr);
-    return -1;
+  if (*hstr == '[' && *(pstr-1) == ']') {
+    hstr++;
+    *(pstr-1) = '\0';
   }
 
-  free(hstr);
+  /*
+   * Terminate the host section of the description.
+   */
+  *pstr++ = '\0';
 
-  if ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
-    fprintf(stderr, "%s: net_open(): Cannot open socket: %s\n",
-	    progname, strerror(errno));
-    return -1;
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_family = AF_UNSPEC;
+  hints.ai_socktype = SOCK_STREAM;
+  s = getaddrinfo(hstr, pstr, &hints, &result);
+
+  if (s != 0) {
+    fprintf(stderr, "%s: net_open(): Cannot resolve host=\"%s\", port=\"%s\": %s\n",
+	    progname, hstr, pstr, gai_strerror(s));
+    goto error;
+  }
+  for (rp = result; rp != NULL; rp = rp->ai_next) {
+    fd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
+    if (fd == -1) {
+      /* This one failed, loop over */
+      continue;
+    }
+    if (connect(fd, rp->ai_addr, rp->ai_addrlen) != -1) {
+      /* Success, we are connected */
+      break;
+    }
+    close(fd);
   }
-
-  memset(&sockaddr, 0, sizeof(struct sockaddr_in));
-  sockaddr.sin_family = AF_INET;
-  sockaddr.sin_port = htons(pnum);
-  memcpy(&(sockaddr.sin_addr.s_addr), hp->h_addr, sizeof(struct in_addr));
-
-  if (connect(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr))) {
-    fprintf(stderr, "%s: net_open(): Connect failed: %s\n",
+  if (rp == NULL) {
+    fprintf(stderr, "%s: net_open(): Cannot connect: %s\n",
 	    progname, strerror(errno));
-    return -1;
   }
-
-  fdp->ifd = fd;
-  return 0;
+  else {
+    fdp->ifd = fd;
+    ret = 0;
+  }
+  freeaddrinfo(result);
+
+error:
+  free(hp);
+  return ret;
 }
 
 
Index: avrdude.1
===================================================================
--- avrdude.1.orig	2014-01-17 17:54:33.433671000 +0100
+++ avrdude.1	2014-02-10 18:58:24.994242025 +0100
@@ -502,6 +502,10 @@
 on
 .Ar host
 is established.
+Square brackets may be placed around
+.Ar host
+to improve readability, for numeric IPv6 addresses (e.g.
+.Li net:[2606:2800::42]:1337 ) .
 The remote endpoint is assumed to be a terminal or console server
 that connects the network stream to a local serial port where the
 actual programmer has been attached to.
Index: doc/avrdude.texi
===================================================================
--- doc/avrdude.texi.orig	2014-01-17 17:54:33.433671000 +0100
+++ doc/avrdude.texi	2014-02-10 19:13:59.136187968 +0100
@@ -549,6 +549,9 @@
 In this case, instead of trying to open a local device, a TCP
 network connection to (TCP) @var{port} on @var{host}
 is established.
+Square brackets may be placed around @var{host} to improve
+readability for numeric IPv6 addresses (e.g.
+@code{net:[2606:2800::42]:1337}).
 The remote endpoint is assumed to be a terminal or console server
 that connects the network stream to a local serial port where the
 actual programmer has been attached to.
