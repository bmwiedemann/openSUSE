#!/bin/sh
#
# Copyright (c) 1996, 1997, 1998 S.u.S.E. GmbH
# Copyright (c) 1998, 1999, 2000, 2001 SuSE GmbH
# Copyright (c) 2002, 2003, (2004?) SuSE Linux AG
# Copyright (c) 2004(?), 2005, 2006, 2007, 2008 SUSE Linux Products GmbH
#
# Authors: Rolf Haberrecker <apache@suse.de>, 2001
#          Peter Poeml <apache@suse.de>, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011.
#          Roman Drahtmueller <draht@suse.de>, 2010, 2011, 2012.
#
#
# /etc/init.d/apache2
#
### BEGIN INIT INFO
# Provides:			apache apache2 httpd
# Required-Start:		$local_fs $remote_fs $network 
# Should-Start:			$named $time postgresql sendmail mysql ypclient dhcp radiusd
# Should-Stop:			$named $time postgresql sendmail mysql ypclient dhcp radiusd
# Required-Stop:		$local_fs $remote_fs $network
# Default-Start:		3 5
# Default-Stop:			0 1 2 6
# X-Interactive:		true
# Short-Description:		Apache 2 HTTP Server
# Description:			Start the Apache HTTP daemon
### END INIT INFO

pname=apache2
: ${sysconfdir:=/etc/$pname}
: ${apache_link:=/usr/sbin/httpd}
: ${sysconfig_apache:=/etc/sysconfig/$pname}
: ${pidfile:=/var/run/httpd.pid}
: ${logdir:=/var/log/$pname}
: ${homedir:=/var/lib/$pname}

#
# load the configuration
#

#
# Note about ulimits:
# if you want to set ulimits, e.g. to increase the max number of open file handle, 
# or to allow core files, you can do so by editing /etc/sysconfig/apache2 and
# simply write the ulimit commands into that file.
# Example:
# ulimit -n 16384
# ulimit -H -n 16384
# ulimit -c unlimited
# See the output of "help ulimit" in the bash, or "man 1 ulimit".
#
test -s /etc/rc.status && . /etc/rc.status && rc_reset

. /usr/share/$pname/load_configuration
export ${!APACHE_*}

httpd_conf=${APACHE_HTTPD_CONF:-$sysconfdir/httpd.conf}

apache_bin=$(/usr/share/$pname/find_mpm 2>/dev/null)

test -L $apache_link && apache_bin=$(readlink $apache_link)

if [ -z "$APACHE_MPM" ]; then 
	APACHE_MPM=${apache_bin##*-}
fi

if ! [ -x $apache_bin ]; then
	echo >&2 ${warn}$apache_bin-$APACHE_MPM is not a valid httpd binary. 
	echo >&2 Check your APACHE_MPM setting in /etc/sysconfig/$pname. $norm
	rc_failed 5
	rc_status -v1
	rc_exit
fi

# a proper home should be set, otherwise the server might end up 
# with HOME=/root and some script might try to use that
HOME=$homedir

get_server_flags()
{
	unset server_flags
	case "$action" in startssl) server_flags="-DSSL";; esac
	for i in $APACHE_SERVER_FLAGS; do
		case $i in 
		-D)	;;
		-D*)	server_flags="$server_flags $i";;
		*)	server_flags="$server_flags -D$i";;
		esac
	done
	server_flags="$server_flags -DSYSCONFIG -C 'Include /etc/apache2/sysconfig.d/'"
}

action="$1"
case "$action" in
    stop|try-restart|*status*|probe)
	;;
    *)
	shift; get_server_flags
	${get_module_list_done:=false} || /usr/share/$pname/get_module_list && export get_module_list_done=true
	${get_includes:=false} || /usr/share/$pname/get_includes && export get_includes_done=true
	;;
esac

#
# main part 
#
case "$action" in
    start*)
	if [ -e $pidfile ]; then
	        $0 status &>/dev/null
		ret=$?
		if [ $ret = 1 ]; then
				echo "Warning: found stale pidfile (unclean shutdown?)"
		elif [ $ret = 0 ]; then
				echo "Apache is already running ($pidfile)"
				rc_failed $ret
				rc_status -v1
				rc_exit
		fi
	fi

	echo -n "Starting httpd (${APACHE_MPM:-${apache_bin#*-}}) "
	cmdline=$(echo $apache_bin -f $httpd_conf $server_flags "$@")
	if eval $cmdline -t > $logdir/rc$pname.out 2>&1 ; then
		export -n ${!APACHE_*}
		eval startproc -f -t ${APACHE_START_TIMEOUT:-2} $cmdline
		ret=$?

		if test -t 1 && stty -a 2>/dev/null | grep -q -- -echo\ ; then 
			# this means that apache was still waiting for a passphrase to be entered 
			stty echo 2>/dev/null
			echo;echo 
			echo >&2 An SSL passphrase has not been entered within ${APACHE_START_TIMEOUT:-<not set>} seconds.
			echo >&2 To increase this timeout, adjust APACHE_START_TIMEOUT in $sysconfig_apache .
			# this surely means that apache won't start, despite it looked good to startproc
			killall $apache_bin
			echo >&2 "Trying to start the server without SSL (-D NOSSL)."
			$0 start "$@" -D NOSSL
			# rc_failed 1
			# rc_status -v1
			# rc_exit
		else
			rc_failed $ret
			rc_status -v
		fi
	else
		if [ "$link" = "$base" ] ; then
			cat $logdir/rc$pname.out
			echo >&2
			echo >&2 The command line was:
			echo >&2 $cmdline
			echo >&2
		else
			echo -e -n "\nsee $logdir/rc$pname.out for details\n";
		fi
		rc_failed 1
		rc_status -v1
        fi
	;;
    stop)
	echo -n "Shutting down httpd "
        if [ ! -f $pidfile -a -f $pidfile.rpmsave ]; then mv $pidfile.rpmsave $pidfile; fi
	if ! [ -f $pidfile ]; then
		echo -n "(not running)"
	else
		pid=$(<$pidfile)
		# re-read exe symlink, it could be (deleted) in the meanwhile.
		apache_bin=$(readlink /proc/$pid/exe 2>/dev/null)
		kill -TERM $pid 2>/dev/null
		case $? in
		    1)  echo -n "(not running)";;
		    0)  # wait until the processes are gone (the parent is the last one)
			echo -n "(waiting for all children to terminate) "
			for ((wait=0; wait<120; wait++)); do
				if test -f $pidfile; then 
					usleep 500000
					continue
				fi
				if ! test -f /proc/$pid/exe; then
					break
				fi
				if test "$(readlink /proc/$pid/exe 2>/dev/null)" = "$apache_bin"; then 
					usleep 500000
				else
					break
				fi

			done
			;;
		esac
	fi

	rc_status -v
	;;
    stop-graceful)
        echo "Shutting down httpd gracefully (SIGWINCH)"
        if ! [ -f $pidfile ]; then
                echo -n "(not running)"
        else
                pid=$(<$pidfile)
                kill -WINCH $pid 2>/dev/null
                case $? in
                    1)  echo -n "(not running)";;
                    0)  # wait until the pidfile is gone. The parent stays there, but closes the listen ports.
                        echo -n "(waiting for parent to close listen ports and remove pidfile) "
                        for ((wait=0; wait<120; wait++)); do
                                if test -f $pidfile; then
                                        usleep 500000
                                        continue
                                else
                                        break
                                fi
                        done
                        ;;
                esac
        fi

	rc_status -v
	;;
    try-restart)
	## Do a restart only if the service was active before.
	## Note: try-restart is now part of LSB (as of 1.9).
	## RH has a similar command named condrestart.
	$0 status
	if test $? = 0; then
		$0 restart
	else
		rc_reset        # Not running is not a failure.
	fi
	# Remember status and be quiet
	rc_status
	;;
    restart)
	$0 configtest "$@" || { rc_failed $?; rc_exit; }

	if $0 status &>/dev/null; then 
		$0 stop
	fi
	$0 start "$@"
	# Remember status and be quiet
	rc_status
	;;
    restart-hup)
	$0 configtest "$@" || { rc_failed $?; rc_exit; }

	if $0 status &>/dev/null; then 
		echo -n "Restarting httpd (SIGHUP)"
		kill -HUP $(<$pidfile) || return=$rc_failed
	else 
		$0 start "$@"
	fi
	# Remember status and be quiet
        rc_status -v
	;;
    restart-graceful)
	$0 configtest "$@" || { rc_failed $?; rc_exit; }

	if $0 status &>/dev/null; then 
		$0 stop-graceful "$@"
		$0 start "$@"
	else 
		$0 start "$@"
	fi
	# Remember status and be quiet
        rc_status
	;;
    reload|force-reload|graceful)
	# check if there is a deleted binary. If there is, then logrotate
	# or other occasions will fail to reload, as dlopen(3) of apache
	# modules is prone to fail due to symbol mismatches.
	# in this case, we only complain and fail.
	if [ ! -f $pidfile -a -f $pidfile.rpmsave ]; then mv $pidfile.rpmsave $pidfile; fi
	executable=$( readlink /proc/$(cat $pidfile)/exe 2> /dev/null )
	case "$executable" in
		*httpd*delete*)
			echo -n "Reload httpd after package update: ignoring request. Please do a manual restart explicitly! "
			rc_failed 1
			rc_status -v
			rc_exit
		;;
		*)
		;;
	esac

	echo -n "Reload httpd (graceful restart)"

	cmdline=$(echo $apache_bin -f $httpd_conf $server_flags "$@")
	if eval $cmdline -t &> $logdir/rc$pname.out; then
		killproc -USR1 $apache_bin || return=$rc_failed
		rc_status -v
	else
		if [ "$link" = "$base" ] ; then
			echo -e -n "\n\n"
			cat $logdir/rc$pname.out
			echo >&2
			echo >&2 The command line was:
			echo >&2 $cmdline
			echo >&2
		else
			echo -e -n "\nsee $logdir/rc$pname.out for details\n";
		fi
		rc_failed 6
		rc_status -v1
        fi
	;;
    status)
        if [ ! -f $pidfile -a -f $pidfile.rpmsave ]; then mv $pidfile.rpmsave $pidfile; fi
        echo -n "Checking for httpd: "
	# we don't use checkproc here since it is confused when we exchange the binaries
	if ! [ -f $pidfile ]; then
		# not running
		rc_failed 3
	elif [ -s $pidfile -a -d /proc/$(<$pidfile) ]; then
		# running
		:
	else
		# stale pid file
		rc_failed 1
		#rm -f $pidfile
	fi
	rc_status -v
	;;
    probe)
        ## Optional: Probe for the necessity of a reload,
        ## give out the argument which is required for a reload.

	for i in $httpd_conf \
		$APACHE_CONF_INCLUDE_FILES \
		$APACHE_CONF_INCLUDE_DIRS 
	do
		if [ $i -nt $pidfile ]; then
			echo reload
			break
		fi
	done
        ;;

    conf*|test|syntax|check)
	cmdline=$(echo $apache_bin -f $httpd_conf $server_flags "$@")
	eval $cmdline -t 
	rc_failed $?
	rc_exit
	;;

    extr*)
	cmdline=$(echo $apache_bin -f $httpd_conf $server_flags "$@")
	out=$(su - nobody -c "$cmdline" 2>&1)
	case $out in 
		*make_sock:\ could\ not\ bind\ to\ address*) echo Syntax: OK; rc_failed=0;;
		*) echo Syntax: NOT OK:; echo $out; rc_failed=1;;
	esac
	rc_exit
	;;

    server-status)
	apachectl status
	;;

    full-server-status|fullstatus)
	apachectl fullstatus
	;;

    *)
    cat >&2 <<-EOF 
	Usage: $0 <command> <server flags>

	where <command> is one of:
	        start              - start httpd
	        startssl           - start httpd with -DSSL
	        stop               - stop httpd (sending SIGTERM to parent)
	        try-restart        - stop httpd and if this succeeds (i.e. if
	                             it was running before), start it again.

	        status             - check whether httpd is running

	        restart            - stop httpd if running; start httpd
	        restart-graceful   - stop httpd gracefully if running; start httpd
	        reload|graceful    - do a graceful restart by sending a SIGUSR1, or 
	                             start if not running
	        stop-graceful      - stop httpd (sending SIGWINCH to parent)

	        configtest         - do a configuration syntax test
	        extreme-configtest - try to run httpd as nobody (detects more errors 
	                             by actually loading the configuration, but cannot 
	                             read SSL certificates)
	        probe              - probe for the necessity of a reload, give 
	                             out the argument which is required for a reload.
	                             (by comparing conf files with pidfile timestamp)

	        full-server-status - dump a full status screen; requires lynx or w3m 
	                             and mod_status enabled
	        server-status      - dump a short status screen; requires lynx or w3m
	                             and mod_status enabled

	        help               - this screen
	
	optional server flags are passed through to httpd.
	
	EOF
    exit 1
esac


# Inform the caller not only verbosely and set an exit status.
rc_exit
