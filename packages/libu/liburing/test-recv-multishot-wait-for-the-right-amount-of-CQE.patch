From: Jens Axboe <axboe@kernel.dk>
Date: Tue, 6 Feb 2024 13:17:14 -0700
Subject: test/recv-multishot: wait for the right amount of CQEs
Git-repo: git://git.kernel.dk/liburing.git
Git-commit: a1d5e4b863a60af93d0cab9d4bbf578733337a90
Patch-mainline: 2.6
References: kernel 6.9

This test assumes that all task_work is a) has already arrived, and
b) will always be fully run even though the app asked for less, which
can lead to premature checking of CQEs and hitting end-of-CQEs before
it should.

Fix it up to wait for what it needs.

Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 test/recv-multishot.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/test/recv-multishot.c b/test/recv-multishot.c
index f66f1319..39983e8d 100644
--- a/test/recv-multishot.c
+++ b/test/recv-multishot.c
@@ -57,7 +57,7 @@ static int test(struct args *args)
 	int const N = 8;
 	int const N_BUFFS = N * 64;
 	int const N_CQE_OVERFLOW = 4;
-	int const min_cqes = 2;
+	int const min_cqes = args->early_error ? 2 : 8;
 	int const NAME_LEN = sizeof(struct sockaddr_storage);
 	int const CONTROL_LEN = CMSG_ALIGN(sizeof(struct sockaddr_storage))
 					+ sizeof(struct cmsghdr);
@@ -237,7 +237,11 @@ static int test(struct args *args)
 	usleep(1000);
 
 	if ((args->stream && !early_error) || recv_cqes < min_cqes) {
-		ret = io_uring_wait_cqes(&ring, &cqe, 1, &timeout, NULL);
+		unsigned int to_wait = 1;
+
+		if (recv_cqes < min_cqes)
+			to_wait = min_cqes - recv_cqes;
+		ret = io_uring_wait_cqes(&ring, &cqe, to_wait, &timeout, NULL);
 		if (ret && ret != -ETIME) {
 			fprintf(stderr, "wait final failed: %d\n", ret);
 			ret = -1;
-- 
2.44.0

