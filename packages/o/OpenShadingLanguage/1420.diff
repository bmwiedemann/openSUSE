Index: b/INSTALL.md
===================================================================
--- a/INSTALL.md
+++ b/INSTALL.md
@@ -16,7 +16,7 @@ NEW or CHANGED dependencies since the la
 
 * A suitable C++11 compiler to build OSL itself, which may be any of:
    - GCC 4.8.5 or newer (tested through gcc 11)
-   - Clang 3.4 or newer (tested through clang 12)
+   - Clang 3.4 or newer (tested through clang 13)
    - Microsoft Visual Studio 2015 or newer
    - Intel C++ compiler icc version 13 (?) or newer
 
@@ -43,7 +43,7 @@ NEW or CHANGED dependencies since the la
     DYLD_LIBRARY_PATH on OS X) and then OSL's build scripts will be able
     to find it.
 
-* **[LLVM](http://www.llvm.org) 7, 8, 9, 10, 11, or 12**, including
+* **[LLVM](http://www.llvm.org) 7, 8, 9, 10, 11, 12, or 13**, including clang
   clang libraries.
 
   Note that LLVM 10+ is not compatible with C++11, and requires C++14 or
@@ -73,13 +73,13 @@ Build process
 
 Here are the steps to check out, build, and test the OSL distribution:
 
-0. Install and build dependencies.
+1. Install and build dependencies.
 
-1. Check out a copy of the source code from the Git repository:
+2. Check out a copy of the source code from the Git repository:
 
         git clone https://github.com/AcademySoftwareFoundation/OpenShadingLanguage.git osl
 
-2. Change to the distribution directory and 'make'
+3. Change to the distribution directory and 'make'
 
         cd osl
         make
@@ -95,7 +95,7 @@ Here are the steps to check out, build,
    "make STOP_ON_WARNING=0", that create a build that will only stop for
    full errors, not warnings.
 
-3. After compilation, you'll end up with a full OSL distribution in
+4. After compilation, you'll end up with a full OSL distribution in
    dist/ARCH, where ARCH is the architecture you are building on, one of
    "linux", "linux64", "macosx", "windows", or "windows64".
 
@@ -103,14 +103,14 @@ Here are the steps to check out, build,
    instead type 'make debug' at the top level, you will end up with
    a debug build (no optimization, full symbols) in "dist/ARCH.debug".
 
-4. Add the "dist/ARCH/bin" to your $PATH, and "dist/ARCH/lib" to your
+5. Add the "dist/ARCH/bin" to your $PATH, and "dist/ARCH/lib" to your
    $LD_LIBRAY_PATH (or $DYLD_LIBRARY_PATH on OS X), or copy the contents
    of those files to appropriate directories.  Public include files
    (those needed when building applications that incorporate OSL)
    can be found in "dist/ARCH/include", and documentation can be found
    in "dist/ARCH/share/doc".
 
-5. After building (and setting your library path), you can run the
+6. After building (and setting your library path), you can run the
    test suite with:
 
         make test
Index: b/src/include/OSL/llvm_util.h
===================================================================
--- a/src/include/OSL/llvm_util.h
+++ b/src/include/OSL/llvm_util.h
@@ -577,6 +577,9 @@ public:
                     llvm::Value *src, int srcalign, int len);
 
     /// Dereference a pointer:  return *ptr
+    /// type is the type of the thing being pointed to.
+    llvm::Value *op_load (llvm::Type* type, llvm::Value *ptr);
+    // Blind pointer version that's deprecated as of LLVM13:
     llvm::Value *op_load (llvm::Value *ptr);
 
     /// Store to a dereferenced pointer:   *ptr = val
@@ -589,17 +592,25 @@ public:
 
     /// Generate a GEP (get element pointer) where the element index is an
     /// llvm::Value, which can be generated from either a constant or a
-    /// runtime-computed integer element index.
+    /// runtime-computed integer element index. `type` is the type of the data
+    /// we're retrieving.
+    llvm::Value *GEP (llvm::Type* type, llvm::Value *ptr, llvm::Value *elem);
+    // Blind pointer version that's deprecated as of LLVM13:
     llvm::Value *GEP (llvm::Value *ptr, llvm::Value *elem);
 
     /// Generate a GEP (get element pointer) with an integer element
-    /// offset.
+    /// offset. `type` is the type of the data we're retrieving.
+    llvm::Value *GEP (llvm::Type* type, llvm::Value *ptr, int elem);
+    // Blind pointer version that's deprecated as of LLVM13:
     llvm::Value *GEP (llvm::Value *ptr, int elem);
 
     /// Generate a GEP (get element pointer) with two integer element
     /// offsets.  This is just a special (and common) case of GEP where
     /// we have a 2-level hierarchy and we have fixed element indices
-    /// that are known at compile time.
+    /// that are known at compile time.  `type` is the type of the data we're
+    /// retrieving.
+    llvm::Value *GEP (llvm::Type* type, llvm::Value *ptr, int elem1, int elem2);
+    // Blind pointer version that's deprecated as of LLVM13:
     llvm::Value *GEP (llvm::Value *ptr, int elem1, int elem2);
 
     // Arithmetic ops.  It auto-detects the type (int vs float).
Index: b/src/liboslexec/llvm_util.cpp
===================================================================
--- a/src/liboslexec/llvm_util.cpp
+++ b/src/liboslexec/llvm_util.cpp
@@ -2592,9 +2592,17 @@ LLVM_Util::op_memcpy (llvm::Value *dst,
 
 
 llvm::Value *
+LLVM_Util::op_load (llvm::Type* type, llvm::Value* ptr)
+{
+    return builder().CreateLoad (type, ptr);
+}
+
+
+
+llvm::Value *
 LLVM_Util::op_load (llvm::Value *ptr)
 {
-    return builder().CreateLoad (ptr);
+    return op_load(ptr->getType()->getPointerElementType(), ptr);
 }
 
 
@@ -2608,9 +2616,26 @@ LLVM_Util::op_store (llvm::Value *val, l
 
 
 llvm::Value *
+LLVM_Util::GEP (llvm::Type* type, llvm::Value* ptr, llvm::Value* elem)
+{
+    return builder().CreateGEP(type, ptr, elem);
+}
+
+
+
+llvm::Value *
 LLVM_Util::GEP (llvm::Value *ptr, llvm::Value *elem)
 {
-    return builder().CreateGEP (ptr, elem);
+    return GEP(ptr->getType()->getScalarType()->getPointerElementType(), ptr,
+               elem);
+}
+
+
+
+llvm::Value *
+LLVM_Util::GEP (llvm::Type* type, llvm::Value* ptr, int elem)
+{
+    return builder().CreateConstGEP1_32(type, ptr, elem);
 }
 
 
@@ -2618,7 +2643,16 @@ LLVM_Util::GEP (llvm::Value *ptr, llvm::
 llvm::Value *
 LLVM_Util::GEP (llvm::Value *ptr, int elem)
 {
-    return builder().CreateConstGEP1_32 (ptr, elem);
+    return GEP(ptr->getType()->getScalarType()->getPointerElementType(), ptr,
+               elem);
+}
+
+
+
+llvm::Value *
+LLVM_Util::GEP(llvm::Type* type, llvm::Value* ptr, int elem1, int elem2)
+{
+    return builder().CreateConstGEP2_32 (type, ptr, elem1, elem2);
 }
 
 
@@ -2626,7 +2660,8 @@ LLVM_Util::GEP (llvm::Value *ptr, int el
 llvm::Value *
 LLVM_Util::GEP (llvm::Value *ptr, int elem1, int elem2)
 {
-    return builder().CreateConstGEP2_32 (nullptr, ptr, elem1, elem2);
+    return GEP(ptr->getType()->getScalarType()->getPointerElementType(), ptr,
+               elem1, elem2);
 }
 
 
Index: b/src/liboslexec/runtimeoptimize.cpp
===================================================================
--- a/src/liboslexec/runtimeoptimize.cpp
+++ b/src/liboslexec/runtimeoptimize.cpp
@@ -2301,7 +2301,6 @@ RuntimeOptimizer::optimize_instance ()
     // passes, but we have a hard cutoff just to be sure we don't
     // ever get into an infinite loop from an unforseen cycle where we
     // end up inadvertently transforming A => B => A => etc.
-    int totalchanged = 0;
     int reallydone = 0;   // Force a few passes after we think we're done
     int npasses = shadingsys().opt_passes();
     for (m_pass = 0;  m_pass < npasses;  ++m_pass) {
@@ -2362,7 +2361,6 @@ RuntimeOptimizer::optimize_instance ()
         // If nothing changed, we're done optimizing.  But wait, it may be
         // that after re-tracking variable lifetimes, we can notice new
         // optimizations!  So force another pass, then we're really done.
-        totalchanged += changed;
         if (changed < 1) {
             if (++reallydone > 3)
                 break;
