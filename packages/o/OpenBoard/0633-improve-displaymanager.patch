From aef0bfb171e9df1206381ebba95b95830212c576 Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Tue, 7 Jun 2022 09:28:21 +0200
Subject: [PATCH 01/12] fix: validation of screen configuration

- never reject
- make inacceptable input status visible by red border
- fixup list when screen label is pressed
- improve preferences controller
- use background color to show invalid entry
- longer fade-out timer for screen labels (better focus handling?)
- allow empty input for default configuration
---
 src/core/UBPreferencesController.cpp | 87 +++++++++++++++++-----------
 src/core/UBPreferencesController.h   |  3 +-
 2 files changed, 55 insertions(+), 35 deletions(-)

diff --git a/src/core/UBPreferencesController.cpp b/src/core/UBPreferencesController.cpp
index c63438b0f..2b40e4822 100644
--- a/src/core/UBPreferencesController.cpp
+++ b/src/core/UBPreferencesController.cpp
@@ -52,6 +52,21 @@ qreal UBPreferencesController::sSliderRatio = 10.0;
 qreal UBPreferencesController::sMinPenWidth = 0.5;
 qreal UBPreferencesController::sMaxPenWidth = 50.0;
 
+// convenience function to convert between screen list as QString and QStringList
+QStringList splitScreenList(const QString& input)
+{
+    QStringList screenNames = input.split(',');
+
+    for (QString& entry : screenNames)
+    {
+        entry = entry.trimmed();
+    }
+
+    screenNames.removeAll("");
+
+    return screenNames;
+}
+
 
 UBPreferencesDialog::UBPreferencesDialog(UBPreferencesController* prefController, QWidget* parent,Qt::WindowFlags f)
     :QDialog(parent,f)
@@ -125,7 +140,7 @@ void UBPreferencesController::wire()
     connect(mPreferencesUI->screenList, &QLineEdit::textChanged, [this,settings](const QString &text){
         if (mPreferencesUI->screenList->hasAcceptableInput())
         {
-            settings->appScreenList->set(text.split(','));
+            settings->appScreenList->set(splitScreenList(text));
         }
     });
 
@@ -776,7 +791,7 @@ void UBScreenListLineEdit::focusInEvent(QFocusEvent *focusEvent)
 
     if (mScreenLabels.empty())
     {
-        QStringList screenNames = text().split(',', QString::SkipEmptyParts);
+        QStringList screenNames = splitScreenList(text());
 
         QList<QScreen*> screens = UBApplication::displayManager->availableScreens();
         QStringList availableScreenNames;
@@ -787,6 +802,7 @@ void UBScreenListLineEdit::focusInEvent(QFocusEvent *focusEvent)
             QPushButton* button = new QPushButton(this);
             button->setWindowFlag(Qt::FramelessWindowHint, true);
             button->setWindowFlag(Qt::WindowStaysOnTopHint, true);
+            button->setWindowFlag(Qt::X11BypassWindowManagerHint, true);
             button->setWindowFlag(Qt::Window, true);
             button->setText(screen->name());
             QFont font;
@@ -825,22 +841,25 @@ void UBScreenListLineEdit::focusOutEvent(QFocusEvent *focusEvent)
         qDeleteAll(mScreenLabels);
         mScreenLabels.clear();
     });
-    mFadeOutTimer->start(250);
+    mFadeOutTimer->start(500);
 }
 
 void UBScreenListLineEdit::addScreen()
 {
     QPushButton* button = dynamic_cast<QPushButton*>(sender());
 
-    if (button && (text().isEmpty() || hasAcceptableInput()))
+    if (button)
     {
-        if (text().isEmpty())
+        QString list = text();
+        mValidator->fixup(list);
+
+        if (list.isEmpty())
         {
             setText(button->text());
         }
         else
         {
-            setText(text() + "," + button->text());
+            setText(list + "," + button->text());
         }
 
         button->setEnabled(false);
@@ -852,7 +871,7 @@ void UBScreenListLineEdit::addScreen()
 
 void UBScreenListLineEdit::onTextChanged(const QString &input)
 {
-    QStringList screenNames = input.split(',', QString::SkipEmptyParts);
+    QStringList screenNames = splitScreenList(input);
 
     for (QPushButton* button : mScreenLabels)
     {
@@ -872,8 +891,6 @@ void UBScreenListLineEdit::onTextChanged(const QString &input)
             }
         }
 
-        qDebug() << "Create QCompleter" << model;
-
         if (!mCompleter)
         {
             mCompleter = new QCompleter(model, this);
@@ -884,6 +901,16 @@ void UBScreenListLineEdit::onTextChanged(const QString &input)
             mCompleter->setModel(new QStringListModel(model, mCompleter));
         }
     }
+
+    // user indication of acceptable input
+    if (hasAcceptableInput())
+    {
+        setStyleSheet("");
+    }
+    else
+    {
+        setStyleSheet("QLineEdit { background-color: #FFB3C8; }");
+    }
 }
 
 UBStringListValidator::UBStringListValidator(QStringList list, QObject *parent)
@@ -893,40 +920,32 @@ UBStringListValidator::UBStringListValidator(QStringList list, QObject *parent)
 
 }
 
-QValidator::State UBStringListValidator::validate(QString &input, int &) const
+void UBStringListValidator::fixup(QString &input) const
 {
-    if (input.isEmpty())
+    // remove invalid tokens from list
+    QStringList inputList = splitScreenList(input);
+    QStringList outputList;
+
+    for (const QString& token : inputList)
     {
-        return Intermediate;
+        if (mList.contains(token))
+        {
+            outputList << token;
+        }
     }
 
+    input = outputList.join(',');
+}
+
+QValidator::State UBStringListValidator::validate(QString &input, int &) const
+{
     bool ok = true;
-    bool wasOk = false;
-    QStringList inputList = input.split(',', QString::SkipEmptyParts);
+    QStringList inputList = splitScreenList(input);
 
     for (const QString& token : inputList)
     {
-        wasOk = ok;
         ok &= mList.contains(token) && inputList.count(token) == 1;
     }
 
-    if (ok)
-    {
-        return Acceptable;
-    }
-    else if (wasOk && !inputList.empty())
-    {
-        // check if last token is at least a prefix of any valid input
-        QString lastToken = inputList.last();
-
-        for (const QString& item : mList)
-        {
-            if (!inputList.contains(item) && item.startsWith(lastToken))
-            {
-                return Intermediate;
-            }
-        }
-    }
-
-    return Invalid;
+    return ok ? Acceptable : Intermediate;
 }
diff --git a/src/core/UBPreferencesController.h b/src/core/UBPreferencesController.h
index 874cdbd76..9bc49769c 100644
--- a/src/core/UBPreferencesController.h
+++ b/src/core/UBPreferencesController.h
@@ -160,7 +160,8 @@ class UBStringListValidator : public QValidator
     UBStringListValidator(QStringList list, QObject* parent = nullptr);
     virtual ~UBStringListValidator() = default;
 
-    virtual QValidator::State validate(QString &input, int &pos) const;
+    virtual void fixup(QString& input) const;
+    virtual QValidator::State validate(QString& input, int& pos) const;
 
 private:
     QStringList mList;

From 03050cf3136911e95c598719081aa43e033388b4 Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Tue, 7 Jun 2022 19:12:57 +0200
Subject: [PATCH 02/12] fix: improve UBDisplayManager

- set initial window size in window mode
- use the UBPlatformUtils.showFullScreen for control widget only
  - others must be unconditionally full screen
- position screens after some delay
  - to override other decisions of the window manager
- retain window size and position when switching screens in window mode
---
 src/core/UBDisplayManager.cpp | 77 ++++++++++++++++++++++++++---------
 1 file changed, 58 insertions(+), 19 deletions(-)

diff --git a/src/core/UBDisplayManager.cpp b/src/core/UBDisplayManager.cpp
index de324014c..e06c01692 100644
--- a/src/core/UBDisplayManager.cpp
+++ b/src/core/UBDisplayManager.cpp
@@ -93,10 +93,12 @@ void UBDisplayManager::initScreenIndexes()
         emit availableScreenCountChanged(screens.count());
     }
 
-    QStringList screenList = UBSettings::settings()->appScreenList->get().toStringList();
+    QVariant appScreenList = UBSettings::settings()->appScreenList->get();
+    QStringList screenList = appScreenList.toStringList();
 
-    if (screenList.empty())
+    if (!appScreenList.isValid())
     {
+        // no entry in configuration files
         // "old" configuration mode
         bool swapScreens = UBSettings::settings()->swapControlAndDisplayScreens->get().toBool();
 
@@ -138,8 +140,19 @@ void UBDisplayManager::initScreenIndexes()
     }
     else
     {
-        // "new" configuration mode using list of screen names
+        // converting an empty entry to a QStringList creates a list with one empty QString
+        if (appScreenList.toStringList().isEmpty() || appScreenList.toStringList().at(0).isEmpty())
+        {
+            screenList.clear();
+
+            // explicitly stored an empty list, take all available screens
+            for (QScreen* screen : mAvailableScreens)
+            {
+                screenList << screen->name();
+            }
+        }
 
+        // "new" configuration mode using list of screen names
         // first, create a map of screens by name
         QMap<QString,QScreen*> screenByName;
 
@@ -199,11 +212,10 @@ int UBDisplayManager::numScreens()
 int UBDisplayManager::numPreviousViews()
 {
     int previousViews = 0;
-    ScreenRole role(ScreenRole::Previous1);
 
-    for (int i = 0; i < 5; ++i)
+    for (ScreenRole role = ScreenRole::Previous1; role <= ScreenRole::Previous5; ++role)
     {
-        if (mScreensByRole.contains(role++))
+        if (mScreensByRole.contains(role))
         {
             ++previousViews;
         }
@@ -215,8 +227,17 @@ int UBDisplayManager::numPreviousViews()
 
 void UBDisplayManager::setControlWidget(QWidget* pControlWidget)
 {
-    if(hasControl() && pControlWidget)
+    if (hasControl() && pControlWidget)
+    {
+        // set an initial geometry for window mode
+        QScreen* controlScreen = mScreensByRole[ScreenRole::Control];
+        QRect geometry = controlScreen->geometry();
+        geometry.setSize(geometry.size() - QSize(150, 150));
+        geometry.moveTo(50, 50);
+        pControlWidget->setGeometry(geometry);
+
         mWidgetsByRole[ScreenRole::Control] = pControlWidget;
+    }
 }
 
 void UBDisplayManager::setDesktopWidget(QWidget* pDesktopWidget )
@@ -241,7 +262,7 @@ void UBDisplayManager::setDisplayWidget(QWidget* pDisplayWidget)
         if (mScreensByRole.contains(ScreenRole::Display))
         {
             mWidgetsByRole[ScreenRole::Display]->setGeometry(mScreensByRole[ScreenRole::Display]->geometry());
-            UBPlatformUtils::showFullScreen(mWidgetsByRole[ScreenRole::Display]);
+            mWidgetsByRole[ScreenRole::Display]->showFullScreen();
         }
     }
 }
@@ -270,9 +291,12 @@ QList<QScreen *> UBDisplayManager::availableScreens() const
 void UBDisplayManager::adjustScreens()
 {
     initScreenIndexes();
-    positionScreens();
 
-    emit screenLayoutChanged();
+    // delayed execution to avoid interference with window managers
+    QTimer::singleShot(200, [this](){
+        positionScreens();
+        emit screenLayoutChanged();
+    });
 }
 
 
@@ -283,10 +307,28 @@ void UBDisplayManager::positionScreens()
         mWidgetsByRole[ScreenRole::Desktop]->hide();
         mWidgetsByRole[ScreenRole::Desktop]->setGeometry(mScreensByRole[ScreenRole::Control]->geometry());
     }
+
     if (mWidgetsByRole.contains(ScreenRole::Control) && hasControl())
     {
         mWidgetsByRole[ScreenRole::Control]->showNormal();
-        mWidgetsByRole[ScreenRole::Control]->setGeometry(mScreensByRole[ScreenRole::Control]->geometry());
+
+        QRect geometry = mScreensByRole[ScreenRole::Control]->geometry();
+
+        if (UBSettings::settings()->appRunInWindow->get().toBool())
+        {
+            // reuse previous size and relative position
+            QRect previousGeometry = mWidgetsByRole[ScreenRole::Control]->geometry();
+            QRect previousScreenGeometry = QGuiApplication::screenAt(previousGeometry.topLeft())->geometry();
+            QPoint offset = previousGeometry.topLeft() - previousScreenGeometry.topLeft();
+            geometry.setSize(previousGeometry.size());
+            geometry.moveTo(geometry.topLeft() + offset);
+
+            // make sure widget fits to screen
+            geometry = mScreensByRole[ScreenRole::Control]->geometry().intersected(geometry);
+        }
+
+        mWidgetsByRole[ScreenRole::Control]->showNormal();
+        mWidgetsByRole[ScreenRole::Control]->setGeometry(geometry);
         UBPlatformUtils::showFullScreen(mWidgetsByRole[ScreenRole::Control]);
     }
 
@@ -294,31 +336,28 @@ void UBDisplayManager::positionScreens()
     {
         mWidgetsByRole[ScreenRole::Display]->showNormal();
         mWidgetsByRole[ScreenRole::Display]->setGeometry(mScreensByRole[ScreenRole::Display]->geometry());
-        UBPlatformUtils::showFullScreen(mWidgetsByRole[ScreenRole::Display]);
+        mWidgetsByRole[ScreenRole::Display]->showFullScreen();
     }
     else if(mWidgetsByRole.contains(ScreenRole::Display))
     {
         mWidgetsByRole[ScreenRole::Display]->hide();
     }
 
-    ScreenRole role(ScreenRole::Previous1);
-
-    for (int i = 0; i < 5; ++i)
+    for (ScreenRole role = ScreenRole::Previous1; role <= ScreenRole::Previous5; ++role)
     {
         if (mWidgetsByRole.contains(role))
         {
             if (mScreensByRole.contains(role)) {
                 QWidget* previous = mWidgetsByRole[role];
+                previous->showNormal();
                 previous->setGeometry(mScreensByRole[role]->geometry());
-                UBPlatformUtils::showFullScreen(previous);
+                previous->showFullScreen();
             }
             else
             {
                 mWidgetsByRole[role]->hide();
             }
         }
-
-        ++role;
     }
 
     if (mWidgetsByRole.contains(ScreenRole::Control) && hasControl())
@@ -351,7 +390,7 @@ void UBDisplayManager::blackout()
 
     foreach(UBBlackoutWidget *blackoutWidget, mBlackoutWidgets)
     {
-        UBPlatformUtils::showFullScreen(blackoutWidget);
+        blackoutWidget->showFullScreen();
     }
 }
 

From c7996ff0768ee90a80b077010b6b69ac9f9052e8 Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Fri, 10 Jun 2022 11:29:50 +0200
Subject: [PATCH 03/12] fix: position minimized dock palette

- recompute position when screen configuration is updated
- recompute position on screen when window is resized
  - connect resize event with recalculation of position
---
 src/gui/UBDockPalette.cpp | 13 +++++++++----
 src/gui/UBDockPalette.h   |  2 +-
 2 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/src/gui/UBDockPalette.cpp b/src/gui/UBDockPalette.cpp
index 0de4b28a5..bf652304c 100644
--- a/src/gui/UBDockPalette.cpp
+++ b/src/gui/UBDockPalette.cpp
@@ -37,10 +37,12 @@
 
 #include "core/UBSettings.h"
 #include "core/UBApplication.h"
+#include "core/UBDisplayManager.h"
 #include "core/UBPreferencesController.h"
 #include "core/UBDownloadManager.h"
 
 #include "board/UBBoardController.h"
+#include "board/UBBoardView.h"
 
 #include "core/memcheck.h"
 
@@ -101,6 +103,9 @@ UBDockPalette::UBDockPalette(eUBDockPaletteType paletteType, QWidget *parent, co
 
     connect(UBApplication::boardController,SIGNAL(documentSet(UBDocumentProxy*)),this,SLOT(onDocumentSet(UBDocumentProxy*)));
     connect(this,SIGNAL(pageSelectionChangedRequired()),UBApplication::boardController,SLOT(selectionChanged()));
+
+    connect(UBApplication::displayManager, SIGNAL(screenLayoutChanged()), this, SLOT(onResizeRequest()));
+    connect(UBApplication::boardController->controlView(), SIGNAL(resized(QResizeEvent*)), this, SLOT(onResizeRequest()));
 }
 
 /**
@@ -411,12 +416,12 @@ void UBDockPalette::removeTab(UBDockPaletteWidget* widget)
 }
 
 /**
- * \brief Handle the resize request
- * @param event as the given resize request
+ * \brief Reposition the dock palette
  */
-void UBDockPalette::onResizeRequest(QResizeEvent *event)
+void UBDockPalette::onResizeRequest()
 {
-    resizeEvent(event);
+    // it is possible to pass a nullptr because the handler does not use this argument
+    UBDockPalette::resizeEvent(nullptr);
 }
 
 /**
diff --git a/src/gui/UBDockPalette.h b/src/gui/UBDockPalette.h
index 4c3f8c68e..0b714d2e5 100644
--- a/src/gui/UBDockPalette.h
+++ b/src/gui/UBDockPalette.h
@@ -203,7 +203,7 @@ public slots:
 
 private slots:
     void onToolbarPosUpdated();
-    void onResizeRequest(QResizeEvent* event);
+    void onResizeRequest();
 
 private:
     void tabClicked(int tabIndex);

From e4df0d6146cd0035fbeb5b973038ac9712861fcc Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Fri, 10 Jun 2022 13:45:16 +0200
Subject: [PATCH 04/12] fix: re-initialize previous screens on layout change

---
 src/core/UBApplicationController.cpp | 22 +++++++++++++++-------
 src/core/UBApplicationController.h   |  1 +
 2 files changed, 16 insertions(+), 7 deletions(-)

diff --git a/src/core/UBApplicationController.cpp b/src/core/UBApplicationController.cpp
index f99bfbe95..a5d36eaa1 100644
--- a/src/core/UBApplicationController.cpp
+++ b/src/core/UBApplicationController.cpp
@@ -101,13 +101,6 @@ UBApplicationController::UBApplicationController(UBBoardView *pControlView,
     connect(mUninoteController, SIGNAL(imageCaptured(const QPixmap &, bool)), this, SLOT(addCapturedPixmap(const QPixmap &, bool)));
     connect(mUninoteController, SIGNAL(restoreUniboard()), this, SLOT(hideDesktop()));
 
-    for(int i = 0; i < displayManager->numPreviousViews(); i++)
-    {
-        UBBoardView *previousView = new UBBoardView(UBApplication::boardController, UBItemLayerType::FixedBackground, UBItemLayerType::Tool, 0);
-        previousView->setInteractive(false);
-        mPreviousViews.append(previousView);
-    }
-
     mBlackScene = new UBGraphicsScene(0); // deleted by UBApplicationController::destructor
     mBlackScene->setBackground(true, UBPageBackground::plain);
 
@@ -166,6 +159,8 @@ void UBApplicationController::screenLayoutChanged()
     initViewState(mControlView->horizontalScrollBar()->value(),
             mControlView->verticalScrollBar()->value());
 
+    initPreviousViews();
+
     adaptToolBar();
 
     adjustDisplayView();
@@ -541,6 +536,19 @@ void UBApplicationController::updateRequestFinished(QNetworkReply * reply)
     }
 }
 
+void UBApplicationController::initPreviousViews()
+{
+    qDeleteAll(mPreviousViews);
+    mPreviousViews.clear();
+
+    for(int i = 0; i < UBApplication::displayManager->numPreviousViews(); i++)
+    {
+        UBBoardView *previousView = new UBBoardView(UBApplication::boardController, UBItemLayerType::FixedBackground, UBItemLayerType::Tool, 0);
+        previousView->setInteractive(false);
+        mPreviousViews.append(previousView);
+    }
+}
+
 
 void UBApplicationController::downloadJsonFinished(QString currentJson)
 {
diff --git a/src/core/UBApplicationController.h b/src/core/UBApplicationController.h
index 0136fa3c6..2342faebf 100644
--- a/src/core/UBApplicationController.h
+++ b/src/core/UBApplicationController.h
@@ -150,6 +150,7 @@ class UBApplicationController : public QObject
 
 
     protected:
+        void initPreviousViews();
 
         UBDesktopAnnotationController *mUninoteController;
 

From ebb5c5a83bab2e1f0a2803967a106510dd2d004e Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Fri, 10 Jun 2022 16:13:00 +0200
Subject: [PATCH 05/12] feat: configure screen list by index

- use a numeric index to identify screens
- store separate configurations per monitor configuration
- avoid focus loss for screen list input field
  - set WindowDoesNotAcceptFocus flag on screen labels
  - remove unnecessary fade-out timer
---
 src/core/UBPreferencesController.cpp | 128 ++++++++++++++++++++-------
 src/core/UBPreferencesController.h   |   6 +-
 2 files changed, 99 insertions(+), 35 deletions(-)

diff --git a/src/core/UBPreferencesController.cpp b/src/core/UBPreferencesController.cpp
index 2b40e4822..d797db561 100644
--- a/src/core/UBPreferencesController.cpp
+++ b/src/core/UBPreferencesController.cpp
@@ -116,7 +116,37 @@ UBPreferencesController::~UBPreferencesController()
 
 void UBPreferencesController::adjustScreens()
 {
-    mPreferencesUI->multiDisplayGroupBox->setEnabled(UBApplication::displayManager->numScreens() > 1);
+    bool enabled = UBApplication::displayManager->numScreens() > 1;
+    mPreferencesUI->multiDisplayGroupBox->setEnabled(enabled);
+
+    if (enabled)
+    {
+        mPreferencesUI->screenList->setPlaceholderText(tr("Use all available displays"));
+    }
+    else
+    {
+        mPreferencesUI->screenList->setPlaceholderText("");
+    }
+
+    auto availableScreens = UBApplication::displayManager->availableScreens();
+    QStringList screenNames;
+
+    for (QScreen* screen : availableScreens)
+    {
+        screenNames << screen->name();
+    }
+
+    std::sort(screenNames.begin(), screenNames.end());
+    QString screenConfiguration = screenNames.join('_');
+
+    QString path = UBSettings::settings()->appScreenList->path() + "-" + screenConfiguration;
+
+    if (path != mScreenConfigurationPath)
+    {
+        mScreenConfigurationPath = path;
+        QStringList value = UBSettings::settings()->value(path).toStringList();
+        UBSettings::settings()->appScreenList->set(value);
+    }
 }
 
 void UBPreferencesController::show()
@@ -137,10 +167,12 @@ void UBPreferencesController::wire()
     connect(mPreferencesUI->closeButton, SIGNAL(released()), this, SLOT(close()));
     connect(mPreferencesUI->defaultSettingsButton, SIGNAL(released()), this, SLOT(defaultSettings()));
 
-    connect(mPreferencesUI->screenList, &QLineEdit::textChanged, [this,settings](const QString &text){
-        if (mPreferencesUI->screenList->hasAcceptableInput())
+    connect(mPreferencesUI->screenList, &UBScreenListLineEdit::screenListChanged, [this,settings](const QStringList screenList){
+        settings->appScreenList->set(screenList);
+
+        if (!mScreenConfigurationPath.isEmpty())
         {
-            settings->appScreenList->set(splitScreenList(text));
+            settings->setValue(mScreenConfigurationPath, screenList);
         }
     });
 
@@ -301,7 +333,7 @@ void UBPreferencesController::init()
 
     mPreferencesUI->useExternalBrowserCheckBox->setChecked(settings->webUseExternalBrowser->get().toBool());
     mPreferencesUI->displayBrowserPageCheckBox->setChecked(settings->webShowPageImmediatelyOnMirroredScreen->get().toBool());
-    mPreferencesUI->screenList->setText(settings->appScreenList->get().toStringList().join(','));
+    mPreferencesUI->screenList->loadScreenList(settings->appScreenList->get().toStringList());
     mPreferencesUI->webHomePage->setText(settings->webHomePage->get().toString());
 
     mPreferencesUI->proxyUsername->setText(settings->proxyUsername());
@@ -761,50 +793,67 @@ UBScreenListLineEdit::UBScreenListLineEdit(QWidget *parent)
     : QLineEdit(parent)
     , mValidator(nullptr)
     , mCompleter(nullptr)
-    , mFadeOutTimer(nullptr)
 {
     connect(this, &QLineEdit::textChanged, this, &UBScreenListLineEdit::onTextChanged);
 }
 
 void UBScreenListLineEdit::setDefault()
 {
-    QList<QScreen*> screens = UBApplication::displayManager->availableScreens();
-    QStringList availableScreenNames;
+    setText("");
+}
+
+void UBScreenListLineEdit::loadScreenList(const QStringList &screenList)
+{
+    // convert screen list to index list
+    auto screens = UBApplication::displayManager->availableScreens();
+    QStringList screenNames;
+
+    for (QScreen* screen : screens)
+    {
+        screenNames << screen->name();
+    }
+
+    QStringList screenIndexes;
 
-    for (QScreen* screen : screens) {
-        availableScreenNames << screen->name();
+    for (const QString& screenName: screenList)
+    {
+        int index = screenNames.indexOf(screenName);
+
+        if (index >= 0)
+        {
+            screenIndexes << QString::number(index + 1);
+        }
+        else
+        {
+            qDebug() << "Invalid screen name" << screenName;
+        }
     }
 
-    setText(availableScreenNames.join(','));
+    setText(screenIndexes.join(','));
 }
 
 void UBScreenListLineEdit::focusInEvent(QFocusEvent *focusEvent)
 {
     QLineEdit::focusInEvent(focusEvent);
 
-    if (mFadeOutTimer)
-    {
-        mFadeOutTimer->stop();
-        delete mFadeOutTimer;
-        mFadeOutTimer = nullptr;
-    }
-
     if (mScreenLabels.empty())
     {
         QStringList screenNames = splitScreenList(text());
 
         QList<QScreen*> screens = UBApplication::displayManager->availableScreens();
-        QStringList availableScreenNames;
+        QStringList availableScreenIndexes;
+        int screenIndex = 1;
 
         for (QScreen* screen : screens) {
-            availableScreenNames << screen->name();
+            availableScreenIndexes << QString::number(screenIndex);
 
             QPushButton* button = new QPushButton(this);
             button->setWindowFlag(Qt::FramelessWindowHint, true);
             button->setWindowFlag(Qt::WindowStaysOnTopHint, true);
             button->setWindowFlag(Qt::X11BypassWindowManagerHint, true);
             button->setWindowFlag(Qt::Window, true);
-            button->setText(screen->name());
+            button->setWindowFlag(Qt::WindowDoesNotAcceptFocus, true);
+            button->setText(QString::number(screenIndex++));
             QFont font;
             font.setPointSize(48);
             button->setFont(font);
@@ -824,9 +873,8 @@ void UBScreenListLineEdit::focusInEvent(QFocusEvent *focusEvent)
             delete mValidator;
         }
 
-        mValidator = new UBStringListValidator(availableScreenNames);
+        mValidator = new UBStringListValidator(availableScreenIndexes);
         setValidator(mValidator);
-        activateWindow();
     }
 }
 
@@ -834,14 +882,8 @@ void UBScreenListLineEdit::focusOutEvent(QFocusEvent *focusEvent)
 {
     QLineEdit::focusOutEvent(focusEvent);
 
-    // avoid deleting screen labels when input widget shortly looses focus,
-    // e.g. by clicking one of the scren label buttons
-    mFadeOutTimer = new QTimer(this);
-    mFadeOutTimer->callOnTimeout([this](){
-        qDeleteAll(mScreenLabels);
-        mScreenLabels.clear();
-    });
-    mFadeOutTimer->start(500);
+    qDeleteAll(mScreenLabels);
+    mScreenLabels.clear();
 }
 
 void UBScreenListLineEdit::addScreen()
@@ -864,9 +906,6 @@ void UBScreenListLineEdit::addScreen()
 
         button->setEnabled(false);
     }
-
-    // regain focus after pressing screen label button
-    activateWindow();
 }
 
 void UBScreenListLineEdit::onTextChanged(const QString &input)
@@ -906,6 +945,27 @@ void UBScreenListLineEdit::onTextChanged(const QString &input)
     if (hasAcceptableInput())
     {
         setStyleSheet("");
+
+        QStringList screenList = splitScreenList(input);
+
+        // convert from index to screen name
+        auto screens = UBApplication::displayManager->availableScreens();
+
+        for (QString& entry : screenList)
+        {
+            int screenIndex = entry.toInt() - 1;
+
+            if (screenIndex >= 0 && screenIndex < screens.size())
+            {
+                entry = screens[screenIndex]->name();
+            }
+            else
+            {
+                qDebug() << "Invalid screen index " << entry;
+            }
+        }
+
+        emit screenListChanged(screenList);
     }
     else
     {
diff --git a/src/core/UBPreferencesController.h b/src/core/UBPreferencesController.h
index 9bc49769c..16e13bc3b 100644
--- a/src/core/UBPreferencesController.h
+++ b/src/core/UBPreferencesController.h
@@ -86,6 +86,7 @@ class UBPreferencesController : public QObject
         UBBrushPropertiesFrame* mMarkerProperties;
         UBColorPicker* mDarkBackgroundGridColorPicker;
         UBColorPicker* mLightBackgroundGridColorPicker;
+        QString mScreenConfigurationPath;
 
     protected slots:
 
@@ -136,11 +137,15 @@ class UBScreenListLineEdit : public QLineEdit
     virtual ~UBScreenListLineEdit() = default;
 
     void setDefault();
+    void loadScreenList(const QStringList& screenList);
 
 protected:
     virtual void focusInEvent(QFocusEvent* focusEvent) override;
     virtual void focusOutEvent(QFocusEvent* focusEvent) override;
 
+signals:
+    void screenListChanged(QStringList screenList);
+
 private slots:
     void addScreen();
     void onTextChanged(const QString& input);
@@ -149,7 +154,6 @@ private slots:
     QList<QPushButton*> mScreenLabels;
     QValidator* mValidator;
     QCompleter* mCompleter;
-    QTimer* mFadeOutTimer;
 };
 
 class UBStringListValidator : public QValidator

From fdf430cfeb82cb0fac6132974cc700f122f78435 Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Sat, 11 Jun 2022 15:53:15 +0200
Subject: [PATCH 06/12] fix: showFullscreen in window mode

- restrict window mode to control widget only
- make same changes for MacOS
---
 src/core/UBDisplayManager.cpp            | 11 +++++------
 src/frameworks/UBPlatformUtils_linux.cpp |  5 ++++-
 src/frameworks/UBPlatformUtils_mac.mm    | 24 +++++++++++++++---------
 src/frameworks/UBPlatformUtils_win.cpp   |  5 ++++-
 4 files changed, 28 insertions(+), 17 deletions(-)

diff --git a/src/core/UBDisplayManager.cpp b/src/core/UBDisplayManager.cpp
index e06c01692..64905c010 100644
--- a/src/core/UBDisplayManager.cpp
+++ b/src/core/UBDisplayManager.cpp
@@ -262,7 +262,7 @@ void UBDisplayManager::setDisplayWidget(QWidget* pDisplayWidget)
         if (mScreensByRole.contains(ScreenRole::Display))
         {
             mWidgetsByRole[ScreenRole::Display]->setGeometry(mScreensByRole[ScreenRole::Display]->geometry());
-            mWidgetsByRole[ScreenRole::Display]->showFullScreen();
+            UBPlatformUtils::showFullScreen(mWidgetsByRole[ScreenRole::Display]);
         }
     }
 }
@@ -336,7 +336,7 @@ void UBDisplayManager::positionScreens()
     {
         mWidgetsByRole[ScreenRole::Display]->showNormal();
         mWidgetsByRole[ScreenRole::Display]->setGeometry(mScreensByRole[ScreenRole::Display]->geometry());
-        mWidgetsByRole[ScreenRole::Display]->showFullScreen();
+        UBPlatformUtils::showFullScreen(mWidgetsByRole[ScreenRole::Display]);
     }
     else if(mWidgetsByRole.contains(ScreenRole::Display))
     {
@@ -351,7 +351,7 @@ void UBDisplayManager::positionScreens()
                 QWidget* previous = mWidgetsByRole[role];
                 previous->showNormal();
                 previous->setGeometry(mScreensByRole[role]->geometry());
-                previous->showFullScreen();
+                UBPlatformUtils::showFullScreen(previous);
             }
             else
             {
@@ -388,9 +388,9 @@ void UBDisplayManager::blackout()
 
     UBPlatformUtils::fadeDisplayOut();
 
-    foreach(UBBlackoutWidget *blackoutWidget, mBlackoutWidgets)
+    for (UBBlackoutWidget* blackoutWidget : mBlackoutWidgets)
     {
-        blackoutWidget->showFullScreen();
+        UBPlatformUtils::showFullScreen(blackoutWidget);
     }
 }
 
@@ -405,7 +405,6 @@ void UBDisplayManager::unBlackout()
     UBPlatformUtils::fadeDisplayIn();
 
     UBApplication::boardController->freezeW3CWidgets(false);
-
 }
 
 
diff --git a/src/frameworks/UBPlatformUtils_linux.cpp b/src/frameworks/UBPlatformUtils_linux.cpp
index 8864d52c3..7e1c0d80d 100644
--- a/src/frameworks/UBPlatformUtils_linux.cpp
+++ b/src/frameworks/UBPlatformUtils_linux.cpp
@@ -36,6 +36,8 @@
 #include <X11/keysym.h>
 
 #include "frameworks/UBFileSystemUtils.h"
+#include "core/UBApplication.h"
+#include "core/UBDisplayManager.h"
 #include "core/UBSettings.h"
 
 
@@ -440,7 +442,8 @@ void UBPlatformUtils::setFrontProcess()
 
 void UBPlatformUtils::showFullScreen(QWidget *pWidget)
 {
-    if (UBSettings::settings()->appRunInWindow->get().toBool()) {
+    if (UBSettings::settings()->appRunInWindow->get().toBool() &&
+            pWidget == UBApplication::displayManager->widget(ScreenRole::Control)) {
         pWidget->show();
     } else {
         pWidget->showFullScreen();
diff --git a/src/frameworks/UBPlatformUtils_mac.mm b/src/frameworks/UBPlatformUtils_mac.mm
index 3138861fd..6d8adfc7b 100644
--- a/src/frameworks/UBPlatformUtils_mac.mm
+++ b/src/frameworks/UBPlatformUtils_mac.mm
@@ -29,6 +29,7 @@
 #include "MacUtils.h"
 #include "UBPlatformUtils.h"
 #include "core/UBApplication.h"
+#include "core/UBDisplayManager.h"
 #include "core/UBSettings.h"
 #include "frameworks/UBFileSystemUtils.h"
 #include "gui/UBMainWindow.h"
@@ -607,17 +608,22 @@ QString QStringFromStringRef(CFStringRef stringRef)
      * Since it is impossible to later set different presentation options (i.e Hide dock & menu bar)
      * to NSApplication, we have to avoid calling QWidget::showFullScreen on OSX.
     */
-    
-    pWidget->showMaximized();
 
-    /* Bit of a hack. On OS X 10.10, showMaximized() resizes the widget to full screen (if the dock and
-     * menu bar are hidden); but on 10.9, it is placed in the "available" screen area (i.e the
-     * screen area minus the menu bar and dock area). So we have to manually resize it to the
-     * total screen height, and move it up to the top of the screen (y=0 position). */
+    if (UBSettings::settings()->appRunInWindow->get().toBool() &&
+            pWidget == UBApplication::displayManager->widget(ScreenRole::Control)) {
+        pWidget->show();
+    } else {
+        pWidget->showMaximized();
+
+        /* Bit of a hack. On OS X 10.10, showMaximized() resizes the widget to full screen (if the dock and
+         * menu bar are hidden); but on 10.9, it is placed in the "available" screen area (i.e the
+         * screen area minus the menu bar and dock area). So we have to manually resize it to the
+         * total screen height, and move it up to the top of the screen (y=0 position). */
 
-    QRect currentScreenRect = QApplication::desktop()->screenGeometry(pWidget);
-    pWidget->resize(currentScreenRect.width(), currentScreenRect.height());
-    pWidget->move(currentScreenRect.left(), currentScreenRect.top());
+        QRect currentScreenRect = QGuiApplication::screenAt(pWidget->geometry().topLeft())->geometry();
+        pWidget->resize(currentScreenRect.width(), currentScreenRect.height());
+        pWidget->move(currentScreenRect.left(), currentScreenRect.top());
+    }
 }
 
 
diff --git a/src/frameworks/UBPlatformUtils_win.cpp b/src/frameworks/UBPlatformUtils_win.cpp
index 73d611e22..65682391d 100644
--- a/src/frameworks/UBPlatformUtils_win.cpp
+++ b/src/frameworks/UBPlatformUtils_win.cpp
@@ -36,6 +36,8 @@
 
 #include "frameworks/UBFileSystemUtils.h"
 #include "core/memcheck.h"
+#include "core/UBApplication.h"
+#include "core/UBDisplayManager.h"
 #include "core/UBSettings.h"
 
 void UBPlatformUtils::init()
@@ -437,7 +439,8 @@ void UBPlatformUtils::setFrontProcess()
 
 void UBPlatformUtils::showFullScreen(QWidget *pWidget)
 {
-    if (UBSettings::settings()->appRunInWindow->get().toBool()) {
+    if (UBSettings::settings()->appRunInWindow->get().toBool() &&
+            pWidget == UBApplication::displayManager->widget(ScreenRole::Control)) {
         pWidget->show();
     } else {
         pWidget->showFullScreen();

From df7577796c44cea5faf328877e3bb1f2f86c58a3 Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Sat, 11 Jun 2022 17:13:02 +0200
Subject: [PATCH 07/12] refactor: store indexes instead of screen names, checks
 and formatting

- an entry like
    ScreenList-HDMI-1_VGA-1=2, 1
  is easily readable and contains all it needs:
  - for a screen configuration woth
    - HDMI-1 as primary screen and
    - VGA-1 as next screen
  - use
    - the second entry as control screen and
    - the first entry as display screen

- carefully check pointers before dereferencing
- use guarded pointers for not-owned objects
- formatting
- comments and readability
- apply monitor configuration on-the-fly while editing
---
 src/core/UBDisplayManager.cpp        | 167 ++++++++++++++++-----------
 src/core/UBDisplayManager.h          |  16 +--
 src/core/UBPreferencesController.cpp |  59 ++--------
 3 files changed, 116 insertions(+), 126 deletions(-)

diff --git a/src/core/UBDisplayManager.cpp b/src/core/UBDisplayManager.cpp
index 64905c010..28104f5a4 100644
--- a/src/core/UBDisplayManager.cpp
+++ b/src/core/UBDisplayManager.cpp
@@ -72,6 +72,7 @@ void UBDisplayManager::initScreenIndexes()
     for (int i = 1; i < screens.size(); )
     {
         QRect iGeomentry = screens[i]->geometry();
+        bool removed = false;
 
         for (int j = 0; j < i; ++j)
         {
@@ -80,19 +81,29 @@ void UBDisplayManager::initScreenIndexes()
             if (iGeomentry.contains(jGeometry) || jGeometry.contains(iGeomentry))
             {
                 screens.removeAt(i);
+                removed = true;
                 break;
             }
         }
 
-        ++i;
+        if (!removed)
+        {
+            ++i;
+        }
     }
 
-    if (screens.count() != mAvailableScreens.count())
+    if (screens != mAvailableScreens)
     {
         mAvailableScreens = screens;
         emit availableScreenCountChanged(screens.count());
     }
 
+    /*
+     * Emitting availableScreenCountChanged updated the screen configuration
+     * in the UBPreferencesManager, so we now get the screen list valid for
+     * the new monitor configuration.
+     */
+
     QVariant appScreenList = UBSettings::settings()->appScreenList->get();
     QStringList screenList = appScreenList.toStringList();
 
@@ -115,19 +126,17 @@ void UBDisplayManager::initScreenIndexes()
             }
 
             mScreensByRole[ScreenRole::Control] = controlScreen;
-            screenList << controlScreen->name();
+            screenList << (swapScreens ? "2" : "1");
+
+            mScreensByRole[ScreenRole::Display] = displayScreen;
+            screenList << (swapScreens ? "1" : "2");
 
-            if (mUseMultiScreen)
+            ScreenRole role(ScreenRole::Previous1);
+
+            for (int i = 2; i < screens.count(); ++i)
             {
-                mScreensByRole[ScreenRole::Display] = displayScreen;
-                screenList << displayScreen->name();
-                ScreenRole role(ScreenRole::Previous1);
-
-                for (int i = 2; i < screens.count(); ++i)
-                {
-                    mScreensByRole[role++] = screens[i];
-                    screenList << screens[i]->name();
-                }
+                mScreensByRole[role++] = screens[i];
+                screenList << QString::number(i + 1);
             }
 
             if (screenList.count() > 1)
@@ -146,37 +155,44 @@ void UBDisplayManager::initScreenIndexes()
             screenList.clear();
 
             // explicitly stored an empty list, take all available screens
-            for (QScreen* screen : mAvailableScreens)
+            for (int index = 1; index <= mAvailableScreens.count(); ++index)
             {
-                screenList << screen->name();
+                screenList << QString::number(index);
             }
         }
 
-        // "new" configuration mode using list of screen names
-        // first, create a map of screens by name
-        QMap<QString,QScreen*> screenByName;
+        // "new" configuration mode using list of screen indexes
+        // convert to index list and check: are all numbers in range?
+        QList<int> indexList;
 
-        for (QScreen* screen : mAvailableScreens)
+        for (QString& entry : screenList)
         {
-            screenByName[screen->name()] = screen;
+            int index = entry.toInt();
+
+            if (index < 1 || index > mAvailableScreens.size())
+            {
+                qDebug() << "Warning: Screen index out of range, skipped:" << index;
+            }
+            else
+            {
+                indexList << index - 1;
+            }
         }
 
-        // configure control screen
-        QScreen* controlScreen = screenByName.value(screenList[0], nullptr);
+        // configure control screen, by default use primary screen
+        QScreen* controlScreen = primaryScreen;
 
-        if (!controlScreen)
+        if (!indexList.empty() && mAvailableScreens[indexList[0]])
         {
-            // by default use primary screen and remove it from the list of available screens
-            controlScreen = primaryScreen;
-            screenByName.remove(controlScreen->name());
+            controlScreen = mAvailableScreens[indexList[0]];
         }
 
         mScreensByRole[ScreenRole::Control] = controlScreen;
 
         // configure display screen
-        if (mUseMultiScreen && screenList.count() > 1)
+        if (mUseMultiScreen && indexList.count() > 1)
         {
-            QScreen* displayScreen = screenByName.value(screenList[1], nullptr);
+            QScreen* displayScreen = mAvailableScreens[indexList[1]];
 
             if (displayScreen)
             {
@@ -187,9 +203,9 @@ void UBDisplayManager::initScreenIndexes()
         // configure previous screens
         ScreenRole role = ScreenRole::Previous1;
 
-        for (int i = 2; i < screenList.count(); ++i)
+        for (int i = 2; i < indexList.count(); ++i)
         {
-            QScreen* previousScreen = screenByName.value(screenList[i], nullptr);
+            QScreen* previousScreen = mAvailableScreens[indexList[i]];
 
             if (previousScreen)
             {
@@ -198,7 +214,6 @@ void UBDisplayManager::initScreenIndexes()
         }
     }
 
-
     // Desktop screen is same as Control screen
     mScreensByRole[ScreenRole::Desktop] = mScreensByRole[ScreenRole::Control];
 }
@@ -215,7 +230,7 @@ int UBDisplayManager::numPreviousViews()
 
     for (ScreenRole role = ScreenRole::Previous1; role <= ScreenRole::Previous5; ++role)
     {
-        if (mScreensByRole.contains(role))
+        if (mScreensByRole.value(role))
         {
             ++previousViews;
         }
@@ -242,15 +257,17 @@ void UBDisplayManager::setControlWidget(QWidget* pControlWidget)
 
 void UBDisplayManager::setDesktopWidget(QWidget* pDesktopWidget )
 {
-    if(pDesktopWidget)
+    if (pDesktopWidget)
+    {
         mWidgetsByRole[ScreenRole::Desktop] = pDesktopWidget;
+    }
 }
 
 void UBDisplayManager::setDisplayWidget(QWidget* pDisplayWidget)
 {
-    if(pDisplayWidget)
+    if (pDisplayWidget)
     {
-        if (mWidgetsByRole.contains(ScreenRole::Display))
+        if (widget(ScreenRole::Display))
         {
             mWidgetsByRole[ScreenRole::Display]->hide();
             pDisplayWidget->setGeometry(mWidgetsByRole[ScreenRole::Display]->geometry());
@@ -259,10 +276,10 @@ void UBDisplayManager::setDisplayWidget(QWidget* pDisplayWidget)
 
         mWidgetsByRole[ScreenRole::Display] = pDisplayWidget;
 
-        if (mScreensByRole.contains(ScreenRole::Display))
+        if (mScreensByRole.value(ScreenRole::Display))
         {
-            mWidgetsByRole[ScreenRole::Display]->setGeometry(mScreensByRole[ScreenRole::Display]->geometry());
-            UBPlatformUtils::showFullScreen(mWidgetsByRole[ScreenRole::Display]);
+            pDisplayWidget->setGeometry(mScreensByRole[ScreenRole::Display]->geometry());
+            UBPlatformUtils::showFullScreen(pDisplayWidget);
         }
     }
 }
@@ -302,52 +319,57 @@ void UBDisplayManager::adjustScreens()
 
 void UBDisplayManager::positionScreens()
 {
-    if(mWidgetsByRole.contains(ScreenRole::Desktop) && hasControl())
+    if (widget(ScreenRole::Desktop) && hasControl())
     {
         mWidgetsByRole[ScreenRole::Desktop]->hide();
         mWidgetsByRole[ScreenRole::Desktop]->setGeometry(mScreensByRole[ScreenRole::Control]->geometry());
     }
 
-    if (mWidgetsByRole.contains(ScreenRole::Control) && hasControl())
+    if (mWidgetsByRole.value(ScreenRole::Control) && hasControl())
     {
-        mWidgetsByRole[ScreenRole::Control]->showNormal();
+        QWidget* controlWidget = mWidgetsByRole[ScreenRole::Control];
+        controlWidget->showNormal();
 
         QRect geometry = mScreensByRole[ScreenRole::Control]->geometry();
 
         if (UBSettings::settings()->appRunInWindow->get().toBool())
         {
             // reuse previous size and relative position
-            QRect previousGeometry = mWidgetsByRole[ScreenRole::Control]->geometry();
-            QRect previousScreenGeometry = QGuiApplication::screenAt(previousGeometry.topLeft())->geometry();
-            QPoint offset = previousGeometry.topLeft() - previousScreenGeometry.topLeft();
-            geometry.setSize(previousGeometry.size());
-            geometry.moveTo(geometry.topLeft() + offset);
-
-            // make sure widget fits to screen
-            geometry = mScreensByRole[ScreenRole::Control]->geometry().intersected(geometry);
+            QRect previousGeometry = controlWidget->geometry();
+            QScreen* previousScreen = QGuiApplication::screenAt(previousGeometry.topLeft());
+
+            if (previousScreen)
+            {
+                QRect previousScreenGeometry = QGuiApplication::screenAt(previousGeometry.topLeft())->geometry();
+                QPoint offset = previousGeometry.topLeft() - previousScreenGeometry.topLeft();
+                geometry.setSize(previousGeometry.size());
+                geometry.moveTo(geometry.topLeft() + offset);
+
+                // make sure widget fits to screen
+                geometry = mScreensByRole[ScreenRole::Control]->geometry().intersected(geometry);
+            }
         }
 
-        mWidgetsByRole[ScreenRole::Control]->showNormal();
-        mWidgetsByRole[ScreenRole::Control]->setGeometry(geometry);
-        UBPlatformUtils::showFullScreen(mWidgetsByRole[ScreenRole::Control]);
+        controlWidget->setGeometry(geometry);
+        UBPlatformUtils::showFullScreen(controlWidget);
     }
 
-    if (mWidgetsByRole.contains(ScreenRole::Display) && hasDisplay())
+    if (mWidgetsByRole.value(ScreenRole::Display) && hasDisplay())
     {
         mWidgetsByRole[ScreenRole::Display]->showNormal();
         mWidgetsByRole[ScreenRole::Display]->setGeometry(mScreensByRole[ScreenRole::Display]->geometry());
         UBPlatformUtils::showFullScreen(mWidgetsByRole[ScreenRole::Display]);
     }
-    else if(mWidgetsByRole.contains(ScreenRole::Display))
+    else if (mWidgetsByRole.value(ScreenRole::Display))
     {
         mWidgetsByRole[ScreenRole::Display]->hide();
     }
 
     for (ScreenRole role = ScreenRole::Previous1; role <= ScreenRole::Previous5; ++role)
     {
-        if (mWidgetsByRole.contains(role))
+        if (mWidgetsByRole.value(role))
         {
-            if (mScreensByRole.contains(role)) {
+            if (mScreensByRole.value(role)) {
                 QWidget* previous = mWidgetsByRole[role];
                 previous->showNormal();
                 previous->setGeometry(mScreensByRole[role]->geometry());
@@ -360,8 +382,10 @@ void UBDisplayManager::positionScreens()
         }
     }
 
-    if (mWidgetsByRole.contains(ScreenRole::Control) && hasControl())
+    if (mWidgetsByRole.value(ScreenRole::Control) && hasControl())
+    {
         mWidgetsByRole[ScreenRole::Control]->activateWindow();
+    }
 }
 
 
@@ -369,8 +393,8 @@ void UBDisplayManager::blackout()
 {
     for (auto screen : mScreensByRole)
     {
-        UBBlackoutWidget *blackoutWidget = new UBBlackoutWidget(); //deleted in UBDisplayManager::unBlackout
-        Ui::BlackoutWidget *blackoutUi = new Ui::BlackoutWidget();
+        UBBlackoutWidget* blackoutWidget = new UBBlackoutWidget(); //deleted in UBDisplayManager::unBlackout
+        Ui::BlackoutWidget* blackoutUi = new Ui::BlackoutWidget();
         blackoutUi->setupUi(blackoutWidget);
 
         connect(blackoutUi->iconButton, SIGNAL(pressed()), blackoutWidget, SLOT(doActivity()));
@@ -411,8 +435,14 @@ void UBDisplayManager::unBlackout()
 void UBDisplayManager::addOrRemoveScreen(QScreen *screen)
 {
     Q_UNUSED(screen);
-    // adjustment must be delayed, because OS also tries to position the widgets
-    QTimer::singleShot(3000, [this](){ adjustScreens(); } );
+
+    initScreenIndexes();
+
+    // positioning must be delayed, because OS also tries to position the widgets
+    QTimer::singleShot(3000, [this](){
+        positionScreens();
+        emit screenLayoutChanged();
+    });
 }
 
 
@@ -423,37 +453,37 @@ void UBDisplayManager::setUseMultiScreen(bool pUse)
 
 QSize UBDisplayManager::screenSize(ScreenRole role) const
 {
-    QScreen* screen = mScreensByRole.value(role, nullptr);
+    QScreen* screen = mScreensByRole.value(role);
     return screen ? screen->size() : QSize();
 }
 
 QSize UBDisplayManager::availableScreenSize(ScreenRole role) const
 {
-    QScreen* screen = mScreensByRole.value(role, nullptr);
+    QScreen* screen = mScreensByRole.value(role);
     return screen ? screen->availableSize() : QSize();
 }
 
 QRect UBDisplayManager::screenGeometry(ScreenRole role) const
 {
-    QScreen* screen = mScreensByRole.value(role, nullptr);
+    QScreen* screen = mScreensByRole.value(role);
     return screen ? screen->geometry() : QRect();
 }
 
 qreal UBDisplayManager::physicalDpi(ScreenRole role) const
 {
-    QScreen* screen = mScreensByRole.value(role, nullptr);
+    QScreen* screen = mScreensByRole.value(role);
     return screen ? screen->physicalDotsPerInch() : 96.;
 }
 
 qreal UBDisplayManager::logicalDpi(ScreenRole role) const
 {
-    QScreen* screen = mScreensByRole.value(role, nullptr);
+    QScreen* screen = mScreensByRole.value(role);
     return screen ? screen->logicalDotsPerInch() : 96.;
 }
 
 QPixmap UBDisplayManager::grab(ScreenRole role, QRect rect) const
 {
-    QScreen* screen = mScreensByRole.value(role, nullptr);
+    QScreen* screen = mScreensByRole.value(role);
 
     if (screen)
     {
@@ -469,7 +499,8 @@ QPixmap UBDisplayManager::grabGlobal(QRect rect) const
 {
     QScreen* screen = QGuiApplication::screenAt(rect.topLeft());
 
-    if (screen) {
+    if (screen)
+    {
         rect.translate(-screen->geometry().topLeft());
         return screen->grabWindow(0, rect.x(), rect.y(), rect.width(), rect.height());
     }
diff --git a/src/core/UBDisplayManager.h b/src/core/UBDisplayManager.h
index c7e1f43ec..d08281174 100644
--- a/src/core/UBDisplayManager.h
+++ b/src/core/UBDisplayManager.h
@@ -73,20 +73,23 @@ class UBDisplayManager : public QObject
 
         bool hasControl()
         {
-            return mScreensByRole.contains(ScreenRole::Control);
+            return mScreensByRole.value(ScreenRole::Control);
         }
 
         bool hasDisplay()
         {
-            return mScreensByRole.contains(ScreenRole::Display);
+            return mScreensByRole.value(ScreenRole::Display);
         }
 
         bool hasPrevious()
         {
-            return mScreensByRole.contains(ScreenRole::Previous1);
+            return mScreensByRole.value(ScreenRole::Previous1);
         }
 
-        bool useMultiScreen() { return mUseMultiScreen; }
+        bool useMultiScreen()
+        {
+            return mUseMultiScreen;
+        }
 
         void setUseMultiScreen(bool pUse);
 
@@ -124,11 +127,10 @@ class UBDisplayManager : public QObject
         QList<UBBlackoutWidget*> mBlackoutWidgets;
 
         QList<QScreen*> mAvailableScreens;
-        QMap<ScreenRole, QScreen*> mScreensByRole;
-        QMap<ScreenRole, QWidget*> mWidgetsByRole;
+        QMap<ScreenRole, QPointer<QScreen>> mScreensByRole;
+        QMap<ScreenRole, QPointer<QWidget>> mWidgetsByRole;
 
         bool mUseMultiScreen;
-
 };
 
 #endif /* UBDISPLAYMANAGER_H_ */
diff --git a/src/core/UBPreferencesController.cpp b/src/core/UBPreferencesController.cpp
index d797db561..7f479f96a 100644
--- a/src/core/UBPreferencesController.cpp
+++ b/src/core/UBPreferencesController.cpp
@@ -55,16 +55,16 @@ qreal UBPreferencesController::sMaxPenWidth = 50.0;
 // convenience function to convert between screen list as QString and QStringList
 QStringList splitScreenList(const QString& input)
 {
-    QStringList screenNames = input.split(',');
+    QStringList screenList = input.split(',');
 
-    for (QString& entry : screenNames)
+    for (QString& entry : screenList)
     {
         entry = entry.trimmed();
     }
 
-    screenNames.removeAll("");
+    screenList.removeAll("");
 
-    return screenNames;
+    return screenList;
 }
 
 
@@ -98,7 +98,7 @@ UBPreferencesController::UBPreferencesController(QWidget *parent)
     mPreferencesUI = new Ui::preferencesDialog();  // deleted in destructor
     mPreferencesUI->setupUi(mPreferencesWindow);
     adjustScreens();
-    connect(UBApplication::displayManager, &UBDisplayManager::screenLayoutChanged, this, &UBPreferencesController::adjustScreens);
+    connect(UBApplication::displayManager, &UBDisplayManager::availableScreenCountChanged, this, &UBPreferencesController::adjustScreens);
     wire();
 }
 
@@ -133,10 +133,9 @@ void UBPreferencesController::adjustScreens()
 
     for (QScreen* screen : availableScreens)
     {
-        screenNames << screen->name();
+        screenNames << screen->name().replace("/", "");
     }
 
-    std::sort(screenNames.begin(), screenNames.end());
     QString screenConfiguration = screenNames.join('_');
 
     QString path = UBSettings::settings()->appScreenList->path() + "-" + screenConfiguration;
@@ -146,6 +145,7 @@ void UBPreferencesController::adjustScreens()
         mScreenConfigurationPath = path;
         QStringList value = UBSettings::settings()->value(path).toStringList();
         UBSettings::settings()->appScreenList->set(value);
+        mPreferencesUI->screenList->loadScreenList(value);
     }
 }
 
@@ -804,32 +804,7 @@ void UBScreenListLineEdit::setDefault()
 
 void UBScreenListLineEdit::loadScreenList(const QStringList &screenList)
 {
-    // convert screen list to index list
-    auto screens = UBApplication::displayManager->availableScreens();
-    QStringList screenNames;
-
-    for (QScreen* screen : screens)
-    {
-        screenNames << screen->name();
-    }
-
-    QStringList screenIndexes;
-
-    for (const QString& screenName: screenList)
-    {
-        int index = screenNames.indexOf(screenName);
-
-        if (index >= 0)
-        {
-            screenIndexes << QString::number(index + 1);
-        }
-        else
-        {
-            qDebug() << "Invalid screen name" << screenName;
-        }
-    }
-
-    setText(screenIndexes.join(','));
+    setText(screenList.join(','));
 }
 
 void UBScreenListLineEdit::focusInEvent(QFocusEvent *focusEvent)
@@ -947,24 +922,6 @@ void UBScreenListLineEdit::onTextChanged(const QString &input)
         setStyleSheet("");
 
         QStringList screenList = splitScreenList(input);
-
-        // convert from index to screen name
-        auto screens = UBApplication::displayManager->availableScreens();
-
-        for (QString& entry : screenList)
-        {
-            int screenIndex = entry.toInt() - 1;
-
-            if (screenIndex >= 0 && screenIndex < screens.size())
-            {
-                entry = screens[screenIndex]->name();
-            }
-            else
-            {
-                qDebug() << "Invalid screen index " << entry;
-            }
-        }
-
         emit screenListChanged(screenList);
     }
     else

From 45761b5c2cdef916d8afaec5d8ce434b75ef9ac9 Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Mon, 13 Jun 2022 15:57:51 +0200
Subject: [PATCH 08/12] fix: initialize previous screen widgets and content

- create widgets immediately after screen count is known
- update content after widgets are positioned
---
 src/core/UBApplicationController.cpp | 13 +++++++------
 src/core/UBDisplayManager.h          |  1 -
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/core/UBApplicationController.cpp b/src/core/UBApplicationController.cpp
index a5d36eaa1..43c641d61 100644
--- a/src/core/UBApplicationController.cpp
+++ b/src/core/UBApplicationController.cpp
@@ -97,7 +97,10 @@ UBApplicationController::UBApplicationController(UBBoardView *pControlView,
     connect(displayManager, SIGNAL(screenLayoutChanged()), this, SLOT(screenLayoutChanged()));
     connect(displayManager, SIGNAL(screenLayoutChanged()), mUninoteController, SLOT(screenLayoutChanged()));
     connect(displayManager, SIGNAL(screenLayoutChanged()), UBApplication::webController, SLOT(screenLayoutChanged()));
-    connect(displayManager, SIGNAL(adjustDisplayViewsRequired()), UBApplication::boardController, SLOT(adjustDisplayViews()));
+    connect(displayManager, &UBDisplayManager::availableScreenCountChanged, [this](){
+        initPreviousViews();
+        UBApplication::displayManager->setPreviousDisplaysWidgets(mPreviousViews);
+    });
     connect(mUninoteController, SIGNAL(imageCaptured(const QPixmap &, bool)), this, SLOT(addCapturedPixmap(const QPixmap &, bool)));
     connect(mUninoteController, SIGNAL(restoreUniboard()), this, SLOT(hideDesktop()));
 
@@ -141,6 +144,8 @@ void UBApplicationController::initViewState(int horizontalPosition, int vertical
 
 void UBApplicationController::initScreenLayout(bool useMultiscreen)
 {
+    initPreviousViews();
+
     UBDisplayManager* displayManager = UBApplication::displayManager;
 
     displayManager->setControlWidget(mMainWindow);
@@ -159,11 +164,9 @@ void UBApplicationController::screenLayoutChanged()
     initViewState(mControlView->horizontalScrollBar()->value(),
             mControlView->verticalScrollBar()->value());
 
-    initPreviousViews();
-
     adaptToolBar();
 
-    adjustDisplayView();
+    UBApplication::boardController->adjustDisplayViews();
 
     if (UBApplication::displayManager->hasDisplay())
     {
@@ -174,8 +177,6 @@ void UBApplicationController::screenLayoutChanged()
        UBApplication::boardController->setBoxing(QRect());
     }
 
-    adjustPreviousViews(0, 0);
-
     // update mirror if necessary
     UBDisplayManager* displayManager = UBApplication::displayManager;
 
diff --git a/src/core/UBDisplayManager.h b/src/core/UBDisplayManager.h
index d08281174..3058f0381 100644
--- a/src/core/UBDisplayManager.h
+++ b/src/core/UBDisplayManager.h
@@ -106,7 +106,6 @@ class UBDisplayManager : public QObject
 
         void screenLayoutChanged();
         void availableScreenCountChanged(int screenCount);
-        void adjustDisplayViewsRequired();
 
    public slots:
 

From e5ef9eb96cb618bd373b12df7dff0408204be0d9 Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Wed, 15 Jun 2022 09:54:20 +0200
Subject: [PATCH 09/12] fix: typo in debug message

---
 src/core/UBPersistenceWorker.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/core/UBPersistenceWorker.cpp b/src/core/UBPersistenceWorker.cpp
index 3d8667ab6..abb098686 100644
--- a/src/core/UBPersistenceWorker.cpp
+++ b/src/core/UBPersistenceWorker.cpp
@@ -62,7 +62,7 @@ void UBPersistenceWorker::saveMetadata(UBDocumentProxy *proxy)
 
 void UBPersistenceWorker::applicationWillClose()
 {
-    qDebug() << "applicaiton Will close signal received";
+    qDebug() << "application Will close signal received";
     mReceivedApplicationClosing = true;
     mSemaphore.release();
 }

From e639f0ae496ec45268c3233c9d894641b0a9299c Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Wed, 15 Jun 2022 11:35:25 +0200
Subject: [PATCH 10/12] fix: additional UBDisplayManager and
 UBPreferencesController changes

- split into three phases
  - initScreenIndexes
  - assignRoles
  - positionScreens
- no delayed execution in adjustScreens
- move initial window position to positionScreens
- make use of access functions also internally
- remove QCompleter, makes no sense and steals focus
- add and remove widgets for previous views as needed, don't recreate
- ignore wheel events on non-interactive boards
- compute grid size when screen roles are assigned
---
 src/board/UBBoardController.cpp      |   4 +-
 src/board/UBBoardView.cpp            |   7 ++
 src/core/UBApplicationController.cpp |  13 ++-
 src/core/UBDisplayManager.cpp        | 169 ++++++++++++++-------------
 src/core/UBDisplayManager.h          |  11 +-
 src/core/UBPreferencesController.cpp |  23 ++--
 src/core/UBPreferencesController.h   |   1 -
 7 files changed, 127 insertions(+), 101 deletions(-)

diff --git a/src/board/UBBoardController.cpp b/src/board/UBBoardController.cpp
index 9877ade68..0bdd0d894 100644
--- a/src/board/UBBoardController.cpp
+++ b/src/board/UBBoardController.cpp
@@ -152,7 +152,9 @@ void UBBoardController::init()
 
     setActiveDocumentScene(doc);
 
-    initBackgroundGridSize();
+    connect(UBApplication::displayManager, &UBDisplayManager::screenRolesAssigned, [this](){
+        initBackgroundGridSize();
+    });
 
     undoRedoStateChange(true);
 
diff --git a/src/board/UBBoardView.cpp b/src/board/UBBoardView.cpp
index 41ae3a811..99892242d 100644
--- a/src/board/UBBoardView.cpp
+++ b/src/board/UBBoardView.cpp
@@ -1542,6 +1542,13 @@ void UBBoardView::mouseDoubleClickEvent (QMouseEvent *event)
 
 void UBBoardView::wheelEvent (QWheelEvent *wheelEvent)
 {
+    if (!isInteractive())
+    {
+        // ignore event on non-interactive views
+        wheelEvent->accept();
+        return;
+    }
+
     // Zoom in/out when Ctrl is pressed
     if (wheelEvent->modifiers() == Qt::ControlModifier && wheelEvent->orientation() == Qt::Vertical)
     {
diff --git a/src/core/UBApplicationController.cpp b/src/core/UBApplicationController.cpp
index 43c641d61..bb92920b5 100644
--- a/src/core/UBApplicationController.cpp
+++ b/src/core/UBApplicationController.cpp
@@ -539,15 +539,22 @@ void UBApplicationController::updateRequestFinished(QNetworkReply * reply)
 
 void UBApplicationController::initPreviousViews()
 {
-    qDeleteAll(mPreviousViews);
-    mPreviousViews.clear();
+    int numPreviousViews = UBApplication::displayManager->numPreviousViews();
 
-    for(int i = 0; i < UBApplication::displayManager->numPreviousViews(); i++)
+    // create the missing views
+    for (int i = mPreviousViews.count(); i < numPreviousViews; i++)
     {
         UBBoardView *previousView = new UBBoardView(UBApplication::boardController, UBItemLayerType::FixedBackground, UBItemLayerType::Tool, 0);
         previousView->setInteractive(false);
         mPreviousViews.append(previousView);
     }
+
+    // delete the superfluous views
+    while (mPreviousViews.count() > numPreviousViews)
+    {
+        UBBoardView* view = mPreviousViews.takeLast();
+        delete view;
+    }
 }
 
 
diff --git a/src/core/UBDisplayManager.cpp b/src/core/UBDisplayManager.cpp
index 28104f5a4..6a2c248f2 100644
--- a/src/core/UBDisplayManager.cpp
+++ b/src/core/UBDisplayManager.cpp
@@ -94,6 +94,7 @@ void UBDisplayManager::initScreenIndexes()
 
     if (screens != mAvailableScreens)
     {
+        qDebug() << "availableScreens" << screens;
         mAvailableScreens = screens;
         emit availableScreenCountChanged(screens.count());
     }
@@ -103,9 +104,13 @@ void UBDisplayManager::initScreenIndexes()
      * in the UBPreferencesManager, so we now get the screen list valid for
      * the new monitor configuration.
      */
+}
 
+void UBDisplayManager::assignRoles()
+{
     QVariant appScreenList = UBSettings::settings()->appScreenList->get();
     QStringList screenList = appScreenList.toStringList();
+    qDebug() << "assignRoles using screen list" << screenList;
 
     if (!appScreenList.isValid())
     {
@@ -113,12 +118,12 @@ void UBDisplayManager::initScreenIndexes()
         // "old" configuration mode
         bool swapScreens = UBSettings::settings()->swapControlAndDisplayScreens->get().toBool();
 
-        mScreensByRole[ScreenRole::Control] = screens[0];
+        mScreensByRole[ScreenRole::Control] = mAvailableScreens[0];
 
-        if (screens.count() > 1)
+        if (mAvailableScreens.count() > 1)
         {
-            QScreen* controlScreen = screens[0];
-            QScreen* displayScreen = screens[1];
+            QScreen* controlScreen = mAvailableScreens[0];
+            QScreen* displayScreen = mAvailableScreens[1];
 
             if (swapScreens)
             {
@@ -133,9 +138,9 @@ void UBDisplayManager::initScreenIndexes()
 
             ScreenRole role(ScreenRole::Previous1);
 
-            for (int i = 2; i < screens.count(); ++i)
+            for (int i = 2; i < mAvailableScreens.count(); ++i)
             {
-                mScreensByRole[role++] = screens[i];
+                mScreensByRole[role++] = mAvailableScreens[i];
                 screenList << QString::number(i + 1);
             }
 
@@ -180,7 +185,7 @@ void UBDisplayManager::initScreenIndexes()
         }
 
         // configure control screen, by default use primary screen
-        QScreen* controlScreen = primaryScreen;
+        QScreen* controlScreen = mAvailableScreens[0];
 
         if (!indexList.empty() && mAvailableScreens[indexList[0]])
         {
@@ -216,6 +221,8 @@ void UBDisplayManager::initScreenIndexes()
 
     // Desktop screen is same as Control screen
     mScreensByRole[ScreenRole::Desktop] = mScreensByRole[ScreenRole::Control];
+
+    emit screenRolesAssigned();
 }
 
 int UBDisplayManager::numScreens()
@@ -230,7 +237,7 @@ int UBDisplayManager::numPreviousViews()
 
     for (ScreenRole role = ScreenRole::Previous1; role <= ScreenRole::Previous5; ++role)
     {
-        if (mScreensByRole.value(role))
+        if (screen(role))
         {
             ++previousViews;
         }
@@ -242,15 +249,8 @@ int UBDisplayManager::numPreviousViews()
 
 void UBDisplayManager::setControlWidget(QWidget* pControlWidget)
 {
-    if (hasControl() && pControlWidget)
+    if (pControlWidget)
     {
-        // set an initial geometry for window mode
-        QScreen* controlScreen = mScreensByRole[ScreenRole::Control];
-        QRect geometry = controlScreen->geometry();
-        geometry.setSize(geometry.size() - QSize(150, 150));
-        geometry.moveTo(50, 50);
-        pControlWidget->setGeometry(geometry);
-
         mWidgetsByRole[ScreenRole::Control] = pControlWidget;
     }
 }
@@ -265,20 +265,20 @@ void UBDisplayManager::setDesktopWidget(QWidget* pDesktopWidget )
 
 void UBDisplayManager::setDisplayWidget(QWidget* pDisplayWidget)
 {
-    if (pDisplayWidget)
+    if (pDisplayWidget && pDisplayWidget != widget((ScreenRole::Display)))
     {
         if (widget(ScreenRole::Display))
         {
-            mWidgetsByRole[ScreenRole::Display]->hide();
-            pDisplayWidget->setGeometry(mWidgetsByRole[ScreenRole::Display]->geometry());
-            pDisplayWidget->setWindowFlags(mWidgetsByRole[ScreenRole::Display]->windowFlags());
+            widget(ScreenRole::Display)->hide();
+            pDisplayWidget->setGeometry(widget(ScreenRole::Display)->geometry());
+            pDisplayWidget->setWindowFlags(widget(ScreenRole::Display)->windowFlags());
         }
 
         mWidgetsByRole[ScreenRole::Display] = pDisplayWidget;
 
-        if (mScreensByRole.value(ScreenRole::Display))
+        if (screen(ScreenRole::Display))
         {
-            pDisplayWidget->setGeometry(mScreensByRole[ScreenRole::Display]->geometry());
+            pDisplayWidget->setGeometry(screen(ScreenRole::Display)->geometry());
             UBPlatformUtils::showFullScreen(pDisplayWidget);
         }
     }
@@ -295,9 +295,14 @@ void UBDisplayManager::setPreviousDisplaysWidgets(QList<UBBoardView*> pPreviousV
     }
 }
 
-QWidget* UBDisplayManager::widget(ScreenRole role)
+QWidget* UBDisplayManager::widget(ScreenRole role) const
+{
+    return mWidgetsByRole.value(role);
+}
+
+QScreen* UBDisplayManager::screen(ScreenRole role) const
 {
-    return mWidgetsByRole.value(role, nullptr);
+    return mScreensByRole.value(role);
 }
 
 QList<QScreen *> UBDisplayManager::availableScreens() const
@@ -307,85 +312,95 @@ QList<QScreen *> UBDisplayManager::availableScreens() const
 
 void UBDisplayManager::adjustScreens()
 {
-    initScreenIndexes();
-
-    // delayed execution to avoid interference with window managers
-    QTimer::singleShot(200, [this](){
-        positionScreens();
-        emit screenLayoutChanged();
-    });
+    assignRoles();
+    positionScreens();
 }
 
-
 void UBDisplayManager::positionScreens()
 {
+    qDebug() << "positionScreens";
     if (widget(ScreenRole::Desktop) && hasControl())
     {
-        mWidgetsByRole[ScreenRole::Desktop]->hide();
-        mWidgetsByRole[ScreenRole::Desktop]->setGeometry(mScreensByRole[ScreenRole::Control]->geometry());
+        widget(ScreenRole::Desktop)->hide();
+        widget(ScreenRole::Desktop)->setGeometry(screen(ScreenRole::Control)->geometry());
     }
 
-    if (mWidgetsByRole.value(ScreenRole::Control) && hasControl())
+    if (widget(ScreenRole::Control) && hasControl())
     {
-        QWidget* controlWidget = mWidgetsByRole[ScreenRole::Control];
+        QWidget* controlWidget = widget(ScreenRole::Control);
+
         controlWidget->showNormal();
 
-        QRect geometry = mScreensByRole[ScreenRole::Control]->geometry();
+        QRect geometry = screenGeometry(ScreenRole::Control);
 
         if (UBSettings::settings()->appRunInWindow->get().toBool())
         {
-            // reuse previous size and relative position
-            QRect previousGeometry = controlWidget->geometry();
-            QScreen* previousScreen = QGuiApplication::screenAt(previousGeometry.topLeft());
-
-            if (previousScreen)
+            if (controlWidget->property("isInitialized").toBool())
             {
-                QRect previousScreenGeometry = QGuiApplication::screenAt(previousGeometry.topLeft())->geometry();
-                QPoint offset = previousGeometry.topLeft() - previousScreenGeometry.topLeft();
-                geometry.setSize(previousGeometry.size());
-                geometry.moveTo(geometry.topLeft() + offset);
-
-                // make sure widget fits to screen
-                geometry = mScreensByRole[ScreenRole::Control]->geometry().intersected(geometry);
+                // reuse previous size and relative position
+                QRect previousGeometry = controlWidget->geometry();
+                QScreen* previousScreen = QGuiApplication::screenAt(previousGeometry.topLeft());
+
+                if (previousScreen)
+                {
+                    QRect previousScreenGeometry = QGuiApplication::screenAt(previousGeometry.topLeft())->geometry();
+                    QPoint offset = previousGeometry.topLeft() - previousScreenGeometry.topLeft();
+                    geometry.setSize(previousGeometry.size());
+                    geometry.moveTo(geometry.topLeft() + offset);
+
+                    // make sure widget fits to screen
+                    geometry = screenGeometry(ScreenRole::Control).intersected(geometry);
+                }
+            }
+            else
+            {
+                // calculate an initial geometry for window mode
+                geometry.setSize(geometry.size() - QSize(150, 150));
+                geometry.translate(50, 50);
+                controlWidget->setProperty("isInitialized", true);
             }
         }
 
+        qDebug() << "control geometry" << geometry;
         controlWidget->setGeometry(geometry);
         UBPlatformUtils::showFullScreen(controlWidget);
     }
 
-    if (mWidgetsByRole.value(ScreenRole::Display) && hasDisplay())
+    if (widget(ScreenRole::Display) && hasDisplay() && mUseMultiScreen)
     {
-        mWidgetsByRole[ScreenRole::Display]->showNormal();
-        mWidgetsByRole[ScreenRole::Display]->setGeometry(mScreensByRole[ScreenRole::Display]->geometry());
-        UBPlatformUtils::showFullScreen(mWidgetsByRole[ScreenRole::Display]);
+        qDebug() << "display geometry" << screenGeometry(ScreenRole::Display);
+        widget(ScreenRole::Display)->showNormal();
+        widget(ScreenRole::Display)->setGeometry(screenGeometry(ScreenRole::Display));
+        UBPlatformUtils::showFullScreen(widget(ScreenRole::Display));
     }
-    else if (mWidgetsByRole.value(ScreenRole::Display))
+    else if (widget(ScreenRole::Display))
     {
-        mWidgetsByRole[ScreenRole::Display]->hide();
+        widget(ScreenRole::Display)->hide();
     }
 
     for (ScreenRole role = ScreenRole::Previous1; role <= ScreenRole::Previous5; ++role)
     {
-        if (mWidgetsByRole.value(role))
+        if (widget(role))
         {
-            if (mScreensByRole.value(role)) {
-                QWidget* previous = mWidgetsByRole[role];
+            if (screen(role)) {
+                QWidget* previous = widget(role);
                 previous->showNormal();
-                previous->setGeometry(mScreensByRole[role]->geometry());
+                previous->setGeometry(screenGeometry(role));
                 UBPlatformUtils::showFullScreen(previous);
             }
             else
             {
-                mWidgetsByRole[role]->hide();
+                widget(role)->hide();
             }
         }
     }
 
-    if (mWidgetsByRole.value(ScreenRole::Control) && hasControl())
+    if (widget(ScreenRole::Control) && hasControl())
     {
-        mWidgetsByRole[ScreenRole::Control]->activateWindow();
+        widget(ScreenRole::Control)->activateWindow();
     }
+
+    emit screenLayoutChanged();
 }
 
 
@@ -431,21 +446,19 @@ void UBDisplayManager::unBlackout()
     UBApplication::boardController->freezeW3CWidgets(false);
 }
 
-
 void UBDisplayManager::addOrRemoveScreen(QScreen *screen)
 {
     Q_UNUSED(screen);
 
     initScreenIndexes();
+    assignRoles();
 
     // positioning must be delayed, because OS also tries to position the widgets
     QTimer::singleShot(3000, [this](){
         positionScreens();
-        emit screenLayoutChanged();
     });
 }
 
-
 void UBDisplayManager::setUseMultiScreen(bool pUse)
 {
     mUseMultiScreen = pUse;
@@ -453,43 +466,43 @@ void UBDisplayManager::setUseMultiScreen(bool pUse)
 
 QSize UBDisplayManager::screenSize(ScreenRole role) const
 {
-    QScreen* screen = mScreensByRole.value(role);
-    return screen ? screen->size() : QSize();
+    QScreen* scr = screen(role);
+    return scr ? scr->size() : QSize();
 }
 
 QSize UBDisplayManager::availableScreenSize(ScreenRole role) const
 {
-    QScreen* screen = mScreensByRole.value(role);
-    return screen ? screen->availableSize() : QSize();
+    QScreen* scr = screen(role);
+    return scr ? scr->availableSize() : QSize();
 }
 
 QRect UBDisplayManager::screenGeometry(ScreenRole role) const
 {
-    QScreen* screen = mScreensByRole.value(role);
-    return screen ? screen->geometry() : QRect();
+    QScreen* scr = screen(role);
+    return scr ? scr->geometry() : QRect();
 }
 
 qreal UBDisplayManager::physicalDpi(ScreenRole role) const
 {
-    QScreen* screen = mScreensByRole.value(role);
-    return screen ? screen->physicalDotsPerInch() : 96.;
+    QScreen* scr = screen(role);
+    return scr ? scr->physicalDotsPerInch() : 96.;
 }
 
 qreal UBDisplayManager::logicalDpi(ScreenRole role) const
 {
-    QScreen* screen = mScreensByRole.value(role);
-    return screen ? screen->logicalDotsPerInch() : 96.;
+    QScreen* scr = screen(role);
+    return scr ? scr->logicalDotsPerInch() : 96.;
 }
 
 QPixmap UBDisplayManager::grab(ScreenRole role, QRect rect) const
 {
-    QScreen* screen = mScreensByRole.value(role);
+    QScreen* scr = screen(role);
 
-    if (screen)
+    if (scr)
     {
         // see https://doc.qt.io/qt-6.2/qtwidgets-desktop-screenshot-example.html
         // for using window id 0
-        return screen->grabWindow(0, rect.x(), rect.y(), rect.width(), rect.height());
+        return scr->grabWindow(0, rect.x(), rect.y(), rect.width(), rect.height());
     }
 
     return QPixmap();
diff --git a/src/core/UBDisplayManager.h b/src/core/UBDisplayManager.h
index 3058f0381..3f5f17ffc 100644
--- a/src/core/UBDisplayManager.h
+++ b/src/core/UBDisplayManager.h
@@ -67,7 +67,8 @@ class UBDisplayManager : public QObject
 
         void setPreviousDisplaysWidgets(QList<UBBoardView*> pPreviousViews);
 
-        QWidget* widget(ScreenRole role);
+        QWidget* widget(ScreenRole role) const;
+        QScreen* screen(ScreenRole role) const;
 
         QList<QScreen*> availableScreens() const;
 
@@ -103,7 +104,7 @@ class UBDisplayManager : public QObject
         QPixmap grabGlobal(QRect rect) const;
 
    signals:
-
+        void screenRolesAssigned();
         void screenLayoutChanged();
         void availableScreenCountChanged(int screenCount);
 
@@ -115,13 +116,15 @@ class UBDisplayManager : public QObject
 
         void unBlackout();
 
+    private slots:
+
         void addOrRemoveScreen(QScreen* screen);
 
     private:
 
-        void positionScreens();
-
         void initScreenIndexes();
+        void assignRoles();
+        void positionScreens();
 
         QList<UBBlackoutWidget*> mBlackoutWidgets;
 
diff --git a/src/core/UBPreferencesController.cpp b/src/core/UBPreferencesController.cpp
index 7f479f96a..8667a03ce 100644
--- a/src/core/UBPreferencesController.cpp
+++ b/src/core/UBPreferencesController.cpp
@@ -130,10 +130,11 @@ void UBPreferencesController::adjustScreens()
 
     auto availableScreens = UBApplication::displayManager->availableScreens();
     QStringList screenNames;
+    QRegularExpression specialChars("[^a-zA-Z0-9]+");
 
     for (QScreen* screen : availableScreens)
     {
-        screenNames << screen->name().replace("/", "");
+        screenNames << screen->name().replace(specialChars, "-");
     }
 
     QString screenConfiguration = screenNames.join('_');
@@ -792,7 +793,6 @@ UBBrushPropertiesFrame::UBBrushPropertiesFrame(QFrame* owner, const QList<QColor
 UBScreenListLineEdit::UBScreenListLineEdit(QWidget *parent)
     : QLineEdit(parent)
     , mValidator(nullptr)
-    , mCompleter(nullptr)
 {
     connect(this, &QLineEdit::textChanged, this, &UBScreenListLineEdit::onTextChanged);
 }
@@ -856,7 +856,6 @@ void UBScreenListLineEdit::focusInEvent(QFocusEvent *focusEvent)
 void UBScreenListLineEdit::focusOutEvent(QFocusEvent *focusEvent)
 {
     QLineEdit::focusOutEvent(focusEvent);
-
     qDeleteAll(mScreenLabels);
     mScreenLabels.clear();
 }
@@ -904,23 +903,12 @@ void UBScreenListLineEdit::onTextChanged(const QString &input)
                 model << input + button->text();
             }
         }
-
-        if (!mCompleter)
-        {
-            mCompleter = new QCompleter(model, this);
-            setCompleter(mCompleter);
-        }
-        else
-        {
-            mCompleter->setModel(new QStringListModel(model, mCompleter));
-        }
     }
 
     // user indication of acceptable input
     if (hasAcceptableInput())
     {
         setStyleSheet("");
-
         QStringList screenList = splitScreenList(input);
         emit screenListChanged(screenList);
     }
@@ -958,6 +946,13 @@ QValidator::State UBStringListValidator::validate(QString &input, int &) const
 {
     bool ok = true;
     QStringList inputList = splitScreenList(input);
+    // number of commas must match number of list items - 1
+    int commas = input.count(',');
+
+    if (commas && commas + 1 != inputList.size())
+    {
+        ok = false;
+    }
 
     for (const QString& token : inputList)
     {
diff --git a/src/core/UBPreferencesController.h b/src/core/UBPreferencesController.h
index 16e13bc3b..dee191610 100644
--- a/src/core/UBPreferencesController.h
+++ b/src/core/UBPreferencesController.h
@@ -153,7 +153,6 @@ private slots:
 private:
     QList<QPushButton*> mScreenLabels;
     QValidator* mValidator;
-    QCompleter* mCompleter;
 };
 
 class UBStringListValidator : public QValidator

From 281a072d48297a7e00932b4ee191e5d371a5395a Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Wed, 15 Jun 2022 17:13:56 +0200
Subject: [PATCH 11/12] feat: improve boxing in window mode

- calculate boxing as if window would be full screen
---
 src/board/UBBoardController.cpp | 25 +++++++++++++++++++++----
 1 file changed, 21 insertions(+), 4 deletions(-)

diff --git a/src/board/UBBoardController.cpp b/src/board/UBBoardController.cpp
index 0bdd0d894..e69a7ddff 100644
--- a/src/board/UBBoardController.cpp
+++ b/src/board/UBBoardController.cpp
@@ -252,8 +252,12 @@ void UBBoardController::setBoxing(QRect displayRect)
         return;
     }
 
-    qreal controlWidth = (qreal)mMainWindow->centralWidget()->width();
-    qreal controlHeight = (qreal)mMainWindow->centralWidget()->height();
+    // compute boxing based on the assumed widget size for fullscreen
+    QSize centralWidgetSize = mMainWindow->centralWidget()->size();
+    QSize controlWindowSize = mMainWindow->size();
+    QSize controlScreenSize = UBApplication::displayManager->screenSize(ScreenRole::Control);
+    qreal controlWidth = controlScreenSize.width();
+    qreal controlHeight = controlScreenSize.height() - controlWindowSize.height() + centralWidgetSize.height();
     qreal displayWidth = (qreal)displayRect.width();
     qreal displayHeight = (qreal)displayRect.height();
 
@@ -263,13 +267,25 @@ void UBBoardController::setBoxing(QRect displayRect)
     if (displayRatio < controlRatio)
     {
         // Pillarboxing
-        int boxWidth = (controlWidth - (displayWidth * (controlHeight / displayHeight))) / 2;
+        int boxWidth = (centralWidgetSize.width() - (displayWidth * (controlHeight / displayHeight))) / 2;
+
+        if (boxWidth < 0)
+        {
+            boxWidth = 0;
+        }
+
         mControlLayout->setContentsMargins(boxWidth, 0, boxWidth, 0);
     }
     else if (displayRatio > controlRatio)
     {
         // Letterboxing
-        int boxHeight = (controlHeight - (displayHeight * (controlWidth / displayWidth))) / 2;
+        int boxHeight = (centralWidgetSize.height() - (displayHeight * (controlWidth / displayWidth))) / 2;
+
+        if (boxHeight < 0)
+        {
+            boxHeight = 0;
+        }
+
         mControlLayout->setContentsMargins(0, boxHeight, 0, boxHeight);
     }
     else
@@ -1810,6 +1826,7 @@ void UBBoardController::boardViewResized(QResizeEvent* event)
     if (mDisplayView) {
         UBApplication::applicationController->adjustDisplayView();
         mDisplayView->centerOn(0,0);
+        setBoxing(mDisplayView->geometry());
     }
 
     mPaletteManager->containerResized();

From 6a38501e33735f82e064656c4b82294798028e7a Mon Sep 17 00:00:00 2001
From: letsfindaway <me@letsfindaway.de>
Date: Fri, 17 Jun 2022 09:50:08 +0200
Subject: [PATCH 12/12] fix: object ownership, some cleanup

- set ownership of UBStringListValidator
- make UBStringListValidator mutable and add setValidationStringList
- lazy initialization and then update of UBStringListValidator
- rename some functions and variables for better clarity
- fix conversion from "old" screen configuration
- move constant code out of loop
- avoid duplicate splitting of input string
- remove obsolete setting
- fix default value for screen list setting
---
 src/core/UBPreferencesController.cpp | 55 +++++++++++++++-------------
 src/core/UBPreferencesController.h   |  9 ++++-
 src/core/UBSettings.cpp              |  6 ++-
 src/core/UBSettings.h                |  1 -
 4 files changed, 40 insertions(+), 31 deletions(-)

diff --git a/src/core/UBPreferencesController.cpp b/src/core/UBPreferencesController.cpp
index 8667a03ce..132b87fd1 100644
--- a/src/core/UBPreferencesController.cpp
+++ b/src/core/UBPreferencesController.cpp
@@ -52,19 +52,19 @@ qreal UBPreferencesController::sSliderRatio = 10.0;
 qreal UBPreferencesController::sMinPenWidth = 0.5;
 qreal UBPreferencesController::sMaxPenWidth = 50.0;
 
-// convenience function to convert between screen list as QString and QStringList
-QStringList splitScreenList(const QString& input)
+// convenience function to split a comma separated list of tokens to a QStringList
+QStringList trimmedTokens(const QString& input)
 {
-    QStringList screenList = input.split(',');
+    QStringList tokens = input.split(',');
 
-    for (QString& entry : screenList)
+    for (QString& entry : tokens)
     {
         entry = entry.trimmed();
     }
 
-    screenList.removeAll("");
+    tokens.removeAll("");
 
-    return screenList;
+    return tokens;
 }
 
 
@@ -144,9 +144,9 @@ void UBPreferencesController::adjustScreens()
     if (path != mScreenConfigurationPath)
     {
         mScreenConfigurationPath = path;
-        QStringList value = UBSettings::settings()->value(path).toStringList();
+        QVariant value = UBSettings::settings()->value(path);
         UBSettings::settings()->appScreenList->set(value);
-        mPreferencesUI->screenList->loadScreenList(value);
+        mPreferencesUI->screenList->loadScreenList(value.toStringList());
     }
 }
 
@@ -813,13 +813,16 @@ void UBScreenListLineEdit::focusInEvent(QFocusEvent *focusEvent)
 
     if (mScreenLabels.empty())
     {
-        QStringList screenNames = splitScreenList(text());
+        QStringList screenList = trimmedTokens(text());
 
         QList<QScreen*> screens = UBApplication::displayManager->availableScreens();
         QStringList availableScreenIndexes;
         int screenIndex = 1;
+        QFont font;
+        font.setPointSize(48);
 
-        for (QScreen* screen : screens) {
+        for (QScreen* screen : screens)
+        {
             availableScreenIndexes << QString::number(screenIndex);
 
             QPushButton* button = new QPushButton(this);
@@ -829,12 +832,10 @@ void UBScreenListLineEdit::focusInEvent(QFocusEvent *focusEvent)
             button->setWindowFlag(Qt::Window, true);
             button->setWindowFlag(Qt::WindowDoesNotAcceptFocus, true);
             button->setText(QString::number(screenIndex++));
-            QFont font;
-            font.setPointSize(48);
             button->setFont(font);
             button->move(screen->geometry().topLeft());
             button->setMinimumSize(300, 150);
-            button->setDisabled(screenNames.contains(button->text()));
+            button->setDisabled(screenList.contains(button->text()));
             button->show();
 
             connect(button, &QPushButton::pressed, this, &UBScreenListLineEdit::addScreen);
@@ -842,14 +843,13 @@ void UBScreenListLineEdit::focusInEvent(QFocusEvent *focusEvent)
             mScreenLabels << button;
         }
 
-        if (mValidator)
+        if (!mValidator)
         {
-            setValidator(nullptr);
-            delete mValidator;
+            mValidator = new UBStringListValidator(this);
+            setValidator(mValidator);
         }
 
-        mValidator = new UBStringListValidator(availableScreenIndexes);
-        setValidator(mValidator);
+        mValidator->setValidationStringList(availableScreenIndexes);
     }
 }
 
@@ -884,11 +884,11 @@ void UBScreenListLineEdit::addScreen()
 
 void UBScreenListLineEdit::onTextChanged(const QString &input)
 {
-    QStringList screenNames = splitScreenList(input);
+    QStringList screenList = trimmedTokens(input);
 
     for (QPushButton* button : mScreenLabels)
     {
-        button->setDisabled(screenNames.contains(button->text()));
+        button->setDisabled(screenList.contains(button->text()));
     }
 
     if (input.isEmpty() || input.right(1) == ',')
@@ -909,7 +909,6 @@ void UBScreenListLineEdit::onTextChanged(const QString &input)
     if (hasAcceptableInput())
     {
         setStyleSheet("");
-        QStringList screenList = splitScreenList(input);
         emit screenListChanged(screenList);
     }
     else
@@ -918,17 +917,16 @@ void UBScreenListLineEdit::onTextChanged(const QString &input)
     }
 }
 
-UBStringListValidator::UBStringListValidator(QStringList list, QObject *parent)
+UBStringListValidator::UBStringListValidator(QObject *parent)
     : QValidator(parent)
-    , mList(list)
 {
 
 }
 
 void UBStringListValidator::fixup(QString &input) const
 {
-    // remove invalid tokens from list
-    QStringList inputList = splitScreenList(input);
+    // remove invalid tokens from list, trim tokens
+    QStringList inputList = trimmedTokens(input);
     QStringList outputList;
 
     for (const QString& token : inputList)
@@ -945,7 +943,7 @@ void UBStringListValidator::fixup(QString &input) const
 QValidator::State UBStringListValidator::validate(QString &input, int &) const
 {
     bool ok = true;
-    QStringList inputList = splitScreenList(input);
+    QStringList inputList = trimmedTokens(input);
     // number of commas must match number of list items - 1
     int commas = input.count(',');
 
@@ -961,3 +959,8 @@ QValidator::State UBStringListValidator::validate(QString &input, int &) const
 
     return ok ? Acceptable : Intermediate;
 }
+
+void UBStringListValidator::setValidationStringList(const QStringList &list)
+{
+    mList = list;
+}
diff --git a/src/core/UBPreferencesController.h b/src/core/UBPreferencesController.h
index dee191610..6f0522a73 100644
--- a/src/core/UBPreferencesController.h
+++ b/src/core/UBPreferencesController.h
@@ -128,6 +128,9 @@ class UBBrushPropertiesFrame : public Ui::brushProperties
 
 };
 
+// forward
+class UBStringListValidator;
+
 class UBScreenListLineEdit : public QLineEdit
 {
     Q_OBJECT;
@@ -152,7 +155,7 @@ private slots:
 
 private:
     QList<QPushButton*> mScreenLabels;
-    QValidator* mValidator;
+    UBStringListValidator* mValidator;
 };
 
 class UBStringListValidator : public QValidator
@@ -160,12 +163,14 @@ class UBStringListValidator : public QValidator
     Q_OBJECT;
 
 public:
-    UBStringListValidator(QStringList list, QObject* parent = nullptr);
+    UBStringListValidator(QObject* parent = nullptr);
     virtual ~UBStringListValidator() = default;
 
     virtual void fixup(QString& input) const;
     virtual QValidator::State validate(QString& input, int& pos) const;
 
+    void setValidationStringList(const QStringList& list);
+
 private:
     QStringList mList;
 };
diff --git a/src/core/UBSettings.cpp b/src/core/UBSettings.cpp
index 0e02d358b..7c29f532b 100644
--- a/src/core/UBSettings.cpp
+++ b/src/core/UBSettings.cpp
@@ -243,10 +243,12 @@ void UBSettings::init()
     appEnableAutomaticSoftwareUpdates = new UBSetting(this, "App", "EnableAutomaticSoftwareUpdates", false);
     appSoftwareUpdateURL = new UBSetting(this, "App", "SoftwareUpdateURL", "http://www.openboard.ch/update.json");
     appHideCheckForSoftwareUpdate = new UBSetting(this, "App", "HideCheckForSoftwareUpdate", false);
-    appHideSwapDisplayScreens = new UBSetting(this, "App", "HideSwapDisplayScreens", true);
     appToolBarOrientationVertical = new UBSetting(this, "App", "ToolBarOrientationVertical", false);
     appPreferredLanguage = new UBSetting(this,"App","PreferredLanguage", "");
 
+    // removed in version 1.7.0
+    mUserSettings->remove("App/HideSwapDisplayScreens");
+
     rightLibPaletteBoardModeWidth = new UBSetting(this, "Board", "RightLibPaletteBoardModeWidth", 270);
     rightLibPaletteBoardModeIsCollapsed = new UBSetting(this,"Board", "RightLibPaletteBoardModeIsCollapsed",true);
     rightLibPaletteDesktopModeWidth = new UBSetting(this, "Board", "RightLibPaletteDesktopModeWidth", 270);
@@ -260,7 +262,7 @@ void UBSettings::init()
     appLastSessionDocumentUUID = new UBSetting(this, "App", "LastSessionDocumentUUID", "");
     appLastSessionPageIndex = new UBSetting(this, "App", "LastSessionPageIndex", 0);
     appUseMultiscreen = new UBSetting(this, "App", "UseMultiscreenMode", true);
-    appScreenList = new UBSetting(this, "App", "ScreenList", QStringList());
+    appScreenList = new UBSetting(this, "App", "ScreenList", QVariant());
 
     appStartupHintsEnabled = new UBSetting(this,"App","EnableStartupHints",false);
 
diff --git a/src/core/UBSettings.h b/src/core/UBSettings.h
index 84ff96ee5..1848ef708 100644
--- a/src/core/UBSettings.h
+++ b/src/core/UBSettings.h
@@ -259,7 +259,6 @@ class UBSettings : public QObject
         UBSetting* appEnableAutomaticSoftwareUpdates;
         UBSetting* appSoftwareUpdateURL;
         UBSetting* appHideCheckForSoftwareUpdate;
-        UBSetting* appHideSwapDisplayScreens;
         UBSetting* appToolBarOrientationVertical;
         UBSetting* appPreferredLanguage;
         UBSetting* appRunInWindow;
