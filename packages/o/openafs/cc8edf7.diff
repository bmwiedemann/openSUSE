From cc8edf7f9b75a2114ef6c7f003456b5515cbaaf5 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Tue, 05 Jul 2022 10:28:10 -0600
Subject: [PATCH] Linux: Introduce file mapping readpage helpers

Create a helper function that determines if a file's
 i_mapping->a_ops->readpage
is NULL.

Create a helper function that calls a file's
 i_mapping->a_ops->readpage

There are no functional changes with this commit.

Note: This commit isolates references to 'readpage' so that future
commits can change the name in a more straight forward manner.

Reviewed-on: https://gerrit.openafs.org/15039
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit a81f7300f08d6e515adbde4bce4b72a3102b60f9)

Change-Id: I9268fd2622ecd48ad6971a8faaeefef8128f4024
---

diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 5411863..b834a40 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -2206,6 +2206,18 @@
 
 #endif /* USABLE_KERNEL_PAGE_SYMLINK_CACHE */
 
+/*
+ * Call the mapping function that reads data for a given page.
+ * Note: When we return, it is expected that the page is unlocked.  It is the
+ * responsibility of the called function (e.g. ->readpage) to unlock the given
+ * page, even when an error occurs.
+ */
+static int
+mapping_read_page(struct address_space *mapping, struct page *page)
+{
+    return mapping->a_ops->readpage(NULL, page);
+}
+
 /* Populate a page by filling it from the cache file pointed at by cachefp
  * (which contains indicated chunk)
  * If task is NULL, the page copy occurs syncronously, and the routine
@@ -2272,9 +2284,9 @@
 
     if (!PageUptodate(cachepage)) {
 	ClearPageError(cachepage);
-	/* Note that ->readpage always handles unlocking the given page, even
-	 * when an error is returned. */
-	code = cachemapping->a_ops->readpage(NULL, cachepage);
+	/* Note that mapping_read_page always handles unlocking the given page,
+	 * even when an error is returned. */
+	code = mapping_read_page(cachemapping, cachepage);
 	if (!code && !task) {
 	    wait_on_page_locked(cachepage);
 	}
@@ -2306,6 +2318,17 @@
 	put_page(cachepage);
 
     return code;
+}
+
+/*
+ * Return true if the file has a mapping that can read pages
+ */
+static int inline
+file_can_read_pages(struct file *fp)
+{
+    if (fp->f_dentry->d_inode->i_mapping->a_ops->readpage != NULL)
+	return 1;
+    return 0;
 }
 
 static int inline
@@ -2403,7 +2426,8 @@
 	AFS_GLOCK();
 	goto out;
     }
-    if (!cacheFp->f_dentry->d_inode->i_mapping->a_ops->readpage) {
+
+    if (!file_can_read_pages(cacheFp)) {
 	cachefs_noreadpage = 1;
 	AFS_GLOCK();
 	goto out;
@@ -2871,7 +2895,7 @@
 		code = -1;
 		goto out;
 	    }
-	    if (cacheFp->f_dentry->d_inode->i_mapping->a_ops->readpage == NULL) {
+	    if (!file_can_read_pages(cacheFp)) {
 		cachefs_noreadpage = 1;
 		/* No mapping function */
 		code = -1;
