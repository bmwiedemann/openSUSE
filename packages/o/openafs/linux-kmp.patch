From 20b8a37950b3718b85a4a3d21b23469a5176eb6a Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 07 Oct 2021 11:15:58 -0600
Subject: [PATCH] LINUX 5.14: explicitly set set_page_dirty to default

Linux 5.14 commit: 'mm: require ->set_page_dirty to be explicitly wired
up' (0af573780b0b13) removed calling __set_page_dirty_buffers when the
address_space_operations structure member set_page_dirty was NULL.

A kernel RIP error can occur when the set_page_dirty operation is
requested. (Reproducible by running 'iozone -B -a')

Update the definition for afs_file_aops to explicitly set the
'set_page_dirty' member to '__set_page_dirty_buffers'.

There are no functional changes, since this commit is using the same
function that the Linux kernel was using if set_page_dirty had been
NULL.

Problem originally reported by "Andrej Filipcic"
<andrej.filipcic@ijs.si> in the openafs-info mailing list.  The Linux
5.14 commit causing the openafs failure was identified by "Michael Laß"
<lass@mail.upb.de> also on in the openafs-info mailing list.

Note: The declaration for the function '__set_page_dirty_buffers' was
moved from linux/mm.h into linux/buffer_head.h in Linux 2.6.19.  Since
this is close to the minimum supported Linux version 2.6.18, we are not
introducing an additional autoconf test to determine which header file
the declaration for __set_page_dirty_buffers resides in.

Reviewed-on: https://gerrit.openafs.org/14826
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Mark Vitale <mvitale@sinenomine.net>
Tested-by: Michael Laß <lass@mail.uni-paderborn.de>
Reviewed-by: Michael Laß <lass@mail.uni-paderborn.de>
Tested-by: Cheyenne Wills <cwills@sinenomine.net>
Reviewed-by: Ralf Brunckhorst <rbrunckhorst@sinenomine.net>
Tested-by: Ralf Brunckhorst <rbrunckhorst@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit ba485a13e965909b63b25103fdf810de381e4977)

Change-Id: Iae61573e5ccf9458646eba4403322536fd86f2bf
---

diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index f4bedae..00103a5 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -26,6 +26,7 @@
 #include "afsincludes.h"
 #include "afs/afs_stats.h"
 #include <linux/mm.h>
+#include <linux/buffer_head.h>
 #ifdef HAVE_MM_INLINE_H
 #include <linux/mm_inline.h>
 #endif
@@ -3287,6 +3288,7 @@
   .readpage =		afs_linux_readpage,
   .readpages = 		afs_linux_readpages,
   .writepage =		afs_linux_writepage,
+  .set_page_dirty =	__set_page_dirty_buffers,
 #if defined (STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_WRITE_BEGIN)
   .write_begin =        afs_linux_write_begin,
   .write_end =          afs_linux_write_end,
From 4b752d855fb7315cbc119e39b1bbc0b50e6d56b4 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Fri, 12 Nov 2021 14:42:57 -0700
Subject: [PATCH] Linux 5.15: Convert osi_Msg macro to a function

With Linux 5.15-prerc1 printk is defined as a macro instead of a
function ("printk: Userspace format indexing support" 33701557)

This change is causing a build failure:

 .../src/rx/rx_kernel.h:62:18: error: ‘printk’ undeclared (first use in
   this function); did you mean ‘_printk’?
   62 | # define osi_Msg printk)(
      |                  ^~~~~~

The definition and use of the osi_Msg and osi_VMsg macros are
unconventional and the C preprocessor is not handling the macro
expansion when printk is itself a macro.

   #define osi_Msg printk)(
   ...
   (osi_Msg "%s", x);

Change osi_Msg to a function, and simply replace osi_VMsg with vprintf
since osi_VMsg is only used at one location within user space code.

osi_Msg is implemented in 2 locations, in rx_kcommon for kernel space
and in rx_user for userspace.

Note: The unconventional definitions of osi_Msg/osi_VMsg was historical
and due to older compilers not supporting variadic macros.  All of
the currently support platforms should now support variadic functions.

Reviewed-on: https://gerrit.openafs.org/14791
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 22876c8b88f8e5e92f08b230e5e1959499f0c406)

Change-Id: I48a67b2fe79b45403414bb7d962c29c9be07262e
---

diff --git a/src/rx/rx.c b/src/rx/rx.c
index a9cf2fc..4931f73 100644
--- a/src/rx/rx.c
+++ b/src/rx/rx.c
@@ -1745,14 +1745,14 @@
     clock_NewTime();
 
     if (serviceId == 0) {
-	(osi_Msg
+	osi_Msg(
 	 "rx_NewService:  service id for service %s is not non-zero.\n",
 	 serviceName);
 	return 0;
     }
     if (port == 0) {
 	if (rx_port == 0) {
-	    (osi_Msg
+	    osi_Msg(
 	     "rx_NewService: A non-zero port must be specified on this call if a non-zero port was not provided at Rx initialization (service %s).\n",
 	     serviceName);
 	    return 0;
@@ -1775,7 +1775,7 @@
 		     * installed; if the caller was intending to
 		     * change the security classes used by this
 		     * service, he/she loses. */
-		    (osi_Msg
+		    osi_Msg(
 		     "rx_NewService: tried to install service %s with service id %d, which is already in use for service %s\n",
 		     serviceName, serviceId, service->serviceName);
 		    USERPRI;
@@ -1820,7 +1820,7 @@
     }
     USERPRI;
     rxi_FreeService(tservice);
-    (osi_Msg "rx_NewService: cannot support > %d services\n",
+    osi_Msg("rx_NewService: cannot support > %d services\n",
      RX_MAX_SERVICES);
     return 0;
 }
diff --git a/src/rx/rx_internal.h b/src/rx/rx_internal.h
index b420a23..274d981 100644
--- a/src/rx/rx_internal.h
+++ b/src/rx/rx_internal.h
@@ -75,3 +75,6 @@
 			  int iovcnt, size_t length, int istack);
 extern void rxi_SendRaw(struct rx_call *call, struct rx_connection *conn,
 			int type, char *data, int bytes, int istack);
+
+/* rx_kcommon.c / rx_user.c */
+extern void osi_Msg(const char *fmt, ...) AFS_ATTRIBUTE_FORMAT(__printf__, 1, 2);
diff --git a/src/rx/rx_kcommon.c b/src/rx/rx_kcommon.c
index f6045fa..0b2000d 100644
--- a/src/rx/rx_kcommon.c
+++ b/src/rx/rx_kcommon.c
@@ -1298,6 +1298,19 @@
 # endif /* RXK_LISTENER_ENV */
 #endif /* !UKERNEL */
 
+void
+osi_Msg(const char *fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+#if defined(AFS_LINUX26_ENV)
+    vprintk(fmt, ap);
+#else
+    vprintf(fmt, ap);
+#endif
+    va_end(ap);
+}
+
 #if !defined(AFS_LINUX26_ENV)
 void
 # if defined(AFS_AIX_ENV)
diff --git a/src/rx/rx_kernel.h b/src/rx/rx_kernel.h
index 1e7980d..6f10ba4 100644
--- a/src/rx/rx_kernel.h
+++ b/src/rx/rx_kernel.h
@@ -58,13 +58,6 @@
     (void)((exp) || (osi_AssertFailK( #exp , __FILE__, __LINE__), 0))
 # endif
 
-#ifdef AFS_LINUX20_ENV
-# define	osi_Msg printk)(
-#else
-# define	osi_Msg printf)(
-#endif
-#define osi_VMsg vprintf)(
-
 #define	osi_YieldIfPossible()
 #define	osi_WakeupAndYieldIfPossible(x)	    rx_Wakeup(x)
 
diff --git a/src/rx/rx_lwp.c b/src/rx/rx_lwp.c
index fec4329..4aa8c59 100644
--- a/src/rx/rx_lwp.c
+++ b/src/rx/rx_lwp.c
@@ -385,12 +385,12 @@
      */
     if (fcntl(sock, F_SETFL, FNDELAY) == -1) {
 	perror("fcntl");
-	(osi_Msg "rxi_Listen: unable to set non-blocking mode on socket\n");
+	osi_Msg("rxi_Listen: unable to set non-blocking mode on socket\n");
 	return -1;
     }
 
     if (sock > FD_SETSIZE - 1) {
-	(osi_Msg "rxi_Listen: socket descriptor > (FD_SETSIZE-1) = %d\n",
+	osi_Msg("rxi_Listen: socket descriptor > (FD_SETSIZE-1) = %d\n",
 	 FD_SETSIZE - 1);
 	return -1;
     }
@@ -442,7 +442,7 @@
 
 	if (!sfds) {
 	    if (!(sfds = IOMGR_AllocFDSet())) {
-		(osi_Msg "rx failed to alloc fd_set: ");
+		osi_Msg("rx failed to alloc fd_set: ");
 		perror("rx_sendmsg");
 		return -1;
 	    }
@@ -460,7 +460,7 @@
 	if (err != EWOULDBLOCK && err != ENOBUFS)
 #endif
 	{
-	    (osi_Msg "rx failed to send packet: ");
+	    osi_Msg("rx failed to send packet: ");
 	    perror("rx_sendmsg");
             if (err > 0)
               return -err;
diff --git a/src/rx/rx_user.c b/src/rx/rx_user.c
index 7e6c06b..04e1542 100644
--- a/src/rx/rx_user.c
+++ b/src/rx/rx_user.c
@@ -104,11 +104,11 @@
 
 #if !defined(AFS_NT40_ENV)
     if (ntohs(port) >= IPPORT_RESERVED && ntohs(port) < IPPORT_USERRESERVED) {
-/*	(osi_Msg "%s*WARNING* port number %d is not a reserved port number.  Use port numbers above %d\n", name, port, IPPORT_USERRESERVED);
+/*	osi_Msg("%s*WARNING* port number %d is not a reserved port number.  Use port numbers above %d\n", name, port, IPPORT_USERRESERVED);
 */ ;
     }
     if (ntohs(port) > 0 && ntohs(port) < IPPORT_RESERVED && geteuid() != 0) {
-	(osi_Msg
+	osi_Msg(
 	 "%sport number %d is a reserved port number which may only be used by root.  Use port numbers above %d\n",
 	 name, ntohs(port), IPPORT_USERRESERVED);
 	goto error;
@@ -144,7 +144,7 @@
         break;
     }
     if (code) {
-	(osi_Msg "%sbind failed\n", name);
+	osi_Msg("%sbind failed\n", name);
 	goto error;
     }
 #if !defined(AFS_NT40_ENV)
@@ -191,7 +191,7 @@
 	     (socketFd, SOL_SOCKET, SO_RCVBUF, (char *)&len2,
 	      sizeof(len2)) >= 0);
 	if (!greedy)
-	    (osi_Msg "%s*WARNING* Unable to increase buffering on socket\n",
+	    osi_Msg("%s*WARNING* Unable to increase buffering on socket\n",
 	     name);
         if (rx_stats_active)
             rx_atomic_set(&rx_stats.socketGreedy, greedy);
@@ -231,12 +231,21 @@
 }
 
 void
+osi_Msg(const char *fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+    vfprintf(stderr, fmt, ap);
+    va_end(ap);
+}
+
+void
 osi_Panic(char *msg, ...)
 {
     va_list ap;
     va_start(ap, msg);
-    (osi_Msg "Fatal Rx error: ");
-    (osi_VMsg msg, ap);
+    fprintf(stderr, "Fatal Rx error: ");
+    vfprintf(stderr, msg, ap);
     va_end(ap);
     fflush(stderr);
     fflush(stdout);
diff --git a/src/rx/rx_user.h b/src/rx/rx_user.h
index ecc036f..6b9dad9 100644
--- a/src/rx/rx_user.h
+++ b/src/rx/rx_user.h
@@ -65,7 +65,4 @@
 
 #define osi_Assert(e) opr_Assert(e)
 
-#define	osi_Msg			    fprintf)(stderr,
-#define osi_VMsg		    vfprintf)(stderr,
-
 #endif /* RX_USER_INCLUDE */
