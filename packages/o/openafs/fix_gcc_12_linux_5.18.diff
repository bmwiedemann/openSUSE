From 0937ab044dd14fbe3461066759dd0529818f9c1b Mon Sep 17 00:00:00 2001
From: Pat Riehecky <riehecky@fnal.gov>
Date: Wed, 19 Sep 2018 15:51:00 -0500
Subject: [PATCH] configure.ac: Add missing double include guard

This is primarily a sanity check (identified by clang-tidy).

Reviewed-on: https://gerrit.openafs.org/13333
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit ec45ae60536190c2f5fbf272a9acfe0a85824e24)

Change-Id: I6cf42d3645fa2669971a3adcd320397afb4cf2bd
---

diff --git a/acinclude.m4 b/acinclude.m4
index c06945c..53230ae 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -5,6 +5,7 @@
 dnl parameters must be done like $[]1 instead of $1
 
 AC_DEFUN([OPENAFS_CONFIGURE_COMMON],[
+OPENAFS_AUTOHEADER_TOP
 OPENAFS_AUTOHEADER_BOTTOM
 AC_CANONICAL_HOST
 SRCDIR_PARENT=`pwd`
diff --git a/src/cf/autoheader.m4 b/src/cf/autoheader.m4
index b4be641..6d9d54a 100644
--- a/src/cf/autoheader.m4
+++ b/src/cf/autoheader.m4
@@ -1,3 +1,8 @@
+AC_DEFUN([OPENAFS_AUTOHEADER_TOP],[
+    AH_TOP([
+#ifndef __AFSCONFIG_H
+#define __AFSCONFIG_H 1])
+])
 AC_DEFUN([OPENAFS_AUTOHEADER_BOTTOM],[
     AH_BOTTOM([
 #undef HAVE_RES_SEARCH
@@ -57,5 +62,6 @@
 #undef ENABLE_REDHAT_BUILDSYS
 #if defined(ENABLE_REDHAT_BUILDSYS) && defined(KERNEL) && defined(REDHAT_FIX)
 # include "redhat-fix.h"
-#endif])
+#endif
+#endif /* __AFSCONFIG_H */])
 ])
From 0d6ca2205df7e17424cd1037736c388b4577b717 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 02 Jun 2022 13:45:27 -0600
Subject: [PATCH] autoconf: Remove/update obsolete autoconf macros

Autoconf 2.70 (released in 2020-12) produces warning messages about
obsolete constructs by default.

Running regen.sh with autoconf 2.70 installed produces the following
warnings:

..
 configure.ac:7: warning: The macro `AC_CONFIG_HEADER' is obsolete.
 configure.ac:21: warning: AC_PROG_LEX without either yywrap or noyywrap
   is obsolete
 configure.ac:21: warning: The macro `AC_HEADER_STDC' is obsolete.
 configure.ac:21: warning: The macro `AC_HEADER_TIME' is obsolete.
..

Replace AC_CONFIG_HEADER with AC_CONFIG_HEADERS

Add the noyywrap parameter to AC_PROG_LEX.  Use the noyywrap option
since we already provide a yywrap function in the .l sources.

Remove AC_HEADER_STDC.  There are no references to the the autoconf
variable set by this macro.  This macro was marked as obsolete prior to
autoconf 2.64 with the following note:
 "This macro is obsolescent, as current systems have conforming header
 files. New programs need not use this macro."

AC_HEADER_TIME was marked as obsolete prior to autoconf 2.64 with the
following note:
 "This macro is obsolescent, as current systems can include both files
  when they exist. New programs need not use this macro."

The only reference that requires AC_HEADER_TIME is within the external
roken code pulled from heimdal. Compiles that use the external upstream
heimdal packages result in a build error if TIME_WITH_SYS_TIME is not
defined:
  building src/crypto/hcrypto
    src/external/heimdal/hcrypto/camellia.c
      include/roken.h:803:58: error: ‘struct tm’ declared inside

Update autoheader.m4 so a define for TIME_WITH_SYS_TIME is created. This
avoids modifying the external heimdal/roken code.

Reviewed-on: https://gerrit.openafs.org/14838
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 2a659ba160fbdc87a5fb4f330ffda82c1534929d)

[cwills@sinenomine.net resolved conflict with MACOS_VERSION numbers]

Change-Id: I1f5ed4ac66bd5bc35ef79e784e784ae2847321a2
---

diff --git a/acinclude.m4 b/acinclude.m4
index 53230ae..1633968 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -58,7 +58,6 @@
 OPENAFS_C_PRAGMA
 OPENAFS_MORE_ROKEN_CHECKS
 OPENAFS_NETDB_CHECKS
-AC_HEADER_TIME
 OPENAFS_ROKEN_HEADERS
 OPENAFS_BSWAP_CHECKS
 OPENAFS_HPUX_CHECKS
diff --git a/configure-libafs.ac b/configure-libafs.ac
index ae48c4d..3eebcfc 100644
--- a/configure-libafs.ac
+++ b/configure-libafs.ac
@@ -3,7 +3,7 @@
 AC_CONFIG_AUX_DIR([build-tools])
 AC_CONFIG_SRCDIR([src/libafs/Makefile.common.in])
 
-AC_CONFIG_HEADER([src/config/afsconfig.h])
+AC_CONFIG_HEADERS([src/config/afsconfig.h])
 MACOS_VERSION=1.8.9d1
 
 AC_SUBST([MACOS_VERSION])
diff --git a/configure.ac b/configure.ac
index 8ca0126..21123fb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -4,7 +4,7 @@
 AC_CONFIG_MACRO_DIR([src/cf])
 AC_CONFIG_SRCDIR([src/config/stds.h])
 
-AC_CONFIG_HEADER([src/config/afsconfig.h])
+AC_CONFIG_HEADERS([src/config/afsconfig.h])
 MACOS_VERSION=1.8.9d1
 
 AC_SUBST([MACOS_VERSION])
diff --git a/src/cf/autoheader.m4 b/src/cf/autoheader.m4
index 6d9d54a..681817f 100644
--- a/src/cf/autoheader.m4
+++ b/src/cf/autoheader.m4
@@ -63,5 +63,13 @@
 #if defined(ENABLE_REDHAT_BUILDSYS) && defined(KERNEL) && defined(REDHAT_FIX)
 # include "redhat-fix.h"
 #endif
+
+/*
+ * AC_HEADER_TIME, which set TIME_WITH_SYS_TIME, has been marked as obsolete
+ * prior to autoconf 2.64 and autoconf 2.70 flags its use with a warning.
+ * However the external roken code still relies on the definition.
+ */
+#define TIME_WITH_SYS_TIME 1
+
 #endif /* __AFSCONFIG_H */])
 ])
diff --git a/src/cf/headers.m4 b/src/cf/headers.m4
index af4a4dd..889373a 100644
--- a/src/cf/headers.m4
+++ b/src/cf/headers.m4
@@ -1,6 +1,5 @@
 AC_DEFUN([OPENAFS_HEADER_CHECKS],[
 dnl checks for header files.
-AC_HEADER_STDC
 AC_HEADER_SYS_WAIT
 AC_HEADER_DIRENT
 AC_CHECK_HEADERS([ \
diff --git a/src/cf/lex.m4 b/src/cf/lex.m4
index 938b108..fd49089 100644
--- a/src/cf/lex.m4
+++ b/src/cf/lex.m4
@@ -1,5 +1,5 @@
 AC_DEFUN([OPENAFS_LEX],[
-AC_PROG_LEX
+AC_PROG_LEX([noyywrap])
 dnl if we are flex, be lex-compatible
 OPENAFS_LEX_IS_FLEX([AC_SUBST([LEX], ["$LEX -l"])])
 ])
From 4c319a35b10293ee89e616b001fe215415bbc298 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Fri, 18 Oct 2019 13:43:36 -0400
Subject: [PATCH] warn when starting without keys

The server processes will happily start without keys and then fail all
authenticated access, including database synchronization and local
commands with -localauth.  At least issue warnings to let admins know
the keys are missing and that akeyconvert or asetkey needs to be run.

The situation is not helped by fact the filenames of the key files have
changed between versions. In 1.6.x the (non-DES) keys were in the
rxkad.keytab file and in later versions they are in the KeyFile* files,
so if you are used to 1.6.x it is not obvious what is wrong.

Reviewed-on: https://gerrit.openafs.org/13911
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
(cherry picked from commit 042f809ccfe12bafed73aa4eb4db2c86737e0b22)

Change-Id: I280d3c83b4576684f2035f79d94966bc5a174681
---

diff --git a/src/auth/cellconfig.p.h b/src/auth/cellconfig.p.h
index 3b91e01..c1ccf87 100644
--- a/src/auth/cellconfig.p.h
+++ b/src/auth/cellconfig.p.h
@@ -168,6 +168,7 @@
 				  int *minorType,
 				  struct rx_opaque **keyMaterial);
 
+extern int afsconf_CountKeys(struct afsconf_dir *);
 extern int afsconf_GetAllKeys(struct afsconf_dir *,
 			      struct afsconf_typedKeyList **);
 extern int afsconf_GetKeysByType(struct afsconf_dir *dir,
diff --git a/src/auth/keys.c b/src/auth/keys.c
index 54ad955..ad36c49 100644
--- a/src/auth/keys.c
+++ b/src/auth/keys.c
@@ -822,6 +822,39 @@
 }
 
 int
+_afsconf_CountKeys(struct afsconf_dir *dir)
+{
+    int count = 0;
+    struct opr_queue *typeCursor;
+    struct keyTypeList *typeEntry;
+    struct opr_queue *kvnoCursor;
+    struct kvnoList *kvnoEntry;
+    struct opr_queue *subCursor;
+
+    for (opr_queue_Scan(&dir->keyList, typeCursor)) {
+	typeEntry = opr_queue_Entry(typeCursor, struct keyTypeList, link);
+	for (opr_queue_Scan(&typeEntry->kvnoList, kvnoCursor)) {
+	    kvnoEntry = opr_queue_Entry(kvnoCursor, struct kvnoList, link);
+	    for (opr_queue_Scan(&kvnoEntry->subTypeList, subCursor))
+		count++;
+	}
+    }
+    return count;
+}
+
+int
+afsconf_CountKeys(struct afsconf_dir *dir)
+{
+    int count = 0;
+
+    LOCK_GLOBAL_MUTEX;
+    count = _afsconf_CountKeys(dir);
+    UNLOCK_GLOBAL_MUTEX;
+
+    return count;
+}
+
+int
 afsconf_GetAllKeys(struct afsconf_dir *dir, struct afsconf_typedKeyList **keys)
 {
     int code;
@@ -840,16 +873,8 @@
     if (code)
 	goto out;
 
-    count = 0;
     /* First, work out how many keys we have in total */
-    for (opr_queue_Scan(&dir->keyList, typeCursor)) {
-	typeEntry = opr_queue_Entry(typeCursor, struct keyTypeList, link);
-	for (opr_queue_Scan(&typeEntry->kvnoList, kvnoCursor)) {
-	    kvnoEntry = opr_queue_Entry(kvnoCursor, struct kvnoList, link);
-	    for (opr_queue_Scan(&kvnoEntry->subTypeList, subCursor))
-		count++;
-	}
-    }
+    count = _afsconf_CountKeys(dir);
 
     /* Allocate space for all of these */
     retval = malloc(sizeof(struct afsconf_typedKeyList));
diff --git a/src/auth/liboafs_auth.la.sym b/src/auth/liboafs_auth.la.sym
index 5497f99..2fd6e59 100644
--- a/src/auth/liboafs_auth.la.sym
+++ b/src/auth/liboafs_auth.la.sym
@@ -8,6 +8,7 @@
 afsconf_ClientAuthSecure
 afsconf_ClientAuthToken
 afsconf_Close
+afsconf_CountKeys
 afsconf_DeleteKey
 afsconf_GetAfsdbInfo
 afsconf_GetAllKeys
diff --git a/src/bozo/bosserver.c b/src/bozo/bosserver.c
index 8bba0e7..42b0fb4 100644
--- a/src/bozo/bosserver.c
+++ b/src/bozo/bosserver.c
@@ -1149,6 +1149,12 @@
     /* opened the cell databse */
     bozo_confdir = tdir;
 
+    if (afsconf_CountKeys(bozo_confdir) == 0) {
+	bozo_Log("WARNING: No encryption keys found! "
+		 "All authenticated accesses will fail. "
+		 "Run akeyconvert or asetkey to import encryption keys.\n");
+    }
+
     code = bnode_Init();
     if (code) {
 	printf("bosserver: could not init bnode package, code %d\n", code);
diff --git a/src/budb/server.c b/src/budb/server.c
index 3a80918..8190ef9 100644
--- a/src/budb/server.c
+++ b/src/budb/server.c
@@ -467,6 +467,12 @@
 	ERROR(BUDB_NOCELLS);
     }
 
+    if (afsconf_CountKeys(BU_conf) == 0) {
+	LogError(0, "WARNING: No encryption keys found! "
+		    "All authenticated accesses will fail. "
+		    "Run akeyconvert or asetkey to import encryption keys.\n");
+    }
+
     code = afsconf_GetLocalCell(BU_conf, lcell, sizeof(lcell));
     if (code) {
 	LogError(0, "** Can't determine local cell name!\n");
diff --git a/src/butc/tcmain.c b/src/butc/tcmain.c
index 14d1aaf..24406fe 100644
--- a/src/butc/tcmain.c
+++ b/src/butc/tcmain.c
@@ -997,6 +997,12 @@
 	exit(1);
     }
 
+    if (afsconf_CountKeys(butc_confdir) == 0) {
+	TLog(0, "WARNING: No encryption keys found! "
+		"All authenticated accesses will fail. "
+		"Run akeyconvert or asetkey to import encryption keys.\n");
+    }
+
     /* Start auditing */
     osi_audit_init();
     if (as->parms[9].items) {
diff --git a/src/libafsauthent/afsauthent.def b/src/libafsauthent/afsauthent.def
index 8927ef8..10c71cb 100644
--- a/src/libafsauthent/afsauthent.def
+++ b/src/libafsauthent/afsauthent.def
@@ -209,3 +209,4 @@
         xdr_idlist					@208
         xdr_namelist					@209
         xdr_prlist					@210
+        afsconf_CountKeys				@211
diff --git a/src/ptserver/ptserver.c b/src/ptserver/ptserver.c
index 2ab437d..c5e640e 100644
--- a/src/ptserver/ptserver.c
+++ b/src/ptserver/ptserver.c
@@ -607,7 +607,11 @@
 		   "1.0",
 #endif
 		   "Starting AFS", FSLog);
-    if (afsconf_GetLatestKey(prdir, NULL, NULL) == 0) {
+    if (afsconf_CountKeys(prdir) == 0) {
+	ViceLog(0, ("WARNING: No encryption keys found! "
+		    "All authenticated accesses will fail. "
+		    "Run akeyconvert or asetkey to import encryption keys.\n"));
+    } else if (afsconf_GetLatestKey(prdir, NULL, NULL) == 0) {
 	LogDesWarning();
     }
 
diff --git a/src/update/server.c b/src/update/server.c
index c2985d3..1b191e1 100644
--- a/src/update/server.c
+++ b/src/update/server.c
@@ -289,6 +289,12 @@
 	exit(1);
     }
 
+    if (afsconf_CountKeys(cdir) == 0) {
+	fprintf(stderr, "WARNING: No encryption keys found! "
+			"All authenticated accesses will fail."
+			"Run akeyconvert or asetkey to import encryption keys.\n");
+    }
+
     if (rxBind) {
 	afs_int32 ccode;
         if (AFSDIR_SERVER_NETRESTRICT_FILEPATH ||
diff --git a/src/viced/viced.c b/src/viced/viced.c
index 6a9643b..38dc877 100644
--- a/src/viced/viced.c
+++ b/src/viced/viced.c
@@ -1900,7 +1900,12 @@
     OpenLog(&logopts);
 
     LogCommandLine(argc, argv, "starting", "", "File server", FSLog);
-    if (afsconf_GetLatestKey(confDir, NULL, NULL) == 0) {
+
+    if (afsconf_CountKeys(confDir) == 0) {
+	ViceLog(0, ("WARNING: No encryption keys found! "
+		    "All authenticated accesses will fail. "
+		    "Run akeyconvert or asetkey to import encryption keys.\n"));
+    } else if (afsconf_GetLatestKey(confDir, NULL, NULL) == 0) {
 	LogDesWarning();
     }
 
diff --git a/src/vlserver/vlserver.c b/src/vlserver/vlserver.c
index 08ecab9..0909378 100644
--- a/src/vlserver/vlserver.c
+++ b/src/vlserver/vlserver.c
@@ -534,7 +534,11 @@
     rx_SetMaxProcs(tservice, 4);
 
     LogCommandLine(argc, argv, "vlserver", VldbVersion, "Starting AFS", FSLog);
-    if (afsconf_GetLatestKey(tdir, NULL, NULL) == 0) {
+    if (afsconf_CountKeys(tdir) == 0) {
+	VLog(0, ("WARNING: No encryption keys found! "
+		 "All authenticated accesses will fail."
+		 "Run akeyconvert or asetkey to import encryption keys.\n"));
+    } else if (afsconf_GetLatestKey(tdir, NULL, NULL) == 0) {
 	LogDesWarning();
     }
     VLog(0, ("%s\n", cml_version_number));
diff --git a/src/volser/volmain.c b/src/volser/volmain.c
index 2bbbc92..96de6a0 100644
--- a/src/volser/volmain.c
+++ b/src/volser/volmain.c
@@ -630,7 +630,11 @@
 
     LogCommandLine(argc, argv, "Volserver", VolserVersion, "Starting AFS",
 		   Log);
-    if (afsconf_GetLatestKey(tdir, NULL, NULL) == 0) {
+    if (afsconf_CountKeys(tdir) == 0) {
+	Log("WARNING: No encryption keys found! "
+	    "All authenticated accesses will fail. "
+	    "Run akeyconvert or asetkey to import encryption keys.\n");
+    } else if (afsconf_GetLatestKey(tdir, NULL, NULL) == 0) {
 	LogDesWarning();
     }
 
From b55fcc70a13998f337d6d39c2709c8d75a05a7c8 Mon Sep 17 00:00:00 2001
From: Mark Vitale <mvitale@sinenomine.net>
Date: Fri, 29 Jan 2016 01:00:56 -0500
Subject: [PATCH] afs: clarify cold and warm shutdown logic

Currently, any code that wants to perform a cold shutdown must first set
global afs_cold_shutdown = 1, then call afs_shutdown(void).

Instead, modify afs_shutdown() to accept a single parm which specifies
AFS_WARM or AFS_COLD shutdown, and to set the value of global
afs_cold_shutdown based on this parm.  Remove all other assignments for
afs_cold_shutdown.  Modify all callers of afs_shutdown() to specify
AFS_WARM or AFS_COLD as needed to maintain equivalent function.

This should make it much easier to tell at a glance what type of
shutdown is being requested by each caller to afs_shutdown().

No functional change should be incurred by this commit.

Reviewed-on: https://gerrit.openafs.org/12182
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit a2e03e74c4959f72c90288ec85a40c037c9c6243)

Change-Id: I9271c1161f419ea02b9fe43ec46219dce19c9d50
---

diff --git a/src/afs/AIX/osi_vfsops.c b/src/afs/AIX/osi_vfsops.c
index 5265944..71c1553 100644
--- a/src/afs/AIX/osi_vfsops.c
+++ b/src/afs/AIX/osi_vfsops.c
@@ -100,8 +100,7 @@
     AFS_STATCNT(afs_unmount);
 
     afs_globalVFS = 0;
-    afs_cold_shutdown = 1;
-    afs_shutdown();
+    afs_shutdown(AFS_COLD);
 
     AFS_VFSUNLOCK();
     return 0;
diff --git a/src/afs/DARWIN/osi_vfsops.c b/src/afs/DARWIN/osi_vfsops.c
index b180882..d5b8671 100644
--- a/src/afs/DARWIN/osi_vfsops.c
+++ b/src/afs/DARWIN/osi_vfsops.c
@@ -196,7 +196,7 @@
 	        vflush(mp, NULLVP, FORCECLOSE/*0*/);
 		AFS_GLOCK();
 		afs_globalVFS = 0;
-		afs_shutdown();
+		afs_shutdown(AFS_WARM);
 	    } else {
 		AFS_GUNLOCK();
 		return EBUSY;
diff --git a/src/afs/FBSD/osi_vfsops.c b/src/afs/FBSD/osi_vfsops.c
index d8b06b9..6044bbe 100644
--- a/src/afs/FBSD/osi_vfsops.c
+++ b/src/afs/FBSD/osi_vfsops.c
@@ -184,7 +184,7 @@
     AFS_GLOCK();
     AFS_STATCNT(afs_unmount);
     afs_globalVFS = 0;
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
     AFS_GUNLOCK();
 
 out:
diff --git a/src/afs/HPUX/osi_vfsops.c b/src/afs/HPUX/osi_vfsops.c
index df0ca59..0ddc227 100644
--- a/src/afs/HPUX/osi_vfsops.c
+++ b/src/afs/HPUX/osi_vfsops.c
@@ -103,7 +103,7 @@
     AFS_STATCNT(afs_unmount);
 
     afs_globalVFS = 0;
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
 
     AFS_GUNLOCK();
     return 0;
diff --git a/src/afs/IRIX/osi_vfsops.c b/src/afs/IRIX/osi_vfsops.c
index a7e8387..a03ac33 100644
--- a/src/afs/IRIX/osi_vfsops.c
+++ b/src/afs/IRIX/osi_vfsops.c
@@ -245,7 +245,7 @@
     }
     ReleaseWriteLock(&afs_xvcache);
     afs_globalVFS = 0;
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
 #ifdef AFS_SGI65_ENV
     VFS_REMOVEBHV(afsp, &afs_vfs_bhv);
 #endif
diff --git a/src/afs/LINUX/osi_vfsops.c b/src/afs/LINUX/osi_vfsops.c
index ca1d5c8..b85ab3f 100644
--- a/src/afs/LINUX/osi_vfsops.c
+++ b/src/afs/LINUX/osi_vfsops.c
@@ -353,7 +353,7 @@
     afs_globalVFS = 0;
     afs_globalVp = 0;
 
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
     mntput(afs_cacheMnt);
 
     osi_linux_verify_alloced_memory();
diff --git a/src/afs/NBSD/osi_vfsops.c b/src/afs/NBSD/osi_vfsops.c
index a52629b..a78943d 100644
--- a/src/afs/NBSD/osi_vfsops.c
+++ b/src/afs/NBSD/osi_vfsops.c
@@ -302,8 +302,7 @@
     vflush(mp, NULLVP, 0);	/* don't support forced */
     AFS_GLOCK();
     afs_globalVFS = NULL;
-    afs_cold_shutdown = 1;
-    afs_shutdown();		/* XXX */
+    afs_shutdown(AFS_COLD);
     AFS_GUNLOCK();
 
     mp->mnt_data = NULL;
diff --git a/src/afs/OBSD/osi_vfsops.c b/src/afs/OBSD/osi_vfsops.c
index 4377494..830906c 100644
--- a/src/afs/OBSD/osi_vfsops.c
+++ b/src/afs/OBSD/osi_vfsops.c
@@ -290,8 +290,7 @@
     afsp->mnt_data = NULL;
     AFS_GLOCK();
     afs_globalVFS = 0;
-    afs_cold_shutdown = 1;
-    afs_shutdown();		/* XXX */
+    afs_shutdown(AFS_COLD);
     AFS_GUNLOCK();
 
     /* give up syscall entries for ioctl & setgroups, which we've stolen */
diff --git a/src/afs/SOLARIS/osi_vfsops.c b/src/afs/SOLARIS/osi_vfsops.c
index 5b1a3a5..c6c9ddf 100644
--- a/src/afs/SOLARIS/osi_vfsops.c
+++ b/src/afs/SOLARIS/osi_vfsops.c
@@ -75,7 +75,7 @@
 
     afs_globalVFS = 0;
 
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
 }
 
 int
diff --git a/src/afs/UKERNEL/osi_vfsops.c b/src/afs/UKERNEL/osi_vfsops.c
index b44709b..cfae3d3 100644
--- a/src/afs/UKERNEL/osi_vfsops.c
+++ b/src/afs/UKERNEL/osi_vfsops.c
@@ -53,7 +53,7 @@
 {
     AFS_STATCNT(afs_unmount);
     afs_globalVFS = 0;
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
     return 0;
 }
 
diff --git a/src/afs/afs_call.c b/src/afs/afs_call.c
index 32ad210..37cac13 100644
--- a/src/afs/afs_call.c
+++ b/src/afs/afs_call.c
@@ -1456,12 +1456,10 @@
 	if (afs_globalVFS != 0) {
 	    afs_warn("AFS isn't unmounted yet! Call aborted\n");
 	    code = EACCES;
+	} else if (parm2 == AFS_COLD) {
+	    afs_shutdown(AFS_COLD);
 	} else {
-	    afs_cold_shutdown = 0;
-	    if (parm2 == 1) {
-		afs_cold_shutdown = 1;
-	    }
-	    afs_shutdown();
+	    afs_shutdown(AFS_WARM);
 	}
     } else if (parm == AFSOP_AFS_VFSMOUNT) {
 #ifdef	AFS_HPUX_ENV
@@ -1645,7 +1643,7 @@
 
 enum afs_shutdown_state afs_shuttingdown = AFS_RUNNING;
 void
-afs_shutdown(void)
+afs_shutdown(enum afs_shutdown_type cold_flag)
 {
     extern short afs_brsDaemons;
     extern afs_int32 afs_CheckServerDaemonStarted;
@@ -1661,6 +1659,8 @@
     if (afs_shuttingdown != AFS_RUNNING)
 	return;
 
+    afs_cold_shutdown = ((cold_flag == AFS_COLD) ? 1 : 0);
+
     afs_shuttingdown = AFS_FLUSHING_CB;
 
     /* Give up all of our callbacks if we can. */
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index b9fd078..ac7431b 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -33,7 +33,14 @@
 extern char afs_rootVolumeName[MAXROOTVOLNAMELEN];
 extern void afs_FlushCBs(void);
 extern int afs_CheckInit(void);
-extern void afs_shutdown(void);
+/* for afs_shutdown */
+enum afs_shutdown_type {
+	AFS_WARM = 0,
+	AFS_COLD = 1,
+};
+extern void afs_shutdown(enum afs_shutdown_type);
+
+
 extern void shutdown_afstest(void);
 extern int afs_syscall_call(long parm, long parm2, long parm3,
 			    long parm4, long parm5, long parm6);
diff --git a/src/afsd/afsd.c b/src/afsd/afsd.c
index ffedee5..3ea3cac 100644
--- a/src/afsd/afsd.c
+++ b/src/afsd/afsd.c
@@ -2255,7 +2255,7 @@
 	 * Cold shutdown is the default
 	 */
 	printf("afsd: Shutting down all afs processes and afs state\n");
-	code = afsd_syscall(AFSOP_SHUTDOWN, 1);
+	code = afsd_syscall(AFSOP_SHUTDOWN, 1);		/* always AFS_COLD */
 	if (code) {
 	    printf("afsd: AFS still mounted; Not shutting down\n");
 	    exit(1);
From d276e663553343990c504c5d3029edefaa2f7891 Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Thu, 04 Apr 2019 16:18:57 -0400
Subject: [PATCH] fs: Avoid unnecessary cell DNS lookups

Currently, many routines in 'fs' cause afsconf_GetCellInfo to be
called for the given cell, which causes an AFSDB/SRV lookup for the
given cell if the cell has no dbservers specified in the local
CellServDB. Sites often define such CellServDB records to indicate
that the given cell exists, but the dbserver IPs should only be looked
up via DNS.

However, 'fs' is only calling afsconf_GetCellInfo in order to
canonicalize the cell name (we're allowed to give an abbreviated name
for a cell on the command line if the abbreviation is unambiguous, but
we want to give the full name to the kernel). We don't care about the
other cell info at all, so triggering a DNS lookup is completely
unnecessary.

If our DNS server is not responding, e.g. because we've lost network
access entirely, this causes the relevant 'fs' commands to fail,
possibly after a long delay. Some fs commands such as 'fs setcell' are
often run during client startup, and can still otherwise run fine
without network access, and so such failures are unnecessary.

To fix this, we introduce a new function, called afsconf_GetCellName,
which only returns the full name for a cell, and does not require a
DNS lookup for such "empty" cells in the local CellServDB. For all
code paths in 'fs' that just need the cell name (which is all of them
besides 'fs mkmount'), use this new function.

Reviewed-on: https://gerrit.openafs.org/13540
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 4a150387e3151ecdfca8b4f7c732a1e876968279)

Change-Id: Ia81eb1e067fe399949d3ea8ae1957e87f6698753
---

diff --git a/src/auth/cellconfig.c b/src/auth/cellconfig.c
index 20547aa..2226e83 100644
--- a/src/auth/cellconfig.c
+++ b/src/auth/cellconfig.c
@@ -1325,9 +1325,14 @@
 }
 #endif /* windows */
 
-int
-afsconf_GetCellInfo(struct afsconf_dir *adir, char *acellName, char *aservice,
-		    struct afsconf_cell *acellInfo)
+/* flags for _GetCellInfo */
+#define AFSCONF_GETCELL_EMPTYOK (0x1) /** it's okay to return 'empty' cells
+					* (that is, cells without any
+					* dbservers) */
+
+static int
+_GetCellInfo(struct afsconf_dir *adir, char *acellName, char *aservice,
+	     struct afsconf_cell *acellInfo, afs_uint32 flags)
 {
     struct afsconf_entry *tce;
     struct afsconf_aliasentry *tcae;
@@ -1338,6 +1343,11 @@
     int cnLen;
     int ambig;
     char tbuffer[64];
+    int emptyok = 0;
+
+    if ((flags & AFSCONF_GETCELL_EMPTYOK)) {
+	emptyok = 1;
+    }
 
     LOCK_GLOBAL_MUTEX;
     if (adir)
@@ -1387,7 +1397,7 @@
 	    bestce = tce;
 	}
     }
-    if (!ambig && bestce && bestce->cellInfo.numServers) {
+    if (!ambig && bestce && (bestce->cellInfo.numServers || emptyok)) {
 	*acellInfo = bestce->cellInfo;	/* structure assignment */
 	if (aservice) {
 	    tservice = afsconf_FindService(aservice);
@@ -1459,7 +1469,9 @@
                 strcpy(acellInfo->hostName[i], hostName[i]);
             }
             acellInfo->numServers = numServers;
-            acellInfo->flags |= AFSCONF_CELL_FLAG_DNS_QUERIED;
+	    if (numServers) {
+		acellInfo->flags |= AFSCONF_CELL_FLAG_DNS_QUERIED;
+	    }
         }
 	UNLOCK_GLOBAL_MUTEX;
 	return 0;
@@ -1470,6 +1482,63 @@
 }
 
 /**
+ * Get info about a cell.
+ *
+ * @param[in] adir	afsconf object.
+ * @param[in] acellName	name of the cell to get. a cell name abbreviation can
+ *			be given if it's unambiguous (e.g. "cell" can be given
+ *			for "cell.example.com" if no other cells begin with
+ *			"cell").
+ * @param[in] aservice	name of the service in the cell, as accepted by
+ *			afsconf_FindService. if NULL is given: for local
+ *			lookups, no port information will be returned; for DNS
+ *			lookups, we'll default to "afs3-vlserver".
+ * @param[out] acellInfo    info for the requested cell and service
+ *
+ * @return afsconf error codes
+ */
+int
+afsconf_GetCellInfo(struct afsconf_dir *adir, char *acellName, char *aservice,
+		    struct afsconf_cell *acellInfo)
+{
+    return _GetCellInfo(adir, acellName, aservice, acellInfo, 0);
+}
+
+/**
+ * Get a cell's name.
+ *
+ * This is similar to afsconf_GetCellInfo, but doesn't actually retrieve the
+ * info of the specified cell (beyond it's name). This can be useful to verify
+ * that a cell name is valid, or to canonicalize a possibly-abbreviated cell
+ * name. Unlike afsconf_GetCellInfo, this call can avoid DNS lookups if the
+ * cell name is specified in the local config, but the cell's servers are not.
+ *
+ * @param[in] adir	afsconf object.
+ * @param[in] acellName	name of the cell to get. a cell name abbreviation can
+ *			be given if it's unambiguous (see afsconf_GetCellInfo).
+ * @param[out] buf	on success, the cell's name is written to this buffer.
+ * @param[in] buf_size	size of 'buf'.
+ *
+ * @return afsconf error codes
+ * @retval AFSCONF_FAILURE  buf_size is too small to fit the cell's name.
+ */
+int
+afsconf_GetCellName(struct afsconf_dir *adir, char *acellName, char *buf,
+		    size_t buf_size)
+{
+    int code;
+    struct afsconf_cell info;
+    code = _GetCellInfo(adir, acellName, NULL, &info, AFSCONF_GETCELL_EMPTYOK);
+    if (code) {
+	return code;
+    }
+    if (strlcpy(buf, info.name, buf_size) >= buf_size) {
+	return AFSCONF_FAILURE;
+    }
+    return 0;
+}
+
+/**
  * Get the current localcell name.
  *
  * Internal function to get a pointer to the local cell name.
diff --git a/src/auth/cellconfig.p.h b/src/auth/cellconfig.p.h
index c1ccf87..4aed031 100644
--- a/src/auth/cellconfig.p.h
+++ b/src/auth/cellconfig.p.h
@@ -123,6 +123,8 @@
 extern int afsconf_GetCellInfo(struct afsconf_dir *adir, char *acellName,
 			       char *aservice,
 			       struct afsconf_cell *acellInfo);
+extern int afsconf_GetCellName(struct afsconf_dir *adir, char *acellName,
+			       char *buf, size_t buf_size);
 extern int afsconf_GetLocalCell(struct afsconf_dir *adir,
 				char *aname, afs_int32 alen);
 extern int afsconf_Close(struct afsconf_dir *adir);
diff --git a/src/auth/liboafs_auth.la.sym b/src/auth/liboafs_auth.la.sym
index 2fd6e59..fcd0b99 100644
--- a/src/auth/liboafs_auth.la.sym
+++ b/src/auth/liboafs_auth.la.sym
@@ -13,6 +13,7 @@
 afsconf_GetAfsdbInfo
 afsconf_GetAllKeys
 afsconf_GetCellInfo
+afsconf_GetCellName
 afsconf_GetExtendedCellInfo
 afsconf_GetKey
 afsconf_GetLatestKey
diff --git a/src/venus/fs.c b/src/venus/fs.c
index 630f44c..103f309 100644
--- a/src/venus/fs.c
+++ b/src/venus/fs.c
@@ -66,7 +66,7 @@
 static int PruneList(struct AclEntry **, int);
 static int CleanAcl(struct Acl *, char *);
 static int SetVolCmd(struct cmd_syndesc *as, void *arock);
-static int GetCellName(char *, struct afsconf_cell *);
+static int GetCellName(char *, char *, size_t);
 static void Die(int, char *);
 
 /*
@@ -2063,7 +2063,6 @@
     afs_int32 j;
     afs_int32 temp;
     char *tp;
-    struct afsconf_cell info;
     struct chservinfo checkserv;
 
     memset(&checkserv, 0, sizeof(struct chservinfo));
@@ -2086,12 +2085,12 @@
 
     /* now copy in optional cell name, if specified */
     if (as->parms[0].items) {
-	code = GetCellName(as->parms[0].items->data, &info);
+	code = GetCellName(as->parms[0].items->data, &checkserv.tbuffer[0],
+			   sizeof(checkserv.tbuffer));
 	if (code) {
 	    return 1;
 	}
-	strcpy(checkserv.tbuffer, info.name);
-	checkserv.tsize = strlen(info.name) + 1;
+	checkserv.tsize = strlen(checkserv.tbuffer) + 1;
     } else {
 	strcpy(checkserv.tbuffer, "\0");
 	checkserv.tsize = 0;
@@ -2957,7 +2956,7 @@
 {
     afs_int32 code;
     struct ViceIoctl blob;
-    struct afsconf_cell info;
+    char cellName[MAXCELLCHARS];
     struct cmd_item *ti;
     struct a {
 	afs_int32 stat;
@@ -2970,24 +2969,24 @@
 	/* once per cell */
 	blob.out_size = sizeof(args);
 	blob.out = (caddr_t) & args;
-	code = GetCellName(ti->data, &info);
+	code = GetCellName(ti->data, &cellName[0], sizeof(cellName));
 	if (code) {
 	    error = 1;
 	    continue;
 	}
-	blob.in_size = 1 + strlen(info.name);
-	blob.in = info.name;
+	blob.in_size = 1 + strlen(cellName);
+	blob.in = cellName;
 	code = pioctl(0, VIOC_GETCELLSTATUS, &blob, 1);
 	if (code) {
 	    if (errno == ENOENT)
 		fprintf(stderr, "%s: the cell named '%s' does not exist\n",
-			pn, info.name);
+			pn, cellName);
 	    else
-		Die(errno, info.name);
+		Die(errno, cellName);
 	    error = 1;
 	    continue;
 	}
-	printf("Cell %s status: ", info.name);
+	printf("Cell %s status: ", cellName);
 	if (args.stat & 2)
 	    printf("no setuid allowed");
 	else
@@ -3004,7 +3003,6 @@
 {
     afs_int32 code;
     struct ViceIoctl blob;
-    struct afsconf_cell info;
     struct cmd_item *ti;
     struct a {
 	afs_int32 stat;
@@ -3029,19 +3027,18 @@
     /* set stat for all listed cells */
     for (ti = as->parms[0].items; ti; ti = ti->next) {
 	/* once per cell */
-	code = GetCellName(ti->data, &info);
+	code = GetCellName(ti->data, &args.cname[0], sizeof(args.cname));
 	if (code) {
 	    error = 1;
 	    continue;
 	}
-	strcpy(args.cname, info.name);
 	blob.in_size = sizeof(args);
 	blob.in = (caddr_t) & args;
 	blob.out_size = 0;
 	blob.out = (caddr_t) 0;
 	code = pioctl(0, VIOC_SETCELLSTATUS, &blob, 1);
 	if (code) {
-	    Die(errno, info.name);	/* XXX added cell name to Die() call */
+	    Die(errno, args.cname);	/* XXX added cell name to Die() call */
 	    error = 1;
 	}
     }
@@ -3049,7 +3046,7 @@
 }
 
 static int
-GetCellName(char *cellName, struct afsconf_cell *info)
+GetCellName(char *cellName, char *buf, size_t buf_size)
 {
     struct afsconf_dir *tdir;
     int code;
@@ -3062,7 +3059,7 @@
 	return -1;
     }
 
-    code = afsconf_GetCellInfo(tdir, cellName, AFSCONF_VLDBSERVICE, info);
+    code = afsconf_GetCellName(tdir, cellName, buf, buf_size);
     if (code) {
 	fprintf(stderr, "%s: cell %s not in %s\n", pn, cellName,
 		AFSDIR_CLIENT_CELLSERVDB_FILEPATH);
From 30798c48534085b5e3811e7412728efce54a3d17 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Thu, 27 Dec 2018 09:32:35 -0500
Subject: [PATCH] build: declare test targets as phony

Modern versions `make` will not build the 'test' target since a
directory exists with the same name.

    $ grep -C1 '^test:' Makefile
    test:
        cd test; $(MAKE)

    $ make test
    make: 'test' is up to date.

Declare these targets as .PHONY to force make to build the test programs
even when the 'test' directory is present. Also use '&&' to concatenate
commands instead ';' to avoid running the second command when the first
fails.

Reviewed-on: https://gerrit.openafs.org/13419
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 0bd55a02bb5707b1b8b26347d5cb6ad71765f622)

Change-Id: I4bc8c09720a19658afbab733ea74332083bb29f4
---

diff --git a/src/auth/Makefile.in b/src/auth/Makefile.in
index 8dec8a6..d172019 100644
--- a/src/auth/Makefile.in
+++ b/src/auth/Makefile.in
@@ -177,8 +177,9 @@
 #
 # Misc. targets
 #
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 clean:
 	$(LT_CLEAN)
diff --git a/src/bozo/Makefile.in b/src/bozo/Makefile.in
index 6a7b544..a8916cc 100644
--- a/src/bozo/Makefile.in
+++ b/src/bozo/Makefile.in
@@ -163,8 +163,9 @@
 		bosint.cs.c bosint.ss.c bosint.xdr.c bosint.h \
 		core boserr.c bnode.h AFS_component_version_number.c
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 include ../config/Makefile.version
 
diff --git a/src/comerr/Makefile.in b/src/comerr/Makefile.in
index b94f1c6..d906feb 100644
--- a/src/comerr/Makefile.in
+++ b/src/comerr/Makefile.in
@@ -89,8 +89,9 @@
 		et_lex.lex.c test1.h test1.c test2.h test2.c \
 		eddep makedep core AFS_component_version_number.c
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 compile_et.o:  AFS_component_version_number.c
 # specify yacc build product as a dependency so our .c.o rule will apply
diff --git a/src/dir/Makefile.in b/src/dir/Makefile.in
index 978ddc1..34c63f5 100644
--- a/src/dir/Makefile.in
+++ b/src/dir/Makefile.in
@@ -28,8 +28,9 @@
 	$(AR) crv $@ buffer.o dir.o salvage.o  AFS_component_version_number.o
 	$(RANLIB) $@
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 buffer.o: buffer.c dir.h
 
diff --git a/src/libacl/Makefile.in b/src/libacl/Makefile.in
index f2c90f5..fbf532c 100644
--- a/src/libacl/Makefile.in
+++ b/src/libacl/Makefile.in
@@ -64,8 +64,9 @@
 #
 # Misc. targets
 #
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 clean:
 	$(LT_CLEAN)
diff --git a/src/log/Makefile.in b/src/log/Makefile.in
index e067d3a..f1cbf73 100644
--- a/src/log/Makefile.in
+++ b/src/log/Makefile.in
@@ -102,7 +102,8 @@
 	$(RM) -f *.o unlog tokens kseal pagsh pagsh.krb \
 		core AFS_component_version_number.c tokens.krb
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 include ../config/Makefile.version
diff --git a/src/util/Makefile.in b/src/util/Makefile.in
index 27fa26e..d1fcbae 100644
--- a/src/util/Makefile.in
+++ b/src/util/Makefile.in
@@ -212,8 +212,9 @@
 	$(RM) -f sys dirpath.h
 	$(RM) -f util.a *.o core AFS_component_version_number.c
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 include ../config/Makefile.version
 
diff --git a/src/venus/Makefile.in b/src/venus/Makefile.in
index 78645b7..6ad2211 100644
--- a/src/venus/Makefile.in
+++ b/src/venus/Makefile.in
@@ -366,7 +366,8 @@
 		AFS_component_version_number.c fstrace gcpags livesys dedebug \
 		cacheout afsio
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 include ../config/Makefile.version
diff --git a/src/vol/Makefile.in b/src/vol/Makefile.in
index 8da6394..320be75 100644
--- a/src/vol/Makefile.in
+++ b/src/vol/Makefile.in
@@ -246,8 +246,9 @@
 	$(RM) -f *.o *.a AFS_component_version_number.c
 	$(RM) -f ${SCMPROGS} ${STAGEPROGS} core salvager volinfo volscan vol-bless gi fssync-debug
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 include ../config/Makefile.version
 
From bd304fcab943c716097c1f7408f153fde2adc1c2 Mon Sep 17 00:00:00 2001
From: Mark Vitale <mvitale@sinenomine.net>
Date: Tue, 05 Mar 2019 23:11:38 -0500
Subject: [PATCH] dir: make dtest buildable again

Commit 7fe4125fe3435092b75ed29b884d8d3c2d1a2cad 'dir/vol: Die() really
does' overlooked src/dir/test/dtest.c, breaking its build.

Fix the signature of Die() and the makefile so dtest can be built.
In addition, change the Makefile so it is always built.

Reviewed-on: https://gerrit.openafs.org/13794
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
(cherry picked from commit 192a2ff49af5dbbb4f8175eec7cb63bfe97e444e)

Change-Id: I92df1068c0c071ac643bd8c43eb7e63efdf4f09b
---

diff --git a/src/dir/Makefile.in b/src/dir/Makefile.in
index 34c63f5..729083d 100644
--- a/src/dir/Makefile.in
+++ b/src/dir/Makefile.in
@@ -12,7 +12,8 @@
 
 all: \
 	${TOP_LIBDIR}/libdir.a \
-	depinstall
+	depinstall \
+	test
 
 depinstall: \
 	${TOP_INCDIR}/afs/dir.h
@@ -29,7 +30,7 @@
 	$(RANLIB) $@
 
 .PHONY: test
-test:
+test: ${TOP_LIBDIR}/libdir.a
 	cd test && $(MAKE)
 
 buffer.o: buffer.c dir.h
diff --git a/src/dir/test/Makefile.in b/src/dir/test/Makefile.in
index bf47fd1..e205f23 100644
--- a/src/dir/test/Makefile.in
+++ b/src/dir/test/Makefile.in
@@ -10,7 +10,8 @@
 include @TOP_OBJDIR@/src/config/Makefile.lwp
 
 
-LIBS = ${srcdir}/lib/libdir.a ${srcdir}/lib/util.a  ${srcdir}/lib/liblwp.a
+LIBS = ${srcdir}/lib/libdir.a ${srcdir}/lib/liblwp.a \
+	   ${srcdir}/lib/libopr.a
 
 OBJS=test-salvage.o physio.o dtest.o
 
diff --git a/src/dir/test/dtest.c b/src/dir/test/dtest.c
index e881c67..d2d3d38 100644
--- a/src/dir/test/dtest.c
+++ b/src/dir/test/dtest.c
@@ -14,6 +14,7 @@
 #include <roken.h>
 
 #include <afs/dir.h>
+#include <afs/opr.h>
 
 long fidCounter = 0;
 
@@ -244,9 +245,10 @@
 }
 
 void
-Die(char *msg)
+Die(const char *msg)
 {
     printf("Something died with this message:  %s\n", msg);
+    opr_abort();
 }
 
 void
From d18d5c8ed290b13234b4f69c9cbe08e51654d79d Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@dson.org>
Date: Fri, 05 Mar 2021 22:20:35 -0600
Subject: [PATCH] dir: Explicitly 'make all' in src/dir/test

Currently, we 'cd test' and then just run 'make', which makes the
first target specified in the Makefile. On some platforms (FreeBSD),
this results in 'make' trying to build '%.c', which of course we
cannot do, since that's a pattern rule, and so 'make' fails.

To fix this, just 'make all' explicitly, to make the intended targets
in src/dir/test.

Reviewed-on: https://gerrit.openafs.org/14550
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
(cherry picked from commit c0b7367253eb6c346d577e099a0b0172d4d24ff3)

Change-Id: I3c1cc73d88471a31ce2d95325c8dafe797d1c43d
---

diff --git a/src/dir/Makefile.in b/src/dir/Makefile.in
index 729083d..2d3f6d7 100644
--- a/src/dir/Makefile.in
+++ b/src/dir/Makefile.in
@@ -31,7 +31,7 @@
 
 .PHONY: test
 test: ${TOP_LIBDIR}/libdir.a
-	cd test && $(MAKE)
+	cd test && $(MAKE) all
 
 buffer.o: buffer.c dir.h
 
From 2ee6960e6e7c3652eab4ec044d5eb2588762006c Mon Sep 17 00:00:00 2001
From: Russ Allbery <rra@stanford.edu>
Date: Mon, 03 Aug 2020 20:59:25 -0400
Subject: [PATCH] Import of code from c-tap-harness

This commit updates the code imported from c-tap-harness to
abdb66561ffd4d2f238fdb06f448ccf09d80c059 (release/4.7)

Upstream changes are:

Daniel Collins (1):
      Add is_blob() test function.

Daniel Kahn Gillmor (1):
      LICENSE: use https for all URLs

Daria Brashear (1):
      Add verbose mode environment variable to runtests

Julien ÉLIE (2):
      Document -v in usage and comments of runtests
      Avoid realloc of zero length in tests/runtests.c

Marc Dionne (1):
      Add test_cleanup_register_with_data

Russ Allbery (115):
      clang --analyze cleanups for runtests
      Modernize POD tests
      Update README to my current layout
      Explicitly note that test programs must be executable
      Fix comment typo in tests/runtests.c
      Switch to a copyright-format 1.0 LICENSE file
      Flush harness output after each line
      Show the test count as ? when the plan is deferred
      More correctly backspace over test counts when aborting
      Refactor test list handling
      Allow passing tests on the runtests command line
      Don't allow command-line arguments if a list was given
      Search for tests under the name given as well
      Release 2.0
      Fix backward incompatibility when searching for tests
      Document decision to ignore TAP version directives
      Release 2.1
      Document different runtests behavior in bail handling
      Change exit status of bail to 255
      Release 2.2
      Add a new test_cleanup_register C API
      Add warn_unused_result attributes
      Add portability for warn_unsed_result attributes to tap/macros.h
      Minor coding style fix (spacing) in runtests.c
      Split the runtests usage string for ISO C90 string limits
      Include stddef.h
      Diagnose failure to register the exit handler
      Use diag internally in the basic C TAP library
      Some additional comments about cleanup functions
      Move repetitive printing code in the C TAP library to a macro
      Set a flag when bailing for more correct cleanup
      Change my email address to eagle@eyrie.org
      Release 2.3
      Add diag_file_add and diag_file_remove functions
      Don't die for unknown files passed to diag_file_remove
      Release 2.4
      Update comment about AIX and WCOREDUMP
      Don't test for NULL before calling free
      Be more careful about file descriptors in child processes
      Run cleanup functions in non-primary processes as well
      Release 3.0
      Update collective package copyright notices at start of LICENSE
      Check integer overflows on memory allocation, fix string creation
      Switch POD spelling test to use Lancaster consensus variable
      Add new bnrealloc API for brealloc with checked multiplication
      Rename nrealloc to reallocarray
      Return the test status from test functions
      Fix the overflow check for breallocarray
      Fix the overflow check for xreallocarray in runtests
      Restructure test result reallocation in runtests
      Change diag and sysdiag to always return true
      Release 3.1
      Fix typos in basic.c and basic.h
      Fix usage message when running runtests with no arguments
      Update introductory runtests comments for current syntax
      Add the -l flag to suggested runtests invocation in README
      Support comments and blank lines in test lists
      Release 3.2
      Update licensing information
      Various improvements to verbose support
      Compile warning-free with Clang, check Autoconf macros
      Release 3.3
      Remove unnecessary assert.h include in tap/basic.c
      Fix some additional -v documentation issues
      Rebalance usage to avoid too-long strings
      Fix segfault in runtests with empty test list
      Release 3.4
      Document running autogen if starting from Git
      Rename autogen to bootstrap
      Support and prefer C_TAP_SOURCE and C_TAP_BUILD
      Fix comment typo in tests/runtests.c
      Add missing va_end to is_double
      Release 4.0
      Fix all non-https www.eyrie.org URLs
      Add is_bool C test function
      Add DocKnot metadata and a Markdown README file
      Update documentation for new DocKnot standards
      Release 4.1
      Use more defaults from DocKnot templates
      Fix new fall-through warning in GCC 7
      Use compiler warnings from rra-c-util, fix issues
      Merge pull request #4 from solemnwarning/master
      Coding style fixes and NEWS for is_blob
      Re-enable -Wunknown-pragmas for GCC
      Avoid zero-length realloc allocations in breallocarray
      Update copyright date on tests/runtests.c
      Release 4.2
      Add SPDX-License-Identifier headers to source files
      Add and run new check-cppcheck target
      Fix instructions for running one test
      Identify values as left and right
      Fix is_string comparisons with NULL pointers
      Add support for running tests under valgrind
      Replace putc with fprintf
      Update shared files from rra-c-util
      Release 4.3
      Update NEWS date for 4.3 release
      Collapse some copyright dates
      NEWS and coding style for test_cleanup_register_with_data
      Remove unused variables caught by Clang scan-build
      Update to rra-c-util 8.0
      Fix error checking in bstrndup
      Release 4.4
      Add support for C++
      Document that C TAP Harness can be built as C++
      Release 4.5
      Regenerate README files
      Reformat using clang-format 10
      Update to rra-c-util 8.1
      Release 4.6
      Fix spelling errors caught by codespell
      Protect the test suite against C_TAP_VERBOSE
      Switch to GitHub Actions for CI
      Add NEWS entry for GCC 10 warning fixes
      Release 4.7

Reviewed-on: https://gerrit.openafs.org/14294
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Tested-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 3f377aa117273eba5c77ad652c0b086446b3f874)

Change-Id: I7b72d9ebd34d3bb5a05268339e136bb1b4309b92
---

diff --git a/src/external/c-tap-harness-last b/src/external/c-tap-harness-last
index 3420957..3f9f4cb 100644
--- a/src/external/c-tap-harness-last
+++ b/src/external/c-tap-harness-last
@@ -1 +1 @@
-d3fc03606efc8e76ff34f04470e6133db25a3982
+abdb66561ffd4d2f238fdb06f448ccf09d80c059
diff --git a/src/external/c-tap-harness/LICENSE b/src/external/c-tap-harness/LICENSE
index 5f95816..783d176 100644
--- a/src/external/c-tap-harness/LICENSE
+++ b/src/external/c-tap-harness/LICENSE
@@ -1,138 +1,154 @@
-The C TAP Harness package as a whole is:
+Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
+Comment: This file documents the copyright statements and licenses for
+ every file in this package in a machine-readable format.  For a less
+ detailed, higher-level overview, see README.
+ .
+ For any copyright year range specified as YYYY-ZZZZ in this file, the
+ range specifies every single year in that closed interval.
 
-  Copyright 2000, 2001, 2004, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-      Russ Allbery <rra@stanford.edu>
-  Copyright 2006, 2007, 2008, 2009, 2011, 2012
-      The Board of Trustees of the Leland Stanford Junior University
+Files: *
+Copyright: 2000-2001, 2004, 2006-2020 Russ Allbery <eagle@eyrie.org>
+  2001-2002, 2004-2014
+    The Board of Trustees of the Leland Stanford Junior University
+License: Expat
 
-and released under the following license:
+Files: .clang-format docs/api/bail.3 docs/api/bail.pod
+ docs/api/bcalloc_type.3 docs/api/bcalloc_type.pod docs/api/bmalloc.3
+ docs/api/bmalloc.pod docs/api/breallocarray.3 docs/api/breallocarray.pod
+ docs/api/diag.3 docs/api/diag.pod docs/api/diag_file_add.3
+ docs/api/diag_file_add.pod docs/api/is_int.3 docs/api/is_int.pod
+ docs/api/ok.3 docs/api/ok.pod docs/api/plan.3 docs/api/plan.pod
+ docs/api/skip.3 docs/api/skip.pod docs/api/skip_all.3
+ docs/api/skip_all.pod docs/api/test_cleanup_register.3
+ docs/api/test_cleanup_register.pod docs/api/test_file_path.3
+ docs/api/test_file_path.pod docs/api/test_tmpdir.3
+ docs/api/test_tmpdir.pod docs/runtests.1 docs/runtests.pod
+ docs/writing-tests tests/data/cppcheck.supp
+Copyright: 2009-2020 Russ Allbery <eagle@eyrie.org>
+License: all-permissive
+ Copying and distribution of this file, with or without modification, are
+ permitted in any medium without royalty provided the copyright notice and
+ this notice are preserved.  This file is offered as-is, without any
+ warranty.
 
-  Permission is hereby granted, free of charge, to any person obtaining a
-  copy of this software and associated documentation files (the
-  "Software"), to deal in the Software without restriction, including
-  without limitation the rights to use, copy, modify, merge, publish,
-  distribute, sublicense, and/or sell copies of the Software, and to
-  permit persons to whom the Software is furnished to do so, subject to
-  the following conditions:
+Files: Makefile.in
+Copyright: 1994-2020 Free Software Foundation, Inc.
+  2008-2020 Russ Allbery <eagle@eyrie.org>
+License: FSF-unlimited and Expat
 
-  The above copyright notice and this permission notice shall be included
-  in all copies or substantial portions of the Software.
+Files: aclocal.m4
+Copyright: 1996-2020 Free Software Foundation, Inc.
+License: FSF-unlimited
 
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+Files: build-aux/ar-lib build-aux/compile build-aux/depcomp
+ build-aux/missing
+Copyright: 1996-2020 Free Software Foundation, Inc.
+License: GPL-2+ with Autoconf exception or Expat
 
-All individual files without an explicit exception below are released
-under this license.  Some files may have additional copyright holders as
-noted in those files.
+Files: build-aux/install-sh
+Copyright: 1994 X Consortium
+License: X11
+ Permission is hereby granted, free of charge, to any person obtaining a
+ copy of this software and associated documentation files (the
+ "Software"), to deal in the Software without restriction, including
+ without limitation the rights to use, copy, modify, merge, publish,
+ distribute, sublicense, and/or sell copies of the Software, and to permit
+ persons to whom the Software is furnished to do so, subject to the
+ following conditions:
+ .
+ The above copyright notice and this permission notice shall be included
+ in all copies or substantial portions of the Software.
+ .
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ OTHER DEALINGS IN THE SOFTWARE.
+ .
+ Except as contained in this notice, the name of the X Consortium shall
+ not be used in advertising or otherwise to promote the sale, use or other
+ dealings in this Software without prior written authorization from the X
+ Consortium.
 
-Some files in this distribution are individually released under different
-licenses, all of which are compatible with the above general package
-license but which may require preservation of additional notices.  All
-required notices are preserved in this file.  Of the files intended to be
-copied into other packages, only docs/writing-tests has a different
-license notice, and its requirements are met by preserving the license
-section of that document in any derivative works.
+Files: configure
+Copyright: 1992-1996, 1998-2012 Free Software Foundation, Inc.
+License: FSF-configure
+ This script is free software; the Free Software Foundation gives unlimited
+ permission to copy, distribute and modify it.
 
-Collected copyright notices for the entire package:
+Files: m4/cc-flags.m4
+Copyright: 2006, 2009, 2016 Internet Systems Consortium, Inc.
+  2016-2020 Russ Allbery <eagle@eyrie.org>
+License: ISC
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+ .
+ THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
+ REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY
+ SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-  Copyright 2000, 2001, 2004, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-      Russ Allbery <rra@stanford.edu>
-  Copyright 2006, 2007, 2008, 2009, 2011, 2012
-      The Board of Trustees of the Leland Stanford Junior University
-  Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-      2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-      Free Software Foundation, Inc.
-  Copyright 1994 X Consortium
+Files: m4/clang.m4
+Copyright: 2015 Russ Allbery <eagle@eyrie.org>
+License: unlimited
+ This file is free software; the authors give unlimited permission to copy
+ and/or distribute it, with or without modifications, as long as this
+ notice is preserved.
 
-The file docs/writing-tests is released under the following license:
+License: Expat
+ Permission is hereby granted, free of charge, to any person obtaining a
+ copy of this software and associated documentation files (the
+ "Software"), to deal in the Software without restriction, including
+ without limitation the rights to use, copy, modify, merge, publish,
+ distribute, sublicense, and/or sell copies of the Software, and to permit
+ persons to whom the Software is furnished to do so, subject to the
+ following conditions:
+ .
+ The above copyright notice and this permission notice shall be included
+ in all copies or substantial portions of the Software.
+ .
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
+ OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
-  Copying and distribution of this file, with or without modification, are
-  permitted in any medium without royalty provided the copyright notice
-  and this notice are preserved.  This file is offered as-is, without any
-  warranty.
+License: FSF-unlimited
+ This file is free software; the Free Software Foundation gives unlimited
+ permission to copy and/or distribute it, with or without modifications, as
+ long as this notice is preserved.
+ .
+ This program is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+ implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
-The files Makefile.in and aclocal.m4 are generated by GNU Automake and
-released under the following copyright and license:
+License: GPL-2+ with Autoconf exception
+ This file is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License as published by the
+ Free Software Foundation; either version 2 of the License, or (at your
+ option) any later version.
+ .
+ This program is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+ Public License for more details.
+ .
+ You should have received a copy of the GNU General Public License along
+ with this program.  If not, see <https://www.gnu.org/licenses/>.
+ .
+ As a special exception to the GNU General Public License, if you
+ distribute this file as part of a program that contains a configuration
+ script generated by Autoconf, you may include it under the same
+ distribution terms that you use for the rest of that program.
+Comment: The option described in the license has been accepted and these
+ files are distributed under the same terms as the package as a whole, as
+ described at the top of this file.
 
-  Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-  2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-  Foundation, Inc.  This file is free software; the Free Software
-  Foundation gives unlimited permission to copy and/or distribute it, with
-  or without modifications, as long as this notice is preserved.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-  even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-  PARTICULAR PURPOSE.
-
-The file configure is generated by GNU Autoconf and is released under the
-following copyright and license:
-
-  Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-  2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
-  Foundation, Inc.  This configure script is free software; the Free
-  Software Foundation gives unlimited permission to copy, distribute and
-  modify it.
-
-The files build-aux/compile, build-aux/depcomp, and build-aux/missing are
-taken from GNU Automake and are released under the following copyright and
-license:
-
-  Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005, 2006,
-  2007, 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
-
-  This program is free software; you can redistribute it and/or modify it
-  under the terms of the GNU General Public License as published by the
-  Free Software Foundation; either version 2, or (at your option) any
-  later version.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  As a special exception to the GNU General Public License, if you
-  distribute this file as part of a program that contains a configuration
-  script generated by Autoconf, you may include it under the same
-  distribution terms that you use for the rest of that program.
-
-For the C TAP Harness distribution, the option described in the last
-paragraph has been accepted and these files are distributed under the same
-terms as the C TAP Harness package as a whole, as described at the top of
-this file.
-
-The file build-aux/install-sh is released under the following copyright
-and license:
-
-  Copyright (C) 1994 X Consortium
-
-  Permission is hereby granted, free of charge, to any person obtaining a
-  copy of this software and associated documentation files (the
-  "Software"), to deal in the Software without restriction, including
-  without limitation the rights to use, copy, modify, merge, publish,
-  distribute, sublicense, and/or sell copies of the Software, and to
-  permit persons to whom the Software is furnished to do so, subject to
-  the following conditions:
-
-  The above copyright notice and this permission notice shall be included
-  in all copies or substantial portions of the Software.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
-  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-  OTHER DEALINGS IN THE SOFTWARE.
-
-  Except as contained in this notice, the name of the X Consortium shall
-  not be used in advertising or otherwise to promote the sale, use or
-  other dealings in this Software without prior written authorization
-  from the X Consortium.
-
-  FSF changes to this file are in the public domain.
diff --git a/src/external/c-tap-harness/NEWS b/src/external/c-tap-harness/NEWS
index be4aba8..7e4a617 100644
--- a/src/external/c-tap-harness/NEWS
+++ b/src/external/c-tap-harness/NEWS
@@ -1,5 +1,275 @@
                     User-Visible C TAP Harness Changes
 
+C TAP Harness 4.7 (2020-05-16)
+
+    Allow the package test suite to be run with C_TAP_VERBOSE without
+    breaking test results via inheritance of that setting.
+
+    Fix warnings with GCC 10.
+
+C TAP Harness 4.6 (2020-01-07)
+
+    Reformat all C source using clang-format 10 and the formatting rules
+    specified in .clang-format.
+
+    Update to rra-c-util 8.1:
+
+    * Drop support for Perl versions prior to Perl 5.8.
+
+C TAP Harness 4.5 (2019-08-31)
+
+    Add new bcalloc_type and breallocarray_type macros that take a type
+    instead of a size as their third argument and cast the return value to
+    a pointer to that type.  These are more friendly to C++ code than
+    C-style allocation functions returning void *.
+
+    The test harness and libtap C library can now alternatively be
+    compiled with a C++ compiler, making it easier to incorporate them
+    into a C++ project.  Thanks to Peter Paris for the initial report.
+
+C TAP Harness 4.4 (2018-12-25)
+
+    Add test_cleanup_register_with_data to the C TAP library.  This is the
+    same as test_cleanup_register except takes a generic pointer, which is
+    then passed to the cleanup function as a third argument.  This should
+    have been the only API from the beginning, but test_cleanup_register
+    is preserved for backward compatibility.  Patch from Marc Dionne.
+
+    Fix error checking for malloc failure in bstrndup function (caught by
+    cppcheck).
+
+    Update to rra-c-util 8.0:
+
+    * Skip tests requiring Test::More if it isn't available.
+    * Check for pre-SPDX license grant strings.
+    * Improved test for obsolete strings in package source files.
+
+C TAP Harness 4.3 (2018-05-06)
+
+    Add support for valgrind and libtool test options in test lists.  Test
+    lists now take a space-separated set of options after the test name.
+    If the valgrind option is present and C_TAP_VALGRIND is set in the
+    environment, the test will be run by passing it as an option to the
+    command given in C_TAP_VALGRIND.  If the libtool option is also set,
+    valgrind will be run via the libtool script set in C_TAP_LIBTOOL,
+    using --mode=execute, so that valgrind will run on the underlying
+    binary and not the libtool shell wrapper.
+
+    On test failures, report the values as left and right instead of
+    wanted and seen.  This idea is stolen from the Rust assert framework.
+    It avoids having to care about the order in which values are passed
+    into the test functions.
+
+    Fix is_string comparisons involving NULL pointers so that the string
+    "(null)" will no longer compare equal to NULL (although the diagnostic
+    output on test failure is still mildly confusing).
+
+    Add new check-cppcheck target that runs cppcheck on all source code,
+    and fix one unnecessary check for NULL that it uncovered.
+
+    Add SPDX-License-Identifier headers to all substantial source files,
+    and add a test to check for them.  This imports more supporting test
+    machinery whose canonical home is in rra-c-util.  If you want to use
+    files in tests/tap/perl, copy them from rra-c-util instead of this
+    package.
+
+    C TAP Harness now imports the Perl test modules from rra-c-util to
+    support some checks, so tests/docs/pod-spelling-t and tests/docs/pod-t
+    have been updated to the versions from rra-c-util.  Projects that were
+    previously copying those tests should be able to continue to use them,
+    but will now need the modules in tests/tap/perl (the canonical version
+    of which are maintained in rra-c-util).
+
+C TAP Harness 4.2 (2017-12-30)
+
+    Add is_blob function to the C test library.  This tests whether two
+    regions of memory are identical, similar to ok(memcmp(...)) but
+    reporting where the regions differ.  Patch from Daniel Collins.
+
+    Avoid zero-length realloc allocations in breallocarray.
+
+    Fix new fall-through warning in GCC 7.
+
+    Switch to the compiler warning Autoconf macros and warning set from
+    rra-c-util with the addition of -ansi -pedantic for GCC and
+    -pedantic-errors for Clang.  Add some casts to fix warnings from
+    -Wconversion, and suppress some spurious warnings from Clang about
+    tests/tap/float.c.
+
+C TAP Harness 4.1 (2016-12-23)
+
+    Add is_bool function to the C test library.  This compares its two
+    arguments only for their truthfulness.  is_bool(true, arg) is the same
+    as ok(arg), but there are times (such as when testing for a false
+    value) where this allows for clearer code or clearer output.
+
+C TAP Harness 4.0 (2016-05-07)
+
+    When building runtests, one must now set the C_TAP_SOURCE and
+    C_TAP_BUILD C preprocessor symbols to the source and build
+    directories, instead of SOURCE and BUILD.  An updated Makefile.am
+    recipe is documented in README.
+
+    runtests now sets C_TAP_SOURCE and C_TAP_BUILD in the environment in
+    addition to SOURCE and BUILD.  All test programs using this harness
+    should switch to the new C_TAP_SOURCE and C_TAP_BUILD environment
+    variables.  SOURCE and BUILD are very generic and may conflict with
+    other programs and uses, and setting them will be removed in a later
+    version.
+
+    The TAP test libraries (C and shell) now use C_TAP_SOURCE and
+    C_TAP_BUILD environment variables instead of SOURCE and BUILD for the
+    test_file_path() and test_tmpdir() functions.  If you were using these
+    libraries with another test harness, you will need to set the new
+    environment variables.
+
+    Fix missing va_end() call in is_double(), which would have caused
+    compilation failures or other problems on some platforms.  Thanks,
+    Julien ÉLIE.
+
+    Rename the script to bootstrap from a Git checkout to bootstrap,
+    matching the emerging consensus in the Autoconf world.
+
+C TAP Harness 3.4 (2015-08-18)
+
+    Fix segfault in runtests when given a test list containing only
+    comments and blank lines.  Thanks, aherbert.
+
+C TAP Harness 3.3 (2015-04-26)
+
+    If runtests is given the -v option, or if the environment variable
+    C_TAP_VERBOSE is set, the complete output of each test program will be
+    shown instead of the summary of total and failing tests.  Based on
+    work by D. Brashear.
+
+    C TAP Harness now compiles cleanly with Clang with -Weverything
+    -Wno-padded -pedantic-errors, and automatically detects Clang and
+    switches warning flags for make warnings.
+
+C TAP Harness 3.2 (2014-12-25)
+
+    The runtests harness now supports ignoring comments and blank lines in
+    the test list specified with -l.  Leading whitespace before the test
+    name is also ignored.
+
+C TAP Harness 3.1 (2014-07-02)
+
+    ok, okv, and all is_* functions now return true if the test succeeds
+    and false if it fails, matching the return status of the corresponding
+    Perl Test::More functions.  This allows more succinct code when the
+    actions of a test program should vary based on the success or failure
+    of previous tests.  Based on a patch by Peter Pöschl.
+
+    diag and sysdiag now always return 1, making it easier to insert calls
+    into compound statements when debugging tests.  Based on a patch by
+    Peter Pöschl.
+
+    Add new breallocarray API that does the same as realloc but takes
+    calloc-style arguments to specify the size and checks internally for
+    integer overflow.  Inspired by the OpenBSD reallocarray function.
+
+    Check for integer overflows on memory allocation.  All the possible
+    issues for this code are rather theoretical, but one may as well
+    strive for correctness.
+
+    Replace all uses of sprintf with a simpler string concatenation
+    function that checks for allocation overflow.  (The standards
+    assumptions for this package don't permit assuming asprintf or a
+    sufficiently non-broken snprintf to simulate asprintf.)
+
+C TAP Harness 3.0 (2014-01-28)
+
+    The test_cleanup_register API has changed in this release.  Cleanup
+    functions must now take two parameters, not one, and are called from
+    all test processes, not just the primary one.  The new second argument
+    indicates whether the cleanup function was called in the primary
+    process (the one in which plan or plan_lazy was called).  External
+    resources, such as files, should generally only be freed when the
+    cleanup function is called in the primary process, but tests may want
+    to free internal resources, like memory, in all processes to ease
+    analysis with tools like valgrind.
+
+    When running test programs from a list, reopen standard input for each
+    program to /dev/null, and be more careful about closing all duplicates
+    of file descriptors left behind after setting up standard output and
+    standard error so that extraneous file descriptors aren't leaked to
+    the child process.
+
+C TAP Harness 2.4 (2013-12-25)
+
+    Add new diag_file_add and diag_file_remove APIs to the basic C TAP
+    library.  These functions manage a list of registered file that
+    contains supplemental diagnostic information.  Each registered file is
+    checked before each output function for any new lines, and any lines
+    are displayed as if they'd been passed to diag().  This can be useful
+    if, for example, the test involves a background daemon whose output
+    can be logged to a disk file.
+
+C TAP Harness 2.3 (2013-11-13)
+
+    Add new test_cleanup_register API to the basic C TAP library.  This
+    registers a C callback function that's called during exit from the
+    test and passed in a boolean argument indicating whether the test
+    succeeded or failed.
+
+    Suppress lazy plans and the summary of tests at the end of a test
+    program if the program aborted with bail or sysbail.
+
+    Add warn_unused_result gcc attributes to the C TAP library functions
+    where ignoring the return value is almost certainly a bug (such as all
+    the malloc functions).
+
+    Add portability for warn_unsed_result attributes to tap/macros.h.
+
+C TAP Harness 2.2 (2013-08-14)
+
+    bail and sysbail now exit with status 255 to match the behavior of
+    BAIL_OUT in Perl's Test::More.
+
+    Document that runtests handling of test cases that bail out differs
+    from the documented behavior of BAIL_OUT in Perl's Test::More and the
+    behavior of prove, and document why.
+
+C TAP Harness 2.1 (2013-03-15)
+
+    When locating test programs, try a suffix (-t, .t, or no suffix) with
+    all bases before moving on to the next suffix.  The behavior in the
+    previous release was not backward-compatible: it would find the
+    unsuffixed helper program in the build directory instead of the actual
+    test in the source directory for some rra-c-util tests when the build
+    directory and the source directory weren't the same.
+
+    Document that TAP version directives in the TAP output are ignored.
+
+C TAP Harness 2.0 (2013-03-14)
+
+    The default behavior of tests/runtests has changed to make it act more
+    like other test drivers.  Now, to provide a file containing a list of
+    tests, use the -l option.  Existing users should add -l to the command
+    line in front of the test list.  Otherwise, the command-line arguments
+    are taken as tests to run, as if they were all listed in a test list
+    file.
+
+    runtests now tries the test name without any extension if the test
+    name with either -t or .t was not found.  It also does not consider a
+    directory to be a valid test when searching for the executable, even
+    if the directory is executable.
+
+    Flush the harness output after each test.  This effectively implements
+    line buffering even when standard output is not a terminal and
+    therefore output isn't flushed after each line of test output.
+
+    When displaying partial status of tests with a deferred plan, show the
+    total number of tests as ? rather than the number of tests seen so
+    far.  This matches the behavior of Perl's prove utility.
+
+    More correctly handle backspacing over the test count in several abort
+    cases when reporting status to a terminal.
+
+    Add GCC annotations to some internal functions in runtests to help
+    clang --analyze better understand code correctness.  Remove a dead
+    store caught by clang --analyze.
+
 C TAP Harness 1.12 (2012-05-11)
 
     Fix additional uses of local in the shell TAP library for portability
@@ -54,7 +324,7 @@
 
     Move the is_double C TAP test function into a separate source file.
     Including this function may require linking with libm on some
-    platforms, which is undesireable if the package otherwise doesn't use
+    platforms, which is undesirable if the package otherwise doesn't use
     math functions.  The new tests/tap/float.c and tests/tap/float.h files
     need only be included in a package that wants to do floating point
     tests.  Users of is_double will now need to include tests/tap/float.h
diff --git a/src/external/c-tap-harness/README b/src/external/c-tap-harness/README
index ddcfc91..3a6bb55 100644
--- a/src/external/c-tap-harness/README
+++ b/src/external/c-tap-harness/README
@@ -1,12 +1,12 @@
-                            C TAP Harness 1.12
+                            C TAP Harness 4.7
                (C harness for running TAP-compliant tests)
+               Maintained by Russ Allbery <eagle@eyrie.org>
 
-                Written by Russ Allbery <rra@stanford.edu>
-
-  Copyright 2000, 2001, 2004, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-  Russ Allbery <rra@stanford.edu>.  This software is distributed under a
-  BSD-style license.  Please see the file LICENSE in the distribution for
-  more information.
+  Copyright 2000-2001, 2004, 2006-2020 Russ Allbery <eagle@eyrie.org>.
+  Copyright 2006-2009, 2011-2013 The Board of Trustees of the Leland
+  Stanford Junior University.  This software is distributed under a
+  BSD-style license.  Please see the section LICENSE below for more
+  information.
 
 BLURB
 
@@ -28,7 +28,7 @@
   merges all the various versions into a single code base that all my
   packages can pull from.
 
-  C TAP Harness provides a full TAP specification (apart from a few
+  C TAP Harness provides a full TAP specification driver (apart from a few
   possible edge cases) and has additional special features for supporting
   builds outside the source directory.  It's mostly useful for packages
   using Autoconf and Automake and because it doesn't assume or require
@@ -44,7 +44,11 @@
 
   Also included in this package are C and shell libraries that provide
   utility functions for writing test scripts that use TAP to report
-  exists.
+  results.  The C library also provides a variety of utility functions
+  useful for test programs running as part of an Automake-built package:
+  finding test data files, creating temporary files, reporting output from
+  external programs running in the background, and similar common
+  problems.
 
 REQUIREMENTS
 
@@ -55,50 +59,68 @@
   Bourne-compatible shell.  Outside of the test suite, C TAP Harness has
   no other prerequisites or requirements.
 
-  To run the test suite, you will need Perl plus the Perl modules
-  Test::More and Test::Pod.  Test::More comes with Perl 5.8 and later.
-  Test::Pod is available from CPAN and currently must be installed
-  separately, but the POD tests will be skipped without interfering with
-  the rest of the tests if it's not installed.
-
-  To check spelling in the POD documentation, Pod::Spell (available from
-  CPAN) and either aspell or ispell with the american dictionary are also
-  required.  The user's path is searched for aspell or ispell and aspell
-  is preferred.  Spelling tests are disabled by default since spelling
-  dictionaries differ too much between systems.  To enable those tests,
-  set RRA_MAINTAINER_TESTS to a true value.
+  C TAP Harness can also be built with a C++ compiler and should be
+  similarly portable to any recent C++ compiler, although it is only
+  tested with g++.
 
   To bootstrap from a Git checkout, or if you change the Automake files
   and need to regenerate Makefile.in, you will need Automake 1.11 or
   later.  For bootstrap or if you change configure.ac or any of the m4
   files it includes and need to regenerate configure or config.h.in, you
-  will need Autoconf 2.64 or later.  Perl is also required to generate the
-  manual page from a fresh Git checkout.
+  will need Autoconf 2.64 or later.  Perl is also required to generate
+  manual pages from a fresh Git checkout.
 
-BUILDING AND TESTING
+BUILDING
 
-  You can build C TAP Harness and run its internal test suite with:
+  You can build C TAP Harness with the standard commands:
 
       ./configure
       make
+
+  If you are building from a Git clone, first run ./bootstrap in the
+  source directory to generate the build files.  Building outside of the
+  source directory is also supported, if you wish, by creating an empty
+  directory and then running configure with the correct relative path.
+
+  Pass --enable-silent-rules to configure for a quieter build (similar to
+  the Linux kernel).  Use make warnings instead of make to build with full
+  compiler warnings (requires either GCC or Clang and may require a
+  relatively current version of the compiler).
+
+  Installing C TAP Harness is not normally done.  Instead, see the section
+  on using the harness below.
+
+TESTING
+
+  C TAP Harness comes with a comprehensive test suite, which you can run
+  after building with:
+
       make check
-
-  While there is a configure script, it exists just to drive the build
-  system and do some path substitution and isn't doing portability
-  probes.  Pass --enable-silent-rules to configure for a quieter build
-  (similar to the Linux kernel).
-
-  Use make warnings instead of make to build with full GCC compiler
-  warnings (requires a relatively current version of GCC).
 
   If a test fails, you can run a single test with verbose output via:
 
-      ./runtests -b `pwd`/tests -s `pwd`/tests -o <name-of-test>
+      tests/runtests -b $(pwd)/tests -s $(pwd)/tests -o <name-of-test>
 
   Do this instead of running the test program directly since it will
   ensure that necessary environment variables are set up.  You may need to
-  change the -s option if you build with a separate build directory from
-  the source directory.
+  change the -s option argument if you build with a separate build
+  directory from the source directory.
+
+  To run the test suite, you will need Perl 5.8 or later.  The following
+  additional Perl modules will be used by the test suite if present:
+
+  * Test::Pod
+  * Test::Spelling
+
+  All are available on CPAN.  Those tests will be skipped if the modules
+  are not available.
+
+  To enable tests that don't detect functionality problems but are used to
+  sanity-check the release, set the environment variable RELEASE_TESTING
+  to a true value.  To enable tests that may be sensitive to the local
+  environment or that produce a lot of false positives without uncovering
+  many problems, set the environment variable AUTHOR_TESTING to a true
+  value.
 
 USING THE HARNESS
 
@@ -123,8 +145,8 @@
     library:
 
         check_PROGRAMS = tests/runtests
-        tests_runtests_CPPFLAGS = -DSOURCE='"$(abs_top_srcdir)/tests"' \
-                -DBUILD='"$(abs_top_builddir)/tests"'
+        tests_runtests_CPPFLAGS = -DC_TAP_SOURCE='"$(abs_top_srcdir)/tests"' \
+                -DC_TAP_BUILD='"$(abs_top_builddir)/tests"'
         check_LIBRARIES = tests/tap/libtap.a
         tests_tap_libtap_a_CPPFLAGS = -I$(abs_top_srcdir)/tests
         tests_tap_libtap_a_SOURCES = tests/tap/basic.c tests/tap/basic.h \
@@ -132,8 +154,8 @@
 
     Omit float.c and float.h from the last line if your package doesn't
     need the is_double function.  Building the build and source
-    directories into runtests will let tests/runtests -o <test> to work
-    for users without requiring that they set any other variables, even if
+    directories into runtests will let tests/runtests -o <test> work for
+    users without requiring that they set any other variables, even if
     they're doing an out-of-source build.
 
     Add additional source files and headers that should go into the TAP
@@ -142,16 +164,18 @@
   * Add code to Makefile.am to run the test suite:
 
         check-local: $(check_PROGRAMS)
-              cd tests && ./runtests $(abs_top_srcdir)/tests/TESTS
+              cd tests && ./runtests -l $(abs_top_srcdir)/tests/TESTS
 
-    See the Makefile.am in this package for an example (although note that
-    it keeps runtests in an unusual location).
+    See the Makefile.am in this package for an example.
 
-  * List the test programs in the TESTS file.  This should have the name
-    of the test executable with the trailing "-t" or ".t" (you can use
-    either extension as you prefer) omitted.  For any test programs that
-    need to be compiled, add build rules for them in Makefile.am, simliar
-    to:
+  * List the test programs in the tests/TESTS file.  This should have the
+    name of the test executable with the trailing "-t" or ".t" (you can
+    use either extension as you prefer) omitted.
+
+    Test programs must be executable.
+
+    For any test programs that need to be compiled, add build rules for
+    them in Makefile.am, similar to:
 
         tests_libtap_c_basic_LDADD = tests/tap/libtap.a
 
@@ -173,7 +197,7 @@
     the tap subdirectory of your tests directory and add it to EXTRA_DIST.
     Shell programs should start with:
 
-        . "${SOURCE}/tap/libtap.sh"
+        . "${C_TAP_SOURCE}/tap/libtap.sh"
 
     and can then use the functions defined in the library.
 
@@ -186,43 +210,93 @@
 
   If you have data files that your test cases use, conventionally they go
   into tests/data.  You can then find the data directory relative to the
-  SOURCE environment variable (set by runtests) in your test program.  If
-  you have data that's compiled or generated by Autoconf, it will be
-  relative to the BUILD environment variable.  Don't forget to add test
-  data to EXTRA_DIST as necessary.
+  C_TAP_SOURCE environment variable (set by runtests) in your test
+  program.  If you have data that's compiled or generated by Autoconf, it
+  will be relative to the BUILD environment variable.  Don't forget to add
+  test data to EXTRA_DIST as necessary.
 
   For more TAP library add-ons, generally ones that rely on additional
   portability code not shipped in this package or with narrower uses, see
-  the rra-c-util package:
+  the rra-c-util package [1].  There are several additional TAP library
+  add-ons in the tests/tap directory in that package.  It's also an
+  example of how to use this test harness in another package.
 
-      http://www.eyrie.org/~eagle/software/rra-c-util/
+  [1] https://www.eyrie.org/~eagle/software/rra-c-util/
 
-  There are several additional TAP library add-ons in the tests/tap
-  directory in that package.  It's also an example of how to use this test
-  harness in another package.
-
-HOMEPAGE AND SOURCE REPOSITORY
+SUPPORT
 
   The C TAP Harness web page at:
 
-      http://www.eyrie.org/~eagle/software/c-tap-harness/
+      https://www.eyrie.org/~eagle/software/c-tap-harness/
 
   will always have the current version of this package, the current
   documentation, and pointers to any additional resources.
 
-  C TAP Harness is maintained using Git.  You can access the current
-  source by cloning the repository at:
+  For bug tracking, use the issue tracker on GitHub:
 
-      git://git.eyrie.org/devel/c-tap-harness.git
+      https://github.com/rra/c-tap-harness/issues
+
+  However, please be aware that I tend to be extremely busy and work
+  projects often take priority.  I'll save your report and get to it as
+  soon as I can, but it may take me a couple of months.
+
+SOURCE REPOSITORY
+
+  C TAP Harness is maintained using Git.  You can access the current
+  source on GitHub at:
+
+      https://github.com/rra/c-tap-harness
+
+  or by cloning the repository at:
+
+      https://git.eyrie.org/git/devel/c-tap-harness.git
 
   or view the repository via the web at:
 
-      http://git.eyrie.org/?p=devel/c-tap-harness.git
+      https://git.eyrie.org/?p=devel/c-tap-harness.git
 
-  C TAP Harness is also available via github at:
+  The eyrie.org repository is the canonical one, maintained by the author,
+  but using GitHub is probably more convenient for most purposes.  Pull
+  requests are gratefully reviewed and normally accepted.
 
-      http://github.com/rra/c-tap-harness
+LICENSE
 
-  and the github wiki and issue tracker are available on an experimental
-  basis.  If you like using the github facilities, try filing issues or
-  adding supplemental documentation there.
+  The C TAP Harness package as a whole is covered by the following
+  copyright statement and license:
+
+    Copyright 2000-2001, 2004, 2006-2020 Russ Allbery <eagle@eyrie.org>
+    Copyright 2006-2009, 2011-2013
+        The Board of Trustees of the Leland Stanford Junior University
+
+    Permission is hereby granted, free of charge, to any person obtaining
+    a copy of this software and associated documentation files (the
+    "Software"), to deal in the Software without restriction, including
+    without limitation the rights to use, copy, modify, merge, publish,
+    distribute, sublicense, and/or sell copies of the Software, and to
+    permit persons to whom the Software is furnished to do so, subject to
+    the following conditions:
+
+    The above copyright notice and this permission notice shall be
+    included in all copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+  Some files in this distribution are individually released under
+  different licenses, all of which are compatible with the above general
+  package license but which may require preservation of additional
+  notices.  All required notices, and detailed information about the
+  licensing of each file, are recorded in the LICENSE file.
+
+  Files covered by a license with an assigned SPDX License Identifier
+  include SPDX-License-Identifier tags to enable automated processing of
+  license information.  See https://spdx.org/licenses/ for more
+  information.
+
+  For any copyright range specified by files in this package as YYYY-ZZZZ,
+  the range specifies every single year in that closed interval.
diff --git a/src/external/c-tap-harness/tests/runtests.c b/src/external/c-tap-harness/tests/runtests.c
index 4249875..1050120 100644
--- a/src/external/c-tap-harness/tests/runtests.c
+++ b/src/external/c-tap-harness/tests/runtests.c
@@ -1,17 +1,53 @@
 /*
  * Run a set of tests, reporting results.
  *
+ * Test suite driver that runs a set of tests implementing a subset of the
+ * Test Anything Protocol (TAP) and reports the results.
+ *
+ * Any bug reports, bug fixes, and improvements are very much welcome and
+ * should be sent to the e-mail address below.  This program is part of C TAP
+ * Harness <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ *
+ * Copyright 2000-2001, 2004, 2006-2019 Russ Allbery <eagle@eyrie.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+/*
  * Usage:
  *
- *      runtests [-b <build-dir>] [-s <source-dir>] <test-list>
- *      runtests -o [-b <build-dir>] [-s <source-dir>] <test>
+ *      runtests [-hv] [-b <build-dir>] [-s <source-dir>] -l <test-list>
+ *      runtests [-hv] [-b <build-dir>] [-s <source-dir>] <test> [<test> ...]
+ *      runtests -o [-h] [-b <build-dir>] [-s <source-dir>] <test>
  *
  * In the first case, expects a list of executables located in the given file,
- * one line per executable.  For each one, runs it as part of a test suite,
- * reporting results.  Test output should start with a line containing the
- * number of tests (numbered from 1 to this number), optionally preceded by
- * "1..", although that line may be given anywhere in the output.  Each
- * additional line should be in the following format:
+ * one line per executable, possibly followed by a space-separated list of
+ * options.  For each one, runs it as part of a test suite, reporting results.
+ * In the second case, use the same infrastructure, but run only the tests
+ * listed on the command line.
+ *
+ * Test output should start with a line containing the number of tests
+ * (numbered from 1 to this number), optionally preceded by "1..", although
+ * that line may be given anywhere in the output.  Each additional line should
+ * be in the following format:
  *
  *      ok <number>
  *      not ok <number>
@@ -44,49 +80,30 @@
  * output.  This is intended for use with failing tests so that the person
  * running the test suite can get more details about what failed.
  *
- * If built with the C preprocessor symbols SOURCE and BUILD defined, C TAP
- * Harness will export those values in the environment so that tests can find
- * the source and build directory and will look for tests under both
- * directories.  These paths can also be set with the -b and -s command-line
- * options, which will override anything set at build time.
+ * If built with the C preprocessor symbols C_TAP_SOURCE and C_TAP_BUILD
+ * defined, C TAP Harness will export those values in the environment so that
+ * tests can find the source and build directory and will look for tests under
+ * both directories.  These paths can also be set with the -b and -s
+ * command-line options, which will override anything set at build time.
  *
- * Any bug reports, bug fixes, and improvements are very much welcome and
- * should be sent to the e-mail address below.  This program is part of C TAP
- * Harness <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
- *
- * Copyright 2000, 2001, 2004, 2006, 2007, 2008, 2009, 2010, 2011
- *     Russ Allbery <rra@stanford.edu>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
-*/
+ * If the -v option is given, or the C_TAP_VERBOSE environment variable is set,
+ * display the full output of each test as it runs rather than showing a
+ * summary of the results of each test.
+ */
 
 /* Required for fdopen(), getopt(), and putenv(). */
 #if defined(__STRICT_ANSI__) || defined(PEDANTIC)
-# ifndef _XOPEN_SOURCE
-#  define _XOPEN_SOURCE 500
-# endif
+#    ifndef _XOPEN_SOURCE
+#        define _XOPEN_SOURCE 500
+#    endif
 #endif
 
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stdarg.h>
+#include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -101,63 +118,81 @@
 /* sys/time.h must be included before sys/resource.h on some platforms. */
 #include <sys/resource.h>
 
-/* AIX doesn't have WCOREDUMP. */
+/* AIX 6.1 (and possibly later) doesn't have WCOREDUMP. */
 #ifndef WCOREDUMP
-# define WCOREDUMP(status)      ((unsigned)(status) & 0x80)
+#    define WCOREDUMP(status) ((unsigned) (status) &0x80)
 #endif
 
 /*
- * The source and build versions of the tests directory.  This is used to set
- * the SOURCE and BUILD environment variables and find test programs, if set.
- * Normally, this should be set as part of the build process to the test
- * subdirectories of $(abs_top_srcdir) and $(abs_top_builddir) respectively.
+ * POSIX requires that these be defined in <unistd.h>, but they're not always
+ * available.  If one of them has been defined, all the rest almost certainly
+ * have.
  */
-#ifndef SOURCE
-# define SOURCE NULL
+#ifndef STDIN_FILENO
+#    define STDIN_FILENO  0
+#    define STDOUT_FILENO 1
+#    define STDERR_FILENO 2
 #endif
-#ifndef BUILD
-# define BUILD NULL
+
+/*
+ * Used for iterating through arrays.  Returns the number of elements in the
+ * array (useful for a < upper bound in a for loop).
+ */
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
+
+/*
+ * The source and build versions of the tests directory.  This is used to set
+ * the C_TAP_SOURCE and C_TAP_BUILD environment variables (and the SOURCE and
+ * BUILD environment variables set for backward compatibility) and find test
+ * programs, if set.  Normally, this should be set as part of the build
+ * process to the test subdirectories of $(abs_top_srcdir) and
+ * $(abs_top_builddir) respectively.
+ */
+#ifndef C_TAP_SOURCE
+#    define C_TAP_SOURCE NULL
+#endif
+#ifndef C_TAP_BUILD
+#    define C_TAP_BUILD NULL
 #endif
 
 /* Test status codes. */
-enum test_status {
-    TEST_FAIL,
-    TEST_PASS,
-    TEST_SKIP,
-    TEST_INVALID
-};
+enum test_status { TEST_FAIL, TEST_PASS, TEST_SKIP, TEST_INVALID };
+
+/* Really, just a boolean, but this is more self-documenting. */
+enum test_verbose { CONCISE = 0, VERBOSE = 1 };
 
 /* Indicates the state of our plan. */
 enum plan_status {
-    PLAN_INIT,                  /* Nothing seen yet. */
-    PLAN_FIRST,                 /* Plan seen before any tests. */
-    PLAN_PENDING,               /* Test seen and no plan yet. */
-    PLAN_FINAL                  /* Plan seen after some tests. */
+    PLAN_INIT,    /* Nothing seen yet. */
+    PLAN_FIRST,   /* Plan seen before any tests. */
+    PLAN_PENDING, /* Test seen and no plan yet. */
+    PLAN_FINAL    /* Plan seen after some tests. */
 };
 
 /* Error exit statuses for test processes. */
-#define CHILDERR_DUP    100     /* Couldn't redirect stderr or stdout. */
-#define CHILDERR_EXEC   101     /* Couldn't exec child process. */
-#define CHILDERR_STDERR 102     /* Couldn't open stderr file. */
+#define CHILDERR_DUP    100 /* Couldn't redirect stderr or stdout. */
+#define CHILDERR_EXEC   101 /* Couldn't exec child process. */
+#define CHILDERR_STDIN  102 /* Couldn't open stdin file. */
+#define CHILDERR_STDERR 103 /* Couldn't open stderr file. */
 
 /* Structure to hold data for a set of tests. */
 struct testset {
-    char *file;                 /* The file name of the test. */
-    char *path;                 /* The path to the test program. */
-    enum plan_status plan;      /* The status of our plan. */
-    unsigned long count;        /* Expected count of tests. */
-    unsigned long current;      /* The last seen test number. */
-    unsigned int length;        /* The length of the last status message. */
-    unsigned long passed;       /* Count of passing tests. */
-    unsigned long failed;       /* Count of failing lists. */
-    unsigned long skipped;      /* Count of skipped tests (passed). */
-    unsigned long allocated;    /* The size of the results table. */
-    enum test_status *results;  /* Table of results by test number. */
-    unsigned int aborted;       /* Whether the set as aborted. */
-    int reported;               /* Whether the results were reported. */
-    int status;                 /* The exit status of the test. */
-    unsigned int all_skipped;   /* Whether all tests were skipped. */
-    char *reason;               /* Why all tests were skipped. */
+    char *file;                /* The file name of the test. */
+    char **command;            /* The argv vector to run the command. */
+    enum plan_status plan;     /* The status of our plan. */
+    unsigned long count;       /* Expected count of tests. */
+    unsigned long current;     /* The last seen test number. */
+    unsigned int length;       /* The length of the last status message. */
+    unsigned long passed;      /* Count of passing tests. */
+    unsigned long failed;      /* Count of failing lists. */
+    unsigned long skipped;     /* Count of skipped tests (passed). */
+    unsigned long allocated;   /* The size of the results table. */
+    enum test_status *results; /* Table of results by test number. */
+    unsigned int aborted;      /* Whether the set was aborted. */
+    unsigned int reported;     /* Whether the results were reported. */
+    int status;                /* The exit status of the test. */
+    unsigned int all_skipped;  /* Whether all tests were skipped. */
+    char *reason;              /* Why all tests were skipped. */
 };
 
 /* Structure to hold a linked list of test sets. */
@@ -167,21 +202,27 @@
 };
 
 /*
- * Usage message.  Should be used as a printf format with two arguments: the
- * path to runtests, given twice.
+ * Usage message.  Should be used as a printf format with four arguments: the
+ * path to runtests, given three times, and the usage_description.  This is
+ * split into variables to satisfy the pedantic ISO C90 limit on strings.
  */
 static const char usage_message[] = "\
-Usage: %s [-b <build-dir>] [-s <source-dir>] <test-list>\n\
-       %s -o [-b <build-dir>] [-s <source-dir>] <test>\n\
+Usage: %s [-hv] [-b <build-dir>] [-s <source-dir>] <test> ...\n\
+       %s [-hv] [-b <build-dir>] [-s <source-dir>] -l <test-list>\n\
+       %s -o [-h] [-b <build-dir>] [-s <source-dir>] <test>\n\
 \n\
 Options:\n\
     -b <build-dir>      Set the build directory to <build-dir>\n\
+%s";
+static const char usage_extra[] = "\
+    -l <list>           Take the list of tests to run from <test-list>\n\
     -o                  Run a single test rather than a list of tests\n\
     -s <source-dir>     Set the source directory to <source-dir>\n\
+    -v                  Show the full output of each test\n\
 \n\
-runtests normally runs each test listed in a file whose path is given as\n\
-its command-line argument.  With the -o option, it instead runs a single\n\
-test and shows its complete output.\n";
+runtests normally runs each test listed on the command line.  With the -l\n\
+option, it instead runs every test listed in a file.  With the -o option,\n\
+it instead runs a single test and shows its complete output.\n";
 
 /*
  * Header used for test output.  %s is replaced by the file name of the list
@@ -197,9 +238,83 @@
 -------------------------- -------------- ---- ----  ------------------------";
 
 /* Include the file name and line number in malloc failures. */
-#define xmalloc(size)     x_malloc((size), __FILE__, __LINE__)
-#define xrealloc(p, size) x_realloc((p), (size), __FILE__, __LINE__)
+#define xcalloc(n, type) \
+    ((type *) x_calloc((n), sizeof(type), __FILE__, __LINE__))
+#define xmalloc(size)     ((char *) x_malloc((size), __FILE__, __LINE__))
 #define xstrdup(p)        x_strdup((p), __FILE__, __LINE__)
+#define xstrndup(p, size) x_strndup((p), (size), __FILE__, __LINE__)
+#define xreallocarray(p, n, type) \
+    ((type *) x_reallocarray((p), (n), sizeof(type), __FILE__, __LINE__))
+
+/*
+ * __attribute__ is available in gcc 2.5 and later, but only with gcc 2.7
+ * could you use the __format__ form of the attributes, which is what we use
+ * (to avoid confusion with other macros).
+ */
+#ifndef __attribute__
+#    if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+#        define __attribute__(spec) /* empty */
+#    endif
+#endif
+
+/*
+ * We use __alloc_size__, but it was only available in fairly recent versions
+ * of GCC.  Suppress warnings about the unknown attribute if GCC is too old.
+ * We know that we're GCC at this point, so we can use the GCC variadic macro
+ * extension, which will still work with versions of GCC too old to have C99
+ * variadic macro support.
+ */
+#if !defined(__attribute__) && !defined(__alloc_size__)
+#    if defined(__GNUC__) && !defined(__clang__)
+#        if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 3)
+#            define __alloc_size__(spec, args...) /* empty */
+#        endif
+#    endif
+#endif
+
+/*
+ * LLVM and Clang pretend to be GCC but don't support all of the __attribute__
+ * settings that GCC does.  For them, suppress warnings about unknown
+ * attributes on declarations.  This unfortunately will affect the entire
+ * compilation context, but there's no push and pop available.
+ */
+#if !defined(__attribute__) && (defined(__llvm__) || defined(__clang__))
+#    pragma GCC diagnostic ignored "-Wattributes"
+#endif
+
+/* Declare internal functions that benefit from compiler attributes. */
+static void die(const char *, ...)
+    __attribute__((__nonnull__, __noreturn__, __format__(printf, 1, 2)));
+static void sysdie(const char *, ...)
+    __attribute__((__nonnull__, __noreturn__, __format__(printf, 1, 2)));
+static void *x_calloc(size_t, size_t, const char *, int)
+    __attribute__((__alloc_size__(1, 2), __malloc__, __nonnull__));
+static void *x_malloc(size_t, const char *, int)
+    __attribute__((__alloc_size__(1), __malloc__, __nonnull__));
+static void *x_reallocarray(void *, size_t, size_t, const char *, int)
+    __attribute__((__alloc_size__(2, 3), __malloc__, __nonnull__(4)));
+static char *x_strdup(const char *, const char *, int)
+    __attribute__((__malloc__, __nonnull__));
+static char *x_strndup(const char *, size_t, const char *, int)
+    __attribute__((__malloc__, __nonnull__));
+
+
+/*
+ * Report a fatal error and exit.
+ */
+static void
+die(const char *format, ...)
+{
+    va_list args;
+
+    fflush(stdout);
+    fprintf(stderr, "runtests: ");
+    va_start(args, format);
+    vfprintf(stderr, format, args);
+    va_end(args);
+    fprintf(stderr, "\n");
+    exit(1);
+}
 
 
 /*
@@ -223,6 +338,24 @@
 
 
 /*
+ * Allocate zeroed memory, reporting a fatal error and exiting on failure.
+ */
+static void *
+x_calloc(size_t n, size_t size, const char *file, int line)
+{
+    void *p;
+
+    n = (n > 0) ? n : 1;
+    size = (size > 0) ? size : 1;
+    p = calloc(n, size);
+    if (p == NULL)
+        sysdie("failed to calloc %lu bytes at %s line %d",
+               (unsigned long) size, file, line);
+    return p;
+}
+
+
+/*
  * Allocate memory, reporting a fatal error and exiting on failure.
  */
 static void *
@@ -240,14 +373,29 @@
 
 /*
  * Reallocate memory, reporting a fatal error and exiting on failure.
+ *
+ * We should technically use SIZE_MAX here for the overflow check, but
+ * SIZE_MAX is C99 and we're only assuming C89 + SUSv3, which does not
+ * guarantee that it exists.  They do guarantee that UINT_MAX exists, and we
+ * can assume that UINT_MAX <= SIZE_MAX.  And we should not be allocating
+ * anything anywhere near that large.
+ *
+ * (In theory, C89 and C99 permit size_t to be smaller than unsigned int, but
+ * I disbelieve in the existence of such systems and they will have to cope
+ * without overflow checks.)
  */
 static void *
-x_realloc(void *p, size_t size, const char *file, int line)
+x_reallocarray(void *p, size_t n, size_t size, const char *file, int line)
 {
-    p = realloc(p, size);
+    n = (n > 0) ? n : 1;
+    size = (size > 0) ? size : 1;
+
+    if (n > 0 && UINT_MAX / n <= size)
+        sysdie("realloc too large at %s line %d", file, line);
+    p = realloc(p, n * size);
     if (p == NULL)
         sysdie("failed to realloc %lu bytes at %s line %d",
-               (unsigned long) size, file, line);
+               (unsigned long) (n * size), file, line);
     return p;
 }
 
@@ -262,12 +410,90 @@
     size_t len;
 
     len = strlen(s) + 1;
-    p = malloc(len);
+    p = (char *) malloc(len);
     if (p == NULL)
-        sysdie("failed to strdup %lu bytes at %s line %d",
-               (unsigned long) len, file, line);
+        sysdie("failed to strdup %lu bytes at %s line %d", (unsigned long) len,
+               file, line);
     memcpy(p, s, len);
     return p;
+}
+
+
+/*
+ * Copy the first n characters of a string, reporting a fatal error and
+ * existing on failure.
+ *
+ * Avoid using the system strndup function since it may not exist (on Mac OS
+ * X, for example), and there's no need to introduce another portability
+ * requirement.
+ */
+char *
+x_strndup(const char *s, size_t size, const char *file, int line)
+{
+    const char *p;
+    size_t len;
+    char *copy;
+
+    /* Don't assume that the source string is nul-terminated. */
+    for (p = s; (size_t)(p - s) < size && *p != '\0'; p++)
+        ;
+    len = (size_t)(p - s);
+    copy = (char *) malloc(len + 1);
+    if (copy == NULL)
+        sysdie("failed to strndup %lu bytes at %s line %d",
+               (unsigned long) len, file, line);
+    memcpy(copy, s, len);
+    copy[len] = '\0';
+    return copy;
+}
+
+
+/*
+ * Form a new string by concatenating multiple strings.  The arguments must be
+ * terminated by (const char *) 0.
+ *
+ * This function only exists because we can't assume asprintf.  We can't
+ * simulate asprintf with snprintf because we're only assuming SUSv3, which
+ * does not require that snprintf with a NULL buffer return the required
+ * length.  When those constraints are relaxed, this should be ripped out and
+ * replaced with asprintf or a more trivial replacement with snprintf.
+ */
+static char *
+concat(const char *first, ...)
+{
+    va_list args;
+    char *result;
+    const char *string;
+    size_t offset;
+    size_t length = 0;
+
+    /*
+     * Find the total memory required.  Ensure we don't overflow length.  We
+     * aren't guaranteed to have SIZE_MAX, so use UINT_MAX as an acceptable
+     * substitute (see the x_nrealloc comments).
+     */
+    va_start(args, first);
+    for (string = first; string != NULL; string = va_arg(args, const char *)) {
+        if (length >= UINT_MAX - strlen(string)) {
+            errno = EINVAL;
+            sysdie("strings too long in concat");
+        }
+        length += strlen(string);
+    }
+    va_end(args);
+    length++;
+
+    /* Create the string. */
+    result = xmalloc(length);
+    va_start(args, first);
+    offset = 0;
+    for (string = first; string != NULL; string = va_arg(args, const char *)) {
+        memcpy(result + offset, string, strlen(string));
+        offset += strlen(string);
+    }
+    va_end(args);
+    result[offset] = '\0';
+    return result;
 }
 
 
@@ -278,7 +504,7 @@
 static double
 tv_seconds(const struct timeval *tv)
 {
-    return difftime(tv->tv_sec, 0) + tv->tv_usec * 1e-6;
+    return difftime(tv->tv_sec, 0) + (double) tv->tv_usec * 1e-6;
 }
 
 
@@ -309,7 +535,20 @@
 static const char *
 skip_whitespace(const char *p)
 {
-    while (isspace((unsigned char)(*p)))
+    while (isspace((unsigned char) (*p)))
+        p++;
+    return p;
+}
+
+
+/*
+ * Given a pointer to a string, skip any non-whitespace characters and return
+ * a pointer to the first whitespace character, or to the end of the string.
+ */
+static const char *
+skip_non_whitespace(const char *p)
+{
+    while (*p != '\0' && !isspace((unsigned char) (*p)))
         p++;
     return p;
 }
@@ -321,38 +560,65 @@
  * argument.  Returns the PID of the new process.  Errors are fatal.
  */
 static pid_t
-test_start(const char *path, int *fd)
+test_start(char *const *command, int *fd)
 {
-    int fds[2], errfd;
+    int fds[2], infd, errfd;
     pid_t child;
 
+    /* Create a pipe used to capture the output from the test program. */
     if (pipe(fds) == -1) {
         puts("ABORTED");
         fflush(stdout);
         sysdie("can't create pipe");
     }
+
+    /* Fork a child process, massage the file descriptors, and exec. */
     child = fork();
-    if (child == (pid_t) -1) {
+    switch (child) {
+    case -1:
         puts("ABORTED");
         fflush(stdout);
         sysdie("can't fork");
-    } else if (child == 0) {
-        /* In child.  Set up our stdout and stderr. */
+
+    /* In the child.  Set up our standard output. */
+    case 0:
+        close(fds[0]);
+        close(STDOUT_FILENO);
+        if (dup2(fds[1], STDOUT_FILENO) < 0)
+            _exit(CHILDERR_DUP);
+        close(fds[1]);
+
+        /* Point standard input at /dev/null. */
+        close(STDIN_FILENO);
+        infd = open("/dev/null", O_RDONLY);
+        if (infd < 0)
+            _exit(CHILDERR_STDIN);
+        if (infd != STDIN_FILENO) {
+            if (dup2(infd, STDIN_FILENO) < 0)
+                _exit(CHILDERR_DUP);
+            close(infd);
+        }
+
+        /* Point standard error at /dev/null. */
+        close(STDERR_FILENO);
         errfd = open("/dev/null", O_WRONLY);
         if (errfd < 0)
             _exit(CHILDERR_STDERR);
-        if (dup2(errfd, 2) == -1)
-            _exit(CHILDERR_DUP);
-        close(fds[0]);
-        if (dup2(fds[1], 1) == -1)
-            _exit(CHILDERR_DUP);
+        if (errfd != STDERR_FILENO) {
+            if (dup2(errfd, STDERR_FILENO) < 0)
+                _exit(CHILDERR_DUP);
+            close(errfd);
+        }
 
         /* Now, exec our process. */
-        if (execl(path, path, (char *) 0) == -1)
+        if (execv(command[0], command) == -1)
             _exit(CHILDERR_EXEC);
-    } else {
-        /* In parent.  Close the extra file descriptor. */
+        break;
+
+    /* In parent.  Close the extra file descriptor. */
+    default:
         close(fds[1]);
+        break;
     }
     *fd = fds[0];
     return child;
@@ -380,15 +646,63 @@
 
 
 /*
+ * Allocate or resize the array of test results to be large enough to contain
+ * the test number in.
+ */
+static void
+resize_results(struct testset *ts, unsigned long n)
+{
+    unsigned long i;
+    size_t s;
+
+    /* If there's already enough space, return quickly. */
+    if (n <= ts->allocated)
+        return;
+
+    /*
+     * If no space has been allocated, do the initial allocation.  Otherwise,
+     * resize.  Start with 32 test cases and then add 1024 with each resize to
+     * try to reduce the number of reallocations.
+     */
+    if (ts->allocated == 0) {
+        s = (n > 32) ? n : 32;
+        ts->results = xcalloc(s, enum test_status);
+    } else {
+        s = (n > ts->allocated + 1024) ? n : ts->allocated + 1024;
+        ts->results = xreallocarray(ts->results, s, enum test_status);
+    }
+
+    /* Set the results for the newly-allocated test array. */
+    for (i = ts->allocated; i < s; i++)
+        ts->results[i] = TEST_INVALID;
+    ts->allocated = s;
+}
+
+
+/*
+ * Report an invalid test number and set the appropriate flags.  Pulled into a
+ * separate function since we do this in several places.
+ */
+static void
+invalid_test_number(struct testset *ts, long n, enum test_verbose verbose)
+{
+    if (!verbose)
+        test_backspace(ts);
+    printf("ABORTED (invalid test number %ld)\n", n);
+    ts->aborted = 1;
+    ts->reported = 1;
+}
+
+
+/*
  * Read the plan line of test output, which should contain the range of test
  * numbers.  We may initialize the testset structure here if we haven't yet
  * seen a test.  Return true if initialization succeeded and the test should
  * continue, false otherwise.
  */
 static int
-test_plan(const char *line, struct testset *ts)
+test_plan(const char *line, struct testset *ts, enum test_verbose verbose)
 {
-    unsigned long i;
     long n;
 
     /*
@@ -401,12 +715,14 @@
         line += 3;
 
     /*
-     * Get the count, check it for validity, and initialize the struct.  If we
-     * have something of the form "1..0 # skip foo", the whole file was
+     * Get the count and check it for validity.
+     *
+     * If we have something of the form "1..0 # skip foo", the whole file was
      * skipped; record that.  If we do skip the whole file, zero out all of
-     * our statistics, since they're no longer relevant.  strtol is called
-     * with a second argument to advance the line pointer past the count to
-     * make it simpler to detect the # skip case.
+     * our statistics, since they're no longer relevant.
+     *
+     * strtol is called with a second argument to advance the line pointer
+     * past the count to make it simpler to detect the # skip case.
      */
     n = strtol(line, (char **) &line, 10);
     if (n == 0) {
@@ -435,29 +751,27 @@
         ts->reported = 1;
         return 0;
     }
-    if (ts->plan == PLAN_INIT && ts->allocated == 0) {
-        ts->count = n;
-        ts->allocated = n;
-        ts->plan = PLAN_FIRST;
-        ts->results = xmalloc(ts->count * sizeof(enum test_status));
-        for (i = 0; i < ts->count; i++)
-            ts->results[i] = TEST_INVALID;
-    } else if (ts->plan == PLAN_PENDING) {
-        if ((unsigned long) n < ts->count) {
-            printf("ABORTED (invalid test number %lu)\n", ts->count);
-            ts->aborted = 1;
-            ts->reported = 1;
-            return 0;
-        }
-        ts->count = n;
-        if ((unsigned long) n > ts->allocated) {
-            ts->results = xrealloc(ts->results, n * sizeof(enum test_status));
-            for (i = ts->allocated; i < ts->count; i++)
-                ts->results[i] = TEST_INVALID;
-            ts->allocated = n;
-        }
-        ts->plan = PLAN_FINAL;
+
+    /*
+     * If we are doing lazy planning, check the plan against the largest test
+     * number that we saw and fail now if we saw a check outside the plan
+     * range.
+     */
+    if (ts->plan == PLAN_PENDING && (unsigned long) n < ts->count) {
+        invalid_test_number(ts, (long) ts->count, verbose);
+        return 0;
     }
+
+    /*
+     * Otherwise, allocated or resize the results if needed and update count,
+     * and then record that we've seen a plan.
+     */
+    resize_results(ts, (unsigned long) n);
+    ts->count = (unsigned long) n;
+    if (ts->plan == PLAN_INIT)
+        ts->plan = PLAN_FIRST;
+    else if (ts->plan == PLAN_PENDING)
+        ts->plan = PLAN_FINAL;
     return 1;
 }
 
@@ -469,13 +783,13 @@
  * reported status.
  */
 static void
-test_checkline(const char *line, struct testset *ts)
+test_checkline(const char *line, struct testset *ts, enum test_verbose verbose)
 {
     enum test_status status = TEST_PASS;
     const char *bail;
     char *end;
     long number;
-    unsigned long i, current;
+    unsigned long current;
     int outlen;
 
     /* Before anything, check for a test abort. */
@@ -488,7 +802,8 @@
             length = strlen(bail);
             if (bail[length - 1] == '\n')
                 length--;
-            test_backspace(ts);
+            if (!verbose)
+                test_backspace(ts);
             printf("ABORTED (%.*s)\n", (int) length, bail);
             ts->reported = 1;
         }
@@ -508,14 +823,16 @@
         return;
 
     /* If we haven't yet seen a plan, look for one. */
-    if (ts->plan == PLAN_INIT && isdigit((unsigned char)(*line))) {
-        if (!test_plan(line, ts))
+    if (ts->plan == PLAN_INIT && isdigit((unsigned char) (*line))) {
+        if (!test_plan(line, ts, verbose))
             return;
     } else if (strncmp(line, "1..", 3) == 0) {
         if (ts->plan == PLAN_PENDING) {
-            if (!test_plan(line, ts))
+            if (!test_plan(line, ts, verbose))
                 return;
         } else {
+            if (!verbose)
+                test_backspace(ts);
             puts("ABORTED (multiple plans)");
             ts->aborted = 1;
             ts->reported = 1;
@@ -534,39 +851,30 @@
     errno = 0;
     number = strtol(line, &end, 10);
     if (errno != 0 || end == line)
-        number = ts->current + 1;
-    current = number;
-    if (number <= 0 || (current > ts->count && ts->plan == PLAN_FIRST)) {
-        test_backspace(ts);
-        printf("ABORTED (invalid test number %lu)\n", current);
-        ts->aborted = 1;
-        ts->reported = 1;
+        current = ts->current + 1;
+    else if (number <= 0) {
+        invalid_test_number(ts, number, verbose);
+        return;
+    } else
+        current = (unsigned long) number;
+    if (current > ts->count && ts->plan == PLAN_FIRST) {
+        invalid_test_number(ts, (long) current, verbose);
         return;
     }
 
     /* We have a valid test result.  Tweak the results array if needed. */
     if (ts->plan == PLAN_INIT || ts->plan == PLAN_PENDING) {
         ts->plan = PLAN_PENDING;
+        resize_results(ts, current);
         if (current > ts->count)
             ts->count = current;
-        if (current > ts->allocated) {
-            unsigned long n;
-
-            n = (ts->allocated == 0) ? 32 : ts->allocated * 2;
-            if (n < current)
-                n = current;
-            ts->results = xrealloc(ts->results, n * sizeof(enum test_status));
-            for (i = ts->allocated; i < n; i++)
-                ts->results[i] = TEST_INVALID;
-            ts->allocated = n;
-        }
     }
 
     /*
      * Handle directives.  We should probably do something more interesting
      * with unexpected passes of todo tests.
      */
-    while (isdigit((unsigned char)(*line)))
+    while (isdigit((unsigned char) (*line)))
         line++;
     line = skip_whitespace(line);
     if (*line == '#') {
@@ -579,7 +887,8 @@
 
     /* Make sure that the test number is in range and not a duplicate. */
     if (ts->results[current - 1] != TEST_INVALID) {
-        test_backspace(ts);
+        if (!verbose)
+            test_backspace(ts);
         printf("ABORTED (duplicate test number %lu)\n", current);
         ts->aborted = 1;
         ts->reported = 1;
@@ -588,17 +897,27 @@
 
     /* Good results.  Increment our various counters. */
     switch (status) {
-        case TEST_PASS: ts->passed++;   break;
-        case TEST_FAIL: ts->failed++;   break;
-        case TEST_SKIP: ts->skipped++;  break;
-        case TEST_INVALID:              break;
+    case TEST_PASS:
+        ts->passed++;
+        break;
+    case TEST_FAIL:
+        ts->failed++;
+        break;
+    case TEST_SKIP:
+        ts->skipped++;
+        break;
+    case TEST_INVALID:
+        break;
     }
     ts->current = current;
     ts->results[current - 1] = status;
-    test_backspace(ts);
-    if (isatty(STDOUT_FILENO)) {
-        outlen = printf("%lu/%lu", current, ts->count);
-        ts->length = (outlen >= 0) ? outlen : 0;
+    if (!verbose && isatty(STDOUT_FILENO)) {
+        test_backspace(ts);
+        if (ts->plan == PLAN_PENDING)
+            outlen = printf("%lu/?", current);
+        else
+            outlen = printf("%lu/%lu", current, ts->count);
+        ts->length = (outlen >= 0) ? (unsigned int) outlen : 0;
         fflush(stdout);
     }
 }
@@ -614,7 +933,7 @@
  * disable this).
  */
 static unsigned int
-test_print_range(unsigned long first, unsigned long last, unsigned int chars,
+test_print_range(unsigned long first, unsigned long last, unsigned long chars,
                  unsigned int limit)
 {
     unsigned int needed = 0;
@@ -754,6 +1073,7 @@
             if (!ts->reported)
                 puts("ABORTED (execution failed -- not found?)");
             break;
+        case CHILDERR_STDIN:
         case CHILDERR_STDERR:
             if (!ts->reported)
                 puts("ABORTED (can't open /dev/null)");
@@ -783,7 +1103,7 @@
  * false otherwise.
  */
 static int
-test_run(struct testset *ts)
+test_run(struct testset *ts, enum test_verbose verbose)
 {
     pid_t testpid, child;
     int outfd, status;
@@ -792,7 +1112,7 @@
     char buffer[BUFSIZ];
 
     /* Run the test program. */
-    testpid = test_start(ts->path, &outfd);
+    testpid = test_start(ts->command, &outfd);
     output = fdopen(outfd, "r");
     if (!output) {
         puts("ABORTED");
@@ -800,12 +1120,19 @@
         sysdie("fdopen failed");
     }
 
-    /* Pass each line of output to test_checkline(). */
-    while (!ts->aborted && fgets(buffer, sizeof(buffer), output))
-        test_checkline(buffer, ts);
+    /*
+     * Pass each line of output to test_checkline(), and print the line if
+     * verbosity is requested.
+     */
+    while (!ts->aborted && fgets(buffer, sizeof(buffer), output)) {
+        if (verbose)
+            printf("%s", buffer);
+        test_checkline(buffer, ts, verbose);
+    }
     if (ferror(output) || ts->plan == PLAN_INIT)
         ts->aborted = 1;
-    test_backspace(ts);
+    if (!verbose)
+        test_backspace(ts);
 
     /*
      * Consume the rest of the test output, close the output descriptor,
@@ -813,7 +1140,8 @@
      * for eventual output.
      */
     while (fgets(buffer, sizeof(buffer), output))
-        ;
+        if (verbose)
+            printf("%s", buffer);
     fclose(output);
     child = waitpid(testpid, &ts->status, 0);
     if (child == (pid_t) -1) {
@@ -846,6 +1174,7 @@
     struct testset *ts;
     unsigned int chars;
     unsigned long i, first, last, total;
+    double failed;
 
     puts(header);
 
@@ -854,8 +1183,9 @@
     for (; fails; fails = fails->next) {
         ts = fails->ts;
         total = ts->count - ts->skipped;
+        failed = (double) ts->failed;
         printf("%-26.26s %4lu/%-4lu %3.0f%% %4lu ", ts->file, ts->failed,
-               total, total ? (ts->failed * 100.0) / total : 0,
+               total, total ? (failed * 100.0) / (double) total : 0,
                ts->skipped);
         if (WIFEXITED(ts->status))
             printf("%4d  ", WEXITSTATUS(ts->status));
@@ -883,13 +1213,26 @@
         if (first != 0)
             test_print_range(first, last, chars, 19);
         putchar('\n');
-        free(ts->file);
-        free(ts->path);
-        free(ts->results);
-        if (ts->reason != NULL)
-            free(ts->reason);
-        free(ts);
     }
+}
+
+
+/*
+ * Check whether a given file path is a valid test.  Currently, this checks
+ * whether it is executable and is a regular file.  Returns true or false.
+ */
+static int
+is_valid_test(const char *path)
+{
+    struct stat st;
+
+    if (access(path, X_OK) < 0)
+        return 0;
+    if (stat(path, &st) < 0)
+        return 0;
+    if (!S_ISREG(st.st_mode))
+        return 0;
+    return 1;
 }
 
 
@@ -898,94 +1241,297 @@
  * and build directories, find the test.  We try first relative to the current
  * directory, then in the build directory (if not NULL), then in the source
  * directory.  In each of those directories, we first try a "-t" extension and
- * then a ".t" extension.  When we find an executable program, we fill in the
- * path member of the testset struct.  If none of those paths are executable,
- * just fill in the name of the test with "-t" appended.
+ * then a ".t" extension.  When we find an executable program, we return the
+ * path to that program.  If none of those paths are executable, just fill in
+ * the name of the test as is.
  *
  * The caller is responsible for freeing the path member of the testset
  * struct.
  */
-static void
-find_test(const char *name, struct testset *ts, const char *source,
-          const char *build)
+static char *
+find_test(const char *name, const char *source, const char *build)
 {
-    char *path;
-    const char *bases[4];
-    unsigned int i;
+    char *path = NULL;
+    const char *bases[3], *suffix, *base;
+    unsigned int i, j;
+    const char *suffixes[3] = {"-t", ".t", ""};
 
+    /* Possible base directories. */
     bases[0] = ".";
     bases[1] = build;
     bases[2] = source;
-    bases[3] = NULL;
 
-    for (i = 0; i < 3; i++) {
-        if (bases[i] == NULL)
-            continue;
-        path = xmalloc(strlen(bases[i]) + strlen(name) + 4);
-        sprintf(path, "%s/%s-t", bases[i], name);
-        if (access(path, X_OK) != 0)
-            path[strlen(path) - 2] = '.';
-        if (access(path, X_OK) == 0)
-            break;
-        free(path);
-        path = NULL;
+    /* Try each suffix with each base. */
+    for (i = 0; i < ARRAY_SIZE(suffixes); i++) {
+        suffix = suffixes[i];
+        for (j = 0; j < ARRAY_SIZE(bases); j++) {
+            base = bases[j];
+            if (base == NULL)
+                continue;
+            path = concat(base, "/", name, suffix, (const char *) 0);
+            if (is_valid_test(path))
+                return path;
+            free(path);
+            path = NULL;
+        }
     }
-    if (path == NULL) {
-        path = xmalloc(strlen(name) + 3);
-        sprintf(path, "%s-t", name);
-    }
-    ts->path = path;
+    if (path == NULL)
+        path = xstrdup(name);
+    return path;
 }
 
 
 /*
- * Run a batch of tests from a given file listing each test on a line by
- * itself.  Takes two additional parameters: the root of the source directory
- * and the root of the build directory.  Test programs will be first searched
- * for in the current directory, then the build directory, then the source
- * directory.  The file must be rewindable.  Returns true iff all tests
- * passed.
+ * Parse a single line of a test list and store the test name and command to
+ * execute it in the given testset struct.
+ *
+ * Normally, each line is just the name of the test, which is located in the
+ * test directory and turned into a command to run.  However, each line may
+ * have whitespace-separated options, which change the command that's run.
+ * Current supported options are:
+ *
+ * valgrind
+ *     Run the test under valgrind if C_TAP_VALGRIND is set.  The contents
+ *     of that environment variable are taken as the valgrind command (with
+ *     options) to run.  The command is parsed with a simple split on
+ *     whitespace and no quoting is supported.
+ *
+ * libtool
+ *     If running under valgrind, use libtool to invoke valgrind.  This avoids
+ *     running valgrind on the wrapper shell script generated by libtool.  If
+ *     set, C_TAP_LIBTOOL must be set to the full path to the libtool program
+ *     to use to run valgrind and thus the test.  Ignored if the test isn't
+ *     being run under valgrind.
+ */
+static void
+parse_test_list_line(const char *line, struct testset *ts, const char *source,
+                     const char *build)
+{
+    const char *p, *end, *option, *libtool;
+    const char *valgrind = NULL;
+    unsigned int use_libtool = 0;
+    unsigned int use_valgrind = 0;
+    size_t len, i;
+
+    /* Determine the name of the test. */
+    p = skip_non_whitespace(line);
+    ts->file = xstrndup(line, p - line);
+
+    /* Check if any test options are set. */
+    p = skip_whitespace(p);
+    while (*p != '\0') {
+        end = skip_non_whitespace(p);
+        if (strncmp(p, "libtool", end - p) == 0) {
+            use_libtool = 1;
+        } else if (strncmp(p, "valgrind", end - p) == 0) {
+            valgrind = getenv("C_TAP_VALGRIND");
+            use_valgrind = (valgrind != NULL);
+        } else {
+            option = xstrndup(p, end - p);
+            die("unknown test list option %s", option);
+        }
+        p = skip_whitespace(end);
+    }
+
+    /* Construct the argv to run the test.  First, find the length. */
+    len = 1;
+    if (use_valgrind && valgrind != NULL) {
+        p = skip_whitespace(valgrind);
+        while (*p != '\0') {
+            len++;
+            p = skip_whitespace(skip_non_whitespace(p));
+        }
+        if (use_libtool)
+            len += 2;
+    }
+
+    /* Now, build the command. */
+    ts->command = xcalloc(len + 1, char *);
+    i = 0;
+    if (use_valgrind && valgrind != NULL) {
+        if (use_libtool) {
+            libtool = getenv("C_TAP_LIBTOOL");
+            if (libtool == NULL)
+                die("valgrind with libtool requested, but C_TAP_LIBTOOL is not"
+                    " set");
+            ts->command[i++] = xstrdup(libtool);
+            ts->command[i++] = xstrdup("--mode=execute");
+        }
+        p = skip_whitespace(valgrind);
+        while (*p != '\0') {
+            end = skip_non_whitespace(p);
+            ts->command[i++] = xstrndup(p, end - p);
+            p = skip_whitespace(end);
+        }
+    }
+    if (i != len - 1)
+        die("internal error while constructing command line");
+    ts->command[i++] = find_test(ts->file, source, build);
+    ts->command[i] = NULL;
+}
+
+
+/*
+ * Read a list of tests from a file, returning the list of tests as a struct
+ * testlist, or NULL if there were no tests (such as a file containing only
+ * comments).  Reports an error to standard error and exits if the list of
+ * tests cannot be read.
+ */
+static struct testlist *
+read_test_list(const char *filename, const char *source, const char *build)
+{
+    FILE *file;
+    unsigned int line;
+    size_t length;
+    char buffer[BUFSIZ];
+    const char *start;
+    struct testlist *listhead, *current;
+
+    /* Create the initial container list that will hold our results. */
+    listhead = xcalloc(1, struct testlist);
+    current = NULL;
+
+    /*
+     * Open our file of tests to run and read it line by line, creating a new
+     * struct testlist and struct testset for each line.
+     */
+    file = fopen(filename, "r");
+    if (file == NULL)
+        sysdie("can't open %s", filename);
+    line = 0;
+    while (fgets(buffer, sizeof(buffer), file)) {
+        line++;
+        length = strlen(buffer) - 1;
+        if (buffer[length] != '\n') {
+            fprintf(stderr, "%s:%u: line too long\n", filename, line);
+            exit(1);
+        }
+        buffer[length] = '\0';
+
+        /* Skip comments, leading spaces, and blank lines. */
+        start = skip_whitespace(buffer);
+        if (strlen(start) == 0)
+            continue;
+        if (start[0] == '#')
+            continue;
+
+        /* Allocate the new testset structure. */
+        if (current == NULL)
+            current = listhead;
+        else {
+            current->next = xcalloc(1, struct testlist);
+            current = current->next;
+        }
+        current->ts = xcalloc(1, struct testset);
+        current->ts->plan = PLAN_INIT;
+
+        /* Parse the line and store the results in the testset struct. */
+        parse_test_list_line(start, current->ts, source, build);
+    }
+    fclose(file);
+
+    /* If there were no tests, current is still NULL. */
+    if (current == NULL) {
+        free(listhead);
+        return NULL;
+    }
+
+    /* Return the results. */
+    return listhead;
+}
+
+
+/*
+ * Build a list of tests from command line arguments.  Takes the argv and argc
+ * representing the command line arguments and returns a newly allocated test
+ * list, or NULL if there were no tests.  The caller is responsible for
+ * freeing.
+ */
+static struct testlist *
+build_test_list(char *argv[], int argc, const char *source, const char *build)
+{
+    int i;
+    struct testlist *listhead, *current;
+
+    /* Create the initial container list that will hold our results. */
+    listhead = xcalloc(1, struct testlist);
+    current = NULL;
+
+    /* Walk the list of arguments and create test sets for them. */
+    for (i = 0; i < argc; i++) {
+        if (current == NULL)
+            current = listhead;
+        else {
+            current->next = xcalloc(1, struct testlist);
+            current = current->next;
+        }
+        current->ts = xcalloc(1, struct testset);
+        current->ts->plan = PLAN_INIT;
+        current->ts->file = xstrdup(argv[i]);
+        current->ts->command = xcalloc(2, char *);
+        current->ts->command[0] = find_test(current->ts->file, source, build);
+        current->ts->command[1] = NULL;
+    }
+
+    /* If there were no tests, current is still NULL. */
+    if (current == NULL) {
+        free(listhead);
+        return NULL;
+    }
+
+    /* Return the results. */
+    return listhead;
+}
+
+
+/* Free a struct testset. */
+static void
+free_testset(struct testset *ts)
+{
+    size_t i;
+
+    free(ts->file);
+    for (i = 0; ts->command[i] != NULL; i++)
+        free(ts->command[i]);
+    free(ts->command);
+    free(ts->results);
+    free(ts->reason);
+    free(ts);
+}
+
+
+/*
+ * Run a batch of tests.  Takes two additional parameters: the root of the
+ * source directory and the root of the build directory.  Test programs will
+ * be first searched for in the current directory, then the build directory,
+ * then the source directory.  Returns true iff all tests passed, and always
+ * frees the test list that's passed in.
  */
 static int
-test_batch(const char *testlist, const char *source, const char *build)
+test_batch(struct testlist *tests, enum test_verbose verbose)
 {
-    FILE *tests;
-    unsigned int length, i;
-    unsigned int longest = 0;
-    char buffer[BUFSIZ];
-    unsigned int line;
-    struct testset ts, *tmp;
+    size_t length, i;
+    size_t longest = 0;
+    unsigned int count = 0;
+    struct testset *ts;
     struct timeval start, end;
     struct rusage stats;
     struct testlist *failhead = NULL;
     struct testlist *failtail = NULL;
-    struct testlist *next;
+    struct testlist *current, *next;
+    int succeeded;
     unsigned long total = 0;
     unsigned long passed = 0;
     unsigned long skipped = 0;
     unsigned long failed = 0;
     unsigned long aborted = 0;
 
-    /*
-     * Open our file of tests to run and scan it, checking for lines that
-     * are too long and searching for the longest line.
-     */
-    tests = fopen(testlist, "r");
-    if (!tests)
-        sysdie("can't open %s", testlist);
-    line = 0;
-    while (fgets(buffer, sizeof(buffer), tests)) {
-        line++;
-        length = strlen(buffer) - 1;
-        if (buffer[length] != '\n') {
-            fprintf(stderr, "%s:%u: line too long\n", testlist, line);
-            exit(1);
-        }
+    /* Walk the list of tests to find the longest name. */
+    for (current = tests; current != NULL; current = current->next) {
+        length = strlen(current->ts->file);
         if (length > longest)
             longest = length;
     }
-    if (fseek(tests, 0, SEEK_SET) == -1)
-        sysdie("can't rewind %s", testlist);
 
     /*
      * Add two to longest and round up to the nearest tab stop.  This is how
@@ -998,64 +1544,54 @@
     /* Start the wall clock timer. */
     gettimeofday(&start, NULL);
 
-    /*
-     * Now, plow through our tests again, running each one.  Check line
-     * length again out of paranoia.
-     */
-    line = 0;
-    while (fgets(buffer, sizeof(buffer), tests)) {
-        line++;
-        length = strlen(buffer) - 1;
-        if (buffer[length] != '\n') {
-            fprintf(stderr, "%s:%u: line too long\n", testlist, line);
-            exit(1);
-        }
-        buffer[length] = '\0';
-        fputs(buffer, stdout);
-        for (i = length; i < longest; i++)
-            putchar('.');
+    /* Now, plow through our tests again, running each one. */
+    for (current = tests; current != NULL; current = current->next) {
+        ts = current->ts;
+
+        /* Print out the name of the test file. */
+        fputs(ts->file, stdout);
+        if (verbose)
+            fputs("\n\n", stdout);
+        else
+            for (i = strlen(ts->file); i < longest; i++)
+                putchar('.');
         if (isatty(STDOUT_FILENO))
             fflush(stdout);
-        memset(&ts, 0, sizeof(ts));
-        ts.plan = PLAN_INIT;
-        ts.file = xstrdup(buffer);
-        find_test(buffer, &ts, source, build);
-        ts.reason = NULL;
-        if (test_run(&ts)) {
-            free(ts.file);
-            free(ts.path);
-            free(ts.results);
-            if (ts.reason != NULL)
-                free(ts.reason);
-        } else {
-            tmp = xmalloc(sizeof(struct testset));
-            memcpy(tmp, &ts, sizeof(struct testset));
-            if (!failhead) {
-                failhead = xmalloc(sizeof(struct testset));
-                failhead->ts = tmp;
-                failhead->next = NULL;
+
+        /* Run the test. */
+        succeeded = test_run(ts, verbose);
+        fflush(stdout);
+        if (verbose)
+            putchar('\n');
+
+        /* Record cumulative statistics. */
+        aborted += ts->aborted;
+        total += ts->count + ts->all_skipped;
+        passed += ts->passed;
+        skipped += ts->skipped + ts->all_skipped;
+        failed += ts->failed;
+        count++;
+
+        /* If the test fails, we shuffle it over to the fail list. */
+        if (!succeeded) {
+            if (failhead == NULL) {
+                failhead = xcalloc(1, struct testlist);
                 failtail = failhead;
             } else {
-                failtail->next = xmalloc(sizeof(struct testset));
+                failtail->next = xcalloc(1, struct testlist);
                 failtail = failtail->next;
-                failtail->ts = tmp;
-                failtail->next = NULL;
             }
+            failtail->ts = ts;
+            failtail->next = NULL;
         }
-        aborted += ts.aborted;
-        total += ts.count + ts.all_skipped;
-        passed += ts.passed;
-        skipped += ts.skipped + ts.all_skipped;
-        failed += ts.failed;
     }
     total -= skipped;
-    fclose(tests);
 
     /* Stop the timer and get our child resource statistics. */
     gettimeofday(&end, NULL);
     getrusage(RUSAGE_CHILDREN, &stats);
 
-    /* Print out our final results. */
+    /* Summarize the failures and free the failure list. */
     if (failhead != NULL) {
         test_fail_summary(failhead);
         while (failhead != NULL) {
@@ -1064,6 +1600,16 @@
             failhead = next;
         }
     }
+
+    /* Free the memory used by the test lists. */
+    while (tests != NULL) {
+        next = tests->next;
+        free_testset(tests->ts);
+        free(tests);
+        tests = next;
+    }
+
+    /* Print out the final test summary. */
     putchar('\n');
     if (aborted != 0) {
         if (aborted == 1)
@@ -1071,12 +1617,11 @@
         else
             printf("Aborted %lu test sets", aborted);
         printf(", passed %lu/%lu tests", passed, total);
-    }
-    else if (failed == 0)
+    } else if (failed == 0)
         fputs("All tests successful", stdout);
     else
         printf("Failed %lu/%lu tests, %.2f%% okay", failed, total,
-               (total - failed) * 100.0 / total);
+               (double) (total - failed) * 100.0 / (double) total);
     if (skipped != 0) {
         if (skipped == 1)
             printf(", %lu test skipped", skipped);
@@ -1084,10 +1629,10 @@
             printf(", %lu tests skipped", skipped);
     }
     puts(".");
-    printf("Files=%u,  Tests=%lu", line, total);
+    printf("Files=%u,  Tests=%lu", count, total);
     printf(",  %.2f seconds", tv_diff(&end, &start));
-    printf(" (%.2f usr + %.2f sys = %.2f CPU)\n",
-           tv_seconds(&stats.ru_utime), tv_seconds(&stats.ru_stime),
+    printf(" (%.2f usr + %.2f sys = %.2f CPU)\n", tv_seconds(&stats.ru_utime),
+           tv_seconds(&stats.ru_stime),
            tv_sum(&stats.ru_utime, &stats.ru_stime));
     return (failed == 0 && aborted == 0);
 }
@@ -1100,18 +1645,18 @@
 static void
 test_single(const char *program, const char *source, const char *build)
 {
-    struct testset ts;
+    char *path;
 
-    memset(&ts, 0, sizeof(ts));
-    find_test(program, &ts, source, build);
-    if (execl(ts.path, ts.path, (char *) 0) == -1)
-        sysdie("cannot exec %s", ts.path);
+    path = find_test(program, source, build);
+    if (execl(path, path, (char *) 0) == -1)
+        sysdie("cannot exec %s", path);
 }
 
 
 /*
- * Main routine.  Set the SOURCE and BUILD environment variables and then,
- * given a file listing tests, run each test listed.
+ * Main routine.  Set the C_TAP_SOURCE, C_TAP_BUILD, SOURCE, and BUILD
+ * environment variables and then, given a file listing tests, run each test
+ * listed.
  */
 int
 main(int argc, char *argv[])
@@ -1119,20 +1664,29 @@
     int option;
     int status = 0;
     int single = 0;
+    enum test_verbose verbose = CONCISE;
+    char *c_tap_source_env = NULL;
+    char *c_tap_build_env = NULL;
     char *source_env = NULL;
     char *build_env = NULL;
-    const char *list;
-    const char *source = SOURCE;
-    const char *build = BUILD;
+    const char *program;
+    const char *shortlist;
+    const char *list = NULL;
+    const char *source = C_TAP_SOURCE;
+    const char *build = C_TAP_BUILD;
+    struct testlist *tests;
 
-    while ((option = getopt(argc, argv, "b:hos:")) != EOF) {
+    program = argv[0];
+    while ((option = getopt(argc, argv, "b:hl:os:v")) != EOF) {
         switch (option) {
         case 'b':
             build = optarg;
             break;
         case 'h':
-            printf(usage_message, argv[0], argv[0]);
+            printf(usage_message, program, program, program, usage_extra);
             exit(0);
+        case 'l':
+            list = optarg;
             break;
         case 'o':
             single = 1;
@@ -1140,49 +1694,77 @@
         case 's':
             source = optarg;
             break;
+        case 'v':
+            verbose = VERBOSE;
+            break;
         default:
             exit(1);
         }
     }
-    if (argc - optind != 1) {
-        fprintf(stderr, usage_message, argv[0], argv[0]);
+    argv += optind;
+    argc -= optind;
+    if ((list == NULL && argc < 1) || (list != NULL && argc > 0)) {
+        fprintf(stderr, usage_message, program, program, program, usage_extra);
         exit(1);
     }
-    argc -= optind;
-    argv += optind;
 
+    /*
+     * If C_TAP_VERBOSE is set in the environment, that also turns on verbose
+     * mode.
+     */
+    if (getenv("C_TAP_VERBOSE") != NULL)
+        verbose = VERBOSE;
+
+    /*
+     * Set C_TAP_SOURCE and C_TAP_BUILD environment variables.  Also set
+     * SOURCE and BUILD for backward compatibility, although we're trying to
+     * migrate to the ones with a C_TAP_* prefix.
+     */
     if (source != NULL) {
-        source_env = xmalloc(strlen("SOURCE=") + strlen(source) + 1);
-        sprintf(source_env, "SOURCE=%s", source);
+        c_tap_source_env = concat("C_TAP_SOURCE=", source, (const char *) 0);
+        if (putenv(c_tap_source_env) != 0)
+            sysdie("cannot set C_TAP_SOURCE in the environment");
+        source_env = concat("SOURCE=", source, (const char *) 0);
         if (putenv(source_env) != 0)
             sysdie("cannot set SOURCE in the environment");
     }
     if (build != NULL) {
-        build_env = xmalloc(strlen("BUILD=") + strlen(build) + 1);
-        sprintf(build_env, "BUILD=%s", build);
+        c_tap_build_env = concat("C_TAP_BUILD=", build, (const char *) 0);
+        if (putenv(c_tap_build_env) != 0)
+            sysdie("cannot set C_TAP_BUILD in the environment");
+        build_env = concat("BUILD=", build, (const char *) 0);
         if (putenv(build_env) != 0)
             sysdie("cannot set BUILD in the environment");
     }
 
+    /* Run the tests as instructed. */
     if (single)
         test_single(argv[0], source, build);
-    else {
-        list = strrchr(argv[0], '/');
-        if (list == NULL)
-            list = argv[0];
+    else if (list != NULL) {
+        shortlist = strrchr(list, '/');
+        if (shortlist == NULL)
+            shortlist = list;
         else
-            list++;
-        printf(banner, list);
-        status = test_batch(argv[0], source, build) ? 0 : 1;
+            shortlist++;
+        printf(banner, shortlist);
+        tests = read_test_list(list, source, build);
+        status = test_batch(tests, verbose) ? 0 : 1;
+    } else {
+        tests = build_test_list(argv, argc, source, build);
+        status = test_batch(tests, verbose) ? 0 : 1;
     }
 
-    /* For valgrind cleanliness. */
+    /* For valgrind cleanliness, free all our memory. */
     if (source_env != NULL) {
+        putenv((char *) "C_TAP_SOURCE=");
         putenv((char *) "SOURCE=");
+        free(c_tap_source_env);
         free(source_env);
     }
     if (build_env != NULL) {
+        putenv((char *) "C_TAP_BUILD=");
         putenv((char *) "BUILD=");
+        free(c_tap_build_env);
         free(build_env);
     }
     exit(status);
diff --git a/src/external/c-tap-harness/tests/tap/basic.c b/src/external/c-tap-harness/tests/tap/basic.c
index e8196fc..b5f42d0 100644
--- a/src/external/c-tap-harness/tests/tap/basic.c
+++ b/src/external/c-tap-harness/tests/tap/basic.c
@@ -10,10 +10,11 @@
  * up the TAP output format, or finding things in the test environment.
  *
  * This file is part of C TAP Harness.  The current version plus supporting
- * documentation is at <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ * documentation is at <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
  *
- * Copyright 2009, 2010, 2011, 2012 Russ Allbery <rra@stanford.edu>
- * Copyright 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2011, 2012
+ * Written by Russ Allbery <eagle@eyrie.org>
+ * Copyright 2009-2019 Russ Allbery <eagle@eyrie.org>
+ * Copyright 2001-2002, 2004-2008, 2011-2014
  *     The Board of Trustees of the Leland Stanford Junior University
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -33,17 +34,20 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
  */
 
 #include <errno.h>
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #ifdef _WIN32
-# include <direct.h>
+#    include <direct.h>
 #else
-# include <sys/stat.h>
+#    include <sys/stat.h>
 #endif
 #include <sys/types.h>
 #include <unistd.h>
@@ -52,13 +56,13 @@
 
 /* Windows provides mkdir and rmdir under different names. */
 #ifdef _WIN32
-# define mkdir(p, m) _mkdir(p)
-# define rmdir(p)    _rmdir(p)
+#    define mkdir(p, m) _mkdir(p)
+#    define rmdir(p)    _rmdir(p)
 #endif
 
 /*
  * The test count.  Always contains the number that will be used for the next
- * test status.
+ * test status.  This is exported to callers of the library.
  */
 unsigned long testnum = 1;
 
@@ -66,72 +70,324 @@
  * Status information stored so that we can give a test summary at the end of
  * the test case.  We store the planned final test and the count of failures.
  * We can get the highest test count from testnum.
- *
- * We also store the PID of the process that called plan() and only summarize
- * results when that process exits, so as to not misreport results in forked
- * processes.
- *
- * If _lazy is true, we're doing lazy planning and will print out the plan
- * based on the last test number at the end of testing.
  */
 static unsigned long _planned = 0;
-static unsigned long _failed  = 0;
+static unsigned long _failed = 0;
+
+/*
+ * Store the PID of the process that called plan() and only summarize
+ * results when that process exits, so as to not misreport results in forked
+ * processes.
+ */
 static pid_t _process = 0;
+
+/*
+ * If true, we're doing lazy planning and will print out the plan based on the
+ * last test number at the end of testing.
+ */
 static int _lazy = 0;
+
+/*
+ * If true, the test was aborted by calling bail().  Currently, this is only
+ * used to ensure that we pass a false value to any cleanup functions even if
+ * all tests to that point have passed.
+ */
+static int _aborted = 0;
+
+/*
+ * Registered cleanup functions.  These are stored as a linked list and run in
+ * registered order by finish when the test program exits.  Each function is
+ * passed a boolean value indicating whether all tests were successful.
+ */
+struct cleanup_func {
+    test_cleanup_func func;
+    test_cleanup_func_with_data func_with_data;
+    void *data;
+    struct cleanup_func *next;
+};
+static struct cleanup_func *cleanup_funcs = NULL;
+
+/*
+ * Registered diag files.  Any output found in these files will be printed out
+ * as if it were passed to diag() before any other output we do.  This allows
+ * background processes to log to a file and have that output interleaved with
+ * the test output.
+ */
+struct diag_file {
+    char *name;
+    FILE *file;
+    char *buffer;
+    size_t bufsize;
+    struct diag_file *next;
+};
+static struct diag_file *diag_files = NULL;
+
+/*
+ * Print a specified prefix and then the test description.  Handles turning
+ * the argument list into a va_args structure suitable for passing to
+ * print_desc, which has to be done in a macro.  Assumes that format is the
+ * argument immediately before the variadic arguments.
+ */
+#define PRINT_DESC(prefix, format)  \
+    do {                            \
+        if (format != NULL) {       \
+            va_list args;           \
+            printf("%s", prefix);   \
+            va_start(args, format); \
+            vprintf(format, args);  \
+            va_end(args);           \
+        }                           \
+    } while (0)
+
+
+/*
+ * Form a new string by concatenating multiple strings.  The arguments must be
+ * terminated by (const char *) 0.
+ *
+ * This function only exists because we can't assume asprintf.  We can't
+ * simulate asprintf with snprintf because we're only assuming SUSv3, which
+ * does not require that snprintf with a NULL buffer return the required
+ * length.  When those constraints are relaxed, this should be ripped out and
+ * replaced with asprintf or a more trivial replacement with snprintf.
+ */
+static char *
+concat(const char *first, ...)
+{
+    va_list args;
+    char *result;
+    const char *string;
+    size_t offset;
+    size_t length = 0;
+
+    /*
+     * Find the total memory required.  Ensure we don't overflow length.  See
+     * the comment for breallocarray for why we're using UINT_MAX here.
+     */
+    va_start(args, first);
+    for (string = first; string != NULL; string = va_arg(args, const char *)) {
+        if (length >= UINT_MAX - strlen(string))
+            bail("strings too long in concat");
+        length += strlen(string);
+    }
+    va_end(args);
+    length++;
+
+    /* Create the string. */
+    result = bcalloc_type(length, char);
+    va_start(args, first);
+    offset = 0;
+    for (string = first; string != NULL; string = va_arg(args, const char *)) {
+        memcpy(result + offset, string, strlen(string));
+        offset += strlen(string);
+    }
+    va_end(args);
+    result[offset] = '\0';
+    return result;
+}
+
+
+/*
+ * Helper function for check_diag_files to handle a single line in a diag
+ * file.
+ *
+ * The general scheme here used is as follows: read one line of output.  If we
+ * get NULL, check for an error.  If there was one, bail out of the test
+ * program; otherwise, return, and the enclosing loop will check for EOF.
+ *
+ * If we get some data, see if it ends in a newline.  If it doesn't end in a
+ * newline, we have one of two cases: our buffer isn't large enough, in which
+ * case we resize it and try again, or we have incomplete data in the file, in
+ * which case we rewind the file and will try again next time.
+ *
+ * Returns a boolean indicating whether the last line was incomplete.
+ */
+static int
+handle_diag_file_line(struct diag_file *file, fpos_t where)
+{
+    int size;
+    size_t length;
+
+    /* Read the next line from the file. */
+    size = file->bufsize > INT_MAX ? INT_MAX : (int) file->bufsize;
+    if (fgets(file->buffer, size, file->file) == NULL) {
+        if (ferror(file->file))
+            sysbail("cannot read from %s", file->name);
+        return 0;
+    }
+
+    /*
+     * See if the line ends in a newline.  If not, see which error case we
+     * have.
+     */
+    length = strlen(file->buffer);
+    if (file->buffer[length - 1] != '\n') {
+        int incomplete = 0;
+
+        /* Check whether we ran out of buffer space and resize if so. */
+        if (length < file->bufsize - 1)
+            incomplete = 1;
+        else {
+            file->bufsize += BUFSIZ;
+            file->buffer =
+                breallocarray_type(file->buffer, file->bufsize, char);
+        }
+
+        /*
+         * On either incomplete lines or too small of a buffer, rewind
+         * and read the file again (on the next pass, if incomplete).
+         * It's simpler than trying to double-buffer the file.
+         */
+        if (fsetpos(file->file, &where) < 0)
+            sysbail("cannot set position in %s", file->name);
+        return incomplete;
+    }
+
+    /* We saw a complete line.  Print it out. */
+    printf("# %s", file->buffer);
+    return 0;
+}
+
+
+/*
+ * Check all registered diag_files for any output.  We only print out the
+ * output if we see a complete line; otherwise, we wait for the next newline.
+ */
+static void
+check_diag_files(void)
+{
+    struct diag_file *file;
+    fpos_t where;
+    int incomplete;
+
+    /*
+     * Walk through each file and read each line of output available.
+     */
+    for (file = diag_files; file != NULL; file = file->next) {
+        clearerr(file->file);
+
+        /* Store the current position in case we have to rewind. */
+        if (fgetpos(file->file, &where) < 0)
+            sysbail("cannot get position in %s", file->name);
+
+        /* Continue until we get EOF or an incomplete line of data. */
+        incomplete = 0;
+        while (!feof(file->file) && !incomplete) {
+            incomplete = handle_diag_file_line(file, where);
+        }
+    }
+}
 
 
 /*
  * Our exit handler.  Called on completion of the test to report a summary of
  * results provided we're still in the original process.  This also handles
  * printing out the plan if we used plan_lazy(), although that's suppressed if
- * we never ran a test (due to an early bail, for example).
+ * we never ran a test (due to an early bail, for example), and running any
+ * registered cleanup functions.
  */
 static void
 finish(void)
 {
+    int success, primary;
+    struct cleanup_func *current;
     unsigned long highest = testnum - 1;
+    struct diag_file *file, *tmp;
 
-    if (_planned == 0 && !_lazy)
-        return;
-    fflush(stderr);
-    if (_process != 0 && getpid() == _process) {
-        if (_lazy && highest > 0) {
-            printf("1..%lu\n", highest);
-            _planned = highest;
-        }
-        if (_planned > highest)
-            printf("# Looks like you planned %lu test%s but only ran %lu\n",
-                   _planned, (_planned > 1 ? "s" : ""), highest);
-        else if (_planned < highest)
-            printf("# Looks like you planned %lu test%s but ran %lu extra\n",
-                   _planned, (_planned > 1 ? "s" : ""), highest - _planned);
-        else if (_failed > 0)
-            printf("# Looks like you failed %lu test%s of %lu\n", _failed,
-                   (_failed > 1 ? "s" : ""), _planned);
-        else if (_planned > 1)
-            printf("# All %lu tests successful or skipped\n", _planned);
-        else
-            printf("# %lu test successful or skipped\n", _planned);
+    /* Check for pending diag_file output. */
+    check_diag_files();
+
+    /* Free the diag_files. */
+    file = diag_files;
+    while (file != NULL) {
+        tmp = file;
+        file = file->next;
+        fclose(tmp->file);
+        free(tmp->name);
+        free(tmp->buffer);
+        free(tmp);
     }
+    diag_files = NULL;
+
+    /*
+     * Determine whether all tests were successful, which is needed before
+     * calling cleanup functions since we pass that fact to the functions.
+     */
+    if (_planned == 0 && _lazy)
+        _planned = highest;
+    success = (!_aborted && _planned == highest && _failed == 0);
+
+    /*
+     * If there are any registered cleanup functions, we run those first.  We
+     * always run them, even if we didn't run a test.  Don't do anything
+     * except free the diag_files and call cleanup functions if we aren't the
+     * primary process (the process in which plan or plan_lazy was called),
+     * and tell the cleanup functions that fact.
+     */
+    primary = (_process == 0 || getpid() == _process);
+    while (cleanup_funcs != NULL) {
+        if (cleanup_funcs->func_with_data) {
+            void *data = cleanup_funcs->data;
+
+            cleanup_funcs->func_with_data(success, primary, data);
+        } else {
+            cleanup_funcs->func(success, primary);
+        }
+        current = cleanup_funcs;
+        cleanup_funcs = cleanup_funcs->next;
+        free(current);
+    }
+    if (!primary)
+        return;
+
+    /* Don't do anything further if we never planned a test. */
+    if (_planned == 0)
+        return;
+
+    /* If we're aborting due to bail, don't print summaries. */
+    if (_aborted)
+        return;
+
+    /* Print out the lazy plan if needed. */
+    fflush(stderr);
+    if (_lazy && _planned > 0)
+        printf("1..%lu\n", _planned);
+
+    /* Print out a summary of the results. */
+    if (_planned > highest)
+        diag("Looks like you planned %lu test%s but only ran %lu", _planned,
+             (_planned > 1 ? "s" : ""), highest);
+    else if (_planned < highest)
+        diag("Looks like you planned %lu test%s but ran %lu extra", _planned,
+             (_planned > 1 ? "s" : ""), highest - _planned);
+    else if (_failed > 0)
+        diag("Looks like you failed %lu test%s of %lu", _failed,
+             (_failed > 1 ? "s" : ""), _planned);
+    else if (_planned != 1)
+        diag("All %lu tests successful or skipped", _planned);
+    else
+        diag("%lu test successful or skipped", _planned);
 }
 
 
 /*
  * Initialize things.  Turns on line buffering on stdout and then prints out
- * the number of tests in the test suite.
+ * the number of tests in the test suite.  We intentionally don't check for
+ * pending diag_file output here, since it should really come after the plan.
  */
 void
 plan(unsigned long count)
 {
     if (setvbuf(stdout, NULL, _IOLBF, BUFSIZ) != 0)
-        fprintf(stderr, "# cannot set stdout to line buffered: %s\n",
-                strerror(errno));
+        sysdiag("cannot set stdout to line buffered");
     fflush(stderr);
     printf("1..%lu\n", count);
     testnum = 1;
     _planned = count;
     _process = getpid();
-    atexit(finish);
+    if (atexit(finish) != 0) {
+        sysdiag("cannot register exit handler");
+        diag("cleanups will not be run");
+    }
 }
 
 
@@ -143,45 +399,28 @@
 plan_lazy(void)
 {
     if (setvbuf(stdout, NULL, _IOLBF, BUFSIZ) != 0)
-        fprintf(stderr, "# cannot set stdout to line buffered: %s\n",
-                strerror(errno));
+        sysdiag("cannot set stdout to line buffered");
     testnum = 1;
     _process = getpid();
     _lazy = 1;
-    atexit(finish);
+    if (atexit(finish) != 0)
+        sysbail("cannot register exit handler to display plan");
 }
 
 
 /*
  * Skip the entire test suite and exits.  Should be called instead of plan(),
- * not after it, since it prints out a special plan line.
+ * not after it, since it prints out a special plan line.  Ignore diag_file
+ * output here, since it's not clear if it's allowed before the plan.
  */
 void
 skip_all(const char *format, ...)
 {
     fflush(stderr);
     printf("1..0 # skip");
-    if (format != NULL) {
-        va_list args;
-
-        putchar(' ');
-        va_start(args, format);
-        vprintf(format, args);
-        va_end(args);
-    }
+    PRINT_DESC(" ", format);
     putchar('\n');
     exit(0);
-}
-
-
-/*
- * Print the test description.
- */
-static void
-print_desc(const char *format, va_list args)
-{
-    printf(" - ");
-    vprintf(format, args);
 }
 
 
@@ -189,37 +428,37 @@
  * Takes a boolean success value and assumes the test passes if that value
  * is true and fails if that value is false.
  */
-void
+int
 ok(int success, const char *format, ...)
 {
     fflush(stderr);
+    check_diag_files();
     printf("%sok %lu", success ? "" : "not ", testnum++);
     if (!success)
         _failed++;
-    if (format != NULL) {
-        va_list args;
-
-        va_start(args, format);
-        print_desc(format, args);
-        va_end(args);
-    }
+    PRINT_DESC(" - ", format);
     putchar('\n');
+    return success;
 }
 
 
 /*
  * Same as ok(), but takes the format arguments as a va_list.
  */
-void
+int
 okv(int success, const char *format, va_list args)
 {
     fflush(stderr);
+    check_diag_files();
     printf("%sok %lu", success ? "" : "not ", testnum++);
     if (!success)
         _failed++;
-    if (format != NULL)
-        print_desc(format, args);
+    if (format != NULL) {
+        printf(" - ");
+        vprintf(format, args);
+    }
     putchar('\n');
+    return success;
 }
 
 
@@ -230,15 +469,9 @@
 skip(const char *reason, ...)
 {
     fflush(stderr);
+    check_diag_files();
     printf("ok %lu # skip", testnum++);
-    if (reason != NULL) {
-        va_list args;
-
-        va_start(args, reason);
-        putchar(' ');
-        vprintf(reason, args);
-        va_end(args);
-    }
+    PRINT_DESC(" ", reason);
     putchar('\n');
 }
 
@@ -246,25 +479,21 @@
 /*
  * Report the same status on the next count tests.
  */
-void
-ok_block(unsigned long count, int status, const char *format, ...)
+int
+ok_block(unsigned long count, int success, const char *format, ...)
 {
     unsigned long i;
 
     fflush(stderr);
+    check_diag_files();
     for (i = 0; i < count; i++) {
-        printf("%sok %lu", status ? "" : "not ", testnum++);
-        if (!status)
+        printf("%sok %lu", success ? "" : "not ", testnum++);
+        if (!success)
             _failed++;
-        if (format != NULL) {
-            va_list args;
-
-            va_start(args, format);
-            print_desc(format, args);
-            va_end(args);
-        }
+        PRINT_DESC(" - ", format);
         putchar('\n');
     }
+    return success;
 }
 
 
@@ -277,101 +506,157 @@
     unsigned long i;
 
     fflush(stderr);
+    check_diag_files();
     for (i = 0; i < count; i++) {
         printf("ok %lu # skip", testnum++);
-        if (reason != NULL) {
-            va_list args;
-
-            va_start(args, reason);
-            putchar(' ');
-            vprintf(reason, args);
-            va_end(args);
-        }
+        PRINT_DESC(" ", reason);
         putchar('\n');
     }
 }
 
 
 /*
- * Takes an expected integer and a seen integer and assumes the test passes
- * if those two numbers match.
+ * Takes two boolean values and requires the truth value of both match.
  */
-void
-is_int(long wanted, long seen, const char *format, ...)
+int
+is_bool(int left, int right, const char *format, ...)
 {
+    int success;
+
     fflush(stderr);
-    if (wanted == seen)
+    check_diag_files();
+    success = (!!left == !!right);
+    if (success)
         printf("ok %lu", testnum++);
     else {
-        printf("# wanted: %ld\n#   seen: %ld\n", wanted, seen);
+        diag(" left: %s", !!left ? "true" : "false");
+        diag("right: %s", !!right ? "true" : "false");
         printf("not ok %lu", testnum++);
         _failed++;
     }
-    if (format != NULL) {
-        va_list args;
-
-        va_start(args, format);
-        print_desc(format, args);
-        va_end(args);
-    }
+    PRINT_DESC(" - ", format);
     putchar('\n');
+    return success;
 }
 
 
 /*
- * Takes a string and what the string should be, and assumes the test passes
- * if those strings match (using strcmp).
+ * Takes two integer values and requires they match.
  */
-void
-is_string(const char *wanted, const char *seen, const char *format, ...)
+int
+is_int(long left, long right, const char *format, ...)
 {
-    if (wanted == NULL)
-        wanted = "(null)";
-    if (seen == NULL)
-        seen = "(null)";
+    int success;
+
     fflush(stderr);
-    if (strcmp(wanted, seen) == 0)
+    check_diag_files();
+    success = (left == right);
+    if (success)
         printf("ok %lu", testnum++);
     else {
-        printf("# wanted: %s\n#   seen: %s\n", wanted, seen);
+        diag(" left: %ld", left);
+        diag("right: %ld", right);
         printf("not ok %lu", testnum++);
         _failed++;
     }
-    if (format != NULL) {
-        va_list args;
-
-        va_start(args, format);
-        print_desc(format, args);
-        va_end(args);
-    }
+    PRINT_DESC(" - ", format);
     putchar('\n');
+    return success;
 }
 
 
 /*
- * Takes an expected unsigned long and a seen unsigned long and assumes the
- * test passes if the two numbers match.  Otherwise, reports them in hex.
+ * Takes two strings and requires they match (using strcmp).  NULL arguments
+ * are permitted and handled correctly.
  */
-void
-is_hex(unsigned long wanted, unsigned long seen, const char *format, ...)
+int
+is_string(const char *left, const char *right, const char *format, ...)
 {
+    int success;
+
     fflush(stderr);
-    if (wanted == seen)
+    check_diag_files();
+
+    /* Compare the strings, being careful of NULL. */
+    if (left == NULL)
+        success = (right == NULL);
+    else if (right == NULL)
+        success = 0;
+    else
+        success = (strcmp(left, right) == 0);
+
+    /* Report the results. */
+    if (success)
         printf("ok %lu", testnum++);
     else {
-        printf("# wanted: %lx\n#   seen: %lx\n", (unsigned long) wanted,
-               (unsigned long) seen);
+        diag(" left: %s", left == NULL ? "(null)" : left);
+        diag("right: %s", right == NULL ? "(null)" : right);
         printf("not ok %lu", testnum++);
         _failed++;
     }
-    if (format != NULL) {
-        va_list args;
-
-        va_start(args, format);
-        print_desc(format, args);
-        va_end(args);
-    }
+    PRINT_DESC(" - ", format);
     putchar('\n');
+    return success;
+}
+
+
+/*
+ * Takes two unsigned longs and requires they match.  On failure, reports them
+ * in hex.
+ */
+int
+is_hex(unsigned long left, unsigned long right, const char *format, ...)
+{
+    int success;
+
+    fflush(stderr);
+    check_diag_files();
+    success = (left == right);
+    if (success)
+        printf("ok %lu", testnum++);
+    else {
+        diag(" left: %lx", (unsigned long) left);
+        diag("right: %lx", (unsigned long) right);
+        printf("not ok %lu", testnum++);
+        _failed++;
+    }
+    PRINT_DESC(" - ", format);
+    putchar('\n');
+    return success;
+}
+
+
+/*
+ * Takes pointers to a regions of memory and requires that len bytes from each
+ * match.  Otherwise reports any bytes which didn't match.
+ */
+int
+is_blob(const void *left, const void *right, size_t len, const char *format,
+        ...)
+{
+    int success;
+    size_t i;
+
+    fflush(stderr);
+    check_diag_files();
+    success = (memcmp(left, right, len) == 0);
+    if (success)
+        printf("ok %lu", testnum++);
+    else {
+        const unsigned char *left_c = (const unsigned char *) left;
+        const unsigned char *right_c = (const unsigned char *) right;
+
+        for (i = 0; i < len; i++) {
+            if (left_c[i] != right_c[i])
+                diag("offset %lu: left %02x, right %02x", (unsigned long) i,
+                     left_c[i], right_c[i]);
+        }
+        printf("not ok %lu", testnum++);
+        _failed++;
+    }
+    PRINT_DESC(" - ", format);
+    putchar('\n');
+    return success;
 }
 
 
@@ -383,14 +668,16 @@
 {
     va_list args;
 
+    _aborted = 1;
     fflush(stderr);
+    check_diag_files();
     fflush(stdout);
     printf("Bail out! ");
     va_start(args, format);
     vprintf(format, args);
     va_end(args);
     printf("\n");
-    exit(1);
+    exit(255);
 }
 
 
@@ -403,51 +690,110 @@
     va_list args;
     int oerrno = errno;
 
+    _aborted = 1;
     fflush(stderr);
+    check_diag_files();
     fflush(stdout);
     printf("Bail out! ");
     va_start(args, format);
     vprintf(format, args);
     va_end(args);
     printf(": %s\n", strerror(oerrno));
-    exit(1);
+    exit(255);
 }
 
 
 /*
- * Report a diagnostic to stderr.
+ * Report a diagnostic to stderr.  Always returns 1 to allow embedding in
+ * compound statements.
  */
-void
+int
 diag(const char *format, ...)
 {
     va_list args;
 
     fflush(stderr);
+    check_diag_files();
     fflush(stdout);
     printf("# ");
     va_start(args, format);
     vprintf(format, args);
     va_end(args);
     printf("\n");
+    return 1;
 }
 
 
 /*
- * Report a diagnostic to stderr, appending strerror(errno).
+ * Report a diagnostic to stderr, appending strerror(errno).  Always returns 1
+ * to allow embedding in compound statements.
  */
-void
+int
 sysdiag(const char *format, ...)
 {
     va_list args;
     int oerrno = errno;
 
     fflush(stderr);
+    check_diag_files();
     fflush(stdout);
     printf("# ");
     va_start(args, format);
     vprintf(format, args);
     va_end(args);
     printf(": %s\n", strerror(oerrno));
+    return 1;
+}
+
+
+/*
+ * Register a new file for diag_file processing.
+ */
+void
+diag_file_add(const char *name)
+{
+    struct diag_file *file, *prev;
+
+    file = bcalloc_type(1, struct diag_file);
+    file->name = bstrdup(name);
+    file->file = fopen(file->name, "r");
+    if (file->file == NULL)
+        sysbail("cannot open %s", name);
+    file->buffer = bcalloc_type(BUFSIZ, char);
+    file->bufsize = BUFSIZ;
+    if (diag_files == NULL)
+        diag_files = file;
+    else {
+        for (prev = diag_files; prev->next != NULL; prev = prev->next)
+            ;
+        prev->next = file;
+    }
+}
+
+
+/*
+ * Remove a file from diag_file processing.  If the file is not found, do
+ * nothing, since there are some situations where it can be removed twice
+ * (such as if it's removed from a cleanup function, since cleanup functions
+ * are called after freeing all the diag_files).
+ */
+void
+diag_file_remove(const char *name)
+{
+    struct diag_file *file;
+    struct diag_file **prev = &diag_files;
+
+    for (file = diag_files; file != NULL; file = file->next) {
+        if (strcmp(file->name, name) == 0) {
+            *prev = file->next;
+            fclose(file->file);
+            free(file->name);
+            free(file->buffer);
+            free(file);
+            return;
+        }
+        prev = &file->next;
+    }
 }
 
 
@@ -461,7 +807,7 @@
 
     p = calloc(n, size);
     if (p == NULL)
-        sysbail("failed to calloc %lu", (unsigned long)(n * size));
+        sysbail("failed to calloc %lu", (unsigned long) (n * size));
     return p;
 }
 
@@ -495,6 +841,34 @@
 
 
 /*
+ * The same as brealloc, but determine the size by multiplying an element
+ * count by a size, similar to calloc.  The multiplication is checked for
+ * integer overflow.
+ *
+ * We should technically use SIZE_MAX here for the overflow check, but
+ * SIZE_MAX is C99 and we're only assuming C89 + SUSv3, which does not
+ * guarantee that it exists.  They do guarantee that UINT_MAX exists, and we
+ * can assume that UINT_MAX <= SIZE_MAX.
+ *
+ * (In theory, C89 and C99 permit size_t to be smaller than unsigned int, but
+ * I disbelieve in the existence of such systems and they will have to cope
+ * without overflow checks.)
+ */
+void *
+breallocarray(void *p, size_t n, size_t size)
+{
+    if (n > 0 && UINT_MAX / n <= size)
+        bail("reallocarray too large");
+    if (n == 0)
+        n = 1;
+    p = realloc(p, n * size);
+    if (p == NULL)
+        sysbail("failed to realloc %lu bytes", (unsigned long) (n * size));
+    return p;
+}
+
+
+/*
  * Copy a string, reporting a fatal error with bail on failure.
  */
 char *
@@ -504,7 +878,7 @@
     size_t len;
 
     len = strlen(s) + 1;
-    p = malloc(len);
+    p = (char *) malloc(len);
     if (p == NULL)
         sysbail("failed to strdup %lu bytes", (unsigned long) len);
     memcpy(p, s, len);
@@ -525,11 +899,11 @@
     size_t length;
 
     /* Don't assume that the source string is nul-terminated. */
-    for (p = s; (size_t) (p - s) < n && *p != '\0'; p++)
+    for (p = s; (size_t)(p - s) < n && *p != '\0'; p++)
         ;
-    length = p - s;
-    copy = malloc(length + 1);
-    if (p == NULL)
+    length = (size_t)(p - s);
+    copy = (char *) malloc(length + 1);
+    if (copy == NULL)
         sysbail("failed to strndup %lu bytes", (unsigned long) length);
     memcpy(copy, s, length);
     copy[length] = '\0';
@@ -538,31 +912,24 @@
 
 
 /*
- * Locate a test file.  Given the partial path to a file, look under BUILD and
- * then SOURCE for the file and return the full path to the file.  Returns
- * NULL if the file doesn't exist.  A non-NULL return should be freed with
- * test_file_path_free().
- *
- * This function uses sprintf because it attempts to be independent of all
- * other portability layers.  The use immediately after a memory allocation
- * should be safe without using snprintf or strlcpy/strlcat.
+ * Locate a test file.  Given the partial path to a file, look under
+ * C_TAP_BUILD and then C_TAP_SOURCE for the file and return the full path to
+ * the file.  Returns NULL if the file doesn't exist.  A non-NULL return
+ * should be freed with test_file_path_free().
  */
 char *
 test_file_path(const char *file)
 {
     char *base;
     char *path = NULL;
-    size_t length;
-    const char *envs[] = { "BUILD", "SOURCE", NULL };
+    const char *envs[] = {"C_TAP_BUILD", "C_TAP_SOURCE", NULL};
     int i;
 
     for (i = 0; envs[i] != NULL; i++) {
         base = getenv(envs[i]);
         if (base == NULL)
             continue;
-        length = strlen(base) + 1 + strlen(file) + 1;
-        path = bmalloc(length);
-        sprintf(path, "%s/%s", base, file);
+        path = concat(base, "/", file, (const char *) 0);
         if (access(path, R_OK) == 0)
             break;
         free(path);
@@ -580,13 +947,12 @@
 void
 test_file_path_free(char *path)
 {
-    if (path != NULL)
-        free(path);
+    free(path);
 }
 
 
 /*
- * Create a temporary directory, tmp, under BUILD if set and the current
+ * Create a temporary directory, tmp, under C_TAP_BUILD if set and the current
  * directory if it does not.  Returns the path to the temporary directory in
  * newly allocated memory, and calls bail on any failure.  The return value
  * should be freed with test_tmpdir_free.
@@ -600,14 +966,11 @@
 {
     const char *build;
     char *path = NULL;
-    size_t length;
 
-    build = getenv("BUILD");
+    build = getenv("C_TAP_BUILD");
     if (build == NULL)
         build = ".";
-    length = strlen(build) + strlen("/tmp") + 1;
-    path = bmalloc(length);
-    sprintf(path, "%s/tmp", build);
+    path = concat(build, "/tmp", (const char *) 0);
     if (access(path, X_OK) < 0)
         if (mkdir(path, 0777) < 0)
             sysbail("error creating temporary directory %s", path);
@@ -623,7 +986,44 @@
 void
 test_tmpdir_free(char *path)
 {
-    rmdir(path);
     if (path != NULL)
-        free(path);
+        rmdir(path);
+    free(path);
+}
+
+static void
+register_cleanup(test_cleanup_func func,
+                 test_cleanup_func_with_data func_with_data, void *data)
+{
+    struct cleanup_func *cleanup, **last;
+
+    cleanup = bcalloc_type(1, struct cleanup_func);
+    cleanup->func = func;
+    cleanup->func_with_data = func_with_data;
+    cleanup->data = data;
+    cleanup->next = NULL;
+    last = &cleanup_funcs;
+    while (*last != NULL)
+        last = &(*last)->next;
+    *last = cleanup;
+}
+
+/*
+ * Register a cleanup function that is called when testing ends.  All such
+ * registered functions will be run by finish.
+ */
+void
+test_cleanup_register(test_cleanup_func func)
+{
+    register_cleanup(func, NULL, NULL);
+}
+
+/*
+ * Same as above, but also allows an opaque pointer to be passed to the cleanup
+ * function.
+ */
+void
+test_cleanup_register_with_data(test_cleanup_func_with_data func, void *data)
+{
+    register_cleanup(NULL, func, data);
 }
diff --git a/src/external/c-tap-harness/tests/tap/basic.h b/src/external/c-tap-harness/tests/tap/basic.h
index fa4adaf..45f15f2 100644
--- a/src/external/c-tap-harness/tests/tap/basic.h
+++ b/src/external/c-tap-harness/tests/tap/basic.h
@@ -2,10 +2,11 @@
  * Basic utility routines for the TAP protocol.
  *
  * This file is part of C TAP Harness.  The current version plus supporting
- * documentation is at <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ * documentation is at <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
  *
- * Copyright 2009, 2010, 2011, 2012 Russ Allbery <rra@stanford.edu>
- * Copyright 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2011, 2012
+ * Written by Russ Allbery <eagle@eyrie.org>
+ * Copyright 2009-2019 Russ Allbery <eagle@eyrie.org>
+ * Copyright 2001-2002, 2004-2008, 2011-2012, 2014
  *     The Board of Trustees of the Leland Stanford Junior University
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -25,14 +26,16 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
  */
 
 #ifndef TAP_BASIC_H
 #define TAP_BASIC_H 1
 
+#include <stdarg.h> /* va_list */
+#include <stddef.h> /* size_t */
 #include <tests/tap/macros.h>
-#include <stdarg.h>             /* va_list */
-#include <sys/types.h>          /* size_t */
 
 /*
  * Used for iterating through arrays.  ARRAY_SIZE returns the number of
@@ -40,8 +43,8 @@
  * ARRAY_END returns a pointer to the element past the end (ISO C99 makes it
  * legal to refer to such a pointer as long as it's never dereferenced).
  */
-#define ARRAY_SIZE(array)       (sizeof(array) / sizeof((array)[0]))
-#define ARRAY_END(array)        (&(array)[ARRAY_SIZE(array)])
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
+#define ARRAY_END(array)  (&(array)[ARRAY_SIZE(array)])
 
 BEGIN_DECLS
 
@@ -55,7 +58,7 @@
 void plan(unsigned long count);
 
 /*
- * Prepare for lazy planning, in which the plan will be  printed automatically
+ * Prepare for lazy planning, in which the plan will be printed automatically
  * at the end of the test program.
  */
 void plan_lazy(void);
@@ -67,27 +70,40 @@
 /*
  * Basic reporting functions.  The okv() function is the same as ok() but
  * takes the test description as a va_list to make it easier to reuse the
- * reporting infrastructure when writing new tests.
+ * reporting infrastructure when writing new tests.  ok() and okv() return the
+ * value of the success argument.
  */
-void ok(int success, const char *format, ...)
+int ok(int success, const char *format, ...)
     __attribute__((__format__(printf, 2, 3)));
-void okv(int success, const char *format, va_list args);
-void skip(const char *reason, ...)
-    __attribute__((__format__(printf, 1, 2)));
+int okv(int success, const char *format, va_list args)
+    __attribute__((__format__(printf, 2, 0)));
+void skip(const char *reason, ...) __attribute__((__format__(printf, 1, 2)));
 
-/* Report the same status on, or skip, the next count tests. */
-void ok_block(unsigned long count, int success, const char *format, ...)
+/*
+ * Report the same status on, or skip, the next count tests.  ok_block()
+ * returns the value of the success argument.
+ */
+int ok_block(unsigned long count, int success, const char *format, ...)
     __attribute__((__format__(printf, 3, 4)));
 void skip_block(unsigned long count, const char *reason, ...)
     __attribute__((__format__(printf, 2, 3)));
 
-/* Check an expected value against a seen value. */
-void is_int(long wanted, long seen, const char *format, ...)
+/*
+ * Compare two values.  Returns true if the test passes and false if it fails.
+ * is_bool takes an int since the bool type isn't fully portable yet, but
+ * interprets both arguments for their truth value, not for their numeric
+ * value.
+ */
+int is_bool(int, int, const char *format, ...)
     __attribute__((__format__(printf, 3, 4)));
-void is_string(const char *wanted, const char *seen, const char *format, ...)
+int is_int(long, long, const char *format, ...)
     __attribute__((__format__(printf, 3, 4)));
-void is_hex(unsigned long wanted, unsigned long seen, const char *format, ...)
+int is_string(const char *, const char *, const char *format, ...)
     __attribute__((__format__(printf, 3, 4)));
+int is_hex(unsigned long, unsigned long, const char *format, ...)
+    __attribute__((__format__(printf, 3, 4)));
+int is_blob(const void *, const void *, size_t, const char *format, ...)
+    __attribute__((__format__(printf, 4, 5)));
 
 /* Bail out with an error.  sysbail appends strerror(errno). */
 void bail(const char *format, ...)
@@ -96,39 +112,81 @@
     __attribute__((__noreturn__, __nonnull__, __format__(printf, 1, 2)));
 
 /* Report a diagnostic to stderr prefixed with #. */
-void diag(const char *format, ...)
+int diag(const char *format, ...)
     __attribute__((__nonnull__, __format__(printf, 1, 2)));
-void sysdiag(const char *format, ...)
+int sysdiag(const char *format, ...)
     __attribute__((__nonnull__, __format__(printf, 1, 2)));
+
+/*
+ * Register or unregister a file that contains supplementary diagnostics.
+ * Before any other output, all registered files will be read, line by line,
+ * and each line will be reported as a diagnostic as if it were passed to
+ * diag().  Nul characters are not supported in these files and will result in
+ * truncated output.
+ */
+void diag_file_add(const char *file) __attribute__((__nonnull__));
+void diag_file_remove(const char *file) __attribute__((__nonnull__));
 
 /* Allocate memory, reporting a fatal error with bail on failure. */
 void *bcalloc(size_t, size_t)
-    __attribute__((__alloc_size__(1, 2), __malloc__));
+    __attribute__((__alloc_size__(1, 2), __malloc__, __warn_unused_result__));
 void *bmalloc(size_t)
-    __attribute__((__alloc_size__(1), __malloc__));
+    __attribute__((__alloc_size__(1), __malloc__, __warn_unused_result__));
+void *breallocarray(void *, size_t, size_t)
+    __attribute__((__alloc_size__(2, 3), __malloc__, __warn_unused_result__));
 void *brealloc(void *, size_t)
-    __attribute__((__alloc_size__(2), __malloc__));
+    __attribute__((__alloc_size__(2), __malloc__, __warn_unused_result__));
 char *bstrdup(const char *)
-    __attribute__((__malloc__, __nonnull__));
+    __attribute__((__malloc__, __nonnull__, __warn_unused_result__));
 char *bstrndup(const char *, size_t)
-    __attribute__((__malloc__, __nonnull__));
+    __attribute__((__malloc__, __nonnull__, __warn_unused_result__));
 
 /*
- * Find a test file under BUILD or SOURCE, returning the full path.  The
- * returned path should be freed with test_file_path_free().
+ * Macros that cast the return value from b* memory functions, making them
+ * usable in C++ code and providing some additional type safety.
+ */
+#define bcalloc_type(n, type) ((type *) bcalloc((n), sizeof(type)))
+#define breallocarray_type(p, n, type) \
+    ((type *) breallocarray((p), (n), sizeof(type)))
+
+/*
+ * Find a test file under C_TAP_BUILD or C_TAP_SOURCE, returning the full
+ * path.  The returned path should be freed with test_file_path_free().
  */
 char *test_file_path(const char *file)
-    __attribute__((__malloc__, __nonnull__));
+    __attribute__((__malloc__, __nonnull__, __warn_unused_result__));
 void test_file_path_free(char *path);
 
 /*
- * Create a temporary directory relative to BUILD and return the path.  The
- * returned path should be freed with test_tmpdir_free.
+ * Create a temporary directory relative to C_TAP_BUILD and return the path.
+ * The returned path should be freed with test_tmpdir_free().
  */
-char *test_tmpdir(void)
-    __attribute__((__malloc__));
+char *test_tmpdir(void) __attribute__((__malloc__, __warn_unused_result__));
 void test_tmpdir_free(char *path);
 
+/*
+ * Register a cleanup function that is called when testing ends.  All such
+ * registered functions will be run during atexit handling (and are therefore
+ * subject to all the same constraints and caveats as atexit functions).
+ *
+ * The function must return void and will be passed two arguments: an int that
+ * will be true if the test completed successfully and false otherwise, and an
+ * int that will be true if the cleanup function is run in the primary process
+ * (the one that called plan or plan_lazy) and false otherwise.  If
+ * test_cleanup_register_with_data is used instead, a generic pointer can be
+ * provided and will be passed to the cleanup function as a third argument.
+ *
+ * test_cleanup_register_with_data is the better API and should have been the
+ * only API.  test_cleanup_register was an API error preserved for backward
+ * cmpatibility.
+ */
+typedef void (*test_cleanup_func)(int, int);
+typedef void (*test_cleanup_func_with_data)(int, int, void *);
+
+void test_cleanup_register(test_cleanup_func) __attribute__((__nonnull__));
+void test_cleanup_register_with_data(test_cleanup_func_with_data, void *)
+    __attribute__((__nonnull__));
+
 END_DECLS
 
 #endif /* TAP_BASIC_H */
diff --git a/src/external/c-tap-harness/tests/tap/float.c b/src/external/c-tap-harness/tests/tap/float.c
index 67dd555..8fbd441 100644
--- a/src/external/c-tap-harness/tests/tap/float.c
+++ b/src/external/c-tap-harness/tests/tap/float.c
@@ -8,9 +8,9 @@
  * otherwise care about floating point.
  *
  * This file is part of C TAP Harness.  The current version plus supporting
- * documentation is at <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ * documentation is at <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
  *
- * Copyright 2008, 2010, 2012 Russ Allbery <rra@stanford.edu>
+ * Copyright 2008, 2010, 2012-2019 Russ Allbery <eagle@eyrie.org>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -29,13 +29,15 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
  */
 
 /* Required for isnan() and isinf(). */
 #if defined(__STRICT_ANSI__) || defined(PEDANTIC)
-# ifndef _XOPEN_SOURCE
-#  define _XOPEN_SOURCE 600
-# endif
+#    ifndef _XOPEN_SOURCE
+#        define _XOPEN_SOURCE 600
+#    endif
 #endif
 
 #include <math.h>
@@ -46,22 +48,49 @@
 #include <tests/tap/float.h>
 
 /*
- * Takes an expected double and a seen double and assumes the test passes if
- * those two numbers are within delta of each other.
+ * Clang 4.0.1 gets very confused by this file and produces warnings about
+ * floating point implicit conversion from the isnan() and isinf() macros.
  */
-void
-is_double(double wanted, double seen, double epsilon, const char *format, ...)
+#if defined(__llvm__) || defined(__clang__)
+#    pragma clang diagnostic ignored "-Wconversion"
+#    pragma clang diagnostic ignored "-Wdouble-promotion"
+#endif
+
+/*
+ * Returns true if the two doubles are equal infinities, false otherwise.
+ * This requires a bit of machination since isinf is not required to return
+ * different values for positive and negative infinity, and we're trying to
+ * avoid direct comparisons between floating point numbers.
+ */
+static int
+is_equal_infinity(double left, double right)
+{
+    if (!isinf(left) || !isinf(right))
+        return 0;
+    return !!(left < 0) == !!(right < 0);
+}
+
+/*
+ * Takes two doubles and requires they be within epsilon of each other.
+ */
+int
+is_double(double left, double right, double epsilon, const char *format, ...)
 {
     va_list args;
+    int success;
 
     va_start(args, format);
     fflush(stderr);
-    if ((isnan(wanted) && isnan(seen))
-        || (isinf(wanted) && isinf(seen) && wanted == seen)
-        || fabs(wanted - seen) <= epsilon)
+    if ((isnan(left) && isnan(right)) || is_equal_infinity(left, right)
+        || fabs(left - right) <= epsilon) {
+        success = 1;
         okv(1, format, args);
-    else {
-        printf("# wanted: %g\n#   seen: %g\n", wanted, seen);
+    } else {
+        success = 0;
+        diag(" left: %g", left);
+        diag("right: %g", right);
         okv(0, format, args);
     }
+    va_end(args);
+    return success;
 }
diff --git a/src/external/c-tap-harness/tests/tap/float.h b/src/external/c-tap-harness/tests/tap/float.h
index 7464535..bdf8451 100644
--- a/src/external/c-tap-harness/tests/tap/float.h
+++ b/src/external/c-tap-harness/tests/tap/float.h
@@ -2,9 +2,9 @@
  * Floating point check function for the TAP protocol.
  *
  * This file is part of C TAP Harness.  The current version plus supporting
- * documentation is at <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ * documentation is at <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
  *
- * Copyright 2008, 2010, 2012 Russ Allbery <rra@stanford.edu>
+ * Copyright 2008, 2010, 2012, 2014, 2018 Russ Allbery <eagle@eyrie.org>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -23,6 +23,8 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
  */
 
 #ifndef TAP_FLOAT_H
@@ -32,9 +34,8 @@
 
 BEGIN_DECLS
 
-/* Check an expected value against a seen value within epsilon. */
-void is_double(double wanted, double seen, double epsilon,
-               const char *format, ...)
+/* Compare two values within epsilon. */
+int is_double(double, double, double epsilon, const char *format, ...)
     __attribute__((__format__(printf, 4, 5)));
 
 END_DECLS
diff --git a/src/external/c-tap-harness/tests/tap/libtap.sh b/src/external/c-tap-harness/tests/tap/libtap.sh
index f9347d8..1827a68 100644
--- a/src/external/c-tap-harness/tests/tap/libtap.sh
+++ b/src/external/c-tap-harness/tests/tap/libtap.sh
@@ -7,11 +7,11 @@
 #
 # This file provides a TAP-compatible shell function library useful for
 # writing test cases.  It is part of C TAP Harness, which can be found at
-# <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+# <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
 #
-# Written by Russ Allbery <rra@stanford.edu>
-# Copyright 2009, 2010, 2011, 2012 Russ Allbery <rra@stanford.edu>
-# Copyright 2006, 2007, 2008
+# Written by Russ Allbery <eagle@eyrie.org>
+# Copyright 2009-2012, 2016 Russ Allbery <eagle@eyrie.org>
+# Copyright 2006-2008, 2013
 #     The Board of Trustees of the Leland Stanford Junior University
 #
 # Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -31,6 +31,8 @@
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 # IN THE SOFTWARE.
+#
+# SPDX-License-Identifier: MIT
 
 # Print out the number of test cases we expect to run.
 plan () {
@@ -204,7 +206,7 @@
 # Bail out with an error message.
 bail () {
     echo 'Bail out!' "$@"
-    exit 1
+    exit 255
 }
 
 # Output a diagnostic on standard error, preceded by the required # mark.
@@ -212,32 +214,32 @@
     echo '#' "$@"
 }
 
-# Search for the given file first in $BUILD and then in $SOURCE and echo the
-# path where the file was found, or the empty string if the file wasn't
-# found.
+# Search for the given file first in $C_TAP_BUILD and then in $C_TAP_SOURCE
+# and echo the path where the file was found, or the empty string if the file
+# wasn't found.
 #
 # This macro uses puts, so don't run it using backticks inside double quotes
 # or bizarre quoting behavior will happen with Solaris sh.
 test_file_path () {
-    if [ -n "$BUILD" ] && [ -f "$BUILD/$1" ] ; then
-        puts "$BUILD/$1"
-    elif [ -n "$SOURCE" ] && [ -f "$SOURCE/$1" ] ; then
-        puts "$SOURCE/$1"
+    if [ -n "$C_TAP_BUILD" ] && [ -f "$C_TAP_BUILD/$1" ] ; then
+        puts "$C_TAP_BUILD/$1"
+    elif [ -n "$C_TAP_SOURCE" ] && [ -f "$C_TAP_SOURCE/$1" ] ; then
+        puts "$C_TAP_SOURCE/$1"
     else
         echo ''
     fi
 }
 
-# Create $BUILD/tmp for use by tests for storing temporary files and return
-# the path (via standard output).
+# Create $C_TAP_BUILD/tmp for use by tests for storing temporary files and
+# return the path (via standard output).
 #
 # This macro uses puts, so don't run it using backticks inside double quotes
 # or bizarre quoting behavior will happen with Solaris sh.
 test_tmpdir () {
-    if [ -z "$BUILD" ] ; then
+    if [ -z "$C_TAP_BUILD" ] ; then
         tap_tmpdir="./tmp"
     else
-        tap_tmpdir="$BUILD"/tmp
+        tap_tmpdir="$C_TAP_BUILD"/tmp
     fi
     if [ ! -d "$tap_tmpdir" ] ; then
         mkdir "$tap_tmpdir" || bail "Error creating $tap_tmpdir"
diff --git a/src/external/c-tap-harness/tests/tap/macros.h b/src/external/c-tap-harness/tests/tap/macros.h
index 33fee42..c2c8b5c 100644
--- a/src/external/c-tap-harness/tests/tap/macros.h
+++ b/src/external/c-tap-harness/tests/tap/macros.h
@@ -6,9 +6,9 @@
  * everyone can pull them in.
  *
  * This file is part of C TAP Harness.  The current version plus supporting
- * documentation is at <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ * documentation is at <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
  *
- * Copyright 2008, 2012 Russ Allbery <rra@stanford.edu>
+ * Copyright 2008, 2012-2013, 2015 Russ Allbery <eagle@eyrie.org>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -27,6 +27,8 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
  */
 
 #ifndef TAP_MACROS_H
@@ -40,9 +42,9 @@
  * the other attributes to work with GCC versions between 2.7 and 2.96.
  */
 #ifndef __attribute__
-# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
-#  define __attribute__(spec)   /* empty */
-# endif
+#    if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
+#        define __attribute__(spec) /* empty */
+#    endif
 #endif
 
 /*
@@ -53,9 +55,18 @@
  * variadic macro support.
  */
 #if !defined(__attribute__) && !defined(__alloc_size__)
-# if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 3)
-#  define __alloc_size__(spec, args...) /* empty */
-# endif
+#    if defined(__GNUC__) && !defined(__clang__)
+#        if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 3)
+#            define __alloc_size__(spec, args...) /* empty */
+#        endif
+#    endif
+#endif
+
+/* Suppress __warn_unused_result__ if gcc is too old. */
+#if !defined(__attribute__) && !defined(__warn_unused_result__)
+#    if __GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)
+#        define __warn_unused_result__ /* empty */
+#    endif
 #endif
 
 /*
@@ -65,7 +76,7 @@
  * compilation context, but there's no push and pop available.
  */
 #if !defined(__attribute__) && (defined(__llvm__) || defined(__clang__))
-# pragma GCC diagnostic ignored "-Wattributes"
+#    pragma GCC diagnostic ignored "-Wattributes"
 #endif
 
 /* Used for unused parameters to silence gcc warnings. */
@@ -78,11 +89,11 @@
 #undef BEGIN_DECLS
 #undef END_DECLS
 #ifdef __cplusplus
-# define BEGIN_DECLS    extern "C" {
-# define END_DECLS      }
+#    define BEGIN_DECLS extern "C" {
+#    define END_DECLS   }
 #else
-# define BEGIN_DECLS    /* empty */
-# define END_DECLS      /* empty */
+#    define BEGIN_DECLS /* empty */
+#    define END_DECLS   /* empty */
 #endif
 
 #endif /* TAP_MACROS_H */
From 9f1165538bd7ff4290964f35190553079ee26b42 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Tue, 04 Aug 2020 10:34:07 -0400
Subject: [PATCH] tests: Accommodate c-tap-harness 4.7

The SOURCE and BUILD environment variables have been changed to
C_TAP_SOURCE and C_TAP_BUILD in the new version of c-tap-harness.  The
runtests command syntax has changed as well.

Convert all of the old SOURCE and BUILD environment variables to the new
C_TAP_SOURCE and C_TAP_BUILD names.

Add the required -l command line option to specify the test list.

Add the new runtests -v option to run the tests in verbose mode to make
it easier to see which tests failed.

Reviewed-on: https://gerrit.openafs.org/14295
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 624219a1b2192e5c7b6b45e2cbe784a9c5f33a96)

Change-Id: I3a1ed224a6271918711bdd520094df348d7f8cae
---

diff --git a/tests/Makefile.in b/tests/Makefile.in
index 23f1fa0..69f709d 100644
--- a/tests/Makefile.in
+++ b/tests/Makefile.in
@@ -6,8 +6,8 @@
 include @TOP_OBJDIR@/src/config/Makefile.config
 include @TOP_OBJDIR@/src/config/Makefile.pthread
 
-MODULE_CFLAGS = -DSOURCE='"$(abs_top_srcdir)/tests"' \
-	-DBUILD='"$(abs_top_builddir)/tests"'
+MODULE_CFLAGS = -DC_TAP_SOURCE='"$(abs_top_srcdir)/tests"' \
+	-DC_TAP_BUILD='"$(abs_top_builddir)/tests"'
 
 SUBDIRS = tap common auth util cmd volser opr rx
 
@@ -23,7 +23,7 @@
 check test tests: runtests
 	@for A in $(SUBDIRS); do cd $$A && $(MAKE) $@ && cd .. || exit 1; done
 	MAKECHECK=1 ./libwrap @TOP_OBJDIR@/lib \
-	    ./runtests $(abs_top_srcdir)/tests/TESTS
+	    ./runtests -v -l $(abs_top_srcdir)/tests/TESTS
 
 install:
 
diff --git a/tests/auth/keys-t.c b/tests/auth/keys-t.c
index 789b49b..f0556ce 100644
--- a/tests/auth/keys-t.c
+++ b/tests/auth/keys-t.c
@@ -128,11 +128,11 @@
 	goto out;
 
     /* Work out the path to our KeyFile. If the test harness hasn't set
-     * the SOURCE environment variable, then assume it is in our CWD */
-    if (getenv("SOURCE") == NULL) {
+     * the C_TAP_SOURCE environment variable, then assume it is in our CWD */
+    if (getenv("C_TAP_SOURCE") == NULL) {
 	keyfilesrc = strdup("KeyFile");
     } else {
-	if (asprintf(&keyfilesrc, "%s/auth/KeyFile", getenv("SOURCE")) == -1)
+	if (asprintf(&keyfilesrc, "%s/auth/KeyFile", getenv("C_TAP_SOURCE")) == -1)
 	    goto out;
     }
 
diff --git a/tests/bozo/bos-man-t b/tests/bozo/bos-man-t
index fedcf58..b7a3d32 100755
--- a/tests/bozo/bos-man-t
+++ b/tests/bozo/bos-man-t
@@ -8,7 +8,7 @@
 
 # Set this to the bare command to test
 my $command = 'bos';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/bucoord/backup-man-t b/tests/bucoord/backup-man-t
index d8df2c8..162fd2c 100755
--- a/tests/bucoord/backup-man-t
+++ b/tests/bucoord/backup-man-t
@@ -8,7 +8,7 @@
 
 # Set this to the bare command to test
 my $command = 'backup';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/cmd/command-t.c b/tests/cmd/command-t.c
index 796ff22..71efd39 100644
--- a/tests/cmd/command-t.c
+++ b/tests/cmd/command-t.c
@@ -360,10 +360,10 @@
     cmd_FreeArgv(tv);
 
     /* Now, try adding a configuration file into the mix */
-    if (getenv("SOURCE") == NULL)
+    if (getenv("C_TAP_SOURCE") == NULL)
 	path = strdup("test1.conf");
     else {
-	if (asprintf(&path, "%s/cmd/test1.conf", getenv("SOURCE")) < 0)
+	if (asprintf(&path, "%s/cmd/test1.conf", getenv("C_TAP_SOURCE")) < 0)
 	    path = NULL;
     }
     if (path != NULL) {
diff --git a/tests/common/servers.c b/tests/common/servers.c
index 8a7d7a6..de85cd0 100644
--- a/tests/common/servers.c
+++ b/tests/common/servers.c
@@ -30,7 +30,7 @@
 	char *binPath, *logPath, *dbPath, *build;
 
 	/* Child */
-	build = getenv("BUILD");
+	build = getenv("C_TAP_BUILD");
 
 	if (build == NULL)
 	    build = "..";
diff --git a/tests/kauth/kas-man-t b/tests/kauth/kas-man-t
index 1629588..508dc47 100755
--- a/tests/kauth/kas-man-t
+++ b/tests/kauth/kas-man-t
@@ -8,7 +8,7 @@
 
 # Set this to the bare command to test
 my $command = 'kas';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/ptserver/pt_util-t b/tests/ptserver/pt_util-t
index 8d3cdcb..2267cee 100755
--- a/tests/ptserver/pt_util-t
+++ b/tests/ptserver/pt_util-t
@@ -6,7 +6,7 @@
 use File::Basename;
 use Test::More tests=>2;
 
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
   $builddir = dirname($0)."/..";
 }
diff --git a/tests/ptserver/pts-man-t b/tests/ptserver/pts-man-t
index 60645ea..2884587 100755
--- a/tests/ptserver/pts-man-t
+++ b/tests/ptserver/pts-man-t
@@ -8,7 +8,7 @@
 
 # Set this to the bare command to test
 my $command = 'pts';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/rx/perf-t b/tests/rx/perf-t
index 025d6b5..530630a 100755
--- a/tests/rx/perf-t
+++ b/tests/rx/perf-t
@@ -7,7 +7,7 @@
 use POSIX qw(:sys_wait_h :signal_h);
 
 my $port = 4000;
-my $build = $ENV{BUILD};
+my $build = $ENV{C_TAP_BUILD};
 $build = ".." if (!defined($build));
 my $rxperf = $build."/../src/tools/rxperf/rxperf";
 
diff --git a/tests/venus/fs-man-t b/tests/venus/fs-man-t
index 3267b5d..cfbf6c0 100755
--- a/tests/venus/fs-man-t
+++ b/tests/venus/fs-man-t
@@ -8,7 +8,7 @@
 
 # Set this to the bare command to test
 my $command = 'fs';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/volser/vos-man-t b/tests/volser/vos-man-t
index 2e2cc35..381f5ba 100755
--- a/tests/volser/vos-man-t
+++ b/tests/volser/vos-man-t
@@ -8,7 +8,7 @@
 
 # Set this to the bare command to test
 my $command = 'vos';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/volser/vos-t.c b/tests/volser/vos-t.c
index 75b0c50..41e74bd 100644
--- a/tests/volser/vos-t.c
+++ b/tests/volser/vos-t.c
@@ -69,7 +69,7 @@
 	close(outpipe[0]);
 	close(outpipe[1]);
 
-	build = getenv("BUILD");
+	build = getenv("C_TAP_BUILD");
 	if (build == NULL)
 	    build = "..";
 
From 6274236570d34d01ccb09f9644eb97d84f57267b Mon Sep 17 00:00:00 2001
From: Mans Nilsson <mansaxel@besserwisser.org>
Date: Thu, 16 Dec 2021 21:36:22 +0100
Subject: [PATCH] Add sysname, files and header entries for FreeBSD 12.3

Created a new sysname "amd64_fbsd_123" in src/config/afs_sysnames.h
and added "param" files with minimal changes:

	modified:   src/config/afs_sysnames.h
	new file:   src/config/param.amd64_fbsd_123.h
	new file:   src/config/param.i386_fbsd_123.h

This mod builds on 12.3 with all tests passing.

Reviewed-on: https://gerrit.openafs.org/14860
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 7a6192276b3779205fa8bc8c141eda41cf28e37e)

Change-Id: Id66f9fe5663b33671ba1b9e68b8715a5eacd5da2
---

diff --git a/src/config/afs_sysnames.h b/src/config/afs_sysnames.h
index ae20e3d..2dd4d29 100644
--- a/src/config/afs_sysnames.h
+++ b/src/config/afs_sysnames.h
@@ -248,6 +248,7 @@
 #define SYS_NAME_ID_i386_fbsd_120      2160
 #define SYS_NAME_ID_i386_fbsd_121      2161
 #define SYS_NAME_ID_i386_fbsd_122      2162
+#define SYS_NAME_ID_i386_fbsd_123      2163
 
 #define SYS_NAME_ID_ia64_linux2		2200
 #define SYS_NAME_ID_ia64_linux22	2201
@@ -365,6 +366,7 @@
 #define SYS_NAME_ID_amd64_fbsd_120     3060
 #define SYS_NAME_ID_amd64_fbsd_121     3061
 #define SYS_NAME_ID_amd64_fbsd_122     3062
+#define SYS_NAME_ID_amd64_fbsd_123     3063
 
 #define SYS_NAME_ID_amd64_w2k           3400
 
diff --git a/src/config/param.amd64_fbsd_123.h b/src/config/param.amd64_fbsd_123.h
new file mode 100644
index 0000000..9388198
--- /dev/null
+++ b/src/config/param.amd64_fbsd_123.h
@@ -0,0 +1,56 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"amd64_fbsd_123"
+#define SYS_NAME_ID	SYS_NAME_ID_amd64_fbsd_123
+
+#define AFS_64BITPOINTER_ENV 1
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#define AFS_64BITUSERPOINTER_ENV 1
+
+#define AFS_FBSD101_ENV 1
+#define AFS_FBSD102_ENV 1
+#define AFS_FBSD103_ENV 1
+#define AFS_FBSD104_ENV 1
+#define AFS_FBSD110_ENV 1
+#define AFS_FBSD111_ENV 1
+#define AFS_FBSD120_ENV 1
+#define AFS_FBSD121_ENV 1
+#define AFS_FBSD122_ENV 1
+#define AFS_FBSD123_ENV 1
+
+#define AFS_X86_FBSD101_ENV 1
+#define AFS_X86_FBSD102_ENV 1
+#define AFS_X86_FBSD103_ENV 1
+#define AFS_X86_FBSD104_ENV 1
+#define AFS_X86_FBSD110_ENV 1
+#define AFS_X86_FBSD111_ENV 1
+#define AFS_X86_FBSD120_ENV 1
+#define AFS_X86_FBSD121_ENV 1
+#define AFS_X86_FBSD122_ENV 1
+#define AFS_X86_FBSD123_ENV 1
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define AFS_USR_FBSD101_ENV 1
+#define AFS_USR_FBSD102_ENV 1
+#define AFS_USR_FBSD103_ENV 1
+#define AFS_USR_FBSD104_ENV 1
+#define AFS_USR_FBSD110_ENV 1
+#define AFS_USR_FBSD111_ENV 1
+#define AFS_USR_FBSD120_ENV 1
+#define AFS_USR_FBSD121_ENV 1
+#define AFS_USR_FBSD122_ENV 1
+#define AFS_USR_FBSD123_ENV 1
+
+#endif /* !defined(UKERNEL) */
+
+#define USE_UCONTEXT
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.i386_fbsd_123.h b/src/config/param.i386_fbsd_123.h
new file mode 100644
index 0000000..be51d6d
--- /dev/null
+++ b/src/config/param.i386_fbsd_123.h
@@ -0,0 +1,52 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"i386_fbsd_123"
+#define SYS_NAME_ID	SYS_NAME_ID_i386_fbsd_123
+
+#define AFS_FAKEOPEN_ENV 1	/* call afs_FakeOpen as if !AFS_VM_RDWR */
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#define AFS_FBSD101_ENV 1
+#define AFS_FBSD102_ENV 1
+#define AFS_FBSD103_ENV 1
+#define AFS_FBSD104_ENV 1
+#define AFS_FBSD110_ENV 1
+#define AFS_FBSD111_ENV 1
+#define AFS_FBSD120_ENV 1
+#define AFS_FBSD121_ENV 1
+#define AFS_FBSD122_ENV 1
+#define AFS_FBSD123_ENV 1
+
+#define AFS_X86_FBSD101_ENV 1
+#define AFS_X86_FBSD102_ENV 1
+#define AFS_X86_FBSD103_ENV 1
+#define AFS_X86_FBSD104_ENV 1
+#define AFS_X86_FBSD110_ENV 1
+#define AFS_X86_FBSD111_ENV 1
+#define AFS_X86_FBSD120_ENV 1
+#define AFS_X86_FBSD121_ENV 1
+#define AFS_X86_FBSD122_ENV 1
+#define AFS_X86_FBSD123_ENV 1
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define AFS_USR_FBSD101_ENV 1
+#define AFS_USR_FBSD102_ENV 1
+#define AFS_USR_FBSD103_ENV 1
+#define AFS_USR_FBSD104_ENV 1
+#define AFS_USR_FBSD110_ENV 1
+#define AFS_USR_FBSD111_ENV 1
+#define AFS_USR_FBSD120_ENV 1
+#define AFS_USR_FBSD121_ENV 1
+#define AFS_USR_FBSD122_ENV 1
+#define AFS_USR_FBSD123_ENV 1
+
+#endif /* !defined(UKERNEL) */
+
+#endif /* AFS_PARAM_H */
From 98ceecd283cc2bca804c776634f89f71cffa5d62 Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@dson.org>
Date: Wed, 01 Jan 2020 17:09:24 -0600
Subject: [PATCH] FBSD: Avoid recursive osi_VM_StoreAllSegments lock

Currently, osi_VM_StoreAllSegments calls vget() for the given vnode,
which requires locking the vnode. However, the vnode should already be
locked. For example, when called from the close syscall, we reach this
function via: vn_close1 -> afs_vop_close -> afs_close ->
afs_StoreOnLastReference -> afs_StoreAllSegments ->
osi_VM_StoreAllSegments. This causes a panic like so:

    kernel: panic: lockmgr_xlock_hard: recursing on non recursive lockmgr 0x[...] @ /usr/src/sys/kern/vfs_subr.c:2730

We can also reach this code path from the BOP_STORE background
operation (BStore -> afs_StoreOnLastReference -> afs_StoreAllSegments
-> osi_VM_StoreAllSegments), initiated from afs_close(), which has the
vnode locked. In this case, we won't be recursively locking the vnode,
since the process calling afs_close() is the one that holds the lock,
and the background thread is the process trying to lock the vnode
again. So we'll just deadlock.

From the comments in this function, it seems like locking the vnode at
all in here is unnecessary, since the vnode should be locked from the
higher-level functions anyway. So just skip the vget and all of the
related looping retry logic. As a result, this function can now become
somewhat simplified.

Reviewed-on: https://gerrit.openafs.org/14000
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit bdd4a0c78b1acaf1c947ca53d16159ef95cc9840)

Change-Id: I9f279cef6aef9beff6636edc0cd7cfa5f3d36cfa
---

diff --git a/src/afs/FBSD/osi_vm.c b/src/afs/FBSD/osi_vm.c
index 780ae12..d02c533 100644
--- a/src/afs/FBSD/osi_vm.c
+++ b/src/afs/FBSD/osi_vm.c
@@ -110,41 +110,30 @@
 {
     struct vnode *vp;
     struct vm_object *obj;
-    int anyio, tries;
 
-    ReleaseWriteLock(&avc->lock);
-    AFS_GUNLOCK();
-    tries = 5;
     vp = AFSTOV(avc);
-
     /*
-     * I don't understand this.  Why not just call vm_object_page_clean()
-     * and be done with it?  I particularly don't understand why we're calling
-     * vget() here.  Is there some reason to believe that the vnode might
-     * be being recycled at this point?  I don't think there's any need for
-     * this loop, either -- if we keep the vnode locked all the time,
-     * that and the object lock will prevent any new pages from appearing.
-     * The loop is what causes the race condition.  -GAW
+     * VOP_ISLOCKED may return LK_EXCLOTHER here, since we may be running in a
+     * BOP_STORE background operation, and so we're running in a different
+     * thread than the actual syscall that has the vnode locked. So we cannot
+     * just call ASSERT_VOP_LOCKED (since that will fail if VOP_ISLOCKED
+     * returns LK_EXCLOTHER), and instead we just have our own assert here.
      */
-    do {
-	anyio = 0;
-	
-	obj = vp->v_object;
-	if (obj != NULL && obj->flags & OBJ_MIGHTBEDIRTY) {
-	    if (!vget(vp, LK_EXCLUSIVE | LK_RETRY, curthread)) {
-		    obj = vp->v_object;
-		    if (obj != NULL) {
-			AFS_VM_OBJECT_WLOCK(obj);
-			vm_object_page_clean(obj, 0, 0, OBJPC_SYNC);
-			AFS_VM_OBJECT_WUNLOCK(obj);
-			anyio = 1;
-		    }
-		    vput(vp);
-		}
-	    }
-    } while (anyio && (--tries > 0));
-    AFS_GLOCK();
-    ObtainWriteLock(&avc->lock, 94);
+    osi_Assert(VOP_ISLOCKED(vp) != 0);
+
+    obj = vp->v_object;
+
+    if (obj != NULL && (obj->flags & OBJ_MIGHTBEDIRTY) != 0) {
+	ReleaseWriteLock(&avc->lock);
+	AFS_GUNLOCK();
+
+	AFS_VM_OBJECT_WLOCK(obj);
+	vm_object_page_clean(obj, 0, 0, OBJPC_SYNC);
+	AFS_VM_OBJECT_WUNLOCK(obj);
+
+	AFS_GLOCK();
+	ObtainWriteLock(&avc->lock, 94);
+    }
 }
 
 /* Try to invalidate pages, for "fs flush" or "fs flushv"; or
From 871120323c3c9bcdc1a82d0f681cd8e6b08128a8 Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@dson.org>
Date: Sun, 22 Dec 2019 00:43:07 -0600
Subject: [PATCH] FBSD: Use GENERIC kernel headers by default

Currently, if --with-bsd-kernel-build is not specified during
configure, we do not set KERNBUILDDIR during the libafs build at all.
This means that we do not use an opt_global.h during the build.

For the GENERIC kernel, in the past this has worked well enough to
produce a working kernel module, but with FreeBSD 12, the GENERIC
kernel turns on the VIMAGE option by default. If our kernel module is
built without VIMAGE defined, our kernel module cannot be loaded into
GENERIC, since VIMAGE changes the definitions of some symbols that we
use (for example, trying to load such a libafs fails with the message
"link_elf_obj: symbol in_ifaddrhead undefined").

To allow the build to work by default for GENERIC kernels, without
needing any additional configure flags, change the libafs Makefile to
use the headers for the GENERIC kernel if no kernel build dir is
given. To do this, we create a directory in our build tree and
generate the opt_*.h headers in there (using config(8)), and specify
that directory as the kernel build dir.

This approach only works for GENERIC kernels, of course, but that is
the most common scenario. Users that want to build for a custom kernel
configuration still need to specify the actual kernel build dir with
--with-bsd-kernel-build.

Reviewed-on: https://gerrit.openafs.org/14001
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit a9c1939eeb36372872f3258a9ae7259a564332c3)

Change-Id: I456871c2b55cd3fc1eef7bf68011a725e253b902
---

diff --git a/src/libafs/MakefileProto.FBSD.in b/src/libafs/MakefileProto.FBSD.in
index be7d270..8a2a369 100644
--- a/src/libafs/MakefileProto.FBSD.in
+++ b/src/libafs/MakefileProto.FBSD.in
@@ -60,13 +60,33 @@
 # We have some sketchy code that redeclares prototypes
 CWARNFLAGS+= -Wno-redundant-decls
 
+GEN_KBLD_DIR=@abs_builddir@/kconf-GENERIC
+AFS_OS_CLEAN=$(GEN_KBLD_DIR)
+
+# Starting with FreeBSD 12, opt_global.h is effectively required to build, even
+# for the GENERIC kernel. Normally this would be provided in the kernel build
+# dir (--with-bsd-kernel-build). If that dir was not specified, we can still
+# get the needed header files if we assume that the user is building for the
+# GENERIC kernel. So if we don't have a kernel build dir, generate the header
+# files in GEN_KBLD_DIR by using config(8), and specify that as the
+# KERNBUILDDIR. This won't always work, of course, but it has a chance at
+# working for the most common setups (when the user isn't using some custom
+# kernel). The kernel headers, of course, we assume are in $(KSRC).
+$(GEN_KBLD_DIR):
+	-mkdir $(GEN_KBLD_DIR)
+	cd $(KSRC)/$(MACHINE)/conf && \
+		/usr/sbin/config -d $(GEN_KBLD_DIR) GENERIC
+
 # setup for bsd.kmod.mk infrastructure
 .PATH:	${TOP_SRCDIR}/afs/FBSD
 KMODDIR=/boot/modules
 KERN_DEBUGDIR=/usr/lib/debug
 KMOD=	libafs
 SYSDIR= ${KSRC}
-.if !empty(KBLD)
+
+.if empty(KBLD)
+KERNBUILDDIR=$(GEN_KBLD_DIR)
+.else
 KERNBUILDDIR=${KBLD}
 .endif
 
@@ -83,7 +103,7 @@
 # generating headers and objects in this directory, which we want in $(KOBJ).
 # We also need the install target from bsd.kmod.mk in $(KOBJ), but the one
 # from Makefile.common in this directory.  A prime candidate for cleanup.
-setup:
+setup: $(KERNBUILDDIR)
 	-mkdir $(KOBJ)
 	-$(RM) $(KOBJ)/Makefile $(KOBJ)/Makefile.common
 	$(CP) Makefile $(KOBJ)/Makefile
From b18ced6c44148c2ed90d72fb3019de52b7444c3e Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Sat, 04 Apr 2020 22:28:21 -0500
Subject: [PATCH] Add autoconf-archive to src/external

Add autoconf-archive to the src/external mechanism, so we can more
easily import and update the AX_* m4 macros we pull in from
autoconf-archive. Commits are imported from
<git://git.savannah.gnu.org/autoconf-archive.git>.

We already have a copy of ax_gcc_func_attribute.m4 in the tree, so
include that in the list of files. While we're here, also include a
few more macros for checking compiler flags, which will be used in
subsequent commits.

Reviewed-on: https://gerrit.openafs.org/14133
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit a072c65bba86cbcd81157e354d3719ac41a2c97d)

Change-Id: I785607be9abe85e43287c4880103a365e264473b
---

diff --git a/src/external/autoconf-archive-author b/src/external/autoconf-archive-author
new file mode 100644
index 0000000..1c668c5
--- /dev/null
+++ b/src/external/autoconf-archive-author
@@ -0,0 +1 @@
+Autoconf Archive Maintainers <autoconf-archive-maintainers@gnu.org>
diff --git a/src/external/autoconf-archive-files b/src/external/autoconf-archive-files
new file mode 100644
index 0000000..42c7c38
--- /dev/null
+++ b/src/external/autoconf-archive-files
@@ -0,0 +1,5 @@
+m4/ax_append_compile_flags.m4	m4/ax_append_compile_flags.m4
+m4/ax_append_flag.m4		m4/ax_append_flag.m4
+m4/ax_check_compile_flag.m4	m4/ax_check_compile_flag.m4
+m4/ax_gcc_func_attribute.m4	m4/ax_gcc_func_attribute.m4
+m4/ax_require_defined.m4	m4/ax_require_defined.m4
From 476d58796e903594c41201123317c434566afbf2 Mon Sep 17 00:00:00 2001
From: Autoconf Archive Maintainers <autoconf-archive-maintainers@gnu.org>
Date: Tue, 07 Apr 2020 10:23:16 -0500
Subject: [PATCH] Import of code from autoconf-archive

This commit updates the code imported from autoconf-archive to
24358c8c5ca679949ef522964d94e4d1cd1f941a (v2019.01.06)

New files are:
	m4/ax_append_compile_flags.m4
	m4/ax_append_flag.m4
	m4/ax_check_compile_flag.m4
	m4/ax_gcc_func_attribute.m4
	m4/ax_require_defined.m4

Reviewed-on: https://gerrit.openafs.org/14138
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit d8205bbb482554812fbe66afa3c337d991a247b6)

Change-Id: Ibc18f5ddef8b63ba258fa666ada60577a845aa8f
---

diff --git a/src/external/autoconf-archive-last b/src/external/autoconf-archive-last
new file mode 100644
index 0000000..8bf2750
--- /dev/null
+++ b/src/external/autoconf-archive-last
@@ -0,0 +1 @@
+24358c8c5ca679949ef522964d94e4d1cd1f941a
diff --git a/src/external/autoconf-archive/m4/ax_append_compile_flags.m4 b/src/external/autoconf-archive/m4/ax_append_compile_flags.m4
new file mode 100644
index 0000000..9c85635
--- /dev/null
+++ b/src/external/autoconf-archive/m4/ax_append_compile_flags.m4
@@ -0,0 +1,46 @@
+# ============================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_append_compile_flags.html
+# ============================================================================
+#
+# SYNOPSIS
+#
+#   AX_APPEND_COMPILE_FLAGS([FLAG1 FLAG2 ...], [FLAGS-VARIABLE], [EXTRA-FLAGS], [INPUT])
+#
+# DESCRIPTION
+#
+#   For every FLAG1, FLAG2 it is checked whether the compiler works with the
+#   flag.  If it does, the flag is added FLAGS-VARIABLE
+#
+#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
+#   CFLAGS) is used.  During the check the flag is always added to the
+#   current language's flags.
+#
+#   If EXTRA-FLAGS is defined, it is added to the current language's default
+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
+#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
+#   force the compiler to issue an error when a bad flag is given.
+#
+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
+#
+#   NOTE: This macro depends on the AX_APPEND_FLAG and
+#   AX_CHECK_COMPILE_FLAG. Please keep this macro in sync with
+#   AX_APPEND_LINK_FLAGS.
+#
+# LICENSE
+#
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 7
+
+AC_DEFUN([AX_APPEND_COMPILE_FLAGS],
+[AX_REQUIRE_DEFINED([AX_CHECK_COMPILE_FLAG])
+AX_REQUIRE_DEFINED([AX_APPEND_FLAG])
+for flag in $1; do
+  AX_CHECK_COMPILE_FLAG([$flag], [AX_APPEND_FLAG([$flag], [$2])], [], [$3], [$4])
+done
+])dnl AX_APPEND_COMPILE_FLAGS
diff --git a/src/external/autoconf-archive/m4/ax_append_flag.m4 b/src/external/autoconf-archive/m4/ax_append_flag.m4
new file mode 100644
index 0000000..dd6d8b6
--- /dev/null
+++ b/src/external/autoconf-archive/m4/ax_append_flag.m4
@@ -0,0 +1,50 @@
+# ===========================================================================
+#      https://www.gnu.org/software/autoconf-archive/ax_append_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_APPEND_FLAG(FLAG, [FLAGS-VARIABLE])
+#
+# DESCRIPTION
+#
+#   FLAG is appended to the FLAGS-VARIABLE shell variable, with a space
+#   added in between.
+#
+#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
+#   CFLAGS) is used.  FLAGS-VARIABLE is not changed if it already contains
+#   FLAG.  If FLAGS-VARIABLE is unset in the shell, it is set to exactly
+#   FLAG.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 8
+
+AC_DEFUN([AX_APPEND_FLAG],
+[dnl
+AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_SET_IF
+AS_VAR_PUSHDEF([FLAGS], [m4_default($2,_AC_LANG_PREFIX[FLAGS])])
+AS_VAR_SET_IF(FLAGS,[
+  AS_CASE([" AS_VAR_GET(FLAGS) "],
+    [*" $1 "*], [AC_RUN_LOG([: FLAGS already contains $1])],
+    [
+     AS_VAR_APPEND(FLAGS,[" $1"])
+     AC_RUN_LOG([: FLAGS="$FLAGS"])
+    ])
+  ],
+  [
+  AS_VAR_SET(FLAGS,[$1])
+  AC_RUN_LOG([: FLAGS="$FLAGS"])
+  ])
+AS_VAR_POPDEF([FLAGS])dnl
+])dnl AX_APPEND_FLAG
diff --git a/src/external/autoconf-archive/m4/ax_check_compile_flag.m4 b/src/external/autoconf-archive/m4/ax_check_compile_flag.m4
new file mode 100644
index 0000000..bd753b3
--- /dev/null
+++ b/src/external/autoconf-archive/m4/ax_check_compile_flag.m4
@@ -0,0 +1,53 @@
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_check_compile_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CHECK_COMPILE_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])
+#
+# DESCRIPTION
+#
+#   Check whether the given FLAG works with the current language's compiler
+#   or gives an error.  (Warnings, however, are ignored)
+#
+#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on
+#   success/failure.
+#
+#   If EXTRA-FLAGS is defined, it is added to the current language's default
+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
+#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
+#   force the compiler to issue an error when a bad flag is given.
+#
+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this
+#   macro in sync with AX_CHECK_{PREPROC,LINK}_FLAG.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 6
+
+AC_DEFUN([AX_CHECK_COMPILE_FLAG],
+[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF
+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl
+AC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [
+  ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS
+  _AC_LANG_PREFIX[]FLAGS="$[]_AC_LANG_PREFIX[]FLAGS $4 $1"
+  AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],
+    [AS_VAR_SET(CACHEVAR,[yes])],
+    [AS_VAR_SET(CACHEVAR,[no])])
+  _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])
+AS_VAR_IF(CACHEVAR,yes,
+  [m4_default([$2], :)],
+  [m4_default([$3], :)])
+AS_VAR_POPDEF([CACHEVAR])dnl
+])dnl AX_CHECK_COMPILE_FLAGS
diff --git a/src/external/autoconf-archive/m4/ax_gcc_func_attribute.m4 b/src/external/autoconf-archive/m4/ax_gcc_func_attribute.m4
new file mode 100644
index 0000000..098c9aa
--- /dev/null
+++ b/src/external/autoconf-archive/m4/ax_gcc_func_attribute.m4
@@ -0,0 +1,238 @@
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_gcc_func_attribute.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_GCC_FUNC_ATTRIBUTE(ATTRIBUTE)
+#
+# DESCRIPTION
+#
+#   This macro checks if the compiler supports one of GCC's function
+#   attributes; many other compilers also provide function attributes with
+#   the same syntax. Compiler warnings are used to detect supported
+#   attributes as unsupported ones are ignored by default so quieting
+#   warnings when using this macro will yield false positives.
+#
+#   The ATTRIBUTE parameter holds the name of the attribute to be checked.
+#
+#   If ATTRIBUTE is supported define HAVE_FUNC_ATTRIBUTE_<ATTRIBUTE>.
+#
+#   The macro caches its result in the ax_cv_have_func_attribute_<attribute>
+#   variable.
+#
+#   The macro currently supports the following function attributes:
+#
+#    alias
+#    aligned
+#    alloc_size
+#    always_inline
+#    artificial
+#    cold
+#    const
+#    constructor
+#    constructor_priority for constructor attribute with priority
+#    deprecated
+#    destructor
+#    dllexport
+#    dllimport
+#    error
+#    externally_visible
+#    fallthrough
+#    flatten
+#    format
+#    format_arg
+#    gnu_inline
+#    hot
+#    ifunc
+#    leaf
+#    malloc
+#    noclone
+#    noinline
+#    nonnull
+#    noreturn
+#    nothrow
+#    optimize
+#    pure
+#    sentinel
+#    sentinel_position
+#    unused
+#    used
+#    visibility
+#    warning
+#    warn_unused_result
+#    weak
+#    weakref
+#
+#   Unsupported function attributes will be tested with a prototype
+#   returning an int and not accepting any arguments and the result of the
+#   check might be wrong or meaningless so use with care.
+#
+# LICENSE
+#
+#   Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 9
+
+AC_DEFUN([AX_GCC_FUNC_ATTRIBUTE], [
+    AS_VAR_PUSHDEF([ac_var], [ax_cv_have_func_attribute_$1])
+
+    AC_CACHE_CHECK([for __attribute__(($1))], [ac_var], [
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([
+            m4_case([$1],
+                [alias], [
+                    int foo( void ) { return 0; }
+                    int bar( void ) __attribute__(($1("foo")));
+                ],
+                [aligned], [
+                    int foo( void ) __attribute__(($1(32)));
+                ],
+                [alloc_size], [
+                    void *foo(int a) __attribute__(($1(1)));
+                ],
+                [always_inline], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [artificial], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [cold], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [const], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [constructor_priority], [
+                    int foo( void ) __attribute__((__constructor__(65535/2)));
+                ],
+                [constructor], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [deprecated], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [destructor], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [dllexport], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [dllimport], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [error], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [externally_visible], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [fallthrough], [
+                    int foo( void ) {switch (0) { case 1: __attribute__(($1)); case 2: break ; }};
+                ],
+                [flatten], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [format], [
+                    int foo(const char *p, ...) __attribute__(($1(printf, 1, 2)));
+                ],
+                [format_arg], [
+                    char *foo(const char *p) __attribute__(($1(1)));
+                ],
+                [gnu_inline], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [hot], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [ifunc], [
+                    int my_foo( void ) { return 0; }
+                    static int (*resolve_foo(void))(void) { return my_foo; }
+                    int foo( void ) __attribute__(($1("resolve_foo")));
+                ],
+                [leaf], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [malloc], [
+                    void *foo( void ) __attribute__(($1));
+                ],
+                [noclone], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [noinline], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [nonnull], [
+                    int foo(char *p) __attribute__(($1(1)));
+                ],
+                [noreturn], [
+                    void foo( void ) __attribute__(($1));
+                ],
+                [nothrow], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [optimize], [
+                    __attribute__(($1(3))) int foo( void ) { return 0; }
+                ],
+                [pure], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [sentinel], [
+                    int foo(void *p, ...) __attribute__(($1));
+                ],
+                [sentinel_position], [
+                    int foo(void *p, ...) __attribute__(($1(1)));
+                ],
+                [returns_nonnull], [
+                    void *foo( void ) __attribute__(($1));
+                ],
+                [unused], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [used], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [visibility], [
+                    int foo_def( void ) __attribute__(($1("default")));
+                    int foo_hid( void ) __attribute__(($1("hidden")));
+                    int foo_int( void ) __attribute__(($1("internal")));
+                    int foo_pro( void ) __attribute__(($1("protected")));
+                ],
+                [warning], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [warn_unused_result], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [weak], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [weakref], [
+                    static int foo( void ) { return 0; }
+                    static int bar( void ) __attribute__(($1("foo")));
+                ],
+                [
+                 m4_warn([syntax], [Unsupported attribute $1, the test may fail])
+                 int foo( void ) __attribute__(($1));
+                ]
+            )], [])
+            ],
+            dnl GCC doesn't exit with an error if an unknown attribute is
+            dnl provided but only outputs a warning, so accept the attribute
+            dnl only if no warning were issued.
+            [AS_IF([test -s conftest.err],
+                [AS_VAR_SET([ac_var], [no])],
+                [AS_VAR_SET([ac_var], [yes])])],
+            [AS_VAR_SET([ac_var], [no])])
+    ])
+
+    AS_IF([test yes = AS_VAR_GET([ac_var])],
+        [AC_DEFINE_UNQUOTED(AS_TR_CPP(HAVE_FUNC_ATTRIBUTE_$1), 1,
+            [Define to 1 if the system has the `$1' function attribute])], [])
+
+    AS_VAR_POPDEF([ac_var])
+])
diff --git a/src/external/autoconf-archive/m4/ax_require_defined.m4 b/src/external/autoconf-archive/m4/ax_require_defined.m4
new file mode 100644
index 0000000..17c3eab
--- /dev/null
+++ b/src/external/autoconf-archive/m4/ax_require_defined.m4
@@ -0,0 +1,37 @@
+# ===========================================================================
+#    https://www.gnu.org/software/autoconf-archive/ax_require_defined.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_REQUIRE_DEFINED(MACRO)
+#
+# DESCRIPTION
+#
+#   AX_REQUIRE_DEFINED is a simple helper for making sure other macros have
+#   been defined and thus are available for use.  This avoids random issues
+#   where a macro isn't expanded.  Instead the configure script emits a
+#   non-fatal:
+#
+#     ./configure: line 1673: AX_CFLAGS_WARN_ALL: command not found
+#
+#   It's like AC_REQUIRE except it doesn't expand the required macro.
+#
+#   Here's an example:
+#
+#     AX_REQUIRE_DEFINED([AX_CHECK_LINK_FLAG])
+#
+# LICENSE
+#
+#   Copyright (c) 2014 Mike Frysinger <vapier@gentoo.org>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 2
+
+AC_DEFUN([AX_REQUIRE_DEFINED], [dnl
+  m4_ifndef([$1], [m4_fatal([macro ]$1[ is not defined; is a m4 file missing?])])
+])dnl AX_REQUIRE_DEFINED
From 43022047cc8a472df61fd09aad825e507822fc31 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Fri, 16 Mar 2018 20:41:35 -0400
Subject: [PATCH] autoconf: import gcc function attribute check macro

Import Gabriele Svelto's AC_GCC_FUNC_ATTRIBUTE autoconf macro to check for
GCC-style function attributes.  This macro is part of the GNU Autoconf
Archive[1]. The imported file is distributed under an all-permissive license.

[1] https://www.gnu.org/software/autoconf-archive/

Reviewed-on: https://gerrit.openafs.org/12962
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit b818854f19e33315d1b6453b72a55b54d740e976)

Change-Id: I6305bf70715048da7da0d605d4ad4bf5551291c0
---

diff --git a/LICENSE b/LICENSE
index 9252889..44b079e 100644
--- a/LICENSE
+++ b/LICENSE
@@ -415,3 +415,15 @@
   THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
   WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+====================================================
+
+The file src/cf/ax_gcc_func_attribute.m4 covered by
+the following license:
+
+  Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>
+
+  Copying and distribution of this file, with or without modification, are
+  permitted in any medium without royalty provided the copyright notice
+  and this notice are preserved.  This file is offered as-is, without any
+  warranty.
diff --git a/src/cf/ax_gcc_func_attribute.m4 b/src/cf/ax_gcc_func_attribute.m4
new file mode 100644
index 0000000..098c9aa
--- /dev/null
+++ b/src/cf/ax_gcc_func_attribute.m4
@@ -0,0 +1,238 @@
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_gcc_func_attribute.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_GCC_FUNC_ATTRIBUTE(ATTRIBUTE)
+#
+# DESCRIPTION
+#
+#   This macro checks if the compiler supports one of GCC's function
+#   attributes; many other compilers also provide function attributes with
+#   the same syntax. Compiler warnings are used to detect supported
+#   attributes as unsupported ones are ignored by default so quieting
+#   warnings when using this macro will yield false positives.
+#
+#   The ATTRIBUTE parameter holds the name of the attribute to be checked.
+#
+#   If ATTRIBUTE is supported define HAVE_FUNC_ATTRIBUTE_<ATTRIBUTE>.
+#
+#   The macro caches its result in the ax_cv_have_func_attribute_<attribute>
+#   variable.
+#
+#   The macro currently supports the following function attributes:
+#
+#    alias
+#    aligned
+#    alloc_size
+#    always_inline
+#    artificial
+#    cold
+#    const
+#    constructor
+#    constructor_priority for constructor attribute with priority
+#    deprecated
+#    destructor
+#    dllexport
+#    dllimport
+#    error
+#    externally_visible
+#    fallthrough
+#    flatten
+#    format
+#    format_arg
+#    gnu_inline
+#    hot
+#    ifunc
+#    leaf
+#    malloc
+#    noclone
+#    noinline
+#    nonnull
+#    noreturn
+#    nothrow
+#    optimize
+#    pure
+#    sentinel
+#    sentinel_position
+#    unused
+#    used
+#    visibility
+#    warning
+#    warn_unused_result
+#    weak
+#    weakref
+#
+#   Unsupported function attributes will be tested with a prototype
+#   returning an int and not accepting any arguments and the result of the
+#   check might be wrong or meaningless so use with care.
+#
+# LICENSE
+#
+#   Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 9
+
+AC_DEFUN([AX_GCC_FUNC_ATTRIBUTE], [
+    AS_VAR_PUSHDEF([ac_var], [ax_cv_have_func_attribute_$1])
+
+    AC_CACHE_CHECK([for __attribute__(($1))], [ac_var], [
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([
+            m4_case([$1],
+                [alias], [
+                    int foo( void ) { return 0; }
+                    int bar( void ) __attribute__(($1("foo")));
+                ],
+                [aligned], [
+                    int foo( void ) __attribute__(($1(32)));
+                ],
+                [alloc_size], [
+                    void *foo(int a) __attribute__(($1(1)));
+                ],
+                [always_inline], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [artificial], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [cold], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [const], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [constructor_priority], [
+                    int foo( void ) __attribute__((__constructor__(65535/2)));
+                ],
+                [constructor], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [deprecated], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [destructor], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [dllexport], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [dllimport], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [error], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [externally_visible], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [fallthrough], [
+                    int foo( void ) {switch (0) { case 1: __attribute__(($1)); case 2: break ; }};
+                ],
+                [flatten], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [format], [
+                    int foo(const char *p, ...) __attribute__(($1(printf, 1, 2)));
+                ],
+                [format_arg], [
+                    char *foo(const char *p) __attribute__(($1(1)));
+                ],
+                [gnu_inline], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [hot], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [ifunc], [
+                    int my_foo( void ) { return 0; }
+                    static int (*resolve_foo(void))(void) { return my_foo; }
+                    int foo( void ) __attribute__(($1("resolve_foo")));
+                ],
+                [leaf], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [malloc], [
+                    void *foo( void ) __attribute__(($1));
+                ],
+                [noclone], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [noinline], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [nonnull], [
+                    int foo(char *p) __attribute__(($1(1)));
+                ],
+                [noreturn], [
+                    void foo( void ) __attribute__(($1));
+                ],
+                [nothrow], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [optimize], [
+                    __attribute__(($1(3))) int foo( void ) { return 0; }
+                ],
+                [pure], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [sentinel], [
+                    int foo(void *p, ...) __attribute__(($1));
+                ],
+                [sentinel_position], [
+                    int foo(void *p, ...) __attribute__(($1(1)));
+                ],
+                [returns_nonnull], [
+                    void *foo( void ) __attribute__(($1));
+                ],
+                [unused], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [used], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [visibility], [
+                    int foo_def( void ) __attribute__(($1("default")));
+                    int foo_hid( void ) __attribute__(($1("hidden")));
+                    int foo_int( void ) __attribute__(($1("internal")));
+                    int foo_pro( void ) __attribute__(($1("protected")));
+                ],
+                [warning], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [warn_unused_result], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [weak], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [weakref], [
+                    static int foo( void ) { return 0; }
+                    static int bar( void ) __attribute__(($1("foo")));
+                ],
+                [
+                 m4_warn([syntax], [Unsupported attribute $1, the test may fail])
+                 int foo( void ) __attribute__(($1));
+                ]
+            )], [])
+            ],
+            dnl GCC doesn't exit with an error if an unknown attribute is
+            dnl provided but only outputs a warning, so accept the attribute
+            dnl only if no warning were issued.
+            [AS_IF([test -s conftest.err],
+                [AS_VAR_SET([ac_var], [no])],
+                [AS_VAR_SET([ac_var], [yes])])],
+            [AS_VAR_SET([ac_var], [no])])
+    ])
+
+    AS_IF([test yes = AS_VAR_GET([ac_var])],
+        [AC_DEFINE_UNQUOTED(AS_TR_CPP(HAVE_FUNC_ATTRIBUTE_$1), 1,
+            [Define to 1 if the system has the `$1' function attribute])], [])
+
+    AS_VAR_POPDEF([ac_var])
+])
From e73c6a751339d4754829b0fa51a2b174fab0b3ba Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Sat, 04 Apr 2020 22:35:07 -0500
Subject: [PATCH] Use autoconf-archive m4 from src/external

Switch to using the m4 macros from autoconf-archive in our
src/external mechanism, instead of manually-copied versions in src/cf.
The src/external copy of ax_gcc_func_attribute.m4 is identical to the
existing copy in src/cf, so that should incur no changes. There are
also a few new macros pulled in, but they are currently unused.

Increase our AC_PREREQ in configure.ac to 2.64, to match the AC_PREREQ
in some of the new files.

Reviewed-on: https://gerrit.openafs.org/14135
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit ca847ddf35e336a8bc3159ce4b26f0162417bbd5)

Change-Id: Ifa43b3869e426fada5bd925b0ae002a0f6436232
---

diff --git a/LICENSE b/LICENSE
index 44b079e..f200e2a 100644
--- a/LICENSE
+++ b/LICENSE
@@ -418,10 +418,13 @@
 
 ====================================================
 
-The file src/cf/ax_gcc_func_attribute.m4 covered by
-the following license:
+The files under src/external/autoconf-archive/m4/ are covered by the following
+license:
 
+  Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+  Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
   Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>
+  Copyright (c) 2014 Mike Frysinger <vapier@gentoo.org>
 
   Copying and distribution of this file, with or without modification, are
   permitted in any medium without royalty provided the copyright notice
diff --git a/configure.ac b/configure.ac
index 21123fb..8dca772 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,4 +1,4 @@
-AC_PREREQ([2.60])
+AC_PREREQ([2.64])
 AC_INIT([OpenAFS],[m4_esyscmd(build-tools/git-version .)],[openafs-bugs@openafs.org],[],[http://www.openafs.org/])
 AC_CONFIG_AUX_DIR([build-tools])
 AC_CONFIG_MACRO_DIR([src/cf])
diff --git a/regen.sh b/regen.sh
index 3ada36c..3ae1987 100755
--- a/regen.sh
+++ b/regen.sh
@@ -26,11 +26,15 @@
   exit 1
 fi
 
+M4_INCS="-I src/cf"
+M4_INCS="$M4_INCS -I src/external/rra-c-util/m4"
+M4_INCS="$M4_INCS -I src/external/autoconf-archive/m4"
+
 echo "Running aclocal"
 if which aclocal > /dev/null 2>&1; then
-  aclocal -I src/cf -I src/external/rra-c-util/m4
+  aclocal $M4_INCS
 elif which aclocal-1.10 > /dev/null 2>&1; then
-  aclocal-1.10 -I src/cf -I src/external/rra-c-util/m4
+  aclocal-1.10 $M4_INCS
 else
   echo "No aclocal found on your system (looked for aclocal & aclocal-1.10)"
   exit 1
diff --git a/src/cf/ax_gcc_func_attribute.m4 b/src/cf/ax_gcc_func_attribute.m4
deleted file mode 100644
index 098c9aa..0000000
--- a/src/cf/ax_gcc_func_attribute.m4
+++ /dev/null
@@ -1,238 +0,0 @@
-# ===========================================================================
-#  https://www.gnu.org/software/autoconf-archive/ax_gcc_func_attribute.html
-# ===========================================================================
-#
-# SYNOPSIS
-#
-#   AX_GCC_FUNC_ATTRIBUTE(ATTRIBUTE)
-#
-# DESCRIPTION
-#
-#   This macro checks if the compiler supports one of GCC's function
-#   attributes; many other compilers also provide function attributes with
-#   the same syntax. Compiler warnings are used to detect supported
-#   attributes as unsupported ones are ignored by default so quieting
-#   warnings when using this macro will yield false positives.
-#
-#   The ATTRIBUTE parameter holds the name of the attribute to be checked.
-#
-#   If ATTRIBUTE is supported define HAVE_FUNC_ATTRIBUTE_<ATTRIBUTE>.
-#
-#   The macro caches its result in the ax_cv_have_func_attribute_<attribute>
-#   variable.
-#
-#   The macro currently supports the following function attributes:
-#
-#    alias
-#    aligned
-#    alloc_size
-#    always_inline
-#    artificial
-#    cold
-#    const
-#    constructor
-#    constructor_priority for constructor attribute with priority
-#    deprecated
-#    destructor
-#    dllexport
-#    dllimport
-#    error
-#    externally_visible
-#    fallthrough
-#    flatten
-#    format
-#    format_arg
-#    gnu_inline
-#    hot
-#    ifunc
-#    leaf
-#    malloc
-#    noclone
-#    noinline
-#    nonnull
-#    noreturn
-#    nothrow
-#    optimize
-#    pure
-#    sentinel
-#    sentinel_position
-#    unused
-#    used
-#    visibility
-#    warning
-#    warn_unused_result
-#    weak
-#    weakref
-#
-#   Unsupported function attributes will be tested with a prototype
-#   returning an int and not accepting any arguments and the result of the
-#   check might be wrong or meaningless so use with care.
-#
-# LICENSE
-#
-#   Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>
-#
-#   Copying and distribution of this file, with or without modification, are
-#   permitted in any medium without royalty provided the copyright notice
-#   and this notice are preserved.  This file is offered as-is, without any
-#   warranty.
-
-#serial 9
-
-AC_DEFUN([AX_GCC_FUNC_ATTRIBUTE], [
-    AS_VAR_PUSHDEF([ac_var], [ax_cv_have_func_attribute_$1])
-
-    AC_CACHE_CHECK([for __attribute__(($1))], [ac_var], [
-        AC_LINK_IFELSE([AC_LANG_PROGRAM([
-            m4_case([$1],
-                [alias], [
-                    int foo( void ) { return 0; }
-                    int bar( void ) __attribute__(($1("foo")));
-                ],
-                [aligned], [
-                    int foo( void ) __attribute__(($1(32)));
-                ],
-                [alloc_size], [
-                    void *foo(int a) __attribute__(($1(1)));
-                ],
-                [always_inline], [
-                    inline __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [artificial], [
-                    inline __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [cold], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [const], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [constructor_priority], [
-                    int foo( void ) __attribute__((__constructor__(65535/2)));
-                ],
-                [constructor], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [deprecated], [
-                    int foo( void ) __attribute__(($1("")));
-                ],
-                [destructor], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [dllexport], [
-                    __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [dllimport], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [error], [
-                    int foo( void ) __attribute__(($1("")));
-                ],
-                [externally_visible], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [fallthrough], [
-                    int foo( void ) {switch (0) { case 1: __attribute__(($1)); case 2: break ; }};
-                ],
-                [flatten], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [format], [
-                    int foo(const char *p, ...) __attribute__(($1(printf, 1, 2)));
-                ],
-                [format_arg], [
-                    char *foo(const char *p) __attribute__(($1(1)));
-                ],
-                [gnu_inline], [
-                    inline __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [hot], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [ifunc], [
-                    int my_foo( void ) { return 0; }
-                    static int (*resolve_foo(void))(void) { return my_foo; }
-                    int foo( void ) __attribute__(($1("resolve_foo")));
-                ],
-                [leaf], [
-                    __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [malloc], [
-                    void *foo( void ) __attribute__(($1));
-                ],
-                [noclone], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [noinline], [
-                    __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [nonnull], [
-                    int foo(char *p) __attribute__(($1(1)));
-                ],
-                [noreturn], [
-                    void foo( void ) __attribute__(($1));
-                ],
-                [nothrow], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [optimize], [
-                    __attribute__(($1(3))) int foo( void ) { return 0; }
-                ],
-                [pure], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [sentinel], [
-                    int foo(void *p, ...) __attribute__(($1));
-                ],
-                [sentinel_position], [
-                    int foo(void *p, ...) __attribute__(($1(1)));
-                ],
-                [returns_nonnull], [
-                    void *foo( void ) __attribute__(($1));
-                ],
-                [unused], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [used], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [visibility], [
-                    int foo_def( void ) __attribute__(($1("default")));
-                    int foo_hid( void ) __attribute__(($1("hidden")));
-                    int foo_int( void ) __attribute__(($1("internal")));
-                    int foo_pro( void ) __attribute__(($1("protected")));
-                ],
-                [warning], [
-                    int foo( void ) __attribute__(($1("")));
-                ],
-                [warn_unused_result], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [weak], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [weakref], [
-                    static int foo( void ) { return 0; }
-                    static int bar( void ) __attribute__(($1("foo")));
-                ],
-                [
-                 m4_warn([syntax], [Unsupported attribute $1, the test may fail])
-                 int foo( void ) __attribute__(($1));
-                ]
-            )], [])
-            ],
-            dnl GCC doesn't exit with an error if an unknown attribute is
-            dnl provided but only outputs a warning, so accept the attribute
-            dnl only if no warning were issued.
-            [AS_IF([test -s conftest.err],
-                [AS_VAR_SET([ac_var], [no])],
-                [AS_VAR_SET([ac_var], [yes])])],
-            [AS_VAR_SET([ac_var], [no])])
-    ])
-
-    AS_IF([test yes = AS_VAR_GET([ac_var])],
-        [AC_DEFINE_UNQUOTED(AS_TR_CPP(HAVE_FUNC_ATTRIBUTE_$1), 1,
-            [Define to 1 if the system has the `$1' function attribute])], [])
-
-    AS_VAR_POPDEF([ac_var])
-])
From aa8c15ec11c164b0204a9e8046291da39a59b4a2 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Thu, 02 Jun 2022 10:47:46 -0600
Subject: [PATCH] autoconf: check for format __attribute__ to avoid warnings

Building with Solaris Studio generates a ludicrous number of warnings
in the form:

   roken.h, line ...: warning: attribute "format" is unknown, ignored

Modern Solaris Studio supports several GCC-style function attributes,
including the `noreturn' attribute, however does not support the
`format' attribute.

Currently, configure defines HAVE___ATTRIBUTE__ when the `noreturn'
attribute is available. roken headers conditionally declare printf-like
functions with the `format' function attribute when HAVE___ATTRIBUTE__
is defined, leading to the warning messages when building under Solaris
Studio. Unsupported function attributes generate warnings, not errors.

Fix these warnings by defining HAVE___ATTRIBUTE__ if and only if the
`format' attribute is supported by the compiler, instead of checking for
`noreturn'.  Note that the `format' type is currently the only attribute
used by roken at this time.

Reviewed-on: https://gerrit.openafs.org/12956
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit f9b3cf888304d42c2a1a8472fdeeab68a7347859)

Change-Id: I7ae19fa3d7d90e67d6eb63ef9b51a74a215e9273
---

diff --git a/src/cf/c-attribute.m4 b/src/cf/c-attribute.m4
index c179d90..be339a8 100644
--- a/src/cf/c-attribute.m4
+++ b/src/cf/c-attribute.m4
@@ -1,27 +1,17 @@
 dnl
-dnl $Id$
+dnl GCC-style function __attribute__ checks.
 dnl
-
+dnl Define HAVE___ATTRIBUTE__ if and only if we specifically support the
+dnl `format' function attribute. This is done for the imported roken
+dnl headers, which use that symbol to conditionally declare functions with
+dnl printf-like arguments. This is the only use of function attributes in
+dnl roken.  The HAVE___ATTRIBUTE__ symbol is not used in the OpenAFS code.
 dnl
-dnl Test for __attribute__
-dnl
-
 AC_DEFUN([OPENAFS_C_ATTRIBUTE], [
-AC_MSG_CHECKING(for __attribute__)
-AC_CACHE_VAL(ac_cv___attribute__, [
-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[#include <stdlib.h>
-static void foo(void) __attribute__ ((noreturn));
+  AX_GCC_FUNC_ATTRIBUTE([format])
 
-static void
-foo(void)
-{
-  exit(1);
-}
-]])],
-[ac_cv___attribute__=yes],
-[ac_cv___attribute__=no])])
-if test "$ac_cv___attribute__" = "yes"; then
-  AC_DEFINE(HAVE___ATTRIBUTE__, 1, [define if your compiler has __attribute__])
-fi
-AC_MSG_RESULT($ac_cv___attribute__)
+  AS_IF([test "$ax_cv_have_func_attribute_format" = "yes"], [
+    AC_DEFINE([HAVE___ATTRIBUTE__], [1],
+      [define if your compiler has __attribute__((format))])
+  ])
 ])
From e4e9d4ea4ad65c700a31ba415be5afc2cdc680d1 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Thu, 02 Jun 2022 10:48:49 -0600
Subject: [PATCH] autoconf: attribute type checks

Check for function attributes by type and update src/afs/stds.h to
conditionally include the attributes detected, instead of checking for
specific compilers and compiler versions.

This allows attributes to be used when building under Solaris Studio.

Reviewed-on: https://gerrit.openafs.org/12963
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
(cherry picked from commit 1f29c9f05f53966df1bbd9ece479155f78f995e0)

Change-Id: I6163e3ebf73c6616dfd3de78e76b14b5907bd4df
---

diff --git a/src/cf/c-attribute.m4 b/src/cf/c-attribute.m4
index be339a8..61b9410 100644
--- a/src/cf/c-attribute.m4
+++ b/src/cf/c-attribute.m4
@@ -8,7 +8,11 @@
 dnl roken.  The HAVE___ATTRIBUTE__ symbol is not used in the OpenAFS code.
 dnl
 AC_DEFUN([OPENAFS_C_ATTRIBUTE], [
+  AX_GCC_FUNC_ATTRIBUTE([always_inline])
   AX_GCC_FUNC_ATTRIBUTE([format])
+  AX_GCC_FUNC_ATTRIBUTE([nonnull])
+  AX_GCC_FUNC_ATTRIBUTE([noreturn])
+  AX_GCC_FUNC_ATTRIBUTE([unused])
 
   AS_IF([test "$ax_cv_have_func_attribute_format" = "yes"], [
     AC_DEFINE([HAVE___ATTRIBUTE__], [1],
diff --git a/src/config/stds.h b/src/config/stds.h
index a773823..cbcb7fc 100644
--- a/src/config/stds.h
+++ b/src/config/stds.h
@@ -250,7 +250,8 @@
 #elif defined(AFS_SGI_ENV) || defined(AFS_USR_SGI_ENV)
 #define static_inline static
 #define hdr_static_inline(x) x
-#elif defined(AFS_NBSD_ENV) && !defined(AFS_NBSD50_ENV)
+#elif defined(AFS_NBSD_ENV) && !defined(AFS_NBSD50_ENV) \
+      && defined(HAVE_FUNC_ATTRIBUTE_ALWAYS_INLINE)
 #define static_inline static __inline __attribute__((always_inline))
 #define hdr_static_inline(x) static __inline __attribute__((always_inline)) x
 #else
@@ -274,21 +275,28 @@
 #define afs_int_to_pointer(i)      ((void *)  (i))
 #endif
 
-#if defined(__GNUC__) && __GNUC__ > 2
-#define AFS_UNUSED __attribute__((unused))
-#define AFS_ATTRIBUTE_FORMAT(style,x,y) __attribute__((format(style, x, y)))
-#define AFS_NORETURN __attribute__((__noreturn__))
-#define AFS_NONNULL(x) __attribute__((__nonnull__ x))
-#elif defined (__clang__)
-#define AFS_UNUSED __attribute__((unused))
-#define AFS_ATTRIBUTE_FORMAT(style,x,y) __attribute__((format(style, x, y)))
-#define AFS_NORETURN __attribute__((__noreturn__))
-#define AFS_NONNULL(x) __attribute__((__nonnull__ x))
+#ifdef HAVE_FUNC_ATTRIBUTE_UNUSED
+# define AFS_UNUSED __attribute__((unused))
 #else
-#define AFS_UNUSED
-#define AFS_ATTRIBUTE_FORMAT(style,x,y)
-#define AFS_NORETURN
-#define AFS_NONNULL(x)
+# define AFS_UNUSED
+#endif
+
+#ifdef HAVE_FUNC_ATTRIBUTE_FORMAT
+# define AFS_ATTRIBUTE_FORMAT(style,x,y) __attribute__((format(style, x, y)))
+#else
+# define AFS_ATTRIBUTE_FORMAT(style,x,y)
+#endif
+
+#ifdef HAVE_FUNC_ATTRIBUTE_NORETURN
+# define AFS_NORETURN __attribute__((__noreturn__))
+#else
+# define AFS_NORETURN
+#endif
+
+#ifdef HAVE_FUNC_ATTRIBUTE_NONNULL
+# define AFS_NONNULL(x) __attribute__((__nonnull__ x))
+#else
+# define AFS_NONNULL(x)
 #endif
 
 /*
From 22c405fe86c511f6d74436d7d982595b89400652 Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Tue, 31 Mar 2020 21:19:18 -0500
Subject: [PATCH] vos: Properly print volume transaction flags

Currently, the code in 'vos status' treats the 'iflags' and 'vflags'
of a transaction like an enumerated type; that is, we only check if
'iflags' is equal to ITOffline or ITBusy, etc. But both of these flags
fields are bitfields; any combination of the relevant flags could
theoretically be set.

Practically speaking, we only ever set at most one of the flags in
'iflags', but if anything ever did set more than one flag, our output
would look broken (we'd print "attachFlags:" without any flags).

For 'vflags', multiple flags are often set at once: the most common
combination is VTDeleteOnSalvage|VTOutOfService. So currently, we
usually print "attachFlags:" without any actual flags, since the
'vflags' field isn't exactly equal to VTDeleteOnSalvage (instead it's
set to VTDeleteOnSalvage|VTOutOfService). And if we ever did see just
VTDeleteOnSalvage set by itself, the way the switch() cases fall
through to each other, we'd print out that _all_ flags are set.

To fix all of this, just test for the individual flag bits instead.

Reviewed-on: https://gerrit.openafs.org/14126
Tested-by: Andrew Deason <adeason@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit f841c189a53f3a6bcf5c25336e4e0ad5362036e2)

Change-Id: Id57d2569bbaa94bb9e7e621cdd16c1e171899362
---

diff --git a/src/volser/vos.c b/src/volser/vos.c
index 379a19c..e43e9fb 100644
--- a/src/volser/vos.c
+++ b/src/volser/vos.c
@@ -4053,33 +4053,32 @@
 	}
 	if (pntr->iflags) {
 	    fprintf(STDOUT, "attachFlags:  ");
-	    switch (pntr->iflags) {
-	    case ITOffline:
+	    if ((pntr->iflags & ITOffline) != 0) {
 		fprintf(STDOUT, "offline ");
-		break;
-	    case ITBusy:
+	    }
+	    if ((pntr->iflags & ITBusy) != 0) {
 		fprintf(STDOUT, "busy ");
-		break;
-	    case ITReadOnly:
+	    }
+	    if ((pntr->iflags & ITReadOnly) != 0) {
 		fprintf(STDOUT, "readonly ");
-		break;
-	    case ITCreate:
+	    }
+	    if ((pntr->iflags & ITCreate) != 0) {
 		fprintf(STDOUT, "create ");
-		break;
-	    case ITCreateVolID:
+	    }
+	    if ((pntr->iflags & ITCreateVolID) != 0) {
 		fprintf(STDOUT, "create volid ");
-		break;
 	    }
 	    fprintf(STDOUT, "\n");
 	}
 	if (pntr->vflags) {
 	    fprintf(STDOUT, "volumeStatus: ");
-	    switch (pntr->vflags) {
-	    case VTDeleteOnSalvage:
+	    if ((pntr->vflags & VTDeleteOnSalvage) != 0) {
 		fprintf(STDOUT, "deleteOnSalvage ");
-	    case VTOutOfService:
+	    }
+	    if ((pntr->vflags & VTOutOfService) != 0) {
 		fprintf(STDOUT, "outOfService ");
-	    case VTDeleted:
+	    }
+	    if ((pntr->vflags & VTDeleted) != 0) {
 		fprintf(STDOUT, "deleted ");
 	    }
 	    fprintf(STDOUT, "\n");
From 953c94c08824611b8291dcb6c4d336e5b49b43b9 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 02 Jun 2022 10:56:39 -0600
Subject: [PATCH] Add more 'fall through' switch comments

Commit a455452d (LINUX 5.3: Add comments for fallthrough switch cases)
added the special /* fall through */ comment to various switch/case
blocks, in order to avoid implicit-fallthrough warnings from causing
the build to fail when building the Linux kernel module.

In this commit, add additional /* fall through */ comments to the rest
of the tree where falling through is intentional. Add a "break;" in one
place in dumptool.c where falling through seems like a mistake, and flag
certain functions as AFS_NORETURN to avoid needing to explicitly break
or fallthrough.

Check for the availability of the -Wimplicit-fallthrough compiler flag
and use it when --enable-checking is set, to prevent additional cases
from creeping into the tree.

Note: the -Wimplicit-fallthrough compiler flag was added in gcc 7.

Reviewed-on: https://gerrit.openafs.org/14125
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
(cherry picked from commit 929d501421579290ce1d4f9aabe45980e5458a9a)

Change-Id: I57d19d715fe61e9125b0b9efc8ae36934001bb10
---

diff --git a/src/butc/dump.c b/src/butc/dump.c
index 62d09e5..ceda6d7 100644
--- a/src/butc/dump.c
+++ b/src/butc/dump.c
@@ -868,8 +868,7 @@
 		    dparamsPtr->volumesFailed++;
 		    continue;
 		}
-		/* Fall into RWVOL case */
-
+		/* fall through */
 	    case RWVOL:
 		for (e = 0; e < vldbEntry.nServers; e++) {	/* Find the RW volume */
 		    if (vldbEntry.serverFlags[e] & VLSF_RWVOL)
diff --git a/src/cf/osconf.m4 b/src/cf/osconf.m4
index 1e1b080..c5ff784 100644
--- a/src/cf/osconf.m4
+++ b/src/cf/osconf.m4
@@ -700,6 +700,11 @@
   esac
 fi
 
+dnl add additional checks if compilers support the flags
+AS_IF([test "x$enable_checking" != "xno"],
+      [AX_APPEND_COMPILE_FLAGS([-Wimplicit-fallthrough], [XCFLAGS])
+])
+
 dnl horribly cheating, assuming double / is ok.
 case $INSTALL in
   ./* ) 
diff --git a/src/cmd/cmd.c b/src/cmd/cmd.c
index ffe49aa7..3605ba0 100644
--- a/src/cmd/cmd.c
+++ b/src/cmd/cmd.c
@@ -678,7 +678,7 @@
 	case CMD_SINGLE_OR_FLAG:
 	    if (tp->items == &dummy)
 		break;
-	    /* Deliberately fall through here */
+	    /* fall through */
 	case CMD_SINGLE:
 	case CMD_LIST:
 	    /* free whole list in both cases, just for fun */
diff --git a/src/opr/jhash.h b/src/opr/jhash.h
index 4568f56..d110735 100644
--- a/src/opr/jhash.h
+++ b/src/opr/jhash.h
@@ -150,19 +150,19 @@
 
     /* All the case statements fall through */
     switch(length) {
-      case 12 : c += (afs_uint32) str[11]<<24;
-      case 11 : c += (afs_uint32) str[10]<<16;
-      case 10 : c += (afs_uint32) str[9]<<8;
-      case 9  : c += (afs_uint32) str[8];
-      case 8  : b += (afs_uint32) str[7]<<24;
-      case 7  : b += (afs_uint32) str[6]<<16;
-      case 6  : b += (afs_uint32) str[5]<<8;
-      case 5  : b += (afs_uint32) str[4];
-      case 4  : a += (afs_uint32) str[3]<<24;
-      case 3  : a += (afs_uint32) str[2]<<16;
-      case 2  : a += (afs_uint32) str[1]<<8;
+      case 12 : c += (afs_uint32) str[11]<<24; 	/* fall through */
+      case 11 : c += (afs_uint32) str[10]<<16; 	/* fall through */
+      case 10 : c += (afs_uint32) str[9]<<8; 	/* fall through */
+      case 9  : c += (afs_uint32) str[8]; 	/* fall through */
+      case 8  : b += (afs_uint32) str[7]<<24; 	/* fall through */
+      case 7  : b += (afs_uint32) str[6]<<16;	/* fall through */
+      case 6  : b += (afs_uint32) str[5]<<8;	/* fall through */
+      case 5  : b += (afs_uint32) str[4];	/* fall through */
+      case 4  : a += (afs_uint32) str[3]<<24;	/* fall through */
+      case 3  : a += (afs_uint32) str[2]<<16;	/* fall through */
+      case 2  : a += (afs_uint32) str[1]<<8;	/* fall through */
       case 1  : a += (afs_uint32) str[0];
-	opr_jhash_final(a, b, c);
+	opr_jhash_final(a, b, c);       	/* fall through */
       case 0:     /* case 0: nothing left to add */
 	break;
     }
diff --git a/src/tools/dumpscan/afsdump_dirlist.c b/src/tools/dumpscan/afsdump_dirlist.c
index 0af2ed7..811ddd4 100644
--- a/src/tools/dumpscan/afsdump_dirlist.c
+++ b/src/tools/dumpscan/afsdump_dirlist.c
@@ -56,7 +56,7 @@
 
 
 /* Print a usage message and exit */
-static void
+static void AFS_NORETURN
 usage(int status, char *msg)
 {
     if (msg)
diff --git a/src/tools/dumpscan/afsdump_extract.c b/src/tools/dumpscan/afsdump_extract.c
index db0b2fa..dfe0369 100644
--- a/src/tools/dumpscan/afsdump_extract.c
+++ b/src/tools/dumpscan/afsdump_extract.c
@@ -62,7 +62,7 @@
 static dump_parser dp;
 
 /* Print a usage message and exit */
-static void
+static void AFS_NORETURN
 usage(int status, char *msg)
 {
     if (msg)
diff --git a/src/tools/dumpscan/afsdump_scan.c b/src/tools/dumpscan/afsdump_scan.c
index dafae67..787172d 100644
--- a/src/tools/dumpscan/afsdump_scan.c
+++ b/src/tools/dumpscan/afsdump_scan.c
@@ -63,7 +63,7 @@
 
 
 /* Print a usage message and exit */
-static void
+static void AFS_NORETURN
 usage(int status, char *msg)
 {
     if (msg)
diff --git a/src/tools/dumpscan/dumptool.c b/src/tools/dumpscan/dumptool.c
index 58d67e8..61dc0e6 100644
--- a/src/tools/dumpscan/dumptool.c
+++ b/src/tools/dumpscan/dumptool.c
@@ -1300,6 +1300,7 @@
 	    break;
 	case 'R':
 	    Rflag++;
+	    break;
 	case 's':
 	    sflag++;
 	    break;
diff --git a/src/tools/dumpscan/parsevnode.c b/src/tools/dumpscan/parsevnode.c
index 0e18e49..1940b3b 100644
--- a/src/tools/dumpscan/parsevnode.c
+++ b/src/tools/dumpscan/parsevnode.c
@@ -480,7 +480,7 @@
 		    return r;
 		break;
 	    }
-
+	    /* fall through */
 	default:
 	    if ((r = xfskip(X, v->size)))
 		return r;
diff --git a/src/vol/salvaged.c b/src/vol/salvaged.c
index 2f354c5..23e2cb3 100644
--- a/src/vol/salvaged.c
+++ b/src/vol/salvaged.c
@@ -478,6 +478,7 @@
 	switch (sres.state) {
 	case SALVSYNC_STATE_ERROR:
 	    printf("salvageserver reports salvage ended in an error; check log files for more details\n");
+	    /* fall through */
 	case SALVSYNC_STATE_DONE:
 	case SALVSYNC_STATE_UNKNOWN:
 	    done = 1;
diff --git a/src/vol/salvsync-server.c b/src/vol/salvsync-server.c
index 6767f60..4d6a9d7 100644
--- a/src/vol/salvsync-server.c
+++ b/src/vol/salvsync-server.c
@@ -940,7 +940,7 @@
     switch (clone->state) {
     case SALVSYNC_STATE_QUEUED:
 	DeleteFromSalvageQueue(clone);
-
+	/* fall through */
     case SALVSYNC_STATE_SALVAGING:
 	switch (parent->state) {
 	case SALVSYNC_STATE_UNKNOWN:
diff --git a/src/vol/volume.c b/src/vol/volume.c
index c2d0668..4c2c10e 100644
--- a/src/vol/volume.c
+++ b/src/vol/volume.c
@@ -1796,15 +1796,18 @@
 		(V_attachState(vp) != VOL_STATE_PREATTACHED)) {
 		break;
 	    }
+	    /* fall through */
 	case 1:
 	    if ((V_attachState(vp) == VOL_STATE_ATTACHED) &&
 		(vp->header == NULL)) {
 		break;
 	    }
+	    /* fall through */
 	case 2:
 	    if (VIsExclusiveState(V_attachState(vp))) {
 		break;
 	    }
+	    /* fall through */
 	case 3:
 	    *idx = nqp;
 	    DeleteVolumeFromVByPList_r(vp);
From 592fc080103bd2ad751fbc9be2a75c085b9cb822 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 02 Jun 2022 11:18:59 -0600
Subject: [PATCH] clang-10: use AFS_FALLTHROUGH for case fallthrough

Clang-10 will not recognize '/* fallthrough */' as an indicator to
turn off the fallthrough diagnostic due to the lack of a 'break' in a
case statement.  Clang-10 requires the '__attribute__((fallthrough))'
statement to disable the diagnostic.

In addition clang-10 is finding additional locations where fall throughs
occur.

Determine if the compiler supports '__attribute__((fallthrough))' to
disable the implicit fallthrough diagnostic.

Define a new macro 'AFS_FALLTHROUGH' that will disable the fallthrough
diagnostic. Set it as a wrapper for the Linux kernel's 'fallthrough'
macro if available, otherwise set it as a wrapper macro for
'__attribute__((fallthrough))' if the compiler supports it.

Update CODING to document the use of AFS_FALLTHROUGH when needing to
fallthrough between case statements.

Replace the '/* fallthrough */' comments with AFS_FALLTHROUGH, and add
AFS_FALLTHROUGH as needed.

Replace some fallthroughs with a break (or goto) if the flow was was
just to a break (or goto).

e.g.   case x:                 case x:
           somestmt;               somestmt;
                                   break;
       case y:                 case y:
           break;                  break;

Correct a mis-indented brace '}' in src/WINNT/afsd/smb3.c

Note, the clang maintainers have rejected the use of comments as a flag
to turn off the fall through warnings.

Reviewed-on: https://gerrit.openafs.org/14274
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 16f1b2f894c28614df0f096be8232b1176e87c70)

[cwills@sinenomine.net Note asetkey.c is not present in 1.8.x]

Change-Id: I4d92d519bd168ac111f46d37bcf7dca7021e5463
---

diff --git a/CODING b/CODING
index 5d62dbb..bac7490 100644
--- a/CODING
+++ b/CODING
@@ -115,6 +115,47 @@
 	    do_something();
 	}
 
+In switch statements, to fall through from one case statement to another, use
+AFS_FALLTHROUGH to mark the intentional fall through.  Do not use fall through
+comments (e.g. /* fallthrough */), as some compilers do not recognize them and
+will flag the case statement with an implied fallthrough warning.
+
+Use:
+
+    switch (x) {
+    case 1:
+        do_something();
+        AFS_FALLTHROUGH;
+    case 2:
+        do_something_else();
+        AFS_FALLTHROUGH;
+    default:
+        do_some_action();
+    }
+
+Instead of using fallthrough comments:
+
+    switch (x) {
+    case 1:
+        do_something();
+        /* fallthrough */
+    case 2:
+        do_something_else();
+        /* fallthrough */
+    default:
+        do_some_action();
+    }
+
+Or not marking the fall through:
+
+   switch (x) {
+    case 1:
+        do_something();
+    case 2:
+        do_something_else();
+    default:
+        do_some_action();
+    }
 
 Dependencies required to build OpenAFS from source
 --------------------------------------------------
diff --git a/src/WINNT/afsadmsvr/TaAfsAdmSvrGeneral.cpp b/src/WINNT/afsadmsvr/TaAfsAdmSvrGeneral.cpp
index 8e51331..bf758e5 100644
--- a/src/WINNT/afsadmsvr/TaAfsAdmSvrGeneral.cpp
+++ b/src/WINNT/afsadmsvr/TaAfsAdmSvrGeneral.cpp
@@ -653,7 +653,7 @@
       {
       case itCELL:
          AfsAdmSvr_MarkRefreshThread (idScope);
-         // fall through
+         AFS_FALLTHROUGH;
 
       case itSERVER:
          ASACTION Action;
diff --git a/src/WINNT/afsd/afskfw.c b/src/WINNT/afsd/afskfw.c
index 636b58b..a45896f 100644
--- a/src/WINNT/afsd/afskfw.c
+++ b/src/WINNT/afsd/afskfw.c
@@ -1995,7 +1995,7 @@
                 if ( !GetDlgItemText(hDialog, ID_MID_TEXT+i, mid_tb[i].buf, mid_tb[i].len) )
                     *mid_tb[i].buf = '\0';
             }
-            /* fallthrough */
+            AFS_FALLTHROUGH;
         case IDCANCEL:
             EndDialog(hDialog, LOWORD(wParam));
             return TRUE;
diff --git a/src/WINNT/afsd/cm_daemon.c b/src/WINNT/afsd/cm_daemon.c
index 2a3f032..c3f41c8 100644
--- a/src/WINNT/afsd/cm_daemon.c
+++ b/src/WINNT/afsd/cm_daemon.c
@@ -252,7 +252,8 @@
                 cm_daemons[daemonID].retryCount++;
                 osi_QAddT((osi_queue_t **) &cm_daemons[daemonID].head, (osi_queue_t **)&cm_daemons[daemonID].tail, &rp->q);
                 break;
-            } /* otherwise fall through */
+            }
+            AFS_FALLTHROUGH;
         case 0:  /* success */
         default: /* other error */
             if (code == 0) {
diff --git a/src/WINNT/afsd/cm_utils.c b/src/WINNT/afsd/cm_utils.c
index f89b84b..c335a40 100644
--- a/src/WINNT/afsd/cm_utils.c
+++ b/src/WINNT/afsd/cm_utils.c
@@ -768,7 +768,7 @@
             break;
         case '.':
             dot++;
-            /* fallthrough */
+            AFS_FALLTHROUGH;
         default:
             if ( star ) {
                 newmask[j++] = '*';
diff --git a/src/WINNT/afsd/rpc_srvsvc.c b/src/WINNT/afsd/rpc_srvsvc.c
index aa262fe..899e2ad 100644
--- a/src/WINNT/afsd/rpc_srvsvc.c
+++ b/src/WINNT/afsd/rpc_srvsvc.c
@@ -877,12 +877,12 @@
                 NetrIntGenerateSharePath(ServerName, &scp->fid);
             /* must be the empty string */
             InfoStruct->ShareInfo2->shi2_passwd = wcsdup(L"");
-            /* fall-through */
+            AFS_FALLTHROUGH;
         case 1:
             InfoStruct->ShareInfo1->shi1_type = STYPE_DISKTREE;
             InfoStruct->ShareInfo1->shi1_remark =
                 NetrIntGenerateShareRemark(scp, &scp->fid);
-            /* fall-through */
+            AFS_FALLTHROUGH;
         case 0:
             /* Canonicalized version of NetName parameter */
             InfoStruct->ShareInfo0->shi0_netname = wcsdup(NetName);
@@ -995,7 +995,7 @@
     switch (Level) {
     case 103:
         InfoStruct->ServerInfo103->sv103_capabilities = 0;
-        /* fall-through */
+        AFS_FALLTHROUGH;
     case 102:
         InfoStruct->ServerInfo102->sv102_users = 0xFFFFFFFF;
         InfoStruct->ServerInfo102->sv102_disc = SV_NODISC;
@@ -1004,13 +1004,13 @@
         InfoStruct->ServerInfo102->sv102_anndelta = 0;
         InfoStruct->ServerInfo102->sv102_licenses = 0;
         InfoStruct->ServerInfo102->sv102_userpath = wcsdup(L"C:\\");
-        /* fall-through */
+        AFS_FALLTHROUGH;
     case 101:
         InfoStruct->ServerInfo101->sv101_version_major = AFSPRODUCT_VERSION_MAJOR;
         InfoStruct->ServerInfo101->sv101_version_minor = AFSPRODUCT_VERSION_MINOR;
         InfoStruct->ServerInfo101->sv101_type = SV_TYPE_WORKSTATION | SV_TYPE_SERVER | SV_TYPE_SERVER_UNIX;
         InfoStruct->ServerInfo101->sv101_comment = wcsdup(wAFSVersion);
-        /* fall-through */
+        AFS_FALLTHROUGH;
     case 100:
         InfoStruct->ServerInfo100->sv100_platform_id = SV_PLATFORM_ID_AFS;
         /* The Netbios Name */
diff --git a/src/WINNT/afsd/smb.c b/src/WINNT/afsd/smb.c
index 22b9d43..4bfb1be 100644
--- a/src/WINNT/afsd/smb.c
+++ b/src/WINNT/afsd/smb.c
@@ -9471,7 +9471,7 @@
         case NRC_SNUMOUT:
 	case NRC_SABORT:
 	    LogEvent(EVENTLOG_WARNING_TYPE, MSG_UNEXPECTED_SMB_SESSION_CLOSE, ncb_error_string(rc));
-	    /* fallthrough */
+	    AFS_FALLTHROUGH;
 	case NRC_SCLOSED:
             /* Client closed session */
             vcp = smb_FindVC(ncbp->ncb_lsn, 0, lanas[idx_session]);
diff --git a/src/WINNT/afsd/smb3.c b/src/WINNT/afsd/smb3.c
index d461f85..006e2fa 100644
--- a/src/WINNT/afsd/smb3.c
+++ b/src/WINNT/afsd/smb3.c
@@ -5392,12 +5392,12 @@
                    shortName);
             fp->u.FfileBothDirectoryInfo.shortNameLength = cm_ClientStrLen(shortName);
 #endif
-    }
-        /* Fallthrough */
+        }
+        AFS_FALLTHROUGH;
 
     case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
         fp->u.FfileFullDirectoryInfo.eaSize = 0;
-        /* Fallthrough */
+        AFS_FALLTHROUGH;
 
     case SMB_FIND_FILE_DIRECTORY_INFO:
         fp->u.FfileDirectoryInfo.nextEntryOffset = 0;
@@ -6108,11 +6108,11 @@
                     fp->u.FfileBothDirectoryInfo.shortNameLength = cm_ClientStrLen(shortName);
 #endif
                 }
-                /* Fallthrough */
+                AFS_FALLTHROUGH;
 
             case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
                 fp->u.FfileFullDirectoryInfo.eaSize = 0;
-                /* Fallthrough */
+                AFS_FALLTHROUGH;
 
             case SMB_FIND_FILE_DIRECTORY_INFO:
                 fp->u.FfileDirectoryInfo.nextEntryOffset = orbytes + align;
diff --git a/src/WINNT/afssvrmgr/svr_getdates.cpp b/src/WINNT/afssvrmgr/svr_getdates.cpp
index 07096e8..b8ba340 100644
--- a/src/WINNT/afssvrmgr/svr_getdates.cpp
+++ b/src/WINNT/afssvrmgr/svr_getdates.cpp
@@ -97,7 +97,7 @@
                {
                case IDOK:
                   Server_GetDates_OnOK (hDlg);
-                  // fall through
+                  AFS_FALLTHROUGH;
 
                case IDCANCEL:
                   DestroyWindow (hDlg);
diff --git a/src/WINNT/afssvrmgr/svr_install.cpp b/src/WINNT/afssvrmgr/svr_install.cpp
index 2dfca8b..f77b54d 100644
--- a/src/WINNT/afssvrmgr/svr_install.cpp
+++ b/src/WINNT/afssvrmgr/svr_install.cpp
@@ -94,7 +94,7 @@
                {
                case IDOK:
                   Server_Install_OnOK (hDlg);
-                  // fall through
+                  AFS_FALLTHROUGH;
 
                case IDCANCEL:
                   DestroyWindow (hDlg);
diff --git a/src/WINNT/afssvrmgr/svr_prune.cpp b/src/WINNT/afssvrmgr/svr_prune.cpp
index ac39fc3..d645b16 100644
--- a/src/WINNT/afssvrmgr/svr_prune.cpp
+++ b/src/WINNT/afssvrmgr/svr_prune.cpp
@@ -94,7 +94,7 @@
                {
                case IDOK:
                   Server_Prune_OnOK (hDlg);
-                  // fall through
+                  AFS_FALLTHROUGH;
 
                case IDCANCEL:
                   DestroyWindow (hDlg);
diff --git a/src/afs/LINUX/osi_export.c b/src/afs/LINUX/osi_export.c
index a3175b5..cd96b07 100644
--- a/src/afs/LINUX/osi_export.c
+++ b/src/afs/LINUX/osi_export.c
@@ -93,7 +93,7 @@
 		if (*max_len < 5) {
 		    return 255;
 		}
-		/* fall through */
+		AFS_FALLTHROUGH;
 
 	    case VN_TYPE_CELL:
 	    case VN_TYPE_ALIAS:
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 00103a5..0fe93ff 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -2699,7 +2699,7 @@
 	case LARGE_FILES_BYPASS_CACHE:
 	    if (i_size_read(ip) > cache_bypass_threshold)
 		return 1;
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	default:
 	    return 0;
      }
diff --git a/src/aklog/klog.c b/src/aklog/klog.c
index edf16e0..0f29884 100644
--- a/src/aklog/klog.c
+++ b/src/aklog/klog.c
@@ -246,12 +246,12 @@
 	    i = get_princ_len(k5context, k5princ, 1);
 	    if (i > MAXKTCNAMELEN-1) i = MAXKTCNAMELEN-1;
 	    memcpy(ktcprinc->instance, get_princ_str(k5context, k5princ, 1), i);
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	case 1:
 	    i = get_princ_len(k5context, k5princ, 0);
 	    if (i > MAXKTCNAMELEN-1) i = MAXKTCNAMELEN-1;
 	    memcpy(ktcprinc->name, get_princ_str(k5context, k5princ, 0), i);
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	case 0:
 	    break;
 	}
diff --git a/src/butc/dump.c b/src/butc/dump.c
index ceda6d7..3750ef7 100644
--- a/src/butc/dump.c
+++ b/src/butc/dump.c
@@ -868,7 +868,7 @@
 		    dparamsPtr->volumesFailed++;
 		    continue;
 		}
-		/* fall through */
+		AFS_FALLTHROUGH;
 	    case RWVOL:
 		for (e = 0; e < vldbEntry.nServers; e++) {	/* Find the RW volume */
 		    if (vldbEntry.serverFlags[e] & VLSF_RWVOL)
diff --git a/src/cf/c-attribute.m4 b/src/cf/c-attribute.m4
index 61b9410..97dbfb3 100644
--- a/src/cf/c-attribute.m4
+++ b/src/cf/c-attribute.m4
@@ -9,6 +9,7 @@
 dnl
 AC_DEFUN([OPENAFS_C_ATTRIBUTE], [
   AX_GCC_FUNC_ATTRIBUTE([always_inline])
+  AX_GCC_FUNC_ATTRIBUTE([fallthrough])
   AX_GCC_FUNC_ATTRIBUTE([format])
   AX_GCC_FUNC_ATTRIBUTE([nonnull])
   AX_GCC_FUNC_ATTRIBUTE([noreturn])
diff --git a/src/cmd/cmd.c b/src/cmd/cmd.c
index 3605ba0..b8694cb 100644
--- a/src/cmd/cmd.c
+++ b/src/cmd/cmd.c
@@ -678,7 +678,7 @@
 	case CMD_SINGLE_OR_FLAG:
 	    if (tp->items == &dummy)
 		break;
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	case CMD_SINGLE:
 	case CMD_LIST:
 	    /* free whole list in both cases, just for fun */
diff --git a/src/config/stds.h b/src/config/stds.h
index cbcb7fc..e3acab3 100644
--- a/src/config/stds.h
+++ b/src/config/stds.h
@@ -299,6 +299,14 @@
 # define AFS_NONNULL(x)
 #endif
 
+#if defined(AFS_LINUX26_ENV) && defined(fallthrough)
+# define AFS_FALLTHROUGH fallthrough
+#elif defined(HAVE_FUNC_ATTRIBUTE_FALLTHROUGH)
+# define AFS_FALLTHROUGH __attribute__((fallthrough))
+#else
+# define AFS_FALLTHROUGH do {} while(0)
+#endif
+
 /*
  * Conditionally remove unreached statements under Solaris Studio.
  */
diff --git a/src/opr/jhash.h b/src/opr/jhash.h
index d110735..5fedaa1 100644
--- a/src/opr/jhash.h
+++ b/src/opr/jhash.h
@@ -79,13 +79,10 @@
 
     /* All the case statements fall through */
     switch(length) {
-      case 3 : c+=k[2];
-	/* fall through */
-      case 2 : b+=k[1];
-	/* fall through */
+      case 3 : c+=k[2];			AFS_FALLTHROUGH;
+      case 2 : b+=k[1];			AFS_FALLTHROUGH;
       case 1 : a+=k[0];
-	opr_jhash_final(a, b, c);
-	/* fall through */
+	opr_jhash_final(a, b, c);	AFS_FALLTHROUGH;
       case 0:     /* case 0: nothing left to add */
 	break;
     }
@@ -150,19 +147,19 @@
 
     /* All the case statements fall through */
     switch(length) {
-      case 12 : c += (afs_uint32) str[11]<<24; 	/* fall through */
-      case 11 : c += (afs_uint32) str[10]<<16; 	/* fall through */
-      case 10 : c += (afs_uint32) str[9]<<8; 	/* fall through */
-      case 9  : c += (afs_uint32) str[8]; 	/* fall through */
-      case 8  : b += (afs_uint32) str[7]<<24; 	/* fall through */
-      case 7  : b += (afs_uint32) str[6]<<16;	/* fall through */
-      case 6  : b += (afs_uint32) str[5]<<8;	/* fall through */
-      case 5  : b += (afs_uint32) str[4];	/* fall through */
-      case 4  : a += (afs_uint32) str[3]<<24;	/* fall through */
-      case 3  : a += (afs_uint32) str[2]<<16;	/* fall through */
-      case 2  : a += (afs_uint32) str[1]<<8;	/* fall through */
+      case 12 : c += (afs_uint32) str[11]<<24;	AFS_FALLTHROUGH;
+      case 11 : c += (afs_uint32) str[10]<<16;	AFS_FALLTHROUGH;
+      case 10 : c += (afs_uint32) str[9]<<8;	AFS_FALLTHROUGH;
+      case 9  : c += (afs_uint32) str[8];	AFS_FALLTHROUGH;
+      case 8  : b += (afs_uint32) str[7]<<24;	AFS_FALLTHROUGH;
+      case 7  : b += (afs_uint32) str[6]<<16;	AFS_FALLTHROUGH;
+      case 6  : b += (afs_uint32) str[5]<<8;	AFS_FALLTHROUGH;
+      case 5  : b += (afs_uint32) str[4];	AFS_FALLTHROUGH;
+      case 4  : a += (afs_uint32) str[3]<<24;	AFS_FALLTHROUGH;
+      case 3  : a += (afs_uint32) str[2]<<16;	AFS_FALLTHROUGH;
+      case 2  : a += (afs_uint32) str[1]<<8;	AFS_FALLTHROUGH;
       case 1  : a += (afs_uint32) str[0];
-	opr_jhash_final(a, b, c);       	/* fall through */
+	opr_jhash_final(a, b, c);		AFS_FALLTHROUGH;
       case 0:     /* case 0: nothing left to add */
 	break;
     }
diff --git a/src/rx/rx_trace.c b/src/rx/rx_trace.c
index 59cc646..512491e 100644
--- a/src/rx/rx_trace.c
+++ b/src/rx/rx_trace.c
@@ -122,6 +122,8 @@
 
     case RX_CALL_ARRIVAL:
 	call->traceWait = now;
+	break;
+
     default:
 	break;
     }
diff --git a/src/rx/xdr.c b/src/rx/xdr.c
index b1efad3..7d23917 100644
--- a/src/rx/xdr.c
+++ b/src/rx/xdr.c
@@ -424,7 +424,7 @@
 	if (sp == NULL) {
 	    return (FALSE);
 	}
-	/* fall through */
+	AFS_FALLTHROUGH;
 
     case XDR_ENCODE:
 	return (xdr_opaque(xdrs, sp, nodesize));
@@ -519,7 +519,7 @@
 	if (sp == NULL) {
 	    return (TRUE);	/* already free */
 	}
-	/* Fall through */
+	AFS_FALLTHROUGH;
     case XDR_ENCODE:
 	size = strlen(sp);
 	break;
@@ -547,7 +547,7 @@
 	    return (FALSE);
 	}
 	sp[size] = 0;
-	/* fall through */
+	AFS_FALLTHROUGH;
 
     case XDR_ENCODE:
 	return (xdr_opaque(xdrs, sp, size));
diff --git a/src/rxkad/ticket5.c b/src/rxkad/ticket5.c
index 326e1b8..3fd5082 100644
--- a/src/rxkad/ticket5.c
+++ b/src/rxkad/ticket5.c
@@ -749,7 +749,7 @@
     case ETYPE_DES3_CBC_SHA1:
 	if (compress_parity_bits(keydata, &keylen))
 	    return 1;
-	/* FALLTHROUGH */
+	AFS_FALLTHROUGH;
     default:
 	if (enctype < 0)
 	    return 1;
diff --git a/src/tests/snprintf.c b/src/tests/snprintf.c
index aaed1a7..a8eeb19e 100644
--- a/src/tests/snprintf.c
+++ b/src/tests/snprintf.c
@@ -442,7 +442,7 @@
 		}
 	    case '\0':
 		--format;
-		/* FALLTHROUGH */
+		AFS_FALLTHROUGH;
 	    case '%':
 		if ((*state->append_char) (state, c))
 		    return -1;
diff --git a/src/tools/dumpscan/parsevnode.c b/src/tools/dumpscan/parsevnode.c
index 1940b3b..f4e5e4b 100644
--- a/src/tools/dumpscan/parsevnode.c
+++ b/src/tools/dumpscan/parsevnode.c
@@ -27,7 +27,7 @@
  */
 
 /* parsevnode.c - Parse a VNode */
-
+#include <afsconfig.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <errno.h>
@@ -480,7 +480,7 @@
 		    return r;
 		break;
 	    }
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	default:
 	    if ((r = xfskip(X, v->size)))
 		return r;
diff --git a/src/vfsck/pass2.c b/src/vfsck/pass2.c
index 8b14fdd..9d0b745 100644
--- a/src/vfsck/pass2.c
+++ b/src/vfsck/pass2.c
@@ -140,7 +140,7 @@
 #else /* no ACLS */
 	statemap[ROOTINO] = DSTATE;
 #endif /* ACLS */
-	/* fall into ... */
+	AFS_FALLTHROUGH;
 
     case DSTATE:
 	descend(&rootdesc, ROOTINO);
@@ -347,7 +347,7 @@
 		else if ((n = reply("REMOVE")) == 1)
 		    break;
 	    }
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 
 	case FSTATE:
 #ifdef VICE
diff --git a/src/vfsck/pass5.c b/src/vfsck/pass5.c
index 8e6cd6d..4ac84fe 100644
--- a/src/vfsck/pass5.c
+++ b/src/vfsck/pass5.c
@@ -213,7 +213,7 @@
 	    case DCLEAR:
 	    case DFOUND:
 		newcg->cg_cs.cs_ndir++;
-		/* fall through */
+		AFS_FALLTHROUGH;
 
 #ifdef VICE
 	    case VSTATE:
diff --git a/src/vol/fssync-server.c b/src/vol/fssync-server.c
index 8cf3b55..720e6ef 100644
--- a/src/vol/fssync-server.c
+++ b/src/vol/fssync-server.c
@@ -954,6 +954,7 @@
 
 		VOL_CV_WAIT(&V_attachCV(vp));
 	    }
+	    break;
 
 	case debugUtility:
 	    break;
@@ -996,7 +997,7 @@
 	     * attaching the volume would be safe */
 	    VRegisterVolOp_r(vp, &info);
 	    vp->pending_vol_op->vol_op_state = FSSYNC_VolOpRunningUnknown;
-	    /* fall through */
+	    goto done;
 
 	case VOL_STATE_DELETED:
 	    goto done;
@@ -1026,7 +1027,7 @@
                  * attaching the volume would be safe */
                 VRegisterVolOp_r(vp, &info);
                 vp->pending_vol_op->vol_op_state = FSSYNC_VolOpRunningUnknown;
-		/* fall through */
+		goto done;
 
             case VOL_STATE_DELETED:
                 goto done;
diff --git a/src/vol/salvaged.c b/src/vol/salvaged.c
index 23e2cb3..5b53a7b 100644
--- a/src/vol/salvaged.c
+++ b/src/vol/salvaged.c
@@ -478,7 +478,7 @@
 	switch (sres.state) {
 	case SALVSYNC_STATE_ERROR:
 	    printf("salvageserver reports salvage ended in an error; check log files for more details\n");
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	case SALVSYNC_STATE_DONE:
 	case SALVSYNC_STATE_UNKNOWN:
 	    done = 1;
diff --git a/src/vol/salvsync-server.c b/src/vol/salvsync-server.c
index 4d6a9d7..dd32d8d 100644
--- a/src/vol/salvsync-server.c
+++ b/src/vol/salvsync-server.c
@@ -940,7 +940,7 @@
     switch (clone->state) {
     case SALVSYNC_STATE_QUEUED:
 	DeleteFromSalvageQueue(clone);
-	/* fall through */
+	AFS_FALLTHROUGH;
     case SALVSYNC_STATE_SALVAGING:
 	switch (parent->state) {
 	case SALVSYNC_STATE_UNKNOWN:
diff --git a/src/vol/volume.c b/src/vol/volume.c
index 4c2c10e..aa88d8a 100644
--- a/src/vol/volume.c
+++ b/src/vol/volume.c
@@ -1796,18 +1796,18 @@
 		(V_attachState(vp) != VOL_STATE_PREATTACHED)) {
 		break;
 	    }
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	case 1:
 	    if ((V_attachState(vp) == VOL_STATE_ATTACHED) &&
 		(vp->header == NULL)) {
 		break;
 	    }
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	case 2:
 	    if (VIsExclusiveState(V_attachState(vp))) {
 		break;
 	    }
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	case 3:
 	    *idx = nqp;
 	    DeleteVolumeFromVByPList_r(vp);
@@ -1851,6 +1851,7 @@
     case VOL_STATE_PREATTACHED:
     case VOL_STATE_ERROR:
 	VChangeState_r(vp, VOL_STATE_UNATTACHED);
+	break;
     case VOL_STATE_UNATTACHED:
     case VOL_STATE_DELETED:
 	break;
diff --git a/src/volser/volprocs.c b/src/volser/volprocs.c
index 745bdd3..710d4be 100644
--- a/src/volser/volprocs.c
+++ b/src/volser/volprocs.c
@@ -2316,6 +2316,7 @@
 	case VOL_INFO_LIST_SINGLE:
 	    Log("1 Volser: GetVolInfo: Volume %" AFS_VOLID_FMT " (%s:%s) will be destroyed on next salvage\n",
 		afs_printable_VolumeId_lu(volumeId), pname, volname);
+	    goto drop;
 
 	default:
 	    goto drop;
From 801dbd010b1d89582ed11e2a10160b6d0f13472e Mon Sep 17 00:00:00 2001
From: Mark Vitale <mvitale@sinenomine.net>
Date: Mon, 04 May 2020 17:35:05 -0400
Subject: [PATCH] UKERNEL: remove dead code osi_SetTime

osi_SetTime has been dead code since the original IBM code import.
Remove it from the tree.

No functional change is incurred by this commit.

Reviewed-on: https://gerrit.openafs.org/14191
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit d6101128664918e6fcefbaeb68c4c1d439851411)

Change-Id: I8a406e4199b959f7470b53882ee143efb8723d7c
---

diff --git a/src/afs/UKERNEL/afs_usrops.c b/src/afs/UKERNEL/afs_usrops.c
index 0e38fb8..7720800 100644
--- a/src/afs/UKERNEL/afs_usrops.c
+++ b/src/afs/UKERNEL/afs_usrops.c
@@ -943,12 +943,6 @@
 }
 
 int
-osi_SetTime(struct timeval *tv)
-{
-    return 0;
-}
-
-int
 osi_Active(struct vcache *avc)
 {
     AFS_STATCNT(osi_Active);
From 6011d44b1acd66e0d32015503770987d135d4565 Mon Sep 17 00:00:00 2001
From: Mark Vitale <mvitale@sinenomine.net>
Date: Mon, 18 May 2020 14:19:25 -0400
Subject: [PATCH] Convert all osi_timeval_t to osi_timeval32_t

Since commit 130144850c6d05bc69e06257a5d7219eb98697d8 "xstat: cm xstat
time values are 32 bit", OpenAFS has had two timeval definitions:
osi_timeval_t and osi_timeval32_t.  Since they are functionally
equivalent, convert all references to osi_timeval_t to osi_timeval32_t.
This makes clear that this struct is always expected to contain 32-bit
members for tv_sec and tv_usec.

There are still a few platforms where osi_timeval32_t is mistakenly
defined with 64-bit members; these will be addressed in future commits.

No functional change should be incurred by this commit.

Reviewed-on: https://gerrit.openafs.org/14215
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit c6eff25be9fc959f666b33425c9ee2635224826e)

Change-Id: I55a2ac3d7fb65c3b14aded755cd81056a3775f74
---

diff --git a/src/afs/AIX/osi_config.c b/src/afs/AIX/osi_config.c
index 6cd306d..82fe533 100644
--- a/src/afs/AIX/osi_config.c
+++ b/src/afs/AIX/osi_config.c
@@ -56,7 +56,7 @@
 #include <sys/timer.h>		/* For the timer related defines                */
 #include <sys/intr.h>		/* for the serialization defines                */
 #include <sys/malloc.h>		/* for the parameters to xmalloc()              */
-#include "afs/afs_osi.h"	/* pick up osi_timeval_t for afs_stats.h */
+#include "afs/afs_osi.h"	/* pick up osi_timeval32_t for afs_stats.h */
 #include "afs/afs_stats.h"
 #include "../export.h"
 
diff --git a/src/afs/afs_callback.c b/src/afs/afs_callback.c
index c186347..b441abc 100644
--- a/src/afs/afs_callback.c
+++ b/src/afs/afs_callback.c
@@ -66,7 +66,7 @@
 };
 unsigned long lastCallBack_vnode;
 unsigned int lastCallBack_dv;
-osi_timeval_t lastCallBack_time;
+osi_timeval32_t lastCallBack_time;
 
 /* these are for storing alternate interface addresses */
 struct interfaceAddr afs_cb_interface;
diff --git a/src/afs/afs_dcache.c b/src/afs/afs_dcache.c
index 6a18f80..3c072bb 100644
--- a/src/afs/afs_dcache.c
+++ b/src/afs/afs_dcache.c
@@ -429,10 +429,10 @@
  * struct so we need only export one symbol for AIX.
  */
 static struct CTD_stats {
-    osi_timeval_t CTD_beforeSleep;
-    osi_timeval_t CTD_afterSleep;
-    osi_timeval_t CTD_sleepTime;
-    osi_timeval_t CTD_runTime;
+    osi_timeval32_t CTD_beforeSleep;
+    osi_timeval32_t CTD_afterSleep;
+    osi_timeval32_t CTD_sleepTime;
+    osi_timeval32_t CTD_runTime;
     int CTD_nSleeps;
 } CTD_stats;
 
@@ -467,7 +467,7 @@
 void
 afs_CacheTruncateDaemon(void)
 {
-    osi_timeval_t CTD_tmpTime;
+    osi_timeval32_t CTD_tmpTime;
     u_int counter;
     u_int cb_lowat;
     u_int dc_hiwat =
diff --git a/src/afs/afs_fetchstore.c b/src/afs/afs_fetchstore.c
index 501061a..7b35b8f 100644
--- a/src/afs/afs_fetchstore.c
+++ b/src/afs/afs_fetchstore.c
@@ -25,12 +25,12 @@
 
 #ifndef AFS_NOSTATS
 static void
-FillStoreStats(int code, int idx, osi_timeval_t xferStartTime,
+FillStoreStats(int code, int idx, osi_timeval32_t xferStartTime,
 	       afs_size_t bytesToXfer, afs_size_t bytesXferred)
 {
     struct afs_stats_xferData *xferP;
-    osi_timeval_t xferStopTime;
-    osi_timeval_t elapsedTime;
+    osi_timeval32_t xferStopTime;
+    osi_timeval32_t elapsedTime;
 
     xferP = &(afs_stats_cmfullperf.rpc.fsXferTimes[idx]);
     osi_GetuTime(&xferStopTime);
@@ -450,7 +450,7 @@
     afs_size_t bytesXferred;
 
 #ifndef AFS_NOSTATS
-    osi_timeval_t xferStartTime;	/*FS xfer start time */
+    osi_timeval32_t xferStartTime;	/*FS xfer start time */
     afs_size_t bytesToXfer = 10000;	/* # bytes to xfer */
 #endif /* AFS_NOSTATS */
     XSTATS_DECLS;
@@ -1116,7 +1116,7 @@
 
     XSTATS_DECLS;
 #ifndef AFS_NOSTATS
-    osi_timeval_t xferStartTime;	/*FS xfer start time */
+    osi_timeval32_t xferStartTime;	/*FS xfer start time */
     afs_size_t bytesToXfer = 0, bytesXferred = 0;
 #endif
 
diff --git a/src/afs/afs_icl.c b/src/afs/afs_icl.c
index 558d42a..6e4ce63 100644
--- a/src/afs/afs_icl.c
+++ b/src/afs/afs_icl.c
@@ -614,7 +614,7 @@
 {
     int rsize;			/* record size in longs */
     int tsize;		/* temp size */
-    osi_timeval_t tv;
+    osi_timeval32_t tv;
     int t1, t2, t3, t4;
 
     t4 = types & 0x3f;		/* decode types */
diff --git a/src/afs/afs_lock.c b/src/afs/afs_lock.c
index f97e6ed..4489853 100644
--- a/src/afs/afs_lock.c
+++ b/src/afs/afs_lock.c
@@ -122,7 +122,7 @@
 void
 Afs_Lock_Obtain(struct afs_lock *lock, int how)
 {
-    osi_timeval_t tt1, tt2, et;
+    osi_timeval32_t tt1, tt2, et;
     afs_uint32 us;
 
     AFS_STATCNT(Lock_Obtain);
diff --git a/src/afs/afs_osi.h b/src/afs/afs_osi.h
index 67d6f99..f64aa87 100644
--- a/src/afs/afs_osi.h
+++ b/src/afs/afs_osi.h
@@ -178,28 +178,19 @@
  */
 #define osi_GetuTime(x) osi_GetTime(x)
 
-/* osi_timeval_t exists because SGI 6.x has two sizes of timeval. */
-/** In 64 bit Solaris the timeval structure has members that are 64 bit
-  * In the GetTime() interface we expect pointers to afs_int32. So the need to
-  * define osi_timeval_t to have 32 bit members. To make this less ambiguous
-  * we now use 32 bit quantities consistently all over the code.
-  * In 64 bit HP-UX the timeval structure has a 64 bit member.
-  */
-
+/*
+ * We use osi_timeval32_t because the native timeval varies in size on
+ * different platforms.  We require a fixed size timeval, at least for the
+ * xstats.
+ */
 #if defined(AFS_HPUX_ENV) || defined(AFS_LINUX_64BIT_KERNEL) || (defined(AFS_LINUX26_ENV) && !defined(HAVE_LINUX_TIME_T)) || (defined(AFS_SGI61_ENV) && defined(KERNEL) && defined(_K64U64))
-typedef struct {
-    afs_int32 tv_sec;
-    afs_int32 tv_usec;
-} osi_timeval_t;
 typedef struct {
     afs_int32 tv_sec;
     afs_int32 tv_usec;
 } osi_timeval32_t;
 #elif defined(AFS_SUN5_ENV)
-typedef struct timeval32 osi_timeval_t;
 typedef struct timeval32 osi_timeval32_t;
 #else
-typedef struct timeval osi_timeval_t;
 typedef struct timeval osi_timeval32_t;
 #endif /* AFS_SGI61_ENV */
 
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index ac7431b..b6998ab 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -61,7 +61,7 @@
 extern afs_int32 afs_connectBacks;
 extern unsigned long lastCallBack_vnode;
 extern unsigned int lastCallBack_dv;
-extern osi_timeval_t lastCallBack_time;
+extern osi_timeval32_t lastCallBack_time;
 extern struct interfaceAddr afs_cb_interface;
 
 extern int afs_RXCallBackServer(void);
diff --git a/src/afs/afs_server.c b/src/afs/afs_server.c
index 4f433e7..7ae3951 100644
--- a/src/afs/afs_server.c
+++ b/src/afs/afs_server.c
@@ -129,7 +129,7 @@
 {
     struct server *a_serverP = sa->server;
     struct srvAddr *sap;
-    osi_timeval_t currTime, *currTimeP;	/*Current time */
+    osi_timeval32_t currTime, *currTimeP;	/*Current time */
     afs_int32 downTime;		/*Computed downtime, in seconds */
     struct afs_stats_SrvUpDownInfo *upDownP;	/*Ptr to up/down info record */
 
@@ -354,8 +354,8 @@
     int currIdx;		/*Curr idx into srv table */
     struct server *currSrvP;	/*Ptr to curr server record */
     afs_int32 currChainLen;	/*Length of curr hash chain */
-    osi_timeval_t currTime;	/*Current time */
-    osi_timeval_t *currTimeP;	/*Ptr to above */
+    osi_timeval32_t currTime;	/*Current time */
+    osi_timeval32_t *currTimeP;	/*Ptr to above */
     afs_int32 srvRecordAge;	/*Age of server record, in secs */
     struct afs_stats_SrvUpDownInfo *upDownP;	/*Ptr to current up/down
 						 * info being manipulated */
@@ -823,7 +823,7 @@
 
     AFS_STATCNT(afs_random);
     if (!state) {
-	osi_timeval_t t;
+	osi_timeval32_t t;
 	osi_GetTime(&t);
 	/*
 	 * Clear the low nybble of tv_usec in a size-independent manner before adding
@@ -1820,8 +1820,8 @@
 void
 afs_ActivateServer(struct srvAddr *sap)
 {
-    osi_timeval_t currTime;	/*Filled with current time */
-    osi_timeval_t *currTimeP;	/*Ptr to above */
+    osi_timeval32_t currTime;	/*Filled with current time */
+    osi_timeval32_t *currTimeP;	/*Ptr to above */
     struct afs_stats_SrvUpDownInfo *upDownP;	/*Ptr to up/down info record */
     struct server *aserver = sap->server;
 
diff --git a/src/afs/afs_stats.h b/src/afs/afs_stats.h
index f80970f..8b578e4 100644
--- a/src/afs/afs_stats.h
+++ b/src/afs/afs_stats.h
@@ -50,7 +50,7 @@
 #endif /* !KERNEL */
 
 #define XSTATS_DECLS struct afs_stats_opTimingData *opP = NULL; \
-    osi_timeval_t opStartTime = { 0, 0}, opStopTime, elapsedTime
+    osi_timeval32_t opStartTime = { 0, 0}, opStopTime, elapsedTime
 
 #define XSTATS_START_TIME(arg) \
   opP = &(afs_stats_cmfullperf.rpc.fsRPCTimes[arg]); \
diff --git a/src/afs/lock.h b/src/afs/lock.h
index 9d7fef4..4d8bbee 100644
--- a/src/afs/lock.h
+++ b/src/afs/lock.h
@@ -115,7 +115,7 @@
     unsigned short readers_reading;	/* # readers actually with read locks */
     unsigned short num_waiting;	/* probably need this soon */
     unsigned short spare;	/* not used now */
-    osi_timeval_t time_waiting;	/* for statistics gathering */
+    osi_timeval32_t time_waiting;	/* for statistics gathering */
 #if defined(INSTRUMENT_LOCKS)
     /* the following are useful for debugging
      ** the field 'src_indicator' is updated only by ObtainLock() and
diff --git a/src/rx/rx.c b/src/rx/rx.c
index 4931f73..a5a26bd 100644
--- a/src/rx/rx.c
+++ b/src/rx/rx.c
@@ -481,7 +481,7 @@
 rx_InitHost(u_int host, u_int port)
 {
 #ifdef KERNEL
-    osi_timeval_t tv;
+    osi_timeval32_t tv;
 #else /* KERNEL */
     struct timeval tv;
 #endif /* KERNEL */
diff --git a/src/rx/rx_clock.h b/src/rx/rx_clock.h
index e487b30..8aac378 100644
--- a/src/rx/rx_clock.h
+++ b/src/rx/rx_clock.h
@@ -95,7 +95,7 @@
 #else /* KERNEL */
 #define clock_Init()
 #if defined(AFS_SGI61_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_LINUX_64BIT_KERNEL)
-#define clock_GetTime(cv) osi_GetTime((osi_timeval_t *)cv)
+#define clock_GetTime(cv) osi_GetTime((osi_timeval32_t *)cv)
 #else
 #if (defined(AFS_AIX51_ENV) && defined(AFS_64BIT_KERNEL)) || (defined(AFS_DARWIN100_ENV) && defined(__amd64__)) || defined(AFS_XBSD_ENV)
 #define        clock_GetTime(cv)                               \
@@ -106,7 +106,7 @@
        (cv)->usec = (afs_int32)tv.tv_usec;             \
     END
 #else /* defined(AFS_AIX51_ENV) && defined(AFS_64BIT_KERNEL) */
-#define clock_GetTime(cv) osi_GetTime((osi_timeval_t *)(cv))
+#define clock_GetTime(cv) osi_GetTime((osi_timeval32_t *)(cv))
 #endif /* defined(AFS_AIX51_ENV) && defined(AFS_64BIT_KERNEL) */
 #endif
 #define clock_Sec() osi_Time()
diff --git a/src/util/uuid.c b/src/util/uuid.c
index dbf77d0..010db30 100644
--- a/src/util/uuid.c
+++ b/src/util/uuid.c
@@ -393,7 +393,7 @@
 void
 uuid__get_os_time(uuid_time_t * os_time)
 {
-    osi_timeval_t tp;
+    osi_timeval32_t tp;
 
     osi_GetTime(&tp);
     os_time->hi = tp.tv_sec;
diff --git a/src/venus/kdump.c b/src/venus/kdump.c
index b10081a..3494051 100644
--- a/src/venus/kdump.c
+++ b/src/venus/kdump.c
@@ -355,7 +355,7 @@
 typedef struct {
     int tv_sec;
     int tv_usec;
-} osi_timeval_t;		/* Needed here since KERNEL defined. */
+} osi_timeval32_t;		/* Needed here since KERNEL defined. */
 
 /*#include "afs/volerrors.h"*/
 #ifdef AFS_LINUX20_ENV
From 3805bf14fd02dfed8d9345382b18d55af9ae50a2 Mon Sep 17 00:00:00 2001
From: Mark Vitale <mvitale@sinenomine.net>
Date: Tue, 05 May 2020 11:26:00 -0400
Subject: [PATCH] UKERNEL: remove redundant declaration of osi_GetTime

Commit c861bb0d779b54236b63eda87d9dfaf7792d1659 "Additional UKERNEL
headers, prototyping and other fixes" added the following lines to
src/rx/rx_prototypes.h:

  #if defined(UKERNEL) && !defined(osi_GetTime)
  extern int osi_GetTime(struct timeval *tv);
  #endif

However, this appears to be redundant with the declaration in
src/afs/afs_prototypes.h:

  #ifdef UKERNEL
  ...
  extern int osi_GetTime(struct timeval *tv);
  ...
  #endif

which was added much earlier with commit
8f2df21ffe59e9aa66219bf24656775b584c122d
"pull-prototypes-to-head-20020821".

Remove the redundant declaration in rx/rx_prototypes.h.

No functional change is incurrred by this commit.

Reviewed-on: https://gerrit.openafs.org/14192
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 03f44172180563cb9d12d79e5512aae815fee899)

Change-Id: I2e562f0e25bf4dd0f47f952782792585a8e7fc20
---

diff --git a/src/rx/rx_prototypes.h b/src/rx/rx_prototypes.h
index d33d235..7eb8e04 100644
--- a/src/rx/rx_prototypes.h
+++ b/src/rx/rx_prototypes.h
@@ -188,9 +188,6 @@
 #if !defined(clock_UpdateTime)
 extern void clock_UpdateTime(void);
 #endif
-#if defined(UKERNEL) && !defined(osi_GetTime)
-extern int osi_GetTime(struct timeval *tv);
-#endif
 
 /* rx_clock_nt.c */
 
From 60c97c371aee9496a6635c1e3d018ae7441c1c50 Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Tue, 02 Jun 2020 13:12:14 -0500
Subject: [PATCH] afs: Move osi_GetTime out of param.h

Most platforms currently #define osi_GetTime in their param.h. This is
really redundant, since the definition of osi_GetTime almost never
changes for a given platform, so we end up with many copies of the
same osi_GetTime definition for a given platform.

Move osi_GetTime out of param.h for these platforms, and define it in
osi_machdep.h instead, which is where most platform-specific
definitions go.

For DFBSD, we don't have an osi_machdep.h at all yet, so create a new
one to contain the osi_GetTime definition. Currently we don't build
libafs at all on DFBSD, but do this anyway so we don't lose the
existing osi_GetTime definition.

For NBSD, we were providing (conflicting!) definitions for osi_GetTime
in param.h and in osi_machdep.h. Just remove the definitions in
param.h, since those should have been getting overridden by the
osi_machdep.h definition.

Reviewed-on: https://gerrit.openafs.org/14237
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit a5c3dfe99fa1831e3b416e89f52a03fd1cf9f73d)

Change-Id: I3afff0c1b4c14649cc072d555d0c3ebd6de8a0fe
---

diff --git a/src/afs/AIX/osi_machdep.h b/src/afs/AIX/osi_machdep.h
index 1c285b8..23060fd 100644
--- a/src/afs/AIX/osi_machdep.h
+++ b/src/afs/AIX/osi_machdep.h
@@ -84,4 +84,6 @@
  * src/afs/AIX/osi_gcpags.c for how to look at the process list */
 #define osi_procname(procname, size) strncpy(procname, "", size)
 
+#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/DARWIN/osi_machdep.h b/src/afs/DARWIN/osi_machdep.h
index f7c53f2..84ac7eb 100644
--- a/src/afs/DARWIN/osi_machdep.h
+++ b/src/afs/DARWIN/osi_machdep.h
@@ -241,4 +241,6 @@
 #define osi_procname(procname, size) strncpy(procname, curproc->p_comm, size)
 #endif
 
+#define osi_GetTime(x) microtime(x)
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/DFBSD/osi_machdep.h b/src/afs/DFBSD/osi_machdep.h
new file mode 100644
index 0000000..d2dfc1c
--- /dev/null
+++ b/src/afs/DFBSD/osi_machdep.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2000, International Business Machines Corporation and others.
+ * All Rights Reserved.
+ *
+ * This software has been released under the terms of the IBM Public
+ * License.  For details, see the LICENSE file in the top-level source
+ * directory or online at http://www.openafs.org/dl/license10.html
+ */
+
+/*
+ *
+ * DFBSD OSI header file. Extends afs_osi.h.
+ *
+ * afs_osi.h includes this file, which is the only way this file should
+ * be included in a source file. This file can redefine macros declared in
+ * afs_osi.h.
+ */
+
+#ifndef _OSI_MACHDEP_H_
+#define _OSI_MACHDEP_H_
+
+#define osi_GetTime(x) microtime(x)
+
+#endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/FBSD/osi_machdep.h b/src/afs/FBSD/osi_machdep.h
index 67544e1..17baaa6 100644
--- a/src/afs/FBSD/osi_machdep.h
+++ b/src/afs/FBSD/osi_machdep.h
@@ -133,4 +133,6 @@
 
 #define osi_procname(procname, size) strncpy(procname, curproc->p_comm, size)
 
+#define osi_GetTime(x) microtime(x)
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/HPUX/osi_machdep.h b/src/afs/HPUX/osi_machdep.h
index bc90b81..ef4a1d6 100644
--- a/src/afs/HPUX/osi_machdep.h
+++ b/src/afs/HPUX/osi_machdep.h
@@ -121,4 +121,6 @@
 
 #define osi_procname(procname, size) strncpy(procname, "", size)
 
+#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/IRIX/osi_machdep.h b/src/afs/IRIX/osi_machdep.h
index 3c0f78d..a5ba80e 100644
--- a/src/afs/IRIX/osi_machdep.h
+++ b/src/afs/IRIX/osi_machdep.h
@@ -387,5 +387,10 @@
 
 #define osi_procname(procname, size) strncpy(procname, proc_name(curproc()), size)
 
+#ifdef _K64U64
+# define osi_GetTime(x) irix5_microtime((struct __irix5_timeval*)(x))
+#else
+# define osi_GetTime(x) microtime(x)
+#endif
 
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/SOLARIS/osi_machdep.h b/src/afs/SOLARIS/osi_machdep.h
index c34ffb5..a9bb4c5 100644
--- a/src/afs/SOLARIS/osi_machdep.h
+++ b/src/afs/SOLARIS/osi_machdep.h
@@ -125,4 +125,6 @@
 
 #define osi_procname(procname, size) strncpy(procname, PTOU(ttoproc(curthread))->u_comm, size)
 
+#define	osi_GetTime(x) uniqtime32(x)
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/config/param.arm_darwin_100.h b/src/config/param.arm_darwin_100.h
index 2344be0..2783416 100644
--- a/src/config/param.arm_darwin_100.h
+++ b/src/config/param.arm_darwin_100.h
@@ -133,7 +133,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.generic_fbsd.h b/src/config/param.generic_fbsd.h
index 6d16657..94ec068 100644
--- a/src/config/param.generic_fbsd.h
+++ b/src/config/param.generic_fbsd.h
@@ -68,7 +68,6 @@
 #define	AFS_UIOSYS		UIO_SYSSPACE
 #define	AFS_UIOUSER		UIO_USERSPACE
 #define	AFS_CLBYTES		CLBYTES
-#define	osi_GetTime(x)		microtime(x)
 #define AFS_KALLOC(x)		osi_fbsd_alloc((x), 1)
 #undef AFS_KALLOC_NOSLEEP
 #define	AFS_KALLOC_NOSLEEP(x) 	osi_fbsd_alloc((x), 0)
diff --git a/src/config/param.hp_ux102.h b/src/config/param.hp_ux102.h
index bf83b16..93fd121 100644
--- a/src/config/param.hp_ux102.h
+++ b/src/config/param.hp_ux102.h
@@ -63,7 +63,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.hp_ux110.h b/src/config/param.hp_ux110.h
index 8f0616b..ca541f9 100644
--- a/src/config/param.hp_ux110.h
+++ b/src/config/param.hp_ux110.h
@@ -64,7 +64,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.hp_ux1123.h b/src/config/param.hp_ux1123.h
index fd5246c..1ac65ab 100644
--- a/src/config/param.hp_ux1123.h
+++ b/src/config/param.hp_ux1123.h
@@ -69,7 +69,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.hp_ux11i.h b/src/config/param.hp_ux11i.h
index 074db76..9a76aec 100644
--- a/src/config/param.hp_ux11i.h
+++ b/src/config/param.hp_ux11i.h
@@ -68,7 +68,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.ia64_hpux1122.h b/src/config/param.ia64_hpux1122.h
index 82435e8..d659b49 100644
--- a/src/config/param.ia64_hpux1122.h
+++ b/src/config/param.ia64_hpux1122.h
@@ -68,7 +68,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.ia64_hpux1123.h b/src/config/param.ia64_hpux1123.h
index 00b513f..5931bc8 100644
--- a/src/config/param.ia64_hpux1123.h
+++ b/src/config/param.ia64_hpux1123.h
@@ -69,7 +69,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.nbsd15.h b/src/config/param.nbsd15.h
index 905a1c1..9714ee6 100644
--- a/src/config/param.nbsd15.h
+++ b/src/config/param.nbsd15.h
@@ -67,7 +67,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd16.h b/src/config/param.nbsd16.h
index bb88fe2..6694be2 100644
--- a/src/config/param.nbsd16.h
+++ b/src/config/param.nbsd16.h
@@ -68,7 +68,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd20.h b/src/config/param.nbsd20.h
index 07e7415..c294b77 100644
--- a/src/config/param.nbsd20.h
+++ b/src/config/param.nbsd20.h
@@ -74,7 +74,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd21.h b/src/config/param.nbsd21.h
index bb63588..7de8d32 100644
--- a/src/config/param.nbsd21.h
+++ b/src/config/param.nbsd21.h
@@ -74,7 +74,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd30.h b/src/config/param.nbsd30.h
index 95a1c02..2c67a8f 100644
--- a/src/config/param.nbsd30.h
+++ b/src/config/param.nbsd30.h
@@ -70,7 +70,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd40.h b/src/config/param.nbsd40.h
index adb4ae6..0761607 100644
--- a/src/config/param.nbsd40.h
+++ b/src/config/param.nbsd40.h
@@ -72,7 +72,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd50.h b/src/config/param.nbsd50.h
index e8c1f07..0be55a1 100644
--- a/src/config/param.nbsd50.h
+++ b/src/config/param.nbsd50.h
@@ -70,7 +70,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd60.h b/src/config/param.nbsd60.h
index 29519c8..f6a1aef 100644
--- a/src/config/param.nbsd60.h
+++ b/src/config/param.nbsd60.h
@@ -71,7 +71,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd70.h b/src/config/param.nbsd70.h
index 4395bab..ac5b98d 100644
--- a/src/config/param.nbsd70.h
+++ b/src/config/param.nbsd70.h
@@ -72,7 +72,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.ppc_darwin_70.h b/src/config/param.ppc_darwin_70.h
index e72b317..7a71a32 100644
--- a/src/config/param.ppc_darwin_70.h
+++ b/src/config/param.ppc_darwin_70.h
@@ -50,7 +50,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   kalloc(x)
 #define AFS_KFREE(x,y)  kfree(x,y)
 #define v_count         v_usecount
diff --git a/src/config/param.ppc_darwin_80.h b/src/config/param.ppc_darwin_80.h
index 8743530..7b4a4d1 100644
--- a/src/config/param.ppc_darwin_80.h
+++ b/src/config/param.ppc_darwin_80.h
@@ -75,7 +75,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.ppc_darwin_90.h b/src/config/param.ppc_darwin_90.h
index 01e3ad1..bce4212 100644
--- a/src/config/param.ppc_darwin_90.h
+++ b/src/config/param.ppc_darwin_90.h
@@ -80,7 +80,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.rs_aix42.h b/src/config/param.rs_aix42.h
index b993bb5..dc38566 100644
--- a/src/config/param.rs_aix42.h
+++ b/src/config/param.rs_aix42.h
@@ -68,7 +68,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
 #define	osi_GTime(x)	time	/* something for the silly time(0)?? */
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.rs_aix51.h b/src/config/param.rs_aix51.h
index 6e26501..08304c9 100644
--- a/src/config/param.rs_aix51.h
+++ b/src/config/param.rs_aix51.h
@@ -69,7 +69,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
 #define	osi_GTime(x)	time	/* something for the silly time(0)?? */
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.rs_aix52.h b/src/config/param.rs_aix52.h
index cd9f29d..4a64879 100644
--- a/src/config/param.rs_aix52.h
+++ b/src/config/param.rs_aix52.h
@@ -70,7 +70,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
 #define	osi_GTime(x)	time	/* something for the silly time(0)?? */
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.rs_aix53.h b/src/config/param.rs_aix53.h
index 8cec483..382af53 100644
--- a/src/config/param.rs_aix53.h
+++ b/src/config/param.rs_aix53.h
@@ -71,7 +71,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
 #define	osi_GTime(x)	time	/* something for the silly time(0)?? */
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.rs_aix61.h b/src/config/param.rs_aix61.h
index 85fbdc8..868fe9f 100644
--- a/src/config/param.rs_aix61.h
+++ b/src/config/param.rs_aix61.h
@@ -72,7 +72,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
 #define	osi_GTime(x)	time	/* something for the silly time(0)?? */
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.sgi_65.h b/src/config/param.sgi_65.h
index 3596196..bd40c4b 100644
--- a/src/config/param.sgi_65.h
+++ b/src/config/param.sgi_65.h
@@ -91,11 +91,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	MCLBYTES
 #define	AFS_MINCHANGE	2
-#ifdef _K64U64
-#define	osi_GetTime(x)	irix5_microtime((struct __irix5_timeval*)(x))
-#else
-#define	osi_GetTime(x)	microtime(x)
-#endif
 #define	AFS_KALLOC(n)	kmem_alloc(n, KM_SLEEP)
 #define	AFS_KALLOC_NOSLEEP(n)	kmem_alloc(n, KM_NOSLEEP)
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.sun4x_510.h b/src/config/param.sun4x_510.h
index 6a5e061..803ea2a 100644
--- a/src/config/param.sun4x_510.h
+++ b/src/config/param.sun4x_510.h
@@ -74,7 +74,6 @@
 #define	AFS_UIOUSER		UIO_USERSPACE
 #define	AFS_CLBYTES		MCLBYTES
 #define	AFS_MINCHANGE		2
-#define	osi_GetTime(x)		uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sun4x_511.h b/src/config/param.sun4x_511.h
index 256e89e..a6891bb 100644
--- a/src/config/param.sun4x_511.h
+++ b/src/config/param.sun4x_511.h
@@ -77,7 +77,6 @@
 #define	AFS_UIOUSER		UIO_USERSPACE
 #define	AFS_CLBYTES		MCLBYTES
 #define	AFS_MINCHANGE		2
-#define	osi_GetTime(x)		uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sun4x_58.h b/src/config/param.sun4x_58.h
index 4de40e7..df29054 100644
--- a/src/config/param.sun4x_58.h
+++ b/src/config/param.sun4x_58.h
@@ -70,7 +70,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	MCLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sun4x_59.h b/src/config/param.sun4x_59.h
index ad50f36..6ee6d6b 100644
--- a/src/config/param.sun4x_59.h
+++ b/src/config/param.sun4x_59.h
@@ -71,7 +71,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	MCLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sunx86_510.h b/src/config/param.sunx86_510.h
index e0ce387..371e5ee 100644
--- a/src/config/param.sunx86_510.h
+++ b/src/config/param.sunx86_510.h
@@ -84,7 +84,6 @@
 #define	AFS_UIOUSER		UIO_USERSPACE
 #define	AFS_CLBYTES		MCLBYTES
 #define	AFS_MINCHANGE		2
-#define	osi_GetTime(x)		uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sunx86_511.h b/src/config/param.sunx86_511.h
index 1ac462e..b20c0d0 100644
--- a/src/config/param.sunx86_511.h
+++ b/src/config/param.sunx86_511.h
@@ -87,7 +87,6 @@
 #define	AFS_UIOUSER		UIO_USERSPACE
 #define	AFS_CLBYTES		MCLBYTES
 #define	AFS_MINCHANGE		2
-#define	osi_GetTime(x)		uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sunx86_58.h b/src/config/param.sunx86_58.h
index 9f9ffec..e9969d3 100644
--- a/src/config/param.sunx86_58.h
+++ b/src/config/param.sunx86_58.h
@@ -81,7 +81,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	MCLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	uniqtime32(x)
 
 #define	AFS_KALLOC(n)	kmem_alloc(n, KM_SLEEP)
 #define AFS_KALLOC_NOSLEEP(n)   kmem_alloc(n, KM_NOSLEEP)
diff --git a/src/config/param.sunx86_59.h b/src/config/param.sunx86_59.h
index 4875e3c..0c072f7 100644
--- a/src/config/param.sunx86_59.h
+++ b/src/config/param.sunx86_59.h
@@ -82,7 +82,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	MCLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	uniqtime32(x)
 
 #define	AFS_KALLOC(n)	kmem_alloc(n, KM_SLEEP)
 #define AFS_KALLOC_NOSLEEP(n)   kmem_alloc(n, KM_NOSLEEP)
diff --git a/src/config/param.x86_darwin_100.h b/src/config/param.x86_darwin_100.h
index 9d8de10..554eb24 100644
--- a/src/config/param.x86_darwin_100.h
+++ b/src/config/param.x86_darwin_100.h
@@ -113,7 +113,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_110.h b/src/config/param.x86_darwin_110.h
index eae5983..ca893b9 100644
--- a/src/config/param.x86_darwin_110.h
+++ b/src/config/param.x86_darwin_110.h
@@ -116,7 +116,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_120.h b/src/config/param.x86_darwin_120.h
index da6f48a..a6c881a 100644
--- a/src/config/param.x86_darwin_120.h
+++ b/src/config/param.x86_darwin_120.h
@@ -119,7 +119,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_130.h b/src/config/param.x86_darwin_130.h
index a29a938..7571e05 100644
--- a/src/config/param.x86_darwin_130.h
+++ b/src/config/param.x86_darwin_130.h
@@ -122,7 +122,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_140.h b/src/config/param.x86_darwin_140.h
index 83e009f..989e39b 100644
--- a/src/config/param.x86_darwin_140.h
+++ b/src/config/param.x86_darwin_140.h
@@ -125,7 +125,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_150.h b/src/config/param.x86_darwin_150.h
index 6c0df11..666c1de 100644
--- a/src/config/param.x86_darwin_150.h
+++ b/src/config/param.x86_darwin_150.h
@@ -128,7 +128,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_160.h b/src/config/param.x86_darwin_160.h
index 0648752..f2d786a 100644
--- a/src/config/param.x86_darwin_160.h
+++ b/src/config/param.x86_darwin_160.h
@@ -131,7 +131,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_170.h b/src/config/param.x86_darwin_170.h
index b9be380..99c8cd7 100644
--- a/src/config/param.x86_darwin_170.h
+++ b/src/config/param.x86_darwin_170.h
@@ -134,7 +134,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_180.h b/src/config/param.x86_darwin_180.h
index bc671a8..6b6ac01 100644
--- a/src/config/param.x86_darwin_180.h
+++ b/src/config/param.x86_darwin_180.h
@@ -137,7 +137,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_190.h b/src/config/param.x86_darwin_190.h
index 82e69dc..bd4e302 100644
--- a/src/config/param.x86_darwin_190.h
+++ b/src/config/param.x86_darwin_190.h
@@ -142,7 +142,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_80.h b/src/config/param.x86_darwin_80.h
index 2a079a7..fc70f98 100644
--- a/src/config/param.x86_darwin_80.h
+++ b/src/config/param.x86_darwin_80.h
@@ -75,7 +75,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_90.h b/src/config/param.x86_darwin_90.h
index 6814c28..7f832f9 100644
--- a/src/config/param.x86_darwin_90.h
+++ b/src/config/param.x86_darwin_90.h
@@ -80,7 +80,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
From f18dcd96d063320cf37ace3b809257e93f811f2d Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Tue, 02 Jun 2020 13:37:00 -0500
Subject: [PATCH] afs: Always define our own osi_timeval32_t

Since OpenAFS 1.0, osi_GetTime has taken a timeval-like pointer, which
contains 32-bit fields (the actual type has been called either
osi_timeval_t or osi_timeval32_t over time). For platforms that have a
native timeval-like type with 32-bit fields, we just define
osi_timeval32_t to that type, and elsewhere we define our own struct
to be osi_timeval32_t. For platforms that use the native timeval, we
can then define osi_GetTime() to just be, e.g., microtime().

This approach is difficult to maintain, though, because we must keep
track of whether 'struct timeval' contains 32-bit fields on each
platform, which can depend on many factors. It's easy to make mistakes
(the current tree already contains mistakes), and there's not much
benefit.

To avoid all of this, just always define osi_timeval32_t to be our own
struct with afs_int32 fields, and provide definitions for osi_GetTime
that convert from the native time struct to our osi_timeval32_t. This
does mean that for some platforms we do an unnecessary type
conversion, but this is a small price to pay for more straightforward
and maintainable code.

To be a little more sure that our types are correct, change
osi_GetTime to be defined as an inline function instead of a macro.

At the same time, do a similar conversion for the KERNEL
implementation of the rx clock_GetTime function. Get rid of
platform-specific mess, and do a straightforward type conversion
between osi_timeval32_t and struct clock in an inline function.

Reviewed-on: https://gerrit.openafs.org/14238
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
(cherry picked from commit eccd4b9778014c36a4b3af6d9e80194066bd2195)

Change-Id: Ia6ccc7ff3e3a7cfb346449c1335e7a045688aebf
---

diff --git a/src/afs/AIX/osi_machdep.h b/src/afs/AIX/osi_machdep.h
index 23060fd..0c79c03 100644
--- a/src/afs/AIX/osi_machdep.h
+++ b/src/afs/AIX/osi_machdep.h
@@ -84,6 +84,13 @@
  * src/afs/AIX/osi_gcpags.c for how to look at the process list */
 #define osi_procname(procname, size) strncpy(procname, "", size)
 
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timestruc_t now;
+    curtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_nsec / 1000;
+}
 
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/DARWIN/osi_machdep.h b/src/afs/DARWIN/osi_machdep.h
index 84ac7eb..e736c2c 100644
--- a/src/afs/DARWIN/osi_machdep.h
+++ b/src/afs/DARWIN/osi_machdep.h
@@ -241,6 +241,13 @@
 #define osi_procname(procname, size) strncpy(procname, curproc->p_comm, size)
 #endif
 
-#define osi_GetTime(x) microtime(x)
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    microtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
 
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/DFBSD/osi_machdep.h b/src/afs/DFBSD/osi_machdep.h
index d2dfc1c..4c6a80d 100644
--- a/src/afs/DFBSD/osi_machdep.h
+++ b/src/afs/DFBSD/osi_machdep.h
@@ -19,6 +19,13 @@
 #ifndef _OSI_MACHDEP_H_
 #define _OSI_MACHDEP_H_
 
-#define osi_GetTime(x) microtime(x)
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    microtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
 
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/FBSD/osi_machdep.h b/src/afs/FBSD/osi_machdep.h
index 17baaa6..d9d39f0 100644
--- a/src/afs/FBSD/osi_machdep.h
+++ b/src/afs/FBSD/osi_machdep.h
@@ -133,6 +133,13 @@
 
 #define osi_procname(procname, size) strncpy(procname, curproc->p_comm, size)
 
-#define osi_GetTime(x) microtime(x)
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    microtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
 
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/HPUX/osi_machdep.h b/src/afs/HPUX/osi_machdep.h
index ef4a1d6..f2afe21 100644
--- a/src/afs/HPUX/osi_machdep.h
+++ b/src/afs/HPUX/osi_machdep.h
@@ -121,6 +121,13 @@
 
 #define osi_procname(procname, size) strncpy(procname, "", size)
 
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    uniqtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
 
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/IRIX/osi_machdep.h b/src/afs/IRIX/osi_machdep.h
index a5ba80e..56defec 100644
--- a/src/afs/IRIX/osi_machdep.h
+++ b/src/afs/IRIX/osi_machdep.h
@@ -387,10 +387,18 @@
 
 #define osi_procname(procname, size) strncpy(procname, proc_name(curproc()), size)
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
 #ifdef _K64U64
-# define osi_GetTime(x) irix5_microtime((struct __irix5_timeval*)(x))
+    struct __irix5_timeval now;
+    irix5_microtime(&now);
 #else
-# define osi_GetTime(x) microtime(x)
+    struct timeval now;
+    microtime(&now);
 #endif
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
 
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/LINUX/osi_machdep.h b/src/afs/LINUX/osi_machdep.h
index f1828c9..fe48781 100644
--- a/src/afs/LINUX/osi_machdep.h
+++ b/src/afs/LINUX/osi_machdep.h
@@ -99,23 +99,23 @@
 #endif
 
 #if defined(HAVE_LINUX_KTIME_GET_REAL_TS64)
-# define osi_GetTime(V)                                      \
-    do {                                                     \
-	struct timespec64 __afs_tv;                          \
-	ktime_get_real_ts64(&__afs_tv);                      \
-	(V)->tv_sec = (afs_int32)__afs_tv.tv_sec;            \
-	(V)->tv_usec = (afs_int32)__afs_tv.tv_nsec / 1000;   \
-    } while(0)
-#elif defined(AFS_LINUX_64BIT_KERNEL) || !defined(HAVE_LINUX_TIME_T)
-# define osi_GetTime(V)                                 \
-    do {                                               \
-       struct timeval __afs_tv;                              \
-       do_gettimeofday(&__afs_tv);                           \
-       (V)->tv_sec = (afs_int32)__afs_tv.tv_sec;             \
-       (V)->tv_usec = (afs_int32)__afs_tv.tv_usec;           \
-    } while (0)
+static inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timespec64 now;
+    ktime_get_real_ts64(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_nsec / 1000;
+}
 #else
-# define osi_GetTime(V) do_gettimeofday((V))
+static inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    do_gettimeofday(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
 #endif
 
 #undef gop_lookupname
diff --git a/src/afs/NBSD/osi_machdep.h b/src/afs/NBSD/osi_machdep.h
index 2ded63d..43aa621 100644
--- a/src/afs/NBSD/osi_machdep.h
+++ b/src/afs/NBSD/osi_machdep.h
@@ -96,7 +96,6 @@
 
 /* time */
 #define	afs_hz		hz
-#define osi_GetTime(x)	getmicrotime(x)
 #define osi_Time()      time_second
 
 /* str */
@@ -207,4 +206,13 @@
 
 #define AFS_USE_NBSD_NAMECACHE 0
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    getmicrotime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/OBSD/osi_machdep.h b/src/afs/OBSD/osi_machdep.h
index aec0f69..1179e27 100644
--- a/src/afs/OBSD/osi_machdep.h
+++ b/src/afs/OBSD/osi_machdep.h
@@ -97,7 +97,6 @@
 
 /* time */
 #define	afs_hz		hz
-#define osi_GetTime(x)	microtime(x)
 extern time_t osi_Time();
 
 /* str */
@@ -243,4 +242,13 @@
 
 #define osi_procname(procname, size) strncpy(procname, curproc->p_comm, size)
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    microtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/SOLARIS/osi_machdep.h b/src/afs/SOLARIS/osi_machdep.h
index a9bb4c5..45ee8de 100644
--- a/src/afs/SOLARIS/osi_machdep.h
+++ b/src/afs/SOLARIS/osi_machdep.h
@@ -125,6 +125,13 @@
 
 #define osi_procname(procname, size) strncpy(procname, PTOU(ttoproc(curthread))->u_comm, size)
 
-#define	osi_GetTime(x) uniqtime32(x)
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval32 now;
+    uniqtime32(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
 
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/UKERNEL/afs_usrops.c b/src/afs/UKERNEL/afs_usrops.c
index 7720800..c1e7fbd 100644
--- a/src/afs/UKERNEL/afs_usrops.c
+++ b/src/afs/UKERNEL/afs_usrops.c
@@ -936,13 +936,6 @@
 }
 
 int
-osi_GetTime(struct timeval *tv)
-{
-    gettimeofday(tv, NULL);
-    return 0;
-}
-
-int
 osi_Active(struct vcache *avc)
 {
     AFS_STATCNT(osi_Active);
diff --git a/src/afs/UKERNEL/osi_machdep.h b/src/afs/UKERNEL/osi_machdep.h
index 7e11e4d..161fe7e 100644
--- a/src/afs/UKERNEL/osi_machdep.h
+++ b/src/afs/UKERNEL/osi_machdep.h
@@ -83,4 +83,14 @@
 #define osi_curcred()    get_user_struct()->u_cred
 
 #define osi_procname(procname, size) strncpy(procname, "(unknown)", size)
+
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    gettimeofday(&now, NULL);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/afs_osi.h b/src/afs/afs_osi.h
index f64aa87..945c1e9 100644
--- a/src/afs/afs_osi.h
+++ b/src/afs/afs_osi.h
@@ -183,16 +183,10 @@
  * different platforms.  We require a fixed size timeval, at least for the
  * xstats.
  */
-#if defined(AFS_HPUX_ENV) || defined(AFS_LINUX_64BIT_KERNEL) || (defined(AFS_LINUX26_ENV) && !defined(HAVE_LINUX_TIME_T)) || (defined(AFS_SGI61_ENV) && defined(KERNEL) && defined(_K64U64))
 typedef struct {
     afs_int32 tv_sec;
     afs_int32 tv_usec;
 } osi_timeval32_t;
-#elif defined(AFS_SUN5_ENV)
-typedef struct timeval32 osi_timeval32_t;
-#else
-typedef struct timeval osi_timeval32_t;
-#endif /* AFS_SGI61_ENV */
 
 #ifndef UKERNEL
 #define osi_getpid() 		getpid()
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index b6998ab..748b2f5 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -971,7 +971,6 @@
 extern void uafs_Shutdown(void);
 extern void osi_ReleaseVM(struct vcache *avc, int len,
 			  afs_ucred_t *credp);
-extern int osi_GetTime(struct timeval *tv);
 extern int iodone(struct usr_buf *bp);
 extern int usr_ioctl(void);
 extern int lookupname(char *fnamep, int segflg, int followlink,
diff --git a/src/rx/rx_clock.h b/src/rx/rx_clock.h
index 8aac378..a836fab 100644
--- a/src/rx/rx_clock.h
+++ b/src/rx/rx_clock.h
@@ -94,21 +94,14 @@
 #endif /* AFS_USE_GETTIMEOFDAY || AFS_PTHREAD_ENV */
 #else /* KERNEL */
 #define clock_Init()
-#if defined(AFS_SGI61_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_LINUX_64BIT_KERNEL)
-#define clock_GetTime(cv) osi_GetTime((osi_timeval32_t *)cv)
-#else
-#if (defined(AFS_AIX51_ENV) && defined(AFS_64BIT_KERNEL)) || (defined(AFS_DARWIN100_ENV) && defined(__amd64__)) || defined(AFS_XBSD_ENV)
-#define        clock_GetTime(cv)                               \
-    BEGIN                                              \
-       struct timeval tv;                              \
-       osi_GetTime(&tv);                        \
-       (cv)->sec = (afs_int32)tv.tv_sec;               \
-       (cv)->usec = (afs_int32)tv.tv_usec;             \
-    END
-#else /* defined(AFS_AIX51_ENV) && defined(AFS_64BIT_KERNEL) */
-#define clock_GetTime(cv) osi_GetTime((osi_timeval32_t *)(cv))
-#endif /* defined(AFS_AIX51_ENV) && defined(AFS_64BIT_KERNEL) */
-#endif
+static_inline void
+clock_GetTime(struct clock *cv)
+{
+    osi_timeval32_t now;
+    osi_GetTime(&now);
+    cv->sec = now.tv_sec;
+    cv->usec = now.tv_usec;
+}
 #define clock_Sec() osi_Time()
 #define	clock_NewTime()		/* don't do anything; clock is fast enough in kernel */
 #endif /* KERNEL */
From 843b79a2ea922139ff5f765e9717d13defeb3224 Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Thu, 02 Jun 2022 11:11:24 -0600
Subject: [PATCH] Remove AFS_PARISC_LINUX24_ENV references

Since commit 91713206 (Remove LINUX24 from src/afs),
AFS_PARISC_LINUX24_ENV is never defined. Remove references to it.

Reviewed-on: https://gerrit.openafs.org/14472
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit e0e0b3cea6305cdbccc71039a05d6121c32c51cf)

Change-Id: I4871f5ba6018ab47c78d3f07d4665b5a2676102f
---

diff --git a/src/lwp/lwp.c b/src/lwp/lwp.c
index 7599475..87417d7 100644
--- a/src/lwp/lwp.c
+++ b/src/lwp/lwp.c
@@ -52,7 +52,7 @@
 #define MAXINT     (~(1<<((sizeof(int)*8)-1)))
 #define MINSTACK   44
 
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
 #define MINFRAME 128
 #define STACK_ALIGN 8
 #else
@@ -373,10 +373,6 @@
 	PRE_Block = 1;
 #endif
 	lwp_cpptr = temp;
-#if defined(AFS_PARISC_LINUX24_ENV)
-	savecontext(Create_Process_Part2, &temp2->context,
-		    stackptr + MINFRAME);
-#else
 #ifdef __hp9000s800
 	savecontext(Create_Process_Part2, &temp2->context,
 		    stackptr + MINFRAME);
@@ -402,7 +398,6 @@
 #endif /* AFS_S390_LINUX20_ENV */
 #endif /* AFS_SPARC64_LINUX20_ENV || AFS_SPARC_LINUX20_ENV */
 #endif /* AFS_SGI62_ENV */
-#endif
 #endif
 	/* End of gross hack */
 
@@ -519,7 +514,7 @@
 	    pid->status = DESTROYED;
 	    move(pid, &runnable[pid->priority], &blocked);
 	    temp = lwp_cpptr;
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
 	    savecontext(Dispatcher, &(temp->context),
 			&(LWPANCHOR.dsptchstack[MINFRAME]));
 #elif defined(AFS_SGI62_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
@@ -909,7 +904,7 @@
      * the guard word at the front of the stack being damaged and
      * for the stack pointer being below the front of the stack.
      * WARNING!  This code assumes that stacks grow downward. */
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
     /* Fix this (stackcheck at other end of stack?) */
     if (lwp_cpptr != NULL && lwp_cpptr->stack != NULL
 	&& (lwp_cpptr->stackcheck !=
@@ -1052,7 +1047,7 @@
     temp->index = lwp_nextindex++;
     temp->stack = stack;
     temp->stacksize = stacksize;
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
     if (temp->stack != NULL)
 	temp->stackcheck = *(int *)((temp->stack) + stacksize - 4);
 #else
@@ -1107,7 +1102,7 @@
 	for (i = 0; i < stacksize; i++)
 	    stackptr[i] = i & 0xff;
     else
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
 	*(afs_int32 *) (stackptr + stacksize - 4) = STACKMAGIC;
 #else
 	*(afs_int32 *) stackptr = STACKMAGIC;
@@ -1120,7 +1115,7 @@
 {
     int i;
 
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
     if (*(afs_int32 *) (stackptr + stacksize - 4) == STACKMAGIC)
 	return 0;
     else {
diff --git a/src/lwp/process.c b/src/lwp/process.c
index 9540571..c2ba28c 100644
--- a/src/lwp/process.c
+++ b/src/lwp/process.c
@@ -88,7 +88,7 @@
 # else
 #  define LWP_SP JB_SP
 # endif
-#elif	defined(AFS_HPUX_ENV) || defined(AFS_PARISC_LINUX24_ENV)
+#elif	defined(AFS_HPUX_ENV)
 #define	LWP_SP	1
 #elif	defined(AFS_LINUX20_ENV)
 #if defined(AFS_PPC_LINUX20_ENV) || defined(AFS_PPC64_LINUX20_ENV)
@@ -107,8 +107,6 @@
 #elif defined(AFS_ALPHA_LINUX20_ENV)
 #define LWP_SP 8
 #define LWP_FP 7
-#elif defined(AFS_PARISC_LINUX24_ENV)
-#define LWP_SP 19
 #else
 #error Unsupported linux LWP system type.
 #endif
diff --git a/src/venus/kdump.c b/src/venus/kdump.c
index 3494051..f33f26a 100644
--- a/src/venus/kdump.c
+++ b/src/venus/kdump.c
@@ -2602,13 +2602,8 @@
 	   vep->i_dev, vep->i_rdev, vep->i_sb);
 #endif /* AFS_LINUX26_ENV */
 #ifdef AFS_LINUX24_ENV
-#ifdef AFS_PARISC_LINUX24_ENV
-    printf("\ti_sem: count=%d, wait=0x%x\n", vep->i_sem.count,
-	   vep->i_sem.wait);
-#else
     printf("\ti_sem: count=%d, sleepers=%d, wait=0x%x\n", vep->i_sem.count,
 	   vep->i_sem.sleepers, vep->i_sem.wait);
-#endif
 #else
     printf("\ti_sem: count=%d, waking=%d, wait=0x%x\n", vep->i_sem.count,
 	   vep->i_sem.waking, vep->i_sem.wait);
From 5f532b6226800b63fc4dd1230171fd8ff73c942c Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 02 Jun 2022 11:19:32 -0600
Subject: [PATCH] Change AFS*_LINUXnn_ENV to AFS*_LINUX_ENV

The minimum Linux kernel that is now supported is linux-2.6.18.  The
Linux versioned preprocessor macros AFS_*LINUXnn_ENV are no longer
needed to distinguish the different levels of Linux and can be merged
into just a single set of macros.

Perform a global change of _LINUX\d+_ENV to _LINUX_ENV. e.g.
   AFS_LINUX24_ENV       -> AFS_LINUX_ENV
   AFS_USR_LINUX24_ENV   -> AFS_USR_LINUX_ENV
   AFS_AMD64_LINUX20_ENV -> AFS_AMD64_LINUX_ENV

Replace the multiple definitions for the versioned 'AFS*_LINUXnn_ENV'
with just single non-version definitions 'AFS*_LINUX_ENV'.

Apart from replacing the now-redundant #define directives and tidying up
a few comments at the close of a preprocessor block to match their
current form, this commit was done using a mechanical change of the
variable names and did not reduce preprocessor statements that could now
be combined or eliminated.  Nor does this commit remove dead code.  A
follow-up commit (Cleanup AFS_*LINUX_ENV usage) will handle these
changes.

The updates should have no functional changes.

Reviewed-on: https://gerrit.openafs.org/14387
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 6329a523f6305541871bc3d1694065e7b17abe77)

[cwills@sinenomine.net] Conflicts due to:
   'afs: Set AFS_VFSFSID to a numerical value' is already in 1.8.x
   'Linux 5.15: Convert osi_Msg macro to a function' is already in 1.8.x
   'fsint: remove dead code' is not in 1.8.x (removes fsint/afsaux.c)
   'Remove rpctestlib' is not in 1.8.x (removes rpc_test_procs.c)

Change-Id: I19da50622f63db0fcad7acd834559c538e6030be
---

diff --git a/src/JAVA/libjafs/ACL.c b/src/JAVA/libjafs/ACL.c
index b818754..4b364ff 100644
--- a/src/JAVA/libjafs/ACL.c
+++ b/src/JAVA/libjafs/ACL.c
@@ -86,11 +86,11 @@
     params.out = buffer;
     params.out_size = ACL_LEN; 
 
-#if defined(AFS_PPC64_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_PPC64_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     if(pioctl(path, VIOCGETAL, &params, 1)) {
-#else /* AFS_PPC_LINUX20_ENV */
+#else /* AFS_PPC_LINUX_ENV */
     if(syscall(AFS_SYSCALL, AFSCALL_PIOCTL, path, VIOCGETAL, &params, 1)) {
-#endif /* AFS_PPC_LINUX20_ENV */
+#endif /* AFS_PPC_LINUX_ENV */
       fprintf(stderr, "ERROR: ACL::getACL -> VIOCGETAL failed: %d, path: %s\n", errno, path);
       free(buffer);
       return NULL;
@@ -117,11 +117,11 @@
     params.out = NULL;
     params.out_size = 0;
 
-#if defined(AFS_PPC64_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_PPC64_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     if(pioctl(path, VIOCSETAL, &params, 1)) {
-#else /* AFS_PPC_LINUX20_ENV */
+#else /* AFS_PPC_LINUX_ENV */
     if(syscall(AFS_SYSCALL, AFSCALL_PIOCTL, path, VIOCSETAL, &params, 1)) {
-#endif /* AFS_PPC_LINUX20_ENV */
+#endif /* AFS_PPC_LINUX_ENV */
       fprintf(stderr, "ERROR: ACL::setACL -> VIOCSETAL failed: %d, path: %s\n", errno, path);
       return JNI_FALSE;
     }
diff --git a/src/afs/LINUX/osi_groups.c b/src/afs/LINUX/osi_groups.c
index a52cc68..87d149f 100644
--- a/src/afs/LINUX/osi_groups.c
+++ b/src/afs/LINUX/osi_groups.c
@@ -340,7 +340,7 @@
     return (-code);
 }
 
-# if defined(AFS_PPC64_LINUX20_ENV)
+# if defined(AFS_PPC64_LINUX_ENV)
 /* Intercept the uid16 system call as used by 32bit programs. */
 extern asmlinkage long (*sys32_setgroupsp)(int gidsetsize, gid_t *grouplist);
 asmlinkage long afs32_xsetgroups(int gidsetsize, gid_t *grouplist)
@@ -370,15 +370,15 @@
 }
 # endif
 
-# if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_AMD64_LINUX20_ENV)
+# if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
 /* Intercept the uid16 system call as used by 32bit programs. */
-#  ifdef AFS_AMD64_LINUX20_ENV
+#  ifdef AFS_AMD64_LINUX_ENV
 extern asmlinkage long (*sys32_setgroupsp) (int gidsetsize, u16 * grouplist);
-#  endif /* AFS_AMD64_LINUX20_ENV */
-#  ifdef AFS_SPARC64_LINUX26_ENV
+#  endif /* AFS_AMD64_LINUX_ENV */
+#  ifdef AFS_SPARC64_LINUX_ENV
 extern asmlinkage int (*sys32_setgroupsp) (int gidsetsize,
 					   __kernel_gid32_t * grouplist);
-#  endif /* AFS_SPARC64_LINUX26_ENV */
+#  endif /* AFS_SPARC64_LINUX_ENV */
 asmlinkage long
 afs32_xsetgroups(int gidsetsize, u16 * grouplist)
 {
@@ -407,13 +407,13 @@
 }
 
 /* Intercept the uid32 system call as used by 32bit programs. */
-#  ifdef AFS_AMD64_LINUX20_ENV
+#  ifdef AFS_AMD64_LINUX_ENV
 extern asmlinkage long (*sys32_setgroups32p) (int gidsetsize, gid_t * grouplist);
-#  endif /* AFS_AMD64_LINUX20_ENV */
-#  ifdef AFS_SPARC64_LINUX26_ENV
+#  endif /* AFS_AMD64_LINUX_ENV */
+#  ifdef AFS_SPARC64_LINUX_ENV
 extern asmlinkage int (*sys32_setgroups32p) (int gidsetsize,
 					     __kernel_gid32_t * grouplist);
-#  endif /* AFS_SPARC64_LINUX26_ENV */
+#  endif /* AFS_SPARC64_LINUX_ENV */
 asmlinkage long
 afs32_xsetgroups32(int gidsetsize, gid_t * grouplist)
 {
diff --git a/src/afs/LINUX/osi_ioctl.c b/src/afs/LINUX/osi_ioctl.c
index 7d35567..327520c 100644
--- a/src/afs/LINUX/osi_ioctl.c
+++ b/src/afs/LINUX/osi_ioctl.c
@@ -21,7 +21,7 @@
 #include <linux/unistd.h>		/* For syscall numbers. */
 #include <linux/mm.h>
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 #include <asm/ia32_unistd.h>
 #endif
 
diff --git a/src/afs/LINUX/osi_machdep.h b/src/afs/LINUX/osi_machdep.h
index fe48781..c120579 100644
--- a/src/afs/LINUX/osi_machdep.h
+++ b/src/afs/LINUX/osi_machdep.h
@@ -162,35 +162,35 @@
  * Test to see for 64/32bit compatibility mode
  * Return non-zero if in a 64bit kernel and handing a 32bit syscall
  */
-#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX20_ENV) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX_ENV) && !defined(AFS_IA64_LINUX_ENV)
 static inline int
 afs_in_compat_syscall(void)
 {
 # if defined(HAVE_LINUX_IN_COMPAT_SYSCALL)
     return in_compat_syscall();
-# elif defined(AFS_SPARC64_LINUX26_ENV)
+# elif defined(AFS_SPARC64_LINUX_ENV)
     return test_thread_flag(TIF_32BIT);
-# elif defined(AFS_SPARC64_LINUX24_ENV)
+# elif defined(AFS_SPARC64_LINUX_ENV)
     return (current->thread.flags & SPARC_FLAG_32BIT) != 0;
-# elif defined(AFS_SPARC64_LINUX20_ENV)
+# elif defined(AFS_SPARC64_LINUX_ENV)
     return (current->tss.flags & SPARC_FLAG_32BIT) != 0;
-# elif defined(AFS_AMD64_LINUX26_ENV)
+# elif defined(AFS_AMD64_LINUX_ENV)
     return test_thread_flag(TIF_IA32);
-# elif defined(AFS_AMD64_LINUX20_ENV)
+# elif defined(AFS_AMD64_LINUX_ENV)
     return (current->thread.flags & THREAD_IA32) != 0;
-# elif defined(AFS_PPC64_LINUX26_ENV)
+# elif defined(AFS_PPC64_LINUX_ENV)
 #  if defined(STRUCT_TASK_STRUCT_HAS_THREAD_INFO)
     return (current->thread_info->flags & _TIF_32BIT) != 0;
 #  else
     return (task_thread_info(current)->flags & _TIF_32BIT) != 0;
 #  endif
-# elif defined(AFS_PPC64_LINUX20_ENV)
+# elif defined(AFS_PPC64_LINUX_ENV)
    return (current->thread.flags & PPC_FLAG_32BIT) != 0;
-# elif defined(AFS_S390X_LINUX26_ENV)
+# elif defined(AFS_S390X_LINUX_ENV)
    return test_thread_flag(TIF_31BIT);
-# elif defined(AFS_S390X_LINUX20_ENV)
+# elif defined(AFS_S390X_LINUX_ENV)
   return (current->thread.flags & S390_FLAG_31BIT) != 0;
-# elif defined(AFS_ARM64_LINUX26_ENV)
+# elif defined(AFS_ARM64_LINUX_ENV)
   return is_compat_task();
 # else
 #  error afs_in_compat_syscall not done for this linux
@@ -364,7 +364,7 @@
 
 #define OSIFILE_INODE(a) FILE_INODE((a)->filp)
 
-#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX20_ENV) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX_ENV) && !defined(AFS_IA64_LINUX_ENV)
 # define NEED_IOCTL32
 #endif
 
@@ -402,7 +402,7 @@
 
 #define osi_InitGlock()
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 /* RHEL5 beta's kernel doesn't define these. They aren't gonna change, so... */
 
 # ifndef __NR_ia32_afs_syscall
diff --git a/src/afs/LINUX/osi_module.c b/src/afs/LINUX/osi_module.c
index 47e32cf..79ba57c 100644
--- a/src/afs/LINUX/osi_module.c
+++ b/src/afs/LINUX/osi_module.c
@@ -21,7 +21,7 @@
 #include <linux/unistd.h>		/* For syscall numbers. */
 #include <linux/mm.h>
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 #include <asm/ia32_unistd.h>
 #endif
 
diff --git a/src/afs/LINUX/osi_pag_module.c b/src/afs/LINUX/osi_pag_module.c
index ac4f800..e832c5a 100644
--- a/src/afs/LINUX/osi_pag_module.c
+++ b/src/afs/LINUX/osi_pag_module.c
@@ -20,7 +20,7 @@
 #include <linux/unistd.h>		/* For syscall numbers. */
 #include <linux/mm.h>
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 #include <asm/ia32_unistd.h>
 #endif
 
diff --git a/src/afs/LINUX/osi_probe.c b/src/afs/LINUX/osi_probe.c
index fc8153c..87c506f 100644
--- a/src/afs/LINUX/osi_probe.c
+++ b/src/afs/LINUX/osi_probe.c
@@ -74,11 +74,11 @@
 #include <linux/unistd.h>
 #include <linux/mm.h>
 
-#if defined(AFS_PPC64_LINUX26_ENV)
+#if defined(AFS_PPC64_LINUX_ENV)
 # include <asm/abs_addr.h>
 #endif
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 # include <asm/ia32_unistd.h>
 #endif
 
@@ -89,9 +89,9 @@
 #endif
 
 /* lower bound of valid kernel text pointers */
-#ifdef AFS_IA64_LINUX20_ENV
+#ifdef AFS_IA64_LINUX_ENV
 #define ktxt_lower_bound (((unsigned long)&kernel_thread )  & 0xfff00000L)
-#elif defined(AFS_PPC64_LINUX20_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV)
 #define ktxt_lower_bound (KERNELBASE)
 #else
 #define ktxt_lower_bound (((unsigned long)&kernel_thread )  & ~0xfffffL)
@@ -100,7 +100,7 @@
 /* On SPARC64 and S390X, sys_call_table contains 32-bit entries
  * even though pointers are 64 bit quantities.
  */
-#if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_S390X_LINUX24_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
 #define SYSCALLTYPE unsigned int
 #define PROBETYPE int
 #else
@@ -108,7 +108,7 @@
 #define PROBETYPE long
 #endif
 
-#if defined(AFS_S390X_LINUX20_ENV) && !defined(AFS_S390X_LINUX26_ENV) 
+#if defined(AFS_S390X_LINUX_ENV) && !defined(AFS_S390X_LINUX_ENV) 
 #define _SS(x) ((x) << 1)
 #define _SX(x) ((x) &~ 1)
 #else
@@ -299,7 +299,7 @@
     int debug_ignore_NR[4];         /* syscalls to ignore for debugging */
 } probectl;
 
-#if defined(AFS_I386_LINUX26_ENV) || defined(AFS_AMD64_LINUX26_ENV)
+#if defined(AFS_I386_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
 static int check_access(unsigned long, int);
 static int check_table_readable(probectl *, PROBETYPE *);
 #endif
@@ -310,13 +310,13 @@
 /* syscall pairs/triplets to probe */
 /* On PPC64 and SPARC64, we need to omit the ones that might match both tables */
 static tryctl main_try[] = {
-#if !defined(AFS_PPC64_LINUX20_ENV) && !defined(AFS_SPARC64_LINUX20_ENV)
+#if !defined(AFS_PPC64_LINUX_ENV) && !defined(AFS_SPARC64_LINUX_ENV)
 #if defined(EXPORTED_SYS_CHDIR)
     { "scan: close+chdir+write", __NR_close, &sys_close, __NR_chdir, &sys_chdir, __NR_write, &sys_write },
 #endif
 #endif
     { "scan: close+wait4",       __NR_close, &sys_close, __NR_wait4, &sys_wait4, -1,         0          },
-#if !defined(AFS_PPC64_LINUX20_ENV) && !defined(AFS_SPARC64_LINUX20_ENV)
+#if !defined(AFS_PPC64_LINUX_ENV) && !defined(AFS_SPARC64_LINUX_ENV)
 #if defined(EXPORTED_SYS_CHDIR)
     { "scan: close+chdir",       __NR_close, &sys_close, __NR_chdir, &sys_chdir, -1,         0          },
 #endif
@@ -346,13 +346,13 @@
  * other entries, or we might get a sys_ni_syscall into the list and
  * the test would no longer work.
  */
-#if defined(AFS_SPARC64_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV)
     /* mmap2, fstat64, getmsg, putmsg, modify_ldt */
     56, 63, 151, 152, 218,
-#elif defined(AFS_SPARC_LINUX20_ENV)
+#elif defined(AFS_SPARC_LINUX_ENV)
     /* memory_ordering, getmsg, putmsg, unimplemented, modify_ldt */
     52, 151, 152, 164, 218,
-#else /* !AFS_SPARC_LINUX20_ENV */
+#else /* !AFS_SPARC_LINUX_ENV */
 
 /* 
  * These 7 syscalls are present in the syscall table on most "older"
@@ -386,7 +386,7 @@
  * corresponding __NR macros are not defined, so the tests above fail.
  * Instead, we just have to know the numbers for these.
  */
-#if defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     /* break, stty, gtty, ftime, prof, lock, mpx */
     17, 31, 32, 35, 44, 53, 56,
 #endif
@@ -422,7 +422,7 @@
  * unimplemented, but the __NR macros are not defined.  Again,
  * we simply have to know their numbers.
  */
-#ifdef AFS_IA64_LINUX26_ENV
+#ifdef AFS_IA64_LINUX_ENV
     /* create_module, query_module, get_kernel_sysms */
     1132, 1136, 1135,
 #endif
@@ -456,23 +456,23 @@
  * unimplemented calls are very similar.
  * mmap2 and fstat64 are implemented only for 32-bit calls
  */
-#ifdef AFS_PPC64_LINUX20_ENV
+#ifdef AFS_PPC64_LINUX_ENV
     /* _mmap2, _fstat64 */
     192, 197,
-#endif /* AFS_PPC64_LINUX20_ENV */
+#endif /* AFS_PPC64_LINUX_ENV */
 
 /* Similarly for S390X, with lcown16 and fstat64 */
-#ifdef AFS_S390X_LINUX20_ENV
+#ifdef AFS_S390X_LINUX_ENV
     /* lchown16, fstat64 */
     16, 197,
 #endif
-#endif /* !AFS_SPARC_LINUX20_ENV */
+#endif /* !AFS_SPARC_LINUX_ENV */
     0
 };
 
 /* unique syscalls for try_harder */
 static int main_unique_syscalls[] = {
-#if defined(AFS_SPARC64_LINUX24_ENV) || defined(AFS_SPARC_LINUX24_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV)
     /* 
      * On SPARC, we need some additional unique calls to make sure
      * we don't match the SunOS-compatibility table.
@@ -490,7 +490,7 @@
     "system call table",
 
     /* syscall number of first entry in table */
-#ifdef AFS_IA64_LINUX20_ENV
+#ifdef AFS_IA64_LINUX_ENV
     1024,
 #else
     0,
@@ -507,9 +507,9 @@
     main_try,                     /* array of combinations to try */
 
     /* symbol in section to try scanning */
-#if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     (unsigned long)&sys_close,
-#elif defined(AFS_AMD64_LINUX26_ENV)
+#elif defined(AFS_AMD64_LINUX_ENV)
     /* On this platform, it's in a different section! */
     (unsigned long)&generic_ro_fops,
 #else
@@ -519,24 +519,24 @@
     /* default base address for scan */
     /* base address bits to force to zero */
     /* default length for scan */
-#if   defined(AFS_SPARC64_LINUX20_ENV)
+#if   defined(AFS_SPARC64_LINUX_ENV)
     (unsigned long)(&sys_close),
     0xfffff,
     0x10000,
-#elif   defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#elif   defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     /* bleah; this is so suboptimal */
     (unsigned long)(&sys_close),
     0xfffff,
     0x20000,
-#elif   defined(AFS_IA64_LINUX20_ENV)
+#elif   defined(AFS_IA64_LINUX_ENV)
     (unsigned long)(&init_mm),
     0x1fffff,
     0x30000,
-#elif defined(AFS_AMD64_LINUX26_ENV)
+#elif defined(AFS_AMD64_LINUX_ENV)
     (unsigned long)(&generic_ro_fops) - 0x30000,
     0,
     0x6000,
-#elif defined(AFS_PPC64_LINUX26_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV)
     (unsigned long)(&do_signal),
     0xfff,
     0x400,
@@ -564,13 +564,13 @@
 
     /* syscalls to ignore for debugging */
     {
-#if   defined(AFS_ALPHA_LINUX20_ENV)
+#if   defined(AFS_ALPHA_LINUX_ENV)
 	338,
-#elif defined(AFS_AMD64_LINUX20_ENV)
+#elif defined(AFS_AMD64_LINUX_ENV)
 	183,
-#elif defined(AFS_IA64_LINUX20_ENV)
+#elif defined(AFS_IA64_LINUX_ENV)
 	1141,
-#elif defined(AFS_SPARC_LINUX20_ENV) || defined(AFS_SPARC64_LINUX20_ENV)
+#elif defined(AFS_SPARC_LINUX_ENV) || defined(AFS_SPARC64_LINUX_ENV)
 	227,
 #else
 	137,
@@ -587,7 +587,7 @@
 
 
 /********** Probing Configuration: amd64 ia32_sys_call_table **********/
-#if defined(AFS_AMD64_LINUX20_ENV)
+#if defined(AFS_AMD64_LINUX_ENV)
 
 /* syscall pairs/triplets to probe */
 static tryctl ia32_try[] = {
@@ -672,7 +672,7 @@
 
 
 /********** Probing Configuration: IA64 **********/
-#elif defined(AFS_IA64_LINUX20_ENV)
+#elif defined(AFS_IA64_LINUX_ENV)
 struct fptr {
     void *ip;
     unsigned long gp;
@@ -685,7 +685,7 @@
 
 
 /********** Probing Configuration: ppc64, sparc64 sys_call_table32 **********/
-#elif defined(AFS_PPC64_LINUX20_ENV) || defined(AFS_SPARC64_LINUX20_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV) || defined(AFS_SPARC64_LINUX_ENV)
 struct fptr {
     void *ip;
     unsigned long gp;
@@ -702,12 +702,12 @@
 
 /* zapped syscalls for try_harder */
 static int sct32_zapped_syscalls[] = {
-#ifdef AFS_PPC64_LINUX20_ENV
+#ifdef AFS_PPC64_LINUX_ENV
     /* These should be sufficient */
     __NR_break, __NR_stty, __NR_gtty, __NR_ftime,
     __NR_prof, __NR_lock, __NR_mpx,
 #endif
-#ifdef AFS_SPARC64_LINUX20_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
     /* memory_ordering, getmsg, putmsg, unimplemented, modify_ldt */
     52, 151, 152, 164, 218,
 #endif
@@ -717,11 +717,11 @@
 /* unique syscalls for try_harder */
 /* mmap2 and fstat64 are implemented only for 32-bit calls */
 static int sct32_unique_syscalls[] = {
-#ifdef AFS_PPC64_LINUX20_ENV
+#ifdef AFS_PPC64_LINUX_ENV
     /* _mmap2, _fstat64 */
     192, 197,
 #endif
-#ifdef AFS_SPARC64_LINUX24_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
     /* 
      * On SPARC, we need some additional unique calls to make sure
      * we don't match the SunOS-compatibility table.
@@ -752,7 +752,7 @@
     sct32_try,                   /* array of combinations to try */
 
     /* symbol in section to try scanning */
-#if defined(AFS_SPARC64_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV)
     (unsigned long)&sys_close,
 #else
     (unsigned long)&init_mm,
@@ -761,11 +761,11 @@
     /* default base address for scan */
     /* base address bits to force to zero */
     /* default length for scan */
-#if   defined(AFS_SPARC64_LINUX20_ENV)
+#if   defined(AFS_SPARC64_LINUX_ENV)
     (unsigned long)(&sys_close),
     0xfffff,
     0x10000,
-#elif defined(AFS_PPC64_LINUX26_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV)
     (unsigned long)(&do_signal),
     0xfff,
     0x400,
@@ -793,7 +793,7 @@
 
     /* syscalls to ignore for debugging */
     {
-#if defined(AFS_SPARC64_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV)
 	227,
 #else
 	137,
@@ -814,7 +814,7 @@
  * On earlier versions, the two tables were interleaved and so
  * have related base addresses.
  */
-#elif defined(AFS_S390X_LINUX26_ENV)
+#elif defined(AFS_S390X_LINUX_ENV)
 
 /* syscall pairs/triplets to probe */
 /* nothing worthwhile is exported, so this is empty */
@@ -917,7 +917,7 @@
     PROBETYPE *x;
     int i, j;
 
-#if defined(AFS_I386_LINUX26_ENV) || defined(AFS_AMD64_LINUX26_ENV)
+#if defined(AFS_I386_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
     i = check_table_readable(P, ptr);
     if (i >= 0) return i;
 #endif
@@ -964,7 +964,7 @@
     int ret;
     PROBETYPE *ptr;
 
-#if defined(AFS_IA64_LINUX20_ENV) || defined(AFS_PPC64_LINUX20_ENV)
+#if defined(AFS_IA64_LINUX_ENV) || defined(AFS_PPC64_LINUX_ENV)
     ip1 = T->fn1 ? (unsigned long)((struct fptr *)T->fn1)->ip : 0;
     ip2 = T->fn2 ? (unsigned long)((struct fptr *)T->fn2)->ip : 0;
     ip3 = T->fn3 ? (unsigned long)((struct fptr *)T->fn3)->ip : 0;
@@ -984,7 +984,7 @@
 	return 0;
 
     for (offset = 0; offset < datalen; offset++, aptr++) {
-#if defined(AFS_PPC64_LINUX20_ENV)
+#if defined(AFS_PPC64_LINUX_ENV)
 	ptr = (PROBETYPE*)(*aptr);
 	if ((unsigned long)ptr <= KERNELBASE) {
 		continue;
@@ -993,7 +993,7 @@
 	ptr = aptr;
 #endif
 	if ((unsigned long)ptr < init_mm.start_code ||
-#if defined(AFS_AMD64_LINUX20_ENV)
+#if defined(AFS_AMD64_LINUX_ENV)
 		(unsigned long)ptr > init_mm.brk)
 #else
 		(unsigned long)ptr > init_mm.end_data)
@@ -1044,7 +1044,7 @@
     unsigned long ip1;
     int i, s;
 
-#if defined(AFS_I386_LINUX26_ENV) || defined(AFS_AMD64_LINUX26_ENV)
+#if defined(AFS_I386_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
     i = check_table_readable(P, p);
     if (i >= 0) return 0;
 #endif
@@ -1074,7 +1074,7 @@
 	}
     }
 
-#if defined(AFS_IA64_LINUX20_ENV) || defined(AFS_PPC64_LINUX20_ENV)
+#if defined(AFS_IA64_LINUX_ENV) || defined(AFS_PPC64_LINUX_ENV)
     ip1 = P->verify_fn ? (unsigned long)((struct fptr *)(P->verify_fn))->ip : 0;
 #else
     ip1 = (unsigned long)(P->verify_fn);
@@ -1113,7 +1113,7 @@
 #endif
     for (offset = 0; offset < datalen; offset++, ptr++) {
 	 if ((unsigned long)ptr < init_mm.start_code ||
-#if defined(AFS_AMD64_LINUX20_ENV)
+#if defined(AFS_AMD64_LINUX_ENV)
 		(unsigned long)ptr > init_mm.brk)
 #else
 		(unsigned long)ptr > init_mm.end_data)
@@ -1190,7 +1190,7 @@
 {
     tryctl *T;
     void *answer;
-#if defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     void *answer2;
 #endif
 #ifdef OSI_PROBE_DEBUG
@@ -1210,7 +1210,7 @@
 
     for (T = P->trylist; T->name; T++) {
 	answer = try(P, T, B, L);
-#if defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
 	answer2 = try(P, T, (PROBETYPE *)(2 + (void *)B), L);
 #ifdef OSI_PROBE_DEBUG
 	if (probe_debug & 0x0003) {
@@ -1230,7 +1230,7 @@
     /* XXX more checks here */
 
     answer = try_harder(P, B, L);
-#if defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     answer2 = try_harder(P, (PROBETYPE *)(2 + (void *)B), L);
 #ifdef OSI_PROBE_DEBUG
     if (probe_debug & 0x0005) {
@@ -1335,7 +1335,7 @@
 #endif
 }
 
-#if defined(AFS_I386_LINUX26_ENV) || defined(AFS_AMD64_LINUX26_ENV)
+#if defined(AFS_I386_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
 static int check_access(unsigned long address, int mode) 
 { 
     pgd_t *pgd = pgd_offset_k(address);
@@ -1415,7 +1415,7 @@
 	return 0;
     }
     printk("Found %s at 0x%lx (%s)\n", P->desc, (unsigned long)answer, method);
-#if defined(AFS_I386_LINUX26_ENV) || defined(AFS_AMD64_LINUX26_ENV)
+#if defined(AFS_I386_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
     if (!check_access((unsigned long)answer, 1)) {
 	printk("Address 0x%lx is not writable.\n", (unsigned long)answer);
 	printk("System call hooks will not be installed; proceeding anyway\n");
diff --git a/src/afs/LINUX/osi_proc.c b/src/afs/LINUX/osi_proc.c
index 4ac51d3..9c5a080 100644
--- a/src/afs/LINUX/osi_proc.c
+++ b/src/afs/LINUX/osi_proc.c
@@ -25,7 +25,7 @@
 #include <linux/unistd.h>		/* For syscall numbers. */
 #include <linux/mm.h>
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 # include <asm/ia32_unistd.h>
 #endif
 
diff --git a/src/afs/LINUX/osi_syscall.c b/src/afs/LINUX/osi_syscall.c
index 921a7a8..836491c 100644
--- a/src/afs/LINUX/osi_syscall.c
+++ b/src/afs/LINUX/osi_syscall.c
@@ -37,7 +37,7 @@
 #include <linux/unistd.h>		/* For syscall numbers. */
 #include <linux/mm.h>
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 #include <asm/ia32_unistd.h>
 #endif
 
@@ -54,7 +54,7 @@
  * even though pointers are 64 bit quantities.
  * XXX unify this with osi_probe.c
  */
-#if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_S390X_LINUX24_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
 #define SYSCALLTYPE unsigned int
 #define POINTER2SYSCALL (unsigned int)(unsigned long)
 #define SYSCALL2POINTER (void *)(long)
@@ -64,7 +64,7 @@
 #define SYSCALL2POINTER (void *)
 #endif
 
-#if defined(AFS_S390X_LINUX24_ENV) 
+#if defined(AFS_S390X_LINUX_ENV) 
 #define INSERT_SYSCALL(SLOT, TMPPAGE, FUNC) \
 	if (SYSCALL2POINTER FUNC > 0x7fffffff) { \
 	    TMPPAGE = kmalloc ( PAGE_SIZE, GFP_DMA|GFP_KERNEL );	\
@@ -82,7 +82,7 @@
     afs_sys_call_table[_S(SLOT)] = POINTER2SYSCALL FUNC;
 #endif 
 
-#if defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_IA64_LINUX_ENV)
 #define _S(x) ((x)-1024)
 #else
 #define _S(x) x
@@ -96,7 +96,7 @@
 static SYSCALLTYPE *afs_sys_call_table;
 static SYSCALLTYPE afs_ni_syscall = 0;
 
-#ifdef AFS_S390X_LINUX24_ENV
+#ifdef AFS_S390X_LINUX_ENV
 static void *afs_sys_setgroups_page = 0;
 #if defined(__NR_setgroups32)
 static void *afs_sys_setgroups32_page = 0;
@@ -123,7 +123,7 @@
 				    __kernel_gid32_t * grouplist);
 
 /***** AMD64 *****/
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 static SYSCALLTYPE *afs_ia32_sys_call_table;
 static SYSCALLTYPE ia32_ni_syscall = 0;
 
@@ -131,11 +131,11 @@
 asmlinkage long (*sys32_setgroupsp) (int gidsetsize, u16 * grouplist);
 extern asmlinkage long afs32_xsetgroups32(int gidsetsize, gid_t * grouplist);
 asmlinkage long (*sys32_setgroups32p) (int gidsetsize, gid_t * grouplist);
-#endif /* AFS_AMD64_LINUX20_ENV */
+#endif /* AFS_AMD64_LINUX_ENV */
 
 
 /***** PPC64 *****/
-#ifdef AFS_PPC64_LINUX26_ENV
+#ifdef AFS_PPC64_LINUX_ENV
 static SYSCALLTYPE *afs_sys_call_table32;
 static SYSCALLTYPE afs_ni_syscall32 = 0;
 static SYSCALLTYPE old_sys_setgroupsp = 0;
@@ -159,11 +159,11 @@
 	printf("*** error! sys32_setgroups_stub called\n");
 }
 
-#endif /* AFS_PPC64_LINUX26_ENV */
+#endif /* AFS_PPC64_LINUX_ENV */
 
 
 /***** SPARC64 *****/
-#ifdef AFS_SPARC64_LINUX26_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
 static SYSCALLTYPE *afs_sys_call_table32;
 static SYSCALLTYPE afs_ni_syscall32 = 0;
 
@@ -187,11 +187,11 @@
 			 "ret\n\t"
                          "nop");
 }
-#endif /* AFS_SPARC64_LINUX20_ENV */
+#endif /* AFS_SPARC64_LINUX_ENV */
 
 
 /***** IA64 *****/
-#ifdef AFS_IA64_LINUX20_ENV
+#ifdef AFS_IA64_LINUX_ENV
 
 asmlinkage long
 afs_syscall_stub(int r0, int r1, long r2, long r3, long r4, long gp)
@@ -266,7 +266,7 @@
     unsigned long gp;
 };
 
-#endif /* AFS_IA64_LINUX20_ENV */
+#endif /* AFS_IA64_LINUX_ENV */
 
 /***** PPC64 ***** 
  * Spring 2005
@@ -277,7 +277,7 @@
  * Horst Birthelmer <Horst.Birthelmer@sysgo.de>
  * Marius Groeger <Marius.Groeger@sysgo.de>
  */
-#if defined(AFS_PPC64_LINUX26_ENV)
+#if defined(AFS_PPC64_LINUX_ENV)
 extern void flush_cache(void *, unsigned long);
 #define PPC_LO(v) ((v) & 0xffff)
 #define PPC_HI(v) (((v) >> 16) & 0xffff)
@@ -388,7 +388,7 @@
 PPC64_STUB(afs_sys_call_stub);
 PPC64_STUB(afs_xsetgroups_stub);
 PPC64_STUB(afs_xsetgroups32_stub);
-#endif /* AFS_PPC64_LINUX26_ENV */
+#endif /* AFS_PPC64_LINUX_ENV */
 
 
 /**********************************************************************/
@@ -398,7 +398,7 @@
 int osi_syscall_init(void)
 {
 /***** IA64 *****/
-#ifdef AFS_IA64_LINUX20_ENV
+#ifdef AFS_IA64_LINUX_ENV
     /* This needs to be first because we are declaring variables, and
      * also because the handling of syscall pointers is bizarre enough
      * that we want to special-case even the "common" part.
@@ -436,7 +436,7 @@
     /* XXX no 32-bit syscalls on IA64? */
 
 
-#elif defined(AFS_PPC64_LINUX26_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV)
 
     afs_sys_call_table = osi_find_syscall_table(0);
     if (afs_sys_call_table) {
@@ -481,7 +481,7 @@
 	sys32_setgroupsp = POINTER2SYSCALL sys32_setgroups_stub;
     }
 /***** COMMON (except IA64 or PPC64) *****/
-#else /* !AFS_IA64_LINUX20_ENV */
+#else /* !AFS_IA64_LINUX_ENV */
 
     afs_sys_call_table = osi_find_syscall_table(0);
     if (afs_sys_call_table) {
@@ -508,11 +508,11 @@
 	INSERT_SYSCALL(__NR_setgroups32, afs_sys_setgroups32_page, afs_xsetgroups32)
 #endif
     }
-#endif /* !AFS_IA64_LINUX20_ENV */
+#endif /* !AFS_IA64_LINUX_ENV */
 
 
 /***** AMD64 *****/
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
     afs_ia32_sys_call_table = osi_find_syscall_table(1);
     if (afs_ia32_sys_call_table) {
 	/* setup AFS entry point for IA32 */
@@ -532,11 +532,11 @@
 	afs_ia32_sys_call_table[__NR_ia32_setgroups32] =
 	    POINTER2SYSCALL afs32_xsetgroups32;
     }
-#endif /* AFS_AMD64_LINUX20_ENV */
+#endif /* AFS_AMD64_LINUX_ENV */
 
 
 /***** SPARC64 *****/
-#ifdef AFS_SPARC64_LINUX20_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
     afs_sys_call_table32 = osi_find_syscall_table(1);
     if (afs_sys_call_table32) {
 	/* setup AFS entry point for 32-bit SPARC */
@@ -553,7 +553,7 @@
 	afs_sys_call_table32[__NR_setgroups32] =
 	    POINTER2SYSCALL afs32_xsetgroups32;
     }
-#endif /* AFS_SPARC64_LINUX20_ENV */
+#endif /* AFS_SPARC64_LINUX_ENV */
     return 0;
 }
 
@@ -571,26 +571,26 @@
 	afs_sys_call_table[_S(__NR_afs_syscall)] = afs_ni_syscall;
 
 	/* put back setgroups */
-#if defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_IA64_LINUX_ENV)
 	afs_sys_call_table[_S(__NR_setgroups)] =
 	    POINTER2SYSCALL((struct fptr *)sys_setgroupsp)->ip;
-#elif defined(AFS_PPC64_LINUX26_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV)
 	afs_sys_call_table[_S(__NR_setgroups)] =
 	    POINTER2SYSCALL old_sys_setgroupsp;
 	/* put back setgroups32 for PPC64 */
 	afs_sys_call_table32[__NR_setgroups] =
 	    POINTER2SYSCALL old_sys32_setgroupsp;
-#else /* AFS_IA64_LINUX20_ENV */
+#else /* AFS_IA64_LINUX_ENV */
 	afs_sys_call_table[_S(__NR_setgroups)] =
 	    POINTER2SYSCALL sys_setgroupsp;
 #endif
 
-#if defined(__NR_setgroups32) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(__NR_setgroups32) && !defined(AFS_IA64_LINUX_ENV)
 	/* put back setgroups32 */
 	afs_sys_call_table[__NR_setgroups32] = POINTER2SYSCALL sys_setgroups32p;
 #endif
-#if defined(AFS_S390X_LINUX24_ENV)
-#if defined(__NR_setgroups32) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_S390X_LINUX_ENV)
+#if defined(__NR_setgroups32) && !defined(AFS_IA64_LINUX_ENV)
 	if (afs_sys_setgroups32_page)
 	    kfree(afs_sys_setgroups32_page);
 #endif
@@ -603,13 +603,13 @@
 
 
 /***** IA64 *****/
-#ifdef AFS_IA64_LINUX20_ENV
+#ifdef AFS_IA64_LINUX_ENV
     /* XXX no 32-bit syscalls on IA64? */
 #endif
 
 
 /***** AMD64 *****/
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
     if (afs_ia32_sys_call_table) {
 	/* put back AFS entry point for IA32 */
 	afs_ia32_sys_call_table[__NR_ia32_afs_syscall] =
@@ -627,7 +627,7 @@
 
 
 /***** SPARC64 *****/
-#ifdef AFS_SPARC64_LINUX20_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
     if (afs_sys_call_table32) {
 	/* put back AFS entry point for 32-bit SPARC */
 	afs_sys_call_table32[__NR_afs_syscall] = afs_ni_syscall32;
diff --git a/src/afs/UKERNEL/sysincludes.h b/src/afs/UKERNEL/sysincludes.h
index 1500065..03666b0 100644
--- a/src/afs/UKERNEL/sysincludes.h
+++ b/src/afs/UKERNEL/sysincludes.h
@@ -82,7 +82,7 @@
 #include  <arpa/inet.h>
 #endif /* AFS_USR_HPUX_ENV */
 
-#ifdef AFS_USR_LINUX22_ENV
+#ifdef AFS_USR_LINUX_ENV
 #include  <sys/ioctl.h>		/* _IOW() */
 #include  <sys/uio.h>		/* struct iovec */
 #include  <sys/time.h>		/* struct timeval */
@@ -97,7 +97,7 @@
 #include  <netdb.h>
 #include  <arpa/inet.h>
 #define FREAD			0x0001
-#endif /* AFS_USR_LINUX22_ENV */
+#endif /* AFS_USR_LINUX_ENV */
 
 #if defined(AFS_USR_DARWIN_ENV) || defined(AFS_USR_FBSD_ENV) || defined(AFS_USR_DFBSD_ENV)
 #ifdef _KERNEL
@@ -150,7 +150,7 @@
 #include <resolv.h>
 
 /* glibc 2.2 has pthread_attr_setstacksize */
-#if (defined(AFS_LINUX22_ENV) && !defined(AFS_USR_LINUX22_ENV)) || (defined(AFS_USR_LINUX22_ENV) && (__GLIBC_MINOR__ < 2))
+#if (defined(AFS_LINUX_ENV) && !defined(AFS_USR_LINUX_ENV)) || (defined(AFS_USR_LINUX_ENV) && (__GLIBC_MINOR__ < 2))
 #define pthread_attr_setstacksize(a,b) 0
 #endif
 
diff --git a/src/afs/VNOPS/afs_vnop_attrs.c b/src/afs/VNOPS/afs_vnop_attrs.c
index 64abe7f..d103337 100644
--- a/src/afs/VNOPS/afs_vnop_attrs.c
+++ b/src/afs/VNOPS/afs_vnop_attrs.c
@@ -141,7 +141,7 @@
     attrs->va_atime.tv_nsec = attrs->va_mtime.tv_nsec =
 	attrs->va_ctime.tv_nsec = 0;
     attrs->va_gen = hgetlo(avc->f.m.DataVersion);
-#elif defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_OBSD_ENV) || defined(AFS_NBSD_ENV) || defined(AFS_LINUX26_ENV)
+#elif defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_OBSD_ENV) || defined(AFS_NBSD_ENV) || defined(AFS_LINUX_ENV)
     attrs->va_atime.tv_nsec = attrs->va_mtime.tv_nsec =
 	attrs->va_ctime.tv_nsec =
 	(hgetlo(avc->f.m.DataVersion) & 0x7ffff) * 1000;
@@ -298,7 +298,7 @@
 		    /* If it's the root of AFS, replace the inode number with the
 		     * inode number of the mounted on directory; otherwise this
 		     * confuses getwd()... */
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 		    if (avc == afs_globalVp) {
 			struct inode *ip = AFSTOV(avc)->i_sb->s_root->d_inode;
 			attrs->va_nodeid = ip->i_ino;	/* VTOI()? */
@@ -333,7 +333,7 @@
 			}
 # endif /* AFS_DARWIN80_ENV */
 		    }
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 		}
 		afs_PutUser(au, READ_LOCK);
 	    }
@@ -365,7 +365,7 @@
 #elif defined(AFS_AIX_ENV)
 /* Boy, was this machine dependent bogosity hard to swallow????.... */
     if (av->va_mode != -1) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (av->va_mask & ATTR_MODE) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (av->va_mask & AT_MODE) {
@@ -384,7 +384,7 @@
     }
 #if defined(AFS_DARWIN80_ENV)
     if (VATTR_IS_ACTIVE(av, va_gid)) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (av->va_mask & ATTR_GID) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (av->va_mask & AT_GID) {
@@ -404,7 +404,7 @@
     }
 #if defined(AFS_DARWIN80_ENV)
     if (VATTR_IS_ACTIVE(av, va_uid)) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (av->va_mask & ATTR_UID) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (av->va_mask & AT_UID) {
@@ -424,7 +424,7 @@
     }
 #if defined(AFS_DARWIN80_ENV)
     if (VATTR_IS_ACTIVE(av, va_modify_time)) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (av->va_mask & ATTR_MTIME) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (av->va_mask & AT_MTIME) {
@@ -433,7 +433,7 @@
 #endif /* AFS_DARWIN80_ENV */
 	mask |= AFS_SETMODTIME;
 #ifndef	AFS_SGI_ENV
-# if defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_LINUX26_ENV)
+# if defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_LINUX_ENV)
 	if (av->va_mtime.tv_nsec == -1)
 # else
 	if (av->va_mtime.tv_usec == -1)
@@ -470,7 +470,7 @@
     OSI_VC_CONVERT(avc);
 
     AFS_STATCNT(afs_setattr);
-#if defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV) || defined(AFS_LINUX22_ENV)
+#if defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV) || defined(AFS_LINUX_ENV)
     afs_Trace4(afs_iclSetp, CM_TRACE_SETATTR, ICL_TYPE_POINTER, avc,
 	       ICL_TYPE_INT32, attrs->va_mask, ICL_TYPE_OFFSET,
 	       ICL_HANDLE_OFFSET(attrs->va_size), ICL_TYPE_OFFSET,
@@ -510,7 +510,7 @@
      */
 #if defined(AFS_DARWIN80_ENV)
     if (VATTR_IS_ACTIVE(attrs, va_data_size)) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (attrs->va_mask & ATTR_SIZE) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (attrs->va_mask & AT_SIZE) {
@@ -545,7 +545,7 @@
 #endif
 #if defined(AFS_DARWIN80_ENV)
     if (VATTR_IS_ACTIVE(attrs, va_data_size)) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (attrs->va_mask & ATTR_SIZE) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (attrs->va_mask & AT_SIZE) {
@@ -567,13 +567,13 @@
 	} else {
 	    code = afs_TruncateAllSegments(avc, tsize, treq, acred);
 	}
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 	/* We must update the Linux kernel's idea of file size as soon as
 	 * possible, to avoid racing with delayed writepages delivered by
 	 * pdflush */
 	if (code == 0)
 	    i_size_write(AFSTOV(avc), tsize);
-#endif /* AFS_LINUX26_ENV */
+#endif /* AFS_LINUX_ENV */
 #if defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV)
 	vnode_pager_setsize(vp, (u_long) tsize);
 #endif
diff --git a/src/afs/VNOPS/afs_vnop_fid.c b/src/afs/VNOPS/afs_vnop_fid.c
index 3fa2edb..54e1956 100644
--- a/src/afs/VNOPS/afs_vnop_fid.c
+++ b/src/afs/VNOPS/afs_vnop_fid.c
@@ -17,7 +17,7 @@
 #include "afs/param.h"
 
 
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_OBSD_ENV) && !defined(AFS_NBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_OBSD_ENV) && !defined(AFS_NBSD_ENV)
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 #include "afsincludes.h"	/* Afs-based standard headers */
 #include "afs/afs_stats.h"	/* statistics */
@@ -151,4 +151,4 @@
 }
 
 
-#endif /* !AFS_LINUX20_ENV */
+#endif /* !AFS_LINUX_ENV */
diff --git a/src/afs/VNOPS/afs_vnop_flock.c b/src/afs/VNOPS/afs_vnop_flock.c
index 9efeeeb..2ece900 100644
--- a/src/afs/VNOPS/afs_vnop_flock.c
+++ b/src/afs/VNOPS/afs_vnop_flock.c
@@ -122,7 +122,7 @@
 	flock->l_pid = clid;
     }
 }
-#elif defined(AFS_LINUX20_ENV) || defined(AFS_HPUX_ENV)
+#elif defined(AFS_LINUX_ENV) || defined(AFS_HPUX_ENV)
 void
 lockIdSet(struct AFS_FLOCK *flock, struct SimpleLocks *slp, int clid)
 {
@@ -173,7 +173,7 @@
 #if	defined(AFS_SUN5_ENV)
     proc_t *procp = ttoproc(curthread);
 #else
-#if !defined(AFS_AIX41_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_SGI65_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
+#if !defined(AFS_AIX41_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_SGI65_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
 #ifdef AFS_SGI64_ENV
     afs_proc_t *procp = curprocp;
 #elif defined(UKERNEL)
@@ -191,7 +191,7 @@
 	}
 #endif
 	if ((flock1->l_pid == alp->pid) ||
-#if defined(AFS_AIX41_ENV) || defined(AFS_LINUX20_ENV) || defined(AFS_HPUX_ENV)
+#if defined(AFS_AIX41_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_HPUX_ENV)
 	    (!onlymine && (flock1->l_pid == getppid()))
 #else
 #if defined(AFS_SGI65_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
@@ -541,7 +541,7 @@
     lastWarnTime = avc->lastBRLWarnTime = now;
     lastWarnPid = pid;
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
     message = "byte-range locks only enforced for processes on this machine";
 #else
     message = "byte-range lock/unlock ignored; make sure no one else is running this program";
diff --git a/src/afs/VNOPS/afs_vnop_lookup.c b/src/afs/VNOPS/afs_vnop_lookup.c
index b42d6db..2a0457e 100644
--- a/src/afs/VNOPS/afs_vnop_lookup.c
+++ b/src/afs/VNOPS/afs_vnop_lookup.c
@@ -1225,7 +1225,7 @@
 	 * We only do this if the entry looks clear.
 	 */
 	afs_ProcessFS(tvcp, &statsp[i], areqp);
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
 	afs_fill_inode(AFSTOV(tvcp), NULL);	/* reset inode operations */
 #endif
 
@@ -1597,7 +1597,7 @@
 	goto done;
     }
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
     /*
      * Special case of the dynamic mount volume in a static root.
      * This is really unfortunate, but we need this for the translator.
@@ -1634,7 +1634,7 @@
 	    code = EACCES;
 	    goto done;
 	}
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 	if (tvc->mvstat == AFS_MVSTAT_ROOT) {	/* we don't trust the dnlc for root vcaches */
 	    AFS_RELE(AFSTOV(tvc));
 	    *avcp = 0;
@@ -1647,7 +1647,7 @@
 	code = 0;
 	hit = 1;
 	goto done;
-#endif /* linux22 */
+#endif /* AFS_LINUX_ENV */
     }
 
     {				/* sub-block just to reduce stack usage */
@@ -1966,7 +1966,7 @@
 	    if (!hit && (force_eval || tvc->mvstat != AFS_MVSTAT_MTPT)) {
 		osi_dnlc_enter(adp, aname, tvc, &versionNo);
 	    } else {
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 		/* So Linux inode cache is up to date. */
 		code = afs_VerifyVCache(tvc, treq);
 #else
diff --git a/src/afs/VNOPS/afs_vnop_open.c b/src/afs/VNOPS/afs_vnop_open.c
index 678a4a7..fc947e8 100644
--- a/src/afs/VNOPS/afs_vnop_open.c
+++ b/src/afs/VNOPS/afs_vnop_open.c
@@ -151,7 +151,7 @@
     if (writing)
 	tvc->execsOrWriters++;
     tvc->opens++;
-#if defined(AFS_SGI_ENV) || defined (AFS_LINUX26_ENV)
+#if defined(AFS_SGI_ENV) || defined (AFS_LINUX_ENV)
     if (writing && tvc->cred == NULL) {
 	crhold(acred);
 	tvc->cred = acred;
diff --git a/src/afs/VNOPS/afs_vnop_read.c b/src/afs/VNOPS/afs_vnop_read.c
index dba4117..b5e341a 100644
--- a/src/afs/VNOPS/afs_vnop_read.c
+++ b/src/afs/VNOPS/afs_vnop_read.c
@@ -548,7 +548,7 @@
     AFS_GUNLOCK();
     code = VOP_RDWR(tfile->vnode, tuiop, UIO_READ, 0, afs_osi_credp);
     AFS_GLOCK();
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
     AFS_GUNLOCK();
     code = osi_rdwr(tfile, tuiop, UIO_READ);
     AFS_GLOCK();
diff --git a/src/afs/VNOPS/afs_vnop_readdir.c b/src/afs/VNOPS/afs_vnop_readdir.c
index cdc5af5..a83857f 100644
--- a/src/afs/VNOPS/afs_vnop_readdir.c
+++ b/src/afs/VNOPS/afs_vnop_readdir.c
@@ -111,7 +111,7 @@
 }
 
 
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 /* Changes to afs_readdir which affect dcache or vcache handling or use of
  * bulk stat data should also be reflected in the Linux specific verison of
  * the readdir routine.
@@ -952,4 +952,4 @@
     return code;
 }
 
-#endif /* !AFS_LINUX20_ENV */
+#endif /* !AFS_LINUX_ENV */
diff --git a/src/afs/VNOPS/afs_vnop_strategy.c b/src/afs/VNOPS/afs_vnop_strategy.c
index 978df88..c4296bb 100644
--- a/src/afs/VNOPS/afs_vnop_strategy.c
+++ b/src/afs/VNOPS/afs_vnop_strategy.c
@@ -16,7 +16,7 @@
 #include "afs/param.h"
 
 
-#if !defined(AFS_HPUX_ENV) && !defined(AFS_SGI_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN80_ENV)
+#if !defined(AFS_HPUX_ENV) && !defined(AFS_SGI_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN80_ENV)
 
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 #include "afsincludes.h"	/* Afs-based standard headers */
@@ -224,4 +224,4 @@
     return code;
 }
 
-#endif /* !AFS_HPUX_ENV  && !AFS_SGI_ENV && !AFS_LINUX20_ENV */
+#endif /* !AFS_HPUX_ENV  && !AFS_SGI_ENV && !AFS_LINUX_ENV */
diff --git a/src/afs/VNOPS/afs_vnop_write.c b/src/afs/VNOPS/afs_vnop_write.c
index 32d69f4..90ad86c 100644
--- a/src/afs/VNOPS/afs_vnop_write.c
+++ b/src/afs/VNOPS/afs_vnop_write.c
@@ -145,7 +145,7 @@
 	code = VOP_RDWR(tfile->vnode, tuiop, UIO_WRITE, 0, afs_osi_credp);
 	AFS_GLOCK();
     }
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
     AFS_GUNLOCK();
     code = osi_rdwr(tfile, tuiop, UIO_WRITE);
     AFS_GLOCK();
diff --git a/src/afs/afs.h b/src/afs/afs.h
index f436cc6..c47b28c 100644
--- a/src/afs/afs.h
+++ b/src/afs/afs.h
@@ -53,7 +53,7 @@
 # else
 #  define AFS_VFSFSID		99
 # endif
-#elif defined(AFS_SUN5_ENV) || defined(AFS_HPUX90_ENV) || defined(AFS_LINUX20_ENV)
+#elif defined(AFS_SUN5_ENV) || defined(AFS_HPUX90_ENV) || defined(AFS_LINUX_ENV)
 # define AFS_VFSFSID		99
 #elif defined(AFS_SGI_ENV)
 # define AFS_VFSFSID		afs_fstype
@@ -71,7 +71,7 @@
 #if     defined(AFS_HPUX102_ENV)
 #define AFS_FLOCK       k_flock
 #else
-#if     defined(AFS_SUN5_ENV) || (defined(AFS_LINUX24_ENV) && !(defined(AFS_LINUX26_ENV) && defined(AFS_LINUX_64BIT_KERNEL)))
+#if     defined(AFS_SUN5_ENV) || (defined(AFS_LINUX_ENV) && !(defined(AFS_LINUX_ENV) && defined(AFS_LINUX_64BIT_KERNEL)))
 #define AFS_FLOCK       flock64
 #else
 #define AFS_FLOCK       flock
@@ -284,7 +284,7 @@
     struct AFSFid fid;
 };
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 /* On Linux, we have to be able to allocate the storage for this using
  * kmalloc, as otherwise we may deadlock. So, it needs to be able to fit
  * in a single page
@@ -738,7 +738,7 @@
 #elif defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV)
 #define VREFCOUNT(v)          ((v)->vrefCount)
 #define VREFCOUNT_GT(v, y)    (AFSTOV(v)->v_usecount > (y))
-#elif defined(AFS_LINUX24_ENV)
+#elif defined(AFS_LINUX_ENV)
 #define VREFCOUNT(v)		atomic_read(&(AFSTOV(v)->v_count))
 #define VREFCOUNT_GT(v, y)      (VREFCOUNT(v)>y)
 #define VREFCOUNT_SET(v, c)	atomic_set(&(AFSTOV(v)->v_count), c)
@@ -773,7 +773,7 @@
 };
 #define VTOAFS(v) ((((struct nbvdata *)((v)->v_data)))->afsvc)
 #define AFSTOV(vc) ((vc)->v)
-#elif defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_SUN511_ENV) || (defined(AFS_LINUX22_ENV) && !defined(STRUCT_SUPER_OPERATIONS_HAS_ALLOC_INODE))
+#elif defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_SUN511_ENV) || (defined(AFS_LINUX_ENV) && !defined(STRUCT_SUPER_OPERATIONS_HAS_ALLOC_INODE))
 #define VTOAFS(v) ((struct vcache *)(v)->v_data)
 #define AFSTOV(vc) ((vc)->v)
 #else
@@ -847,13 +847,13 @@
  * !(avc->nextfree) && !avc->vlruq.next => (FreeVCList == avc->nextfree)
  */
 struct vcache {
-#if defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_SUN511_ENV) || (defined(AFS_LINUX22_ENV) && !defined(STRUCT_SUPER_OPERATIONS_HAS_ALLOC_INODE))
+#if defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_SUN511_ENV) || (defined(AFS_LINUX_ENV) && !defined(STRUCT_SUPER_OPERATIONS_HAS_ALLOC_INODE))
     struct vnode *v;
 #else
     struct vnode v;		/* Has reference count in v.v_count */
 #endif
     struct afs_q vlruq;		/* lru q next and prev */
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     struct vcache *nextfree;	/* next on free list (if free) */
 #endif
     struct vcache *hnext;	/* Hash next */
@@ -931,7 +931,7 @@
     char cachingStates;			/* Caching policies for this file */
     afs_uint32 cachingTransitions;		/* # of times file has flopped between caching and not */
 
-#if defined(AFS_LINUX24_ENV)
+#if defined(AFS_LINUX_ENV)
     off_t next_seq_offset;	/* Next sequential offset (used by prefetch/readahead) */
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI65_ENV)
     off_t next_seq_blk_offset; /* accounted in blocks for Solaris & IRIX */
@@ -958,10 +958,10 @@
     struct bhv_desc vc_bhv_desc;	/* vnode's behavior data. */
 #endif
 #endif				/* AFS_SGI_ENV */
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
     cred_t *cred;		/* last writer's cred */
 #endif
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
     struct dentry *target_link; /* dentry we prefer, when we are redirecting
                                  * all requests due to duplicate dentry aliases.
                                  * See LINUX/osi_vnodeops.c. Note that this is
@@ -980,13 +980,13 @@
     void *vpacRock;		/* used to read or write in visible partitions */
 #endif
     afs_uint32 lastBRLWarnTime; /* last time we warned about byte-range locks */
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
     spinlock_t pagewriter_lock;
     struct list_head pagewriters;	/* threads that are writing vm pages */
 #endif
 };
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 struct pagewriter {
     struct list_head link;
     pid_t writer;
@@ -1191,7 +1191,7 @@
  * the size correctly.
  */
 typedef ino64_t afs_ufs_dcache_id_t;
-#elif defined(AFS_LINUX26_ENV)
+#elif defined(AFS_LINUX_ENV)
 #define MAX_FH_LEN 10
 typedef union {
 #if defined(NEW_EXPORT_OPS)
@@ -1201,7 +1201,7 @@
 } afs_ufs_dcache_id_t;
 extern int cache_fh_type;
 extern int cache_fh_len;
-#elif defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_S390X_LINUX24_ENV)
+#elif defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_S390X_LINUX_ENV)
 typedef long afs_ufs_dcache_id_t;
 #elif defined(AFS_AIX51_ENV) || defined(AFS_HPUX1123_ENV)
 typedef ino_t afs_ufs_dcache_id_t;
@@ -1552,7 +1552,7 @@
 #elif defined (AFS_DARWIN110_ENV)
 #define afs_cr_uid(cred) kauth_cred_getuid((kauth_cred_t)(cred))
 #define afs_cr_gid(cred) kauth_cred_getgid((kauth_cred_t)(cred))
-#elif !(defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED))
+#elif !(defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED))
 #define afs_cr_uid(cred) ((cred)->cr_uid)
 #define afs_cr_gid(cred) ((cred)->cr_gid)
 #if !defined(AFS_OBSD_ENV)
@@ -1624,7 +1624,7 @@
     /* no cond member */
 #elif defined(AFS_FBSD_ENV) || defined(AFS_OBSD_ENV)
     int cond;			/* "all this gluck should probably be replaced by CVs" */
-#elif defined(AFS_LINUX24_ENV)
+#elif defined(AFS_LINUX_ENV)
     wait_queue_head_t cond;
 #elif defined(AFS_NBSD_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     kcondvar_t cond;		/* Currently associated condition variable */
diff --git a/src/afs/afs_analyze.c b/src/afs/afs_analyze.c
index 4bb212b..188d36e 100644
--- a/src/afs/afs_analyze.c
+++ b/src/afs/afs_analyze.c
@@ -18,7 +18,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #ifndef UKERNEL
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_FBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_FBSD_ENV)
 #include <net/if.h>
 #include <netinet/in.h>
 #endif
@@ -26,7 +26,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_FBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_FBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif
 #endif /* !UKERNEL */
diff --git a/src/afs/afs_buffer.c b/src/afs/afs_buffer.c
index 55a4564..11f1819 100644
--- a/src/afs/afs_buffer.c
+++ b/src/afs/afs_buffer.c
@@ -14,7 +14,7 @@
 #include "afs/sysincludes.h"
 #include "afsincludes.h"
 #if !defined(UKERNEL)
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 # include "h/param.h"
 #endif
 #include "h/types.h"
@@ -22,7 +22,7 @@
 #if	defined(AFS_AIX31_ENV)
 #include "h/limits.h"
 #endif
-#if	!defined(AFS_AIX_ENV) && !defined(AFS_SUN5_ENV) && !defined(AFS_SGI_ENV) && !defined(AFS_LINUX20_ENV)
+#if	!defined(AFS_AIX_ENV) && !defined(AFS_SUN5_ENV) && !defined(AFS_SGI_ENV) && !defined(AFS_LINUX_ENV)
 #include "h/kernel.h"		/* Doesn't needed, so it should go */
 #endif
 #endif /* !defined(UKERNEL) */
@@ -31,7 +31,7 @@
 #include "afsint.h"
 #include "afs/lock.h"
 
-#if !defined(UKERNEL) && !defined(AFS_LINUX20_ENV)
+#if !defined(UKERNEL) && !defined(AFS_LINUX_ENV)
 #include "h/buf.h"
 #endif /* !defined(UKERNEL) */
 
diff --git a/src/afs/afs_bypasscache.h b/src/afs/afs_bypasscache.h
index 37c5669..2cda654 100644
--- a/src/afs/afs_bypasscache.h
+++ b/src/afs/afs_bypasscache.h
@@ -84,7 +84,7 @@
     u_offset_t offset;
     struct seg *segment;
     caddr_t address;
-#elif defined(AFS_LINUX24_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     /* The tested platform, as CITI impl. just packs ab->parms */
     struct uio *auio;
     struct vrequest *areq;
diff --git a/src/afs/afs_call.c b/src/afs/afs_call.c
index 37cac13..24df6aa 100644
--- a/src/afs/afs_call.c
+++ b/src/afs/afs_call.c
@@ -19,7 +19,7 @@
 #include "afs/afs_stats.h"
 #include "rx/rx_globals.h"
 #if !defined(UKERNEL)
-# if !defined(AFS_LINUX20_ENV)
+# if !defined(AFS_LINUX_ENV)
 #  include "net/if.h"
 #  ifdef AFS_SGI62_ENV
 #   include "h/hashing.h"
@@ -41,7 +41,7 @@
 #define	AFS_MINBUFFERS	50
 #endif
 
-#if (defined(AFS_SUN5_ENV) || defined(AFS_LINUX26_ENV) || defined(AFS_DARWIN80_ENV)) && !defined(UKERNEL)
+#if (defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_DARWIN80_ENV)) && !defined(UKERNEL)
 /* If AFS_DAEMONOP_ENV is defined, it indicates we run "daemon" AFS syscalls by
  * spawning a kernel thread to do the work, instead of running them in the
  * calling process. */
@@ -281,7 +281,7 @@
 #endif
 
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
 struct afsd_thread_info {
 # if !defined(INIT_WORK_HAS_DATA)
     struct work_struct tq;
@@ -299,7 +299,7 @@
     int (*sys_setpriority) (int, int, int) = sys_call_table[__NR_setpriority];
 # endif
 # if !defined(HAVE_LINUX_KTHREAD_RUN)
-#  if defined(AFS_LINUX26_ENV)
+#  if defined(AFS_LINUX_ENV)
     daemonize("afsd");
 #  else
     daemonize();
@@ -308,7 +308,7 @@
 				/* doesn't do much, since we were forked from keventd, but
 				 * does call mm_release, which wakes up our parent (since it
 				 * used CLONE_VFORK) */
-# if !defined(AFS_LINUX26_ENV)
+# if !defined(AFS_LINUX_ENV)
     reparent_to_init();
 # endif
     afs_osi_MaskSignals();
@@ -431,13 +431,13 @@
 }
 
 void
-# if defined(AFS_LINUX26_ENV) && !defined(INIT_WORK_HAS_DATA)
+# if defined(AFS_LINUX_ENV) && !defined(INIT_WORK_HAS_DATA)
 afsd_launcher(struct work_struct *work)
 # else
 afsd_launcher(void *rock)
 # endif
 {
-# if defined(AFS_LINUX26_ENV) && !defined(INIT_WORK_HAS_DATA)
+# if defined(AFS_LINUX_ENV) && !defined(INIT_WORK_HAS_DATA)
     struct afsd_thread_info *rock = container_of(work, struct afsd_thread_info, tq);
 # endif
 
@@ -456,7 +456,7 @@
 	     long parm6)
 {
     DECLARE_COMPLETION(c);
-# if defined(AFS_LINUX26_ENV)
+# if defined(AFS_LINUX_ENV)
 #  if defined(INIT_WORK_HAS_DATA)
     struct work_struct tq;
 #  endif
@@ -469,7 +469,7 @@
     }
     info.complete = &c;
     info.parm = parm;
-# if defined(AFS_LINUX26_ENV)
+# if defined(AFS_LINUX_ENV)
 #  if !defined(INIT_WORK_HAS_DATA)
     INIT_WORK(&info.tq, afsd_launcher);
     schedule_work(&info.tq);
@@ -1120,7 +1120,7 @@
 	while (!afs_InitSetup_done)
 	    afs_osi_Sleep(&afs_InitSetup_done);
 
-#if defined(AFS_SGI_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_SUN5_ENV)
+#if defined(AFS_SGI_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_SUN5_ENV)
 	temp = AFS_MINBUFFERS;	/* Should fix this soon */
 #else
 	/* number of 2k buffers we could get from all of the buffer space */
@@ -1475,7 +1475,7 @@
 	afs_SynchronousCloses = 'S';
     } else if (parm == AFSOP_GETMTU) {
 	afs_uint32 mtu = 0;
-#if	!defined(AFS_SUN5_ENV) && !defined(AFS_LINUX20_ENV)
+#if	!defined(AFS_SUN5_ENV) && !defined(AFS_LINUX_ENV)
 # ifdef AFS_USERSPACE_IP_ADDR
 	afs_int32 i;
 	i = rxi_Findcbi(parm2);
@@ -1608,7 +1608,7 @@
 
   out:
     AFS_GUNLOCK();
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     return -code;
 #else
     return code;
diff --git a/src/afs/afs_cbqueue.c b/src/afs/afs_cbqueue.c
index 85b3247..2dd6335 100644
--- a/src/afs/afs_cbqueue.c
+++ b/src/afs/afs_cbqueue.c
@@ -178,7 +178,7 @@
  */
 
 /* Sanity check on the callback queue. Allow for slop in the computation. */
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
 #define CBQ_LIMIT (afs_maxvcount + 10)
 #else
 #define CBQ_LIMIT (afs_cacheStats + afs_stats_cmperf.vcacheXAllocs + 10)
diff --git a/src/afs/afs_conn.c b/src/afs/afs_conn.c
index 92d36af..3b9b183 100644
--- a/src/afs/afs_conn.c
+++ b/src/afs/afs_conn.c
@@ -18,7 +18,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #if !defined(UKERNEL)
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <net/if.h>
 #endif
 #include <netinet/in.h>
@@ -26,7 +26,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif /* ! AFS_HPUX110_ENV */
 #endif /* !defined(UKERNEL) */
diff --git a/src/afs/afs_daemons.c b/src/afs/afs_daemons.c
index cca6032..f84d94c 100644
--- a/src/afs/afs_daemons.c
+++ b/src/afs/afs_daemons.c
@@ -348,7 +348,7 @@
 		 * count to zero and fs checkv is executed when the current
 		 * directory is /afs.
 		 */
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 		osi_ResetRootVCache(volid);
 #else
 # ifdef AFS_DARWIN80_ENV
@@ -382,7 +382,7 @@
     struct dcache *tdc = NULL;
     struct vcache *tvc = NULL;
     struct vnode *tvn = NULL;
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     struct dentry *dp = NULL;
 #endif
     afs_size_t offset, len;
@@ -394,7 +394,7 @@
 	return;
     }
     AFS_GUNLOCK();
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     code = gop_lookupname((char *)ab->ptr_parm[0], AFS_UIOSYS, 1, &dp);
     if (dp)
 	tvn = (struct vnode *)dp->d_inode;
@@ -411,7 +411,7 @@
     if (!tvn || !IsAfsVnode(tvn)) {
 	/* release it and give up */
 	if (tvn) {
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 	    dput(dp);
 #else
 	    AFS_RELE(tvn);
@@ -426,7 +426,7 @@
     if (tdc) {
 	afs_PutDCache(tdc);
     }
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     dput(dp);
 #else
     AFS_RELE(tvn);
diff --git a/src/afs/afs_dcache.c b/src/afs/afs_dcache.c
index 3c072bb..5793fdb 100644
--- a/src/afs/afs_dcache.c
+++ b/src/afs/afs_dcache.c
@@ -3235,7 +3235,7 @@
 	    }
 	} else {
 	    /* Add any other 'complex' inode types here ... */
-#if !defined(AFS_LINUX26_ENV) && !defined(AFS_CACHE_VNODE_PATH)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_CACHE_VNODE_PATH)
 	    tdc->f.inode.ufs = ainode;
 #else
 	    osi_Panic("Can't init cache with inode numbers when complex inodes are "
diff --git a/src/afs/afs_error.c b/src/afs/afs_error.c
index dd346a0..5f31c60 100644
--- a/src/afs/afs_error.c
+++ b/src/afs/afs_error.c
@@ -18,7 +18,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #ifndef UKERNEL
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_FBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_FBSD_ENV)
 #include <net/if.h>
 #include <netinet/in.h>
 #endif
@@ -26,7 +26,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_FBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_FBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif
 #endif /* !UKERNEL */
diff --git a/src/afs/afs_icl.c b/src/afs/afs_icl.c
index 6e4ce63..ed5474d 100644
--- a/src/afs/afs_icl.c
+++ b/src/afs/afs_icl.c
@@ -15,7 +15,7 @@
 #include "afsincludes.h"	/* Afs-based standard headers */
 #include "afs/afs_stats.h"
 #include "rx/rx_globals.h"
-#if !defined(UKERNEL) && !defined(AFS_LINUX20_ENV)
+#if !defined(UKERNEL) && !defined(AFS_LINUX_ENV)
 #include "net/if.h"
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
diff --git a/src/afs/afs_init.c b/src/afs/afs_init.c
index 21b1ea4..c68d6ae 100644
--- a/src/afs/afs_init.c
+++ b/src/afs/afs_init.c
@@ -22,7 +22,7 @@
 #include "afsincludes.h"	/* Afs-based standard headers */
 #include "afs/afs_stats.h"	/* afs statistics */
 #include "rx/rxstat.h"
-#if defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
+#if defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
 # include <linux/cred.h>
 #endif
 
@@ -34,7 +34,7 @@
 afs_int32 cacheInfoModTime;	/*Last time cache info modified */
 #if defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_NBSD_ENV)
 struct mount *afs_cacheVfsp = 0;
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 struct super_block *afs_cacheSBp = 0;
 #else
 struct vfs *afs_cacheVfsp = 0;
@@ -52,7 +52,7 @@
 #endif
 afs_rwlock_t afs_discon_lock;
 extern afs_rwlock_t afs_disconDirtyLock;
-#if defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
+#if defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
 const struct cred *cache_creds;
 #endif
 
@@ -157,7 +157,7 @@
     if (code) {
 	return code;
     }
-#if defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
+#if defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
     /*
      * Save current credentials for later access to disk cache files.
      * If selinux, apparmor or other security modules are enabled,
@@ -253,14 +253,14 @@
 {
     afs_int32 code;
 
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
     struct dentry *dp;
     code = gop_lookupname(filename, AFS_UIOSYS, 0, &dp);
     if (code)
 	return code;
     osi_get_fh(dp, inode);
     dput(dp);
-#else /* AFS_LINUX22_ENV */
+#else /* AFS_LINUX_ENV */
     struct vnode *filevp;
     code = gop_lookupname(filename, AFS_UIOSYS, 0, &filevp);
     if (code)
@@ -275,7 +275,7 @@
     else {
 	AFS_RELE(filevp);
     }
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 
     return 0;
 }
@@ -383,7 +383,7 @@
     struct osi_stat tstat;
     struct osi_file *tfile;
     struct afs_fheader theader;
-#ifndef AFS_LINUX22_ENV
+#ifndef AFS_LINUX_ENV
     struct vnode *filevp;
 #endif
     int goodFile;
@@ -391,7 +391,7 @@
     AFS_STATCNT(afs_InitCacheInfo);
     if (cacheDiskType != AFS_FCACHE_TYPE_UFS)
 	osi_Panic("afs_InitCacheInfo --- called for non-ufs cache!");
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     code = osi_InitCacheInfo(afile);
     if (code)
 	return code;
@@ -423,7 +423,7 @@
 	if (!VFS_STATVFS(filevp->v_vfsp, &st))
 # elif defined(AFS_AIX41_ENV)
 	if (!VFS_STATFS(filevp->v_vfsp, &st, &afs_osi_cred))
-# elif defined(AFS_LINUX20_ENV)
+# elif defined(AFS_LINUX_ENV)
 	{
 	    KERNEL_SPACE_DECL;
 	    TO_USER_SPACE();
@@ -459,7 +459,7 @@
 	    afs_fsfragsize = st.f_bsize - 1;
 # endif /* AFS_SUN5_ENV || AFS_HPUX100_ENV */
     }
-# if defined(AFS_LINUX20_ENV)
+# if defined(AFS_LINUX_ENV)
     cacheInode.ufs = filevp->i_ino;
     afs_cacheSBp = filevp->i_sb;
 # elif defined(AFS_XBSD_ENV)
@@ -483,9 +483,9 @@
     afs_LookupInodeByPath(afile, &cacheInode.ufs, NULL);
 #  endif /* !AFS_CACHE_VNODE_PATH */
     cacheDev.dev = afs_vnodeToDev(filevp);
-# endif /* AFS_LINUX20_ENV */
+# endif /* AFS_LINUX_ENV */
     AFS_RELE(filevp);
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
     if (afs_fsfragsize < AFS_MIN_FRAGSIZE) {
 	afs_fsfragsize = AFS_MIN_FRAGSIZE;
     }
@@ -734,7 +734,7 @@
 	memset(&cacheDev, 0, sizeof(struct osi_dev));
 	osi_dnlc_shutdown();
     }
-#if defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
+#if defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
     put_cred(cache_creds);
 #endif
 }				/*shutdown_cache */
@@ -745,7 +745,7 @@
 {
     AFS_STATCNT(shutdown_vnodeops);
     if (afs_cold_shutdown) {
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
 	afs_rd_stash_i = 0;
 #endif
 	shutdown_mariner();
diff --git a/src/afs/afs_osi.c b/src/afs/afs_osi.c
index c970ea3..895bcc0 100644
--- a/src/afs/afs_osi.c
+++ b/src/afs/afs_osi.c
@@ -103,13 +103,13 @@
 	afs_osi_credp = kcred;
 #else
 	memset(&afs_osi_cred, 0, sizeof(afs_ucred_t));
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
         afs_set_cr_group_info(&afs_osi_cred, groups_alloc(0));
 #endif
 #if defined(AFS_DARWIN80_ENV)
         afs_osi_cred.cr_ref = 1; /* kauth_cred_get_ref needs 1 existing ref */
 #else
-# if !(defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED))
+# if !(defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED))
 	crhold(&afs_osi_cred);  /* don't let it evaporate */
 # endif
 #endif
@@ -129,7 +129,7 @@
 void
 afs_osi_MaskSignals(void)
 {
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     osi_linux_mask();
 #endif
 }
@@ -138,7 +138,7 @@
 void
 afs_osi_UnmaskRxkSignals(void)
 {
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     osi_linux_unmaskrxk();
 #endif
 }
@@ -173,7 +173,7 @@
 void
 afs_osi_Invisible(void)
 {
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     afs_osi_MaskSignals();
 #elif defined(AFS_SUN5_ENV)
     curproc->p_flag |= SSYS;
@@ -221,7 +221,7 @@
        afs_osi_ctxtp_initialized = 0;
     }
 #endif
-#if !defined(AFS_HPUX_ENV) && !defined(UKERNEL) && !defined(AFS_DFBSD_ENV) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_HPUX_ENV) && !defined(UKERNEL) && !defined(AFS_DFBSD_ENV) && !defined(AFS_LINUX_ENV)
     /* LINUX calls this from afs_cleanup() which hooks into module_exit */
     shutdown_osisleep();
 #endif
@@ -250,9 +250,9 @@
 		afs_osi_Free(tmp, sizeof(*tmp));
 #elif defined(AFS_SGI_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_SUN5_ENV)
 		osi_FreeSmallSpace(tmp);
-#elif defined(AFS_LINUX26_ENV)
+#elif defined(AFS_LINUX_ENV)
 		kfree(tmp);
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 		osi_linux_free(tmp);
 #endif
 	    }
diff --git a/src/afs/afs_osi.h b/src/afs/afs_osi.h
index 945c1e9..2fbe54b 100644
--- a/src/afs/afs_osi.h
+++ b/src/afs/afs_osi.h
@@ -11,7 +11,7 @@
 #define _AFS_OSI_
 
 #include "h/types.h"
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include "h/param.h"
 #endif
 
@@ -23,7 +23,7 @@
 #include <sys/lock.h>
 #endif
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #ifndef _LINUX_CODA_FS_I
 #define _LINUX_CODA_FS_I
 #define _CODA_HEADER_
@@ -60,10 +60,10 @@
 
 struct osi_file {
     afs_int32 size;		/* file size in bytes XXX Must be first field XXX */
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
     struct file *filp;		/* May need this if we really open the file. */
 #else
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     struct dentry dentry;	/* merely to hold the pointer to the inode. */
     struct file file;		/* May need this if we really open the file. */
 #else
@@ -133,7 +133,7 @@
  *
  * Darwin, all of the BSDs, and Linux have their own
  */
-#if !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_LINUX_ENV)
 # define	vType(vc)	    AFSTOV(vc)->v_type
 # define	vSetType(vc,type)   AFSTOV(vc)->v_type = (type)
 # define	vSetVfsp(vc,vfsp)   AFSTOV(vc)->v_vfsp = (vfsp)
diff --git a/src/afs/afs_osi_alloc.c b/src/afs/afs_osi_alloc.c
index 78254d6..4e76d32 100644
--- a/src/afs/afs_osi_alloc.c
+++ b/src/afs/afs_osi_alloc.c
@@ -50,7 +50,7 @@
 
     AFS_STATS(afs_stats_cmperf.OutStandingAllocs++);
     AFS_STATS(afs_stats_cmperf.OutStandingMemUsage += size);
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     return osi_linux_alloc(size, 1);
 #else
     return AFS_KALLOC(size);
@@ -66,7 +66,7 @@
 
     AFS_STATS(afs_stats_cmperf.OutStandingAllocs--);
     AFS_STATS(afs_stats_cmperf.OutStandingMemUsage -= asize);
-#if defined(AFS_LINUX20_ENV)
+#if defined(AFS_LINUX_ENV)
     osi_linux_free(x);
 #else
     AFS_KFREE(x, asize);
diff --git a/src/afs/afs_osi_pag.c b/src/afs/afs_osi_pag.c
index 22167f0..f53fc8b 100644
--- a/src/afs/afs_osi_pag.c
+++ b/src/afs/afs_osi_pag.c
@@ -71,19 +71,19 @@
 genpag(void)
 {
     AFS_STATCNT(genpag);
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     /* Ensure unique PAG's (mod 200 days) when reloading the client. */
     return (('A' << 24) + ((pag_epoch + pagCounter++) & 0xffffff));
-#else /* AFS_LINUX20_ENV */
+#else /* AFS_LINUX_ENV */
     return (('A' << 24) + (pagCounter++ & 0xffffff));
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 }
 
 afs_uint32
 getpag(void)
 {
     AFS_STATCNT(getpag);
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     /* Ensure unique PAG's (mod 200 days) when reloading the client. */
     return (('A' << 24) + ((pag_epoch + pagCounter) & 0xffffff));
 #else
@@ -100,18 +100,18 @@
 genpag(void)
 {
     AFS_STATCNT(genpag);
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     return (pag_epoch + pagCounter++);
 #else
     return (pagCounter++);
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 }
 
 afs_uint32
 getpag(void)
 {
     AFS_STATCNT(getpag);
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     /* Ensure unique PAG's (mod 200 days) when reloading the client. */
     return (pag_epoch + pagCounter);
 #else
@@ -251,7 +251,7 @@
 	credp = OSI_GET_CURRENT_CRED();
 	code = AddPag(genpag(), &credp);
     }
-#elif	defined(AFS_LINUX20_ENV)
+#elif	defined(AFS_LINUX_ENV)
     {
 	afs_ucred_t *credp = crref();
 	code = AddPag(genpag(), &credp);
@@ -362,7 +362,7 @@
 	credp = OSI_GET_CURRENT_CRED();
 	code = AddPag(pagval, &credp);
     }
-#elif	defined(AFS_LINUX20_ENV)
+#elif	defined(AFS_LINUX_ENV)
     {
 	afs_ucred_t *credp = crref();
 	code = AddPag(pagval, &credp);
@@ -451,7 +451,7 @@
 int
 afs_InitReq(struct vrequest *av, afs_ucred_t *acred)
 {
-#if defined(AFS_LINUX26_ENV) && !defined(AFS_NONFSTRANS)
+#if defined(AFS_LINUX_ENV) && !defined(AFS_NONFSTRANS)
     int code;
 #endif
 
@@ -460,7 +460,7 @@
     if (afs_shuttingdown == AFS_SHUTDOWN)
 	return EIO;
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 #if !defined(AFS_NONFSTRANS)
     if (osi_linux_nfs_initreq(av, acred, &code))
 	return code;
@@ -599,7 +599,7 @@
 }
 #endif
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 /* osi_get_group_pag is defined in <ARCH>/osi_groups.c */
 #elif defined(AFS_PAG_ONEGROUP_ENV)
 /* osi_get_group_pag is defined in <ARCH>/osi_groups.c */
@@ -639,10 +639,10 @@
 # if defined(AFS_AIX_ENV)
     if (cred->cr_ngrps < 2)
 	return NOPAG;
-# elif defined(AFS_LINUX26_ENV)
+# elif defined(AFS_LINUX_ENV)
     if (afs_cr_group_info(cred)->ngroups < AFS_NUMPAGGROUPS)
 	return NOPAG;
-# elif defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX20_ENV) || defined(AFS_XBSD_ENV)
+# elif defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_XBSD_ENV)
 #  if defined(AFS_SUN510_ENV)
     if (ngroups < 2) {
 #  else
@@ -678,7 +678,7 @@
 	return NOPAG;
     }
 #ifndef AFS_DARWIN110_ENV
-#if defined(AFS_LINUX26_ENV) && defined(LINUX_KEYRING_SUPPORT)
+#if defined(AFS_LINUX_ENV) && defined(LINUX_KEYRING_SUPPORT)
     /*
      * If linux keyrings are in use and we carry the session keyring in our credentials
      * structure, they should be the only criteria for determining
diff --git a/src/afs/afs_osi_vget.c b/src/afs/afs_osi_vget.c
index 5fd36bf..e9c6cc4 100644
--- a/src/afs/afs_osi_vget.c
+++ b/src/afs/afs_osi_vget.c
@@ -21,7 +21,7 @@
 
 
 
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN80_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN80_ENV)
 /* This is the common part of the vget VFS call. */
 int
 afs_osi_vget(struct vcache **avcpp, struct fid *afidp, struct vrequest *areqp)
@@ -72,4 +72,4 @@
 
     return code;
 }
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
diff --git a/src/afs/afs_osi_vm.c b/src/afs/afs_osi_vm.c
index 2b02b7d..450af20 100644
--- a/src/afs/afs_osi_vm.c
+++ b/src/afs/afs_osi_vm.c
@@ -22,7 +22,7 @@
 osi_Active(struct vcache *avc)
 {
     AFS_STATCNT(osi_Active);
-#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || (AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
+#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || (AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
     if ((avc->opens > 0) || (avc->f.states & CMAPPED))
 	return 1;		/* XXX: Warning, verify this XXX  */
 #elif defined(AFS_SGI_ENV)
diff --git a/src/afs/afs_pag_call.c b/src/afs/afs_pag_call.c
index a20e3e6..4cfd7cc 100644
--- a/src/afs/afs_pag_call.c
+++ b/src/afs/afs_pag_call.c
@@ -16,7 +16,7 @@
 #include "afs/afs_stats.h"
 #include "rx/rx_globals.h"
 #include "rx/rxstat.h"
-#if !defined(UKERNEL) && !defined(AFS_LINUX20_ENV)
+#if !defined(UKERNEL) && !defined(AFS_LINUX_ENV)
 #include "net/if.h"
 #include "netinet/in_var.h"
 #endif /* !defined(UKERNEL) */
diff --git a/src/afs/afs_pioctl.c b/src/afs/afs_pioctl.c
index f778846..89e7c41 100644
--- a/src/afs/afs_pioctl.c
+++ b/src/afs/afs_pioctl.c
@@ -312,7 +312,7 @@
 DECL_PIOCTL(PNewUuid);
 DECL_PIOCTL(PPrecache);
 DECL_PIOCTL(PGetPAG);
-#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX24_ENV)
+#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX_ENV)
 DECL_PIOCTL(PSetCachingThreshold);
 #endif
 
@@ -436,7 +436,7 @@
 static pioctlFunction OpioctlSw[]  = {
     PBogus,			/* 0 */
     PNFSNukeCreds,		/* 1 -- nuke all creds for NFS client */
-#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX24_ENV)
+#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX_ENV)
     PSetCachingThreshold        /* 2 -- get/set cache-bypass size threshold */
 #else
     PNoop                       /* 2 -- get/set cache-bypass size threshold */
@@ -708,7 +708,7 @@
 
     return (code);
 }
-#elif defined(AFS_LINUX22_ENV)
+#elif defined(AFS_LINUX_ENV)
 struct afs_ioctl_sys {
     unsigned int com;
     unsigned long arg;
@@ -1019,7 +1019,7 @@
 #endif
 
 /* macro to avoid adding any more #ifdef's to pioctl code. */
-#if defined(AFS_LINUX22_ENV) || defined(AFS_AIX41_ENV)
+#if defined(AFS_LINUX_ENV) || defined(AFS_AIX41_ENV)
 #define PIOCTL_FREE_CRED() crfree(credp)
 #else
 #define PIOCTL_FREE_CRED()
@@ -1045,7 +1045,7 @@
 #ifdef AFS_NEED_CLIENTCONTEXT
     afs_ucred_t *tmpcred = NULL;
 #endif
-#if defined(AFS_NEED_CLIENTCONTEXT) || defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX22_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
+#if defined(AFS_NEED_CLIENTCONTEXT) || defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
     afs_ucred_t *foreigncreds = NULL;
 #endif
     afs_int32 code = 0;
@@ -1053,7 +1053,7 @@
 #ifdef	AFS_AIX41_ENV
     struct ucred *credp = crref();	/* don't free until done! */
 #endif
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     cred_t *credp = crref();	/* don't free until done! */
     struct dentry *dp;
 #endif
@@ -1071,7 +1071,7 @@
     }
     if ((com & 0xff) == PSetClientContext) {
 #ifdef AFS_NEED_CLIENTCONTEXT
-#if defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX22_ENV)
+#if defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX_ENV)
 	code = HandleClientContext(&data, &com, &foreigncreds, credp);
 #else
 	code = HandleClientContext(&data, &com, &foreigncreds, osi_curcred());
@@ -1101,7 +1101,7 @@
 	 * like afs_osi_suser(cred) which, I think, is better since it
 	 * generalizes and supports multi cred environments...
 	 */
-#if defined(AFS_SUN5_ENV) || defined(AFS_LINUX22_ENV)
+#if defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
 	tmpcred = credp;
 	credp = foreigncreds;
 #elif defined(AFS_AIX41_ENV)
@@ -1122,7 +1122,7 @@
     if ((com & 0xff) == 15) {
 	/* special case prefetch so entire pathname eval occurs in helper process.
 	 * otherwise, the pioctl call is essentially useless */
-#if	defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX22_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
+#if	defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
 	code =
 	    Prefetch(path, &data, follow,
 		     foreigncreds ? foreigncreds : credp);
@@ -1142,13 +1142,13 @@
 	    lookupname(path, USR, follow, NULL, &vp,
 		       foreigncreds ? foreigncreds : credp);
 #else
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 	code = gop_lookupname_user(path, AFS_UIOUSER, follow, &dp);
 	if (!code)
 	    vp = (struct vnode *)dp->d_inode;
 #else
 	code = gop_lookupname_user(path, AFS_UIOUSER, follow, &vp);
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 #endif /* AFS_AIX41_ENV */
 	AFS_GLOCK();
 	if (code) {
@@ -1209,7 +1209,7 @@
 	    credp = OSI_GET_CURRENT_CRED();
 	    code = afs_HandlePioctl(vp, com, &data, follow, &credp);
 	}
-#elif defined(AFS_LINUX22_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
+#elif defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
 	code = afs_HandlePioctl(vp, com, &data, follow, &credp);
 #elif defined(UKERNEL)
 	code = afs_HandlePioctl(vp, com, &data, follow,
@@ -1235,7 +1235,7 @@
 	set_p_cred(u.u_procp, tmpcred);	/* restore original credentials */
 #elif	defined(AFS_SGI_ENV)
 	OSI_SET_CURRENT_CRED(tmpcred);	/* restore original credentials */
-#elif	defined(AFS_SUN5_ENV) || defined(AFS_LINUX22_ENV)
+#elif	defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
 	credp = tmpcred;		/* restore original credentials */
 #else
 	osi_curcred() = tmpcred;	/* restore original credentials */
@@ -1245,7 +1245,7 @@
     }
 #endif /* AFS_NEED_CLIENTCONTEXT */
     if (vp) {
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 	/*
 	 * Holding the global lock when calling dput can cause a deadlock
 	 * when the kernel calls back into afs_dentry_iput
@@ -1828,7 +1828,7 @@
 }
 
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
 static_inline int
 _settok_setParentPag(afs_ucred_t **cred)
 {
@@ -4612,7 +4612,7 @@
 #ifdef AFS_AIX51_ENV
     newcred->cr_groupset.gs_union.un_groups[0] = g0;
     newcred->cr_groupset.gs_union.un_groups[1] = g1;
-#elif defined(AFS_LINUX26_ENV)
+#elif defined(AFS_LINUX_ENV)
 # ifdef AFS_PAG_ONEGROUP_ENV
     afs_set_cr_group_info(newcred, groups_alloc(1)); /* nothing sets this */
     l = (((g0-0x3f00) & 0x3fff) << 14) | ((g1-0x3f00) & 0x3fff);
@@ -4639,8 +4639,8 @@
 #endif
 #ifdef AFS_AIX_ENV
     newcred->cr_ngrps = 2;
-#elif !defined(AFS_LINUX26_ENV) && !defined(AFS_SUN510_ENV)
-# if defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX22_ENV) || defined(AFS_FBSD_ENV)
+#elif !defined(AFS_LINUX_ENV) && !defined(AFS_SUN510_ENV)
+# if defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV)
     newcred->cr_ngroups = 2;
 # else
     for (i = 2; i < NGROUPS; i++)
@@ -5122,7 +5122,7 @@
     return 0;
 }
 
-#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX24_ENV)
+#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX_ENV)
 
 DECL_PIOCTL(PSetCachingThreshold)
 {
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index 748b2f5..e8d2c6b 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -637,8 +637,8 @@
 extern int osi_readRandom(void *, afs_size_t);
 
 /* LINUX/osi_misc.c */
-#ifdef AFS_LINUX20_ENV
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
+#ifdef AFS_LINUX_ENV
 extern int osi_lookupname(char *aname, uio_seg_t seg, int followlink,
 			  struct dentry **dpp);
 extern int osi_InitCacheInfo(char *aname);
@@ -702,7 +702,7 @@
 /* ARCH/osi_file.c */
 extern int afs_osicred_initialized;
 extern void *osi_UFSOpen(afs_dcache_id_t *ainode);
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
 extern void osi_get_fh(struct dentry *dp, afs_ufs_dcache_id_t *ainode);
 #endif
 extern int afs_osi_Stat(struct osi_file *afile,
@@ -741,7 +741,7 @@
 # endif /* AFS_XBSD_ENV */
 #endif /* UKERNEL */
 
-#if defined(AFS_LINUX26_ENV) || defined(AFS_PAG_ONEGROUP_ENV)
+#if defined(AFS_LINUX_ENV) || defined(AFS_PAG_ONEGROUP_ENV)
 extern afs_int32 osi_get_group_pag(afs_ucred_t *cred);
 #endif
 
@@ -787,7 +787,7 @@
 extern struct vfs *afs_globalVFS;
 #endif
 extern struct vcache *afs_globalVp;
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 extern void vcache2inode(struct vcache *avc);
 extern void vcache2fakeinode(struct vcache *rootvp, struct vcache *mpvp);
 #endif
@@ -1451,7 +1451,7 @@
 extern afs_int32 afs_uuid_create(afsUUID * uuid);
 extern u_short afs_uuid_hash(afsUUID * uuid);
 
-#if defined(AFS_SUN5_ENV) || defined(AFS_LINUX20_ENV) || defined(AFS_AIX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_SGI62_ENV) || defined(UKERNEL)
+#if defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_AIX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_SGI62_ENV) || defined(UKERNEL)
 #include "osi_prototypes.h"
 #endif
 
diff --git a/src/afs/afs_server.c b/src/afs/afs_server.c
index 7ae3951..5940e4e 100644
--- a/src/afs/afs_server.c
+++ b/src/afs/afs_server.c
@@ -37,7 +37,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #if !defined(UKERNEL)
-# if !defined(AFS_LINUX20_ENV)
+# if !defined(AFS_LINUX_ENV)
 #  include <net/if.h>
 # endif
 # include <netinet/in.h>
@@ -45,7 +45,7 @@
 # ifdef AFS_SGI62_ENV
 #  include "h/hashing.h"
 # endif
-# if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+# if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #  include <netinet/in_var.h>
 # endif /* AFS_HPUX110_ENV */
 # ifdef AFS_DARWIN_ENV
diff --git a/src/afs/afs_syscall.c b/src/afs/afs_syscall.c
index 9414f38..ebb0d14 100644
--- a/src/afs/afs_syscall.c
+++ b/src/afs/afs_syscall.c
@@ -19,7 +19,7 @@
 #include "afsincludes.h"	/* Afs-based standard headers */
 #include "afs/afs_stats.h"
 #include "rx/rx_globals.h"
-#if !defined(UKERNEL) && !defined(AFS_LINUX20_ENV)
+#if !defined(UKERNEL) && !defined(AFS_LINUX_ENV)
 #include "net/if.h"
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
@@ -113,7 +113,7 @@
     }
 #endif /* defined(AFS_SGI_ENV) && (_MIPS_SZLONG==64) */
 
-#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX20_ENV) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX_ENV) && !defined(AFS_IA64_LINUX_ENV)
     if (afs_in_compat_syscall()) {
 	struct afs_ioctl32 dst32;
 
@@ -313,7 +313,7 @@
 };
 
 
-#if defined(AFS_HPUX_64BIT_ENV) || defined(AFS_SUN5_64BIT_ENV) || (defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX20_ENV) && !defined(AFS_IA64_LINUX20_ENV)) || defined(NEED_IOCTL32)
+#if defined(AFS_HPUX_64BIT_ENV) || defined(AFS_SUN5_64BIT_ENV) || (defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX_ENV) && !defined(AFS_IA64_LINUX_ENV)) || defined(NEED_IOCTL32)
 static void
 iparam32_to_iparam(const struct iparam32 *src, struct iparam *dst)
 {
@@ -359,7 +359,7 @@
     }
 #endif /* AFS_SUN5_64BIT_ENV */
 
-#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX20_ENV) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX_ENV) && !defined(AFS_IA64_LINUX_ENV)
     if (afs_in_compat_syscall()) {
 	struct iparam32 dst32;
 
@@ -439,7 +439,7 @@
 	long parm5;
 	long parm6;
     } *uap = (struct a *)args;
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 struct afssysargs {
     long syscall;
     long parm1;
@@ -457,7 +457,7 @@
     long linux_ret = 0;
     long *retval = &linux_ret;
     long eparm[4];		/* matches AFSCALL_ICL in fstrace.c */
-# ifdef AFS_SPARC64_LINUX24_ENV
+# ifdef AFS_SPARC64_LINUX_ENV
     afs_int32 eparm32[4];
 # endif
     /* eparm is also used by AFSCALL_CALL in afsd.c */
@@ -506,7 +506,7 @@
 	return (ENODEV);
     }
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     /* setup uap for use below - pull out the magic decoder ring to know
      * which syscalls have folded argument lists.
      */
@@ -515,7 +515,7 @@
     uap->parm2 = parm2;
     uap->parm3 = parm3;
     if (syscall == AFSCALL_ICL || syscall == AFSCALL_CALL) {
-#ifdef AFS_SPARC64_LINUX24_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
 /* from arch/sparc64/kernel/sys_sparc32.c */
 #define AA(__x)                                \
 ({     unsigned long __ret;            \
@@ -526,7 +526,7 @@
 })
 
 
-#ifdef AFS_SPARC64_LINUX26_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
 	if (test_thread_flag(TIF_32BIT))
 #else
 	if (current->thread.flags & SPARC_FLAG_32BIT)
@@ -782,7 +782,7 @@
 			    uap->parm5, (long *)retval);
 #endif /* !AFS_NBSD40_ENV */
 	    AFS_GUNLOCK();
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 	    if (!code) {
 		/* ICL commands can return values. */
 		code = -linux_ret;	/* Gets negated again at exit below */
@@ -793,7 +793,7 @@
 		setuerror(code);
 #endif
 	    }
-#endif /* !AFS_LINUX20_ENV */
+#endif /* !AFS_LINUX_ENV */
 	} else {
 #if defined(KERNEL_HAVE_UERROR)
 	    setuerror(EINVAL);
@@ -808,7 +808,7 @@
     } /* 32 bit procs */
 #endif
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     code = -code;
 #endif
     return code;
diff --git a/src/afs/afs_user.c b/src/afs/afs_user.c
index e4a5196..8afc01d 100644
--- a/src/afs/afs_user.c
+++ b/src/afs/afs_user.c
@@ -18,7 +18,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #if !defined(UKERNEL)
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <net/if.h>
 #endif
 #include <netinet/in.h>
@@ -26,7 +26,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif /* ! AFS_HPUX110_ENV */
 #endif /* !defined(UKERNEL) */
@@ -712,7 +712,7 @@
     afs_GCPAGs_cred_count++;
 
     pag = PagInCred(pcred);
-#if defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_LINUX22_ENV)
+#if defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_LINUX_ENV)
     uid = (pag != NOPAG ? pag : afs_cr_uid(pcred));
 #elif defined(AFS_SUN510_ENV)
     uid = (pag != NOPAG ? pag : crgetruid(pcred));
diff --git a/src/afs/afs_util.c b/src/afs/afs_util.c
index 8bd595c..c360f71 100644
--- a/src/afs/afs_util.c
+++ b/src/afs/afs_util.c
@@ -20,7 +20,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #if !defined(UKERNEL)
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <net/if.h>
 #endif
 #include <netinet/in.h>
@@ -28,7 +28,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif /* ! AFS_HPUX110_ENV */
 #endif /* !defined(UKERNEL) */
diff --git a/src/afs/afs_vcache.c b/src/afs/afs_vcache.c
index 7e3a778..b953d89 100644
--- a/src/afs/afs_vcache.c
+++ b/src/afs/afs_vcache.c
@@ -62,7 +62,7 @@
 afs_rwlock_t afs_xvcache;	/*Lock: alloc new stat cache entries */
 afs_rwlock_t afs_xvreclaim;	/*Lock: entries reclaimed, not on free list */
 afs_lock_t afs_xvcb;		/*Lock: fids on which there are callbacks */
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
 static struct vcache *freeVCList;	/*Free list for stat cache entries */
 struct vcache *ReclaimedVCList;	/*Reclaimed list for stat entries */
 static struct vcache *Initial_freeVCList;	/*Initial list for above */
@@ -174,7 +174,7 @@
 	code = EBUSY;
 	goto bad;
     }
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     if (avc->nextfree || !avc->vlruq.prev || !avc->vlruq.next) {	/* qv afs.h */
 	refpanic("LRU vs. Free inconsistency");
     }
@@ -203,7 +203,7 @@
     /* remove entry from the volume hash table */
     QRemove(&avc->vhashq);
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
     {
 	struct pagewriter *pw, *store;
 	struct list_head tofree;
@@ -274,7 +274,7 @@
 	afs_evenZaps++;
 
     afs_vcount--;
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     /* put the entry in the free list */
     avc->nextfree = freeVCList;
     freeVCList = avc;
@@ -295,7 +295,7 @@
 	} else
 	    osi_Panic("flush vc refcnt < 1");
     }
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
     return 0;
 
   bad:
@@ -679,7 +679,7 @@
 void
 afs_FlushReclaimedVcaches(void)
 {
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     struct vcache *tvc;
     int code, fv_slept;
     struct vcache *tmpReclaimedVCList = NULL;
@@ -755,7 +755,7 @@
  *
  * Returns 1 if the stat cache looks stressed, and 0 otherwise.
  */
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 int
 afs_VCacheStressed(void)
 {
@@ -784,7 +784,7 @@
 	return 0;
     }
 }
-#else /* AFS_LINUX26_ENV */
+#else /* AFS_LINUX_ENV */
 int
 afs_VCacheStressed(void)
 {
@@ -795,7 +795,7 @@
     }
     return 1;
 }
-#endif /* AFS_LINUX26_ENV */
+#endif /* AFS_LINUX_ENV */
 
 int
 afs_ShakeLooseVCaches(afs_int32 anumber)
@@ -1016,7 +1016,7 @@
 
     afs_FlushReclaimedVcaches();
 
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
     if(!afsd_dynamic_vcaches && afs_vcount >= afs_maxvcount) {
 	afs_ShakeLooseVCaches(anumber);
 	if (afs_vcount >= afs_maxvcount) {
@@ -1028,7 +1028,7 @@
     if (tvc == NULL) {
 	return NULL;
     }
-#else /* AFS_LINUX22_ENV */
+#else /* AFS_LINUX_ENV */
     /* pull out a free cache entry */
     if (!freeVCList) {
 	afs_ShakeLooseVCaches(anumber);
@@ -1046,7 +1046,7 @@
 	afs_vcount++; /* balanced by FlushVCache */
     } /* end of if (!freeVCList) */
 
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 
 #if defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV)
     if (tvc->v)
@@ -1088,7 +1088,7 @@
      * we have to do this after attaching the vnode, because the reference
      * count may be held in the vnode itself */
 
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
     /* Hold it for the LRU (should make count 2) */
     osi_Assert(osi_vnhold(tvc) == 0);
 #elif !(defined (AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV))
@@ -2901,21 +2901,21 @@
 void
 afs_vcacheInit(int astatSize)
 {
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     struct vcache *tvp;
 #endif
     int i;
     if (!afs_maxvcount) {
 	afs_maxvcount = astatSize;	/* no particular limit on linux? */
     }
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     freeVCList = NULL;
 #endif
 
     AFS_RWLOCK_INIT(&afs_xvcache, "afs_xvcache");
     LOCK_INIT(&afs_xvcb, "afs_xvcb");
 
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     /* Allocate and thread the struct vcache entries */
     tvp = afs_osi_Alloc(astatSize * sizeof(struct vcache));
     osi_Assert(tvp != NULL);
@@ -3041,7 +3041,7 @@
     }
     afs_cbrSpace = 0;
 
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     afs_osi_Free(Initial_freeVCList, afs_cacheStats * sizeof(struct vcache));
 
 # ifdef  KERNEL_HAVE_PIN
diff --git a/src/afs/afs_volume.c b/src/afs/afs_volume.c
index 28179db..1f4a7b6 100644
--- a/src/afs/afs_volume.c
+++ b/src/afs/afs_volume.c
@@ -23,7 +23,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #if !defined(UKERNEL)
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <net/if.h>
 #endif
 #include <netinet/in.h>
@@ -31,7 +31,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif /* ! AFS_HPUX110_ENV */
 #endif /* !defined(UKERNEL) */
diff --git a/src/afs/afs_warn.c b/src/afs/afs_warn.c
index ba0b757..074e53f 100644
--- a/src/afs/afs_warn.c
+++ b/src/afs/afs_warn.c
@@ -21,7 +21,7 @@
 
 #if !defined(UKERNEL)
 
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 # include <net/if.h>
 # if defined(AFS_SUN5_ENV)
 #  include <sys/varargs.h>
@@ -36,7 +36,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif /* ! AFS_HPUX110_ENV */
 #endif /* !defined(UKERNEL) */
@@ -55,11 +55,11 @@
 #include <sys/fp_io.h>
 #endif
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
 # define afs_vprintf(fmt, ap) vprintk(fmt, ap)
 #elif defined(AFS_SGI_ENV)
 # define afs_vprintf(fmt, ap) icmn_err(CE_WARN, fmt, ap)
-#elif (defined(AFS_DARWIN80_ENV) && !defined(AFS_DARWIN90_ENV)) || (defined(AFS_LINUX22_ENV))
+#elif (defined(AFS_DARWIN80_ENV) && !defined(AFS_DARWIN90_ENV)) || (defined(AFS_LINUX_ENV))
 static_inline void
 afs_vprintf(const char *fmt, va_list ap)
 {
@@ -230,14 +230,14 @@
 {
     va_list ap;
 
-# ifdef AFS_LINUX20_ENV
+# ifdef AFS_LINUX_ENV
     AFS_STATCNT(afs_warn);
     if ((afs_showflags & GAGCONSOLE) || (afs_showflags & GAGUSER)) {
 	va_start(ap, fmt);
 	afs_vwarn(fmt, ap);
 	va_end(ap);
     }
-# else /* AFS_LINUX20_ENV */
+# else /* AFS_LINUX_ENV */
     AFS_STATCNT(afs_warn);
     if (afs_showflags & GAGCONSOLE) {
 	va_start(ap, fmt);
@@ -251,7 +251,7 @@
 	afs_vwarnuser(fmt, ap);
 	va_end(ap);
     }
-# endif /* AFS_LINUX20_ENV */
+# endif /* AFS_LINUX_ENV */
 }
 #endif /* AFS_AIX_ENV */
 
diff --git a/src/afs/afsincludes.h b/src/afs/afsincludes.h
index 3d0286e..1a4369e 100644
--- a/src/afs/afsincludes.h
+++ b/src/afs/afsincludes.h
@@ -23,7 +23,7 @@
 # elif defined(AFS_HPUX_ENV) || defined(AFS_NBSD_ENV)
 #  include "osi_vfs.h"
 # endif
-# if defined(AFS_SGI_ENV) || defined(AFS_LINUX20_ENV)
+# if defined(AFS_SGI_ENV) || defined(AFS_LINUX_ENV)
 #  include "osi_vfs.h"
 # endif
 # include "rx/rx.h"
@@ -31,13 +31,13 @@
 # include "afs/lock.h"
 # include "afs/volerrors.h"
 # include "afs/voldefs.h"
-# ifdef AFS_LINUX20_ENV
+# ifdef AFS_LINUX_ENV
 #  ifdef TRUE
 #   undef TRUE
 #   undef FALSE
 #  endif
 # endif
-# ifdef AFS_LINUX20_ENV
+# ifdef AFS_LINUX_ENV
 #  undef __NFDBITS
 #  undef __FDMASK
 # endif
@@ -54,7 +54,7 @@
 # include "afs/afs_stats.h"
 # include "afs/afs_prototypes.h"
 # include "afs/discon.h"
-# if defined(AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
+# if defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
 #  include "osi_machdep.h"
 # endif
 
diff --git a/src/afs/lock.h b/src/afs/lock.h
index 4d8bbee..c6e5193 100644
--- a/src/afs/lock.h
+++ b/src/afs/lock.h
@@ -80,7 +80,7 @@
 #  define MyPidxx current_pid()
 #  define MyPidxx2Pid(x) (x)
 # endif
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 typedef struct task_struct * afs_lock_tracker_t;
 # define MyPidxx (current)
 # define MyPidxx2Pid(x) (x? (x)->pid : 0)
diff --git a/src/afs/sysincludes.h b/src/afs/sysincludes.h
index 1f281c5..3e3e015 100644
--- a/src/afs/sysincludes.h
+++ b/src/afs/sysincludes.h
@@ -108,7 +108,7 @@
 # include <sys/protosw.h>
 # include <sys/ioctl.h>
 
-#elif defined(AFS_LINUX22_ENV)
+#elif defined(AFS_LINUX_ENV)
 # include <linux/version.h>
 # ifdef HAVE_LINUX_CONFIG_H
 #  include <linux/config.h>
@@ -121,7 +121,7 @@
 # include <linux/net.h>
 # include <linux/kdev_t.h>
 # include <linux/ioctl.h>
-# if defined(AFS_LINUX26_ENV)
+# if defined(AFS_LINUX_ENV)
 #  include <linux/compat.h>
 #  include <linux/backing-dev.h>
 #  include <linux/pagemap.h>
@@ -177,11 +177,11 @@
 # if defined(HAVE_LINUX_EXPORTFS_H)
 #  include <linux/exportfs.h>
 # endif
-# ifdef AFS_LINUX24_ENV
+# ifdef AFS_LINUX_ENV
 #  include <linux/pagemap.h>
 # endif
 
-#else /* AFS_LINUX22_ENV */
+#else /* AFS_LINUX_ENV */
 
 # include "h/errno.h"
 # include "h/types.h"
@@ -449,7 +449,7 @@
 #  include <sys/debug.h>
 # endif
 
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 
 #endif /* __AFS_SYSINCLUDESH__  so idempotent */
 
diff --git a/src/afsd/afsd.c b/src/afsd/afsd.c
index 3ea3cac..60dfde9 100644
--- a/src/afsd/afsd.c
+++ b/src/afsd/afsd.c
@@ -306,7 +306,7 @@
 				 * -2: file exists in top-level
 				 * >=0: file exists in Dxxx
 				 */
-#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX_ENV)
 AFSD_INO_T *inode_for_V;	/* Array of inodes for desired
 				 * cache files */
 #endif
@@ -1047,7 +1047,7 @@
 	     * file's inode, directory, and bump the number of files found
 	     * total and in this directory.
 	     */
-#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX_ENV)
 	    inode_for_V[vFileNum] = currp->d_ino;
 #endif
 	    dir_for_V[vFileNum] = dirNum;	/* remember this directory */
@@ -1131,7 +1131,7 @@
 	    SetNoBackupAttr(fullpn_CellInfoFile);
 	} else if ((strcmp(currp->d_name, ".") == 0)
 		   || (strcmp(currp->d_name, "..") == 0) ||
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 		   /* this is the ext3 journal file */
 		   (strcmp(currp->d_name, ".journal") == 0) ||
 #endif
@@ -1182,7 +1182,7 @@
 			   vFileNum);
 		else {
 		    struct stat statb;
-#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX_ENV)
 		    assert(inode_for_V[vFileNum] == (AFSD_INO_T) 0);
 #endif
 		    sprintf(vFilePtr, "D%d/V%d", thisDir, vFileNum);
@@ -1195,7 +1195,7 @@
 		    if (CreateCacheFile(fullpn_VFile, &statb))
 			printf("%s: Can't create '%s'\n", rn, fullpn_VFile);
 		    else {
-#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX_ENV)
 			inode_for_V[vFileNum] = statb.st_ino;
 #endif
 			dir_for_V[vFileNum] = thisDir;
@@ -1289,7 +1289,7 @@
 
     /* might want to check here for anything else goofy, like cache pointed at a non-dedicated directory, etc */
 
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
     {
 	int res;
 	struct statfs statfsbuf;
@@ -1298,7 +1298,7 @@
 	if (res != 0) {
 	    return "unable to statfs cache base directory";
 	}
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 	if (statfsbuf.f_type == 0x52654973) {	/* REISERFS_SUPER_MAGIC */
 	    return "cannot use reiserfs as cache partition";
 	} else if (statfsbuf.f_type == 0x58465342) {	/* XFS_SUPER_MAGIC */
@@ -2549,7 +2549,7 @@
 		   cacheStatEntries);
     }
 
-#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX_ENV)
     /*
      * Create and zero the inode table for the desired cache files.
      */
@@ -2944,7 +2944,7 @@
 		}
 		/* fall through to setup-by-inode */
 	    }
-#if defined(AFS_SGI62_ENV) || !(defined(AFS_LINUX26_ENV) || defined(AFS_CACHE_VNODE_PATH))
+#if defined(AFS_SGI62_ENV) || !(defined(AFS_LINUX_ENV) || defined(AFS_CACHE_VNODE_PATH))
 	    afsd_syscall(AFSOP_CACHEINODE, inode_for_V[currVFile]);
 #else
 	    printf
diff --git a/src/afsd/afsd_kernel.c b/src/afsd/afsd_kernel.c
index 28e7646..4a969ea 100644
--- a/src/afsd/afsd_kernel.c
+++ b/src/afsd/afsd_kernel.c
@@ -31,7 +31,7 @@
 #include <sys/file.h>
 #include <sys/wait.h>
 
-#if defined(AFS_LINUX20_ENV)
+#if defined(AFS_LINUX_ENV)
 #include <sys/resource.h>
 #endif
 
@@ -112,7 +112,7 @@
 # define SET_AFSD_RTPRI() SET_RTPRI(68)
 # define SET_RX_RTPRI()   SET_RTPRI(199)
 #else
-# ifdef AFS_LINUX20_ENV
+# ifdef AFS_LINUX_ENV
 #  define SET_AFSD_RTPRI()
 #  define SET_RX_RTPRI() do { \
     if (setpriority(PRIO_PROCESS, 0, -10) < 0) \
@@ -136,7 +136,7 @@
     SET_AFSD_RTPRI();
 }
 
-#if defined(AFS_LINUX20_ENV)
+#if defined(AFS_LINUX_ENV)
 int
 os_syscall(struct afsd_syscall_args *args)
 {
@@ -391,9 +391,9 @@
 static int
 HandleMTab(char *cacheMountDir)
 {
-#if (defined (AFS_HPUX_ENV) || defined(AFS_SGI_ENV) || defined(AFS_LINUX20_ENV))
+#if (defined (AFS_HPUX_ENV) || defined(AFS_SGI_ENV) || defined(AFS_LINUX_ENV))
     FILE *tfilep;
-#if defined(AFS_SGI_ENV) || defined(AFS_LINUX20_ENV)
+#if defined(AFS_SGI_ENV) || defined(AFS_LINUX_ENV)
     struct mntent tmntent;
     char *dir;
     int i;
@@ -507,7 +507,7 @@
     mountFlags = MS_FSS;
     if ((mount(MOUNT_AFS, cacheMountDir, mountFlags, (caddr_t) MOUNT_AFS))
 	< 0) {
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
     if ((mount("AFS", cacheMountDir, MOUNT_AFS, 0, NULL)) < 0) {
 #elif defined(AFS_NBSD50_ENV)
     if ((mount(MOUNT_AFS, cacheMountDir, mountFlags, NULL, 0)) < 0) {
diff --git a/src/auth/ktc.c b/src/auth/ktc.c
index c04bc86..84879ef 100644
--- a/src/auth/ktc.c
+++ b/src/auth/ktc.c
@@ -50,7 +50,7 @@
 #include <afs/sys_prototypes.h>
 #endif
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
 #include <sys/syscall.h>
 #if defined(SYS_keyctl)
 /* Open code this value to avoid a dependency on keyutils */
@@ -297,7 +297,7 @@
 #endif /* NO_AFS_CLIENT */
     if (code)
 	return KTC_PIOCTLFAIL;
-#if defined(AFS_LINUX26_ENV) && defined(SYS_keyctl)
+#if defined(AFS_LINUX_ENV) && defined(SYS_keyctl)
     else
         /*
          * If we're using keyring based PAGs and the SESSION_TO_PARENT keyctl
@@ -372,7 +372,7 @@
 
     if (code)
 	return KTC_PIOCTLFAIL;
-#if defined(AFS_LINUX26_ENV) && defined(SYS_keyctl)
+#if defined(AFS_LINUX_ENV) && defined(SYS_keyctl)
     else
 	/*
 	 * If we're using keyring based PAGs and the SESSION_TO_PARENT keyctl
diff --git a/src/bozo/bnode.c b/src/bozo/bnode.c
index 9dab6d0..b97fea5 100644
--- a/src/bozo/bnode.c
+++ b/src/bozo/bnode.c
@@ -774,7 +774,7 @@
 	setsid();
 #elif defined(AFS_DARWIN90_ENV)
 	setpgid(0, 0);
-#elif defined(AFS_LINUX20_ENV) || defined(AFS_AIX_ENV)
+#elif defined(AFS_LINUX_ENV) || defined(AFS_AIX_ENV)
 	setpgrp();
 #else
 	setpgrp(0, 0);
diff --git a/src/butc/afsxbsa.c b/src/butc/afsxbsa.c
index aee6b48..d8ec545 100644
--- a/src/butc/afsxbsa.c
+++ b/src/butc/afsxbsa.c
@@ -17,7 +17,7 @@
 
 #include <ctype.h>
 
-#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX26_ENV)
+#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
 #include <dlfcn.h>
 #endif
 
@@ -630,9 +630,9 @@
 #endif
 #if defined(AFS_AIX_ENV)
         dynlib = dlopen("/usr/lib/libApiDS.a(dsmapish.o)", RTLD_NOW | RTLD_LOCAL | RTLD_MEMBER);
-#elif defined (AFS_AMD64_LINUX26_ENV)
+#elif defined (AFS_AMD64_LINUX_ENV)
 	dynlib = dlopen("/usr/lib64/libApiTSM64.so", RTLD_NOW | RTLD_LOCAL);
-#elif defined(AFS_SUN5_ENV) || defined(AFS_LINUX26_ENV)
+#elif defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
         dynlib = dlopen("/usr/lib/libApiDS.so", RTLD_NOW | RTLD_LOCAL);
 #else
         dynlib = NULL;
@@ -646,7 +646,7 @@
 #ifdef DEBUG_BUTC
     	printf("dsm_MountLibrary : SUCCESS to Open the libApiDS shared library. \n");
 #endif
-#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX26_ENV)
+#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
 	AFSdsmBeginQuery = (dsInt16_t (*)( dsUint32_t dsmHandle, dsmQueryType queryType, dsmQueryBuff *queryBuffer)) dlsym((void *)dynlib, "dsmBeginQuery");
 	AFSdsmGetNextQObj = (dsInt16_t (*)( dsUint32_t dsmHandle, DataBlk *dataBlkPtr))dlsym((void *)dynlib, "dsmGetNextQObj") ;
 	AFSdsmEndQuery = (dsInt16_t (*)( dsUint32_t dsmHandle))dlsym((void *)dynlib, "dsmEndQuery");
diff --git a/src/butc/butc_xbsa.c b/src/butc/butc_xbsa.c
index f2da6a6..f45f610 100644
--- a/src/butc/butc_xbsa.c
+++ b/src/butc/butc_xbsa.c
@@ -229,7 +229,7 @@
     XBSAQueryApiVersion(&(info->apiVersion));
 #endif
 #else
-#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX26_ENV)
+#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
     XBSAInit                    = BSAInit;
     XBSABeginTxn                = BSABeginTxn;
     XBSAEndTxn                  = BSAEndTxn;
diff --git a/src/butm/file_tm.c b/src/butm/file_tm.c
index fd4c8d7..7f063db 100644
--- a/src/butm/file_tm.c
+++ b/src/butm/file_tm.c
@@ -676,7 +676,7 @@
 
     if (info->posCount >= 2147467264) {	/* 2GB - 16K */
 	info->posCount = 0;
-#if (defined(AFS_SUN_ENV) || defined(AFS_LINUX24_ENV))
+#if (defined(AFS_SUN_ENV) || defined(AFS_LINUX_ENV))
 	if (!isafile) {
 	    afs_int64 off;
 
diff --git a/src/config/afs_args.h b/src/config/afs_args.h
index c016791..bf6b3ae 100644
--- a/src/config/afs_args.h
+++ b/src/config/afs_args.h
@@ -235,7 +235,7 @@
 
 /* Defines and structures for the AFS proc replacement layer for the original syscall (AFS_SYSCALL) strategy */
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 
 #define PROC_FSDIRNAME "openafs"
 #define PROC_SYSCALL_NAME "afs_ioctl"
diff --git a/src/config/param.alpha_linux_26.h b/src/config/param.alpha_linux_26.h
index 62ffd99..55ae09f 100644
--- a/src/config/param.alpha_linux_26.h
+++ b/src/config/param.alpha_linux_26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_ALPHA_LINUX20_ENV	1
-#define AFS_ALPHA_LINUX22_ENV	1
-#define AFS_ALPHA_LINUX24_ENV	1
-#define AFS_ALPHA_LINUX26_ENV	1
+#define AFS_ALPHA_LINUX_ENV	1
 #define __alpha			1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits */
diff --git a/src/config/param.amd64_linux26.h b/src/config/param.amd64_linux26.h
index c14657a..09e5287 100644
--- a/src/config/param.amd64_linux26.h
+++ b/src/config/param.amd64_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_AMD64_LINUX20_ENV	1
-#define AFS_AMD64_LINUX22_ENV	1
-#define AFS_AMD64_LINUX24_ENV	1
-#define AFS_AMD64_LINUX26_ENV	1
+#define AFS_AMD64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits */
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.arm64_linux26.h b/src/config/param.arm64_linux26.h
index 02e867a..fa5b39f1 100644
--- a/src/config/param.arm64_linux26.h
+++ b/src/config/param.arm64_linux26.h
@@ -13,7 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_ARM64_LINUX26_ENV	1
+#define AFS_ARM64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits */
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.arm_linux26.h b/src/config/param.arm_linux26.h
index 1339fd0..2b32488 100644
--- a/src/config/param.arm_linux26.h
+++ b/src/config/param.arm_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_ARM_LINUX20_ENV	1
-#define AFS_ARM_LINUX22_ENV	1
-#define AFS_ARM_LINUX24_ENV	1
-#define AFS_ARM_LINUX26_ENV	1
+#define AFS_ARM_LINUX_ENV	1
 
 #else /* !defined(UKERNEL) */
 
diff --git a/src/config/param.i386_linux26.h b/src/config/param.i386_linux26.h
index 35ff066..48ad0b9 100644
--- a/src/config/param.i386_linux26.h
+++ b/src/config/param.i386_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_I386_LINUX20_ENV	1
-#define AFS_I386_LINUX22_ENV	1
-#define AFS_I386_LINUX24_ENV	1
-#define AFS_I386_LINUX26_ENV	1
+#define AFS_I386_LINUX_ENV	1
 
 #else /* !defined(UKERNEL) */
 
diff --git a/src/config/param.i386_umlinux26.h b/src/config/param.i386_umlinux26.h
index 8b70ae6..090c355 100644
--- a/src/config/param.i386_umlinux26.h
+++ b/src/config/param.i386_umlinux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_I386_LINUX20_ENV	1
-#define AFS_I386_LINUX22_ENV	1
-#define AFS_I386_LINUX24_ENV	1
-#define AFS_I386_LINUX26_ENV	1
+#define AFS_I386_LINUX_ENV	1
 
 #else /* !defined(UKERNEL) */
 
diff --git a/src/config/param.ia64_linux26.h b/src/config/param.ia64_linux26.h
index 04e3fd7..402af6a 100644
--- a/src/config/param.ia64_linux26.h
+++ b/src/config/param.ia64_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_IA64_LINUX20_ENV	1
-#define AFS_IA64_LINUX22_ENV	1
-#define AFS_IA64_LINUX24_ENV	1
-#define AFS_IA64_LINUX26_ENV	1
+#define AFS_IA64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits. */
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.linux26.h b/src/config/param.linux26.h
index 2054d89..05686f0 100644
--- a/src/config/param.linux26.h
+++ b/src/config/param.linux26.h
@@ -15,10 +15,7 @@
 /* This section for kernel libafs compiles only */
 #include <linux/version.h>
 
-#define AFS_LINUX20_ENV		1
-#define AFS_LINUX22_ENV		1
-#define AFS_LINUX24_ENV		1
-#define AFS_LINUX26_ENV		1
+#define AFS_LINUX_ENV		1
 
 #define AFS_MOUNT_AFS		"afs"	/* The name of the filesystem type */
 #define AFS_64BIT_IOPS_ENV	1
@@ -64,10 +61,8 @@
 #else /* !defined(UKERNEL) */
 
 /* This section for user space compiles only */
-#define AFS_USR_LINUX20_ENV	1
-#define AFS_USR_LINUX22_ENV	1
-#define AFS_USR_LINUX24_ENV	1
-#define AFS_USR_LINUX26_ENV	1
+
+#define AFS_USR_LINUX_ENV	1
 
 #define AFS_ENV			1
 #define AFS_64BIT_CLIENT	1
diff --git a/src/config/param.ppc64_linux26.h b/src/config/param.ppc64_linux26.h
index 3c83386..3ac7d3d 100644
--- a/src/config/param.ppc64_linux26.h
+++ b/src/config/param.ppc64_linux26.h
@@ -12,10 +12,7 @@
 
 #ifndef UKERNEL
 /* This section for kernel space compiles only */
-#define AFS_PPC64_LINUX20_ENV	1
-#define AFS_PPC64_LINUX22_ENV	1
-#define AFS_PPC64_LINUX24_ENV	1
-#define AFS_PPC64_LINUX26_ENV	1
+#define AFS_PPC64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1     /* pointers are 64 bits */
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.ppc64le_linux26.h b/src/config/param.ppc64le_linux26.h
index 9c8b822..ca3aba8 100644
--- a/src/config/param.ppc64le_linux26.h
+++ b/src/config/param.ppc64le_linux26.h
@@ -12,10 +12,7 @@
 
 #ifndef UKERNEL
 /* This section for kernel space compiles only */
-#define AFS_PPC64_LINUX20_ENV	1
-#define AFS_PPC64_LINUX22_ENV	1
-#define AFS_PPC64_LINUX24_ENV	1
-#define AFS_PPC64_LINUX26_ENV	1
+#define AFS_PPC64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1     /* pointers are 64 bits */
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.ppc_linux26.h b/src/config/param.ppc_linux26.h
index fd6ee45..60fcb28 100644
--- a/src/config/param.ppc_linux26.h
+++ b/src/config/param.ppc_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_PPC_LINUX20_ENV	1
-#define AFS_PPC_LINUX22_ENV	1
-#define AFS_PPC_LINUX24_ENV	1
-#define AFS_PPC_LINUX26_ENV	1
+#define AFS_PPC_LINUX_ENV	1
 
 #else /* !defined(UKERNEL) */
 
diff --git a/src/config/param.s390_linux26.h b/src/config/param.s390_linux26.h
index 6757c4c..cd2ba4d 100644
--- a/src/config/param.s390_linux26.h
+++ b/src/config/param.s390_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_S390_LINUX20_ENV	1
-#define AFS_S390_LINUX22_ENV	1
-#define AFS_S390_LINUX24_ENV	1
-#define AFS_S390_LINUX26_ENV	1
+#define AFS_S390_LINUX_ENV	1
 
 #else /* !defined(UKERNEL) */
 
diff --git a/src/config/param.s390x_linux26.h b/src/config/param.s390x_linux26.h
index 1606c23..cc65dbd 100644
--- a/src/config/param.s390x_linux26.h
+++ b/src/config/param.s390x_linux26.h
@@ -13,14 +13,8 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_S390_LINUX20_ENV	1
-#define AFS_S390_LINUX22_ENV	1
-#define AFS_S390_LINUX24_ENV	1
-#define AFS_S390_LINUX26_ENV	1
-#define AFS_S390X_LINUX20_ENV	1
-#define AFS_S390X_LINUX22_ENV	1
-#define AFS_S390X_LINUX24_ENV	1
-#define AFS_S390X_LINUX26_ENV	1
+#define AFS_S390_LINUX_ENV	1
+#define AFS_S390X_LINUX_ENV	1
 
 #define AFS_64BITPOINTER_ENV	1
 #define AFS_64BITUSERPOINTER_ENV	1
@@ -30,10 +24,7 @@
 
 /* This section for user space compiles only */
 #define UKERNEL			1	/* user space kernel */
-#define AFS_S390X_LINUX20_ENV	1
-#define AFS_S390X_LINUX22_ENV	1
-#define AFS_S390X_LINUX24_ENV	1
-#define AFS_S390X_LINUX26_ENV	1
+#define AFS_S390X_LINUX_ENV	1
 
 #define AFS_64BITPOINTER_ENV	1
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.sparc64_linux26.h b/src/config/param.sparc64_linux26.h
index c51b66d..9e90cba 100644
--- a/src/config/param.sparc64_linux26.h
+++ b/src/config/param.sparc64_linux26.h
@@ -12,10 +12,7 @@
 
 #ifndef UKERNEL
 /* This section for kernel libafs compiles only */
-#define AFS_SPARC64_LINUX20_ENV	1
-#define AFS_SPARC64_LINUX22_ENV	1
-#define AFS_SPARC64_LINUX24_ENV	1
-#define AFS_SPARC64_LINUX26_ENV	1
+#define AFS_SPARC64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits. */
 #define AFS_32BIT_USR_ENV	1	/* user level processes are 32bit */
diff --git a/src/config/param.sparc_linux26.h b/src/config/param.sparc_linux26.h
index 349907e..82dd98d 100644
--- a/src/config/param.sparc_linux26.h
+++ b/src/config/param.sparc_linux26.h
@@ -12,9 +12,7 @@
 
 #ifndef UKERNEL
 /* This section for kernel libafs compiles only */
-#define AFS_SPARC_LINUX20_ENV	1
-#define AFS_SPARC_LINUX22_ENV	1
-#define AFS_SPARC_LINUX24_ENV	1
+#define AFS_SPARC_LINUX_ENV	1
 
 #if defined(__KERNEL__) && !defined(KDUMP_KERNEL)
 #if defined(AFS_SMP) && defined(CONFIG_MODVERSIONS)
diff --git a/src/config/stds.h b/src/config/stds.h
index e3acab3..0b28e4d 100644
--- a/src/config/stds.h
+++ b/src/config/stds.h
@@ -299,7 +299,7 @@
 # define AFS_NONNULL(x)
 #endif
 
-#if defined(AFS_LINUX26_ENV) && defined(fallthrough)
+#if defined(AFS_LINUX_ENV) && defined(fallthrough)
 # define AFS_FALLTHROUGH fallthrough
 #elif defined(HAVE_FUNC_ATTRIBUTE_FALLTHROUGH)
 # define AFS_FALLTHROUGH __attribute__((fallthrough))
diff --git a/src/crypto/hcrypto/kernel/config.h b/src/crypto/hcrypto/kernel/config.h
index ef89ed4..9623fa9 100644
--- a/src/crypto/hcrypto/kernel/config.h
+++ b/src/crypto/hcrypto/kernel/config.h
@@ -102,7 +102,7 @@
 # undef HAVE_ARC4RANDOM
 #endif
 
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 /*
  * gettimeofday is only used in rand-fortuna.c, not built for Linux.
  * Linux 5.6 removes the native struct timeval, so this stub would not build.
@@ -111,7 +111,7 @@
     {if (tp == NULL) return -1; tp->tv_sec = osi_Time(); tp->tv_usec = 0; return 0;}
 #endif
 
-#if defined(KERNEL) && (defined(AFS_SUN5_ENV) || defined(AFS_ARM64_LINUX26_ENV))
+#if defined(KERNEL) && (defined(AFS_SUN5_ENV) || defined(AFS_ARM64_LINUX_ENV))
 /*
  * Some functions such as RAND_add take a 'double' as an argument, but floating
  * point code generally cannot be used in kernelspace. We never actually use
diff --git a/src/dir/dir.c b/src/dir/dir.c
index 8aa336d..765d5f3 100644
--- a/src/dir/dir.c
+++ b/src/dir/dir.c
@@ -13,7 +13,7 @@
 #ifdef KERNEL
 # if !defined(UKERNEL)
 #  include "h/types.h"
-#  if !defined(AFS_LINUX26_ENV)
+#  if !defined(AFS_LINUX_ENV)
 #   include "h/param.h"
 #  endif
 #  ifdef	AFS_AUX_ENV
@@ -24,10 +24,10 @@
 #   include "h/errno.h"
 #  endif
 #  include "h/time.h"
-#  if defined(AFS_AIX_ENV) || defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX20_ENV)
+#  if defined(AFS_AIX_ENV) || defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
 #   include "h/errno.h"
 #  else
-#   if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX20_ENV)
+#   if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX_ENV)
 #    include "h/kernel.h"
 #   endif
 #  endif
@@ -38,10 +38,10 @@
 #   include "h/user.h"
 #  endif /* AFS_SGI64_ENV */
 #  include "h/uio.h"
-#  if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_HPUX110_ENV)
+#  if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_HPUX110_ENV)
 #   include "h/mbuf.h"
 #  endif
-#  ifndef AFS_LINUX20_ENV
+#  ifndef AFS_LINUX_ENV
 #   include "netinet/in.h"
 #  endif
 # else /* !defined(UKERNEL) */
@@ -60,7 +60,7 @@
 
 # include "afs/dir.h"
 
-# ifdef AFS_LINUX20_ENV
+# ifdef AFS_LINUX_ENV
 #  include "h/string.h"
 # endif
 
diff --git a/src/fsint/afsaux.c b/src/fsint/afsaux.c
index 3eeca5a..6d14ef7 100644
--- a/src/fsint/afsaux.c
+++ b/src/fsint/afsaux.c
@@ -20,7 +20,7 @@
 #if defined(AFS_NBSD50_ENV)
 #include "afs/afs_osi.h"
 #endif
-#if defined(AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
+#if defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
 #include "afs/sysincludes.h"
 #include "afsincludes.h"
 #else
diff --git a/src/gtx/curseswindows.c b/src/gtx/curseswindows.c
index 0c20017..6330302 100644
--- a/src/gtx/curseswindows.c
+++ b/src/gtx/curseswindows.c
@@ -20,7 +20,7 @@
 
 #include <roken.h>
 
-#if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_FBSD_ENV)
+#if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_FBSD_ENV)
 #include <sgtty.h>
 #endif
 
diff --git a/src/kauth/kalog.h b/src/kauth/kalog.h
index 2a0801e..f572a82 100644
--- a/src/kauth/kalog.h
+++ b/src/kauth/kalog.h
@@ -30,7 +30,7 @@
 #define	LOG_TGTREQUEST		8
 
 #ifdef AUTH_DBM_LOG
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include <gdbm.h>
 #define dbm_store	gdbm_store
 #define dbm_firstkey	gdbm_firstkey
@@ -41,7 +41,7 @@
 #define DBM GDBM_FILE
 #define DBM_REPLACE GDBM_REPLACE
 
-#else /* AFS_LINUX20_ENV */
+#else /* AFS_LINUX_ENV */
 #include <ndbm.h>
 #define afs_dbm_nextkey(d, k) dbm_nextkey(d)
 #endif
diff --git a/src/kauth/kaserver.c b/src/kauth/kaserver.c
index da824bc..844ecda 100644
--- a/src/kauth/kaserver.c
+++ b/src/kauth/kaserver.c
@@ -55,7 +55,7 @@
 int MinHours = 0;
 int npwSums = KA_NPWSUMS;	/* needs to be variable sometime */
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
 #undef vfprintf
 #define vfprintf(stream,fmt,args) _doprnt(fmt,args,stream)
 #endif
diff --git a/src/kauth/kauth.rg b/src/kauth/kauth.rg
index 80e5b11..87fce62 100644
--- a/src/kauth/kauth.rg
+++ b/src/kauth/kauth.rg
@@ -71,7 +71,7 @@
  * On Linux, dbm is not part of the standard installation, and we can't
  * statically link it in. So, ignore it for now.
  */
-%#if !defined(AFS_HPUX_ENV) && !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV)
+%#if !defined(AFS_HPUX_ENV) && !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV)
 %#define AUTH_DBM_LOG
 %#endif
 
diff --git a/src/kauth/user.c b/src/kauth/user.c
index 14cd1b0..c913741 100644
--- a/src/kauth/user.c
+++ b/src/kauth/user.c
@@ -163,7 +163,7 @@
     }
 #endif
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_USR_LINUX20_ENV) && (!defined(AFS_XBSD_ENV) || defined(AFS_FBSD_ENV))
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_USR_LINUX_ENV) && (!defined(AFS_XBSD_ENV) || defined(AFS_FBSD_ENV))
     /* handle smoothly the case where no AFS system calls exists (yet) */
     (void)signal(SIGSYS, SIG_IGN);
 #endif
diff --git a/src/libuafs/MakefileProto.LINUX.in b/src/libuafs/MakefileProto.LINUX.in
index 3647a4d..4dd185a 100644
--- a/src/libuafs/MakefileProto.LINUX.in
+++ b/src/libuafs/MakefileProto.LINUX.in
@@ -22,7 +22,7 @@
 UAFS_CFLAGS=-fPIC
 endif
 
-TEST_CFLAGS=-pthread -D_REENTRANT -DAFS_PTHREAD_ENV -DAFS_LINUX22_ENV $(XCFLAGS)
+TEST_CFLAGS=-pthread -D_REENTRANT -DAFS_PTHREAD_ENV -DAFS_LINUX_ENV $(XCFLAGS)
 TEST_LDFLAGS=
 TEST_LIBS=-lpthread @LIB_crypt@
 
diff --git a/src/lwp/iomgr.c b/src/lwp/iomgr.c
index 670fd29..1251d06 100644
--- a/src/lwp/iomgr.c
+++ b/src/lwp/iomgr.c
@@ -201,7 +201,7 @@
 
 /* On Linux without __USE_XOPEN, we have __fds_bits. With __USE_XOPEN, or
  * non-Linux, we have fds_bits. */
-#if defined(AFS_LINUX22_ENV) && (__GLIBC_MINOR__ > 0) && !defined(__USE_XOPEN)
+#if defined(AFS_LINUX_ENV) && (__GLIBC_MINOR__ > 0) && !defined(__USE_XOPEN)
 # define FDS_BITS __fds_bits
 #else
 # define FDS_BITS fds_bits
@@ -473,7 +473,7 @@
 		iomgr_timeout.tv_sec = 100000000;
 		iomgr_timeout.tv_usec = 0;
 	    }
-#if defined(AFS_NT40_ENV) || defined(AFS_LINUX24_ENV)
+#if defined(AFS_NT40_ENV) || defined(AFS_LINUX_ENV)
 	    /* On NT, signals don't interrupt a select call. So this can potentially
 	     * lead to long wait times before a signal is honored. To avoid this we
 	     * dont do select() for longer than IOMGR_MAXWAITTIME (5 secs) */
@@ -565,7 +565,7 @@
 		/* Real timeout only if signal handler hasn't set
 		   iomgr_timeout to zero. */
 
-#if defined(AFS_NT40_ENV) || defined(AFS_LINUX24_ENV)
+#if defined(AFS_NT40_ENV) || defined(AFS_LINUX_ENV)
 		/* On NT, real timeout only if above and if iomgr_timeout
 		 * interval is equal to timeout interval (i.e., not adjusted
 		 * to check for pseudo-signals).
diff --git a/src/lwp/lwp.c b/src/lwp/lwp.c
index 87417d7..c7deffc 100644
--- a/src/lwp/lwp.c
+++ b/src/lwp/lwp.c
@@ -33,8 +33,8 @@
 int setlim(int limcon, uchar_t hard, int limit);
 #endif
 
-#ifndef AFS_ARM_LINUX20_ENV
-#if defined(AFS_S390_LINUX20_ENV)
+#ifndef AFS_ARM_LINUX_ENV
+#if defined(AFS_S390_LINUX_ENV)
 int PRE_Block;	/* Remnants of preemption support. */
 #else
 char PRE_Block;	/* Remnants of preemption support. */
@@ -365,7 +365,7 @@
 	Initialize_PCB(temp, priority, stackmemory, stacksize, ep, parm, name);
 	insert(temp, &runnable[priority]);
 	temp2 = lwp_cpptr;
-#if !defined(AFS_ARM_LINUX20_ENV) && !defined(AFS_ARM_DARWIN_ENV)
+#if !defined(AFS_ARM_LINUX_ENV) && !defined(AFS_ARM_DARWIN_ENV)
 	if (PRE_Block != 0)
 	    Abort_LWP("PRE_Block not 0");
 
@@ -385,18 +385,18 @@
 	savecontext(Create_Process_Part2, &temp2->context, stackptr + stacksize - 16);	/* 16 = 2 * jmp_buf_type */
 #endif /* !sys_x86_darwin_80 */
 #else
-#if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV)
 	savecontext(Create_Process_Part2, &temp2->context, stackptr + stacksize - 0x40);	/* lomgjmp does something
 												 * with %fp + 0x38 */
 #else
-#if defined(AFS_S390_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV)
 	savecontext(Create_Process_Part2, &temp2->context,
 		    stackptr + stacksize - MINFRAME);
-#else /* !AFS_S390_LINUX20_ENV */
+#else /* !AFS_S390_LINUX_ENV */
 	savecontext(Create_Process_Part2, &temp2->context,
 		    stackptr + stacksize - sizeof(void *));
-#endif /* AFS_S390_LINUX20_ENV */
-#endif /* AFS_SPARC64_LINUX20_ENV || AFS_SPARC_LINUX20_ENV */
+#endif /* AFS_S390_LINUX_ENV */
+#endif /* AFS_SPARC64_LINUX_ENV || AFS_SPARC_LINUX_ENV */
 #endif /* AFS_SGI62_ENV */
 #endif
 	/* End of gross hack */
@@ -456,7 +456,7 @@
 	Initialize_PCB(temp, priority, stackptr, stacksize, ep, parm, name);
 	insert(temp, &runnable[priority]);
 	temp2 = lwp_cpptr;
-#if !defined(AFS_ARM_LINUX20_ENV) && !defined(AFS_ARM_DARWIN_ENV)
+#if !defined(AFS_ARM_LINUX_ENV) && !defined(AFS_ARM_DARWIN_ENV)
 	if (PRE_Block != 0)
 	    Abort_LWP("PRE_Block not 0");
 
@@ -521,12 +521,12 @@
 	    savecontext(Dispatcher, &(temp->context),
 			&(LWPANCHOR.
 			  dsptchstack[(sizeof LWPANCHOR.dsptchstack) - 8]));
-#elif defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV)
+#elif defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV)
 	    savecontext(Dispatcher, &(temp->context),
 			&(LWPANCHOR.
 			  dsptchstack[(sizeof LWPANCHOR.dsptchstack) -
 				      0x40]));
-#elif defined(AFS_S390_LINUX20_ENV)
+#elif defined(AFS_S390_LINUX_ENV)
 	    savecontext(Dispatcher, &(temp->context),
 			&(LWPANCHOR.
 			  dsptchstack[(sizeof LWPANCHOR.dsptchstack) -
@@ -956,7 +956,7 @@
 	printf("Dispatch %d [PCB at 0x%x] \"%s\"\n", ++dispatch_count,
 	       runnable[i].head, runnable[i].head->name);
 #endif
-#if !defined(AFS_ARM_LINUX20_ENV) && !defined(AFS_ARM_DARWIN_ENV)
+#if !defined(AFS_ARM_LINUX_ENV) && !defined(AFS_ARM_DARWIN_ENV)
     if (PRE_Block != 1)
 	Abort_LWP("PRE_Block not 1");
 #endif
diff --git a/src/lwp/lwp.h b/src/lwp/lwp.h
index 3b58c59..3f57dd6 100644
--- a/src/lwp/lwp.h
+++ b/src/lwp/lwp.h
@@ -26,7 +26,7 @@
 #ifndef _MFC_VER		/*skip if doing Microsoft foundation class */
 #include <winsock2.h>
 #endif
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 #include <unistd.h>
 #include <time.h>
 #include <sys/time.h>
@@ -212,7 +212,7 @@
  */
 #if defined(USE_UCONTEXT) && defined(HAVE_UCONTEXT_H)
 #define AFS_LWP_MINSTACKSIZE  (288 * 1024)
-#elif defined(AFS_LINUX22_ENV)
+#elif defined(AFS_LINUX_ENV)
 #define AFS_LWP_MINSTACKSIZE	(192 * 1024)
 #else
 #define AFS_LWP_MINSTACKSIZE	(48 * 1024)
@@ -273,7 +273,7 @@
 			     struct lwp_context *savearea, char *sp);
 extern void returnto(struct lwp_context *savearea);
 
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
 /* max time we are allowed to spend in a select call on Linux to avoid
  lost signal issues */
 #define IOMGR_MAXWAITTIME        60	/* seconds */
diff --git a/src/lwp/process.c b/src/lwp/process.c
index c2ba28c..7130c3e 100644
--- a/src/lwp/process.c
+++ b/src/lwp/process.c
@@ -18,7 +18,7 @@
 
 #include "lwp.h"
 
-#if defined(AFS_S390_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV)
 extern int PRE_Block;		/* used in lwp.c and process.s */
 #else
 extern char PRE_Block;		/* used in lwp.c and process.s */
@@ -26,7 +26,7 @@
 
 #if defined(USE_UCONTEXT) && defined(HAVE_UCONTEXT_H)
 
-# if defined(AFS_LINUX20_ENV) || defined(AFS_XBSD_ENV)
+# if defined(AFS_LINUX_ENV) || defined(AFS_XBSD_ENV)
 #  define AFS_UCONTEXT_NOSTACK
 # endif
 
@@ -90,21 +90,21 @@
 # endif
 #elif	defined(AFS_HPUX_ENV)
 #define	LWP_SP	1
-#elif	defined(AFS_LINUX20_ENV)
-#if defined(AFS_PPC_LINUX20_ENV) || defined(AFS_PPC64_LINUX20_ENV)
+#elif	defined(AFS_LINUX_ENV)
+#if defined(AFS_PPC_LINUX_ENV) || defined(AFS_PPC64_LINUX_ENV)
 #define LWP_SP 0
-#elif   defined(AFS_I386_LINUX20_ENV)
+#elif   defined(AFS_I386_LINUX_ENV)
 #define LWP_SP 4
-#elif   defined(AFS_S390_LINUX20_ENV)
+#elif   defined(AFS_S390_LINUX_ENV)
 #define LWP_SP 9
 #define LWP_FP 5
-#elif   defined(AFS_SPARC_LINUX20_ENV)
+#elif   defined(AFS_SPARC_LINUX_ENV)
 #define LWP_SP 0
 #define LWP_FP 1
-#elif   defined(AFS_SPARC64_LINUX20_ENV) && defined(AFS_32BIT_USR_ENV)
+#elif   defined(AFS_SPARC64_LINUX_ENV) && defined(AFS_32BIT_USR_ENV)
 #define LWP_SP 0
 #define LWP_FP 1
-#elif defined(AFS_ALPHA_LINUX20_ENV)
+#elif defined(AFS_ALPHA_LINUX_ENV)
 #define LWP_SP 8
 #define LWP_FP 7
 #else
@@ -127,11 +127,11 @@
 typedef __uint64_t jmp_buf_type;
 #endif
 #else
-#if defined(AFS_ALPHA_LINUX20_ENV) || defined(AFS_PPC64_LINUX20_ENV)
+#if defined(AFS_ALPHA_LINUX_ENV) || defined(AFS_PPC64_LINUX_ENV)
 typedef long jmp_buf_type;
 #else
 typedef int jmp_buf_type;
-#endif /*AFS_ALPHA_LINUX20_ENV */
+#endif /*AFS_ALPHA_LINUX_ENV */
 #endif /*SGI*/
 
     static jmp_buf jmp_tmp;
@@ -143,12 +143,12 @@
   * On Sparc ucontext functions are not implemented.
   */
 #define ptr_mangle(x) (x)
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 
 #ifdef __GLIBC__
 #if (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 3)
 
-#if defined(AFS_SPARC64_LINUX24_ENV) || defined(AFS_SPARC_LINUX24_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV)
 /* technically we should use POINTER_GUARD
  * ( == offsetof (tcbhead_t, pointer_guard) )
  * instead of 0x18
@@ -202,7 +202,7 @@
 	    case 0:
 		jmpBuffer = (jmp_buf_type *) jmp_tmp;
 		jmpBuffer[LWP_SP] = ptr_mangle((jmp_buf_type) sp);
-#if defined(AFS_S390_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV) || (defined(AFS_SPARC64_LINUX20_ENV) && defined(AFS_32BIT_USR_ENV))
+#if defined(AFS_S390_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV) || (defined(AFS_SPARC64_LINUX_ENV) && defined(AFS_32BIT_USR_ENV))
 		jmpBuffer[LWP_FP] = ptr_mangle((jmp_buf_type) sp);
 #endif
 		longjmp(jmp_tmp, 1);
diff --git a/src/lwp/waitkey.c b/src/lwp/waitkey.c
index 11ef20b..aa77555 100644
--- a/src/lwp/waitkey.c
+++ b/src/lwp/waitkey.c
@@ -164,7 +164,7 @@
 #if defined(HAVE_STDIO_EXT_H)
     if (__fbufsize(stdin) > 0)
         return 1;
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
     if (stdin->_IO_read_ptr < stdin->_IO_read_end)
 	return 1;
 #elif (defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)) && defined(AFS_DFBSD_ENV)
diff --git a/src/pam/afs_auth.c b/src/pam/afs_auth.c
index d41d2f0..e5992ad 100644
--- a/src/pam/afs_auth.c
+++ b/src/pam/afs_auth.c
@@ -66,7 +66,7 @@
     pid_t cpid, rcpid;
     int status;
     struct sigaction newAction, origAction;
-#if !(defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
+#if !(defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
     char upwd_buf[2048];       /* size is a guess. */
     struct passwd unix_pwd;
 #endif
@@ -187,7 +187,7 @@
 	RET(PAM_AUTH_ERR);
     }
 #else
-#if     defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
+#if     defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
     upwd = getpwnam(user);
 #else
     upwd = getpwnam_r(user, &unix_pwd, upwd_buf, sizeof(upwd_buf));
diff --git a/src/pam/afs_password.c b/src/pam/afs_password.c
index 547e723..e2c072c 100644
--- a/src/pam/afs_password.c
+++ b/src/pam/afs_password.c
@@ -53,7 +53,7 @@
     struct ubik_client *conn = 0;
     PAM_CONST struct pam_conv *pam_convp = NULL;
     struct passwd *upwd = NULL;
-#if !(defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
+#if !(defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
     char upwd_buf[2048];	/* size is a guess. */
     struct passwd unix_pwd;
 #endif
@@ -130,7 +130,7 @@
 	RET(PAM_AUTH_ERR);
     }
 #else
-#if     defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
+#if     defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
     upwd = getpwnam(user);
 #else
     upwd = getpwnam_r(user, &unix_pwd, upwd_buf, sizeof(upwd_buf));
diff --git a/src/pam/afs_session.c b/src/pam/afs_session.c
index e4a3620..9b460a0 100644
--- a/src/pam/afs_session.c
+++ b/src/pam/afs_session.c
@@ -81,7 +81,7 @@
 	case -1:		/* error */
 	    return (PAM_SESSION_ERR);
 	case 0:		/* child */
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 	    setpgrp();
 #endif
 	    setsid();
diff --git a/src/pam/afs_setcred.c b/src/pam/afs_setcred.c
index 0bfbb85..f6c4fc4 100644
--- a/src/pam/afs_setcred.c
+++ b/src/pam/afs_setcred.c
@@ -57,7 +57,7 @@
     int password_expires = -1;
     char *reason = NULL;
     struct passwd *upwd = NULL;
-#if !(defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
+#if !(defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
     char upwd_buf[2048];       /* size is a guess. */
     struct passwd unix_pwd;
 #endif
@@ -165,7 +165,7 @@
 	RET(PAM_AUTH_ERR);
     }
 #else
-#if     defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
+#if     defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
     upwd = getpwnam(user);
 #else
     upwd = getpwnam_r(user, &unix_pwd, upwd_buf, sizeof(upwd_buf));
diff --git a/src/pam/test_pam.c b/src/pam/test_pam.c
index 1133c25..f557ae8 100644
--- a/src/pam/test_pam.c
+++ b/src/pam/test_pam.c
@@ -28,7 +28,7 @@
 static const char *new_envstring = "GOTHEREVIATESTPAM=1";
 static const char *new_homestring = "HOME=/tmp";
 
-#if defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV) || defined(AFS_DARWIN_ENV)
+#if defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV) || defined(AFS_DARWIN_ENV)
 #define getpassphrase getpass
 #endif
 
diff --git a/src/platform/IRIX/rcmd.c b/src/platform/IRIX/rcmd.c
index 37ad40f..5bc93f6 100644
--- a/src/platform/IRIX/rcmd.c
+++ b/src/platform/IRIX/rcmd.c
@@ -87,7 +87,7 @@
 #endif
      char **ahost;
      u_short rport;
-#if defined(AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
+#if defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
      const char *locuser, *remuser, *cmd;
 #else
      char *locuser, *remuser, *cmd;
@@ -336,7 +336,7 @@
 
 int _check_rhosts_file = 1;
 
-#if defined(AFS_HPUX102_ENV) || defined(AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
+#if defined(AFS_HPUX102_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
 ruserok(rhost, superuser, ruser, luser)
      const char *rhost;
      int superuser;
diff --git a/src/rx/UKERNEL/rx_knet.c b/src/rx/UKERNEL/rx_knet.c
index 7e14cf3..07046c1 100644
--- a/src/rx/UKERNEL/rx_knet.c
+++ b/src/rx/UKERNEL/rx_knet.c
@@ -227,7 +227,7 @@
     len = sizeof(struct sockaddr_in);
     rc = getsockname(sock, (struct sockaddr *)&lcladdr, &len);
     usr_assert(rc >= 0);
-#ifdef AFS_USR_LINUX22_ENV
+#ifdef AFS_USR_LINUX_ENV
     optval0 = 131070;
 #else
     optval0 = 131072;
@@ -240,7 +240,7 @@
     rc = getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (void *)&optval, &optlen);
     usr_assert(rc == 0);
     /* usr_assert(optval == optval0); */
-#ifdef AFS_USR_LINUX22_ENV
+#ifdef AFS_USR_LINUX_ENV
     optval0 = 131070;
 #else
     optval0 = 131072;
diff --git a/src/rx/rx.c b/src/rx/rx.c
index a5a26bd..bb3b445 100644
--- a/src/rx/rx.c
+++ b/src/rx/rx.c
@@ -19,7 +19,7 @@
 #  include "h/types.h"
 #  include "h/time.h"
 #  include "h/stat.h"
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
 #   include "h/socket.h"
 #  endif
 #  include "netinet/in.h"
diff --git a/src/rx/rx_atomic.h b/src/rx/rx_atomic.h
index 72ee054..2979041 100644
--- a/src/rx/rx_atomic.h
+++ b/src/rx/rx_atomic.h
@@ -206,7 +206,7 @@
 rx_atomic_sub(rx_atomic_t *atomic, int change) {
     OSAtomicAdd32(0 - change, &atomic->var);
 }
-#elif defined(AFS_LINUX26_ENV) && defined(KERNEL)
+#elif defined(AFS_LINUX_ENV) && defined(KERNEL)
 #include <asm/atomic.h>
 
 typedef atomic_t rx_atomic_t;
diff --git a/src/rx/rx_internal.h b/src/rx/rx_internal.h
index 274d981..2eafc91 100644
--- a/src/rx/rx_internal.h
+++ b/src/rx/rx_internal.h
@@ -6,7 +6,7 @@
  */
 
 #ifdef AFS_RXERRQ_ENV
-# if defined(AFS_LINUX26_ENV) || defined(AFS_USR_LINUX26_ENV)
+# if defined(AFS_LINUX_ENV) || defined(AFS_USR_LINUX_ENV)
 #  include <linux/types.h>
 #  include <linux/errqueue.h>
 #  include <linux/icmp.h>
diff --git a/src/rx/rx_kcommon.c b/src/rx/rx_kcommon.c
index 0b2000d..688c81d 100644
--- a/src/rx/rx_kcommon.c
+++ b/src/rx/rx_kcommon.c
@@ -197,7 +197,7 @@
     return 0;
 }
 
-#ifndef AFS_LINUX26_ENV
+#ifndef AFS_LINUX_ENV
 /*
  * osi_AssertFailK() -- used by the osi_Assert() macro.
  *
@@ -250,7 +250,7 @@
 
     osi_Panic("%s", buf);
 }
-#endif /* !AFS_LINUX26_ENV */
+#endif /* !AFS_LINUX_ENV */
 
 #ifndef UKERNEL
 /* This is the server process request loop. Kernel server
@@ -464,7 +464,7 @@
  */
 
 
-#if ! defined(AFS_AIX_ENV) && ! defined(AFS_SUN5_ENV) && ! defined(UKERNEL) && ! defined(AFS_LINUX20_ENV) && !defined (AFS_DARWIN_ENV) && !defined (AFS_XBSD_ENV)
+#if ! defined(AFS_AIX_ENV) && ! defined(AFS_SUN5_ENV) && ! defined(UKERNEL) && ! defined(AFS_LINUX_ENV) && !defined (AFS_DARWIN_ENV) && !defined (AFS_XBSD_ENV)
 /* Routine called during the afsd "-shutdown" process to put things back to
  * the initial state.
  */
@@ -824,7 +824,7 @@
  * most of it is simple to follow common code.
  */
 #if !defined(UKERNEL)
-# if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_SOCKPROXY_ENV)
+# if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_SOCKPROXY_ENV)
 /* rxk_NewSocket creates a new socket on the specified port. The port is
  * in network byte order.
  */
@@ -1044,7 +1044,7 @@
 #  endif
     return 0;
 }
-# endif /* !SUN5 && !LINUX20 && !AFS_SOCKPROXY_ENV */
+# endif /* !AFS_SUN5_ENV && !AFS_LINUX_ENV && !AFS_SOCKPROXY_ENV */
 
 # if defined(RXK_LISTENER_ENV) || defined(AFS_SUN5_ENV) || defined(RXK_UPCALL_ENV)
 #  ifdef RXK_TIMEDSLEEP_ENV
@@ -1218,7 +1218,7 @@
  * OS's socket receive routine returns as a result of a signal.
  */
 int rxk_ListenerPid;		/* Used to signal process to wakeup at shutdown */
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
 struct task_struct *rxk_ListenerTask;
 #  endif
 
@@ -1229,7 +1229,7 @@
     int code;
     int host, port;
 
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
     rxk_ListenerPid = current->pid;
     rxk_ListenerTask = current;
     allow_signal(SIGKILL);    /* Allowed, but blocked until shutdown */
@@ -1276,7 +1276,7 @@
 	osi_rxWakeup(&afs_termState);
     }
     rxk_ListenerPid = 0;
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
     rxk_ListenerTask = 0;
     osi_rxWakeup(&rxk_ListenerTask);
 #  endif
@@ -1285,7 +1285,7 @@
 #  endif
 }
 
-#  if !defined(AFS_LINUX20_ENV) && !defined(AFS_SUN5_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
+#  if !defined(AFS_LINUX_ENV) && !defined(AFS_SUN5_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
 /* The manner of stopping the rx listener thread may vary. Most unix's should
  * be able to call soclose.
  */
@@ -1303,7 +1303,7 @@
 {
     va_list ap;
     va_start(ap, fmt);
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
     vprintk(fmt, ap);
 #else
     vprintf(fmt, ap);
@@ -1311,7 +1311,7 @@
     va_end(ap);
 }
 
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 void
 # if defined(AFS_AIX_ENV)
 osi_Panic(char *msg, void *a1, void *a2, void *a3)
@@ -1340,7 +1340,7 @@
 	icmn_err(CE_PANIC, msg, ap);
 	va_end(ap);
     }
-# elif defined(AFS_DARWIN80_ENV) || defined(AFS_LINUX22_ENV) || defined(AFS_FBSD_ENV) || defined(UKERNEL)
+# elif defined(AFS_DARWIN80_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(UKERNEL)
     char buf[256];
     va_list ap;
     if (!msg)
@@ -1351,7 +1351,7 @@
     va_end(ap);
     printf("%s", buf);
     panic("%s", buf);
-# else /* DARWIN80 || LINUX22 || FBSD || UKERNEL */
+# else /* DARWIN80 || LINUX || FBSD || UKERNEL */
     va_list ap;
     if (!msg)
 	msg = "Unknown AFS panic";
@@ -1359,12 +1359,12 @@
     va_start(ap, msg);
     vprintf(msg, ap);
     va_end(ap);
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
     * ((char *) 0) = 0;
 #  else
     panic("%s", msg);
 #  endif
-# endif /* else DARWIN80 || LINUX22 || FBSD || UKERNEL */
+# endif /* else DARWIN80 || LINUX || FBSD || UKERNEL */
 }
 
-#endif /* !AFS_LINUX26_ENV */
+#endif /* !AFS_LINUX_ENV */
diff --git a/src/rx/rx_kcommon.h b/src/rx/rx_kcommon.h
index d4d423a..9f0d89d 100644
--- a/src/rx/rx_kcommon.h
+++ b/src/rx/rx_kcommon.h
@@ -18,7 +18,7 @@
 #ifndef _RX_KCOMMON_H_
 #define _RX_KCOMMON_H_
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #ifndef _LINUX_CODA_FS_I
 #define _LINUX_CODA_FS_I 1
 #define _CODA_HEADER_ 1
@@ -29,10 +29,10 @@
 
 
 #include "h/types.h"
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include "h/param.h"
 #endif
-#ifndef AFS_LINUX22_ENV
+#ifndef AFS_LINUX_ENV
 #include "h/systm.h"
 #endif
 #include "h/time.h"
@@ -43,7 +43,7 @@
 #include "h/disp.h"
 #endif
 #include "h/socket.h"
-#if !defined(AFS_LINUX22_ENV) && !defined(AFS_OBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_OBSD_ENV)
 #include "h/socketvar.h"
 #if !defined(AFS_SUN5_ENV) && !defined(AFS_XBSD_ENV)
 #include "h/domain.h"
@@ -68,7 +68,7 @@
 #include "h/mbuf.h"
 #endif
 #endif /* !defined(AFS_SUN5_ENV) && !defined(AFS_XBSD_ENV) */
-#endif /* !defined(AFS_LINUX22_ENV) && !defined(AFS_OBSD_ENV) */
+#endif /* !defined(AFS_LINUX_ENV) && !defined(AFS_OBSD_ENV) */
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
@@ -83,32 +83,32 @@
 #include "h/signalvar.h"
 #endif /* AFS_OBSD_ENV */
 #include "netinet/in.h"
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #include "linux/route.h"
 #else
 #include "net/route.h"
 #endif
-#if defined(HAVE_IN_SYSTM_H) || !defined(AFS_LINUX22_ENV)
+#if defined(HAVE_IN_SYSTM_H) || !defined(AFS_LINUX_ENV)
 #include "netinet/in_systm.h"
 #endif
 #include "netinet/ip.h"
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX22_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_OBSD_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_OBSD_ENV)
 #include "netinet/in_pcb.h"
-#endif /* ! AFS_HPUX110_ENV && ! AFS_LINUX22_ENV */
-#ifndef AFS_LINUX22_ENV
+#endif /* ! AFS_HPUX110_ENV && ! AFS_LINUX_ENV */
+#ifndef AFS_LINUX_ENV
 #if !defined(AFS_DARWIN_ENV)
 #include "netinet/ip_var.h"
 #endif
 #include "netinet/ip_icmp.h"
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 #include "netinet/udp.h"
-#if !defined(AFS_SGI62_ENV) && !defined(AFS_LINUX22_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_SGI62_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include "netinet/udp_var.h"
 #endif
 #if defined(AFS_HPUX102_ENV) || (defined(AFS_SGI62_ENV) && !defined(AFS_SGI64_ENV))
 #include "h/user.h"
 #endif
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/sched.h"
 #include "h/netdevice.h"
 #include "linux/if.h"
@@ -124,9 +124,9 @@
 #  include <net/if_var.h>
 # endif
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX22_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include "netinet/in_var.h"
-#endif /* ! AFS_HPUX110_ENV && ! AFS_LINUX22_ENV */
+#endif /* ! AFS_HPUX110_ENV && ! AFS_LINUX_ENV */
 #include "afs/afs_osi.h"
 #include "rx_kmutex.h"
 #include "afs/lock.h"
diff --git a/src/rx/rx_kernel.h b/src/rx/rx_kernel.h
index 6f10ba4..6b96ff3 100644
--- a/src/rx/rx_kernel.h
+++ b/src/rx/rx_kernel.h
@@ -37,7 +37,7 @@
 
 extern int osi_utoa(char *buf, size_t len, unsigned long val);
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
 # define osi_Panic(msg...) \
     do { printk(KERN_CRIT "openafs: " msg); BUG(); } while (0)
 # define osi_Assert(expr) \
diff --git a/src/rx/rx_lwp.c b/src/rx/rx_lwp.c
index bc6ae66..96965db 100644
--- a/src/rx/rx_lwp.c
+++ b/src/rx/rx_lwp.c
@@ -451,7 +451,7 @@
 	}
 #ifdef AFS_NT40_ENV
 	if (err)
-#elif defined(AFS_LINUX22_ENV)
+#elif defined(AFS_LINUX_ENV)
 	/* linux unfortunately returns ECONNREFUSED if the target port
 	 * is no longer in use */
 	/* and EAGAIN if a UDP checksum is incorrect */
diff --git a/src/rx/rx_packet.c b/src/rx/rx_packet.c
index 61a5351..2cefeee 100644
--- a/src/rx/rx_packet.c
+++ b/src/rx/rx_packet.c
@@ -20,7 +20,7 @@
 #   include "rx_kcommon.h"
 #  endif
 #  include "h/types.h"
-#  ifndef AFS_LINUX20_ENV
+#  ifndef AFS_LINUX_ENV
 #   include "h/systm.h"
 #  endif
 #  if defined(AFS_SGI_ENV) || defined(AFS_HPUX110_ENV) || defined(AFS_NBSD50_ENV)
@@ -30,7 +30,7 @@
 #   include "h/proc.h"
 #  endif
 #  include "h/socket.h"
-#  if !defined(AFS_SUN5_ENV) &&  !defined(AFS_LINUX20_ENV) && !defined(AFS_HPUX110_ENV)
+#  if !defined(AFS_SUN5_ENV) &&  !defined(AFS_LINUX_ENV) && !defined(AFS_HPUX110_ENV)
 #   if	!defined(AFS_AIX41_ENV)
 #    include "sys/mount.h"		/* it gets pulled in by something later anyway */
 #   endif
@@ -1691,7 +1691,7 @@
 #define m_cpytoc(a, b, c, d)  cpytoc(a, b, c, d)
 #define m_cpytoiovec(a, b, c, d, e) cpytoiovec(a, b, c, d, e)
 #else
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN80_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN80_ENV)
 static int
 m_cpytoiovec(struct mbuf *m, int off, int len, struct iovec iovs[], int niovs)
 {
@@ -1744,10 +1744,10 @@
 
     return len;
 }
-#endif /* LINUX */
+#endif /* !AFS_LINUX_ENV && !AFS_DARWIN80_ENV */
 #endif /* AFS_SUN5_ENV */
 
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN80_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN80_ENV)
 #if defined(AFS_NBSD_ENV)
 int
 rx_mb_to_packet(struct mbuf *amb, void (*free) (struct mbuf *), int hdr_len, int data_len, struct rx_packet *phandle)
@@ -2192,7 +2192,7 @@
     if (code == -WSAEHOSTUNREACH) {
 	down = 1;
     }
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
     if (code == -ENETUNREACH) {
 	down = 1;
     }
diff --git a/src/rx/rx_packet.h b/src/rx/rx_packet.h
index 94269df..46c0789 100644
--- a/src/rx/rx_packet.h
+++ b/src/rx/rx_packet.h
@@ -42,12 +42,12 @@
 #else /* AFS_NT40_ENV */
 # if !defined(AFS_DARWIN_ENV) && !defined(AFS_USR_DARWIN_ENV)   \
     && !defined(AFS_XBSD_ENV) && !defined(AFS_USR_FBSD_ENV)     \
-    && !defined(AFS_USR_DFBSD_ENV) && !defined(AFS_LINUX20_ENV)
+    && !defined(AFS_USR_DFBSD_ENV) && !defined(AFS_LINUX_ENV)
 #  include <sys/sysmacros.h>	/* MIN, MAX on most commercial UNIX */
 # endif
 /* Linux 3.7 doesn't have sys/param.h in kernel space, and afs/param.h ensures
  * that MIN and MAX are available for kernel builds. */
-# if !(defined(AFS_LINUX26_ENV) && defined(KERNEL))
+# if !(defined(AFS_LINUX_ENV) && defined(KERNEL))
 #  include <sys/param.h>	/* MIN, MAX elsewhere */
 # endif
 #endif /* !AFS_NT40_ENV */
diff --git a/src/rx/rx_prototypes.h b/src/rx/rx_prototypes.h
index 7eb8e04..190bb58 100644
--- a/src/rx/rx_prototypes.h
+++ b/src/rx/rx_prototypes.h
@@ -271,7 +271,7 @@
 # ifdef UKERNEL
 extern void *rx_ServerProc(void *);
 # endif
-# ifndef AFS_LINUX26_ENV
+# ifndef AFS_LINUX_ENV
 extern void osi_AssertFailK(const char *expr, const char *file, int line) AFS_NORETURN;
 # endif
 extern void rxk_ListenerProc(void);
@@ -283,7 +283,7 @@
 extern void osi_StopListener(void);
 
 /* ARCH/rx_kmutex.c */
-# if defined(AFS_LINUX20_ENV)
+# if defined(AFS_LINUX_ENV)
 extern void afs_mutex_init(afs_kmutex_t * l);
 extern void afs_mutex_enter(afs_kmutex_t * l);
 extern int afs_mutex_tryenter(afs_kmutex_t * l);
diff --git a/src/rx/rx_pthread.c b/src/rx/rx_pthread.c
index 57f1edb..64240b5 100644
--- a/src/rx/rx_pthread.c
+++ b/src/rx/rx_pthread.c
@@ -418,7 +418,7 @@
 #endif
 
 #ifndef AFS_RXERRQ_ENV
-# ifdef AFS_LINUX22_ENV
+# ifdef AFS_LINUX_ENV
     /* linux unfortunately returns ECONNREFUSED if the target port
      * is no longer in use */
     /* and EAGAIN if a UDP checksum is incorrect */
diff --git a/src/rx/rx_rdwr.c b/src/rx/rx_rdwr.c
index e2721d3..ee1c3e3 100644
--- a/src/rx/rx_rdwr.c
+++ b/src/rx/rx_rdwr.c
@@ -24,7 +24,7 @@
 #   if defined(AFS_AIX_ENV) || defined(AFS_AUX_ENV) || defined(AFS_SUN5_ENV)
 #    include "h/systm.h"
 #   endif
-#   ifdef AFS_LINUX20_ENV
+#   ifdef AFS_LINUX_ENV
 #    include "h/socket.h"
 #   endif
 #   include "netinet/in.h"
diff --git a/src/rx/rx_user.c b/src/rx/rx_user.c
index 04e1542..1569526 100644
--- a/src/rx/rx_user.c
+++ b/src/rx/rx_user.c
@@ -36,7 +36,7 @@
 #define IPPORT_USERRESERVED 5000
 # endif
 
-#if defined(AFS_LINUX22_ENV) && defined(AFS_RXERRQ_ENV)
+#if defined(AFS_LINUX_ENV) && defined(AFS_RXERRQ_ENV)
 # include <linux/types.h>
 # include <linux/errqueue.h>
 # if defined(AFS_ADAPT_PMTU) && !defined(IP_MTU)
@@ -94,7 +94,7 @@
     osi_socket socketFd = OSI_NULLSOCKET;
     struct sockaddr_in taddr;
     char *name = "rxi_GetUDPSocket: ";
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 # if defined(AFS_ADAPT_PMTU)
     int pmtu = IP_PMTUDISC_WANT;
 # else
@@ -197,7 +197,7 @@
             rx_atomic_set(&rx_stats.socketGreedy, greedy);
     }
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     setsockopt(socketFd, SOL_IP, IP_MTU_DISCOVER, &pmtu, sizeof(pmtu));
 #endif
 #ifdef AFS_RXERRQ_ENV
@@ -445,7 +445,7 @@
 
 
 
-#if !defined(AFS_AIX_ENV) && !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN160_ENV)
+#if !defined(AFS_AIX_ENV) && !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN160_ENV)
 int
 rxi_syscall(afs_uint32 a3, afs_uint32 a4, void *a5)
 {
@@ -574,7 +574,7 @@
 	}
 #endif /* SIOCGIFFLAGS */
 
-#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN160_ENV)
+#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN160_ENV)
 	/* this won't run on an AIX system w/o a cache manager */
 	rxi_syscallp = rxi_syscall;
 #endif
diff --git a/src/rx/test/testclient.c b/src/rx/test/testclient.c
index accd085..0ed74c6 100644
--- a/src/rx/test/testclient.c
+++ b/src/rx/test/testclient.c
@@ -57,7 +57,7 @@
 	rx_PrintStats(debugFile);
 }
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV)
 int
 test_syscall(afs_uint32 a3, afs_uint32 a4, void *a5)
 {
@@ -91,7 +91,7 @@
     int setFD = 0;
     int jumbo = 0;
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV)
     setlinebuf(stdout);
     rxi_syscallp = test_syscall;
 #endif
diff --git a/src/rx/test/testserver.c b/src/rx/test/testserver.c
index a84d206..deead44 100644
--- a/src/rx/test/testserver.c
+++ b/src/rx/test/testserver.c
@@ -53,7 +53,7 @@
 	rx_PrintStats(debugFile);
 }
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV)
 int
 test_syscall(a3, a4, a5)
      afs_uint32 a3, a4;
@@ -80,7 +80,7 @@
     int setFD = 0;
     int jumbo = 0;
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV)
     setlinebuf(stdout);
     rxi_syscallp = test_syscall;
 #endif
diff --git a/src/rx/xdr.c b/src/rx/xdr.c
index 7d23917..7ef772d 100644
--- a/src/rx/xdr.c
+++ b/src/rx/xdr.c
@@ -48,10 +48,10 @@
 #ifndef	NeXT
 
 #if defined(KERNEL) && !defined(UKERNEL)
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <sys/param.h>
 #endif
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
 #include <sys/systm.h>
 #endif
 #endif
@@ -591,7 +591,7 @@
     x.x_op = XDR_FREE;
 
     /* See note in xdr.h for the method behind this madness */
-#if defined(AFS_I386_LINUX26_ENV) && defined(KERNEL) && !defined(UKERNEL)
+#if defined(AFS_I386_LINUX_ENV) && defined(KERNEL) && !defined(UKERNEL)
     (*proc)(&x, obj, 0);
 #else
     (*proc)(&x, obj);
diff --git a/src/rx/xdr.h b/src/rx/xdr.h
index 61df7a1..2567372 100644
--- a/src/rx/xdr.h
+++ b/src/rx/xdr.h
@@ -185,7 +185,7 @@
  * normal va_args prototype results in the arguments being placed on the
  * stack, where they aren't accessible to the 'real' function.
  */
-#if defined(AFS_I386_LINUX26_ENV) && defined(KERNEL) && !defined(UKERNEL)
+#if defined(AFS_I386_LINUX_ENV) && defined(KERNEL) && !defined(UKERNEL)
 typedef bool_t(*xdrproc_t) (void *, caddr_t, u_int);
 #else
 typedef bool_t(*xdrproc_t) (void *, ...);
diff --git a/src/rx/xdr_afsuuid.c b/src/rx/xdr_afsuuid.c
index da7855a..dadfcf6 100644
--- a/src/rx/xdr_afsuuid.c
+++ b/src/rx/xdr_afsuuid.c
@@ -15,7 +15,7 @@
 #include <afs/param.h>
 
 #if defined(KERNEL) && !defined(UKERNEL)
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/string.h"
 #else
 #include <sys/param.h>
diff --git a/src/rx/xdr_array.c b/src/rx/xdr_array.c
index 75bcd7c..1785019 100644
--- a/src/rx/xdr_array.c
+++ b/src/rx/xdr_array.c
@@ -47,16 +47,16 @@
  */
 
 #if defined(KERNEL) && !defined(UKERNEL)
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <sys/param.h>
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/string.h"
 #else
 #ifndef AFS_DARWIN90_ENV
 #include <sys/systm.h>
 #endif
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 #endif
 #include "xdr.h"
 
diff --git a/src/rx/xdr_arrayn.c b/src/rx/xdr_arrayn.c
index 2a2e081..d6cb1f7 100644
--- a/src/rx/xdr_arrayn.c
+++ b/src/rx/xdr_arrayn.c
@@ -47,10 +47,10 @@
  */
 
 #if defined(KERNEL) && !defined(UKERNEL)
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <sys/param.h>
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/string.h"
 #else
 #include <sys/systm.h>
diff --git a/src/rx/xdr_int32.c b/src/rx/xdr_int32.c
index 63bf09a..cc87a81 100644
--- a/src/rx/xdr_int32.c
+++ b/src/rx/xdr_int32.c
@@ -34,7 +34,7 @@
 #ifndef	NeXT
 
 #if defined(KERNEL) && !defined(UKERNEL)
-# if !defined(AFS_LINUX26_ENV)
+# if !defined(AFS_LINUX_ENV)
 #  include <sys/param.h>
 # endif
 #else
diff --git a/src/rx/xdr_int64.c b/src/rx/xdr_int64.c
index c1925ed..d2b1e6b 100644
--- a/src/rx/xdr_int64.c
+++ b/src/rx/xdr_int64.c
@@ -8,7 +8,7 @@
 
 
 #if defined(KERNEL) && !defined(UKERNEL)
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/string.h"
 #else
 #include <sys/param.h>
diff --git a/src/rx/xdr_rx.c b/src/rx/xdr_rx.c
index 9a7aba9..ade4de4 100644
--- a/src/rx/xdr_rx.c
+++ b/src/rx/xdr_rx.c
@@ -19,10 +19,10 @@
 # ifndef UKERNEL
 #  include "h/types.h"
 #  include "h/uio.h"
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
 #   include "h/socket.h"
 #  endif
-#  ifdef AFS_LINUX22_ENV
+#  ifdef AFS_LINUX_ENV
 #   ifndef quad_t
 #    define quad_t __quad_t
 #    define u_quad_t __u_quad_t
diff --git a/src/rxgen/rpc_main.c b/src/rxgen/rpc_main.c
index 10aee6c..ecd2f4f 100644
--- a/src/rxgen/rpc_main.c
+++ b/src/rxgen/rpc_main.c
@@ -455,7 +455,7 @@
     f_print(fout, "#include \"h/socket.h\"\n");
     f_print(fout, "#endif\n");
     f_print(fout, "#ifndef	DTYPE_SOCKET  /* XXXXX */\n");
-    f_print(fout, "#ifndef AFS_LINUX22_ENV\n");
+    f_print(fout, "#ifndef AFS_LINUX_ENV\n");
     f_print(fout, "#include \"h/file.h\"\n");
     f_print(fout, "#endif\n");
     f_print(fout, "#endif\n");
@@ -472,7 +472,7 @@
     f_print(fout, "#include \"h/time.h\"\n");
     f_print(fout, "#endif\n");
     f_print(fout, "#ifndef	XDR_GETLONG /* XXXXX */\n");
-    f_print(fout, "#ifdef AFS_LINUX22_ENV\n");
+    f_print(fout, "#ifdef AFS_LINUX_ENV\n");
     f_print(fout, "#ifndef quad_t\n");
     f_print(fout, "#define quad_t __quad_t\n");
     f_print(fout, "#define u_quad_t __u_quad_t\n");
diff --git a/src/rxkad/bg-fcrypt.c b/src/rxkad/bg-fcrypt.c
index c88dbd0..28b6bfe 100644
--- a/src/rxkad/bg-fcrypt.c
+++ b/src/rxkad/bg-fcrypt.c
@@ -38,13 +38,13 @@
 #ifdef KERNEL
 #ifndef UKERNEL
 #include "h/types.h"
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_OBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_OBSD_ENV)
 #include "netinet/in.h"
 #endif
 #else /* UKERNEL */
 #include "afs/sysincludes.h"
 #endif /* UKERNEL */
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #include <asm/byteorder.h>
 #endif
 
diff --git a/src/rxkad/fcrypt.c b/src/rxkad/fcrypt.c
index 5488a0d..7108933 100644
--- a/src/rxkad/fcrypt.c
+++ b/src/rxkad/fcrypt.c
@@ -23,13 +23,13 @@
 #include "h/systm.h"
 #endif
 #include "h/types.h"
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_OBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_OBSD_ENV)
 #include "netinet/in.h"
 #endif
 #else /* UKERNEL */
 #include "afs/sysincludes.h"
 #endif /* UKERNEL */
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #include <asm/byteorder.h>
 #endif
 
diff --git a/src/rxkad/rxkad_client.c b/src/rxkad/rxkad_client.c
index 2f89425..6304883 100644
--- a/src/rxkad/rxkad_client.c
+++ b/src/rxkad/rxkad_client.c
@@ -22,7 +22,7 @@
 #if defined(AFS_AIX_ENV) || defined(AFS_AUX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_XBSD_ENV)
 #include "h/systm.h"
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/socket.h"
 #endif
 #ifndef AFS_OBSD_ENV
diff --git a/src/sys/afssyscalls.h b/src/sys/afssyscalls.h
index cd014d8..6a9391c 100644
--- a/src/sys/afssyscalls.h
+++ b/src/sys/afssyscalls.h
@@ -39,7 +39,7 @@
 #endif
 
 /* Glue layer. */
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 int proc_afs_syscall(long syscall, long param1, long param2, long param3,
 		     long param4, int *rval);
 #endif
diff --git a/src/sys/glue.c b/src/sys/glue.c
index 3562459..a143141 100644
--- a/src/sys/glue.c
+++ b/src/sys/glue.c
@@ -20,7 +20,7 @@
 
 #include "afssyscalls.h"
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 int proc_afs_syscall(long syscall, long param1, long param2, long param3,
 		     long param4, int *rval) {
   struct afsprocdata syscall_data;
diff --git a/src/sys/pioctl.c b/src/sys/pioctl.c
index f2f9138..c71b140 100644
--- a/src/sys/pioctl.c
+++ b/src/sys/pioctl.c
@@ -40,7 +40,7 @@
     return (syscall(AFS_PIOCTL, path, cmd, cmarg, follow));
 }
 
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 
 int
 lpioctl(char *path, int cmd, void *cmarg, int follow)
diff --git a/src/sys/setpag.c b/src/sys/setpag.c
index 48570bf..ef1f4ff 100644
--- a/src/sys/setpag.c
+++ b/src/sys/setpag.c
@@ -50,7 +50,7 @@
 {
     int errcode;
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     int rval;
 
     rval = proc_afs_syscall(AFSCALL_SETPAG,0,0,0,0,&errcode);
diff --git a/src/sys/sys_prototypes.h b/src/sys/sys_prototypes.h
index beb28f6..659cd83 100644
--- a/src/sys/sys_prototypes.h
+++ b/src/sys/sys_prototypes.h
@@ -11,7 +11,7 @@
 #define _SYS_PROTOTYPES_H
 
 /* glue.c */
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 extern int proc_afs_syscall(long, long, long, long, long, int *);
 #endif
 #ifdef AFS_DARWIN80_ENV
diff --git a/src/tools/dumpscan/dumptool.c b/src/tools/dumpscan/dumptool.c
index 61dc0e6..4ded93c 100644
--- a/src/tools/dumpscan/dumptool.c
+++ b/src/tools/dumpscan/dumptool.c
@@ -88,7 +88,7 @@
 #include <afs/vnode.h>
 #include <afs/volume.h>
 
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
 #define _LARGEFILE64_SOURCE 1
 #endif
 #ifdef RESIDENCY
diff --git a/src/uss/uss_common.h b/src/uss/uss_common.h
index ceda7c9..b0536ec 100644
--- a/src/uss/uss_common.h
+++ b/src/uss/uss_common.h
@@ -60,7 +60,7 @@
 #define uss_VolumeLen		300
 #define uss_DirPoolLen		300
 
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
 extern char *sys_errlist[];
 #endif
 
diff --git a/src/util/uuid.c b/src/util/uuid.c
index 010db30..57be4d5 100644
--- a/src/util/uuid.c
+++ b/src/util/uuid.c
@@ -52,7 +52,7 @@
 #  include <rpc.h>
 # else
 #  include <net/if.h>
-#  if !defined(AFS_LINUX20_ENV) && !defined(AFS_ARM_DARWIN_ENV)
+#  if !defined(AFS_LINUX_ENV) && !defined(AFS_ARM_DARWIN_ENV)
 #   include <netinet/if_ether.h>
 #  endif
 # endif
diff --git a/src/util/vice.h b/src/util/vice.h
index 5342be7..bd05d91 100644
--- a/src/util/vice.h
+++ b/src/util/vice.h
@@ -12,7 +12,7 @@
 
 #include <sys/types.h>
 #if !defined(AFS_NT40_ENV)
-# if (!defined(AFS_FBSD_ENV) && !defined(AFS_LINUX26_ENV)) || !defined(KERNEL) || defined(UKERNEL)
+# if (!defined(AFS_FBSD_ENV) && !defined(AFS_LINUX_ENV)) || !defined(KERNEL) || defined(UKERNEL)
 #  include <sys/ioctl.h>
 # endif
 #endif /* AFS_NT40_ENV */
diff --git a/src/venus/fstrace.c b/src/venus/fstrace.c
index 38c1cc0..57258ac 100644
--- a/src/venus/fstrace.c
+++ b/src/venus/fstrace.c
@@ -1089,10 +1089,10 @@
 	    long parm4, long parm5, long parm6)
 {
     int code;
-#if defined(AFS_DARWIN80_ENV) || defined(AFS_LINUX20_ENV)
+#if defined(AFS_DARWIN80_ENV) || defined(AFS_LINUX_ENV)
     int rval;
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #if defined AFS_LINUX_64BIT_KERNEL
     long long eparm[4];
     /* don't want to sign extend it to 64bit, so using ulong */
@@ -1127,7 +1127,7 @@
 #endif
 	}
     }
-#if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV)
     /* on sparc this function returns none value, so do it myself */
     __asm__ __volatile__("mov	%o0, %i0; ret; restore");
 #endif
@@ -1150,7 +1150,7 @@
 #endif
 #endif
 #endif
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
     return code;
 }
 #endif
diff --git a/src/venus/kdump.c b/src/venus/kdump.c
index f33f26a..baee73b 100644
--- a/src/venus/kdump.c
+++ b/src/venus/kdump.c
@@ -16,7 +16,7 @@
 
 #if !defined(AFS_DARWIN_ENV) && !defined(AFS_FBSD_ENV)
 /* Here be hacks. */
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
 #define __KERNEL__
 #include <linux/string.h>
 #define _STRING_H 1
@@ -25,7 +25,7 @@
 #undef USE_UCONTEXT
 #endif
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 /* For some reason, this doesn't get defined in linux/types.h
    if __KERNEL_STRICT_NAMES is defined. But the definition of
    struct inode uses it.
@@ -106,7 +106,7 @@
 #define _KERNEL 1
 #endif
 
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
 #include <nlist.h>
 #endif
 
@@ -142,7 +142,7 @@
 #include <sys/user.h>
 #endif
 
-#ifndef AFS_LINUX26_ENV
+#ifndef AFS_LINUX_ENV
 #include <sys/file.h>
 #endif
 
@@ -177,7 +177,7 @@
 #include <ufs/ffs/fs.h>
 #else
 #include "sys/vfs.h"
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #ifndef UIO_MAXIOV
 #define UIO_MAXIOV 1		/* don't care */
 #endif
@@ -192,30 +192,30 @@
 #undef LONG_MAX
 #undef ULONG_MAX
 #define _LINUX_TIME_H
-#ifndef AFS_LINUX26_ENV
+#ifndef AFS_LINUX_ENV
 #define _LINUX_FCNTL_H
 #endif
-#ifdef AFS_IA64_LINUX24_ENV
+#ifdef AFS_IA64_LINUX_ENV
 #define flock64  flock
-#endif /* AFS_IA64_LINUX24_ENV */
-#ifdef AFS_S390_LINUX20_ENV
+#endif /* AFS_IA64_LINUX_ENV */
+#ifdef AFS_S390_LINUX_ENV
 #define _S390_STATFS_H
 #else
-#ifdef AFS_SPARC64_LINUX20_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
 #define _SPARC64_STATFS_H
 #define _SPARC_STATFS_H
 #else
-#ifdef AFS_SPARC_LINUX20_ENV
+#ifdef AFS_SPARC_LINUX_ENV
 #define _SPARC_STATFS_H
 #else
-#ifdef AFS_ALPHA_LINUX20_ENV
+#ifdef AFS_ALPHA_LINUX_ENV
 #define _ALPHA_STATFS_H
 #else
 #define _I386_STATFS_H
-#endif /* AFS_ALPHA_LINUX20_ENV */
-#endif /* AFS_SPARC_LINUX20_ENV */
-#endif /* AFS_SPARC64_LINUX20_ENV */
-#endif /* AFS_S390_LINUX20_ENV */
+#endif /* AFS_ALPHA_LINUX_ENV */
+#endif /* AFS_SPARC_LINUX_ENV */
+#endif /* AFS_SPARC64_LINUX_ENV */
+#endif /* AFS_S390_LINUX_ENV */
 struct timezone {
     int a, b;
 };
@@ -229,7 +229,7 @@
 #define timer_t ktimer_t
 #define timer_t_redefined
 #endif
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 /* For some reason, this doesn't get defined in linux/types.h
    if __KERNEL_STRICT_NAMES is defined. But the definition of
    struct inode uses it.
@@ -238,7 +238,7 @@
 /* got it from linux/types.h */
 typedef unsigned long sector_t;
 #endif /* HAVE_SECTOR_T */
-#endif /* AFS_LINUX26_ENV */
+#endif /* AFS_LINUX_ENV */
 #include <linux/version.h>
 #include <linux/fs.h>
 #include <osi_vfs.h>
@@ -246,7 +246,7 @@
 #undef timer_t
 #undef timer_t_redefined
 #endif
-#else /* AFS_LINUX20_ENV */
+#else /* AFS_LINUX_ENV */
 #ifdef AFS_HPUX110_ENV
 #define  KERNEL
 #define  _KERNEL 1
@@ -267,7 +267,7 @@
 #else /* AFS_HPUX110_ENV */
 #include "sys/vnode.h"
 #endif /* else AFS_HPUX110_ENV */
-#endif /* else AFS_LINUX20_ENV */
+#endif /* else AFS_LINUX_ENV */
 #ifdef	AFS_HPUX_ENV
 #include "sys/inode.h"
 #else
@@ -275,7 +275,7 @@
 #ifdef	AFS_SUN5_ENV
 #include "sys/fs/ufs_inode.h"
 #else
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
 #include "ufs/inode.h"
 #endif
 #endif
@@ -338,7 +338,7 @@
 } afs_kcondvar_t;
 #endif /* AFS_SGI65_ENV */
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include <asm/atomic.h>
 #include <asm/semaphore.h>
 #define RX_ENABLE_LOCKS 1
@@ -347,7 +347,7 @@
     int opaque2;
 } afs_kmutex_t;
 typedef void *afs_kcondvar_t;
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 
 #include <afs/exporter.h>
 /*#include "afs/osi.h"*/
@@ -358,7 +358,7 @@
 } osi_timeval32_t;		/* Needed here since KERNEL defined. */
 
 /*#include "afs/volerrors.h"*/
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #define _SYS_TIME_H
 #endif
 
@@ -483,14 +483,14 @@
 #define AFSNLIST(N, C) nlist64((N), (C))
 #endif /* AFS_32BIT_KERNEL_ENV */
 #else /* AFS_SGI61_ENV */
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 struct afs_nlist {
     char *n_name;
     unsigned long n_value;
 };
-#else /* AFS_LINUX20_ENV */
+#else /* AFS_LINUX_ENV */
 #define afs_nlist nlist
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 #define AFSNLIST(N, C) nlist((N), (C))
 #endif /* AFS_SGI61_ENV */
 #endif /* defined(AFS_HPUX_ENV) && defined(__LP64__) */
@@ -548,10 +548,10 @@
     return (char *)str;
 }
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 /* Find symbols in a live kernel. */
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 #define KSYMS "/proc/kallsyms"
 #else
 #define KSYMS "/proc/ksyms"
@@ -626,7 +626,7 @@
 	ksyms[nksyms].s_value = (int)strtoul(line, &p, 16);
 #endif /* AFS_LINUX_64BIT_KERNEL */
 	p++;
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 	/* Linux 2.6 /proc/kallsyms has a one-char symbol type
 	   between address and name, so step over it and the following
 	   blank.
@@ -1779,7 +1779,7 @@
 #endif
 
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 /* This is replicated from LINUX/osi_alloc.c */
 #define MEM_SPACE sizeof(int)
 
@@ -2100,7 +2100,7 @@
     printf
 	("\n\nNOTE:\n\tAll [...]* entries above aren't counted towards the total mem since they're redundant\n");
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     if (pnt)
 	print_alloced_memlist();
 #endif
@@ -2577,13 +2577,13 @@
 #endif
     printf(", v_mregb=0x%lx\n", vep->v_mregb);
 #endif
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     /* Print out the stat cache and other inode info. */
     printf
 	("\ti_ino=%d, i_mode=%x, i_nlink=%d, i_uid=%d, i_gid=%d, i_size=%d\n",
 	 vep->i_ino, vep->i_mode, vep->i_nlink, vep->i_uid, vep->i_gid,
 	 vep->i_size);
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
     printf
 	("\ti_atime=%u, i_mtime=%u, i_ctime=%u, i_version=%u, i_nrpages=%u\n",
 	 vep->i_atime, vep->i_mtime, vep->i_ctime, vep->i_version,
@@ -2594,30 +2594,31 @@
 	 vep->i_atime, vep->i_mtime, vep->i_ctime, vep->i_version,
 	 vep->i_nrpages);
 #endif
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
     printf("\ti_op=0x%x, i_rdev=0x%x, i_sb=0x%x\n", vep->i_op,
 	   vep->i_rdev, vep->i_sb);
-#else /* AFS_LINUX26_ENV */
+#else /* AFS_LINUX_ENV */
     printf("\ti_op=0x%x, i_dev=0x%x, i_rdev=0x%x, i_sb=0x%x\n", vep->i_op,
 	   vep->i_dev, vep->i_rdev, vep->i_sb);
-#endif /* AFS_LINUX26_ENV */
-#ifdef AFS_LINUX24_ENV
+#endif /* AFS_LINUX_ENV */
+
+#ifdef AFS_LINUX_ENV
     printf("\ti_sem: count=%d, sleepers=%d, wait=0x%x\n", vep->i_sem.count,
 	   vep->i_sem.sleepers, vep->i_sem.wait);
 #else
     printf("\ti_sem: count=%d, waking=%d, wait=0x%x\n", vep->i_sem.count,
 	   vep->i_sem.waking, vep->i_sem.wait);
 #endif
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
     printf("\ti_hash=0x%x:0x%x, i_list=0x%x:0x%x, i_dentry=0x%x:0x%x\n",
 	   vep->i_hash.pprev, vep->i_hash.next, vep->i_list.prev,
 	   vep->i_list.next, vep->i_dentry.prev, vep->i_dentry.next);
-#else /* AFS_LINUX26_ENV */
+#else /* AFS_LINUX_ENV */
     printf("\ti_hash=0x%x:0x%x, i_list=0x%x:0x%x, i_dentry=0x%x:0x%x\n",
 	   vep->i_hash.prev, vep->i_hash.next, vep->i_list.prev,
 	   vep->i_list.next, vep->i_dentry.prev, vep->i_dentry.next);
-#endif /* AFS_LINUX26_ENV */
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
+#endif /* AFS_LINUX_ENV */
 }
 
 void
@@ -2751,7 +2752,7 @@
 	    }
 	}
     }
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     printf("\tmapcnt=%d\n", vep->mapcnt);
 #endif
 }
diff --git a/src/viced/viced.c b/src/viced/viced.c
index 38dc877..4f63968 100644
--- a/src/viced/viced.c
+++ b/src/viced/viced.c
@@ -329,13 +329,13 @@
 viced_syscall(afs_uint32 a3, afs_uint32 a4, void *a5)
 {
     afs_uint32 rcode;
-# ifndef AFS_LINUX20_ENV
+# ifndef AFS_LINUX_ENV
     void (*old) (int);
 
     old = (void (*)(int))signal(SIGSYS, SIG_IGN);
 # endif
     rcode = syscall(AFS_SYSCALL, 28 /* AFSCALL_CALL */ , a3, a4, a5);
-# ifndef AFS_LINUX20_ENV
+# ifndef AFS_LINUX_ENV
     signal(SIGSYS, old);
 # endif
 
diff --git a/src/vol/daemon_com.h b/src/vol/daemon_com.h
index dabaf3b..ce3a29e 100644
--- a/src/vol/daemon_com.h
+++ b/src/vol/daemon_com.h
@@ -87,7 +87,7 @@
     afs_int64 _##buf##_l[SYNC_PROTO_MAX_LEN/sizeof(afs_int64)]; \
     char * buf = (char *)(_##buf##_l)
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 /* Some Linux kernels have a bug where we are not woken up immediately from a
  * select() when data is available. Work around this by having a low select()
  * timeout, so we don't hang in those situations. */
diff --git a/src/vol/ihandle.h b/src/vol/ihandle.h
index 0bc0203..89fd81c 100644
--- a/src/vol/ihandle.h
+++ b/src/vol/ihandle.h
@@ -521,7 +521,7 @@
 # define IH_CREATE(H, D, P, N, P1, P2, P3, P4) \
         ih_icreate(H, D, P, N, P1, P2, P3, P4)
 
-# ifdef AFS_LINUX22_ENV
+# ifdef AFS_LINUX_ENV
 #  define OS_IOPEN(H) -1
 # else
 #  ifdef O_LARGEFILE
@@ -545,7 +545,7 @@
 
 # define OS_SYNC(FD) fsync(FD)
 
-# ifdef AFS_LINUX22_ENV
+# ifdef AFS_LINUX_ENV
 #  define IH_INC(H, I, P) -1
 #  define IH_DEC(H, I, P) -1
 #  define IH_IREAD(H, O, B, S) -1
@@ -557,7 +557,7 @@
                                           O, B, S)
 #  define IH_IWRITE(H, O, B, S) \
           inode_write((H)->ih_dev, (H)->ih_ino, (H)->ih_vid, O, B, S)
-# endif /* AFS_LINUX22_ENV */
+# endif /* AFS_LINUX_ENV */
 
 #endif /* AFS_NAMEI_ENV */
 
diff --git a/src/vol/listinodes.c b/src/vol/listinodes.c
index 75bf936..3e8cac7 100644
--- a/src/vol/listinodes.c
+++ b/src/vol/listinodes.c
@@ -26,7 +26,7 @@
 #include <ctype.h>
 
 #ifndef AFS_NAMEI_ENV
-#if defined(AFS_LINUX20_ENV)
+#if defined(AFS_LINUX_ENV)
 /* ListViceInodes
  *
  * Return codes:
@@ -1210,7 +1210,7 @@
     return 0;
 }
 
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 static afs_int32
 convertVolumeInfo(FdHandle_t *fdhr, FdHandle_t *fdhw, VolumeId vid)
 {
diff --git a/src/vol/partition.c b/src/vol/partition.c
index 628de33..8d37a07 100644
--- a/src/vol/partition.c
+++ b/src/vol/partition.c
@@ -52,7 +52,7 @@
 #endif
 #endif
 #else /* AFS_VFSINCL_ENV */
-#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX22_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
+#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
 #include <sys/fs.h>
 #endif
 #endif /* AFS_VFSINCL_ENV */
@@ -75,7 +75,7 @@
 #include <sys/mnttab.h>
 #include <sys/mntent.h>
 #else
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #include <mntent.h>
 #include <sys/statfs.h>
 #else
@@ -275,7 +275,7 @@
 VCheckPartition(char *part, char *devname, int logging)
 {
     struct afs_stat_st status;
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_NT40_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_NT40_ENV)
     char AFSIDatPath[MAXPATHLEN];
 #endif
 
@@ -313,7 +313,7 @@
     }
 #endif
 
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_NT40_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_NT40_ENV)
     strcpy(AFSIDatPath, part);
     strcat(AFSIDatPath, "/AFSIDat");
 #ifdef AFS_NAMEI_ENV
@@ -343,7 +343,7 @@
 	return -1;
 #endif
 #endif /* AFS_NAMEI_ENV */
-#endif /* !AFS_LINUX20_ENV && !AFS_NT40_ENV */
+#endif /* !AFS_LINUX_ENV && !AFS_NT40_ENV */
 
     VInitPartition(part, devname, status.st_dev);
 
@@ -850,7 +850,7 @@
 }
 #endif
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 int
 VAttachPartitions(void)
 {
@@ -883,7 +883,7 @@
 
     return errors;
 }
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 
 /* This routine is to be called whenever the actual name of the partition
  * is required. The canonical name is still in part->name.
diff --git a/src/vol/salvaged.c b/src/vol/salvaged.c
index 5b53a7b..c4df218 100644
--- a/src/vol/salvaged.c
+++ b/src/vol/salvaged.c
@@ -51,7 +51,7 @@
 #endif
 #endif
 #else /* AFS_VFSINCL_ENV */
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <sys/inode.h>
 #endif
 #endif /* AFS_VFSINCL_ENV */
diff --git a/src/vol/salvager.c b/src/vol/salvager.c
index b850e37..7e307e4 100644
--- a/src/vol/salvager.c
+++ b/src/vol/salvager.c
@@ -51,7 +51,7 @@
 #endif
 #endif
 #else /* AFS_VFSINCL_ENV */
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <sys/inode.h>
 #endif
 #endif /* AFS_VFSINCL_ENV */
diff --git a/src/vol/vol-salvage.c b/src/vol/vol-salvage.c
index 706f9f0..79a68c6 100644
--- a/src/vol/vol-salvage.c
+++ b/src/vol/vol-salvage.c
@@ -119,7 +119,7 @@
 #endif
 #endif
 #else /* AFS_VFSINCL_ENV */
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <sys/inode.h>
 #endif
 #endif /* AFS_VFSINCL_ENV */
diff --git a/src/vol/volume.c b/src/vol/volume.c
index aa88d8a..4f292e05 100644
--- a/src/vol/volume.c
+++ b/src/vol/volume.c
@@ -58,7 +58,7 @@
 #endif
 #endif
 #else /* AFS_VFSINCL_ENV */
-#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <sys/fs.h>
 #endif
 #endif /* AFS_VFSINCL_ENV */
@@ -83,7 +83,7 @@
 #if defined(AFS_SGI_ENV)
 #include <mntent.h>
 #else
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
 #include <fstab.h>		/* Need to find in libc 5, present in libc 6 */
 #endif
 #endif
diff --git a/src/volser/volmain.c b/src/volser/volmain.c
index 96de6a0..40306d8 100644
--- a/src/volser/volmain.c
+++ b/src/volser/volmain.c
@@ -185,7 +185,7 @@
 volser_syscall(afs_uint32 a3, afs_uint32 a4, void *a5)
 {
     afs_uint32 rcode;
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
     void (*old) (int);
 
     old = signal(SIGSYS, SIG_IGN);
@@ -193,7 +193,7 @@
     rcode =
 	syscall(AFS_SYSCALL /* AFS_SYSCALL */ , 28 /* AFSCALL_CALL */ , a3,
 		a4, a5);
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
     signal(SIGSYS, old);
 #endif
 
diff --git a/tests/rpctestlib/rpc_test_procs.c b/tests/rpctestlib/rpc_test_procs.c
index 5863242..4f37400 100644
--- a/tests/rpctestlib/rpc_test_procs.c
+++ b/tests/rpctestlib/rpc_test_procs.c
@@ -220,7 +220,7 @@
     sprintf(ctx->fs_addr_s, "%s", fs_addr_s);
 
 #if defined(RPC_TEST_ADD_ADDRESSES)
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
     sprintf(cmd, "ip addr add %s/%s dev %s label %s", listen_addr_s, prefix,
             cb_if, cb_if);
     code = system(cmd);
@@ -362,7 +362,7 @@
 {
     afs_int32 code = 0;
 #if defined(RPC_TEST_ADD_ADDRESSES)
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
     sprintf(cmd, "ip addr del %s/%s dev %s label %s", ctx->cb_listen_addr_s,
             ctx->cb_prefix_s, ctx->cb_if_s, ctx->cb_if_s);
     code = system(cmd);
From 82c90ad9c7fb76a38e881630b10065b250912963 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 02 Jun 2022 11:17:45 -0600
Subject: [PATCH] Cleanup AFS_*LINUX_ENV usage

Commit 6329a523f6305541871bc3d1694065e7b17abe77 changed all
occurrences of AFS_*LINUXnn_ENV to AFS_*LINUX_ENV, but did not perform
any refactoring of the use of these variables.

This commit completes the task by refactoring the preprocessor
conditionals that involved removing dead code or collapsing statements.

The updates should have no functional changes.

Reviewed-on: https://gerrit.openafs.org/14388
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
(cherry picked from commit cbc18e4b311bdd2c461f60b7b96eb2ab8a6d1ee5)

Change-Id: I02e9f0cab5e60994c67593b0709ae1e500d23545
---

diff --git a/src/afs/LINUX/osi_machdep.h b/src/afs/LINUX/osi_machdep.h
index c120579..34940c6 100644
--- a/src/afs/LINUX/osi_machdep.h
+++ b/src/afs/LINUX/osi_machdep.h
@@ -170,26 +170,16 @@
     return in_compat_syscall();
 # elif defined(AFS_SPARC64_LINUX_ENV)
     return test_thread_flag(TIF_32BIT);
-# elif defined(AFS_SPARC64_LINUX_ENV)
-    return (current->thread.flags & SPARC_FLAG_32BIT) != 0;
-# elif defined(AFS_SPARC64_LINUX_ENV)
-    return (current->tss.flags & SPARC_FLAG_32BIT) != 0;
 # elif defined(AFS_AMD64_LINUX_ENV)
     return test_thread_flag(TIF_IA32);
-# elif defined(AFS_AMD64_LINUX_ENV)
-    return (current->thread.flags & THREAD_IA32) != 0;
 # elif defined(AFS_PPC64_LINUX_ENV)
 #  if defined(STRUCT_TASK_STRUCT_HAS_THREAD_INFO)
     return (current->thread_info->flags & _TIF_32BIT) != 0;
 #  else
     return (task_thread_info(current)->flags & _TIF_32BIT) != 0;
 #  endif
-# elif defined(AFS_PPC64_LINUX_ENV)
-   return (current->thread.flags & PPC_FLAG_32BIT) != 0;
 # elif defined(AFS_S390X_LINUX_ENV)
    return test_thread_flag(TIF_31BIT);
-# elif defined(AFS_S390X_LINUX_ENV)
-  return (current->thread.flags & S390_FLAG_31BIT) != 0;
 # elif defined(AFS_ARM64_LINUX_ENV)
   return is_compat_task();
 # else
diff --git a/src/afs/VNOPS/afs_vnop_lookup.c b/src/afs/VNOPS/afs_vnop_lookup.c
index 2a0457e..21785e5 100644
--- a/src/afs/VNOPS/afs_vnop_lookup.c
+++ b/src/afs/VNOPS/afs_vnop_lookup.c
@@ -1643,7 +1643,7 @@
 	    hit = 1;
 	    goto done;
 	}
-#else /* non - LINUX */
+#else
 	code = 0;
 	hit = 1;
 	goto done;
diff --git a/src/afs/afs_init.c b/src/afs/afs_init.c
index c68d6ae..364b916 100644
--- a/src/afs/afs_init.c
+++ b/src/afs/afs_init.c
@@ -423,14 +423,6 @@
 	if (!VFS_STATVFS(filevp->v_vfsp, &st))
 # elif defined(AFS_AIX41_ENV)
 	if (!VFS_STATFS(filevp->v_vfsp, &st, &afs_osi_cred))
-# elif defined(AFS_LINUX_ENV)
-	{
-	    KERNEL_SPACE_DECL;
-	    TO_USER_SPACE();
-
-	    VFS_STATFS(filevp->v_vfsp, &st);
-	    TO_KERNEL_SPACE();
-	}
 # elif defined(AFS_DARWIN80_ENV)
 	afs_cacheVfsp = vnode_mount(filevp);
 	if (afs_cacheVfsp && ((st = *(vfs_statfs(afs_cacheVfsp))),1))
@@ -459,10 +451,7 @@
 	    afs_fsfragsize = st.f_bsize - 1;
 # endif /* AFS_SUN5_ENV || AFS_HPUX100_ENV */
     }
-# if defined(AFS_LINUX_ENV)
-    cacheInode.ufs = filevp->i_ino;
-    afs_cacheSBp = filevp->i_sb;
-# elif defined(AFS_XBSD_ENV)
+# if defined(AFS_XBSD_ENV)
     cacheInode.ufs = VTOI(filevp)->i_number;
     cacheDev.mp = filevp->v_mount;
     cacheDev.held_vnode = filevp;
@@ -483,7 +472,7 @@
     afs_LookupInodeByPath(afile, &cacheInode.ufs, NULL);
 #  endif /* !AFS_CACHE_VNODE_PATH */
     cacheDev.dev = afs_vnodeToDev(filevp);
-# endif /* AFS_LINUX_ENV */
+# endif /* AFS_XBSD_ENV */
     AFS_RELE(filevp);
 #endif /* AFS_LINUX_ENV */
     if (afs_fsfragsize < AFS_MIN_FRAGSIZE) {
diff --git a/src/afs/afs_osi.c b/src/afs/afs_osi.c
index 895bcc0..24b96b8 100644
--- a/src/afs/afs_osi.c
+++ b/src/afs/afs_osi.c
@@ -252,8 +252,6 @@
 		osi_FreeSmallSpace(tmp);
 #elif defined(AFS_LINUX_ENV)
 		kfree(tmp);
-#elif defined(AFS_LINUX_ENV)
-		osi_linux_free(tmp);
 #endif
 	    }
 	}
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index e8d2c6b..a7f5af9 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -638,7 +638,6 @@
 
 /* LINUX/osi_misc.c */
 #ifdef AFS_LINUX_ENV
-#ifdef AFS_LINUX_ENV
 extern int osi_lookupname(char *aname, uio_seg_t seg, int followlink,
 			  struct dentry **dpp);
 extern int osi_InitCacheInfo(char *aname);
@@ -648,7 +647,6 @@
 		      uio_seg_t seg);
 extern int uiomove(char *dp, int length, uio_flag_t rw, struct uio *uiop);
 extern void osi_linux_free_inode_pages(void);
-#endif
 extern void osi_linux_mask(void);
 extern void osi_linux_unmaskrxk(void);
 extern int setpag(cred_t ** cr, afs_uint32 pagvalue, afs_uint32 * newpag,
diff --git a/src/afs/afsincludes.h b/src/afs/afsincludes.h
index 1a4369e..9841f2f 100644
--- a/src/afs/afsincludes.h
+++ b/src/afs/afsincludes.h
@@ -36,8 +36,6 @@
 #   undef TRUE
 #   undef FALSE
 #  endif
-# endif
-# ifdef AFS_LINUX_ENV
 #  undef __NFDBITS
 #  undef __FDMASK
 # endif
diff --git a/src/afs/sysincludes.h b/src/afs/sysincludes.h
index 3e3e015..e1312f6 100644
--- a/src/afs/sysincludes.h
+++ b/src/afs/sysincludes.h
@@ -177,9 +177,7 @@
 # if defined(HAVE_LINUX_EXPORTFS_H)
 #  include <linux/exportfs.h>
 # endif
-# ifdef AFS_LINUX_ENV
-#  include <linux/pagemap.h>
-# endif
+# include <linux/pagemap.h>
 
 #else /* AFS_LINUX_ENV */
 
diff --git a/src/afsd/afsd.c b/src/afsd/afsd.c
index 60dfde9..448981a 100644
--- a/src/afsd/afsd.c
+++ b/src/afsd/afsd.c
@@ -1298,17 +1298,6 @@
 	if (res != 0) {
 	    return "unable to statfs cache base directory";
 	}
-#if !defined(AFS_LINUX_ENV)
-	if (statfsbuf.f_type == 0x52654973) {	/* REISERFS_SUPER_MAGIC */
-	    return "cannot use reiserfs as cache partition";
-	} else if (statfsbuf.f_type == 0x58465342) {	/* XFS_SUPER_MAGIC */
-	    return "cannot use xfs as cache partition";
-	} else if (statfsbuf.f_type == 0x01021994) {    /* TMPFS_SUPER_MAGIC */
-            return "cannot use tmpfs as cache partition";
-        } else if (statfsbuf.f_type != 0xEF53) {
-            return "must use ext2 or ext3 for cache partition";
-	}
-#endif
     }
 #endif
 
diff --git a/src/rx/xdr_rx.c b/src/rx/xdr_rx.c
index ade4de4..62fbed3 100644
--- a/src/rx/xdr_rx.c
+++ b/src/rx/xdr_rx.c
@@ -21,8 +21,6 @@
 #  include "h/uio.h"
 #  ifdef AFS_LINUX_ENV
 #   include "h/socket.h"
-#  endif
-#  ifdef AFS_LINUX_ENV
 #   ifndef quad_t
 #    define quad_t __quad_t
 #    define u_quad_t __u_quad_t
diff --git a/src/venus/kdump.c b/src/venus/kdump.c
index baee73b..3cef0f0 100644
--- a/src/venus/kdump.c
+++ b/src/venus/kdump.c
@@ -551,11 +551,7 @@
 #ifdef AFS_LINUX_ENV
 /* Find symbols in a live kernel. */
 
-#ifdef AFS_LINUX_ENV
 #define KSYMS "/proc/kallsyms"
-#else
-#define KSYMS "/proc/ksyms"
-#endif
 
 /* symlist_t contains all the kernel symbols. Forcing a 64 byte array is
  * a bit wasteful, but simple.
@@ -626,13 +622,11 @@
 	ksyms[nksyms].s_value = (int)strtoul(line, &p, 16);
 #endif /* AFS_LINUX_64BIT_KERNEL */
 	p++;
-#ifdef AFS_LINUX_ENV
 	/* Linux 2.6 /proc/kallsyms has a one-char symbol type
 	   between address and name, so step over it and the following
 	   blank.
 	*/
 	p += 2;
-#endif
 	q = strchr(p, '\t');
 	if (q)
 	    *q = '\0';
@@ -682,7 +676,7 @@
     return 0;
 }
 
-#endif
+#endif /* AFS_LINUX_ENV */
 
 #if	defined(AFS_SUN5_ENV)
 #ifdef	_LP64
@@ -1829,7 +1823,7 @@
     printf("Found %d elements in allocated memory list, expected %d\n", n,
 	   count);
 }
-#endif
+#endif /* AFS_LINUX_ENV */
 
 void
 print_allocs(int pnt)
@@ -2583,41 +2577,17 @@
 	("\ti_ino=%d, i_mode=%x, i_nlink=%d, i_uid=%d, i_gid=%d, i_size=%d\n",
 	 vep->i_ino, vep->i_mode, vep->i_nlink, vep->i_uid, vep->i_gid,
 	 vep->i_size);
-#ifdef AFS_LINUX_ENV
     printf
 	("\ti_atime=%u, i_mtime=%u, i_ctime=%u, i_version=%u, i_nrpages=%u\n",
 	 vep->i_atime, vep->i_mtime, vep->i_ctime, vep->i_version,
 	 vep->i_data.nrpages);
-#else
-    printf
-	("\ti_atime=%u, i_mtime=%u, i_ctime=%u, i_version=%u, i_nrpages=%u\n",
-	 vep->i_atime, vep->i_mtime, vep->i_ctime, vep->i_version,
-	 vep->i_nrpages);
-#endif
-#ifdef AFS_LINUX_ENV
     printf("\ti_op=0x%x, i_rdev=0x%x, i_sb=0x%x\n", vep->i_op,
 	   vep->i_rdev, vep->i_sb);
-#else /* AFS_LINUX_ENV */
-    printf("\ti_op=0x%x, i_dev=0x%x, i_rdev=0x%x, i_sb=0x%x\n", vep->i_op,
-	   vep->i_dev, vep->i_rdev, vep->i_sb);
-#endif /* AFS_LINUX_ENV */
-
-#ifdef AFS_LINUX_ENV
     printf("\ti_sem: count=%d, sleepers=%d, wait=0x%x\n", vep->i_sem.count,
 	   vep->i_sem.sleepers, vep->i_sem.wait);
-#else
-    printf("\ti_sem: count=%d, waking=%d, wait=0x%x\n", vep->i_sem.count,
-	   vep->i_sem.waking, vep->i_sem.wait);
-#endif
-#ifdef AFS_LINUX_ENV
     printf("\ti_hash=0x%x:0x%x, i_list=0x%x:0x%x, i_dentry=0x%x:0x%x\n",
 	   vep->i_hash.pprev, vep->i_hash.next, vep->i_list.prev,
 	   vep->i_list.next, vep->i_dentry.prev, vep->i_dentry.next);
-#else /* AFS_LINUX_ENV */
-    printf("\ti_hash=0x%x:0x%x, i_list=0x%x:0x%x, i_dentry=0x%x:0x%x\n",
-	   vep->i_hash.prev, vep->i_hash.next, vep->i_list.prev,
-	   vep->i_list.next, vep->i_dentry.prev, vep->i_dentry.next);
-#endif /* AFS_LINUX_ENV */
 #endif /* AFS_LINUX_ENV */
 }
 
From b8b55154ab00621a0535092c0f0ea4789723da3b Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Thu, 24 Mar 2022 12:04:13 -0500
Subject: [PATCH] afs: Remove redundant AFS_LINUX_ENV test

After our Linux checks were converted to AFS_LINUX_ENV in commit
6329a523 (Change AFS*_LINUXnn_ENV to AFS*_LINUX_ENV), the extra
AFS_LINUX_ENV check in this line doesn't make any sense. Get rid of
it.

Reviewed-on: https://gerrit.openafs.org/14935
Reviewed-by: Marcio Brito Barbosa <mbarbosa@sinenomine.net>
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
(cherry picked from commit a7d04f0770beb08ea7db2dcdc3dee80b2a57233a)

Change-Id: I797e1d677cc758d0475011167c0cbafeedf9788c
---

diff --git a/src/afs/afs.h b/src/afs/afs.h
index c47b28c..582a816 100644
--- a/src/afs/afs.h
+++ b/src/afs/afs.h
@@ -71,7 +71,7 @@
 #if     defined(AFS_HPUX102_ENV)
 #define AFS_FLOCK       k_flock
 #else
-#if     defined(AFS_SUN5_ENV) || (defined(AFS_LINUX_ENV) && !(defined(AFS_LINUX_ENV) && defined(AFS_LINUX_64BIT_KERNEL)))
+#if     defined(AFS_SUN5_ENV) || (defined(AFS_LINUX_ENV) && !defined(AFS_LINUX_64BIT_KERNEL))
 #define AFS_FLOCK       flock64
 #else
 #define AFS_FLOCK       flock
From ff7ad218b8af305297e9c4986d6a2aca521ccfaf Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Mon, 01 Oct 2018 11:38:37 -0400
Subject: [PATCH] ubik: do not reuse the offset variable for the sync site address

The ubik SendFile function performs a sanity check of the host address
before proceeding with the file transfer.  Currently this check reuses
the file offset local variable to hold the value of the sync site
address, a 32-bit IPv4 address. Not only is this confusing, but also
causes a signed/unsigned type mismatch when comparing host addresses.
Instead of being so stingy with local variables, declare a new local
variable of the correct type to hold the value of the sync site address.

This separation is also a prerequisite for supporting larger address
types in the future.

Reviewed-on: https://gerrit.openafs.org/13351
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit f0bab78cbe4f59609fa18647a480cc6989948786)

Change-Id: I2bda69a2586628b51e84c3facf116bf652e3df0a
---

diff --git a/src/ubik/remote.c b/src/ubik/remote.c
index a7ddcc4..70626cd 100644
--- a/src/ubik/remote.c
+++ b/src/ubik/remote.c
@@ -477,6 +477,7 @@
     int tlen;
     struct rx_peer *tpeer;
     struct rx_connection *tconn;
+    afs_uint32 syncHost = 0;
     afs_uint32 otherHost = 0;
     char hoststr[16];
     char pbuffer[1028];
@@ -503,17 +504,17 @@
      * screwup.  Thus, we only object if we're sure we know who the sync site
      * is, and it ain't the guy talking to us.
      */
-    offset = uvote_GetSyncSite();
+    syncHost = uvote_GetSyncSite();
     tconn = rx_ConnectionOf(rxcall);
     tpeer = rx_PeerOf(tconn);
     otherHost = ubikGetPrimaryInterfaceAddr(rx_HostOf(tpeer));
-    if (offset && offset != otherHost) {
+    if (syncHost && syncHost != otherHost) {
 	/* we *know* this is the wrong guy */
         char sync_hoststr[16];
 	ViceLog(0,
 	    ("Ubik: Refusing synchronization with server %s since it is not the sync-site (%s).\n",
 	     afs_inet_ntoa_r(otherHost, hoststr),
-	     afs_inet_ntoa_r(offset, sync_hoststr)));
+	     afs_inet_ntoa_r(syncHost, sync_hoststr)));
 	return USYNC;
     }
 
From 1d528176d9b8ece6acc97438395eee0a29d153e3 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Mon, 10 Sep 2018 23:47:33 -0400
Subject: [PATCH] klog.krb5 -lifetime is not implemented

The klog.krb5 -lifetime option was copied from earlier versions of log
and klog, which had the ability to set the krb4 token lifetime. However,
the -lifetime option is not feasible the krb5 version, and so is not
implemented in klog.krb5.

Update the klog.krb5 man page to document the -lifetime option has no
effect.  Remove the code which unnecessarily checks the unused klog.krb5
-lifetime command line argument.

The unused lifetime variable was discovered by Pat Riehecky using the
clang scan-build static analyzer.

Reviewed-on: https://gerrit.openafs.org/13309
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: PatRiehecky <jcpunk@gmail.com>
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit da699c8b81e818ba97ff8115397d7f7afe0bf512)

Change-Id: I81cd0024f4727ba401df7b5813163b11f9b43bd4
---

diff --git a/doc/man-pages/pod1/klog.krb5.pod b/doc/man-pages/pod1/klog.krb5.pod
index 05d671c..6b98c7a 100644
--- a/doc/man-pages/pod1/klog.krb5.pod
+++ b/doc/man-pages/pod1/klog.krb5.pod
@@ -61,11 +61,6 @@
 
 =item *
 
-The lifetime specified by the issuer with the B<-lifetime> argument if
-that argument was given.
-
-=item *
-
 The maximum ticket lifetime recorded for the C<afs/I<cell>> principal in
 thet Kerberos database.
 
@@ -192,8 +187,7 @@
 
 =item B<-lifetime> <I<ticket lifetime>
 
-Requests a specific lifetime for the token.  Provide a number of hours and
-optionally minutes and seconds in the format I<hh>[B<:>I<mm>[B<:>I<ss>]].
+This option is not implemented by B<klog.krb5> and has no effect.
 
 =item B<-setpag>
 
@@ -263,12 +257,6 @@
 
    % klog.krb5 -principal admin -cell test.example.com
    Password for admin@EXAMPLE.COM:
-
-In the following, the issuer requests a ticket lifetime of 104 hours 30
-minutes (4 days 8 hours 30 minutes).
-
-   % klog.krb5 -lifetime 104:30
-   Password for user@EXAMPLE.ORG:
 
 =head1 PRIVILEGE REQUIRED
 
diff --git a/src/aklog/klog.c b/src/aklog/klog.c
index 0f29884..df4a062 100644
--- a/src/aklog/klog.c
+++ b/src/aklog/klog.c
@@ -127,6 +127,7 @@
     cmd_AddParm(ts, "-pipe", CMD_FLAG, CMD_OPTIONAL,
 		"read password from stdin");
     cmd_AddParm(ts, "-silent", CMD_FLAG, CMD_OPTIONAL, "silent operation");
+    /* Note: -lifetime is not implemented in this version of klog. */
     cmd_AddParm(ts, "-lifetime", CMD_SINGLE, CMD_OPTIONAL,
 		"ticket lifetime in hh[:mm[:ss]]");
     cmd_AddParm(ts, "-setpag", CMD_FLAG, CMD_OPTIONAL,
@@ -361,7 +362,6 @@
     int authtype;
 #endif
     krb5_data enc_part[1];
-    time_t lifetime;		/* requested ticket lifetime */
     krb5_prompter_fct pf = NULL;
     char *pass = 0;
     void *pa = 0;
@@ -512,36 +512,6 @@
 	       strlen(as->parms[aPASSWORD].items->data));
 	pass = passwd;
     }
-
-    if (as->parms[aLIFETIME].items) {
-	char *life = as->parms[aLIFETIME].items->data;
-	char *sp;		/* string ptr to rest of life */
-	lifetime = 3600 * strtol(life, &sp, 0);	/* hours */
-	if (sp == life) {
-	  bad_lifetime:
-	    if (!Silent)
-		fprintf(stderr, "%s: translating '%s' to lifetime failed\n",
-			rn, life);
-	    return 1;
-	}
-	if (*sp == ':') {
-	    life = sp + 1;	/* skip the colon */
-	    lifetime += 60 * strtol(life, &sp, 0);	/* minutes */
-	    if (sp == life)
-		goto bad_lifetime;
-	    if (*sp == ':') {
-		life = sp + 1;
-		lifetime += strtol(life, &sp, 0);	/* seconds */
-		if (sp == life)
-		    goto bad_lifetime;
-		if (*sp)
-		    goto bad_lifetime;
-	    } else if (*sp)
-		goto bad_lifetime;
-	} else if (*sp)
-	    goto bad_lifetime;
-    } else
-	lifetime = 0;
 
     /* Get the password if it wasn't provided. */
     if (!pass) {
From 67c9d5f1f3c2ec26873dc1beace77618a4a64f73 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Mon, 23 Aug 2021 14:23:01 -0400
Subject: [PATCH] ubik: Fix ubeacon_updateUbikNetworkAddress() mismatched array parameter warning

The ubeacon_updateUbikNetworkAddress() prototype does not match the
function definition. The ubik_host parameter is declared as an unbounded
array in the prototype but is defined as a bounded array. As of GCC 12,
a warning is issued for the mismatch:

    error: argument 1 of type ‘afs_uint32[256]’ {aka ‘unsigned int[256]’}
           with mismatched bound [-Werror=array-parameter=]
           ubeacon_updateUbikNetworkAddress(
             afs_uint32 ubik_host[UBIK_MAX_INTERFACE_ADDR])

    note: previously declared as ‘afs_uint32[]’ {aka ‘unsigned int[]’}
          extern int ubeacon_updateUbikNetworkAddress(afs_uint32 ubik_host[]);

Restore the ubik_host array length in the function prototype, which was
dropped in commit 9020e6e2f0357b1082705dcaa6626573433969ec (ubik: Defer
updateUbikNetworkAddress until after RX startup).

Reviewed-on: https://gerrit.openafs.org/14767
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 36796bbb83af2650a872234fdb5cf7124bf6cfa8)

Change-Id: Ia27b5b9642dbd355e1310419424ed0ac04add4b2
---

diff --git a/src/ubik/ubik.p.h b/src/ubik/ubik.p.h
index 4585ba9..6567961 100644
--- a/src/ubik/ubik.p.h
+++ b/src/ubik/ubik.p.h
@@ -491,7 +491,7 @@
 					char clones[]);
 extern int ubeacon_InitServerList(afs_uint32 ame, afs_uint32 aservers[]);
 extern void *ubeacon_Interact(void *);
-extern int ubeacon_updateUbikNetworkAddress(afs_uint32 ubik_host[]);
+extern int ubeacon_updateUbikNetworkAddress(afs_uint32 ubik_host[UBIK_MAX_INTERFACE_ADDR]);
 extern struct beacon_data beacon_globals;
 extern struct addr_data addr_globals;
 
From e7f0ee21a377a90aa5eed28f1ac52cd3e76bf0f4 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Tue, 24 Aug 2021 16:40:22 -0400
Subject: [PATCH] ptserver: Fix CreateEntry() mismatched array parameter warning

The CreateEntry() prototype does not match the function definition. The
aname parameter is declared as an unbounded array in the prototype but
is defined as a bounded array. As of GCC 12, a warning is issued for the
mismatch.

    error: argument 2 of type ‘char[64]’ with mismatched bound
           [-Werror=array-parameter=]
           CreateEntry(struct ubik_trans *at, char aname[PR_MAXNAMELEN], ...

    note: previously declared as ‘char[]’
          extern afs_int32 CreateEntry(struct ubik_trans *at, char aname[], ...

Fix the prototype to declare the 'aname' parameter as a bounded array as
expected for this function.

Reviewed-on: https://gerrit.openafs.org/14768
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit fe64ddd3b49bf15222d32d443ff226dd4c2b899e)

Change-Id: If29ada7f9460591de8d2b61c17d00090465625b2
---

diff --git a/src/ptserver/ptprototypes.h b/src/ptserver/ptprototypes.h
index bc4c8d6..43b1361 100644
--- a/src/ptserver/ptprototypes.h
+++ b/src/ptserver/ptprototypes.h
@@ -76,7 +76,7 @@
 			    afs_int32 loc, afs_int32 aid);
 extern int AccessOK(struct ubik_trans *ut, afs_int32 cid,
 		    struct prentry *tentry, int mem, int any);
-extern afs_int32 CreateEntry(struct ubik_trans *at, char aname[],
+extern afs_int32 CreateEntry(struct ubik_trans *at, char aname[PR_MAXNAMELEN],
 			     afs_int32 *aid, afs_int32 idflag,
 			     afs_int32 flag, afs_int32 oid, afs_int32 creator);
 extern afs_int32 RemoveFromEntry(struct ubik_trans *at, afs_int32 aid,
From cbda97603a65d3084fa9d89fbc63bd3e6c1e93c7 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Mon, 23 Aug 2021 19:43:45 -0400
Subject: [PATCH] pts: Fix stringop-overflow warnings

The ptutil functions are defined to accept bounded character arrays for
user and group names. As of GCC 11, callers which provide the names as
string literals now trigger the stringop-overflow warning, since the
regions provided by the string literals are smaller than the bounded
areas.

    error: ‘pr_ChangeEntry’ accessing 64 bytes in a region of size 1
           [-Werror=stringop-overflow=]
    note: referencing argument 4 of type ‘char *’

    error: ‘pr_IsAMemberOf’ accessing 64 bytes in a region of size 22
           [-Werror=stringop-overflow=]
    note: referencing argument 2 of type ‘char *’

    error: ‘pr_CreateUser’ accessing 64 bytes in a region of size 16
           [-Werror=stringop-overflow=]
    note: referencing argument 1 of type ‘char *’

    error: ‘pr_Delete’ accessing 64 bytes in a region of size 16
           [-Werror=stringop-overflow=]
    note: referencing argument 1 of type ‘char *’

Update the callers in pts and testpt which pass literal strings. Instead
of passing char pointers to literal strings, assign the strings to
prname buffers and pass the prname buffers to the pr utility functions.

Reviewed-on: https://gerrit.openafs.org/14769
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit a3aac5106beddc5a6f7a09c2d21c2524342aca01)

Change-Id: I38883cdf9c6db701370b3c6755ca28e50f618c82
---

diff --git a/src/ptserver/pts.c b/src/ptserver/pts.c
index fb23968..3c5fc6d 100644
--- a/src/ptserver/pts.c
+++ b/src/ptserver/pts.c
@@ -626,6 +626,7 @@
     idlist ids;
     idlist lids;
     struct prcheckentry aentry;
+    prname admins = "system:administrators";
 
     if (GetNameOrId(as, &ids, &names))
 	return PRBADARG;
@@ -691,7 +692,7 @@
 	}
 	if (aentry.id == SYSADMINID)
 	    admin = 1;
-	else if (!pr_IsAMemberOf(aentry.name, "system:administrators", &flag)) {
+	else if (!pr_IsAMemberOf(aentry.name, admins, &flag)) {
 	    if (flag)
 		admin = 1;
 	}
@@ -754,11 +755,12 @@
 {
     afs_int32 code;
     char *name;
+    prname newname = "";
     char *owner;
 
     name = as->parms[0].items->data;
     owner = as->parms[1].items->data;
-    code = pr_ChangeEntry(name, "", 0, owner);
+    code = pr_ChangeEntry(name, newname, 0, owner);
     if (code)
 	afs_com_err(whoami, code, "; unable to change owner of %s to %s", name,
 		owner);
@@ -771,10 +773,11 @@
     afs_int32 code;
     char *oldname;
     char *newname;
+    prname owner = "";
 
     oldname = as->parms[0].items->data;
     newname = as->parms[1].items->data;
-    code = pr_ChangeEntry(oldname, newname, 0, "");
+    code = pr_ChangeEntry(oldname, newname, 0, owner);
     if (code)
 	afs_com_err(whoami, code, "; unable to change name of %s to %s", oldname,
 		newname);
diff --git a/src/ptserver/testpt.c b/src/ptserver/testpt.c
index eaaee48..c359f8f 100644
--- a/src/ptserver/testpt.c
+++ b/src/ptserver/testpt.c
@@ -217,7 +217,7 @@
 CreateUser(int u)
 {
     afs_int32 code;
-    char name[16];
+    prname name;
     afs_int32 id;
 
     sprintf(name, "%s%d", createPrefix, u);
From 93eea3bbeb61fab53df461182762f38f5df00bf8 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Mon, 23 Aug 2021 15:33:19 -0400
Subject: [PATCH] Fix PrintInode() mismatched array parameter warnings

The PrintInode() prototypes do not match the function definitions.

When AFS_64BIT_IOPS_ENV is defined (which is the common case and is
required for namei), the buffer parameter is declared as a bounded
character array (afs_ino_str_t) in the prototype, but is defined as an
unbounded character pointer.  When AFS_64BIT_IOPS_ENV is not defined
(for legacy 32-bit inode vice partitions), PrintInode() is declared with
no specified parameters.

A static buffer is used to hold the formatted string when a NULL is
passed as the first argument to PrintInode(). However, this method is
only used by the volinfo and iopen utility programs.

Fix the mismatch function prototypes and definitions to use the bounded
char array (afs_ino_str_t) in all cases.  Remove the deprecated function
declaration with no specified parameters. Update vol-info and iopen to
pass an afs_ino_str_t buffer and remove the now unused static buffer.
Update the duplicated PrintInode() function definition in namei_ops.c.
(This duplicated code could be removed in a future commit.)

Reviewed-on: https://gerrit.openafs.org/14770
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit a1e57d2e42b6d01e5ece93d5d49a4b9f3ecd3edc)

Change-Id: Ia8685805513c2c17e9253d83aa471718a09a449a
---

diff --git a/src/sys/afssyscalls.c b/src/sys/afssyscalls.c
index 8291a46..b248e69 100644
--- a/src/sys/afssyscalls.c
+++ b/src/sys/afssyscalls.c
@@ -281,23 +281,16 @@
 }
 
 
-/* PrintInode
+/**
+ * Format a string to print either 32 or 64 bit inode numbers.
  *
- * returns a static string used to print either 32 or 64 bit inode numbers.
+ * @param[out]  s    string buffer
+ * @param[in]   ino  inode number
+ * @returns pointer to formatted inode number string
  */
-#ifdef AFS_64BIT_IOPS_ENV
-char *
-PrintInode(char *s, Inode ino)
-#else
 char *
 PrintInode(afs_ino_str_t s, Inode ino)
-#endif
 {
-    static afs_ino_str_t result;
-
-    if (!s)
-	s = result;
-
 #ifdef AFS_64BIT_IOPS_ENV
     (void)sprintf((char *)s, "%llu", ino);
 #else
diff --git a/src/sys/afssyscalls.h b/src/sys/afssyscalls.h
index 6a9391c..aa47d6d 100644
--- a/src/sys/afssyscalls.h
+++ b/src/sys/afssyscalls.h
@@ -88,14 +88,9 @@
 #define AFS_INO_STR_LENGTH 32
 typedef char afs_ino_str_t[AFS_INO_STR_LENGTH];
 
-/* Print either 32 or 64 bit inode numbers. char * may be NULL. In which case
- * a local statis is returned.
+/* Format either 32 or 64 bit inode numbers.
  */
-#ifdef AFS_64BIT_IOPS_ENV
-extern char *PrintInode(afs_ino_str_t, Inode);
-#else
-extern char *PrintInode();
-#endif
+extern char *PrintInode(afs_ino_str_t s, Inode ino) AFS_NONNULL((1));
 
 /* Some places in the code assume icreate can return 0 when there's
  * an error.
diff --git a/src/sys/iopen.c b/src/sys/iopen.c
index 7c1a961..b9cd3d6 100644
--- a/src/sys/iopen.c
+++ b/src/sys/iopen.c
@@ -37,6 +37,7 @@
     int fd, n;
     struct stat status;
     Inode ino;
+    afs_ino_str_t inode_str;
 
     if (argc != 3)
 	Usage();
@@ -54,7 +55,7 @@
     }
     printf("ino=%" AFS_INT64_FMT "\n", ino);
     printf("About to iopen(dev=(%d,%d), inode=%s, mode=%d\n",
-	   major(status.st_dev), minor(status.st_dev), PrintInode(NULL, ino),
+	   major(status.st_dev), minor(status.st_dev), PrintInode(inode_str, ino),
 	   O_RDONLY);
     fflush(stdout);
     fd = IOPEN(status.st_dev, ino, O_RDONLY);
diff --git a/src/vol/namei_ops.c b/src/vol/namei_ops.c
index d02b465..716850d 100644
--- a/src/vol/namei_ops.c
+++ b/src/vol/namei_ops.c
@@ -3271,19 +3271,17 @@
     return code;
 }
 
-/* PrintInode
+/**
+ * Format a string to print inode numbers.
  *
- * returns a static string used to print either 32 or 64 bit inode numbers.
+ * @param[out]  s    string buffer
+ * @param[in]   ino  inode number
+ * @returns pointer to formatted inode number string
  */
 char *
-PrintInode(char *s, Inode ino)
+PrintInode(afs_ino_str_t s, Inode ino)
 {
-    static afs_ino_str_t result;
-    if (!s)
-	s = result;
-
     snprintf(s, sizeof(afs_ino_str_t), "%llu", (afs_uintmax_t) ino);
-
     return s;
 }
 
diff --git a/src/vol/vol-info.c b/src/vol/vol-info.c
index 22ac94a..6423fa8 100644
--- a/src/vol/vol-info.c
+++ b/src/vol/vol-info.c
@@ -331,6 +331,7 @@
     struct versionStamp *vsn;
     int bad = 0;
     int code;
+    afs_ino_str_t inode_str;
 
     vsn = (struct versionStamp *)to;
 
@@ -341,7 +342,7 @@
     if (vsn->magic != magic) {
 	bad++;
 	fprintf(stderr, "%s: Inode %s: Bad magic %x (%x): IGNORED\n",
-		progname, PrintInode(NULL, ih->ih_ino), vsn->magic, magic);
+		progname, PrintInode(inode_str, ih->ih_ino), vsn->magic, magic);
     }
 
     /* Check is conditional, in case caller wants to inspect version himself */
@@ -349,23 +350,23 @@
 	bad++;
 	fprintf(stderr, "%s: Inode %s: Bad version %x (%x): IGNORED\n",
 		progname,
-		PrintInode(NULL, ih->ih_ino), vsn->version, version);
+		PrintInode(inode_str, ih->ih_ino), vsn->version, version);
     }
     if (bad && opt->fixHeader) {
 	vsn->magic = magic;
 	vsn->version = version;
 	printf("Special index inode %s has a bad header. Reconstructing...\n",
-	       PrintInode(NULL, ih->ih_ino));
+	       PrintInode(inode_str, ih->ih_ino));
 	code = IH_IWRITE(ih, 0, to, size);
 	if (code != size) {
 	    fprintf(stderr,
 		    "%s: Write failed for inode %s; header left in damaged state\n",
-		    progname, PrintInode(NULL, ih->ih_ino));
+		    progname, PrintInode(inode_str, ih->ih_ino));
 	}
     }
     if (!bad && opt->dumpInfo) {
 	printf("Inode %s: Good magic %x and version %x\n",
-	       PrintInode(NULL, ih->ih_ino), magic, version);
+	       PrintInode(inode_str, ih->ih_ino), magic, version);
     }
     return 0;
 }
@@ -887,6 +888,7 @@
     afs_sfsize_t size = -1;
     IHandle_t *ih = NULL;
     FdHandle_t *fdP = NULL;
+    afs_ino_str_t inode_str;
 #ifdef AFS_NAMEI_ENV
     namei_t filename;
 #endif /* AFS_NAMEI_ENV */
@@ -912,7 +914,7 @@
 
   error:
     if (opt->dumpInfo) {
-	printf("\t%s inode\t= %s (size = ", name, PrintInode(NULL, inode));
+	printf("\t%s inode\t= %s (size = ", name, PrintInode(inode_str, inode));
 	if (size != -1) {
 	    printf("%lld)\n", size);
 	} else {
@@ -1241,6 +1243,7 @@
     afs_foff_t total;
     ssize_t len;
     Inode ino = VNDISK_GET_INO(vdp->vnode);
+    afs_ino_str_t inode_str;
 
     if (!VALID_INO(ino)) {
 	return;
@@ -1251,10 +1254,10 @@
     if (fdP == NULL) {
 	fprintf(stderr,
 		"%s: Can't open inode %s error %d (ignored)\n",
-		progname, PrintInode(NULL, ino), errno);
+		progname, PrintInode(inode_str, ino), errno);
 	return;
     }
-    snprintf(nfile, sizeof nfile, "TmpInode.%s", PrintInode(NULL, ino));
+    snprintf(nfile, sizeof nfile, "TmpInode.%s", PrintInode(inode_str, ino));
     ofd = afs_open(nfile, O_CREAT | O_RDWR | O_TRUNC, 0600);
     if (ofd < 0) {
 	fprintf(stderr,
@@ -1276,7 +1279,7 @@
 	    unlink(nfile);
 	    fprintf(stderr,
 		    "%s: Error while reading from inode %s (%d)\n",
-		    progname, PrintInode(NULL, ino), errno);
+		    progname, PrintInode(inode_str, ino), errno);
 	    return;
 	}
 	if (len == 0)
@@ -1299,7 +1302,7 @@
     IH_RELEASE(ih);
     close(ofd);
     printf("... Copied inode %s to file %s (%lu bytes)\n",
-	   PrintInode(NULL, ino), nfile, (unsigned long)total);
+	   PrintInode(inode_str, ino), nfile, (unsigned long)total);
 }
 
 /**
@@ -1812,6 +1815,7 @@
     VnodeDiskObject *vnode = vdp->vnode;
     afs_fsize_t fileLength;
     Inode ino;
+    afs_ino_str_t inode_str;
 
     ino = VNDISK_GET_INO(vnode);
     VNDISK_GET_LEN(fileLength, vnode);
@@ -1828,7 +1832,7 @@
 	 vnode->dataVersion, vnode->cloned, (afs_uintmax_t) fileLength,
 	 vnode->linkCount, vnode->parent);
     if (opt->dumpInodeNumber)
-	printf(" inode: %s", PrintInode(NULL, ino));
+	printf(" inode: %s", PrintInode(inode_str, ino));
     if (opt->dumpDate)
 	printf(" ServerModTime: %s", date(vnode->serverModifyTime));
 #if defined(AFS_NAMEI_ENV)
From 120452375c73ba479b6378642a096584d88d4314 Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Mon, 23 Aug 2021 15:37:13 -0400
Subject: [PATCH] bucoord: Fix doDispatch() array-parameter gcc warning

The doDispatch() prototype does not match the function definition. The
targv parameter is declared as an unbounded array in the prototype, but
is defined as a bounded array. As of GCC 12, a warning is issued for the
mismatch.

    main.c:346:18: error: argument 2 of type ‘char *[100]’ with
      mismatched bound [-Werror=array-parameter=]
    bucoord_internal.h:123:40: note: previously declared as ‘char *[]’

Within doDispatch(), the targv argument is just passed to cmd_Dispatch()
(this is the only use of targv). Since cmd_Displatch() expects an
unbounded array, update the doDispatch() definition to match the
prototype.

Reviewed-on: https://gerrit.openafs.org/14771
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 92a6242de2d8ea280debc283a7c089f97c1670bc)

Change-Id: Idc674dccac5adcbe610e059463e493716cf80f57
---

diff --git a/src/bucoord/main.c b/src/bucoord/main.c
index a453cc9..972ac2d 100644
--- a/src/bucoord/main.c
+++ b/src/bucoord/main.c
@@ -343,7 +343,7 @@
 
 afs_int32
 doDispatch(afs_int32 targc,
-	   char *targv[MAXV],
+	   char *targv[],
 	   afs_int32 dispatchCount) /* to prevent infinite recursion */
 {
     char *sargv[MAXV];
From d068f03ad0f94c7a49ddc6d2f9f0a8d1b7f6cf5b Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Mon, 23 Aug 2021 15:42:52 -0400
Subject: [PATCH] libadmin: Fix isAlias may be uninitialized warning

The cfgutil_HostNameIsAlias() function has an output parameter called
isAlias, which is used when cfgutil_HostIsAlias() returns non-zero.
However, it possible for isAlias to not be set before returning. GCC 12
issues a warning about the possible use of the uninitialized isAlias
variable:

    cfginternal.c:366:32: error: ‘isAlias’ may be used uninitialized
       [-Werror=maybe-uninitialized]

Initialize the cfgutil_HostNameIsAlias() isAlias output flag to false.
Also, fix the misleading code indentation around the
cfgutil_HostNameIsAlias() call.

Reviewed-on: https://gerrit.openafs.org/14772
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 4a8d0c4089078fb3df9cc06b595c80c9b4c2ca7f)

Change-Id: I4cadcb4380962e47213fcfd310c1cac331100f65
---

diff --git a/src/libadmin/cfg/cfginternal.c b/src/libadmin/cfg/cfginternal.c
index 1f581b8..f1abacb 100644
--- a/src/libadmin/cfg/cfginternal.c
+++ b/src/libadmin/cfg/cfginternal.c
@@ -348,7 +348,7 @@
 		short dbhostFound = 0;
 
 		while (!dbhostDone) {
-		    short isAlias;
+		    short isAlias = 0;
 
 		    if (!bos_HostGetNext(dbIter, hostNameAlias, &tst2)) {
 			/* no more entries (or failure) */
@@ -357,15 +357,15 @@
 			}
 			dbhostDone = 1;
 
-		    } else
-			if (!cfgutil_HostNameIsAlias
-			    (hostName, hostNameAlias, &isAlias, &tst2)) {
-			tst = tst2;
-			dbhostDone = 1;
-
-		    } else if (isAlias) {
-			dbhostFound = 1;
-			dbhostDone = 1;
+		    } else {
+			if (!cfgutil_HostNameIsAlias(hostName, hostNameAlias,
+						     &isAlias, &tst2)) {
+			    tst = tst2;
+			    dbhostDone = 1;
+			} else if (isAlias) {
+			    dbhostFound = 1;
+			    dbhostDone = 1;
+			}
 		    }
 		}
 
From f641fc20693a565c8e3edc5a8dc8c857b213ab1a Mon Sep 17 00:00:00 2001
From: Michael Meffie <mmeffie@sinenomine.net>
Date: Fri, 03 Sep 2021 07:05:36 -0400
Subject: [PATCH] ptserver: Fix CreateEntry() stringop-overflow warnings

The CreateEntry() prototype has been fixed to match the function
definition, so callers are expected to provide bounded arrays for the
user or group name. Fix the InitialGroup() macro which is used to set
the built-in names using string literal to avoid stringop-overflow
warnings.

    error: ‘CreateEntry’ accessing 64 bytes in a region of size 22 [-Werror=stringop-overflow=]
            code = CreateEntry(tt, (name), &temp, /*idflag*/1, flag, SYSADMINID, SYSADMINID); \

    note: in expansion of macro ‘InitialGroup’
           InitialGroup(SYSADMINID, "system:administrators");
    note: referencing argument 2 of type ‘char *’
    note: in a call to function ‘CreateEntry’
            CreateEntry(struct ubik_trans *at, char aname[PR_MAXNAMELEN], ...

    (Repeated for "system:backup", "system:anyuser", "system:authuser",
    "system:ptsviewers", and "anonymous".)

Reviewed-on: https://gerrit.openafs.org/14789
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 7924aecf95bf4918a485a041f2426bd1fa407ac8)

Change-Id: I6e30729f1b24beb1ed1c4b6d9162b347285b7edc
---

diff --git a/src/ptserver/ptutils.c b/src/ptserver/ptutils.c
index c551c62..1a343fe 100644
--- a/src/ptserver/ptutils.c
+++ b/src/ptserver/ptutils.c
@@ -1847,8 +1847,15 @@
 #define InitialGroup(id,name) do {    \
     afs_int32 temp = (id);		      \
     afs_int32 flag = (id) < 0 ? PRGRP : 0; \
+    char tname[PR_MAXNAMELEN]; \
+    if (strlcpy(tname, (name), sizeof(tname)) >= sizeof(tname)) { \
+	code = PRBADNAM; \
+	afs_com_err (whoami, code, "name too long %s", (name)); \
+	ubik_AbortTrans(tt);	      \
+	return code;		      \
+    } \
     code = CreateEntry		      \
-	(tt, (name), &temp, /*idflag*/1, flag, SYSADMINID, SYSADMINID); \
+	(tt, tname, &temp, /*idflag*/1, flag, SYSADMINID, SYSADMINID); \
     if (code) {			      \
 	afs_com_err (whoami, code, "couldn't create %s with id %di.", 	\
 		 (name), (id));	      \
From 6520127044f1bfdb86410b2e2a3aa6b86d12d2a8 Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Wed, 10 Jul 2019 12:42:54 -0500
Subject: [PATCH] LINUX: Honor --enable-checking for libafs

When we build the kernel module on LINUX, we don't pass in any of our
CFLAGS, since the Linux buildsystem itself figures out what flags are
needed. However, this means that we don't pass in -Werror when
--enable-checking is turned on, so warnings may not cause the build to
fail.

To fix this, create a new autoconf variable, called CFLAGS_WERROR,
that only contains -Werror if --enable-checking is turned on. We then
pass that into the Linux module buildsystem, so -Werror is given to
the compiler when building our module.

Reviewed-on: https://gerrit.openafs.org/13682
Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 6e0f1c3b45102e7644d25cf34395ca980414317f)

[cwills@sinenomine.net] On master gerrit 14106 comes after this commit.
In the 1.8.x branch the 14106 commit is already pulled in (gerrit 14127)
which causes a conflict due a difference in the line above a change
from this commit.

Change-Id: I4e49d5c5fdf26399eb04d2f76196f3c3f4e7baf6
---

diff --git a/src/cf/osconf.m4 b/src/cf/osconf.m4
index c5ff784..5a1c1d0 100644
--- a/src/cf/osconf.m4
+++ b/src/cf/osconf.m4
@@ -673,6 +673,7 @@
   fi
   if test "x$enable_checking" != "xno"; then
     XCFLAGS="${XCFLAGS} -Wall -Wstrict-prototypes -Wold-style-definition -Werror -fdiagnostics-show-option -Wpointer-arith -fno-common"
+    CFLAGS_WERROR="-Werror"
     if test "x$enable_checking" != "xall"; then
       CFLAGS_NOERROR="-Wno-error"
       CFLAGS_NOUNUSED="-Wno-unused"
@@ -758,6 +759,7 @@
 AC_SUBST(CFLAGS_NOSTRICT)
 AC_SUBST(CFLAGS_NOUNUSED)
 AC_SUBST(CFLAGS_NOOLDSTYLE)
+AC_SUBST(CFLAGS_WERROR)
 AC_SUBST(XCFLAGS64)
 AC_SUBST(XLDFLAGS)
 AC_SUBST(XLDFLAGS64)
diff --git a/src/libafs/MakefileProto.LINUX.in b/src/libafs/MakefileProto.LINUX.in
index d98fa05..9bec631 100644
--- a/src/libafs/MakefileProto.LINUX.in
+++ b/src/libafs/MakefileProto.LINUX.in
@@ -125,7 +125,7 @@
 INCLUDES = -I. -I../ -I${TOP_OBJDIR}/src/config \
   -I${TOP_SRCDIR}/rx -I${TOP_OBJDIR}/src/rxstat
 
-CFLAGS = $(CCFLAGS) $(KERN_DBG) $(DEFINES) $(INCLUDES)
+CFLAGS = $(CCFLAGS) $(KERN_DBG) $(DEFINES) $(INCLUDES) @CFLAGS_WERROR@
 
 # Name of directory to hold object files and libraries.
 KOBJ = MODLOAD
From cb8132584e9d326c4fdbb3a4fda7683157555469 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 23 Jul 2020 15:43:42 -0600
Subject: [PATCH] clang-10: ignore fallthrough warning in generated code

Clang-10 will not recognize '/* fall through */' as an indicator to
turn off the fallthrough warning due to the lack of a 'break' in a case
statement.

Code generated by flex uses the '/* fall through */' comments to turn
off compiler warnings for fallthroughs in case statements.

For code generated by flex, ignore the implicit-fallthrough via pragma
or disable the warning via a compile time flag.

Add new env variable "CFLAGS_NOIMPLICIT_FALLTHROUGH" to selectively
disable the compile check in Makefiles when checking is enabled.

Reviewed-on: https://gerrit.openafs.org/14275
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
(cherry picked from commit e5f44f6e9af643cab3a66216dff901e0a4c5eda8)

Change-Id: Ibe1b95e6784ca8b422378cf2896bdc7f1a6d8e61
---

diff --git a/CODING b/CODING
index bac7490..bff3c92 100644
--- a/CODING
+++ b/CODING
@@ -317,7 +317,10 @@
 
 Inhibited warnings
 ------------------
-
+uss/lex.i            : fallthrough   : clang fallthrough, flex generated code
+comerr/et_lex.lex.l  : fallthrough   : clang fallthrough, flex generated code
+                                       pragma set to ignored where included in
+                                       error_table.y
 afs/afs_syscall.c    : old-style
 		     : strict-proto
 		     : all (ukernel) : syscall pointer issues
diff --git a/src/cf/osconf.m4 b/src/cf/osconf.m4
index 5a1c1d0..c67080d 100644
--- a/src/cf/osconf.m4
+++ b/src/cf/osconf.m4
@@ -665,6 +665,7 @@
 CFLAGS_NOSTRICT=-fno-strict-aliasing
 CFLAGS_NOUNUSED=
 CFLAGS_NOOLDSTYLE=
+CFLAGS_NOIMPLICIT_FALLTHROUGH=
 XCFLAGS_NOCHECKING="$XCFLAGS"
 
 if test "x$GCC" = "xyes"; then
@@ -678,6 +679,8 @@
       CFLAGS_NOERROR="-Wno-error"
       CFLAGS_NOUNUSED="-Wno-unused"
       CFLAGS_NOOLDSTYLE="-Wno-old-style-definition"
+      AX_APPEND_COMPILE_FLAGS([-Wno-implicit-fallthrough],
+                               [CFLAGS_NOIMPLICIT_FALLTHROUGH])
       AC_DEFINE(IGNORE_SOME_GCC_WARNINGS, 1, [define to disable some gcc warnings in warnings-as-errors mode])
     else
       CFLAGS_NOSTRICT=
@@ -759,6 +762,7 @@
 AC_SUBST(CFLAGS_NOSTRICT)
 AC_SUBST(CFLAGS_NOUNUSED)
 AC_SUBST(CFLAGS_NOOLDSTYLE)
+AC_SUBST(CFLAGS_NOIMPLICIT_FALLTHROUGH)
 AC_SUBST(CFLAGS_WERROR)
 AC_SUBST(XCFLAGS64)
 AC_SUBST(XLDFLAGS)
diff --git a/src/comerr/error_table.y b/src/comerr/error_table.y
index 05f524b..6690c65 100644
--- a/src/comerr/error_table.y
+++ b/src/comerr/error_table.y
@@ -389,6 +389,11 @@
         exit (1);
 }
 
+#if defined(IGNORE_SOME_GCC_WARNINGS) && defined(__clang__) && defined(HAVE_FUNC_ATTRIBUTE_FALLTHROUGH)
+/* flex generates fallthroughs in case blocks that get flagged by clang */
+# pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
+#endif
+
 #ifdef AFS_NT40_ENV
 #include "et_lex.lex_nt.c"
 #else
diff --git a/src/uss/Makefile.in b/src/uss/Makefile.in
index 7a5fe4f..aa1ddb7 100644
--- a/src/uss/Makefile.in
+++ b/src/uss/Makefile.in
@@ -48,7 +48,7 @@
 
 uss.o:  uss.c AFS_component_version_number.c
 
-CFLAGS_lex.yy.o = @CFLAGS_NOUNUSED@ @CFLAGS_NOOLDSTYLE@
+CFLAGS_lex.yy.o = @CFLAGS_NOUNUSED@ @CFLAGS_NOOLDSTYLE@ @CFLAGS_NOIMPLICIT_FALLTHROUGH@
 lex.yy.o : lex.yy.c y.tab.c
 
 lex.yy.c : lex.l
From fad9f47910f814d67a286bb529378315610386d3 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Fri, 27 Aug 2021 08:20:42 -0600
Subject: [PATCH] clang-13: remove unused variables flagged by clang

Clang-13 changed the default for the unused-but-set-variable resulting
in build warnings/errors with the following type of messages

vsprocs.c:3493:25: error: variable 'tentries' set but not used
    [-Werror,-Wunused-but-set-variable]
       afs_int32 nentries, tentries = 0;

The locations where these local variables are being flagged show that
while the variables are being updated, they are actually never used for
anything (e.g. used as part of an assignment to another variable, passed
as a parameter, used for as returned value, etc.)

Remove the variables being flagged by the clang-13 compiler.

Removal of these variables will not alter the overall functionality of
the code.

Reviewed-on: https://gerrit.openafs.org/14775
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit 8333e8e6020331013af912acb92a308e4f5a1dd2)

Change-Id: Id5e7c6a323e352106b8f6bf32b7163846c366dec
---

diff --git a/src/afs/VNOPS/afs_vnop_read.c b/src/afs/VNOPS/afs_vnop_read.c
index b5e341a..ffcbe68 100644
--- a/src/afs/VNOPS/afs_vnop_read.c
+++ b/src/afs/VNOPS/afs_vnop_read.c
@@ -46,7 +46,6 @@
 	 int noLock)
 {
     afs_size_t totalLength;
-    afs_size_t transferLength;
     afs_size_t filePos;
     afs_size_t offset, tlen;
     afs_size_t len = 0;
@@ -96,7 +95,6 @@
 	       totalLength, ICL_TYPE_OFFSET,
 	       ICL_HANDLE_OFFSET(avc->f.m.Length));
     error = 0;
-    transferLength = 0;
     if (!noLock)
 	ObtainReadLock(&avc->lock);
 #if	defined(AFS_TEXT_ENV) && !defined(AFS_VM_RDWR_ENV)
@@ -352,7 +350,6 @@
 	trimlen = len;
 	afsio_skip(auio, trimlen);	/* update input uio structure */
 	totalLength -= len;
-	transferLength += len;
 	filePos += len;
 
 	if (len <= 0)
diff --git a/src/afs/VNOPS/afs_vnop_write.c b/src/afs/VNOPS/afs_vnop_write.c
index 90ad86c..cf8e334 100644
--- a/src/afs/VNOPS/afs_vnop_write.c
+++ b/src/afs/VNOPS/afs_vnop_write.c
@@ -198,7 +198,6 @@
 	     afs_ucred_t *acred, int noLock)
 {
     afs_size_t totalLength;
-    afs_size_t transferLength;
     afs_size_t filePos;
     afs_size_t offset, len;
     afs_int32 tlen;
@@ -232,7 +231,6 @@
     totalLength = AFS_UIO_RESID(auio);
     filePos = AFS_UIO_OFFSET(auio);
     error = 0;
-    transferLength = 0;
     afs_Trace4(afs_iclSetp, CM_TRACE_WRITE, ICL_TYPE_POINTER, avc,
 	       ICL_TYPE_OFFSET, ICL_HANDLE_OFFSET(filePos), ICL_TYPE_OFFSET,
 	       ICL_HANDLE_OFFSET(totalLength), ICL_TYPE_OFFSET,
@@ -358,7 +356,6 @@
 		tdc->validPos = filePos + len;
 	}
 	totalLength -= len;
-	transferLength += len;
 	filePos += len;
 #if defined(AFS_SGI_ENV)
 	/* afs_xwrite handles setting m.Length */
diff --git a/src/libadmin/vos/vsprocs.c b/src/libadmin/vos/vsprocs.c
index c82c684..475b337 100644
--- a/src/libadmin/vos/vsprocs.c
+++ b/src/libadmin/vos/vsprocs.c
@@ -3490,7 +3490,7 @@
     int rc = 0;
     afs_status_t tst = 0;
     int noError;
-    afs_int32 nentries, tentries = 0;
+    afs_int32 nentries;
     struct VldbListByAttributes attributes;
     nbulkentries arrayEntries;
     int totalF;
@@ -3519,7 +3519,6 @@
 	    goto fail_UV_SyncServer;
 	}
 	nsi = -1;
-	tentries += nentries;
 	totalF = 0;
 	for (j = 0; j < nentries; j++) {	/* process each entry */
 	    vllist = &arrayEntries.nbulkentries_val[j];
diff --git a/src/ubik/disk.c b/src/ubik/disk.c
index ed2b55b..61e7078 100644
--- a/src/ubik/disk.c
+++ b/src/ubik/disk.c
@@ -680,11 +680,10 @@
 	   afs_int32 apos, afs_int32 alen)
 {
     char *bp;
-    afs_int32 offset, len, totalLen;
+    afs_int32 offset, len;
 
     if (atrans->flags & TRDONE)
 	return UDONE;
-    totalLen = 0;
     while (alen > 0) {
 	bp = DRead(atrans, afile, apos >> UBIK_LOGPAGESIZE);
 	if (!bp)
@@ -698,7 +697,6 @@
 	abuffer = (char *)abuffer + len;
 	apos += len;
 	alen -= len;
-	totalLen += len;
 	DRelease(bp, 0);
     }
     return 0;
@@ -746,7 +744,7 @@
 	    afs_int32 apos, afs_int32 alen)
 {
     char *bp;
-    afs_int32 offset, len, totalLen;
+    afs_int32 offset, len;
     struct ubik_trunc *tt;
     afs_int32 code;
 
@@ -769,7 +767,6 @@
     }
 
     /* now update vm */
-    totalLen = 0;
     while (alen > 0) {
 	bp = DRead(atrans, afile, apos >> UBIK_LOGPAGESIZE);
 	if (!bp) {
@@ -786,7 +783,6 @@
 	abuffer = (char *)abuffer + len;
 	apos += len;
 	alen -= len;
-	totalLen += len;
 	DRelease(bp, 1);	/* buffer modified */
     }
     return 0;
diff --git a/src/ubik/remote.c b/src/ubik/remote.c
index 70626cd..5493348 100644
--- a/src/ubik/remote.c
+++ b/src/ubik/remote.c
@@ -472,7 +472,6 @@
     afs_int32 code;
     struct ubik_dbase *dbase = NULL;
     char tbuffer[1024];
-    afs_int32 offset;
     struct ubik_version tversion;
     int tlen;
     struct rx_peer *tpeer;
@@ -526,7 +525,6 @@
     ViceLog(0, ("Ubik: Synchronize database: receive (via SendFile) from server %s begin\n",
 	       afs_inet_ntoa_r(otherHost, hoststr)));
 
-    offset = 0;
     UBIK_VERSION_LOCK;
     epoch = tversion.epoch = 0;		/* start off by labelling in-transit db as invalid */
     (*dbase->setlabel) (dbase, file, &tversion);	/* setlabel does sync */
@@ -570,7 +568,6 @@
 	    close(fd);
 	    goto failed;
 	}
-	offset += tlen;
 	length -= tlen;
     }
     code = close(fd);
From 8148e2d5d7d4ffcecae4179d9154ef52d151f0e0 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 27 Jan 2022 20:19:17 -0700
Subject: [PATCH] Linux-5.17: kernel func complete_and_exit renamed

Handle the Linux kernel function rename made in commit
 "exit: Rename complete_and_exit to kthread_complete_and_exit"
 (cead1855)

Add a new autoconf test for the linux function kthread_complete_and_exit
and if not found use a define to map kthread_complete_and_exit to
complete_and_exit.

Replace calls to complete_and_exit with kthread_complete_and_exit.

Reviewed-on: https://gerrit.openafs.org/14882
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
(cherry picked from commit a651d4db7f86a24ea6784f6f27d5c8482667267b)

Change-Id: Ibe96b92a84a8f876dda4019c221c37dabde93244
---

diff --git a/src/afs/LINUX/osi_compat.h b/src/afs/LINUX/osi_compat.h
index 726b655..53a079b 100644
--- a/src/afs/LINUX/osi_compat.h
+++ b/src/afs/LINUX/osi_compat.h
@@ -27,6 +27,10 @@
 # endif
 #endif
 
+#if !defined(HAVE_LINUX_KTHREAD_COMPLETE_AND_EXIT)
+# define kthread_complete_and_exit complete_and_exit
+#endif
+
 #if defined(STRUCT_DENTRY_OPERATIONS_HAS_D_AUTOMOUNT) && !defined(DCACHE_NEED_AUTOMOUNT)
 # define DCACHE_NEED_AUTOMOUNT DMANAGED_AUTOMOUNT
 #endif
diff --git a/src/afs/afs_call.c b/src/afs/afs_call.c
index 24df6aa..e75cce7 100644
--- a/src/afs/afs_call.c
+++ b/src/afs/afs_call.c
@@ -19,7 +19,9 @@
 #include "afs/afs_stats.h"
 #include "rx/rx_globals.h"
 #if !defined(UKERNEL)
-# if !defined(AFS_LINUX_ENV)
+# if defined(AFS_LINUX_ENV)
+#  include "osi_compat.h"
+# else
 #  include "net/if.h"
 #  ifdef AFS_SGI62_ENV
 #   include "h/hashing.h"
@@ -328,7 +330,7 @@
 	sprintf(current->comm, "afs_callback");
 	afs_RXCallBackServer();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
     case AFSOP_START_AFS:
 	sprintf(current->comm, "afs_afsstart");
@@ -342,7 +344,7 @@
 	sprintf(current->comm, "afsd");
 	afs_Daemon();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
     case AFSOP_START_BKG:
 #ifdef AFS_NEW_BKG
@@ -361,7 +363,7 @@
 	afs_BackgroundDaemon();
 	AFS_GUNLOCK();
 #endif
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
     case AFSOP_START_TRUNCDAEMON:
 	sprintf(current->comm, "afs_trimstart");
@@ -372,7 +374,7 @@
 	sprintf(current->comm, "afs_cachetrim");
 	afs_CacheTruncateDaemon();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
     case AFSOP_START_CS:
 	sprintf(current->comm, "afs_checkserver");
@@ -380,7 +382,7 @@
 	complete(arg->complete);
 	afs_CheckServerDaemon();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
     case AFSOP_RXEVENT_DAEMON:
 	sprintf(current->comm, "afs_evtstart");
@@ -398,7 +400,7 @@
 	sprintf(current->comm, "afs_rxevent");
 	afs_rxevent_daemon();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
 #ifdef RXK_LISTENER_ENV
     case AFSOP_RXLISTENER_DAEMON:
@@ -420,7 +422,7 @@
 	sprintf(current->comm, "afs_rxlistener");
 	rxk_Listener();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
 #endif
     default:
diff --git a/src/cf/linux-kernel-func.m4 b/src/cf/linux-kernel-func.m4
index 0ca3e44..cd4afe9 100644
--- a/src/cf/linux-kernel-func.m4
+++ b/src/cf/linux-kernel-func.m4
@@ -178,6 +178,12 @@
                     [#include <net/ip.h>],
                     [ip_sock_set_mtu_discover(NULL, 0);])
 
+dnl Linux 5.17 renamed complete_and_exit to kthread_complete_and_exit
+AC_CHECK_LINUX_FUNC([kthread_complete_and_exit],
+                    [#include <linux/kernel.h>
+                     #include <linux/kthread.h>],
+                    [kthread_complete_and_exit(0, 0);])
+
 dnl Consequences - things which get set as a result of the
 dnl                above tests
 AS_IF([test "x$ac_cv_linux_func_d_alloc_anon" = "xno"],
From dd996b738abf1b780a47b31ed463522fbe8e0401 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Fri, 28 Jan 2022 14:10:46 -0700
Subject: [PATCH] Linux-5.17: Kernel build uses -Wcast-function-type

The linux 5.17 commit:
  "Makefile: Enable -Wcast-function-type" (552a23a0)
added the -Wcast-function-type compiler flag for kernel module builds.

This change catches a type mismatch in the external files obtained from
heimdal: hcrypto/evp.c and hcrypto/evp-algs.c and produces the following
type of compile time error messages.

  src/libafs/MODLOAD-.../evp.c: In function ‘hc_EVP_md_null’:
  src/libafs/MODLOAD-.../evp.c:501:2: error: cast between incompatible
      function types from ‘void (*)(void *)’ to ‘int (*)(EVP_MD_CTX *)’
          {aka ‘int (*)(struct hc_EVP_MD_CTX *)’}
          [-Werror=cast-function-type]
  501 |  (hc_evp_md_init)null_Init,
      |  ^

Use AX_APPEND_COMPILE_FLAGS to create a CFLAGS_NOCAST_FUNCTION_TYPE
macro to disable this warning and update the CFLAGS for these 2 files
for the Linux libafs build.

Update the CODING documentation to add the new exceptions.  In addition
add a brief description on how to set up autoconf to add a new build
macro to suppress compiler warnings.

Note: upstream heimdal has committed a fix for this in:

   hcrypto: Fix return type for null_Init, null_Update and null_Final
   (fc4b3ce49b)

Reviewed-on: https://gerrit.openafs.org/14881
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
(cherry picked from commit 6bdfa976731ce07f3236893ecf12abb9e169b882)

Change-Id: Ibd354f663d5876c421a8b4e89b8943c9e3d59ebc
---

diff --git a/CODING b/CODING
index bff3c92..62c8218 100644
--- a/CODING
+++ b/CODING
@@ -306,7 +306,13 @@
   # endif
   #endif
 
-If a pragma isn't available for your particular warning, you will need to
+If the source cannot be changed to add a pragma, you might be abe to use the
+autoconf function AX_APPEND_COMPILE_FLAGS to create a new macro that disables
+the warning and then use macro for the build options for that file. For an
+example, see how the autoconf macro CFLAGS_NOIMPLICIT_FALLTHROUGH is defined and
+used.
+
+Finally if there isn't a way to disable the specific warning, you will need to
 disable all warnings for the file in question. You can do this by supplying
 the autoconf macro @CFLAGS_NOERROR@ in the build options for the file. For
 example:
@@ -332,6 +338,10 @@
 				     : signed vs unsigned for dates
 butc/tcudbprocs.c    : all	     : ubik_Call
 external/heimdal/hcrypto/validate.c: all: statement with empty body
+external/heimdal/hcrypto/evp.c:      cast-function-type
+             : Linux kernel build uses -Wcast-function-type
+external/heimdal/hcrypto/evp-algs.c: cast-function-type
+             : Linux kernel build uses -Wcast-function-type
 kauth/admin_tools.c  : strict-proto  : ubik_Call
 kauth/authclient.c   : strict-proto  : ubik_Call nonsense
 libadmin/kas/afs_kasAdmin.c: strict-proto : ubik_Call nonsense
diff --git a/src/cf/osconf.m4 b/src/cf/osconf.m4
index c67080d..2751213 100644
--- a/src/cf/osconf.m4
+++ b/src/cf/osconf.m4
@@ -666,6 +666,7 @@
 CFLAGS_NOUNUSED=
 CFLAGS_NOOLDSTYLE=
 CFLAGS_NOIMPLICIT_FALLTHROUGH=
+CFLAGS_NOCAST_FUNCTION_TYPE=
 XCFLAGS_NOCHECKING="$XCFLAGS"
 
 if test "x$GCC" = "xyes"; then
@@ -681,6 +682,8 @@
       CFLAGS_NOOLDSTYLE="-Wno-old-style-definition"
       AX_APPEND_COMPILE_FLAGS([-Wno-implicit-fallthrough],
                                [CFLAGS_NOIMPLICIT_FALLTHROUGH])
+      AX_APPEND_COMPILE_FLAGS([-Wno-cast-function-type],
+                              [CFLAGS_NOCAST_FUNCTION_TYPE])
       AC_DEFINE(IGNORE_SOME_GCC_WARNINGS, 1, [define to disable some gcc warnings in warnings-as-errors mode])
     else
       CFLAGS_NOSTRICT=
@@ -763,6 +766,7 @@
 AC_SUBST(CFLAGS_NOUNUSED)
 AC_SUBST(CFLAGS_NOOLDSTYLE)
 AC_SUBST(CFLAGS_NOIMPLICIT_FALLTHROUGH)
+AC_SUBST(CFLAGS_NOCAST_FUNCTION_TYPE)
 AC_SUBST(CFLAGS_WERROR)
 AC_SUBST(XCFLAGS64)
 AC_SUBST(XLDFLAGS)
diff --git a/src/libafs/MakefileProto.LINUX.in b/src/libafs/MakefileProto.LINUX.in
index 9bec631..c8b0720 100644
--- a/src/libafs/MakefileProto.LINUX.in
+++ b/src/libafs/MakefileProto.LINUX.in
@@ -79,8 +79,9 @@
 CFLAGS_opr_rbtree.o = -I${TOP_SRCDIR}/opr
 
 CFLAGS_evp.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto \
-	       -DHAVE_CONFIG_H
-CFLAGS_evp-algs.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto
+	       -DHAVE_CONFIG_H @CFLAGS_NOCAST_FUNCTION_TYPE@
+CFLAGS_evp-algs.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto \
+	       @CFLAGS_NOCAST_FUNCTION_TYPE@
 CFLAGS_evp-kernel.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto
 CFLAGS_rand-timer-kernel.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto
 CFLAGS_rand-kernel.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto
From 4ab70de9641807bd06056f0c1ac79550453b9574 Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Thu, 28 Jun 2018 12:50:52 -0500
Subject: [PATCH] afs: Make afs_AllocDCache static

Nothing using afs_AllocDCache outside of afs_dcache.c. Declare the
function static, to ensure that nobody else uses it, and to maybe
allow for more compiler optimization.

Change-Id: I4e4d1e77e20e853fc20b3d5c5289a5f4124de7a4
Reviewed-on: https://gerrit.openafs.org/13226
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/afs/afs_dcache.c b/src/afs/afs_dcache.c
index 303bfca..4be5b59 100644
--- a/src/afs/afs_dcache.c
+++ b/src/afs/afs_dcache.c
@@ -1647,7 +1647,7 @@
  *
  * \return The new dcache.
  */
-struct dcache *
+static struct dcache *
 afs_AllocDCache(struct vcache *avc, afs_int32 chunk, afs_int32 lock,
 		struct VenusFid *ashFid)
 {
From 0322dd56b20b2e2fd6eb7f217964174fb5d25cdd Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Thu, 28 Jun 2018 13:08:47 -0500
Subject: [PATCH] afs: Change afs_AllocDCache to return error codes

Currently, afs_AllocDCache can fail in 2 different situations:

- When we are out of dslots on the free/discard lists
- When we encounter an i/o error when trying to traverse the dslot
  lists

But afs_AllocDCache cannot distinguish between these two cases to its
caller in any way, since all we have to return is a struct dcache (and
so we return NULL on any error).

Currently, the caller of afs_AllocDCache in afs_GetDCache is
determining which of these cases happened by looking at
afs_discardDCList and afs_freeDCList, to see if they look empty. This
is not great for at least a couple of reasons:

- We are examining afs_discardDCList/afs_freeDCList after we drop
  afs_xdcache (but while still holding GLOCK)

- If afs_discardDCList/afs_freeDCList are somehow changed while
  afs_AllocDCache is running, we may infer the wrong reason why
  afs_AllocDCache failed. (currently impossible, but this seems
  fragile)

And in general, this check against afs_discardDCList/afs_freeDCList is
rather indirect. It may be easier to follow if afs_AllocDCache just
directly returned the reason why it failed.

So do that, by changing afs_AllocDCache to return an error code, and
providing the struct dcache in an output argument. This involves
similiarly changing several called functions in the same way, to
return error codes. We only define 2 such error codes with this
commit:

- ENOSPC, when we are out of free/discrad dslots
- EIO, when we encounter a disk i/o error when trying to examine the
  dslot list

Note that this commit should not change any real logic; we're mostly
just changing how errors are returned from these various functions.

Change-Id: I07cc3d7befdcc98360889f4a2ba01fdc9de50848
Reviewed-on: https://gerrit.openafs.org/13227
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/afs/afs_dcache.c b/src/afs/afs_dcache.c
index 4be5b59..3c437bd 100644
--- a/src/afs/afs_dcache.c
+++ b/src/afs/afs_dcache.c
@@ -1121,29 +1121,39 @@
 /**
  * Get a dcache entry from the discard or free list
  *
+ * @param[out] adc    On success, a dcache from the given list. Otherwise, NULL.
  * @param[in] indexp  A pointer to the head of the dcache free list or discard
  *                    list (afs_freeDCList, or afs_discardDCList)
  *
- * @return A dcache from that list, or NULL if none could be retrieved.
+ * @return 0 on success. If there are no dcache slots available, return ENOSPC.
+ *         If we encountered an error in disk i/o while trying to find a
+ *         dcache, return EIO.
  *
  * @pre afs_xdcache is write-locked
  */
-static struct dcache *
-afs_GetDSlotFromList(afs_int32 *indexp)
+static int
+afs_GetDSlotFromList(struct dcache **adc, afs_int32 *indexp)
 {
     struct dcache *tdc;
 
-    if (*indexp != NULLIDX) {
-	tdc = afs_GetUnusedDSlot(*indexp);
-	if (tdc) {
-	    osi_Assert(tdc->refCount == 1);
-	    ReleaseReadLock(&tdc->tlock);
-	    *indexp = afs_dvnextTbl[tdc->index];
-	    afs_dvnextTbl[tdc->index] = NULLIDX;
-	    return tdc;
-	}
+    *adc = NULL;
+
+    if (*indexp == NULLIDX) {
+        return ENOSPC;
     }
-    return NULL;
+
+    tdc = afs_GetUnusedDSlot(*indexp);
+    if (tdc == NULL) {
+        return EIO;
+    }
+
+    osi_Assert(tdc->refCount == 1);
+    ReleaseReadLock(&tdc->tlock);
+    *indexp = afs_dvnextTbl[tdc->index];
+    afs_dvnextTbl[tdc->index] = NULLIDX;
+
+    *adc = tdc;
+    return 0;
 }
 
 /*!
@@ -1170,7 +1180,7 @@
     /*
      * Get an entry from the list of discarded cache elements
      */
-    tdc = afs_GetDSlotFromList(&afs_discardDCList);
+    (void)afs_GetDSlotFromList(&tdc, &afs_discardDCList);
     if (!tdc) {
 	ReleaseWriteLock(&afs_xdcache);
 	return -1;
@@ -1583,31 +1593,34 @@
 }				/*afs_FindDCache */
 
 /* only call these from afs_AllocDCache() */
-static struct dcache *
-afs_AllocFreeDSlot(void)
+static int
+afs_AllocFreeDSlot(struct dcache **adc)
 {
+    int code;
     struct dcache *tdc;
 
-    tdc = afs_GetDSlotFromList(&afs_freeDCList);
-    if (!tdc) {
-	return NULL;
+    code = afs_GetDSlotFromList(&tdc, &afs_freeDCList);
+    if (code) {
+	return code;
     }
     afs_indexFlags[tdc->index] &= ~IFFree;
     ObtainWriteLock(&tdc->lock, 604);
     afs_freeDCCount--;
 
-    return tdc;
+    *adc = tdc;
+    return 0;
 }
-static struct dcache *
-afs_AllocDiscardDSlot(afs_int32 lock)
+static int
+afs_AllocDiscardDSlot(struct dcache **adc, afs_int32 lock)
 {
+    int code;
     struct dcache *tdc;
     afs_uint32 size = 0;
     struct osi_file *file;
 
-    tdc = afs_GetDSlotFromList(&afs_discardDCList);
-    if (!tdc) {
-	return NULL;
+    code = afs_GetDSlotFromList(&tdc, &afs_discardDCList);
+    if (code) {
+	return code;
     }
     afs_indexFlags[tdc->index] &= ~IFDiscarded;
     ObtainWriteLock(&tdc->lock, 605);
@@ -1628,12 +1641,14 @@
 	afs_AdjustSize(tdc, 0);
     }
 
-    return tdc;
+    *adc = tdc;
+    return 0;
 }
 
 /*!
  * Get a fresh dcache from the free or discarded list.
  *
+ * \param adc Set to the new dcache on success, and NULL on error.
  * \param avc Who's dcache is this going to be?
  * \param chunk The position where it will be placed in.
  * \param lock How are locks held.
@@ -1645,29 +1660,34 @@
  * 	- avc (R if (lock & 1) set and W otherwise)
  * \note It write locks the new dcache. The caller must unlock it.
  *
- * \return The new dcache.
+ * \return If we're out of dslots, ENOSPC. If we encountered disk errors, EIO.
+ *         On success, return 0.
  */
-static struct dcache *
-afs_AllocDCache(struct vcache *avc, afs_int32 chunk, afs_int32 lock,
-		struct VenusFid *ashFid)
+static int
+afs_AllocDCache(struct dcache **adc, struct vcache *avc, afs_int32 chunk,
+                afs_int32 lock, struct VenusFid *ashFid)
 {
+    int code;
     struct dcache *tdc = NULL;
 
+    *adc = NULL;
+
     /* if (lock & 2), prefer 'free' dcaches; otherwise, prefer 'discard'
-     * dcaches. In either case, try both if our first choice doesn't work. */
+     * dcaches. In either case, try both if our first choice doesn't work due
+     * to ENOSPC. */
     if ((lock & 2)) {
-	tdc = afs_AllocFreeDSlot();
-	if (!tdc) {
-	    tdc = afs_AllocDiscardDSlot(lock);
+	code = afs_AllocFreeDSlot(&tdc);
+	if (code == ENOSPC) {
+	    code = afs_AllocDiscardDSlot(&tdc, lock);
 	}
     } else {
-	tdc = afs_AllocDiscardDSlot(lock);
-	if (!tdc) {
-	    tdc = afs_AllocFreeDSlot();
+	code = afs_AllocDiscardDSlot(&tdc, lock);
+	if (code == ENOSPC) {
+	    code = afs_AllocFreeDSlot(&tdc);
 	}
     }
-    if (!tdc) {
-	return NULL;
+    if (code) {
+	return code;
     }
 
     /*
@@ -1704,7 +1724,8 @@
     if (tdc->lruq.prev == &tdc->lruq)
 	osi_Panic("lruq 1");
 
-    return tdc;
+    *adc = tdc;
+    return 0;
 }
 
 /*
@@ -1972,10 +1993,10 @@
 		if (!setLocks)
 		    avc->f.states &= ~CDCLock;
 	    }
-	    tdc = afs_AllocDCache(avc, chunk, aflags, NULL);
-	    if (!tdc) {
+	    code = afs_AllocDCache(&tdc, avc, chunk, aflags, NULL);
+	    if (code) {
 		ReleaseWriteLock(&afs_xdcache);
-                if (afs_discardDCList == NULLIDX && afs_freeDCList == NULLIDX) {
+                if (code == ENOSPC) {
                     /* It looks like afs_AllocDCache failed because we don't
                      * have any free dslots to use. Maybe if we wait a little
                      * while, we'll be able to free up some slots, so try for 5
@@ -3621,7 +3642,7 @@
     ObtainWriteLock(&afs_xdcache, 716);
 
     /* Get a fresh dcache. */
-    new_dc = afs_AllocDCache(avc, 0, 0, &shadow_fid);
+    (void)afs_AllocDCache(&new_dc, avc, 0, 0, &shadow_fid);
     osi_Assert(new_dc);
 
     ObtainReadLock(&adc->mflock);
From 0d8ce846ab2e6c45166a61f04eb3af271cbd27db Mon Sep 17 00:00:00 2001
From: Andrew Deason <adeason@sinenomine.net>
Date: Thu, 17 Jan 2019 15:45:36 -0600
Subject: [PATCH] afs: Introduce afs_IsDCacheFresh

Numerous places in libafs check the DV of a dcache against the DV of
the vcache for the same file, in order to check if the dcache is up to
date and can be used. Consolidate all of these checks into a new
function, afs_IsDCacheFresh, to make it easier for future commits to
alter this logic.

This commit should have no visible impact; it is just code
reorganization.

Change-Id: Iedc02b0f5d7d0542ab00ff1effdde03c2a851df4
Reviewed-on: https://gerrit.openafs.org/13435
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: Andrew Deason <adeason@sinenomine.net>
---

diff --git a/src/afs/LINUX/osi_export.c b/src/afs/LINUX/osi_export.c
index a3175b5..926bd0d 100644
--- a/src/afs/LINUX/osi_export.c
+++ b/src/afs/LINUX/osi_export.c
@@ -349,7 +349,7 @@
      */
     while ((adp->f.states & CStatd)
 	   && (tdc->dflags & DFFetching)
-	   && hsame(adp->f.m.DataVersion, tdc->f.versionNo)) {
+	   && afs_IsDCacheFresh(tdc, adp)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseSharedLock(&adp->lock);
 	afs_osi_Sleep(&tdc->validPos);
@@ -357,7 +357,7 @@
 	ObtainReadLock(&tdc->lock);
     }
     if (!(adp->f.states & CStatd)
-	|| !hsame(adp->f.m.DataVersion, tdc->f.versionNo)) {
+	|| !afs_IsDCacheFresh(tdc, adp)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseSharedLock(&adp->lock);
 	afs_PutDCache(tdc);
@@ -770,7 +770,7 @@
      */
     while ((vcp->f.states & CStatd)
 	   && (tdc->dflags & DFFetching)
-	   && hsame(vcp->f.m.DataVersion, tdc->f.versionNo)) {
+	   && afs_IsDCacheFresh(tdc, vcp)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseReadLock(&vcp->lock);
 	afs_osi_Sleep(&tdc->validPos);
@@ -778,7 +778,7 @@
 	ObtainReadLock(&tdc->lock);
     }
     if (!(vcp->f.states & CStatd)
-	|| !hsame(vcp->f.m.DataVersion, tdc->f.versionNo)) {
+	|| !afs_IsDCacheFresh(tdc, vcp)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseReadLock(&vcp->lock);
 	afs_PutDCache(tdc);
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index e3422ca..cfb8743 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -368,7 +368,7 @@
      */
     while ((avc->f.states & CStatd)
 	   && (tdc->dflags & DFFetching)
-	   && hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	   && afs_IsDCacheFresh(tdc, avc)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseWriteLock(&avc->lock);
 	afs_osi_Sleep(&tdc->validPos);
@@ -376,7 +376,7 @@
 	ObtainReadLock(&tdc->lock);
     }
     if (!(avc->f.states & CStatd)
-	|| !hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	|| !afs_IsDCacheFresh(tdc, avc)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseWriteLock(&avc->lock);
 	afs_PutDCache(tdc);
@@ -2256,7 +2256,7 @@
 	ObtainReadLock(&tdc->lock);
 
     /* Is the dcache we've been given currently up to date */
-    if (!hsame(avc->f.m.DataVersion, tdc->f.versionNo) ||
+    if (!afs_IsDCacheFresh(tdc, avc) ||
 	(tdc->dflags & DFFetching))
 	goto out;
 
@@ -2687,7 +2687,7 @@
 	    AFS_GLOCK();
 	    if ((tdc = afs_FindDCache(avc, offset))) {
 		ObtainReadLock(&tdc->lock);
-		if (!hsame(avc->f.m.DataVersion, tdc->f.versionNo) ||
+		if (!afs_IsDCacheFresh(tdc, avc) ||
 		    (tdc->dflags & DFFetching)) {
 		    ReleaseReadLock(&tdc->lock);
 		    afs_PutDCache(tdc);
diff --git a/src/afs/SOLARIS/osi_vnodeops.c b/src/afs/SOLARIS/osi_vnodeops.c
index 361a0e5..e2cedf0 100644
--- a/src/afs/SOLARIS/osi_vnodeops.c
+++ b/src/afs/SOLARIS/osi_vnodeops.c
@@ -350,7 +350,7 @@
 
     /* Check to see whether the cache entry is still valid */
     if (!(avc->f.states & CStatd)
-	|| !hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	|| !afs_IsDCacheFresh(tdc, avc)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseReadLock(&avc->lock);
 	afs_PutDCache(tdc);
@@ -886,12 +886,12 @@
 		AFS_GLOCK();
 		dcp_newpage = afs_FindDCache(avc, pageBase);
 		if (dcp_newpage
-		    && hsame(avc->f.m.DataVersion, dcp_newpage->f.versionNo)) {
+		    && afs_IsDCacheFresh(dcp_newpage, avc)) {
 		    ObtainWriteLock(&avc->lock, 251);
 		    ObtainWriteLock(&avc->vlock, 576);
 		    ObtainReadLock(&dcp_newpage->lock);
 		    if ((avc->activeV == 0)
-			&& hsame(avc->f.m.DataVersion, dcp_newpage->f.versionNo)
+			&& afs_IsDCacheFresh(dcp_newpage, avc)
 			&& !(dcp_newpage->dflags & (DFFetching))) {
 			AFS_GUNLOCK();
 			segmap_pagecreate(segkmap, raddr, rsize, 1);
diff --git a/src/afs/VNOPS/afs_vnop_create.c b/src/afs/VNOPS/afs_vnop_create.c
index c4d7c70..6d1df4f 100644
--- a/src/afs/VNOPS/afs_vnop_create.c
+++ b/src/afs/VNOPS/afs_vnop_create.c
@@ -149,7 +149,7 @@
      * received a callback while we were waiting for the write lock.
      */
     if (!(adp->f.states & CStatd)
-	|| (tdc && !hsame(adp->f.m.DataVersion, tdc->f.versionNo))) {
+	|| (tdc && !afs_IsDCacheFresh(tdc, adp))) {
 	ReleaseWriteLock(&adp->lock);
 	if (tdc) {
 	    ReleaseSharedLock(&tdc->lock);
@@ -543,7 +543,7 @@
     if (adc) {
 	/* does what's in the dcache *now* match what's in the vcache *now*,
 	 * and do we have a valid callback? if not, our local copy is not "ok" */
-	ok = (hsame(avc->f.m.DataVersion, adc->f.versionNo) && avc->callback
+	ok = (afs_IsDCacheFresh(adc, avc) && avc->callback
 	      && (avc->f.states & CStatd) && avc->cbExpires >= osi_Time());
     } else {
 	ok = 0;
diff --git a/src/afs/VNOPS/afs_vnop_lookup.c b/src/afs/VNOPS/afs_vnop_lookup.c
index 08ad2af..8146957 100644
--- a/src/afs/VNOPS/afs_vnop_lookup.c
+++ b/src/afs/VNOPS/afs_vnop_lookup.c
@@ -773,7 +773,7 @@
      */
     while ((adp->f.states & CStatd)
 	   && (dcp->dflags & DFFetching)
-	   && hsame(adp->f.m.DataVersion, dcp->f.versionNo)) {
+	   && afs_IsDCacheFresh(dcp, adp)) {
 	afs_Trace4(afs_iclSetp, CM_TRACE_DCACHEWAIT, ICL_TYPE_STRING,
 		   __FILE__, ICL_TYPE_INT32, __LINE__, ICL_TYPE_POINTER, dcp,
 		   ICL_TYPE_INT32, dcp->dflags);
@@ -784,7 +784,7 @@
 	ObtainReadLock(&dcp->lock);
     }
     if (!(adp->f.states & CStatd)
-	|| !hsame(adp->f.m.DataVersion, dcp->f.versionNo)) {
+	|| !afs_IsDCacheFresh(dcp, adp)) {
 	ReleaseReadLock(&dcp->lock);
 	ReleaseReadLock(&adp->lock);
 	afs_PutDCache(dcp);
@@ -1643,7 +1643,7 @@
 	if (!afs_InReadDir(adp)) {
 	    while ((adp->f.states & CStatd)
 		   && (tdc->dflags & DFFetching)
-		   && hsame(adp->f.m.DataVersion, tdc->f.versionNo)) {
+		   && afs_IsDCacheFresh(tdc, adp)) {
 		ReleaseReadLock(&tdc->lock);
 		ReleaseReadLock(&adp->lock);
 		afs_osi_Sleep(&tdc->validPos);
@@ -1651,7 +1651,7 @@
 		ObtainReadLock(&tdc->lock);
 	    }
 	    if (!(adp->f.states & CStatd)
-		|| !hsame(adp->f.m.DataVersion, tdc->f.versionNo)) {
+		|| !afs_IsDCacheFresh(tdc, adp)) {
 		ReleaseReadLock(&tdc->lock);
 		ReleaseReadLock(&adp->lock);
 		afs_PutDCache(tdc);
diff --git a/src/afs/VNOPS/afs_vnop_read.c b/src/afs/VNOPS/afs_vnop_read.c
index 1b1c682..369d60b 100644
--- a/src/afs/VNOPS/afs_vnop_read.c
+++ b/src/afs/VNOPS/afs_vnop_read.c
@@ -190,7 +190,7 @@
 	     * 2 requests never return a null dcache entry, btw.
 	     */
 	    if (!(tdc->dflags & DFFetching)
-		&& !hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+		&& !afs_IsDCacheFresh(tdc, avc)) {
 		/* have cache entry, it is not coming in now,
 		 * and we'll need new data */
 	      tagain:
@@ -270,7 +270,7 @@
 	    } else {
 		/* no longer fetching, verify data version 
 		 * (avoid new GetDCache call) */
-		if (hsame(avc->f.m.DataVersion, tdc->f.versionNo)
+		if (afs_IsDCacheFresh(tdc, avc)
 		    && ((len = tdc->validPos - filePos) > 0)) {
 		    offset = filePos - AFS_CHUNKTOBASE(tdc->f.chunk);
 		} else {
diff --git a/src/afs/VNOPS/afs_vnop_readdir.c b/src/afs/VNOPS/afs_vnop_readdir.c
index 9efe8eb..7bfc629 100644
--- a/src/afs/VNOPS/afs_vnop_readdir.c
+++ b/src/afs/VNOPS/afs_vnop_readdir.c
@@ -692,7 +692,7 @@
      */
     while ((avc->f.states & CStatd)
 	   && (tdc->dflags & DFFetching)
-	   && hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	   && afs_IsDCacheFresh(tdc, avc)) {
 	afs_Trace4(afs_iclSetp, CM_TRACE_DCACHEWAIT, ICL_TYPE_STRING,
 		   __FILE__, ICL_TYPE_INT32, __LINE__, ICL_TYPE_POINTER, tdc,
 		   ICL_TYPE_INT32, tdc->dflags);
@@ -703,7 +703,7 @@
 	ObtainReadLock(&tdc->lock);
     }
     if (!(avc->f.states & CStatd)
-	|| !hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	|| !afs_IsDCacheFresh(tdc, avc)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseReadLock(&avc->lock);
 	afs_PutDCache(tdc);
diff --git a/src/afs/VNOPS/afs_vnop_remove.c b/src/afs/VNOPS/afs_vnop_remove.c
index f1e1faf..a563652 100644
--- a/src/afs/VNOPS/afs_vnop_remove.c
+++ b/src/afs/VNOPS/afs_vnop_remove.c
@@ -235,7 +235,7 @@
      * received a callback while we were waiting for the write lock.
      */
     if (!(adp->f.states & CStatd)
-	|| (tdc && !hsame(adp->f.m.DataVersion, tdc->f.versionNo))) {
+	|| (tdc && !afs_IsDCacheFresh(tdc, adp))) {
 	ReleaseWriteLock(&adp->lock);
 	if (tdc) {
 	    ReleaseSharedLock(&tdc->lock);
diff --git a/src/afs/VNOPS/afs_vnop_rename.c b/src/afs/VNOPS/afs_vnop_rename.c
index 2d4b9c1..fcf2bcb 100644
--- a/src/afs/VNOPS/afs_vnop_rename.c
+++ b/src/afs/VNOPS/afs_vnop_rename.c
@@ -135,7 +135,7 @@
      */
     if (tdc1) {
 	if (!(aodp->f.states & CStatd)
-	    || !hsame(aodp->f.m.DataVersion, tdc1->f.versionNo)) {
+	    || !afs_IsDCacheFresh(tdc1, aodp)) {
 
 	    ReleaseWriteLock(&aodp->lock);
 	    if (!oneDir) {
diff --git a/src/afs/afs_dcache.c b/src/afs/afs_dcache.c
index 15e63ff..c6a3bfb 100644
--- a/src/afs/afs_dcache.c
+++ b/src/afs/afs_dcache.c
@@ -1737,6 +1737,24 @@
     return 0;
 }
 
+/*!
+ * Check if a dcache is "fresh". That is, if the dcache's DV matches the DV of
+ * the vcache for that file.
+ *
+ * \param adc The dcache to check
+ * \param avc The vcache for adc
+ *
+ * \return 1 if the dcache does match avc's DV; 0 otherwise.
+ */
+int
+afs_IsDCacheFresh(struct dcache *adc, struct vcache *avc)
+{
+    if (!hsame(adc->f.versionNo, avc->f.m.DataVersion)) {
+	return 0;
+    }
+    return 1;
+}
+
 /*
  * afs_GetDCache
  *
@@ -1775,7 +1793,7 @@
 updateV2DC(int lockVc, struct vcache *v, struct dcache *d, int src)
 {
     if (!lockVc || 0 == NBObtainWriteLock(&v->lock, src)) {
-	if (hsame(v->f.m.DataVersion, d->f.versionNo) && v->callback)
+	if (afs_IsDCacheFresh(d, v) && v->callback)
 	    v->dchint = d;
 	if (lockVc)
 	    ReleaseWriteLock(&v->lock);
@@ -1885,7 +1903,7 @@
 	    ReleaseReadLock(&afs_xdcache);
 	    shortcut = 1;
 
-	    if (hsame(tdc->f.versionNo, avc->f.m.DataVersion)
+	    if (afs_IsDCacheFresh(tdc, avc)
 		&& !(tdc->dflags & DFFetching)) {
 
 		afs_stats_cmperf.dcacheHits++;
@@ -2122,7 +2140,7 @@
 	if (AFS_CHUNKTOBASE(chunk) >= avc->f.m.Length &&
 #endif
 #endif /* defined(AFS_AIX32_ENV) || defined(AFS_SGI_ENV) */
-	    !hsame(avc->f.m.DataVersion, tdc->f.versionNo))
+	    !afs_IsDCacheFresh(tdc, avc))
 	    doReallyAdjustSize = 1;
 
 	if (doReallyAdjustSize || overWriteWholeChunk) {
@@ -2186,7 +2204,7 @@
      * avc->lock(W) if !setLocks || slowPass
      * tdc->lock(S)
      */
-    if (!hsame(avc->f.m.DataVersion, tdc->f.versionNo) && !overWriteWholeChunk) {
+    if (!afs_IsDCacheFresh(tdc, avc) && !overWriteWholeChunk) {
 	/*
 	 * Version number mismatch.
 	 */
@@ -2256,7 +2274,7 @@
 	 */
 
 	/* Watch for standard race condition around osi_FlushText */
-	if (hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	if (afs_IsDCacheFresh(tdc, avc)) {
 	    updateV2DC(setLocks, avc, tdc, 569);	/* set hint */
 	    afs_stats_cmperf.dcacheHits++;
 	    ConvertWToSLock(&tdc->lock);
@@ -3575,7 +3593,7 @@
 	tdc = afs_FindDCache(avc, filePos);
 	if (tdc) {
 	    ObtainWriteLock(&tdc->lock, 658);
-	    if (!hsame(tdc->f.versionNo, avc->f.m.DataVersion)
+	    if (!afs_IsDCacheFresh(tdc, avc)
 		|| (tdc->dflags & DFFetching)) {
 		ReleaseWriteLock(&tdc->lock);
 		afs_PutDCache(tdc);
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index 615b0bf..d5ecb25 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -288,6 +288,7 @@
 						 int noLock);
 extern void afs_PopulateDCache(struct vcache *avc, afs_size_t apos,
 			       struct vrequest *areq);
+extern int afs_IsDCacheFresh(struct dcache *adc, struct vcache *avc);
 
 /* afs_disconnected.c */
 
From af73b9a3b1fc625694807287c0897391feaad52d Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 02 Jul 2020 13:39:27 -0600
Subject: [PATCH] LINUX: Don't panic on some file open errors

Commit 'LINUX: Return NULL for afs_linux_raw_open error' (f6af4a155)
updated afs_linux_raw_open to return NULL on some errors, but still
panics if obtaining the dentry fails.

Commit 'afs: Verify osi_UFSOpen worked' (c6b61a451) updated callers of
osi_UFSOpen to verify whether or not the open was successful.  This
meant osi_UFSOpen (and routines it calls) could pass back an error
indication rather than panic when an error is encountered.

Update afs_linux_raw_open to return a failure instead of panic if unable
to obtain a dentry.

Update osi_UFSOpen to return a NULL instead of panic if unable to obtain
memory or fails to open the file. All callers of osi_UFSOpen handle a
fail return, though some will still issue a panic.

Update afs_linux_readpage_fastpath and afs_linux_readpages to not panic
if afs_linux_raw_open fails.  Instead of panic, return an error.

For testing, an error can be forced by removing a file from the
cache directory.

Note this work is based on a commit by pruiter@sinenomine.net

Change-Id: Ic47e4868b4f81d99fbe3b2e4958778508ae4851f
Reviewed-on: https://gerrit.openafs.org/14242
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Mark Vitale <mvitale@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
---

diff --git a/src/afs/LINUX/osi_file.c b/src/afs/LINUX/osi_file.c
index e2218ad..42d49ef 100644
--- a/src/afs/LINUX/osi_file.c
+++ b/src/afs/LINUX/osi_file.c
@@ -65,8 +65,12 @@
 
     dp = afs_get_dentry_from_fh(afs_cacheSBp, ainode, cache_fh_len, cache_fh_type,
 		afs_fh_acceptable);
-    if ((!dp) || IS_ERR(dp))
-           osi_Panic("Can't get dentry\n");
+    if ((!dp) || IS_ERR(dp)) {
+	   afs_warn("afs: Cannot get dentry for cache file (code %d). Trying to continue, "
+		    "but AFS accesses may return errors or panic the system\n",
+		    (int) PTR_ERR(dp));
+	   return NULL;
+    }
     tip = dp->d_inode;
     tip->i_flags |= S_NOATIME;	/* Disable updating access times. */
 
@@ -114,8 +118,11 @@
     AFS_GUNLOCK();
     afile = kmalloc(sizeof(struct osi_file), GFP_NOFS);
     if (!afile) {
-	osi_Panic("osi_UFSOpen: Failed to allocate %d bytes for osi_file.\n",
-		  (int)sizeof(struct osi_file));
+	afs_warn("afs: Failed to allocate memory for opening a cache file. "
+		 "Trying to continue, but AFS access may return errors or panic "
+		 "the system\n");
+	AFS_GLOCK();
+	return NULL;
     }
     memset(afile, 0, sizeof(struct osi_file));
 
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index c32b280..cab5fcc 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -2333,7 +2333,11 @@
     /* XXX - I suspect we should be locking the inodes before we use them! */
     AFS_GUNLOCK();
     cacheFp = afs_linux_raw_open(&tdc->f.inode);
-    osi_Assert(cacheFp);
+    if (cacheFp == NULL) {
+	/* Problem getting the inode */
+	AFS_GLOCK();
+	goto out;
+    }
     if (!cacheFp->f_dentry->d_inode->i_mapping->a_ops->readpage) {
 	cachefs_noreadpage = 1;
 	AFS_GLOCK();
@@ -2726,8 +2730,10 @@
 	    afs_PutDCache(tdc);
 	    AFS_GUNLOCK();
 	    tdc = NULL;
-	    if (cacheFp)
+	    if (cacheFp) {
 		filp_close(cacheFp, NULL);
+		cacheFp = NULL;
+	    }
 	}
 
 	if (!tdc) {
@@ -2744,7 +2750,10 @@
 	    AFS_GUNLOCK();
 	    if (tdc) {
 		cacheFp = afs_linux_raw_open(&tdc->f.inode);
-                osi_Assert(cacheFp);
+		if (cacheFp == NULL) {
+		    /* Problem getting the inode */
+		    goto out;
+		}
 		if (!cacheFp->f_dentry->d_inode->i_mapping->a_ops->readpage) {
 		    cachefs_noreadpage = 1;
 		    goto out;
@@ -2765,7 +2774,7 @@
     afs_lru_cache_finalize(&lrupages);
 
 out:
-    if (tdc)
+    if (cacheFp)
 	filp_close(cacheFp, NULL);
 
     afs_pagecopy_put_task(task);
From 790824ff749b6ee01c4d7101493cbe8773ef41c6 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Sun, 05 Apr 2020 15:51:17 -0600
Subject: [PATCH] cf: Use common macro to test compiler flags

Use the AX_APPEND_COMPILE_FLAGS macro to test and set compiler
specific flags.

Remove the OPENAFS_GCC_SUPPORTS_MARCH check entirely (and the
associated P5PLUS_KOPTS), since nothing has used it for quite some
time.

Change-Id: Ic9626c52ac62cf83d4b8c787aa5aa966e558a781
Reviewed-on: https://gerrit.openafs.org/14132
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
---

diff --git a/src/cf/linux-checks.m4 b/src/cf/linux-checks.m4
index d4a6c97..f0d2daf 100644
--- a/src/cf/linux-checks.m4
+++ b/src/cf/linux-checks.m4
@@ -14,12 +14,9 @@
 if test "x$enable_debug_kernel" = "xno"; then
     LINUX_GCC_KOPTS="$LINUX_GCC_KOPTS -fomit-frame-pointer"
 fi
-OPENAFS_GCC_SUPPORTS_MARCH
-AC_SUBST(P5PLUS_KOPTS)
-OPENAFS_GCC_NEEDS_NO_STRENGTH_REDUCE
-OPENAFS_GCC_NEEDS_NO_STRICT_ALIASING
-OPENAFS_GCC_SUPPORTS_NO_COMMON
-OPENAFS_GCC_SUPPORTS_PIPE
+AX_APPEND_COMPILE_FLAGS([-fno-strict-aliasing -fno-strength-reduce \
+                         -fno-common -pipe],
+                        [LINUX_GCC_KOPTS])
 AC_SUBST(LINUX_GCC_KOPTS)
 
 dnl Setup the kernel build environment
diff --git a/src/cf/linux-test5.m4 b/src/cf/linux-test5.m4
deleted file mode 100644
index 59bdbfc..0000000
--- a/src/cf/linux-test5.m4
+++ /dev/null
@@ -1,88 +0,0 @@
-dnl These options seem to only be used for the 2.4.x
-dnl Linux kernel build
-AC_DEFUN([OPENAFS_GCC_SUPPORTS_MARCH], [
-  AC_CACHE_CHECK([if $CC accepts -march=pentium],
-    [openafs_cv_gcc_supports_march],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="-MARCH=pentium"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-         [[]],
-         [[int x;]])],
-         [openafs_cv_gcc_supports_march=yes],
-         [openafs_cv_gcc_supports_march=no])
-     CFLAGS="$save_CFLAGS"
-    ])
-  AS_IF([test x$openafs_cv_gcc_supports_march = xyes],
-        [P5PLUS_KOPTS="-march=pentium"],
-        [P5PLUS_KOPTS="-m486 -malign-loops=2 -malign-jumps=2 -malign-functions=2"])
-])
-
-AC_DEFUN([OPENAFS_GCC_NEEDS_NO_STRICT_ALIASING], [
-  AC_CACHE_CHECK([if $CC needs -fno-strict-aliasing],
-    [openafs_cv_gcc_needs_no_strict_aliasing],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="-fno-strict-aliasing"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-         [[]],
-         [[int x;]])],
-       [openafs_cv_gcc_needs_no_strict_aliasing=yes],
-       [openafs_cv_gcc_needs_no_strict_aliasing=no])
-     CFLAGS="$save_CFLAGS"
-  ])
-  AS_IF([test x$openafs_cv_gcc_needs_no_strict_aliasing = xyes],
-        [LINUX_GCC_KOPTS="$LINUX_GCC_KOPTS -fno-strict-aliasing"])
-])
-
-AC_DEFUN([OPENAFS_GCC_NEEDS_NO_STRENGTH_REDUCE], [
-  AC_CACHE_CHECK([if $CC needs -fno-strength-reduce],
-    [openafs_cv_gcc_needs_no_strength_reduce],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="-fno-strength-reduce"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-         [[]],
-         [[int x;]])],
-       [openafs_cv_gcc_needs_no_strength_reduce=yes],
-       [openafs_cv_gcc_needs_no_strength_reduce=no])
-     CFLAGS="$save_CFLAGS"
-  ])
-  AS_IF([test x$openafs_cv_gcc_needs_no_strength_reduce = xyes],
-        [LINUX_GCC_KOPTS="$LINUX_GCC_KOPTS -fno-strength-reduce"])
-])
-
-AC_DEFUN([OPENAFS_GCC_SUPPORTS_NO_COMMON], [
-  AC_CACHE_CHECK([if $CC supports -fno-common],
-    [openafs_cv_gcc_supports_no_common],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="-fno-common"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-         [[]],
-         [[int x;]])],
-       [openafs_cv_gcc_supports_no_common=yes],
-       [openafs_cv_gcc_supports_no_common=no])
-
-     CFLAGS="$save_CFLAGS"
-  ])
-  AS_IF([test x$openafs_cv_gcc_supports_no_common = xyes],
-	[LINUX_GCC_KOPTS="$LINUX_GCC_KOPTS -fno-common"])
-])
-
-AC_DEFUN([OPENAFS_GCC_SUPPORTS_PIPE], [
-  AC_CACHE_CHECK([if $CC supports -pipe],
-    [openafs_cv_gcc_supports_pipe],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="-pipe"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-         [[]],
-         [[int x;]])],
-       [openafs_cv_gcc_supports_pipe=yes],
-       [openafs_cv_gcc_supports_pipe=no])
-  CFLAGS="$save_CFLAGS"
-  ])
-  AS_IF([test x$openafs_cv_gcc_supports_pipe = xyes],
-	  [LINUX_GCC_KOPTS="$LINUX_GCC_KOPTS -pipe"])
-])
diff --git a/src/cf/solaris-test1.m4 b/src/cf/solaris-test1.m4
index 89fbdff..201445e 100644
--- a/src/cf/solaris-test1.m4
+++ b/src/cf/solaris-test1.m4
@@ -8,17 +8,6 @@
 dnl
 dnl
 AC_DEFUN([SOLARIS_CC_TAKES_XVECTOR_NONE], [
-  AC_CACHE_CHECK([if $CC accepts -xvector=%none],
-    [ac_cv_solaris_cc_takes_xvector_none],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="$CFLAGS -xvector=%none"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM([[]], [[int x;]])],
-       [ac_cv_solaris_cc_takes_xvector_none=yes],
-       [ac_cv_solaris_cc_takes_xvector_none=no])
-     CFLAGS="$save_CFLAGS"
-    ])
-
 dnl -xvector=%none first appeared in Studio 11, but has only been
 dnl documented as required for Solaris x86 kernel code since Studio
 dnl 12.3.  Studio 12.3 is when the compiler started making more
@@ -28,11 +17,8 @@
 dnl Experiments have shown that -xregs=no%float is also needed to
 dnl 1) eliminate a few optimizations not squelched by -xvector=%none,
 dnl and 2) prevent actual use of floating point types in the kernel
-dnl module.  -xregs=no%float has been present since before Studio 8, so
-dnl it is safe to assume its presence when -xvector=%none is present.
+dnl module.
 dnl
-
-  AS_IF([test "$ac_cv_solaris_cc_takes_xvector_none" = "yes"],
-        [SOLARIS_CC_KOPTS="-xvector=%none -xregs=no%float "])
+  AX_APPEND_COMPILE_FLAGS([-xvector=%none -xregs=no%float], [SOLARIS_CC_KOPTS])
 ])
 
From 573be0228778873c0d445263fb09989918bea4c1 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Tue, 01 Mar 2022 15:35:07 -0700
Subject: [PATCH] cf: Use -Werror when checking for -Wno-* flags

When detecting valid compiler flags clang behaves differently than gcc
for certain types of flags.  Specifically, gcc will ignore an unknown
"-Wno-someflag" while clang will issue a warning.  If using clang and
--enable-checking is specified, this difference causes a build failure
because the warning for the unknown flag is turned into an error.

The autoconf macro AX_APPEND_COMPILE_FLAGS (via the underlying macro
AX_CHECK_COMPILE_FLAGS) looks specifically for errors and not warnings
to determine if the flag is valid.  In order to properly catch the above
type of unknown compiler flags, a '-Werror' must be passed as an
extra-flag.

Update the autoconf functions that use AX_APPEND_COMPILE_FLAGS to use
'-Werror' as an extra flag when testing for "-Wno-..." flags.

Note, for gcc, the test may (incorrectly) think that the compiler
supports the given flag, but that is okay, since the flag will be
ignored by gcc during the build without raising any warnings or errors.

Change-Id: I9e4dabf04a3b019cb1ea58a4b2ac1cf0fc8d1e71
Reviewed-on: https://gerrit.openafs.org/14900
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/cf/linux-checks.m4 b/src/cf/linux-checks.m4
index f0d2daf..e5dcdcc 100644
--- a/src/cf/linux-checks.m4
+++ b/src/cf/linux-checks.m4
@@ -16,7 +16,7 @@
 fi
 AX_APPEND_COMPILE_FLAGS([-fno-strict-aliasing -fno-strength-reduce \
                          -fno-common -pipe],
-                        [LINUX_GCC_KOPTS])
+                        [LINUX_GCC_KOPTS],[-Werror])
 AC_SUBST(LINUX_GCC_KOPTS)
 
 dnl Setup the kernel build environment
diff --git a/src/cf/osconf.m4 b/src/cf/osconf.m4
index d98a1fe..2805ab6 100644
--- a/src/cf/osconf.m4
+++ b/src/cf/osconf.m4
@@ -645,9 +645,9 @@
       CFLAGS_NOUNUSED="-Wno-unused"
       CFLAGS_NOOLDSTYLE="-Wno-old-style-definition"
       AX_APPEND_COMPILE_FLAGS([-Wno-implicit-fallthrough],
-                               [CFLAGS_NOIMPLICIT_FALLTHROUGH])
+			      [CFLAGS_NOIMPLICIT_FALLTHROUGH], [-Werror])
       AX_APPEND_COMPILE_FLAGS([-Wno-cast-function-type],
-                              [CFLAGS_NOCAST_FUNCTION_TYPE])
+			      [CFLAGS_NOCAST_FUNCTION_TYPE], [-Werror])
       AC_DEFINE(IGNORE_SOME_GCC_WARNINGS, 1, [define to disable some gcc warnings in warnings-as-errors mode])
     else
       CFLAGS_NOSTRICT=
@@ -673,7 +673,7 @@
 
 dnl add additional checks if compilers support the flags
 AS_IF([test "x$enable_checking" != "xno"],
-      [AX_APPEND_COMPILE_FLAGS([-Wimplicit-fallthrough], [XCFLAGS])
+      [AX_APPEND_COMPILE_FLAGS([-Wimplicit-fallthrough], [XCFLAGS], [-Werror])
 ])
 
 dnl horribly cheating, assuming double / is ok.
From 88da6b4dfa4ad2b53508f9e0b559392cecb69c86 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 16 Jul 2020 15:05:13 -0600
Subject: [PATCH] cf: Make local copy of ax_gcc_func_attribute.m4

Make a local copy of ax_gcc_func_attribute from autoconf-archive. This
is needed in order to fix a bug in the detection of the fallthrough
attribute.

Remove ax_gcc_func_attribute.m4 from src/external/autoconf-archive/m4.
Update LICENSE file to point to the local copy in src/cf.

Change-Id: I6c4244d2cd4edab4262c1820435c00419d85303b
Reviewed-on: https://gerrit.openafs.org/14272
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/LICENSE b/LICENSE
index f200e2a..b159794 100644
--- a/LICENSE
+++ b/LICENSE
@@ -418,8 +418,8 @@
 
 ====================================================
 
-The files under src/external/autoconf-archive/m4/ are covered by the following
-license:
+The file src/cf/ax_gcc_func_attribute.m4 and the files under
+src/external/autoconf-archive/m4/ are covered by the following license:
 
   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
diff --git a/src/cf/ax_gcc_func_attribute.m4 b/src/cf/ax_gcc_func_attribute.m4
new file mode 100644
index 0000000..098c9aa
--- /dev/null
+++ b/src/cf/ax_gcc_func_attribute.m4
@@ -0,0 +1,238 @@
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_gcc_func_attribute.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_GCC_FUNC_ATTRIBUTE(ATTRIBUTE)
+#
+# DESCRIPTION
+#
+#   This macro checks if the compiler supports one of GCC's function
+#   attributes; many other compilers also provide function attributes with
+#   the same syntax. Compiler warnings are used to detect supported
+#   attributes as unsupported ones are ignored by default so quieting
+#   warnings when using this macro will yield false positives.
+#
+#   The ATTRIBUTE parameter holds the name of the attribute to be checked.
+#
+#   If ATTRIBUTE is supported define HAVE_FUNC_ATTRIBUTE_<ATTRIBUTE>.
+#
+#   The macro caches its result in the ax_cv_have_func_attribute_<attribute>
+#   variable.
+#
+#   The macro currently supports the following function attributes:
+#
+#    alias
+#    aligned
+#    alloc_size
+#    always_inline
+#    artificial
+#    cold
+#    const
+#    constructor
+#    constructor_priority for constructor attribute with priority
+#    deprecated
+#    destructor
+#    dllexport
+#    dllimport
+#    error
+#    externally_visible
+#    fallthrough
+#    flatten
+#    format
+#    format_arg
+#    gnu_inline
+#    hot
+#    ifunc
+#    leaf
+#    malloc
+#    noclone
+#    noinline
+#    nonnull
+#    noreturn
+#    nothrow
+#    optimize
+#    pure
+#    sentinel
+#    sentinel_position
+#    unused
+#    used
+#    visibility
+#    warning
+#    warn_unused_result
+#    weak
+#    weakref
+#
+#   Unsupported function attributes will be tested with a prototype
+#   returning an int and not accepting any arguments and the result of the
+#   check might be wrong or meaningless so use with care.
+#
+# LICENSE
+#
+#   Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 9
+
+AC_DEFUN([AX_GCC_FUNC_ATTRIBUTE], [
+    AS_VAR_PUSHDEF([ac_var], [ax_cv_have_func_attribute_$1])
+
+    AC_CACHE_CHECK([for __attribute__(($1))], [ac_var], [
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([
+            m4_case([$1],
+                [alias], [
+                    int foo( void ) { return 0; }
+                    int bar( void ) __attribute__(($1("foo")));
+                ],
+                [aligned], [
+                    int foo( void ) __attribute__(($1(32)));
+                ],
+                [alloc_size], [
+                    void *foo(int a) __attribute__(($1(1)));
+                ],
+                [always_inline], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [artificial], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [cold], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [const], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [constructor_priority], [
+                    int foo( void ) __attribute__((__constructor__(65535/2)));
+                ],
+                [constructor], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [deprecated], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [destructor], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [dllexport], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [dllimport], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [error], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [externally_visible], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [fallthrough], [
+                    int foo( void ) {switch (0) { case 1: __attribute__(($1)); case 2: break ; }};
+                ],
+                [flatten], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [format], [
+                    int foo(const char *p, ...) __attribute__(($1(printf, 1, 2)));
+                ],
+                [format_arg], [
+                    char *foo(const char *p) __attribute__(($1(1)));
+                ],
+                [gnu_inline], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [hot], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [ifunc], [
+                    int my_foo( void ) { return 0; }
+                    static int (*resolve_foo(void))(void) { return my_foo; }
+                    int foo( void ) __attribute__(($1("resolve_foo")));
+                ],
+                [leaf], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [malloc], [
+                    void *foo( void ) __attribute__(($1));
+                ],
+                [noclone], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [noinline], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [nonnull], [
+                    int foo(char *p) __attribute__(($1(1)));
+                ],
+                [noreturn], [
+                    void foo( void ) __attribute__(($1));
+                ],
+                [nothrow], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [optimize], [
+                    __attribute__(($1(3))) int foo( void ) { return 0; }
+                ],
+                [pure], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [sentinel], [
+                    int foo(void *p, ...) __attribute__(($1));
+                ],
+                [sentinel_position], [
+                    int foo(void *p, ...) __attribute__(($1(1)));
+                ],
+                [returns_nonnull], [
+                    void *foo( void ) __attribute__(($1));
+                ],
+                [unused], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [used], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [visibility], [
+                    int foo_def( void ) __attribute__(($1("default")));
+                    int foo_hid( void ) __attribute__(($1("hidden")));
+                    int foo_int( void ) __attribute__(($1("internal")));
+                    int foo_pro( void ) __attribute__(($1("protected")));
+                ],
+                [warning], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [warn_unused_result], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [weak], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [weakref], [
+                    static int foo( void ) { return 0; }
+                    static int bar( void ) __attribute__(($1("foo")));
+                ],
+                [
+                 m4_warn([syntax], [Unsupported attribute $1, the test may fail])
+                 int foo( void ) __attribute__(($1));
+                ]
+            )], [])
+            ],
+            dnl GCC doesn't exit with an error if an unknown attribute is
+            dnl provided but only outputs a warning, so accept the attribute
+            dnl only if no warning were issued.
+            [AS_IF([test -s conftest.err],
+                [AS_VAR_SET([ac_var], [no])],
+                [AS_VAR_SET([ac_var], [yes])])],
+            [AS_VAR_SET([ac_var], [no])])
+    ])
+
+    AS_IF([test yes = AS_VAR_GET([ac_var])],
+        [AC_DEFINE_UNQUOTED(AS_TR_CPP(HAVE_FUNC_ATTRIBUTE_$1), 1,
+            [Define to 1 if the system has the `$1' function attribute])], [])
+
+    AS_VAR_POPDEF([ac_var])
+])
diff --git a/src/external/autoconf-archive-files b/src/external/autoconf-archive-files
index 42c7c38..eddcf27 100644
--- a/src/external/autoconf-archive-files
+++ b/src/external/autoconf-archive-files
@@ -1,5 +1,4 @@
 m4/ax_append_compile_flags.m4	m4/ax_append_compile_flags.m4
 m4/ax_append_flag.m4		m4/ax_append_flag.m4
 m4/ax_check_compile_flag.m4	m4/ax_check_compile_flag.m4
-m4/ax_gcc_func_attribute.m4	m4/ax_gcc_func_attribute.m4
 m4/ax_require_defined.m4	m4/ax_require_defined.m4
diff --git a/src/external/autoconf-archive/m4/ax_gcc_func_attribute.m4 b/src/external/autoconf-archive/m4/ax_gcc_func_attribute.m4
deleted file mode 100644
index 098c9aa..0000000
--- a/src/external/autoconf-archive/m4/ax_gcc_func_attribute.m4
+++ /dev/null
@@ -1,238 +0,0 @@
-# ===========================================================================
-#  https://www.gnu.org/software/autoconf-archive/ax_gcc_func_attribute.html
-# ===========================================================================
-#
-# SYNOPSIS
-#
-#   AX_GCC_FUNC_ATTRIBUTE(ATTRIBUTE)
-#
-# DESCRIPTION
-#
-#   This macro checks if the compiler supports one of GCC's function
-#   attributes; many other compilers also provide function attributes with
-#   the same syntax. Compiler warnings are used to detect supported
-#   attributes as unsupported ones are ignored by default so quieting
-#   warnings when using this macro will yield false positives.
-#
-#   The ATTRIBUTE parameter holds the name of the attribute to be checked.
-#
-#   If ATTRIBUTE is supported define HAVE_FUNC_ATTRIBUTE_<ATTRIBUTE>.
-#
-#   The macro caches its result in the ax_cv_have_func_attribute_<attribute>
-#   variable.
-#
-#   The macro currently supports the following function attributes:
-#
-#    alias
-#    aligned
-#    alloc_size
-#    always_inline
-#    artificial
-#    cold
-#    const
-#    constructor
-#    constructor_priority for constructor attribute with priority
-#    deprecated
-#    destructor
-#    dllexport
-#    dllimport
-#    error
-#    externally_visible
-#    fallthrough
-#    flatten
-#    format
-#    format_arg
-#    gnu_inline
-#    hot
-#    ifunc
-#    leaf
-#    malloc
-#    noclone
-#    noinline
-#    nonnull
-#    noreturn
-#    nothrow
-#    optimize
-#    pure
-#    sentinel
-#    sentinel_position
-#    unused
-#    used
-#    visibility
-#    warning
-#    warn_unused_result
-#    weak
-#    weakref
-#
-#   Unsupported function attributes will be tested with a prototype
-#   returning an int and not accepting any arguments and the result of the
-#   check might be wrong or meaningless so use with care.
-#
-# LICENSE
-#
-#   Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>
-#
-#   Copying and distribution of this file, with or without modification, are
-#   permitted in any medium without royalty provided the copyright notice
-#   and this notice are preserved.  This file is offered as-is, without any
-#   warranty.
-
-#serial 9
-
-AC_DEFUN([AX_GCC_FUNC_ATTRIBUTE], [
-    AS_VAR_PUSHDEF([ac_var], [ax_cv_have_func_attribute_$1])
-
-    AC_CACHE_CHECK([for __attribute__(($1))], [ac_var], [
-        AC_LINK_IFELSE([AC_LANG_PROGRAM([
-            m4_case([$1],
-                [alias], [
-                    int foo( void ) { return 0; }
-                    int bar( void ) __attribute__(($1("foo")));
-                ],
-                [aligned], [
-                    int foo( void ) __attribute__(($1(32)));
-                ],
-                [alloc_size], [
-                    void *foo(int a) __attribute__(($1(1)));
-                ],
-                [always_inline], [
-                    inline __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [artificial], [
-                    inline __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [cold], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [const], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [constructor_priority], [
-                    int foo( void ) __attribute__((__constructor__(65535/2)));
-                ],
-                [constructor], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [deprecated], [
-                    int foo( void ) __attribute__(($1("")));
-                ],
-                [destructor], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [dllexport], [
-                    __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [dllimport], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [error], [
-                    int foo( void ) __attribute__(($1("")));
-                ],
-                [externally_visible], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [fallthrough], [
-                    int foo( void ) {switch (0) { case 1: __attribute__(($1)); case 2: break ; }};
-                ],
-                [flatten], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [format], [
-                    int foo(const char *p, ...) __attribute__(($1(printf, 1, 2)));
-                ],
-                [format_arg], [
-                    char *foo(const char *p) __attribute__(($1(1)));
-                ],
-                [gnu_inline], [
-                    inline __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [hot], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [ifunc], [
-                    int my_foo( void ) { return 0; }
-                    static int (*resolve_foo(void))(void) { return my_foo; }
-                    int foo( void ) __attribute__(($1("resolve_foo")));
-                ],
-                [leaf], [
-                    __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [malloc], [
-                    void *foo( void ) __attribute__(($1));
-                ],
-                [noclone], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [noinline], [
-                    __attribute__(($1)) int foo( void ) { return 0; }
-                ],
-                [nonnull], [
-                    int foo(char *p) __attribute__(($1(1)));
-                ],
-                [noreturn], [
-                    void foo( void ) __attribute__(($1));
-                ],
-                [nothrow], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [optimize], [
-                    __attribute__(($1(3))) int foo( void ) { return 0; }
-                ],
-                [pure], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [sentinel], [
-                    int foo(void *p, ...) __attribute__(($1));
-                ],
-                [sentinel_position], [
-                    int foo(void *p, ...) __attribute__(($1(1)));
-                ],
-                [returns_nonnull], [
-                    void *foo( void ) __attribute__(($1));
-                ],
-                [unused], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [used], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [visibility], [
-                    int foo_def( void ) __attribute__(($1("default")));
-                    int foo_hid( void ) __attribute__(($1("hidden")));
-                    int foo_int( void ) __attribute__(($1("internal")));
-                    int foo_pro( void ) __attribute__(($1("protected")));
-                ],
-                [warning], [
-                    int foo( void ) __attribute__(($1("")));
-                ],
-                [warn_unused_result], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [weak], [
-                    int foo( void ) __attribute__(($1));
-                ],
-                [weakref], [
-                    static int foo( void ) { return 0; }
-                    static int bar( void ) __attribute__(($1("foo")));
-                ],
-                [
-                 m4_warn([syntax], [Unsupported attribute $1, the test may fail])
-                 int foo( void ) __attribute__(($1));
-                ]
-            )], [])
-            ],
-            dnl GCC doesn't exit with an error if an unknown attribute is
-            dnl provided but only outputs a warning, so accept the attribute
-            dnl only if no warning were issued.
-            [AS_IF([test -s conftest.err],
-                [AS_VAR_SET([ac_var], [no])],
-                [AS_VAR_SET([ac_var], [yes])])],
-            [AS_VAR_SET([ac_var], [no])])
-    ])
-
-    AS_IF([test yes = AS_VAR_GET([ac_var])],
-        [AC_DEFINE_UNQUOTED(AS_TR_CPP(HAVE_FUNC_ATTRIBUTE_$1), 1,
-            [Define to 1 if the system has the `$1' function attribute])], [])
-
-    AS_VAR_POPDEF([ac_var])
-])
From 899b1af4183fb09fd55a36e3d10ffbdb9671a47e Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 16 Jul 2020 15:07:15 -0600
Subject: [PATCH] autoconf: fix detection for fallthrough attribute

Due to bug <https://savannah.gnu.org/patch/?9949>,
ax_gcc_func_attribute.m4 fails to properly detect __attribute__((fallthrough))
in clang. Until this is fixed in autoconf-archive upstream, fix our
local copy of ax_gcc_func_attribute.m4, so we can detect
__attribute__((fallthrough)) to make --enable-checking work with clang.

Change-Id: I80a4557384f8e1438344e48bfe722e20c8773882
Reviewed-on: https://gerrit.openafs.org/14273
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
---

diff --git a/src/cf/ax_gcc_func_attribute.m4 b/src/cf/ax_gcc_func_attribute.m4
index 098c9aa..30bf4c1 100644
--- a/src/cf/ax_gcc_func_attribute.m4
+++ b/src/cf/ax_gcc_func_attribute.m4
@@ -77,7 +77,7 @@
 #   and this notice are preserved.  This file is offered as-is, without any
 #   warranty.
 
-#serial 9
+#serial 9 with local fix for fallthrough attribute
 
 AC_DEFUN([AX_GCC_FUNC_ATTRIBUTE], [
     AS_VAR_PUSHDEF([ac_var], [ax_cv_have_func_attribute_$1])
@@ -132,7 +132,7 @@
                     int foo( void ) __attribute__(($1));
                 ],
                 [fallthrough], [
-                    int foo( void ) {switch (0) { case 1: __attribute__(($1)); case 2: break ; }};
+                    void foo( int x ) {switch (x) { case 1: __attribute__(($1)); case 2: break ; }};
                 ],
                 [flatten], [
                     int foo( void ) __attribute__(($1));
From ae70db6cde5be5abd3bbbb26bd9af6fe68cc4b6b Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Tue, 24 May 2022 20:14:36 -0600
Subject: [PATCH] vol: Use asprintf in _namei_examine_special

GCC-12 is flagging an snprintf statement with a format truncation
warning:

  namei_ops.c: In function ‘namei_ListAFSSubDirs’:
  namei_ops.c:2029:22: error: ‘%s’ directive output may be truncated
   writing up to 255 bytes into a region of size between 0 and 511
   [-Werror=format-truncation=]

Change code to use asprintf instead of snprintf.  Return an error if a
memory allocation fails.

Change-Id: I1f617ab22dbec4c2497ec482115cd20c9af0ecfa
Reviewed-on: https://gerrit.openafs.org/14955
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/vol/namei_ops.c b/src/vol/namei_ops.c
index d2f94bb..d77f33f 100644
--- a/src/vol/namei_ops.c
+++ b/src/vol/namei_ops.c
@@ -2023,13 +2023,17 @@
 	 * this like a normal file, we won't try to INC or DEC it. */
 	info.linkCount = 0;
     } else {
-	char path2[512];
+	char *path2;
 	/* Open this handle */
-	snprintf(path2, sizeof(path2),
-		 "%s" OS_DIRSEP "%s", path1, dname);
+	if (asprintf(&path2, "%s" OS_DIRSEP "%s", path1, dname) < 0) {
+	    Log("_namei_examine_special: memory allocation failure\n");
+	    ret = -1;
+	    goto error;
+	}
 	linkHandle->fd_fd = OS_OPEN(path2, Testing ? O_RDONLY : O_RDWR, 0666);
 	info.linkCount =
 	    namei_GetLinkCount(linkHandle, (Inode) 0, 1, 1, Testing);
+	free(path2);
     }
 
     if (!judgeFun ||
From 82c14b9a667174f044b7421e6e081ad323720a67 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Wed, 11 May 2022 08:48:52 -0600
Subject: [PATCH] afsd: Avoid fscanf overflows when paring cacheinfo

clang-14 is producing the following diagnostic:

    afsd.c:581:44: error: 'fscanf' may overflow; destination buffer in
      argument 3 has size 1024, but the corresponding specifier may
      require size 1025 [-Werror,-Wfortify-source]
        fscanf(cachefd, "%1024[^:]:%1024[^:]:%d", tCacheMountDir,

fscanf is being used to parse the contents of a file and the buffer
sizes are hardcoded.  Simply increase the size of the 2 buffers by 1.

The diagnostic warning is changed to an error when configured with
--enable-checking.

Change-Id: Iefbc4e87242232531a266e876fe779476b42fb62
Reviewed-on: https://gerrit.openafs.org/14958
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/afsd/afsd.c b/src/afsd/afsd.c
index 0d29767..06cd96d 100644
--- a/src/afsd/afsd.c
+++ b/src/afsd/afsd.c
@@ -559,7 +559,7 @@
     FILE *cachefd;		/*Descriptor for cache info file */
     int parseResult;		/*Result of our fscanf() */
     int tCacheBlocks;
-    char tCacheBaseDir[1024], *tbd, tCacheMountDir[1024], *tmd;
+    char tCacheBaseDir[1025], *tbd, tCacheMountDir[1025], *tmd;
 
     if (afsd_debug)
 	printf("%s: Opening cache info file '%s'...\n", rn, fullpn_CacheInfo);
From 6aa129e743e882cf30c35afd67eabf82274c5fca Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Wed, 30 Mar 2022 11:09:45 -0600
Subject: [PATCH] Linux-5.18 replace set_page_dirty with dirty_folio

The commits going into Linux 5.18:

  fs: Add aops->dirty_folio (6f31a5a261db)
  fs: Convert __set_page_dirty_buffers to block_dirty_folio (e621900ad2)
  fs: Remove aops ->set_page_dirty (3a3bae50af)

replaces the address_space_operations structure member set_page_dirty
which with dirty_folio.  The linux function __set_page_dirty_buffers is
replaced by block_dirty_folio.

Nothing within afs uses or implements the set_page_dirty function,
however the structure member is required to be initialized.

Add an autoconf test for the dirty_folio member and if present, set the
address_space_operations member dirty_folio to block_dirty_folio
instead of setting the set_page_dirty member.

Change-Id: Iad6783308989f4a1390c1c94d2c571048bd4e771
Reviewed-on: https://gerrit.openafs.org/14939
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 15258ee..c0cc250 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -3293,7 +3293,11 @@
   .readpage =		afs_linux_readpage,
   .readpages = 		afs_linux_readpages,
   .writepage =		afs_linux_writepage,
+#if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_DIRTY_FOLIO)
+  .dirty_folio =	block_dirty_folio,
+#else
   .set_page_dirty =	__set_page_dirty_buffers,
+#endif
 #if defined (STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_WRITE_BEGIN)
   .write_begin =        afs_linux_write_begin,
   .write_end =          afs_linux_write_end,
diff --git a/src/cf/linux-kernel-struct.m4 b/src/cf/linux-kernel-struct.m4
index 003d34a..2d8cee6 100644
--- a/src/cf/linux-kernel-struct.m4
+++ b/src/cf/linux-kernel-struct.m4
@@ -3,6 +3,8 @@
 AC_CHECK_LINUX_STRUCT([address_space], [backing_dev_info], [fs.h])
 AC_CHECK_LINUX_STRUCT([address_space_operations],
                       [write_begin], [fs.h])
+dnl linux 5.18 replaced set_page_dirty with dirty_folio
+AC_CHECK_LINUX_STRUCT([address_space_operations], [dirty_folio], [fs.h])
 AC_CHECK_LINUX_STRUCT([backing_dev_info], [name],
                       [backing-dev.h])
 AC_CHECK_LINUX_STRUCT([cred], [session_keyring], [cred.h])
From a3fc79633fb0601bf02508bd1e64652f403e4b7e Mon Sep 17 00:00:00 2001
From: Mark Vitale <mvitale@sinenomine.net>
Date: Wed, 23 Sep 2020 17:02:52 -0400
Subject: [PATCH] afs: remove vestigial externs for afs_xcbhash

Commit 64cc7f0ca7a44bb214396c829268a541ab286c69 "afs: Create
afs_StaleVCache" consolidated many references to afs_xcbhash into a new
function afs_StaleVCache.  However, this left many references to 'extern
afs_wrlock_t afs_xcbhash' that are no longer needed.

But actually, many of these have not been needed since
src/afs/afs_prototypes.h gained 'extern afs_rwlock_t afs_xcbhash' with
commit 8f2df21ffe59e9aa66219bf24656775b584c122d
"pull-prototypes-to-head-20020821"

Remove the vestigial extern references.

No functional change is incurred by this commit.

Change-Id: Ie6cfb6d90c52951795378d3b42e041567d207305
Reviewed-on: https://gerrit.openafs.org/14405
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/afs/VNOPS/afs_vnop_attrs.c b/src/afs/VNOPS/afs_vnop_attrs.c
index 7166bf3..beb8297 100644
--- a/src/afs/VNOPS/afs_vnop_attrs.c
+++ b/src/afs/VNOPS/afs_vnop_attrs.c
@@ -33,7 +33,6 @@
 #include "afs/nfsclient.h"
 #include "afs/afs_osidnlc.h"
 
-extern afs_rwlock_t afs_xcbhash;
 struct afs_exporter *afs_nfsexporter;
 extern struct vcache *afs_globalVp;
 #if defined(AFS_HPUX110_ENV)
diff --git a/src/afs/VNOPS/afs_vnop_dirops.c b/src/afs/VNOPS/afs_vnop_dirops.c
index 1ddda67..fd4782c 100644
--- a/src/afs/VNOPS/afs_vnop_dirops.c
+++ b/src/afs/VNOPS/afs_vnop_dirops.c
@@ -29,7 +29,6 @@
 #include "afs/afs_osidnlc.h"
 
 extern afs_rwlock_t afs_xvcache;
-extern afs_rwlock_t afs_xcbhash;
 
 /* don't set CDirty in here because RPC is called synchronously */
 
diff --git a/src/afs/VNOPS/afs_vnop_link.c b/src/afs/VNOPS/afs_vnop_link.c
index f57b7ad..c74aa36 100644
--- a/src/afs/VNOPS/afs_vnop_link.c
+++ b/src/afs/VNOPS/afs_vnop_link.c
@@ -24,8 +24,6 @@
 #include "afs/nfsclient.h"
 #include "afs/afs_osidnlc.h"
 
-extern afs_rwlock_t afs_xcbhash;
-
 /* Note that we don't set CDirty here, this is OK because the link
  * RPC is called synchronously. */
 
diff --git a/src/afs/VNOPS/afs_vnop_remove.c b/src/afs/VNOPS/afs_vnop_remove.c
index 4ab3eb6..78521ca 100644
--- a/src/afs/VNOPS/afs_vnop_remove.c
+++ b/src/afs/VNOPS/afs_vnop_remove.c
@@ -28,7 +28,6 @@
 
 
 extern afs_rwlock_t afs_xvcache;
-extern afs_rwlock_t afs_xcbhash;
 
 
 static void
diff --git a/src/afs/VNOPS/afs_vnop_rename.c b/src/afs/VNOPS/afs_vnop_rename.c
index f899d31..8d72f10 100644
--- a/src/afs/VNOPS/afs_vnop_rename.c
+++ b/src/afs/VNOPS/afs_vnop_rename.c
@@ -25,8 +25,6 @@
 #include "afs/nfsclient.h"
 #include "afs/afs_osidnlc.h"
 
-extern afs_rwlock_t afs_xcbhash;
-
 /* Note that we don't set CDirty here, this is OK because the rename
  * RPC is called synchronously. */
 
diff --git a/src/afs/VNOPS/afs_vnop_symlink.c b/src/afs/VNOPS/afs_vnop_symlink.c
index e88e09e..c9be5f6 100644
--- a/src/afs/VNOPS/afs_vnop_symlink.c
+++ b/src/afs/VNOPS/afs_vnop_symlink.c
@@ -30,7 +30,6 @@
 #include "afs/afs_osidnlc.h"
 
 extern afs_rwlock_t afs_xvcache;
-extern afs_rwlock_t afs_xcbhash;
 
 /* Note: There is the bare bones beginning of symlink hints in the now
  * defunct afs/afs_lookup.c file. Since they are not in use, making the call
diff --git a/src/afs/afs_bypasscache.c b/src/afs/afs_bypasscache.c
index 64da1ed..c51bd25 100644
--- a/src/afs/afs_bypasscache.c
+++ b/src/afs/afs_bypasscache.c
@@ -112,8 +112,6 @@
 afs_size_t cache_bypass_threshold  =  	AFS_CACHE_BYPASS_DISABLED; /* file size > threshold triggers bypass */
 int cache_bypass_prefetch = 1;	/* Should we do prefetching ? */
 
-extern afs_rwlock_t afs_xcbhash;
-
 /*
  * This is almost exactly like the PFlush() routine in afs_pioctl.c,
  * but that routine is static.  We are about to change a file from
From e17bc8ce865f630d268c2a5e8cafb79ad8855f12 Mon Sep 17 00:00:00 2001
From: Mark Vitale <mvitale@sinenomine.net>
Date: Wed, 23 Sep 2020 17:32:40 -0400
Subject: [PATCH] afs: remove vestigial externs for afs_xvcache

These have not been needed since src/afs/afs_prototypes.h gained 'extern
afs_rwlock_t afs_xvcache' with commit
8f2df21ffe59e9aa66219bf24656775b584c122d
"pull-prototypes-to-head-20020821"

Remove the vestigial extern references.

Change-Id: Id6aceff0d5df1f1bed210a3fbf2951c62f35ddbb
Reviewed-on: https://gerrit.openafs.org/14406
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/afs/LINUX/osi_vfsops.c b/src/afs/LINUX/osi_vfsops.c
index b33db3a..5457fbe 100644
--- a/src/afs/LINUX/osi_vfsops.c
+++ b/src/afs/LINUX/osi_vfsops.c
@@ -33,7 +33,6 @@
 #if !defined(AFS_NONFSTRANS)
 extern struct export_operations afs_export_ops;
 #endif
-extern afs_rwlock_t afs_xvcache;
 extern struct afs_q VLRU;
 
 extern struct dentry_operations afs_dentry_operations;
diff --git a/src/afs/VNOPS/afs_vnop_dirops.c b/src/afs/VNOPS/afs_vnop_dirops.c
index fd4782c..5a73506 100644
--- a/src/afs/VNOPS/afs_vnop_dirops.c
+++ b/src/afs/VNOPS/afs_vnop_dirops.c
@@ -28,8 +28,6 @@
 #include "afs/nfsclient.h"
 #include "afs/afs_osidnlc.h"
 
-extern afs_rwlock_t afs_xvcache;
-
 /* don't set CDirty in here because RPC is called synchronously */
 
 int
diff --git a/src/afs/VNOPS/afs_vnop_remove.c b/src/afs/VNOPS/afs_vnop_remove.c
index 78521ca..54ef539 100644
--- a/src/afs/VNOPS/afs_vnop_remove.c
+++ b/src/afs/VNOPS/afs_vnop_remove.c
@@ -27,9 +27,6 @@
 #include "afs/afs_osidnlc.h"
 
 
-extern afs_rwlock_t afs_xvcache;
-
-
 static void
 FetchWholeEnchilada(struct vcache *avc, struct vrequest *areq)
 {
diff --git a/src/afs/VNOPS/afs_vnop_symlink.c b/src/afs/VNOPS/afs_vnop_symlink.c
index c9be5f6..6c991fe 100644
--- a/src/afs/VNOPS/afs_vnop_symlink.c
+++ b/src/afs/VNOPS/afs_vnop_symlink.c
@@ -29,8 +29,6 @@
 #include "afs/nfsclient.h"
 #include "afs/afs_osidnlc.h"
 
-extern afs_rwlock_t afs_xvcache;
-
 /* Note: There is the bare bones beginning of symlink hints in the now
  * defunct afs/afs_lookup.c file. Since they are not in use, making the call
  * is just a performance hit.
From 209eb92448001e59525413610356070d8e4f10a0 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Mon, 06 Jun 2022 12:27:43 -0600
Subject: [PATCH] afs: introduce afs_alloc_ncr/afs_free_ncr

There is duplicated code for initializing a nocache_read_request
and also freeing the associated storage in certain cases.  Create a set
of helper functions that allocates and frees a nocache_read_request and
its associated structures.

afs_alloc_ncr allocates a nocache_read_request structure and if not
UKERNEL, will allocate and initialize the associated uio and iovec
structures.

afs_free_ncr releases a noncache_read_request structure and the
associated uio and iovec structures if not UKERNEL.

Update locations that allocate/free nocache_read_request structures to
use the new functions.

Change-Id: I80c0b4eb036bcb1223b73f4c1de2c12be362de42
Reviewed-on: https://gerrit.openafs.org/14954
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index c0cc250..b4b1016 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -2537,7 +2537,6 @@
 			   struct list_head *page_list, unsigned num_pages)
 {
     afs_int32 page_ix;
-    struct uio *auio;
     afs_offs_t offset;
     struct iovec* iovecp;
     struct nocache_read_request *ancr;
@@ -2552,20 +2551,10 @@
     afs_int32 page_count = 0;
     afs_int32 isize;
 
-    /* background thread must free: iovecp, auio, ancr */
-    iovecp = osi_Alloc(num_pages * sizeof(struct iovec));
-
-    auio = osi_Alloc(sizeof(struct uio));
-    auio->uio_iov = iovecp;
-    auio->uio_iovcnt = num_pages;
-    auio->uio_flag = UIO_READ;
-    auio->uio_seg = AFS_UIOSYS;
-    auio->uio_resid = num_pages * PAGE_SIZE;
-
-    ancr = osi_Alloc(sizeof(struct nocache_read_request));
-    ancr->auio = auio;
-    ancr->offset = auio->uio_offset;
-    ancr->length = auio->uio_resid;
+    ancr = afs_alloc_ncr(num_pages);
+    if (ancr == NULL)
+	return afs_convert_code(ENOMEM);
+    iovecp = ancr->auio->uio_iov;
 
     afs_lru_cache_init(&lrupages);
 
@@ -2587,7 +2576,7 @@
 
 	if(page_ix == 0) {
 	    offset = page_offset(pp);
-	    ancr->offset = auio->uio_offset = offset;
+	    ancr->offset = ancr->auio->uio_offset = offset;
 	    base_index = pp->index;
 	}
         iovecp[page_ix].iov_len = PAGE_SIZE;
@@ -2626,14 +2615,13 @@
     if(page_count) {
 	afs_lru_cache_finalize(&lrupages);
 	credp = crref();
+	/* background thread frees the ancr */
         code = afs_ReadNoCache(avc, ancr, credp);
 	crfree(credp);
     } else {
         /* If there is nothing for the background thread to handle,
          * it won't be freeing the things that we never gave it */
-        osi_Free(iovecp, num_pages * sizeof(struct iovec));
-        osi_Free(auio, sizeof(struct uio));
-        osi_Free(ancr, sizeof(struct nocache_read_request));
+	afs_free_ncr(&ancr);
     }
     /* we do not flush, release, or unmap pages--that will be
      * done for us by the background thread as each page comes in
@@ -2665,8 +2653,17 @@
     ClearPageError(pp);
 
     /* receiver frees */
-    auio = osi_Alloc(sizeof(struct uio));
-    iovecp = osi_Alloc(sizeof(struct iovec));
+    ancr = afs_alloc_ncr(1);
+    if (ancr == NULL) {
+	SetPageError(pp);
+	return afs_convert_code(ENOMEM);
+    }
+    /*
+     * afs_alloc_ncr has already set the auio->uio_iov, make sure setup_uio
+     * uses the existing value when it sets auio->uio_iov.
+     */
+    auio = ancr->auio;
+    iovecp = auio->uio_iov;
 
     /* address can be NULL, because we overwrite it with 'pp', below */
     setup_uio(auio, iovecp, NULL, page_offset(pp),
@@ -2676,8 +2673,6 @@
     get_page(pp); /* see above */
     auio->uio_iov->iov_base = (void*) pp;
     /* the background thread will free this */
-    ancr = osi_Alloc(sizeof(struct nocache_read_request));
-    ancr->auio = auio;
     ancr->offset = page_offset(pp);
     ancr->length = PAGE_SIZE;
 
diff --git a/src/afs/UKERNEL/afs_usrops.c b/src/afs/UKERNEL/afs_usrops.c
index 2e0b9fe..2d11b44 100644
--- a/src/afs/UKERNEL/afs_usrops.c
+++ b/src/afs/UKERNEL/afs_usrops.c
@@ -2373,12 +2373,16 @@
     }
 
     /* these get freed in PrefetchNoCache, so... */
-    bparms = afs_osi_Alloc(sizeof(struct nocache_read_request));
+    bparms = afs_alloc_ncr(0);
+    if (bparms == NULL) {
+	errno = ENOMEM;
+	return -1;
+    }
 
     code = afs_CreateReq(&bparms->areq, get_user_struct()->u_cred);
     if (code) {
 	afs_DestroyReq(bparms->areq);
-	afs_osi_Free(bparms, sizeof(struct nocache_read_request));
+	afs_free_ncr(&bparms);
 	errno = code;
 	return -1;
     }
diff --git a/src/afs/afs_bypasscache.c b/src/afs/afs_bypasscache.c
index c51bd25..50a0110 100644
--- a/src/afs/afs_bypasscache.c
+++ b/src/afs/afs_bypasscache.c
@@ -113,6 +113,86 @@
 int cache_bypass_prefetch = 1;	/* Should we do prefetching ? */
 
 /*
+ * Allocate and initialize nocache_read_request/uid/iovec.
+ * Returns NULL if there was a memory allocation error.
+ * Note: UKERNEL always passes 0 for the number of pages since the iovec
+ * and the uio are allocated by the caller
+ */
+struct nocache_read_request *
+afs_alloc_ncr(unsigned num_pages)
+{
+    struct nocache_read_request *ancr = NULL;
+#if !defined(UKERNEL)
+    struct uio *auio = NULL;
+    struct iovec *iovecp = NULL;
+#endif
+
+    ancr = osi_Alloc(sizeof(*ancr));
+    if (ancr == NULL)
+	goto error;
+
+#if defined(UKERNEL)
+    osi_Assert(num_pages == 0);
+#else
+    iovecp = osi_Alloc(num_pages * sizeof(*iovecp));
+    if (iovecp == NULL)
+	goto error;
+
+    auio = osi_Alloc(sizeof(*auio));
+    if (auio == NULL)
+	goto error;
+    auio->uio_iov = iovecp;
+    auio->uio_iovcnt = num_pages;
+    auio->uio_flag = UIO_READ;
+    auio->uio_seg = AFS_UIOSYS;
+    auio->uio_offset = 0;
+    auio->uio_resid = num_pages * PAGE_SIZE;
+
+    ancr->auio = auio;
+    ancr->offset = auio->uio_offset;
+    ancr->length = auio->uio_resid;
+#endif
+
+    return ancr;
+
+ error:
+#if !defined(UKERNEL)
+    osi_Free(iovecp, num_pages * sizeof(*iovecp));
+    osi_Free(auio, sizeof(*auio));
+#endif
+    osi_Free(ancr, sizeof(*ancr));
+    return NULL;
+}
+
+/*
+ * Free a nocache_read_request and associated structures
+ * Note: UKERNEL the iovec and uio structures are managed by the caller
+ */
+void
+afs_free_ncr(struct nocache_read_request **a_ancr)
+{
+    struct nocache_read_request *ancr = *a_ancr;
+#if !defined(UKERNEL)
+    struct uio *auio;
+    struct iovec *aiovec;
+#endif
+
+    if (ancr == NULL)
+	return;
+
+#if !defined(UKERNEL)
+    auio = ancr->auio;
+    if (auio != NULL) {
+	aiovec = auio->uio_iov;
+	osi_Free(aiovec, auio->uio_iovcnt * sizeof(*aiovec));
+    }
+    osi_Free(auio, sizeof(*auio));
+#endif
+    osi_Free(ancr, sizeof(*ancr));
+    *a_ancr = NULL;
+}
+
+/*
  * This is almost exactly like the PFlush() routine in afs_pioctl.c,
  * but that routine is static.  We are about to change a file from
  * normal caching to bypass it's caching.  Therefore, we want to
@@ -517,10 +597,7 @@
     AFS_GLOCK();
     afs_DestroyReq(areq);
     AFS_GUNLOCK();
-    osi_Free(bparms->auio->uio_iov,
-	     bparms->auio->uio_iovcnt * sizeof(struct iovec));
-    osi_Free(bparms->auio, sizeof(struct uio));
-    osi_Free(bparms, sizeof(struct nocache_read_request));
+    afs_free_ncr(&bparms);
     return code;
 }
 
@@ -647,12 +724,7 @@
 
     afs_DestroyReq(areq);
     osi_Free(tcallspec, sizeof(struct tlocal1));
-    osi_Free(bparms, sizeof(struct nocache_read_request));
-#ifndef UKERNEL
-    /* in UKERNEL, the "pages" are passed in */
-    osi_Free(iovecp, auio->uio_iovcnt * sizeof(struct iovec));
-    osi_Free(auio, sizeof(struct uio));
-#endif
+    afs_free_ncr(&bparms);
     return code;
 }
 #endif
diff --git a/src/afs/afs_bypasscache.h b/src/afs/afs_bypasscache.h
index 2cda654..11f5464 100644
--- a/src/afs/afs_bypasscache.h
+++ b/src/afs/afs_bypasscache.h
@@ -103,7 +103,8 @@
 extern int cache_bypass_prefetch;
 extern int cache_bypass_strategy;
 extern afs_size_t cache_bypass_threshold;
-
+struct nocache_read_request *afs_alloc_ncr(unsigned num_pages);
+void afs_free_ncr(struct nocache_read_request **ancr);
 void afs_TransitionToBypass(struct vcache *, afs_ucred_t *, int);
 void afs_TransitionToCaching(struct vcache *, afs_ucred_t *, int);
 
From 44e24ae5d7dc41e54d23638d5f64ab2e81e43ad0 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 09 Jun 2022 13:20:02 -0600
Subject: [PATCH] afs: introduce get_dcache_readahead

Relocate the block of code that obtains the dcache for a readahead
operation from the afs_linux_readpages function into its own static
function.

Change-Id: Iaaf9523532e292a1f2426d5ced65ddfbceb5d060
Reviewed-on: https://gerrit.openafs.org/14962
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index b4b1016..6bf0019 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -2734,6 +2734,81 @@
     return code;
 }
 
+/*
+ * Updates the adc and acacheFp parameters
+ * Returns:
+ *    0 - success
+ *   -1 - problem getting inode or no mapping function
+ */
+static int
+get_dcache_readahead(struct dcache **adc, struct file **acacheFp,
+		     struct vcache *avc, loff_t offset)
+{
+    struct dcache *tdc = *adc;
+    struct file *cacheFp = *acacheFp;
+    int code;
+
+    if (tdc != NULL && tdc->f.chunk != AFS_CHUNK(offset)) {
+	AFS_GLOCK();
+	ReleaseReadLock(&tdc->lock);
+	afs_PutDCache(tdc);
+	AFS_GUNLOCK();
+	tdc = NULL;
+	if (cacheFp != NULL) {
+	    filp_close(cacheFp, NULL);
+	    cacheFp = NULL;
+	}
+    }
+
+    if (tdc == NULL) {
+	AFS_GLOCK();
+	tdc = afs_FindDCache(avc, offset);
+	if (tdc != NULL) {
+	    ObtainReadLock(&tdc->lock);
+	    if (!afs_IsDCacheFresh(tdc, avc) ||
+		(tdc->dflags & DFFetching) != 0) {
+		ReleaseReadLock(&tdc->lock);
+		afs_PutDCache(tdc);
+		tdc = NULL;
+	    }
+	}
+	AFS_GUNLOCK();
+	if (tdc != NULL) {
+	    cacheFp = afs_linux_raw_open(&tdc->f.inode);
+	    if (cacheFp == NULL) {
+		/* Problem getting the inode */
+		code = -1;
+		goto out;
+	    }
+	    if (cacheFp->f_dentry->d_inode->i_mapping->a_ops->readpage == NULL) {
+		cachefs_noreadpage = 1;
+		/* No mapping function */
+		code = -1;
+		goto out;
+	    }
+	}
+    }
+    code = 0;
+
+ out:
+    if (code != 0) {
+	if (cacheFp != NULL) {
+	    filp_close(cacheFp, NULL);
+	    cacheFp = NULL;
+	}
+	if (tdc != NULL) {
+	    AFS_GLOCK();
+	    ReleaseReadLock(&tdc->lock);
+	    afs_PutDCache(tdc);
+	    AFS_GUNLOCK();
+	    tdc = NULL;
+	}
+    }
+    *adc = tdc;
+    *acacheFp = cacheFp;
+    return code;
+}
+
 /* Readpages reads a number of pages for a particular file. We use
  * this to optimise the reading, by limiting the number of times upon which
  * we have to lookup, lock and open vcaches and dcaches
@@ -2783,42 +2858,9 @@
 	list_del(&page->lru);
 	offset = page_offset(page);
 
-	if (tdc && tdc->f.chunk != AFS_CHUNK(offset)) {
-	    AFS_GLOCK();
-	    ReleaseReadLock(&tdc->lock);
-	    afs_PutDCache(tdc);
-	    AFS_GUNLOCK();
-	    tdc = NULL;
-	    if (cacheFp) {
-		filp_close(cacheFp, NULL);
-		cacheFp = NULL;
-	    }
-	}
-
-	if (!tdc) {
-	    AFS_GLOCK();
-	    if ((tdc = afs_FindDCache(avc, offset))) {
-		ObtainReadLock(&tdc->lock);
-		if (!afs_IsDCacheFresh(tdc, avc) ||
-		    (tdc->dflags & DFFetching)) {
-		    ReleaseReadLock(&tdc->lock);
-		    afs_PutDCache(tdc);
-		    tdc = NULL;
-		}
-	    }
-	    AFS_GUNLOCK();
-	    if (tdc) {
-		cacheFp = afs_linux_raw_open(&tdc->f.inode);
-		if (cacheFp == NULL) {
-		    /* Problem getting the inode */
-		    goto out;
-		}
-		if (!cacheFp->f_dentry->d_inode->i_mapping->a_ops->readpage) {
-		    cachefs_noreadpage = 1;
-		    goto out;
-		}
-	    }
-	}
+	code = get_dcache_readahead(&tdc, &cacheFp, avc, offset);
+	if (code != 0)
+	    goto out;
 
 	if (tdc && !add_to_page_cache(page, mapping, page->index,
 				      GFP_KERNEL)) {
From 0497b0cd7bffb6335ab9bcbf5a1310b8c6a4b299 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Mon, 06 Jun 2022 12:32:19 -0600
Subject: [PATCH] Linux-5.18: replace readpages with readahead

The linux 5.18 the commit 'fs: Remove ->readpages address space
operation' (704528d8) removes the address_space_operations operation
"readpages" which is replaced with the "readahead" operation
that was introduced with the 5.8 commit 'mm: add readahead address
space operation' (8151b4c8).

The address_space_operation function, readahead is called by the VM
to read pages.  A filesystem provides an implementation to handle this
operation.

When readahead is called, the list of pages have already been added to
the lru caches and are locked.  The implementation of the readahead
function needs to handle decrementing the reference count, unlocking the
page and setting PageUptoDate when the IO has completed successfully. IO
errors are ignored by the vfs during readahead (errors will be detected
later in the vfs processing). We must simply unlock the page if an error
occurs.
  (See Linux Documentation/filesystems/vfs.rst)

Add an autoconf test to detect the presence of 'readahead' in the
address_space_operations structure.

For the implementation of readahead (which is contained in Linux's
osi_vnodeops.c):

Add new functions 'afs_linux_bypass_readahead' and 'afs_linux_readahead'
as replacements for 'afs_bypass_readpages' and 'afs_linux_readpages'
when the linux kernel supports the readahead operation.

Don't manage the LRU for pages for the readahead case (e.g. don't
call the afs_lru_cache_* functions).

Notes:
  In afs_linux_bypass_readahead, the pages are already locked and are
  already in the page cache, we just need to place the page into the
  iovecp.  The page's refcount will be decremented and will be unlocked
  when processing the read request.

  In afs_linux_readahead, the lrupages is needed in case a page is added
  to the cachefp's mapping in afs_linux_read_cache (which also handles
  unlocking the page).  Failure to unlock the page if there was no tdc
  results in the read process waiting on that page.

Change-Id: I6960a2fc14df85869c373f3e3afbf3ee5eb7228f
---

diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 6bf0019..7013131 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -2532,6 +2532,92 @@
 
 }
 
+#if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD)
+static void
+afs_linux_bypass_readahead(struct readahead_control *rac)
+{
+    struct file *fp = rac->file;
+    unsigned num_pages = readahead_count(rac);
+    afs_int32 page_ix;
+    afs_offs_t offset;
+    struct iovec* iovecp;
+    struct nocache_read_request *ancr;
+    struct page *pp;
+
+    afs_int32 code = 0;
+
+    cred_t *credp;
+    struct inode *ip = FILE_INODE(fp);
+    struct vcache *avc = VTOAFS(ip);
+    afs_int32 base_index = 0;
+    afs_int32 page_count = 0;
+    afs_int32 isize;
+
+    /* background thread must free: iovecp, auio, ancr */
+    ancr = afs_alloc_ncr(num_pages);
+    if (ancr == NULL)
+	goto error;
+
+    iovecp = ancr->auio->uio_iov;
+
+    for (page_ix = 0; page_ix < num_pages; ++page_ix) {
+	pp = readahead_page(rac);
+	if (pp == NULL)
+	    break;
+
+	isize = (i_size_read(fp->f_mapping->host) - 1) >> PAGE_SHIFT;
+	if (pp->index > isize) {
+	    if (PageLocked(pp))
+		unlock_page(pp);
+	    continue;
+	}
+
+	if (page_ix == 0) {
+	    offset = page_offset(pp);
+	    ancr->offset = ancr->auio->uio_offset = offset;
+	    base_index = pp->index;
+	}
+	iovecp[page_ix].iov_len = PAGE_SIZE;
+	if (base_index != pp->index) {
+	    if (PageLocked(pp))
+		 unlock_page(pp);
+	    put_page(pp);
+	    iovecp[page_ix].iov_base = NULL;
+	    base_index++;
+	    ancr->length -= PAGE_SIZE;
+	    continue;
+	}
+	base_index++;
+	page_count++;
+	/* save the page for background map */
+	iovecp[page_ix].iov_base = pp;
+    }
+
+    /* If there were useful pages in the page list, schedule
+     * the read */
+    if (page_count > 0) {
+	credp = crref();
+	code = afs_ReadNoCache(avc, ancr, credp);
+	crfree(credp);
+    } else {
+	/* If there is nothing for the background thread to handle,
+         * it won't be freeing the things that we never gave it */
+	afs_free_ncr(&ancr);
+    }
+    /* we do not flush, release, or unmap pages--that will be
+     * done for us by the background thread as each page comes in
+     * from the fileserver */
+    return;
+
+ error:
+    while ((pp = readahead_page(rac)) != NULL) {
+	if (PageLocked(pp)) {
+	    unlock_page(pp);
+	}
+    }
+    return;
+}
+#else /* STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD */
 static int
 afs_linux_bypass_readpages(struct file *fp, struct address_space *mapping,
 			   struct list_head *page_list, unsigned num_pages)
@@ -2628,7 +2714,7 @@
      * from the fileserver */
     return afs_convert_code(code);
 }
-
+#endif /* STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD */
 
 static int
 afs_linux_bypass_readpage(struct file *fp, struct page *pp)
@@ -2809,11 +2895,107 @@
     return code;
 }
 
+#if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD)
+/*
+ * Readahead reads a number of pages for a particular file. We use
+ * this to optimise the reading, by limiting the number of times upon which
+ * we have to lookup, lock and open vcaches and dcaches
+ */
+static void
+afs_linux_readahead(struct readahead_control *rac)
+{
+    struct page *page;
+    struct address_space *mapping = rac->mapping;
+    struct inode *inode = mapping->host;
+    struct vcache *avc = VTOAFS(inode);
+    struct dcache *tdc;
+    struct file *cacheFp = NULL;
+    int code = 0;
+    loff_t offset;
+    struct afs_lru_pages lrupages;
+    struct afs_pagecopy_task *task;
+
+    if (afs_linux_bypass_check(inode)) {
+	afs_linux_bypass_readahead(rac);
+	return;
+    }
+    if (cacheDiskType == AFS_FCACHE_TYPE_MEM)
+	return;
+
+    /* No readpage (ex: tmpfs) , skip */
+    if (cachefs_noreadpage)
+	return;
+
+    AFS_GLOCK();
+    code = afs_linux_VerifyVCache(avc, NULL);
+    if (code != 0) {
+	AFS_GUNLOCK();
+	return;
+    }
+
+    ObtainWriteLock(&avc->lock, 912);
+    AFS_GUNLOCK();
+
+    task = afs_pagecopy_init_task();
+
+    tdc = NULL;
+
+    afs_lru_cache_init(&lrupages);
+
+    while ((page = readahead_page(rac)) != NULL) {
+	offset = page_offset(page);
+
+	code = get_dcache_readahead(&tdc, &cacheFp, avc, offset);
+	if (code != 0)
+	    goto error;
+
+	if (tdc != NULL) {
+	    /* Note that add_to_page_cache() locked 'page'.
+	     * afs_linux_read_cache() is guaranteed to handle unlocking it. */
+	    afs_linux_read_cache(cacheFp, page, tdc->f.chunk, &lrupages, task);
+	} else if (PageLocked(page)) {
+	    unlock_page(page);
+	}
+	put_page(page);
+    }
+    afs_lru_cache_finalize(&lrupages);
+
+ done:
+    if (cacheFp != NULL)
+	filp_close(cacheFp, NULL);
+
+    afs_pagecopy_put_task(task);
+
+    AFS_GLOCK();
+    if (tdc != NULL) {
+	ReleaseReadLock(&tdc->lock);
+	afs_PutDCache(tdc);
+    }
+
+    ReleaseWriteLock(&avc->lock);
+    AFS_GUNLOCK();
+    return;
+
+ error:
+    /*
+     * Any error detected during readahead are ignored by the vfs.
+     * Simply unlock the page(s).
+     */
+    if (PageLocked(page)) {
+	unlock_page(page);
+    }
+    while ((page = readahead_page(rac)) != NULL) {
+	if (PageLocked(page)) {
+	    unlock_page(page);
+	}
+    }
+    goto done;
+}
+#else /* STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD */
 /* Readpages reads a number of pages for a particular file. We use
  * this to optimise the reading, by limiting the number of times upon which
  * we have to lookup, lock and open vcaches and dcaches
  */
-
 static int
 afs_linux_readpages(struct file *fp, struct address_space *mapping,
 		    struct list_head *page_list, unsigned int num_pages)
@@ -2890,6 +3072,7 @@
     AFS_GUNLOCK();
     return 0;
 }
+#endif /* STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD */
 
 /* Prepare an AFS vcache for writeback. Should be called with the vcache
  * locked */
@@ -3328,7 +3511,11 @@
 
 static struct address_space_operations afs_file_aops = {
   .readpage =		afs_linux_readpage,
+#if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD)
+  .readahead =		afs_linux_readahead,
+#else
   .readpages = 		afs_linux_readpages,
+#endif
   .writepage =		afs_linux_writepage,
 #if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_DIRTY_FOLIO)
   .dirty_folio =	block_dirty_folio,
diff --git a/src/cf/linux-kernel-struct.m4 b/src/cf/linux-kernel-struct.m4
index 2d8cee6..597289b 100644
--- a/src/cf/linux-kernel-struct.m4
+++ b/src/cf/linux-kernel-struct.m4
@@ -5,6 +5,8 @@
                       [write_begin], [fs.h])
 dnl linux 5.18 replaced set_page_dirty with dirty_folio
 AC_CHECK_LINUX_STRUCT([address_space_operations], [dirty_folio], [fs.h])
+dnl linux 5.18 replaced readpages with readahead (introduced in 5.8)
+AC_CHECK_LINUX_STRUCT([address_space_operations], [readahead], [fs.h])
 AC_CHECK_LINUX_STRUCT([backing_dev_info], [name],
                       [backing-dev.h])
 AC_CHECK_LINUX_STRUCT([cred], [session_keyring], [cred.h])
From 660e9e4fb2699da88f93ea6a44007b29220fa93f Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Tue, 07 Jun 2022 11:14:55 -0600
Subject: [PATCH] lwp: Ignore dangling-pointer warning in process.c

In lwp/process.c the address of a stack variable is saved as part of
creating a new context.  GCC-12 is flagging the statement with a
diagnostic:

  ./process.c:46:24: error: storing the address of local variable
      ‘stackvar’ in ‘*savearea.topstack’ [-Werror=dangling-pointer=]
   46 |     savearea->topstack = (char *)&stackvar;
      |     ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~

In this particular case, the code is meaning to save the address of the
stack in preparation of setting up a new context, which requires knowing
the address the current stack.

The diagnostic is changed from a warning to an error when configured
with --enable-checking.

Set the env variable CFLAGS_NODANGLING_POINTER to
'-Wno-dangling-pointer' if the compiler supports the option and update
the src/lwp/Makefile.in to use the flag when compiling process.c

Change-Id: Ibec956b505c0edad9b74d63b9bb7805f6f0cba01
---

diff --git a/CODING b/CODING
index fef643d..e0a81f8 100644
--- a/CODING
+++ b/CODING
@@ -351,4 +351,6 @@
                                        function _heim_time2generalizedtime, the
                                        two snprintf calls raise
                                        format-truncation warnings due to the
-                                       arithmetic on tm_year and tm_mon fields
\ No newline at end of file
+                                       arithmetic on tm_year and tm_mon fields
+lwp/process.c        : dangling-pointer : Ignore the legitimate use of saving
+                                       the address of a stack variable
diff --git a/src/cf/osconf.m4 b/src/cf/osconf.m4
index 2805ab6..482d5ad 100644
--- a/src/cf/osconf.m4
+++ b/src/cf/osconf.m4
@@ -631,6 +631,7 @@
 CFLAGS_NOOLDSTYLE=
 CFLAGS_NOIMPLICIT_FALLTHROUGH=
 CFLAGS_NOCAST_FUNCTION_TYPE=
+CFLAGS_NODANGLING_POINTER=
 XCFLAGS_NOCHECKING="$XCFLAGS"
 
 if test "x$GCC" = "xyes"; then
@@ -648,6 +649,8 @@
 			      [CFLAGS_NOIMPLICIT_FALLTHROUGH], [-Werror])
       AX_APPEND_COMPILE_FLAGS([-Wno-cast-function-type],
 			      [CFLAGS_NOCAST_FUNCTION_TYPE], [-Werror])
+      AX_APPEND_COMPILE_FLAGS([-Wno-dangling-pointer],
+			      [CFLAGS_NODANGLING_POINTER], [-Werror])
       AC_DEFINE(IGNORE_SOME_GCC_WARNINGS, 1, [define to disable some gcc warnings in warnings-as-errors mode])
     else
       CFLAGS_NOSTRICT=
@@ -732,6 +735,7 @@
 AC_SUBST(CFLAGS_NOOLDSTYLE)
 AC_SUBST(CFLAGS_NOIMPLICIT_FALLTHROUGH)
 AC_SUBST(CFLAGS_NOCAST_FUNCTION_TYPE)
+AC_SUBST(CFLAGS_NODANGLING_POINTER)
 AC_SUBST(CFLAGS_WERROR)
 AC_SUBST(XCFLAGS64)
 AC_SUBST(XLDFLAGS)
diff --git a/src/lwp/Makefile.in b/src/lwp/Makefile.in
index 39d7402..7a54196 100644
--- a/src/lwp/Makefile.in
+++ b/src/lwp/Makefile.in
@@ -60,6 +60,7 @@
 # Making process.o for $(SYS_NAME)
 # The files "process.s" and "process.S" may be used internally,
 # but will be removed after building the .o
+CFLAGS_process.o = @CFLAGS_NODANGLING_POINTER@
 process.o	: process.default.s process.i386.s process.amd64.s process.c lwp.o
 	@set -x; case "$(SYS_NAME)" in \
 	sun4c_51 | sun4c_52 | sun4m_51 | sun4m_52 | sun4c_53 | sun4m_53  | sun4_53 | sun4_52 | sun4_54 | sun4c_54 | sun4m_54 | sun4x_5* | arm_linux* ) \
From 1c969d4d8aab2410f3652073b2248b7bce29b928 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 16 Jun 2022 14:03:40 -0600
Subject: [PATCH] afs: Avoid always-false NULL test on AFSTOV(avc)

GCC-12 is flagging a comparison with the following diagnostic:

 src/afs/afs_vcache.c:3161:25: error: the comparison will always
    evaluate as ‘false’ for the address of ‘v’ will never be NULL
    [-Werror=address]
 3161 |             AFSTOV(avc) == NULL || vType(avc) == VDIR ||
      |                         ^~

When the vcache structure does not have the vnode embedded the expansion
of the AFSTOV macro results in:
   ((avc)->v)
which tests contents of a 'v'.

When the vcache structure does have the vnode embedded, the expansion of
the macro results in:
   (&(avc)->v)
which tests the address of 'v', which will never be NULL in this case.

Update afs.h to add a new define 'AFS_VCACHE_EMBEDDED_VNODE' when the
vcache structure contains an embedded vnode structure.

When the vcache does not have an embedded vnode, define a macro
AFSV_IS_NULL(x) that expands to:
 ((x)->v == NULL)
If the vcache does have an embedded vnode, the macro will expand to just
a constant 0.

Note, the diagnostic message is changed from a warning to an error when
configured with --enable-checking.

Change-Id: Ib72647fa23e5a7ecd96772b04c6ef76540f44535
---

diff --git a/src/afs/afs.h b/src/afs/afs.h
index 370b708..ef01afd 100644
--- a/src/afs/afs.h
+++ b/src/afs/afs.h
@@ -777,6 +777,7 @@
 
 extern afs_int32 vmPageHog;	/* counter for # of vnodes which are page hogs. */
 
+#define AFSV_IS_NULL(v) ((v) == NULL)
 #if defined(AFS_DARWIN80_ENV)
 #define VTOAFS(v) ((struct vcache *)vnode_fsnode((v)))
 #define AFSTOV(vc) ((vc)->v)
@@ -791,8 +792,11 @@
 #define VTOAFS(v) ((struct vcache *)(v)->v_data)
 #define AFSTOV(vc) ((vc)->v)
 #else
+#define AFS_VCACHE_EMBEDDED_VNODE
 #define VTOAFS(V) ((struct vcache *)(V))
 #define AFSTOV(V) (&(V)->v)
+#undef AFSV_IS_NULL
+#define AFSV_IS_NULL(v) 0
 #endif
 
 struct afs_vnuniq {
@@ -861,10 +865,10 @@
  * !(avc->nextfree) && !avc->vlruq.next => (FreeVCList == avc->nextfree)
  */
 struct vcache {
-#if defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_SUN511_ENV) || (defined(AFS_LINUX_ENV) && !defined(STRUCT_SUPER_OPERATIONS_HAS_ALLOC_INODE))
-    struct vnode *v;
-#else
+#if defined(AFS_VCACHE_EMBEDDED_VNODE)
     struct vnode v;		/* Has reference count in v.v_count */
+#else
+    struct vnode *v;
 #endif
     struct afs_q vlruq;		/* lru q next and prev */
 #if !defined(AFS_LINUX_ENV)
diff --git a/src/afs/afs_vcache.c b/src/afs/afs_vcache.c
index d48a297..f8ee37b 100644
--- a/src/afs/afs_vcache.c
+++ b/src/afs/afs_vcache.c
@@ -3158,7 +3158,7 @@
 
     if (do_dnlc) {
 	if ((avc->f.fid.Fid.Vnode & 1) ||
-	    AFSTOV(avc) == NULL || vType(avc) == VDIR ||
+	    AFSV_IS_NULL(AFSTOV(avc)) || vType(avc) == VDIR ||
 	    (avc->f.states & CForeign)) {
 	    /* This vcache is (or could be) a directory. */
 	    osi_dnlc_purgedp(avc);
From cc1724e6f5a8f485197aba6246c909869e58d0b2 Mon Sep 17 00:00:00 2001
From: Perry Ruiter <pruiter@sinenomine.net>
Date: Thu, 23 Apr 2015 21:33:27 -0700
Subject: [PATCH] afsd: Improve syscall tracing

When afsd is started with the -debug flag, extensive debug output is
generated including tracing for each syscall.  Unfortunately the
existing syscall tracing is not especially helpful.  It dumps out two
constants that we already knew at compile time, the first parameter of
the syscall along with the syscall's return code.  Specifically it does
not tell you which syscall is currently being traced.  Here's a current
example of afsd -debug:

    afsd: cacheFiles autotuned to 581250
    afsd: dCacheSize autotuned to 10000
    afsd: cacheStatEntries autotuned to 15000
    SScall(183, 28, 6860800)=0
    SScall(183, 28, -847416368)=0
    SScall(183, 28, 1)=0
    afsd: Forking rx listener daemon.
    afsd: Forking rx callback listener.
    afsd: Forking rxevent daemon.
    SScall(183, 28, 0)=0
    SScall(183, 28, 1)=0
    ...

This patch drops the compile time constants (183 and 28 in the above
sample output) and replaces them with the name of the syscall being
traced.  Additionally the first parameter to a syscall is as likely to
be an address as a decimal value so display it in hex. Here's an example
of afsd -debug with these changes:

    afsd: cacheFiles autotuned to 581250
    afsd: dCacheSize autotuned to 10000
    afsd: cacheStatEntries autotuned to 15000
    os_syscall(AFSOP_SET_THISCELL, 0x68bf80)=0
    os_syscall(AFSOP_SEED_ENTROPY, 0x7fff9ce40c10)=0
    os_syscall(AFSOP_ADVISEADDR, 0x1)=0
    afsd: Forking rx listener daemon.
    afsd: Forking rx callback listener.
    afsd: Forking rxevent daemon.
    os_syscall(AFSOP_RXEVENT_DAEMON, 0x0)=0
    os_syscall(AFSOP_BASIC_INIT, 0x1)=0
    ...

[mmeffie@sinenomine.net: avoid c99 array initialization.]

Change-Id: I4f3d46d420d19abeddbf719efa04aef7e553d51f
Reviewed-on: https://gerrit.openafs.org/11858
Tested-by: Mark Vitale <mvitale@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
---

diff --git a/src/afsd/afsd_kernel.c b/src/afsd/afsd_kernel.c
index 093ba5c..71de913 100644
--- a/src/afsd/afsd_kernel.c
+++ b/src/afsd/afsd_kernel.c
@@ -124,6 +124,72 @@
 # endif
 #endif
 
+static char *afsd_syscalls[AFSOP_MAX_OPCODE + 1]; /* For syscall tracing. */
+
+static void
+afsd_init_syscall_opcodes(void)
+{
+#define add_opcode(x) afsd_syscalls[x] = #x
+    add_opcode(AFSOP_START_RXCALLBACK);
+    add_opcode(AFSOP_START_AFS);
+    add_opcode(AFSOP_START_BKG);
+    add_opcode(AFSOP_START_TRUNCDAEMON);
+    add_opcode(AFSOP_START_CS);
+    add_opcode(AFSOP_ADDCELL);
+    add_opcode(AFSOP_CACHEINIT);
+    add_opcode(AFSOP_CACHEINFO);
+    add_opcode(AFSOP_VOLUMEINFO);
+    add_opcode(AFSOP_CACHEFILE);
+    add_opcode(AFSOP_CACHEINODE);
+    add_opcode(AFSOP_AFSLOG);
+    add_opcode(AFSOP_ROOTVOLUME);
+    add_opcode(AFSOP_STARTLOG);
+    add_opcode(AFSOP_ENDLOG);
+    add_opcode(AFSOP_AFS_VFSMOUNT);
+    add_opcode(AFSOP_ADVISEADDR);
+    add_opcode(AFSOP_CLOSEWAIT);
+    add_opcode(AFSOP_RXEVENT_DAEMON);
+    add_opcode(AFSOP_GETMTU);
+    add_opcode(AFSOP_GETIFADDRS);
+    add_opcode(AFSOP_ADDCELL2);
+    add_opcode(AFSOP_AFSDB_HANDLER);
+    add_opcode(AFSOP_SET_DYNROOT);
+    add_opcode(AFSOP_ADDCELLALIAS);
+    add_opcode(AFSOP_SET_FAKESTAT);
+    add_opcode(AFSOP_CELLINFO);
+    add_opcode(AFSOP_SET_THISCELL);
+    add_opcode(AFSOP_BASIC_INIT);
+    add_opcode(AFSOP_SET_BACKUPTREE);
+    add_opcode(AFSOP_SET_RXPCK);
+    add_opcode(AFSOP_BUCKETPCT);
+    add_opcode(AFSOP_SET_RXMAXMTU);
+    add_opcode(AFSOP_BKG_HANDLER);
+    add_opcode(AFSOP_GETMASK);
+    add_opcode(AFSOP_SET_RXMAXFRAGS);
+    add_opcode(AFSOP_SET_RMTSYS_FLAG);
+    add_opcode(AFSOP_SEED_ENTROPY);
+    add_opcode(AFSOP_SET_INUMCALC);
+    add_opcode(AFSOP_RXLISTENER_DAEMON);
+    add_opcode(AFSOP_CACHEBASEDIR);
+    add_opcode(AFSOP_CACHEDIRS);
+    add_opcode(AFSOP_CACHEFILES);
+    add_opcode(AFSOP_SETINT);
+    add_opcode(AFSOP_GO);
+    add_opcode(AFSOP_CHECKLOCKS);
+    add_opcode(AFSOP_SHUTDOWN);
+    add_opcode(AFSOP_STOP_RXCALLBACK);
+    add_opcode(AFSOP_STOP_AFS);
+    add_opcode(AFSOP_STOP_BKG);
+    add_opcode(AFSOP_STOP_TRUNCDAEMON);
+    /* AFSOP_STOP_RXEVENT -- not a syscall opcode */
+    /* AFSOP_STOP_COMPLETE -- not a syscall opcode */
+    add_opcode(AFSOP_STOP_CS);
+    /* AFSOP_STOP_RXK_LISTENER -- not a syscall opcode */
+    add_opcode(AFSOP_STOP_AFSDB);
+    add_opcode(AFSOP_STOP_NETIF);
+#undef add_opcode
+}
+
 void
 afsd_set_rx_rtpri(void)
 {
@@ -274,19 +340,36 @@
     error = os_syscall(args);
 
     if (afsd_debug) {
+	char *opcode;
+	char buffer[32];
         const char *syscall_str;
+
 #if defined(AFS_SYSCALL)
         syscall_str = AFS_STRINGIZE(AFS_SYSCALL);
 #else
         syscall_str = "[AFS_SYSCALL]";
 #endif
+
+	if ((args->syscall < 0) ||
+	    (args->syscall >= (sizeof(afsd_syscalls) / sizeof(*afsd_syscalls))))
+	    opcode = NULL;
+	else
+	    opcode = afsd_syscalls[args->syscall];
+
+	if (opcode == NULL) {
+	    snprintf(buffer, sizeof(buffer), "unknown (%d)", args->syscall);
+	    opcode = buffer;
+	}
+
 	if (error == -1) {
 	    char *s = strerror(errno);
-	    printf("SScall(%s, %d, %d)=%d (%d, %s)\n", syscall_str, AFSCALL_CALL,
-		   (int)args->params[0], error, errno, s);
+	    printf("os_syscall(%s, %d, %s, 0x%lx)=%d (%d, %s)\n",
+		    syscall_str, AFSCALL_CALL, opcode,
+		   (long)args->params[0], error, errno, s);
 	} else {
-	    printf("SScall(%s, %d, %d)=%d\n", syscall_str, AFSCALL_CALL,
-		   (int)args->params[0], error);
+	    printf("os_syscall(%s %d %s, 0x%lx)=%d\n",
+		    syscall_str, AFSCALL_CALL, opcode,
+		   (long)args->params[0], error);
 	}
     }
 
@@ -573,6 +656,7 @@
 {
     int code;
 
+    afsd_init_syscall_opcodes();
     afsd_init();
 
     code = afsd_parse(argc, argv);
diff --git a/src/config/afs_args.h b/src/config/afs_args.h
index dd90b80..ae7d2d7 100644
--- a/src/config/afs_args.h
+++ b/src/config/afs_args.h
@@ -12,6 +12,9 @@
 
 /*
  * AFS system call opcodes
+ *
+ * When adding new opcodes, please also update afsd_init_syscall_opcodes()
+ * for syscall tracing.
  */
 
 #define AFSOP_START_RXCALLBACK	  0	/* no aux parms */
From 2b90a73b1bf4bf76d409a6e02bb2a6d1b901a062 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Tue, 07 Jun 2022 12:15:20 -0600
Subject: [PATCH] opr: replace AFS_STRINGIZE with opr_stringize

To avoid adding new includes for afs/afsutil.h in order to use
'AFS_STRINGIZE', create a replacement, 'opr_stringize', in afs/opr.h.

Replace the usage of 'AFS_STRINGIZE' with opr_stringize and remove the
definition of 'AFS_STRINGIZE'

Change-Id: I6d12ed101b6f9246a59c46024c216c7fe25bc1c8
---

diff --git a/src/afsd/afsd_kernel.c b/src/afsd/afsd_kernel.c
index c45c64f..94f1a32 100644
--- a/src/afsd/afsd_kernel.c
+++ b/src/afsd/afsd_kernel.c
@@ -9,6 +9,7 @@
 
 #include <afsconfig.h>
 #include <afs/param.h>
+#include <afs/opr.h>
 
 #include <roken.h>
 
@@ -77,8 +78,6 @@
 #include <afs/afs_args.h>
 #include <afs/cellconfig.h>
 #include <afs/afssyscalls.h>
-#include <afs/afsutil.h>
-
 #ifdef AFS_DARWIN_ENV
 #ifdef AFS_DARWIN80_ENV
 #include <sys/xattr.h>
@@ -346,7 +345,7 @@
         const char *syscall_str;
 
 #if defined(AFS_SYSCALL)
-        syscall_str = AFS_STRINGIZE(AFS_SYSCALL);
+	syscall_str = opr_stringize(AFS_SYSCALL);
 #else
         syscall_str = "[AFS_SYSCALL]";
 #endif
diff --git a/src/opr/opr.h b/src/opr/opr.h
index 8970c92..748d16c 100644
--- a/src/opr/opr.h
+++ b/src/opr/opr.h
@@ -9,6 +9,11 @@
 
 /* assert.c */
 
+/* A simple macro to help show the value of #define'd constants. e.g. If 'FOO'
+ * is defined as 5, then opt_stringize(FOO) expands to "5" */
+#define opr_stringize_(s) #s
+#define opr_stringize(s) opr_stringize_(s)
+
 #ifdef AFS_NT40_ENV
 # define opr_abort() opr_NTAbort()
 extern void opr_NTAbort(void);
diff --git a/src/util/afsutil.h b/src/util/afsutil.h
index bbebcc1..bd78946 100644
--- a/src/util/afsutil.h
+++ b/src/util/afsutil.h
@@ -121,11 +121,6 @@
 /* b64_string_t is 8 bytes, in stds.h */
      typedef char lb64_string_t[12];
 
-/* A simple macro to help show the value of #define'd constants. e.g. If 'FOO'
- * is defined as 5, then AFS_STRINGIZE(FOO) expands to "5" */
-#define AFS_STRINGIZE_(s) #s
-#define AFS_STRINGIZE(s) AFS_STRINGIZE_(s)
-
 #include <afs/ktime.h>
 #include "afsutil_prototypes.h"
 
From e34c73390b9740a2b4835dbcf6f8d3d34459fc55 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Tue, 07 Jun 2022 12:19:44 -0600
Subject: [PATCH] Prevent sscanf format widths from overrunning array

cppcheck noted these instances of sscanf could wipe out the ending null
terminator.  Length is now macro expanded rather than hard coded and the
array itself is one unit longer to avoid the overrun.

Change-Id: Ic76e1b74701d7fb7b722ba1f8eae3a4d16e91f65
---

diff --git a/src/kauth/kkids.c b/src/kauth/kkids.c
index 979e544..d5437f1 100644
--- a/src/kauth/kkids.c
+++ b/src/kauth/kkids.c
@@ -15,6 +15,7 @@
 #include <afsconfig.h>
 #include <afs/param.h>
 #include <afs/stds.h>
+#include <afs/opr.h>
 
 #include <roken.h>
 
@@ -228,7 +229,7 @@
 ParseAcl(char *astr)
 {
     int nplus, nminus, i, trights;
-    char tname[MAXNAME];
+    char tname[MAXNAME + 1] = "";
     struct AclEntry *first, *last, *tl;
     struct Acl *ta;
     sscanf(astr, "%d", &nplus);
@@ -242,7 +243,7 @@
     last = 0;
     first = 0;
     for (i = 0; i < nplus; i++) {
-	sscanf(astr, "%100s %d", tname, &trights);
+	sscanf(astr, "%" opr_stringize(MAXNAME) "s %d", tname, &trights);
 	SkipLine(astr);
 	tl = malloc(sizeof(struct AclEntry));
 	if (!first)
diff --git a/src/sys/rmtsysnet.c b/src/sys/rmtsysnet.c
index 296145e..da6b3e6 100644
--- a/src/sys/rmtsysnet.c
+++ b/src/sys/rmtsysnet.c
@@ -9,6 +9,7 @@
 
 #include <afsconfig.h>
 #include <afs/param.h>
+#include <afs/opr.h>
 
 #include <roken.h>
 
@@ -65,7 +66,7 @@
 RParseAcl(char *astr)
 {
     int nplus, nminus, i, trights;
-    char tname[MAXNAME];
+    char tname[MAXNAME + 1] = "";
     struct AclEntry *first, *last, *tl;
     struct Acl *ta;
     sscanf(astr, "%d", &nplus);
@@ -80,7 +81,7 @@
     last = 0;
     first = 0;
     for (i = 0; i < nplus; i++) {
-	sscanf(astr, "%100s %d", tname, &trights);
+	sscanf(astr, "%" opr_stringize(MAXNAME) "s %d", tname, &trights);
 	astr = RSkipLine(astr);
 	tl = malloc(sizeof(struct AclEntry));
 	if (!first)
@@ -97,7 +98,7 @@
     last = 0;
     first = 0;
     for (i = 0; i < nminus; i++) {
-	sscanf(astr, "%100s %d", tname, &trights);
+	sscanf(astr, "%" opr_stringize(MAXNAME) "s %d", tname, &trights);
 	astr = RSkipLine(astr);
 	tl = malloc(sizeof(struct AclEntry));
 	if (!first)
diff --git a/src/uss/uss_acl.c b/src/uss/uss_acl.c
index ee945e8..003eff8 100644
--- a/src/uss/uss_acl.c
+++ b/src/uss/uss_acl.c
@@ -17,6 +17,7 @@
  */
 #include <afsconfig.h>
 #include <afs/param.h>
+#include <afs/opr.h>
 
 #include <roken.h>
 
@@ -404,7 +405,7 @@
 {				/*ParseAcl */
 
     int nplus, nminus, i, trights;
-    char tname[MAXNAME];
+    char tname[MAXNAME + 1] = "";
     struct AclEntry *first, *last, *tl;
     struct Acl *ta;
 
@@ -430,7 +431,7 @@
     last = 0;
     first = 0;
     for (i = 0; i < nplus; i++) {
-	sscanf(a_str, "%100s %d", tname, &trights);
+	sscanf(a_str, "%" opr_stringize(MAXNAME) "s %d", tname, &trights);
 	a_str = SkipLine(a_str);
 	tl = malloc(sizeof(struct AclEntry));
 	if (!first)
@@ -450,7 +451,7 @@
     last = 0;
     first = 0;
     for (i = 0; i < nminus; i++) {
-	sscanf(a_str, "%100s %d", tname, &trights);
+	sscanf(a_str, "%" opr_stringize(MAXNAME) "s %d", tname, &trights);
 	a_str = SkipLine(a_str);
 	tl = malloc(sizeof(struct AclEntry));
 	if (!first)
