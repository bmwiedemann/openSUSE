diff --git a/src/base-lu.cc b/src/base-lu.cc
new file mode 100644
--- /dev/null
+++ b/src/base-lu.cc
@@ -0,0 +1,191 @@
+/*
+
+Copyright (C) 1996-2015 John W. Eaton
+Copyright (C) 2009 VZLU Prague
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "base-lu.h"
+
+template <class lu_type>
+base_lu<lu_type>::base_lu (const lu_type& l, const lu_type& u,
+                           const PermMatrix& p)
+  : a_fact (u), l_fact (l), ipvt (p.transpose ().col_perm_vec ())
+{
+  if (l.columns () != u.rows ())
+    (*current_liboctave_error_handler) ("lu: dimension mismatch");
+}
+
+template <class lu_type>
+bool
+base_lu <lu_type> :: packed (void) const
+{
+  return l_fact.dims () == dim_vector ();
+}
+
+template <class lu_type>
+void
+base_lu <lu_type> :: unpack (void)
+{
+  if (packed ())
+    {
+      l_fact = L ();
+      a_fact = U (); // FIXME: sub-optimal
+      ipvt = getp ();
+    }
+}
+
+template <class lu_type>
+lu_type
+base_lu <lu_type> :: L (void) const
+{
+  if (packed ())
+    {
+      octave_idx_type a_nr = a_fact.rows ();
+      octave_idx_type a_nc = a_fact.cols ();
+      octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
+
+      lu_type l (a_nr, mn, lu_elt_type (0.0));
+
+      for (octave_idx_type i = 0; i < a_nr; i++)
+        {
+          if (i < a_nc)
+            l.xelem (i, i) = 1.0;
+
+          for (octave_idx_type j = 0; j < (i < a_nc ? i : a_nc); j++)
+            l.xelem (i, j) = a_fact.xelem (i, j);
+        }
+
+      return l;
+    }
+  else
+    return l_fact;
+}
+
+template <class lu_type>
+lu_type
+base_lu <lu_type> :: U (void) const
+{
+  if (packed ())
+    {
+      octave_idx_type a_nr = a_fact.rows ();
+      octave_idx_type a_nc = a_fact.cols ();
+      octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
+
+      lu_type u (mn, a_nc, lu_elt_type (0.0));
+
+      for (octave_idx_type i = 0; i < mn; i++)
+        {
+          for (octave_idx_type j = i; j < a_nc; j++)
+            u.xelem (i, j) = a_fact.xelem (i, j);
+        }
+
+      return u;
+    }
+  else
+    return a_fact;
+}
+
+template <class lu_type>
+lu_type
+base_lu <lu_type> :: Y (void) const
+{
+  if (! packed ())
+    (*current_liboctave_error_handler)
+      ("lu: Y () not implemented for unpacked form");
+  return a_fact;
+}
+
+template <class lu_type>
+Array<octave_idx_type>
+base_lu <lu_type> :: getp (void) const
+{
+  if (packed ())
+    {
+      octave_idx_type a_nr = a_fact.rows ();
+
+      Array<octave_idx_type> pvt (dim_vector (a_nr, 1));
+
+      for (octave_idx_type i = 0; i < a_nr; i++)
+        pvt.xelem (i) = i;
+
+      for (octave_idx_type i = 0; i < ipvt.length (); i++)
+        {
+          octave_idx_type k = ipvt.xelem (i);
+
+          if (k != i)
+            {
+              octave_idx_type tmp = pvt.xelem (k);
+              pvt.xelem (k) = pvt.xelem (i);
+              pvt.xelem (i) = tmp;
+            }
+        }
+
+      return pvt;
+    }
+  else
+    return ipvt;
+}
+
+template <class lu_type>
+PermMatrix
+base_lu <lu_type> :: P (void) const
+{
+  return PermMatrix (getp (), false);
+}
+
+template <class lu_type>
+ColumnVector
+base_lu <lu_type> :: P_vec (void) const
+{
+  octave_idx_type a_nr = a_fact.rows ();
+
+  ColumnVector p (a_nr);
+
+  Array<octave_idx_type> pvt = getp ();
+
+  for (octave_idx_type i = 0; i < a_nr; i++)
+    p.xelem (i) = static_cast<double> (pvt.xelem (i) + 1);
+
+  return p;
+}
+
+template <class lu_type>
+bool
+base_lu<lu_type>::regular (void) const
+{
+  bool retval = true;
+
+  octave_idx_type k = std::min (a_fact.rows (), a_fact.columns ());
+
+  for (octave_idx_type i = 0; i < k; i++)
+    {
+      if (a_fact(i, i) == lu_elt_type ())
+        {
+          retval = false;
+          break;
+        }
+    }
+
+  return retval;
+}
diff --git a/src/base-lu.h b/src/base-lu.h
new file mode 100644
--- /dev/null
+++ b/src/base-lu.h
@@ -0,0 +1,87 @@
+/*
+
+Copyright (C) 1996-2015 John W. Eaton
+Copyright (C) 2009 VZLU Prague
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_base_lu_h)
+#define octave_base_lu_h 1
+
+#include "MArray.h"
+#include "dColVector.h"
+#include "PermMatrix.h"
+
+template <class lu_type>
+class
+base_lu
+{
+public:
+
+  typedef typename lu_type::element_type lu_elt_type;
+
+  base_lu (void)
+    : a_fact (), l_fact (), ipvt () { }
+
+  base_lu (const base_lu& a)
+    : a_fact (a.a_fact), l_fact (a.l_fact), ipvt (a.ipvt) { }
+
+  base_lu (const lu_type& l, const lu_type& u,
+           const PermMatrix& p);
+
+  base_lu& operator = (const base_lu& a)
+  {
+    if (this != &a)
+      {
+        a_fact = a.a_fact;
+        l_fact = a.l_fact;
+        ipvt = a.ipvt;
+      }
+    return *this;
+  }
+
+  virtual ~base_lu (void) { }
+
+  bool packed (void) const;
+
+  void unpack (void);
+
+  lu_type L (void) const;
+
+  lu_type U (void) const;
+
+  lu_type Y (void) const;
+
+  PermMatrix P (void) const;
+
+  ColumnVector P_vec (void) const;
+
+  bool regular (void) const;
+
+protected:
+
+  Array<octave_idx_type> getp (void) const;
+
+  lu_type a_fact;
+  lu_type l_fact;
+
+  Array<octave_idx_type> ipvt;
+};
+
+#endif
diff --git a/src/galois-ops.h b/src/galois-ops.h
--- a/src/galois-ops.h
+++ b/src/galois-ops.h
@@ -21,6 +21,32 @@
 #if !defined (galois_octave_ops_h)
 #define galois_octave_ops_h 1
 
+#if ! defined (CAST_BINOP_ARGS)
+#  define CAST_BINOP_ARGS(t1, t2)               \
+  t1 v1 = dynamic_cast<t1> (a1);                \
+  t2 v2 = dynamic_cast<t2> (a2)
+#endif
+
+#if ! defined (CAST_UNOP_ARG)
+#  define CAST_UNOP_ARG(t)                      \
+  t v = dynamic_cast<t> (a)
+#endif
+
+#if ! defined (BINOPDECL)
+#  define BINOPDECL(name, a1, a2)                               \
+  static octave_value                                           \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1,       \
+                             const octave_base_value& a2)
+#endif
+
+#if ! defined (CATOPDECL)
+#  define CATOPDECL(name, a1, a2)                                       \
+  static octave_value                                                   \
+  CONCAT2(oct_catop_, name) (octave_base_value& a1,                     \
+                             const octave_base_value& a2,               \
+                             const Array<octave_idx_type>& ra_idx)
+#endif
+
 // Override the operator and function definition defines from Octave
 
 #define DEFBINOP_OP_G(name, t1, t2, op) \
diff --git a/src/galois.cc b/src/galois.cc
--- a/src/galois.cc
+++ b/src/galois.cc
@@ -27,7 +27,7 @@
 #include "galoisfield.h"
 #include "galois-def.h"
 
-#include <octave/base-lu.cc>
+#include "base-lu.cc"
 
 galois_field_list stored_galois_fields;
 
diff --git a/src/galois.h b/src/galois.h
--- a/src/galois.h
+++ b/src/galois.h
@@ -22,10 +22,10 @@
 #define octave_galois_int_h 1
 
 #include <octave/config.h>
-#include <octave/base-lu.h>
 #include <octave/mx-base.h>
 
 #include "galoisfield.h"
+#include "base-lu.h"
 
 typedef void (*solve_singularity_handler) (double rcond);
 
diff --git a/src/ov-galois.cc b/src/ov-galois.cc
--- a/src/ov-galois.cc
+++ b/src/ov-galois.cc
@@ -24,7 +24,6 @@
 #include <octave/byte-swap.h>
 #include <octave/gripes.h>
 #include <octave/lo-ieee.h>
-#include <octave/oct-hdf5.h>
 #include <octave/oct-locbuf.h>
 #include <octave/oct-obj.h>
 #include <octave/ov.h>
@@ -35,6 +34,22 @@
 #include "galois.h"
 #include "ov-galois.h"
 
+#if defined (HAVE_HDF5)
+#  if defined (HAVE_HDF5_H)
+#    include <hdf5.h>
+#  endif
+#  include "oct-hdf5-types.h"
+#  if defined (OCTAVE_ENABLE_64)
+#    define H5T_NATIVE_IDX H5T_NATIVE_INT64
+#  else
+#    define H5T_NATIVE_IDX H5T_NATIVE_INT
+#  endif
+#endif
+
+#if ! defined (X_CAST)
+#  define X_CAST(T, E) (T) (E)
+#endif
+
 #if defined (DEFINE_OCTAVE_ALLOCATOR)
 DEFINE_OCTAVE_ALLOCATOR (octave_galois);
 #endif
diff --git a/src/syndtable.cc b/src/syndtable.cc
--- a/src/syndtable.cc
+++ b/src/syndtable.cc
@@ -20,8 +20,8 @@
 
 #include <octave/oct.h>
 
-#define COL_MAJ(N) (N / (SIZEOF_INT << 3))
-#define COL_MIN(N) (N % (SIZEOF_INT << 3))
+#define COL_MAJ(N) (N / (sizeof (int) << 3))
+#define COL_MIN(N) (N % (sizeof (int) << 3))
 
 Array<int>
 get_errs (const int& nmin, const int& nmax, const int &nerrs)
