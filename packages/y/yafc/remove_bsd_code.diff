--- lib/base64.c	2000-09-14 16:06:23.000000000 +0200
+++ /home/sscheler/BUILD/yafc-1.1.1/lib/base64.c	2005-11-22 15:05:12.000000000 +0100
@@ -1,151 +1,147 @@
+/* base64.c	base64 encoding and decoding functions
+ * Copyright (C) 2002  Simon Josefsson
+ *
+ * This file is part of Shishi.
+ *
+ * Shishi is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Shishi is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Shishi; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ * This code is heavily modified from fetchmail (also GPL'd, of
+ * course) by Brendan Cully <brendan@kublai.com>, via Mutt.
+ *
+ * Original copyright notice:
+ *
+ * The code in the fetchmail distribution is Copyright 1997 by Eric
+ * S. Raymond.  Portions are also copyrighted by Carl Harris, 1993
+ * and 1995.  Copyright retained for the purpose of protecting free
+ * redistribution of source.
+ *
+ */
+
 /*
- * Copyright (c) 1995, 1996, 1997 Kungliga Tekniska Högskolan
- * (Royal Institute of Technology, Stockholm, Sweden).
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *      This product includes software developed by the Kungliga Tekniska
- *      Högskolan and its contributors.
- * 
- * 4. Neither the name of the Institute nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
+ * Adapted for use with yafc by Stefan Scheler <sscheler@suse.de>
  */
 
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-/*RCSID("$Id: base64.c,v 1.1.1.1 2000/09/14 14:06:23 mhe Exp $");*/
-#endif
 #include <stdlib.h>
 #include <string.h>
-#include "base64.h"
 
-static char base64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+static char B64Chars[64] = {
+  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
+  'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',
+  'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
+  't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7',
+  '8', '9', '+', '/'
+};
+
+#define BAD     -1
+
+static const char base64val[] = {
+  BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD,
+  BAD,
+  BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD,
+  BAD,
+  BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, 62, BAD, BAD, BAD,
+  63,
+  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, BAD, BAD, BAD, BAD, BAD, BAD,
+  BAD, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, BAD, BAD, BAD, BAD, BAD,
+  BAD, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, BAD, BAD, BAD, BAD, BAD
+};
 
-static int pos(char c)
-{
-  char *p;
-  for(p = base64; *p; p++)
-    if(*p == c)
-      return p - base64;
-  return -1;
-}
+#define base64val(c) B64Chars[(unsigned int)(c)]
 
-int base64_encode(const void *data, int size, char **str)
+#define DECODE64(c)  (isascii(c) ? base64val[c] : BAD)
+
+/* raw bytes to null-terminated base 64 string */
+int base64_encode (const void *data, int len, char **str)
 {
-  char *s, *p;
-  int i;
-  int c;
-  unsigned char *q;
-
-  p = s = (char*)malloc(size*4/3+4);
-  if (p == NULL)
-      return -1;
-  q = (unsigned char*)data;
-  i=0;
-  for(i = 0; i < size;){
-    c=q[i++];
-    c*=256;
-    if(i < size)
-      c+=q[i];
-    i++;
-    c*=256;
-    if(i < size)
-      c+=q[i];
-    i++;
-    p[0]=base64[(c&0x00fc0000) >> 18];
-    p[1]=base64[(c&0x0003f000) >> 12];
-    p[2]=base64[(c&0x00000fc0) >> 6];
-    p[3]=base64[(c&0x0000003f) >> 0];
-    if(i > size)
-      p[3]='=';
-    if(i > size+1)
-      p[2]='=';
-    p+=4;
-  }
-  *p=0;
-  *str = s;
-  return strlen(s);
+  unsigned char* in = (unsigned char *)data;
+  char *out = (char*)malloc(len*4/3+4);
+  *str = out;
+  while (len >= 3)
+    {
+      *out++ = B64Chars[in[0] >> 2];
+      *out++ = B64Chars[((in[0] << 4) & 0x30) | (in[1] >> 4)];
+      *out++ = B64Chars[((in[1] << 2) & 0x3c) | (in[2] >> 6)];
+      *out++ = B64Chars[in[2] & 0x3f];
+      len -= 3;
+      in += 3;
+    }
+
+  /* clean up remainder */
+  if (len > 0)
+    {
+      unsigned char fragment;
+
+      *out++ = B64Chars[in[0] >> 2];
+      fragment = (in[0] << 4) & 0x30;
+      if (len > 1)
+	fragment |= in[1] >> 4;
+      *out++ = B64Chars[fragment];
+      *out++ = (len < 2) ? '=' : B64Chars[(in[1] << 2) & 0x3c];
+      *out++ = '=';
+    }
+  *out = '\0';
+  return strlen(*str);
 }
 
-int base64_decode(const char *str, void *data)
+/* Convert '\0'-terminated base 64 string to raw bytes.
+ * Returns length of returned buffer, or -1 on error */
+int
+base64_decode (const char *in, void *data)
 {
-  const char *p;
-  unsigned char *q;
-  int c;
-  int x;
-  int done = 0;
-  q=(unsigned char*)data;
-  for(p=str; *p && !done; p+=4){
-    x = pos(p[0]);
-    if(x >= 0)
-      c = x;
-    else{
-      done = 3;
-      break;
-    }
-    c*=64;
-    
-    x = pos(p[1]);
-    if(x >= 0)
-      c += x;
-    else
-      return -1;
-    c*=64;
-    
-    if(p[2] == '=')
-      done++;
-    else{
-      x = pos(p[2]);
-      if(x >= 0)
-	c += x;
-      else
+  int len = 0;
+  register unsigned char digit1, digit2, digit3, digit4;
+  unsigned char *out=(unsigned char*)data;
+
+  do
+    {
+      digit1 = in[0];
+      if (digit1 > 127 || DECODE64 (digit1) == BAD)
 	return -1;
-    }
-    c*=64;
-    
-    if(p[3] == '=')
-      done++;
-    else{
-      if(done)
+      digit2 = in[1];
+      if (digit2 > 127 || DECODE64 (digit2) == BAD)
 	return -1;
-      x = pos(p[3]);
-      if(x >= 0)
-	c += x;
-      else
+      digit3 = in[2];
+      if (digit3 > 127 || ((digit3 != '=') && (DECODE64 (digit3) == BAD)))
 	return -1;
+      digit4 = in[3];
+      if (digit4 > 127 || ((digit4 != '=') && (DECODE64 (digit4) == BAD)))
+	return -1;
+      in += 4;
+
+      /* digits are already sanity-checked */
+      *out++ = (DECODE64 (digit1) << 2) | (DECODE64 (digit2) >> 4);
+      len++;
+      if (digit3 != '=')
+	{
+	  *out++ =
+	    ((DECODE64 (digit2) << 4) & 0xf0) | (DECODE64 (digit3) >> 2);
+	  len++;
+	  if (digit4 != '=')
+	    {
+	      *out++ = ((DECODE64 (digit3) << 6) & 0xc0) | DECODE64 (digit4);
+	      len++;
+	    }
+	}
     }
-    if(done < 3)
-      *q++=(c&0x00ff0000)>>16;
-      
-    if(done < 2)
-      *q++=(c&0x0000ff00)>>8;
-    if(done < 1)
-      *q++=(c&0x000000ff)>>0;
-  }
-  return q - (unsigned char*)data;
+  while (*in && digit4 != '=');
+
+  return len;
 }
+
--- lib/base64.h	2000-09-14 16:06:26.000000000 +0200
+++ /home/sscheler/BUILD/yafc-1.1.1/lib/base64.h	2005-11-22 15:01:47.000000000 +0100
@@ -1,47 +1,5 @@
-/*
- * Copyright (c) 1995, 1996, 1997 Kungliga Tekniska Högskolan
- * (Royal Institute of Technology, Stockholm, Sweden).
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *      This product includes software developed by the Kungliga Tekniska
- *      Högskolan and its contributors.
- * 
- * 4. Neither the name of the Institute nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/* $Id: base64.h,v 1.1.1.1 2000/09/14 14:06:26 mhe Exp $ */
-
-#ifndef _BASE64_H_
-#define _BASE64_H_
-
-int base64_encode(const void *data, int size, char **str);
-int base64_decode(const char *str, void *data);
-
+#ifndef __BASE64_H
+#define __BASE64_H
+int base64_encode(const void *data, int len, char **str);
+int base64_decode(const char *in, void *data);
 #endif
