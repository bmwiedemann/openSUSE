Index: rabbitmq-java-client-3.5.0/build.properties
===================================================================
--- rabbitmq-java-client-3.5.0.orig/build.properties
+++ rabbitmq-java-client-3.5.0/build.properties
@@ -11,7 +11,7 @@ javac.debug=true
 javac.out=${build.out}/classes
 javadoc.out=build/doc/api
 lib.out=${build.out}/lib
-python.bin=python
+python.bin=python3
 sibling.codegen.dir=../rabbitmq-codegen/
 spec.version=0.9.1
 src.generated=${build.out}/gensrc
Index: rabbitmq-java-client-3.5.0/codegen.py
===================================================================
--- rabbitmq-java-client-3.5.0.orig/codegen.py
+++ rabbitmq-java-client-3.5.0/codegen.py
@@ -15,6 +15,8 @@
 ##
 
 from __future__ import nested_scopes
+from __future__ import print_function
+
 import re
 import sys
 
@@ -127,7 +129,7 @@ def nullCheckedFields(spec, m):
 #---------------------------------------------------------------------------
 
 def printFileHeader():
-    print """//   NOTE: This -*- java -*- source code is autogenerated from the AMQP
+    print("""//   NOTE: This -*- java -*- source code is autogenerated from the AMQP
 //         specification!
 //
 //  The contents of this file are subject to the Mozilla Public License
@@ -145,233 +147,233 @@ def printFileHeader():
 //  The Initial Developer of the Original Code is GoPivotal, Inc.
 //  Copyright (c) 2007-2014 GoPivotal, Inc.  All rights reserved.
 //
-"""
+""")
 
 def genJavaApi(spec):
     def printHeader():
         printFileHeader()
-        print "package com.rabbitmq.client;"
-        print
-        print "import java.io.DataInputStream;"
-        print "import java.io.IOException;"
-        print "import java.util.Collections;"
-        print "import java.util.HashMap;"
-        print "import java.util.Map;"
-        print "import java.util.Date;"
-        print
-        print "import com.rabbitmq.client.impl.ContentHeaderPropertyWriter;"
-        print "import com.rabbitmq.client.impl.ContentHeaderPropertyReader;"
-        print "import com.rabbitmq.client.impl.LongStringHelper;"
+        print("package com.rabbitmq.client;")
+        print()
+        print("import java.io.DataInputStream;")
+        print("import java.io.IOException;")
+        print("import java.util.Collections;")
+        print("import java.util.HashMap;")
+        print("import java.util.Map;")
+        print("import java.util.Date;")
+        print()
+        print("import com.rabbitmq.client.impl.ContentHeaderPropertyWriter;")
+        print("import com.rabbitmq.client.impl.ContentHeaderPropertyReader;")
+        print("import com.rabbitmq.client.impl.LongStringHelper;")
 
     def printProtocolClass():
-        print
-        print "    public static class PROTOCOL {"
-        print "        public static final int MAJOR = %i;" % spec.major
-        print "        public static final int MINOR = %i;" % spec.minor
-        print "        public static final int REVISION = %i;" % spec.revision
-        print "        public static final int PORT = %i;" % spec.port
-        print "    }"
+        print()
+        print("    public static class PROTOCOL {")
+        print("        public static final int MAJOR = %i;" % spec.major)
+        print("        public static final int MINOR = %i;" % spec.minor)
+        print("        public static final int REVISION = %i;" % spec.revision)
+        print("        public static final int PORT = %i;" % spec.port)
+        print("    }")
 
     def printConstants():
-        print
-        for (c,v,cls) in spec.constants: print "    public static final int %s = %i;" % (java_constant_name(c), v)
+        print()
+        for (c,v,cls) in spec.constants: print("    public static final int %s = %i;" % (java_constant_name(c), v))
 
     def builder(c,m):
         def ctorCall(c,m):
             ctor_call = "com.rabbitmq.client.impl.AMQImpl.%s.%s" % (java_class_name(c.name),java_class_name(m.name))
             ctor_arg_list = [ java_field_name(a.name) for a in m.arguments ]
-            print "                    return new %s(%s);" % (ctor_call, ", ".join(ctor_arg_list))
+            print("                    return new %s(%s);" % (ctor_call, ", ".join(ctor_arg_list)))
 
         def genFields(spec, m):
             for a in m.arguments:
                 (jfType, jfName, jfDefault) = typeNameDefault(spec, a)
                 if a.defaultvalue != None:
-                    print "                private %s %s = %s;" % (jfType, jfName, jfDefault)
+                    print("                private %s %s = %s;" % (jfType, jfName, jfDefault))
                 else:
-                    print "                private %s %s;" % (jfType, jfName)
+                    print("                private %s %s;" % (jfType, jfName))
 
         def genArgMethods(spec, m):
             for a in m.arguments:
                 (jfType, jfName, jfDefault) = typeNameDefault(spec, a)
 
-                print "                public Builder %s(%s %s)" % (jfName, jfType, jfName)
-                print "                {   this.%s = %s; return this; }" % (jfName, jfName)
+                print("                public Builder %s(%s %s)" % (jfName, jfType, jfName))
+                print("                {   this.%s = %s; return this; }" % (jfName, jfName))
 
                 if jfType == "boolean":
-                    print "                public Builder %s()" % (jfName)
-                    print "                {   return this.%s(true); }" % (jfName)
+                    print("                public Builder %s()" % (jfName))
+                    print("                {   return this.%s(true); }" % (jfName))
                 elif jfType == "LongString":
-                    print "                public Builder %s(String %s)" % (jfName, jfName)
-                    print "                {   return this.%s(LongStringHelper.asLongString(%s)); }" % (jfName, jfName)
+                    print("                public Builder %s(String %s)" % (jfName, jfName))
+                    print("                {   return this.%s(LongStringHelper.asLongString(%s)); }" % (jfName, jfName))
 
         def genBuildMethod(c,m):
-            print "                public %s build() {" % (java_class_name(m.name))
+            print("                public %s build() {" % (java_class_name(m.name)))
             ctorCall(c,m)
-            print "                }"
+            print("                }")
 
-        print
-        print "            // Builder for instances of %s.%s" % (java_class_name(c.name), java_class_name(m.name))
-        print "            public static final class Builder"
-        print "            {"
+        print()
+        print("            // Builder for instances of %s.%s" % (java_class_name(c.name), java_class_name(m.name)))
+        print("            public static final class Builder")
+        print("            {")
         genFields(spec, m)
-        print
-        print "                public Builder() { }"
-        print
+        print()
+        print("                public Builder() { }")
+        print()
         genArgMethods(spec, m)
         genBuildMethod(c,m)
-        print "            }"
+        print("            }")
 
     def printClassInterfaces():
         for c in spec.classes:
-            print
-            print "    public static class %s {" % (java_class_name(c.name))
+            print()
+            print("    public static class %s {" % (java_class_name(c.name)))
             for m in c.allMethods():
-                print "        public interface %s extends Method {" % ((java_class_name(m.name)))
+                print("        public interface %s extends Method {" % ((java_class_name(m.name))))
                 for a in m.arguments:
-                    print "            %s %s();" % (java_field_type(spec, a.domain), java_getter_name(a.name))
+                    print("            %s %s();" % (java_field_type(spec, a.domain), java_getter_name(a.name)))
                 builder(c,m)
-                print "        }"
-            print "    }"
+                print("        }")
+            print("    }")
 
     def printReadProperties(c):
         if c.fields:
             for f in c.fields:
-                print "            boolean %s_present = reader.readPresence();" % (java_field_name(f.name))
-            print
+                print("            boolean %s_present = reader.readPresence();" % (java_field_name(f.name)))
+            print()
 
-        print "            reader.finishPresence();"
+        print("            reader.finishPresence();")
 
         if c.fields:
-            print
+            print()
             for f in c.fields:
                 (jfName, jfClass) = (java_field_name(f.name), java_class_name(f.domain))
-                print "            this.%s = %s_present ? reader.read%s() : null;" % (jfName, jfName, jfClass)
+                print("            this.%s = %s_present ? reader.read%s() : null;" % (jfName, jfName, jfClass))
 
     def printWritePropertiesTo(c):
-        print
-        print "        public void writePropertiesTo(ContentHeaderPropertyWriter writer)"
-        print "            throws IOException"
-        print "        {"
+        print()
+        print("        public void writePropertiesTo(ContentHeaderPropertyWriter writer)")
+        print("            throws IOException")
+        print("        {")
         if c.fields:
             for f in c.fields:
-                print "            writer.writePresence(this.%s != null);" % (java_field_name(f.name))
-            print
-        print "            writer.finishPresence();"
+                print("            writer.writePresence(this.%s != null);" % (java_field_name(f.name)))
+            print()
+        print("            writer.finishPresence();")
         if c.fields:
-            print
+            print()
             for f in c.fields:
                 (jfName, jfClass) = (java_field_name(f.name), java_class_name(f.domain))
-                print "            if (this.%s != null) writer.write%s(this.%s);" % (jfName, jfClass, jfName)
-        print "        }"
+                print("            if (this.%s != null) writer.write%s(this.%s);" % (jfName, jfClass, jfName))
+        print("        }")
 
     def printAppendPropertyDebugStringTo(c):
         appendList = [ "%s=\")\n               .append(this.%s)\n               .append(\""
                        % (f.name, java_field_name(f.name))
                        for f in c.fields ]
-        print
-        print "        public void appendPropertyDebugStringTo(StringBuilder acc) {"
-        print "            acc.append(\"(%s)\");" % (", ".join(appendList))
-        print "        }"
+        print()
+        print("        public void appendPropertyDebugStringTo(StringBuilder acc) {")
+        print("            acc.append(\"(%s)\");" % (", ".join(appendList)))
+        print("        }")
 
     def printPropertiesBuilderClass(c):
         def printBuilderSetter(fieldType, fieldName):
-            print "            public Builder %s(%s %s)" % (fieldName, java_boxed_type(fieldType), fieldName)
-            print "            {   this.%s = %s; return this; }" % (fieldName, fieldName)
+            print("            public Builder %s(%s %s)" % (fieldName, java_boxed_type(fieldType), fieldName))
+            print("            {   this.%s = %s; return this; }" % (fieldName, fieldName))
             if fieldType == "boolean":
-                print "            public Builder %s()" % (fieldName)
-                print "            {   return this.%s(true); }" % (fieldName)
+                print("            public Builder %s()" % (fieldName))
+                print("            {   return this.%s(true); }" % (fieldName))
             elif fieldType == "LongString":
-                print "            public Builder %s(String %s)" % (fieldName, fieldName)
-                print "            {   return this.%s(LongStringHelper.asLongString(%s)); }" % (fieldName, fieldName)
+                print("            public Builder %s(String %s)" % (fieldName, fieldName))
+                print("            {   return this.%s(LongStringHelper.asLongString(%s)); }" % (fieldName, fieldName))
 
-        print
-        print "        public static final class Builder {"
+        print()
+        print("        public static final class Builder {")
         # fields
         for f in c.fields:
             (fType, fName) = (java_field_type(spec, f.domain), java_field_name(f.name))
-            print "            private %s %s;" % (java_boxed_type(fType), fName)
+            print("            private %s %s;" % (java_boxed_type(fType), fName))
         # ctor
-        print
-        print "            public Builder() {};"
+        print()
+        print("            public Builder() {};")
         # setters
-        print
+        print()
         for f in c.fields:
             printBuilderSetter(java_field_type(spec, f.domain), java_field_name(f.name))
-        print
+        print()
         jClassName = java_class_name(c.name)
         # build()
         objName = "%sProperties" % (jClassName)
         ctor_parm_list = [ java_field_name(f.name) for f in c.fields ]
-        print "            public %s build() {" % (objName)
-        print "                return new %s" % (objName)
-        print "                    ( %s" % ("\n                    , ".join(ctor_parm_list))
-        print "                    );"
-        print "            }"
+        print("            public %s build() {" % (objName))
+        print("                return new %s" % (objName))
+        print("                    ( %s" % ("\n                    , ".join(ctor_parm_list)))
+        print("                    );")
+        print("            }")
 
-        print "        }"
+        print("        }")
 
     def printPropertiesBuilder(c):
-        print
-        print "        public Builder builder() {"
-        print "            Builder builder = new Builder()"
+        print()
+        print("        public Builder builder() {")
+        print("            Builder builder = new Builder()")
         setFieldList = [ "%s(%s)" % (fn, fn)
                          for fn in [ java_field_name(f.name) for f in c.fields ]
                          ]
-        print "                .%s;" % ("\n                .".join(setFieldList))
-        print "            return builder;"
-        print "        }"
+        print("                .%s;" % ("\n                .".join(setFieldList)))
+        print("            return builder;")
+        print("        }")
 
     def printPropertiesClass(c):
         def printGetter(fieldType, fieldName):
             capFieldName = fieldName[0].upper() + fieldName[1:]
-            print "        public %s get%s() { return this.%s; }" % (java_boxed_type(fieldType), capFieldName, fieldName)
+            print("        public %s get%s() { return this.%s; }" % (java_boxed_type(fieldType), capFieldName, fieldName))
 
         jClassName = java_class_name(c.name)
 
-        print
-        print "    public static class %sProperties extends com.rabbitmq.client.impl.AMQ%sProperties {" % (jClassName, jClassName)
+        print()
+        print("    public static class %sProperties extends com.rabbitmq.client.impl.AMQ%sProperties {" % (jClassName, jClassName))
         #property fields
         for f in c.fields:
             (fType, fName) = (java_boxed_type(java_field_type(spec, f.domain)), java_field_name(f.name))
-            print "        private %s %s;" % (fType, fName)
+            print("        private %s %s;" % (fType, fName))
 
         #explicit constructor
         if c.fields:
-            print
+            print()
             consParmList = [ "%s %s" % (java_boxed_type(java_field_type(spec,f.domain)), java_field_name(f.name))
                              for f in c.fields ]
-            print "        public %sProperties(" % (jClassName)
-            print "            %s)" % (",\n            ".join(consParmList))
-            print "        {"
+            print("        public %sProperties(" % (jClassName))
+            print("            %s)" % (",\n            ".join(consParmList)))
+            print("        {")
             for f in c.fields:
                 (fType, fName) = (java_field_type(spec, f.domain), java_field_name(f.name))
                 if fType == "Map<String,Object>":
-                    print "            this.%s = %s==null ? null : Collections.unmodifiableMap(new HashMap<String,Object>(%s));" % (fName, fName, fName)
+                    print("            this.%s = %s==null ? null : Collections.unmodifiableMap(new HashMap<String,Object>(%s));" % (fName, fName, fName))
                 else:
-                    print "            this.%s = %s;" % (fName, fName)
-            print "        }"
+                    print("            this.%s = %s;" % (fName, fName))
+            print("        }")
 
         #datainputstream constructor
-        print
-        print "        public %sProperties(DataInputStream in) throws IOException {" % (jClassName)
-        print "            super(in);"
-        print "            ContentHeaderPropertyReader reader = new ContentHeaderPropertyReader(in);"
-        
+        print()
+        print("        public %sProperties(DataInputStream in) throws IOException {" % (jClassName))
+        print("            super(in);")
+        print("            ContentHeaderPropertyReader reader = new ContentHeaderPropertyReader(in);")
+
         printReadProperties(c)
-        
-        print "        }"
+
+        print("        }")
 
         # default constructor
-        print "        public %sProperties() {}" % (jClassName)
+        print("        public %sProperties() {}" % (jClassName))
 
         #class properties
-        print "        public int getClassId() { return %i; }" % (c.index)
-        print "        public String getClassName() { return \"%s\"; }" % (c.name)
+        print("        public int getClassId() { return %i; }" % (c.index))
+        print("        public String getClassName() { return \"%s\"; }" % (c.name))
 
         printPropertiesBuilder(c)
-        
+
         #accessor methods
-        print
+        print()
         for f in c.fields:
             (jType, jName) = (java_field_type(spec, f.domain), java_field_name(f.name))
             printGetter(jType, jName)
@@ -380,7 +382,7 @@ def genJavaApi(spec):
         printAppendPropertyDebugStringTo(c)
         printPropertiesBuilderClass(c)
 
-        print "    }"
+        print("    }")
 
     def printPropertiesClasses():
         for c in spec.classes:
@@ -388,81 +390,82 @@ def genJavaApi(spec):
                 printPropertiesClass(c)
 
     printHeader()
-    print
-    print "public interface AMQP {"
+    print()
+    print("public interface AMQP {")
 
     printProtocolClass()
     printConstants()
     printClassInterfaces()
     printPropertiesClasses()
 
-    print "}"
+    print("}")
 
 #--------------------------------------------------------------------------------
 
 def genJavaImpl(spec):
     def printHeader():
         printFileHeader()
-        print "package com.rabbitmq.client.impl;"
-        print
-        print "import java.io.IOException;"
-        print "import java.io.DataInputStream;"
-        print "import java.util.Collections;"
-        print "import java.util.HashMap;"
-        print "import java.util.Map;"
-        print
-        print "import com.rabbitmq.client.AMQP;"
-        print "import com.rabbitmq.client.LongString;"
-        print "import com.rabbitmq.client.UnknownClassOrMethodId;"
-        print "import com.rabbitmq.client.UnexpectedMethodError;"
+        print("package com.rabbitmq.client.impl;")
+        print()
+        print("import java.io.IOException;")
+        print("import java.io.DataInputStream;")
+        print("import java.util.Collections;")
+        print("import java.util.HashMap;")
+        print("import java.util.Map;")
+        print()
+        print("import com.rabbitmq.client.AMQP;")
+        print("import com.rabbitmq.client.LongString;")
+        print("import com.rabbitmq.client.UnknownClassOrMethodId;")
+        print("import com.rabbitmq.client.UnexpectedMethodError;")
 
     def printClassMethods(spec, c):
-        print
-        print "    public static class %s {" % (java_class_name(c.name))
-        print "        public static final int INDEX = %s;" % (c.index)
+        print()
+        print("    public static class %s {" % (java_class_name(c.name)))
+        print("        public static final int INDEX = %s;" % (c.index))
         for m in c.allMethods():
 
             def getters():
                 if m.arguments:
-                    print
+                    print()
                     for a in m.arguments:
-                        print "            public %s %s() { return %s; }" % (java_field_type(spec,a.domain), java_getter_name(a.name), java_field_name(a.name))
+                        print("            public %s %s() { return %s; }" % (java_field_type(spec,a.domain), java_getter_name(a.name), java_field_name(a.name)))
 
             def constructors():
-                print
+                print()
                 argList = [ "%s %s" % (java_field_type(spec,a.domain),java_field_name(a.name)) for a in m.arguments ]
-                print "            public %s(%s) {" % (java_class_name(m.name), ", ".join(argList))
+                print("            public %s(%s) {" % (java_class_name(m.name), ", ".join(argList)))
 
-                fieldsToNullCheckInCons = nullCheckedFields(spec, m)
+                fieldsToNullCheckInCons = [f for f in nullCheckedFields(spec, m)]
+                fieldsToNullCheckInCons.sort()
 
                 for f in fieldsToNullCheckInCons:
-                    print "                if (%s == null)" % (f)
-                    print "                    throw new IllegalStateException(\"Invalid configuration: '%s' must be non-null.\");" % (f)
+                    print("                if (%s == null)" % (f))
+                    print("                    throw new IllegalStateException(\"Invalid configuration: '%s' must be non-null.\");" % (f))
 
                 for a in m.arguments:
                     (jfType, jfName) = (java_field_type(spec, a.domain), java_field_name(a.name))
                     if jfType == "Map<String,Object>":
-                        print "                this.%s = %s==null ? null : Collections.unmodifiableMap(new HashMap<String,Object>(%s));" % (jfName, jfName, jfName)
+                        print("                this.%s = %s==null ? null : Collections.unmodifiableMap(new HashMap<String,Object>(%s));" % (jfName, jfName, jfName))
                     else:
-                        print "                this.%s = %s;" % (jfName, jfName)
+                        print("                this.%s = %s;" % (jfName, jfName))
 
-                print "            }"
+                print("            }")
 
                 consArgs = [ "rdr.read%s()" % (java_class_name(spec.resolveDomain(a.domain))) for a in m.arguments ]
-                print "            public %s(MethodArgumentReader rdr) throws IOException {" % (java_class_name(m.name))
-                print "                this(%s);" % (", ".join(consArgs))
-                print "            }"
+                print("            public %s(MethodArgumentReader rdr) throws IOException {" % (java_class_name(m.name)))
+                print("                this(%s);" % (", ".join(consArgs)))
+                print("            }")
 
             def others():
-                print
-                print "            public int protocolClassId() { return %s; }" % (c.index)
-                print "            public int protocolMethodId() { return %s; }" % (m.index)
-                print "            public String protocolMethodName() { return \"%s.%s\";}" % (c.name, m.name)
-                print
-                print "            public boolean hasContent() { return %s; }" % (trueOrFalse(m.hasContent))
-                print
-                print "            public Object visit(MethodVisitor visitor) throws IOException"
-                print "            {   return visitor.visit(this); }"
+                print()
+                print("            public int protocolClassId() { return %s; }" % (c.index))
+                print("            public int protocolMethodId() { return %s; }" % (m.index))
+                print("            public String protocolMethodName() { return \"%s.%s\";}" % (c.name, m.name))
+                print()
+                print("            public boolean hasContent() { return %s; }" % (trueOrFalse(m.hasContent)))
+                print()
+                print("            public Object visit(MethodVisitor visitor) throws IOException")
+                print("            {   return visitor.visit(this); }")
 
             def trueOrFalse(truthVal):
                 if truthVal:
@@ -474,30 +477,30 @@ def genJavaImpl(spec):
                 appendList = [ "%s=\")\n                   .append(this.%s)\n                   .append(\""
                                % (a.name, java_field_name(a.name))
                                for a in m.arguments ]
-                print
-                print "            public void appendArgumentDebugStringTo(StringBuilder acc) {"
-                print "                acc.append(\"(%s)\");" % ", ".join(appendList)
-                print "            }"
+                print()
+                print("            public void appendArgumentDebugStringTo(StringBuilder acc) {")
+                print("                acc.append(\"(%s)\");" % ", ".join(appendList))
+                print("            }")
 
             def write_arguments():
-                print
-                print "            public void writeArgumentsTo(MethodArgumentWriter writer)"
-                print "                throws IOException"
-                print "            {"
+                print()
+                print("            public void writeArgumentsTo(MethodArgumentWriter writer)")
+                print("                throws IOException")
+                print("            {")
                 for a in m.arguments:
-                    print "                writer.write%s(this.%s);" % (java_class_name(spec.resolveDomain(a.domain)), java_field_name(a.name))
-                print "            }"
+                    print("                writer.write%s(this.%s);" % (java_class_name(spec.resolveDomain(a.domain)), java_field_name(a.name)))
+                print("            }")
 
             #start
-            print
-            print "        public static class %s" % (java_class_name(m.name),)
-            print "            extends Method"
-            print "            implements com.rabbitmq.client.AMQP.%s.%s" % (java_class_name(c.name), java_class_name(m.name))
-            print "        {"
-            print "            public static final int INDEX = %s;" % (m.index)
-            print
+            print()
+            print("        public static class %s" % (java_class_name(m.name),))
+            print("            extends Method")
+            print("            implements com.rabbitmq.client.AMQP.%s.%s" % (java_class_name(c.name), java_class_name(m.name)))
+            print("        {")
+            print("            public static final int INDEX = %s;" % (m.index))
+            print()
             for a in m.arguments:
-                print "            private final %s %s;" % (java_field_type(spec, a.domain), java_field_name(a.name))
+                print("            private final %s %s;" % (java_field_type(spec, a.domain), java_field_name(a.name)))
 
             getters()
             constructors()
@@ -506,71 +509,71 @@ def genJavaImpl(spec):
             argument_debug_string()
             write_arguments()
 
-            print "        }"
-        print "    }"
+            print("        }")
+        print("    }")
 
     def printMethodVisitor():
-        print
-        print "    public interface MethodVisitor {"
+        print()
+        print("    public interface MethodVisitor {")
         for c in spec.allClasses():
             for m in c.allMethods():
-                print "        Object visit(%s.%s x) throws IOException;" % (java_class_name(c.name), java_class_name(m.name))
-        print "    }"
+                print("        Object visit(%s.%s x) throws IOException;" % (java_class_name(c.name), java_class_name(m.name)))
+        print("    }")
 
         #default method visitor
-        print
-        print "    public static class DefaultMethodVisitor implements MethodVisitor {"
+        print()
+        print("    public static class DefaultMethodVisitor implements MethodVisitor {")
         for c in spec.allClasses():
             for m in c.allMethods():
-               print "        public Object visit(%s.%s x) throws IOException { throw new UnexpectedMethodError(x); }" % (java_class_name(c.name), java_class_name(m.name))
-        print "    }"
+               print("        public Object visit(%s.%s x) throws IOException { throw new UnexpectedMethodError(x); }" % (java_class_name(c.name), java_class_name(m.name)))
+        print("    }")
 
     def printMethodArgumentReader():
-        print
-        print "    public static Method readMethodFrom(DataInputStream in) throws IOException {"
-        print "        int classId = in.readShort();"
-        print "        int methodId = in.readShort();"
-        print "        switch (classId) {"
+        print()
+        print("    public static Method readMethodFrom(DataInputStream in) throws IOException {")
+        print("        int classId = in.readShort();")
+        print("        int methodId = in.readShort();")
+        print("        switch (classId) {")
         for c in spec.allClasses():
-            print "            case %s:" % (c.index)
-            print "                switch (methodId) {"
+            print("            case %s:" % (c.index))
+            print("                switch (methodId) {")
             for m in c.allMethods():
                 fq_name = java_class_name(c.name) + '.' + java_class_name(m.name)
-                print "                    case %s: {" % (m.index)
-                print "                        return new %s(new MethodArgumentReader(new ValueReader(in)));" % (fq_name)
-                print "                    }"
-            print "                    default: break;"
-            print "                } break;"
-        print "        }"
-        print
-        print "        throw new UnknownClassOrMethodId(classId, methodId);"
-        print "    }"
+                print("                    case %s: {" % (m.index))
+                print("                        return new %s(new MethodArgumentReader(new ValueReader(in)));" % (fq_name))
+                print("                    }")
+            print("                    default: break;")
+            print("                } break;")
+        print("        }")
+        print()
+        print("        throw new UnknownClassOrMethodId(classId, methodId);")
+        print("    }")
 
     def printContentHeaderReader():
-        print
-        print "    public static AMQContentHeader readContentHeaderFrom(DataInputStream in) throws IOException {"
-        print "        int classId = in.readShort();"
-        print "        switch (classId) {"
+        print()
+        print("    public static AMQContentHeader readContentHeaderFrom(DataInputStream in) throws IOException {")
+        print("        int classId = in.readShort();")
+        print("        switch (classId) {")
         for c in spec.allClasses():
             if c.fields:
-                print "            case %s: return new %sProperties(in);" %(c.index, (java_class_name(c.name)))
-        print "            default: break;"
-        print "        }"
-        print
-        print "        throw new UnknownClassOrMethodId(classId);"
-        print "    }"
+                print("            case %s: return new %sProperties(in);" %(c.index, (java_class_name(c.name))))
+        print("            default: break;")
+        print("        }")
+        print()
+        print("        throw new UnknownClassOrMethodId(classId);")
+        print("    }")
 
     printHeader()
-    print
-    print "public class AMQImpl implements AMQP {"
+    print()
+    print("public class AMQImpl implements AMQP {")
 
     for c in spec.allClasses(): printClassMethods(spec,c)
-    
+
     printMethodVisitor()
     printMethodArgumentReader()
     printContentHeaderReader()
 
-    print "}"
+    print("}")
 
 #--------------------------------------------------------------------------------
 
Index: rabbitmq-java-client-3.5.0/codegen/amqp_codegen.py
===================================================================
--- rabbitmq-java-client-3.5.0.orig/codegen/amqp_codegen.py
+++ rabbitmq-java-client-3.5.0/codegen/amqp_codegen.py
@@ -23,7 +23,7 @@ from optparse import OptionParser
 try:
     try:
         import simplejson as json
-    except ImportError, e:
+    except ImportError as e:
         if sys.hexversion >= 0x20600f0:
             import json
         else:
@@ -63,13 +63,13 @@ def extension_info_merger(key, acc, new,
 def domains_merger(key, acc, new, ignore_conflicts):
     merged = dict((k, v) for [k, v] in acc)
     for [k, v] in new:
-        if merged.has_key(k):
+        if k in merged:
             if not ignore_conflicts:
                 raise AmqpSpecFileMergeConflict(key, acc, new)
         else:
             merged[k] = v
 
-    return [[k, v] for (k, v) in merged.iteritems()]
+    return [[k, v] for (k, v) in merged.items()]
 
 def merge_dict_lists_by(dict_key, acc, new, ignore_conflicts):
     acc_index = set(v[dict_key] for v in acc)
@@ -123,7 +123,7 @@ def merge_load_specs(filenames, ignore_c
     docs = [json.load(handle) for handle in handles]
     spec = {}
     for doc in docs:
-        for (key, value) in doc.iteritems():
+        for (key, value) in doc.items():
             (merger, default_value) = mergers.get(key, (default_spec_value_merger, None))
             spec[key] = merger(key, spec.get(key, default_value), value, ignore_conflicts)
     for handle in handles: handle.close()
@@ -139,7 +139,7 @@ class AmqpSpec:
 
         self.major = self.spec['major-version']
         self.minor = self.spec['minor-version']
-        self.revision = self.spec.has_key('revision') and self.spec['revision'] or 0
+        self.revision = 'revision' in self.spec and self.spec['revision'] or 0
         self.port =  self.spec['port']
 
         self.domains = {}
@@ -149,7 +149,7 @@ class AmqpSpec:
 
         self.constants = []
         for d in self.spec['constants']:
-            if d.has_key('class'):
+            if 'class' in d:
                 klass = d['class']
             else:
                 klass = ''
@@ -190,7 +190,7 @@ class AmqpClass(AmqpEntity):
                 break
 
         self.fields = []
-        if self.element.has_key('properties'):
+        if 'properties' in self.element:
             index = 0
             for e in self.element['properties']:
                 self.fields.append(AmqpField(self, e, index))
@@ -207,11 +207,11 @@ class AmqpMethod(AmqpEntity):
         AmqpEntity.__init__(self, element)
         self.klass = klass
         self.index = int(self.element['id'])
-        if self.element.has_key('synchronous'):
+        if 'synchronous' in self.element:
             self.isSynchronous = self.element['synchronous']
         else:
             self.isSynchronous = False
-        if self.element.has_key('content'):
+        if 'content' in self.element:
             self.hasContent = self.element['content']
         else:
             self.hasContent = False
@@ -231,12 +231,12 @@ class AmqpField(AmqpEntity):
         self.method = method
         self.index = index
 
-        if self.element.has_key('type'):
+        if 'type' in self.element:
             self.domain = self.element['type']
         else:
             self.domain = self.element['domain']
             
-        if self.element.has_key('default-value'):
+        if 'default-value' in self.element:
             self.defaultvalue = self.element['default-value']
         else:
             self.defaultvalue = None
@@ -279,7 +279,7 @@ def do_main_dict(funcDict):
         sources = args[1:-1]
         dest = args[-1]
         AmqpSpec.ignore_conflicts = options.ignore_conflicts
-        if funcDict.has_key(function):
+        if function in funcDict:
             execute(funcDict[function], sources, dest)
         else:
             usage()
