--- ./configure.ac.orig	2019-02-07 14:26:10.800566817 +0000
+++ ./configure.ac	2019-02-07 14:26:30.944514306 +0000
@@ -770,6 +770,7 @@ AC_CHECK_FUNCS(lutimes)
 AC_CHECK_FUNCS(mergesort)
 AC_CHECK_FUNCS(getauxval)
 AC_CHECK_FUNCS(setprogname, [], [], [#include <stdlib.h>])
+AC_CHECK_FUNCS(sched_getaffinity, [], [], [#include <sched.h>])
 
 AC_MSG_CHECKING([whether __progname is defined])
 AC_LINK_IFELSE([AC_LANG_PROGRAM([extern const char *__progname;],
--- ./macros.in.orig	2019-02-07 14:20:03.257524913 +0000
+++ ./macros.in	2019-02-07 14:22:46.105100409 +0000
@@ -1056,7 +1056,7 @@ package or when debugging this package.\
 
 #------------------------------------------------------------------------------
 # The "make" analogue, hiding the _smp_mflags magic from specs
-%make_build %{__make} %{_make_output_sync} %{?_smp_mflags}
+%make_build %{__make} %{_make_output_sync} %{?_smp_mflags} V=1 VERBOSE=1
 
 #------------------------------------------------------------------------------
 # The make install analogue of %configure for modern autotools:
--- ./platform.in.orig	2019-02-07 14:23:06.641046876 +0000
+++ ./platform.in	2019-02-07 14:41:12.462256547 +0000
@@ -50,11 +50,17 @@
 
 # Maximum number of CPU's to use when building, 0 for unlimited.
 #%_smp_ncpus_max 0
-%_smp_mflags %([ -z "$RPM_BUILD_NCPUS" ] \\\
-	&& RPM_BUILD_NCPUS="`/usr/bin/getconf _NPROCESSORS_ONLN`"; \\\
+
+%_smp_build_ncpus %([ -z "$RPM_BUILD_NCPUS" ] \\\
+	&& RPM_BUILD_NCPUS="%{getncpus}"; \\\
         ncpus_max=%{?_smp_ncpus_max}; \\\
         if [ -n "$ncpus_max" ] && [ "$ncpus_max" -gt 0 ] && [ "$RPM_BUILD_NCPUS" -gt "$ncpus_max" ]; then RPM_BUILD_NCPUS="$ncpus_max"; fi; \\\
-        if [ "$RPM_BUILD_NCPUS" -gt 1 ]; then echo "-j$RPM_BUILD_NCPUS"; fi)
+        echo "$RPM_BUILD_NCPUS";)
+
+%_smp_mflags -j%{_smp_build_ncpus}
+
+# Enable LTO optimization with a maximal parallelism
+%_lto_cflags -flto=%{_smp_build_ncpus}
 
 #==============================================================================
 # ---- Build policy macros.
--- ./rpmio/macro.c.orig	2019-02-07 14:26:48.768468081 +0000
+++ ./rpmio/macro.c	2019-02-07 14:38:59.286597550 +0000
@@ -12,6 +12,9 @@
 extern char *optarg;
 extern int optind;
 #endif
+#if HAVE_SCHED_GETAFFINITY
+#include <sched.h>
+#endif
 
 #if !defined(isblank)
 #define	isblank(_c)	((_c) == ' ' || (_c) == '\t')
@@ -445,6 +448,23 @@ exit:
     _free(buf);
 }
 
+static unsigned int getncpus(void)
+{
+    unsigned int ncpus = 0;
+#if HAVE_SCHED_GETAFFINITY
+    cpu_set_t set;
+    if (sched_getaffinity (0, sizeof(set), &set) == 0)
+	ncpus = CPU_COUNT(&set);
+#endif
+    /* Fallback to sysconf() if the above isn't supported or didn't work */
+    if (ncpus < 1)
+	ncpus = sysconf(_SC_NPROCESSORS_ONLN);
+    /* If all else fails, there's always the one we're running on... */
+    if (ncpus < 1)
+	ncpus = 1;
+    return ncpus;
+}
+
 /**
  * Parse (and execute) new macro definition.
  * @param mb		macro expansion state
@@ -975,6 +995,9 @@ doFoo(MacroBuf mb, int negate, const cha
     } else if (STREQ("getconfdir", f, fn)) {
 	sprintf(buf, "%s", rpmConfigDir());
 	b = buf;
+    } else if (STREQ("getncpus", f, fn)) {
+	sprintf(buf, "%u", getncpus());
+	b = buf;
     } else if (STREQ("S", f, fn)) {
 	for (b = buf; (c = *b) && risdigit(c);)
 	    b++;
@@ -1271,6 +1294,7 @@ expandMacro(MacroBuf mb, const char *src
 	    STREQ("u2p", f, fn) ||
 	    STREQ("getenv", f, fn) ||
 	    STREQ("getconfdir", f, fn) ||
+	    STREQ("getncpus", f, fn) ||
 	    STREQ("S", f, fn) ||
 	    STREQ("P", f, fn) ||
 	    STREQ("F", f, fn))
--- ./rpmio/rpmio.c.orig	2019-02-07 14:39:20.886542242 +0000
+++ ./rpmio/rpmio.c	2019-02-07 14:39:41.670489024 +0000
@@ -796,7 +796,7 @@ static LZFILE *lzopen_internal(const cha
 #ifdef HAVE_LZMA_MT
 	    } else {
 		if (threads == -1)
-		    threads = sysconf(_SC_NPROCESSORS_ONLN);
+		    threads = rpmExpandNumeric("%{getncpus}");
 		lzma_mt mt_options = {
 		    .flags = 0,
 		    .threads = threads,
