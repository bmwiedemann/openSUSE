From 3e012be9fdb4dc2b87f0f4a1173986adcaeb37ac Mon Sep 17 00:00:00 2001
From: Pietro Albini <pietro@pietroalbini.org>
Date: Thu, 5 Jan 2023 15:52:16 +0100
Subject: [PATCH] CVE-2022-46176: verify ssh host keys in cargo

vendor base64 0.13.1 crate
vendor hmac 0.12.1 crate
vendor subtle 2.4.1 crate
patch libgit2-sys crate to add required APIs
patch git2 crate to add required APIs
---
 Cargo.lock                                    |   38 +-
 src/tools/cargo/Cargo.toml                    |    3 +
 .../src/cargo/sources/git/known_hosts.rs      |  628 ++++++
 src/tools/cargo/src/cargo/sources/git/mod.rs  |    1 +
 .../cargo/src/cargo/sources/git/utils.rs      |   21 +-
 src/tools/cargo/src/cargo/util/config/de.rs   |  107 +-
 src/tools/cargo/src/cargo/util/config/mod.rs  |   19 +
 .../doc/src/appendix/git-authentication.md    |   25 +
 .../cargo/src/doc/src/reference/config.md     |   38 +
 src/tools/cargo/tests/testsuite/config.rs     |   58 +-
 vendor/base64/.cargo-checksum.json            |    1 +
 vendor/base64/Cargo.lock                      |  826 +++++++
 vendor/base64/Cargo.toml                      |   53 +
 vendor/base64/LICENSE-APACHE                  |  201 ++
 vendor/base64/LICENSE-MIT                     |   21 +
 vendor/base64/README.md                       |  114 +
 vendor/base64/RELEASE-NOTES.md                |  109 +
 vendor/base64/benches/benchmarks.rs           |  210 ++
 vendor/base64/examples/base64.rs              |   89 +
 vendor/base64/examples/make_tables.rs         |  179 ++
 vendor/base64/icon_CLion.svg                  |   34 +
 vendor/base64/src/chunked_encoder.rs          |  247 +++
 vendor/base64/src/decode.rs                   |  893 ++++++++
 vendor/base64/src/display.rs                  |   88 +
 vendor/base64/src/encode.rs                   |  675 ++++++
 vendor/base64/src/lib.rs                      |  245 +++
 vendor/base64/src/read/decoder.rs             |  282 +++
 vendor/base64/src/read/decoder_tests.rs       |  335 +++
 vendor/base64/src/read/mod.rs                 |    6 +
 vendor/base64/src/tables.rs                   | 1957 +++++++++++++++++
 vendor/base64/src/tests.rs                    |   81 +
 vendor/base64/src/write/encoder.rs            |  381 ++++
 .../base64/src/write/encoder_string_writer.rs |  176 ++
 vendor/base64/src/write/encoder_tests.rs      |  568 +++++
 vendor/base64/src/write/mod.rs                |    8 +
 vendor/base64/tests/decode.rs                 |  330 +++
 vendor/base64/tests/encode.rs                 |  105 +
 vendor/base64/tests/helpers.rs                |   14 +
 vendor/base64/tests/tests.rs                  |  194 ++
 vendor/git2/.cargo-checksum.json              |    2 +-
 vendor/git2/src/cert.rs                       |   81 +
 vendor/git2/src/lib.rs                        |    2 +-
 vendor/git2/src/remote_callbacks.rs           |   35 +-
 vendor/hmac/.cargo-checksum.json              |    1 +
 vendor/hmac/CHANGELOG.md                      |   97 +
 vendor/hmac/Cargo.toml                        |   55 +
 vendor/hmac/LICENSE-APACHE                    |  201 ++
 vendor/hmac/LICENSE-MIT                       |   25 +
 vendor/hmac/README.md                         |   53 +
 vendor/hmac/src/lib.rs                        |  131 ++
 vendor/hmac/src/optim.rs                      |  280 +++
 vendor/hmac/src/simple.rs                     |  106 +
 vendor/hmac/tests/data/md5.blb                |  Bin 0 -> 245 bytes
 vendor/hmac/tests/data/sha224.blb             |  Bin 0 -> 803 bytes
 vendor/hmac/tests/data/sha256.blb             |  Bin 0 -> 831 bytes
 vendor/hmac/tests/data/sha384.blb             |  Bin 0 -> 943 bytes
 vendor/hmac/tests/data/sha512.blb             |  Bin 0 -> 1062 bytes
 vendor/hmac/tests/data/streebog256.blb        |  Bin 0 -> 84 bytes
 vendor/hmac/tests/data/streebog512.blb        |  Bin 0 -> 117 bytes
 vendor/hmac/tests/data/wycheproof-sha1.blb    |  Bin 0 -> 4875 bytes
 vendor/hmac/tests/data/wycheproof-sha256.blb  |  Bin 0 -> 6153 bytes
 vendor/hmac/tests/data/wycheproof-sha384.blb  |  Bin 0 -> 7857 bytes
 vendor/hmac/tests/data/wycheproof-sha512.blb  |  Bin 0 -> 9648 bytes
 vendor/hmac/tests/mod.rs                      |   88 +
 vendor/libgit2-sys/.cargo-checksum.json       |    2 +-
 vendor/libgit2-sys/lib.rs                     |    4 +
 vendor/subtle/.cargo-checksum.json            |    1 +
 vendor/subtle/CHANGELOG.md                    |   59 +
 vendor/subtle/CONTRIBUTING.md                 |   33 +
 vendor/subtle/Cargo.toml                      |   36 +
 vendor/subtle/LICENSE                         |   28 +
 vendor/subtle/README.md                       |   69 +
 vendor/subtle/src/lib.rs                      |  864 ++++++++
 vendor/subtle/tests/mod.rs                    |  389 ++++
 74 files changed, 11978 insertions(+), 24 deletions(-)
 create mode 100644 src/tools/cargo/src/cargo/sources/git/known_hosts.rs
 create mode 100644 vendor/base64/.cargo-checksum.json
 create mode 100644 vendor/base64/Cargo.lock
 create mode 100644 vendor/base64/Cargo.toml
 create mode 100644 vendor/base64/LICENSE-APACHE
 create mode 100644 vendor/base64/LICENSE-MIT
 create mode 100644 vendor/base64/README.md
 create mode 100644 vendor/base64/RELEASE-NOTES.md
 create mode 100644 vendor/base64/benches/benchmarks.rs
 create mode 100644 vendor/base64/examples/base64.rs
 create mode 100644 vendor/base64/examples/make_tables.rs
 create mode 100644 vendor/base64/icon_CLion.svg
 create mode 100644 vendor/base64/src/chunked_encoder.rs
 create mode 100644 vendor/base64/src/decode.rs
 create mode 100644 vendor/base64/src/display.rs
 create mode 100644 vendor/base64/src/encode.rs
 create mode 100644 vendor/base64/src/lib.rs
 create mode 100644 vendor/base64/src/read/decoder.rs
 create mode 100644 vendor/base64/src/read/decoder_tests.rs
 create mode 100644 vendor/base64/src/read/mod.rs
 create mode 100644 vendor/base64/src/tables.rs
 create mode 100644 vendor/base64/src/tests.rs
 create mode 100644 vendor/base64/src/write/encoder.rs
 create mode 100644 vendor/base64/src/write/encoder_string_writer.rs
 create mode 100644 vendor/base64/src/write/encoder_tests.rs
 create mode 100644 vendor/base64/src/write/mod.rs
 create mode 100644 vendor/base64/tests/decode.rs
 create mode 100644 vendor/base64/tests/encode.rs
 create mode 100644 vendor/base64/tests/helpers.rs
 create mode 100644 vendor/base64/tests/tests.rs
 create mode 100644 vendor/hmac/.cargo-checksum.json
 create mode 100644 vendor/hmac/CHANGELOG.md
 create mode 100644 vendor/hmac/Cargo.toml
 create mode 100644 vendor/hmac/LICENSE-APACHE
 create mode 100644 vendor/hmac/LICENSE-MIT
 create mode 100644 vendor/hmac/README.md
 create mode 100644 vendor/hmac/src/lib.rs
 create mode 100644 vendor/hmac/src/optim.rs
 create mode 100644 vendor/hmac/src/simple.rs
 create mode 100644 vendor/hmac/tests/data/md5.blb
 create mode 100644 vendor/hmac/tests/data/sha224.blb
 create mode 100644 vendor/hmac/tests/data/sha256.blb
 create mode 100644 vendor/hmac/tests/data/sha384.blb
 create mode 100644 vendor/hmac/tests/data/sha512.blb
 create mode 100644 vendor/hmac/tests/data/streebog256.blb
 create mode 100644 vendor/hmac/tests/data/streebog512.blb
 create mode 100644 vendor/hmac/tests/data/wycheproof-sha1.blb
 create mode 100644 vendor/hmac/tests/data/wycheproof-sha256.blb
 create mode 100644 vendor/hmac/tests/data/wycheproof-sha384.blb
 create mode 100644 vendor/hmac/tests/data/wycheproof-sha512.blb
 create mode 100644 vendor/hmac/tests/mod.rs
 create mode 100644 vendor/subtle/.cargo-checksum.json
 create mode 100644 vendor/subtle/CHANGELOG.md
 create mode 100644 vendor/subtle/CONTRIBUTING.md
 create mode 100644 vendor/subtle/Cargo.toml
 create mode 100644 vendor/subtle/LICENSE
 create mode 100644 vendor/subtle/README.md
 create mode 100644 vendor/subtle/src/lib.rs
 create mode 100644 vendor/subtle/tests/mod.rs

diff --git a/Cargo.lock b/Cargo.lock
index dab693419..1aab05d08 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -194,6 +194,12 @@ dependencies = [
  "rustc-demangle",
 ]
 
+[[package]]
+name = "base64"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"
+
 [[package]]
 name = "bitflags"
 version = "1.3.2"
@@ -292,6 +298,7 @@ version = "0.67.0"
 dependencies = [
  "anyhow",
  "atty",
+ "base64",
  "bytesize",
  "cargo-platform 0.1.2",
  "cargo-test-macro",
@@ -309,6 +316,7 @@ dependencies = [
  "git2-curl",
  "glob",
  "hex 0.4.2",
+ "hmac",
  "home",
  "humantime 2.0.1",
  "ignore",
@@ -336,6 +344,7 @@ dependencies = [
  "serde-value",
  "serde_ignored",
  "serde_json",
+ "sha-1",
  "shell-escape",
  "snapbox",
  "strip-ansi-escapes",
@@ -1004,11 +1013,12 @@ dependencies = [
 
 [[package]]
 name = "crypto-common"
-version = "0.1.2"
+version = "0.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a4600d695eb3f6ce1cd44e6e291adceb2cc3ab12f20a33777ecd0bf6eba34e06"
+checksum = "57952ca27b5e3606ff4dd79b0020231aaf9d6aa76dc05fd30137538c50bd3ce8"
 dependencies = [
  "generic-array",
+ "typenum",
 ]
 
 [[package]]
@@ -1095,12 +1105,13 @@ checksum = "524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198"
 
 [[package]]
 name = "digest"
-version = "0.10.2"
+version = "0.10.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8cb780dce4f9a8f5c087362b3a4595936b2019e7c8b30f2c3e9a7e94e6ae9837"
+checksum = "f2fb860ca6fafa5552fb6d0e816a69c8e49f0908bf524e30a90d97c85892d506"
 dependencies = [
  "block-buffer",
  "crypto-common",
+ "subtle",
 ]
 
 [[package]]
@@ -1676,6 +1687,15 @@ version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "644f9158b2f133fd50f5fb3242878846d9eb792e445c893805ff0e3824006e35"
 
+[[package]]
+name = "hmac"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
+dependencies = [
+ "digest",
+]
+
 [[package]]
 name = "home"
 version = "0.5.3"
@@ -4745,6 +4765,12 @@ version = "0.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"
 
+[[package]]
+name = "subtle"
+version = "2.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6bdef32e8150c2a081110b42772ffe7d7c9032b606bc226c8260fd97e0976601"
+
 [[package]]
 name = "syn"
 version = "1.0.102"
@@ -5106,9 +5132,9 @@ dependencies = [
 
 [[package]]
 name = "typenum"
-version = "1.12.0"
+version = "1.15.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "373c8a200f9e67a0c95e62a4f52fbf80c23b4381c05a17845531982fa99e6b33"
+checksum = "dcf81ac59edc17cc8697ff311e8f5ef2d99fcbd9817b34cec66f90b6c3dfd987"
 
 [[package]]
 name = "ucd-parse"
diff --git a/src/tools/cargo/Cargo.toml b/src/tools/cargo/Cargo.toml
index 0b4828315..33263f72f 100644
--- a/src/tools/cargo/Cargo.toml
+++ b/src/tools/cargo/Cargo.toml
@@ -16,6 +16,7 @@ name = "cargo"
 path = "src/cargo/lib.rs"
 
 [dependencies]
+base64 = "0.13.1"
 atty = "0.2"
 bytesize = "1.0"
 cargo-platform = { path = "crates/cargo-platform", version = "0.1.2" }
@@ -32,6 +33,7 @@ git2 = "0.15.0"
 git2-curl = "0.16.0"
 glob = "0.3.0"
 hex = "0.4"
+hmac = "0.12.1"
 home = "0.5"
 humantime = "2.0.0"
 indexmap = "1"
@@ -53,6 +55,7 @@ serde = { version = "1.0.123", features = ["derive"] }
 serde_ignored = "0.1.0"
 serde_json = { version = "1.0.30", features = ["raw_value"] }
 serde-value = "0.7.0"
+sha-1 = "0.10.0"
 shell-escape = "0.1.4"
 strip-ansi-escapes = "0.1.0"
 tar = { version = "0.4.38", default-features = false }
diff --git a/src/tools/cargo/src/cargo/sources/git/known_hosts.rs b/src/tools/cargo/src/cargo/sources/git/known_hosts.rs
new file mode 100644
index 000000000..ca732fafd
--- /dev/null
+++ b/src/tools/cargo/src/cargo/sources/git/known_hosts.rs
@@ -0,0 +1,628 @@
+//! SSH host key validation support.
+//!
+//! A primary goal with this implementation is to provide user-friendly error
+//! messages, guiding them to understand the issue and how to resolve it.
+//!
+//! Note that there are a lot of limitations here. This reads OpenSSH
+//! known_hosts files from well-known locations, but it does not read OpenSSH
+//! config files. The config file can change the behavior of how OpenSSH
+//! handles known_hosts files. For example, some things we don't handle:
+//!
+//! - `GlobalKnownHostsFile` — Changes the location of the global host file.
+//! - `UserKnownHostsFile` — Changes the location of the user's host file.
+//! - `KnownHostsCommand` — A command to fetch known hosts.
+//! - `CheckHostIP` — DNS spoofing checks.
+//! - `VisualHostKey` — Shows a visual ascii-art key.
+//! - `VerifyHostKeyDNS` — Uses SSHFP DNS records to fetch a host key.
+//!
+//! There's also a number of things that aren't supported but could be easily
+//! added (it just adds a little complexity). For example, hostname patterns,
+//! and revoked markers. See "FIXME" comments littered in this file.
+
+use crate::util::config::{Definition, Value};
+use git2::cert::{Cert, SshHostKeyType};
+use git2::CertificateCheckStatus;
+use hmac::Mac;
+use std::collections::HashSet;
+use std::fmt::Write;
+use std::path::{Path, PathBuf};
+
+/// These are host keys that are hard-coded in cargo to provide convenience.
+///
+/// If GitHub ever publishes new keys, the user can add them to their own
+/// configuration file to use those instead.
+///
+/// The GitHub keys are sourced from <https://api.github.com/meta> or
+/// <https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints>.
+///
+/// These will be ignored if the user adds their own entries for `github.com`,
+/// which can be useful if GitHub ever revokes their old keys.
+static BUNDLED_KEYS: &[(&str, &str, &str)] = &[
+    ("github.com", "ssh-ed25519", "AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl"),
+    ("github.com", "ecdsa-sha2-nistp256", "AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg="),
+    ("github.com", "ssh-rsa", "AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ=="),
+];
+
+enum KnownHostError {
+    /// Some general error happened while validating the known hosts.
+    CheckError(anyhow::Error),
+    /// The host key was not found.
+    HostKeyNotFound {
+        hostname: String,
+        key_type: SshHostKeyType,
+        remote_host_key: String,
+        remote_fingerprint: String,
+        other_hosts: Vec<KnownHost>,
+    },
+    /// The host key was found, but does not match the remote's key.
+    HostKeyHasChanged {
+        hostname: String,
+        key_type: SshHostKeyType,
+        old_known_host: KnownHost,
+        remote_host_key: String,
+        remote_fingerprint: String,
+    },
+}
+
+impl From<anyhow::Error> for KnownHostError {
+    fn from(err: anyhow::Error) -> KnownHostError {
+        KnownHostError::CheckError(err.into())
+    }
+}
+
+/// The location where a host key was located.
+#[derive(Clone)]
+enum KnownHostLocation {
+    /// Loaded from a file from disk.
+    File { path: PathBuf, lineno: u32 },
+    /// Loaded from cargo's config system.
+    Config { definition: Definition },
+    /// Part of the hard-coded bundled keys in Cargo.
+    Bundled,
+}
+
+/// The git2 callback used to validate a certificate (only ssh known hosts are validated).
+pub fn certificate_check(
+    cert: &Cert<'_>,
+    host: &str,
+    port: Option<u16>,
+    config_known_hosts: Option<&Vec<Value<String>>>,
+    diagnostic_home_config: &str,
+) -> Result<CertificateCheckStatus, git2::Error> {
+    let Some(host_key) = cert.as_hostkey() else {
+        // Return passthrough for TLS X509 certificates to use whatever validation
+        // was done in git2.
+        return Ok(CertificateCheckStatus::CertificatePassthrough)
+    };
+    // If a nonstandard port is in use, check for that first.
+    // The fallback to check without a port is handled in the HostKeyNotFound handler.
+    let host_maybe_port = match port {
+        Some(port) if port != 22 => format!("[{host}]:{port}"),
+        _ => host.to_string(),
+    };
+    // The error message must be constructed as a string to pass through the libgit2 C API.
+    let err_msg = match check_ssh_known_hosts(host_key, &host_maybe_port, config_known_hosts) {
+        Ok(()) => {
+            return Ok(CertificateCheckStatus::CertificateOk);
+        }
+        Err(KnownHostError::CheckError(e)) => {
+            format!("error: failed to validate host key:\n{:#}", e)
+        }
+        Err(KnownHostError::HostKeyNotFound {
+            hostname,
+            key_type,
+            remote_host_key,
+            remote_fingerprint,
+            other_hosts,
+        }) => {
+            // Try checking without the port.
+            if port.is_some()
+                && !matches!(port, Some(22))
+                && check_ssh_known_hosts(host_key, host, config_known_hosts).is_ok()
+            {
+                return Ok(CertificateCheckStatus::CertificateOk);
+            }
+            let key_type_short_name = key_type.short_name();
+            let key_type_name = key_type.name();
+            let known_hosts_location = user_known_host_location_to_add(diagnostic_home_config);
+            let other_hosts_message = if other_hosts.is_empty() {
+                String::new()
+            } else {
+                let mut msg = String::from(
+                    "Note: This host key was found, \
+                    but is associated with a different host:\n",
+                );
+                for known_host in other_hosts {
+                    let loc = match known_host.location {
+                        KnownHostLocation::File { path, lineno } => {
+                            format!("{} line {lineno}", path.display())
+                        }
+                        KnownHostLocation::Config { definition } => {
+                            format!("config value from {definition}")
+                        }
+                        KnownHostLocation::Bundled => format!("bundled with cargo"),
+                    };
+                    write!(msg, "    {loc}: {}\n", known_host.patterns).unwrap();
+                }
+                msg
+            };
+            format!("error: unknown SSH host key\n\
+                The SSH host key for `{hostname}` is not known and cannot be validated.\n\
+                \n\
+                To resolve this issue, add the host key to {known_hosts_location}\n\
+                \n\
+                The key to add is:\n\
+                \n\
+                {hostname} {key_type_name} {remote_host_key}\n\
+                \n\
+                The {key_type_short_name} key fingerprint is: SHA256:{remote_fingerprint}\n\
+                This fingerprint should be validated with the server administrator that it is correct.\n\
+                {other_hosts_message}\n\
+                See https://doc.rust-lang.org/stable/cargo/appendix/git-authentication.html#ssh-known-hosts \
+                for more information.\n\
+                ")
+        }
+        Err(KnownHostError::HostKeyHasChanged {
+            hostname,
+            key_type,
+            old_known_host,
+            remote_host_key,
+            remote_fingerprint,
+        }) => {
+            let key_type_short_name = key_type.short_name();
+            let key_type_name = key_type.name();
+            let known_hosts_location = user_known_host_location_to_add(diagnostic_home_config);
+            let old_key_resolution = match old_known_host.location {
+                KnownHostLocation::File { path, lineno } => {
+                    let old_key_location = path.display();
+                    format!(
+                        "removing the old {key_type_name} key for `{hostname}` \
+                        located at {old_key_location} line {lineno}, \
+                        and adding the new key to {known_hosts_location}",
+                    )
+                }
+                KnownHostLocation::Config { definition } => {
+                    format!(
+                        "removing the old {key_type_name} key for `{hostname}` \
+                        loaded from Cargo's config at {definition}, \
+                        and adding the new key to {known_hosts_location}"
+                    )
+                }
+                KnownHostLocation::Bundled => {
+                    format!(
+                        "adding the new key to {known_hosts_location}\n\
+                        The current host key is bundled as part of Cargo."
+                    )
+                }
+            };
+            format!("error: SSH host key has changed for `{hostname}`\n\
+                *********************************\n\
+                * WARNING: HOST KEY HAS CHANGED *\n\
+                *********************************\n\
+                This may be caused by a man-in-the-middle attack, or the \
+                server may have changed its host key.\n\
+                \n\
+                The {key_type_short_name} fingerprint for the key from the remote host is:\n\
+                    SHA256:{remote_fingerprint}\n\
+                \n\
+                You are strongly encouraged to contact the server \
+                administrator for `{hostname}` to verify that this new key is \
+                correct.\n\
+                \n\
+                If you can verify that the server has a new key, you can \
+                resolve this error by {old_key_resolution}\n\
+                \n\
+                The key provided by the remote host is:\n\
+                \n\
+                {hostname} {key_type_name} {remote_host_key}\n\
+                \n\
+                See https://doc.rust-lang.org/stable/cargo/appendix/git-authentication.html#ssh-known-hosts \
+                for more information.\n\
+                ")
+        }
+    };
+    Err(git2::Error::new(
+        git2::ErrorCode::GenericError,
+        git2::ErrorClass::Callback,
+        err_msg,
+    ))
+}
+
+/// Checks if the given host/host key pair is known.
+fn check_ssh_known_hosts(
+    cert_host_key: &git2::cert::CertHostkey<'_>,
+    host: &str,
+    config_known_hosts: Option<&Vec<Value<String>>>,
+) -> Result<(), KnownHostError> {
+    let Some(remote_host_key) = cert_host_key.hostkey() else {
+        return Err(anyhow::format_err!("remote host key is not available").into());
+    };
+    let remote_key_type = cert_host_key.hostkey_type().unwrap();
+
+    // Collect all the known host entries from disk.
+    let mut known_hosts = Vec::new();
+    for path in known_host_files() {
+        if !path.exists() {
+            continue;
+        }
+        let hosts = load_hostfile(&path)?;
+        known_hosts.extend(hosts);
+    }
+    if let Some(config_known_hosts) = config_known_hosts {
+        // Format errors aren't an error in case the format needs to change in
+        // the future, to retain forwards compatibility.
+        for line_value in config_known_hosts {
+            let location = KnownHostLocation::Config {
+                definition: line_value.definition.clone(),
+            };
+            match parse_known_hosts_line(&line_value.val, location) {
+                Some(known_host) => known_hosts.push(known_host),
+                None => log::warn!(
+                    "failed to parse known host {} from {}",
+                    line_value.val,
+                    line_value.definition
+                ),
+            }
+        }
+    }
+    // Load the bundled keys. Don't add keys for hosts that the user has
+    // configured, which gives them the option to override them. This could be
+    // useful if the keys are ever revoked.
+    let configured_hosts: HashSet<_> = known_hosts
+        .iter()
+        .flat_map(|known_host| {
+            known_host
+                .patterns
+                .split(',')
+                .map(|pattern| pattern.to_lowercase())
+        })
+        .collect();
+    for (patterns, key_type, key) in BUNDLED_KEYS {
+        if !configured_hosts.contains(*patterns) {
+            let key = base64::decode(key).unwrap();
+            known_hosts.push(KnownHost {
+                location: KnownHostLocation::Bundled,
+                patterns: patterns.to_string(),
+                key_type: key_type.to_string(),
+                key,
+            });
+        }
+    }
+    check_ssh_known_hosts_loaded(&known_hosts, host, remote_key_type, remote_host_key)
+}
+
+/// Checks a host key against a loaded set of known hosts.
+fn check_ssh_known_hosts_loaded(
+    known_hosts: &[KnownHost],
+    host: &str,
+    remote_key_type: SshHostKeyType,
+    remote_host_key: &[u8],
+) -> Result<(), KnownHostError> {
+    // `changed_key` keeps track of any entries where the key has changed.
+    let mut changed_key = None;
+    // `other_hosts` keeps track of any entries that have an identical key,
+    // but a different hostname.
+    let mut other_hosts = Vec::new();
+
+    for known_host in known_hosts {
+        // The key type from libgit2 needs to match the key type from the host file.
+        if known_host.key_type != remote_key_type.name() {
+            continue;
+        }
+        let key_matches = known_host.key == remote_host_key;
+        if !known_host.host_matches(host) {
+            if key_matches {
+                other_hosts.push(known_host.clone());
+            }
+            continue;
+        }
+        if key_matches {
+            return Ok(());
+        }
+        // The host and key type matched, but the key itself did not.
+        // This indicates the key has changed.
+        // This is only reported as an error if no subsequent lines have a
+        // correct key.
+        changed_key = Some(known_host.clone());
+    }
+    // Older versions of OpenSSH (before 6.8, March 2015) showed MD5
+    // fingerprints (see FingerprintHash ssh config option). Here we only
+    // support SHA256.
+    let mut remote_fingerprint = cargo_util::Sha256::new();
+    remote_fingerprint.update(remote_host_key);
+    let remote_fingerprint =
+        base64::encode_config(remote_fingerprint.finish(), base64::STANDARD_NO_PAD);
+    let remote_host_key = base64::encode(remote_host_key);
+    // FIXME: Ideally the error message should include the IP address of the
+    // remote host (to help the user validate that they are connecting to the
+    // host they were expecting to). However, I don't see a way to obtain that
+    // information from libgit2.
+    match changed_key {
+        Some(old_known_host) => Err(KnownHostError::HostKeyHasChanged {
+            hostname: host.to_string(),
+            key_type: remote_key_type,
+            old_known_host,
+            remote_host_key,
+            remote_fingerprint,
+        }),
+        None => Err(KnownHostError::HostKeyNotFound {
+            hostname: host.to_string(),
+            key_type: remote_key_type,
+            remote_host_key,
+            remote_fingerprint,
+            other_hosts,
+        }),
+    }
+}
+
+/// Returns a list of files to try loading OpenSSH-formatted known hosts.
+fn known_host_files() -> Vec<PathBuf> {
+    let mut result = Vec::new();
+    if cfg!(unix) {
+        result.push(PathBuf::from("/etc/ssh/ssh_known_hosts"));
+    } else if cfg!(windows) {
+        // The msys/cygwin version of OpenSSH uses `/etc` from the posix root
+        // filesystem there (such as `C:\msys64\etc\ssh\ssh_known_hosts`).
+        // However, I do not know of a way to obtain that location from
+        // Windows-land. The ProgramData version here is what the PowerShell
+        // port of OpenSSH does.
+        if let Some(progdata) = std::env::var_os("ProgramData") {
+            let mut progdata = PathBuf::from(progdata);
+            progdata.push("ssh");
+            progdata.push("ssh_known_hosts");
+            result.push(progdata)
+        }
+    }
+    result.extend(user_known_host_location());
+    result
+}
+
+/// The location of the user's known_hosts file.
+fn user_known_host_location() -> Option<PathBuf> {
+    // NOTE: This is a potentially inaccurate prediction of what the user
+    // actually wants. The actual location depends on several factors:
+    //
+    // - Windows OpenSSH Powershell version: I believe this looks up the home
+    //   directory via ProfileImagePath in the registry, falling back to
+    //   `GetWindowsDirectoryW` if that fails.
+    // - OpenSSH Portable (under msys): This is very complicated. I got lost
+    //   after following it through some ldap/active directory stuff.
+    // - OpenSSH (most unix platforms): Uses `pw->pw_dir` from `getpwuid()`.
+    //
+    // This doesn't do anything close to that. home_dir's behavior is:
+    // - Windows: $USERPROFILE, or SHGetFolderPathW()
+    // - Unix: $HOME, or getpwuid_r()
+    //
+    // Since there is a mismatch here, the location returned here might be
+    // different than what the user's `ssh` CLI command uses. We may want to
+    // consider trying to align it better.
+    home::home_dir().map(|mut home| {
+        home.push(".ssh");
+        home.push("known_hosts");
+        home
+    })
+}
+
+/// The location to display in an error message instructing the user where to
+/// add the new key.
+fn user_known_host_location_to_add(diagnostic_home_config: &str) -> String {
+    // Note that we don't bother with the legacy known_hosts2 files.
+    let user = user_known_host_location();
+    let openssh_loc = match &user {
+        Some(path) => path.to_str().expect("utf-8 home"),
+        None => "~/.ssh/known_hosts",
+    };
+    format!(
+        "the `net.ssh.known-hosts` array in your Cargo configuration \
+        (such as {diagnostic_home_config}) \
+        or in your OpenSSH known_hosts file at {openssh_loc}"
+    )
+}
+
+const HASH_HOSTNAME_PREFIX: &str = "|1|";
+
+/// A single known host entry.
+#[derive(Clone)]
+struct KnownHost {
+    location: KnownHostLocation,
+    /// The hostname. May be comma separated to match multiple hosts.
+    patterns: String,
+    key_type: String,
+    key: Vec<u8>,
+}
+
+impl KnownHost {
+    /// Returns whether or not the given host matches this known host entry.
+    fn host_matches(&self, host: &str) -> bool {
+        let mut match_found = false;
+        let host = host.to_lowercase();
+        if let Some(hashed) = self.patterns.strip_prefix(HASH_HOSTNAME_PREFIX) {
+            return hashed_hostname_matches(&host, hashed);
+        }
+        for pattern in self.patterns.split(',') {
+            let pattern = pattern.to_lowercase();
+            // FIXME: support * and ? wildcards
+            if let Some(pattern) = pattern.strip_prefix('!') {
+                if pattern == host {
+                    return false;
+                }
+            } else {
+                match_found |= pattern == host;
+            }
+        }
+        match_found
+    }
+}
+
+fn hashed_hostname_matches(host: &str, hashed: &str) -> bool {
+    let Some((b64_salt, b64_host)) = hashed.split_once('|') else { return false; };
+    let Ok(salt) = base64::decode(b64_salt) else { return false; };
+    let Ok(hashed_host) = base64::decode(b64_host) else { return false; };
+    let Ok(mut mac) = hmac::Hmac::<sha1::Sha1>::new_from_slice(&salt) else { return false; };
+    mac.update(host.as_bytes());
+    let result = mac.finalize().into_bytes();
+    hashed_host == &result[..]
+}
+
+/// Loads an OpenSSH known_hosts file.
+fn load_hostfile(path: &Path) -> Result<Vec<KnownHost>, anyhow::Error> {
+    let contents = cargo_util::paths::read(path)?;
+    Ok(load_hostfile_contents(path, &contents))
+}
+
+fn load_hostfile_contents(path: &Path, contents: &str) -> Vec<KnownHost> {
+    let entries = contents
+        .lines()
+        .enumerate()
+        .filter_map(|(lineno, line)| {
+            let location = KnownHostLocation::File {
+                path: path.to_path_buf(),
+                lineno: lineno as u32 + 1,
+            };
+            parse_known_hosts_line(line, location)
+        })
+        .collect();
+    entries
+}
+
+fn parse_known_hosts_line(line: &str, location: KnownHostLocation) -> Option<KnownHost> {
+    let line = line.trim();
+    // FIXME: @revoked and @cert-authority is currently not supported.
+    if line.is_empty() || line.starts_with(['#', '@']) {
+        return None;
+    }
+    let mut parts = line.split([' ', '\t']).filter(|s| !s.is_empty());
+    let patterns = parts.next()?;
+    let key_type = parts.next()?;
+    let key = parts.next().map(base64::decode)?.ok()?;
+    Some(KnownHost {
+        location,
+        patterns: patterns.to_string(),
+        key_type: key_type.to_string(),
+        key,
+    })
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    static COMMON_CONTENTS: &str = r#"
+        # Comments allowed at start of line
+
+        example.com,rust-lang.org ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC5MzWIpZwpkpDjyCNiTIEVFhSA9OUUQvjFo7CgZBGCAj/cqeUIgiLsgtfmtBsfWIkAECQpM7ePP7NLZFGJcHvoyg5jXJiIX5s0eKo9IlcuTLLrMkW5MkHXE7bNklVbW1WdCfF2+y7Ao25B4L8FFRokMh0yp/H6+8xZ7PdVwL3FRPEg8ftZ5R0kuups6xiMHPRX+f/07vfJzA47YDPmXfhkn+JK8kL0JYw8iy8BtNBfRQL99d9iXJzWXnNce5NHMuKD5rOonD3aQHLDlwK+KhrFRrdaxQEM8ZWxNti0ux8yT4Dl5jJY0CrIu3Xl6+qroVgTqJGNkTbhs5DGWdFh6BLPTTH15rN4buisg7uMyLyHqx06ckborqD33gWu+Jig7O+PV6KJmL5mp1O1HXvZqkpBdTiT6GiDKG3oECCIXkUk0BSU9VG9VQcrMxxvgiHlyoXUAfYQoXv/lnxkTnm+Sr36kutsVOs7n5B43ZKAeuaxyQ11huJZpxamc0RA1HM641s= eric@host
+        Example.net ssh-dss AAAAB3NzaC1kc3MAAACBAK2Ek3jVxisXmz5UcZ7W65BAj/nDJCCVvSe0Aytndn4PH6k7sVesut5OoY6PdksZ9tEfuFjjS9HR5SJb8j1GW0GxtaSHHbf+rNc36PeU75bffzyIWwpA8uZFONt5swUAXJXcsHOoapNbUFuhHsRhB2hXxz9QGNiiwIwRJeSHixKRAAAAFQChKfxO1z9H2/757697xP5nJ/Z5dwAAAIEAoc+HIWas+4WowtB/KtAp6XE0B9oHI+55wKtdcGwwb7zHKK9scWNXwxIcMhSvyB3Oe2I7dQQlvyIWxsdZlzOkX0wdsTHjIAnBAP68MyvMv4kq3+I5GAVcFsqoLZfZvh0dlcgUq1/YNYZwKlt89tnzk8Fp4KLWmuw8Bd8IShYVa78AAACAL3qd8kNTY7CthgsQ8iWdjbkGSF/1KCeFyt8UjurInp9wvPDjqagwakbyLOzN7y3/ItTPCaGuX+RjFP0zZTf8i9bsAVyjFJiJ7vzRXcWytuFWANrpzLTn1qzPfh63iK92Aw8AVBYvEA/4bxo+XReAvhNBB/m78G6OedTeu6ZoTsI= eric@host
+        [example.net]:2222 ssh-dss AAAAB3NzaC1kc3MAAACBAJJN5kLZEpOJpXWyMT4KwYvLAj+b9ErNtglxOi86C6Kw7oZeYdDMCfD3lc3PJyX64udQcWGfO4abSESMiYdY43yFAZH279QGH5Q/B5CklVvTqYpfAUR+1r9TQxy3OVQHk7FB2wOi4xNQ3myO0vaYlBOB9il+P223aERbXx4JTWdvAAAAFQCTHWTcXxLK5Z6ZVPmfdSDyHzkF2wAAAIEAhp41/mTnM0Y0EWSyCXuETMW1QSpKGF8sqoZKp6wdzyhLXu0i32gLdXj4p24em/jObYh93hr+MwgxqWq+FHgD+D80Qg5f6vj4yEl4Uu5hqtTpCBFWUQoyEckbUkPf8uZ4/XzAne+tUSjZm09xATCmK9U2IGqZE+D+90eBkf1Svc8AAACAeKhi4EtfwenFYqKz60ZoEEhIsE1yI2jH73akHnfHpcW84w+fk3YlwjcfDfyYso+D0jZBdJeK5qIdkbUWhAX8wDjJVO0WL6r/YPr4yu/CgEyW1H59tAbujGJ4NR0JDqioulzYqNHnxpiw1RJukZnPBfSFKzRElvPOCq/NkQM/Mwk= eric@host
+        nistp256.example.org ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJ4iYGCcJrUIfrHfzlsv8e8kaF36qpcUpe3VNAKVCZX/BDptIdlEe8u8vKNRTPgUO9jqS0+tjTcPiQd8/8I9qng= eric@host
+        nistp384.example.org ecdsa-sha2-nistp384 AAAAE2VjZHNhLXNoYTItbmlzdHAzODQAAAAIbmlzdHAzODQAAABhBNuGT3TqMz2rcwOt2ZqkiNqq7dvWPE66W2qPCoZsh0pQhVU3BnhKIc6nEr6+Wts0Z3jdF3QWwxbbTjbVTVhdr8fMCFhDCWiQFm9xLerYPKnu9qHvx9K87/fjc5+0pu4hLA== eric@host
+        nistp521.example.org ecdsa-sha2-nistp521 AAAAE2VjZHNhLXNoYTItbmlzdHA1MjEAAAAIbmlzdHA1MjEAAACFBAD35HH6OsK4DN75BrKipVj/GvZaUzjPNa1F8wMjUdPB1JlVcUfgzJjWSxrhmaNN3u0soiZw8WNRFINsGPCw5E7DywF1689WcIj2Ye2rcy99je15FknScTzBBD04JgIyOI50mCUaPCBoF14vFlN6BmO00cFo+yzy5N8GuQ2sx9kr21xmFQ== eric@host
+        # Revoked not yet supported.
+        @revoked * ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKtQsi+KPYispwm2rkMidQf30fG1Niy8XNkvASfePoca eric@host
+        example.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAWkjI6XT2SZh3xNk5NhisA3o3sGzWR+VAKMSqHtI0aY eric@host
+        192.168.42.12 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKVYJpa0yUGaNk0NXQTPWa0tHjqRpx+7hl2diReH6DtR eric@host
+        |1|QxzZoTXIWLhUsuHAXjuDMIV3FjQ=|M6NCOIkjiWdCWqkh5+Q+/uFLGjs= ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIIHgN3O21U4LWtP5OzjTzPnUnSDmCNDvyvlaj6Hi65JC eric@host
+        # Negation isn't terribly useful without globs.
+        neg.example.com,!neg.example.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOXfUnaAHTlo1Qi//rNk26OcmHikmkns1Z6WW/UuuS3K eric@host
+    "#;
+
+    #[test]
+    fn known_hosts_parse() {
+        let kh_path = Path::new("/home/abc/.known_hosts");
+        let khs = load_hostfile_contents(kh_path, COMMON_CONTENTS);
+        assert_eq!(khs.len(), 10);
+        match &khs[0].location {
+            KnownHostLocation::File { path, lineno } => {
+                assert_eq!(path, kh_path);
+                assert_eq!(*lineno, 4);
+            }
+            _ => panic!("unexpected"),
+        }
+        assert_eq!(khs[0].patterns, "example.com,rust-lang.org");
+        assert_eq!(khs[0].key_type, "ssh-rsa");
+        assert_eq!(khs[0].key.len(), 407);
+        assert_eq!(&khs[0].key[..30], b"\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x03\x01\x00\x01\x00\x00\x01\x81\x00\xb935\x88\xa5\x9c)");
+        match &khs[1].location {
+            KnownHostLocation::File { path, lineno } => {
+                assert_eq!(path, kh_path);
+                assert_eq!(*lineno, 5);
+            }
+            _ => panic!("unexpected"),
+        }
+        assert_eq!(khs[2].patterns, "[example.net]:2222");
+        assert_eq!(khs[3].patterns, "nistp256.example.org");
+        assert_eq!(khs[7].patterns, "192.168.42.12");
+    }
+
+    #[test]
+    fn host_matches() {
+        let kh_path = Path::new("/home/abc/.known_hosts");
+        let khs = load_hostfile_contents(kh_path, COMMON_CONTENTS);
+        assert!(khs[0].host_matches("example.com"));
+        assert!(khs[0].host_matches("rust-lang.org"));
+        assert!(khs[0].host_matches("EXAMPLE.COM"));
+        assert!(khs[1].host_matches("example.net"));
+        assert!(!khs[0].host_matches("example.net"));
+        assert!(khs[2].host_matches("[example.net]:2222"));
+        assert!(!khs[2].host_matches("example.net"));
+        assert!(khs[8].host_matches("hashed.example.com"));
+        assert!(!khs[8].host_matches("example.com"));
+        assert!(!khs[9].host_matches("neg.example.com"));
+    }
+
+    #[test]
+    fn check_match() {
+        let kh_path = Path::new("/home/abc/.known_hosts");
+        let khs = load_hostfile_contents(kh_path, COMMON_CONTENTS);
+
+        assert!(check_ssh_known_hosts_loaded(
+            &khs,
+            "example.com",
+            SshHostKeyType::Rsa,
+            &khs[0].key
+        )
+        .is_ok());
+
+        match check_ssh_known_hosts_loaded(&khs, "example.com", SshHostKeyType::Dss, &khs[0].key) {
+            Err(KnownHostError::HostKeyNotFound {
+                hostname,
+                remote_fingerprint,
+                other_hosts,
+                ..
+            }) => {
+                assert_eq!(
+                    remote_fingerprint,
+                    "yn+pONDn0EcgdOCVptgB4RZd/wqmsVKrPnQMLtrvhw8"
+                );
+                assert_eq!(hostname, "example.com");
+                assert_eq!(other_hosts.len(), 0);
+            }
+            _ => panic!("unexpected"),
+        }
+
+        match check_ssh_known_hosts_loaded(
+            &khs,
+            "foo.example.com",
+            SshHostKeyType::Rsa,
+            &khs[0].key,
+        ) {
+            Err(KnownHostError::HostKeyNotFound { other_hosts, .. }) => {
+                assert_eq!(other_hosts.len(), 1);
+                assert_eq!(other_hosts[0].patterns, "example.com,rust-lang.org");
+            }
+            _ => panic!("unexpected"),
+        }
+
+        let mut modified_key = khs[0].key.clone();
+        modified_key[0] = 1;
+        match check_ssh_known_hosts_loaded(&khs, "example.com", SshHostKeyType::Rsa, &modified_key)
+        {
+            Err(KnownHostError::HostKeyHasChanged { old_known_host, .. }) => {
+                assert!(matches!(
+                    old_known_host.location,
+                    KnownHostLocation::File { lineno: 4, .. }
+                ));
+            }
+            _ => panic!("unexpected"),
+        }
+    }
+}
diff --git a/src/tools/cargo/src/cargo/sources/git/mod.rs b/src/tools/cargo/src/cargo/sources/git/mod.rs
index b32dbb17b..225bad167 100644
--- a/src/tools/cargo/src/cargo/sources/git/mod.rs
+++ b/src/tools/cargo/src/cargo/sources/git/mod.rs
@@ -1,4 +1,5 @@
 pub use self::source::GitSource;
 pub use self::utils::{fetch, GitCheckout, GitDatabase, GitRemote};
+mod known_hosts;
 mod source;
 mod utils;
diff --git a/src/tools/cargo/src/cargo/sources/git/utils.rs b/src/tools/cargo/src/cargo/sources/git/utils.rs
index 5238fd3c3..dbd547c35 100644
--- a/src/tools/cargo/src/cargo/sources/git/utils.rs
+++ b/src/tools/cargo/src/cargo/sources/git/utils.rs
@@ -683,7 +683,6 @@ where
             | ErrorClass::Submodule
             | ErrorClass::FetchHead
             | ErrorClass::Ssh
-            | ErrorClass::Callback
             | ErrorClass::Http => {
                 let mut msg = "network failure seems to have happened\n".to_string();
                 msg.push_str(
@@ -694,6 +693,13 @@ where
                 );
                 err = err.context(msg);
             }
+            ErrorClass::Callback => {
+                // This unwraps the git2 error. We're using the callback error
+                // specifically to convey errors from Rust land through the C
+                // callback interface. We don't need the `; class=Callback
+                // (26)` that gets tacked on to the git2 error message.
+                err = anyhow::format_err!("{}", e.message());
+            }
             _ => {}
         }
     }
@@ -720,14 +726,27 @@ pub fn with_fetch_options(
     cb: &mut dyn FnMut(git2::FetchOptions<'_>) -> CargoResult<()>,
 ) -> CargoResult<()> {
     let mut progress = Progress::new("Fetch", config);
+    let ssh_config = config.net_config()?.ssh.as_ref();
+    let config_known_hosts = ssh_config.and_then(|ssh| ssh.known_hosts.as_ref());
+    let diagnostic_home_config = config.diagnostic_home_config();
     network::with_retry(config, || {
         with_authentication(url, git_config, |f| {
+            let port = Url::parse(url).ok().and_then(|url| url.port());
             let mut last_update = Instant::now();
             let mut rcb = git2::RemoteCallbacks::new();
             // We choose `N=10` here to make a `300ms * 10slots ~= 3000ms`
             // sliding window for tracking the data transfer rate (in bytes/s).
             let mut counter = MetricsCounter::<10>::new(0, last_update);
             rcb.credentials(f);
+            rcb.certificate_check(|cert, host| {
+                super::known_hosts::certificate_check(
+                    cert,
+                    host,
+                    port,
+                    config_known_hosts,
+                    &diagnostic_home_config,
+                )
+            });
             rcb.transfer_progress(|stats| {
                 let indexed_deltas = stats.indexed_deltas();
                 let msg = if indexed_deltas > 0 {
diff --git a/src/tools/cargo/src/cargo/util/config/de.rs b/src/tools/cargo/src/cargo/util/config/de.rs
index 6fddc7e71..1408f15b5 100644
--- a/src/tools/cargo/src/cargo/util/config/de.rs
+++ b/src/tools/cargo/src/cargo/util/config/de.rs
@@ -384,7 +384,12 @@ impl<'de> de::SeqAccess<'de> for ConfigSeqAccess {
     {
         match self.list_iter.next() {
             // TODO: add `def` to error?
-            Some((value, _def)) => seed.deserialize(value.into_deserializer()).map(Some),
+            Some((value, def)) => {
+                // This might be a String or a Value<String>.
+                // ValueDeserializer will handle figuring out which one it is.
+                let maybe_value_de = ValueDeserializer::new_with_string(value, def);
+                seed.deserialize(maybe_value_de).map(Some)
+            }
             None => Ok(None),
         }
     }
@@ -400,7 +405,17 @@ impl<'de> de::SeqAccess<'de> for ConfigSeqAccess {
 struct ValueDeserializer<'config> {
     hits: u32,
     definition: Definition,
-    de: Deserializer<'config>,
+    /// The deserializer, used to actually deserialize a Value struct.
+    /// This is `None` if deserializing a string.
+    de: Option<Deserializer<'config>>,
+    /// A string value to deserialize.
+    ///
+    /// This is used for situations where you can't address a string via a
+    /// TOML key, such as a string inside an array. The `ConfigSeqAccess`
+    /// doesn't know if the type it should deserialize to is a `String` or
+    /// `Value<String>`, so `ValueDeserializer` needs to be able to handle
+    /// both.
+    str_value: Option<String>,
 }
 
 impl<'config> ValueDeserializer<'config> {
@@ -428,9 +443,19 @@ impl<'config> ValueDeserializer<'config> {
         Ok(ValueDeserializer {
             hits: 0,
             definition,
-            de,
+            de: Some(de),
+            str_value: None,
         })
     }
+
+    fn new_with_string(s: String, definition: Definition) -> ValueDeserializer<'config> {
+        ValueDeserializer {
+            hits: 0,
+            definition,
+            de: None,
+            str_value: Some(s),
+        }
+    }
 }
 
 impl<'de, 'config> de::MapAccess<'de> for ValueDeserializer<'config> {
@@ -459,9 +484,14 @@ impl<'de, 'config> de::MapAccess<'de> for ValueDeserializer<'config> {
         // If this is the first time around we deserialize the `value` field
         // which is the actual deserializer
         if self.hits == 1 {
-            return seed
-                .deserialize(self.de.clone())
-                .map_err(|e| e.with_key_context(&self.de.key, self.definition.clone()));
+            if let Some(de) = &self.de {
+                return seed
+                    .deserialize(de.clone())
+                    .map_err(|e| e.with_key_context(&de.key, self.definition.clone()));
+            } else {
+                return seed
+                    .deserialize(self.str_value.as_ref().unwrap().clone().into_deserializer());
+            }
         }
 
         // ... otherwise we're deserializing the `definition` field, so we need
@@ -484,6 +514,71 @@ impl<'de, 'config> de::MapAccess<'de> for ValueDeserializer<'config> {
     }
 }
 
+// Deserializer is only implemented to handle deserializing a String inside a
+// sequence (like `Vec<String>` or `Vec<Value<String>>`). `Value<String>` is
+// handled by deserialize_struct, and the plain `String` is handled by all the
+// other functions here.
+impl<'de, 'config> de::Deserializer<'de> for ValueDeserializer<'config> {
+    type Error = ConfigError;
+
+    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>
+    where
+        V: de::Visitor<'de>,
+    {
+        visitor.visit_str(&self.str_value.expect("string expected"))
+    }
+
+    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>
+    where
+        V: de::Visitor<'de>,
+    {
+        visitor.visit_string(self.str_value.expect("string expected"))
+    }
+
+    fn deserialize_struct<V>(
+        self,
+        name: &'static str,
+        fields: &'static [&'static str],
+        visitor: V,
+    ) -> Result<V::Value, Self::Error>
+    where
+        V: de::Visitor<'de>,
+    {
+        // Match on the magical struct name/field names that are passed in to
+        // detect when we're deserializing `Value<T>`.
+        //
+        // See more comments in `value.rs` for the protocol used here.
+        if name == value::NAME && fields == value::FIELDS {
+            return visitor.visit_map(self);
+        }
+        unimplemented!("only strings and Value can be deserialized from a sequence");
+    }
+
+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>
+    where
+        V: de::Visitor<'de>,
+    {
+        visitor.visit_string(self.str_value.expect("string expected"))
+    }
+
+    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>
+    where
+        V: de::Visitor<'de>,
+    {
+        visitor.visit_unit()
+    }
+
+    serde::forward_to_deserialize_any! {
+        i8 i16 i32 i64
+        u8 u16 u32 u64
+        option
+        newtype_struct seq tuple tuple_struct map enum bool
+        f32 f64 char bytes
+        byte_buf unit unit_struct
+        identifier
+    }
+}
+
 /// A deserializer which takes two values and deserializes into a tuple of those
 /// two values. This is similar to types like `StrDeserializer` in upstream
 /// serde itself.
diff --git a/src/tools/cargo/src/cargo/util/config/mod.rs b/src/tools/cargo/src/cargo/util/config/mod.rs
index 765c93db7..607d5c023 100644
--- a/src/tools/cargo/src/cargo/util/config/mod.rs
+++ b/src/tools/cargo/src/cargo/util/config/mod.rs
@@ -327,6 +327,18 @@ impl Config {
         &self.home_path
     }
 
+    /// Returns a path to display to the user with the location of their home
+    /// config file (to only be used for displaying a diagnostics suggestion,
+    /// such as recommending where to add a config value).
+    pub fn diagnostic_home_config(&self) -> String {
+        let home = self.home_path.as_path_unlocked();
+        let path = match self.get_file_path(home, "config", false) {
+            Ok(Some(existing_path)) => existing_path,
+            _ => home.join("config.toml"),
+        };
+        path.to_string_lossy().to_string()
+    }
+
     /// Gets the Cargo Git directory (`<cargo_home>/git`).
     pub fn git_path(&self) -> Filesystem {
         self.home_path.join("git")
@@ -2224,6 +2236,13 @@ pub struct CargoNetConfig {
     pub retry: Option<u32>,
     pub offline: Option<bool>,
     pub git_fetch_with_cli: Option<bool>,
+    pub ssh: Option<CargoSshConfig>,
+}
+
+#[derive(Debug, Deserialize)]
+#[serde(rename_all = "kebab-case")]
+pub struct CargoSshConfig {
+    pub known_hosts: Option<Vec<Value<String>>>,
 }
 
 #[derive(Debug, Deserialize)]
diff --git a/src/tools/cargo/src/doc/src/appendix/git-authentication.md b/src/tools/cargo/src/doc/src/appendix/git-authentication.md
index 7fe1f149a..f46a6535c 100644
--- a/src/tools/cargo/src/doc/src/appendix/git-authentication.md
+++ b/src/tools/cargo/src/doc/src/appendix/git-authentication.md
@@ -58,9 +58,34 @@ on how to start `ssh-agent` and to add keys.
 > used by Cargo's built-in SSH library. More advanced requirements should use
 > [`net.git-fetch-with-cli`].
 
+### SSH Known Hosts
+
+When connecting to an SSH host, Cargo must verify the identity of the host
+using "known hosts", which are a list of host keys. Cargo can look for these
+known hosts in OpenSSH-style `known_hosts` files located in their standard
+locations (`.ssh/known_hosts` in your home directory, or
+`/etc/ssh/ssh_known_hosts` on Unix-like platforms or
+`%PROGRAMDATA%\ssh\ssh_known_hosts` on Windows). More information about these
+files can be found in the [sshd man page]. Alternatively, keys may be
+configured in a Cargo configuration file with [`net.ssh.known-hosts`].
+
+When connecting to an SSH host before the known hosts has been configured,
+Cargo will display an error message instructing you how to add the host key.
+This also includes a "fingerprint", which is a smaller hash of the host key,
+which should be easier to visually verify. The server administrator can get
+the fingerprint by running `ssh-keygen` against the public key (for example,
+`ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub`). Well-known sites may
+publish their fingerprints on the web; for example GitHub posts theirs at
+<https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints>.
+
+Cargo comes with the host keys for [github.com](https://github.com) built-in.
+If those ever change, you can add the new keys to the config or known_hosts file.
+
 [`credential.helper`]: https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage
 [`net.git-fetch-with-cli`]: ../reference/config.md#netgit-fetch-with-cli
+[`net.ssh.known-hosts`]: ../reference/config.md#netsshknown-hosts
 [GCM]: https://github.com/microsoft/Git-Credential-Manager-Core/
 [PuTTY]: https://www.chiark.greenend.org.uk/~sgtatham/putty/
 [Microsoft installation documentation]: https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse
 [key management]: https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement
+[sshd man page]: https://man.openbsd.org/sshd#SSH_KNOWN_HOSTS_FILE_FORMAT
diff --git a/src/tools/cargo/src/doc/src/reference/config.md b/src/tools/cargo/src/doc/src/reference/config.md
index f60c185e9..cc4a505ed 100644
--- a/src/tools/cargo/src/doc/src/reference/config.md
+++ b/src/tools/cargo/src/doc/src/reference/config.md
@@ -114,6 +114,9 @@ retry = 2                   # network retries
 git-fetch-with-cli = true   # use the `git` executable for git operations
 offline = true              # do not access the network
 
+[net.ssh]
+known-hosts = ["..."]       # known SSH host keys
+
 [patch.<registry>]
 # Same keys as for [patch] in Cargo.toml
 
@@ -749,6 +752,41 @@ needed, and generate an error if it encounters a network error.
 
 Can be overridden with the `--offline` command-line option.
 
+##### `net.ssh`
+
+The `[net.ssh]` table contains settings for SSH connections.
+
+##### `net.ssh.known-hosts`
+* Type: array of strings
+* Default: see description
+* Environment: not supported
+
+The `known-hosts` array contains a list of SSH host keys that should be
+accepted as valid when connecting to an SSH server (such as for SSH git
+dependencies). Each entry should be a string in a format similar to OpenSSH
+`known_hosts` files. Each string should start with one or more hostnames
+separated by commas, a space, the key type name, a space, and the
+base64-encoded key. For example:
+
+```toml
+[net.ssh]
+known-hosts = [
+    "example.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFO4Q5T0UV0SQevair9PFwoxY9dl4pQl3u5phoqJH3cF"
+]
+```
+
+Cargo will attempt to load known hosts keys from common locations supported in
+OpenSSH, and will join those with any listed in a Cargo configuration file.
+If any matching entry has the correct key, the connection will be allowed.
+
+Cargo comes with the host keys for [github.com][github-keys] built-in. If
+those ever change, you can add the new keys to the config or known_hosts file.
+
+See [Git Authentication](../appendix/git-authentication.md#ssh-known-hosts)
+for more details.
+
+[github-keys]: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints
+
 #### `[patch]`
 
 Just as you can override dependencies using [`[patch]` in
diff --git a/src/tools/cargo/tests/testsuite/config.rs b/src/tools/cargo/tests/testsuite/config.rs
index b1d07bb40..d1487833f 100644
--- a/src/tools/cargo/tests/testsuite/config.rs
+++ b/src/tools/cargo/tests/testsuite/config.rs
@@ -1,7 +1,7 @@
 //! Tests for config settings.
 
 use cargo::core::{PackageIdSpec, Shell};
-use cargo::util::config::{self, Config, SslVersionConfig, StringList};
+use cargo::util::config::{self, Config, Definition, SslVersionConfig, StringList};
 use cargo::util::interning::InternedString;
 use cargo::util::toml::{self, VecStringOrBool as VSOB};
 use cargo::CargoResult;
@@ -1508,3 +1508,59 @@ fn all_profile_options() {
     let roundtrip_toml = toml_edit::easy::to_string(&roundtrip).unwrap();
     compare::assert_match_exact(&profile_toml, &roundtrip_toml);
 }
+
+#[cargo_test]
+fn value_in_array() {
+    // Value<String> in an array should work
+    let root_path = paths::root().join(".cargo/config.toml");
+    write_config_at(
+        &root_path,
+        "\
+[net.ssh]
+known-hosts = [
+    \"example.com ...\",
+    \"example.net ...\",
+]
+",
+    );
+
+    let foo_path = paths::root().join("foo/.cargo/config.toml");
+    write_config_at(
+        &foo_path,
+        "\
+[net.ssh]
+known-hosts = [
+    \"example.org ...\",
+]
+",
+    );
+
+    let config = ConfigBuilder::new()
+        .cwd("foo")
+        // environment variables don't actually work for known-hosts due to
+        // space splitting, but this is included here just to validate that
+        // they work (particularly if other Vec<Value> config vars are added
+        // in the future).
+        .env("CARGO_NET_SSH_KNOWN_HOSTS", "env-example")
+        .build();
+    let net_config = config.net_config().unwrap();
+    let kh = net_config
+        .ssh
+        .as_ref()
+        .unwrap()
+        .known_hosts
+        .as_ref()
+        .unwrap();
+    assert_eq!(kh.len(), 4);
+    assert_eq!(kh[0].val, "example.org ...");
+    assert_eq!(kh[0].definition, Definition::Path(foo_path.clone()));
+    assert_eq!(kh[1].val, "example.com ...");
+    assert_eq!(kh[1].definition, Definition::Path(root_path.clone()));
+    assert_eq!(kh[2].val, "example.net ...");
+    assert_eq!(kh[2].definition, Definition::Path(root_path.clone()));
+    assert_eq!(kh[3].val, "env-example");
+    assert_eq!(
+        kh[3].definition,
+        Definition::Environment("CARGO_NET_SSH_KNOWN_HOSTS".to_string())
+    );
+}
diff --git a/vendor/base64/.cargo-checksum.json b/vendor/base64/.cargo-checksum.json
new file mode 100644
index 000000000..03a68d2fe
--- /dev/null
+++ b/vendor/base64/.cargo-checksum.json
@@ -0,0 +1 @@
+{"files":{"Cargo.lock":"0ed67b0f1f68ba5e19475d679df711f1f2c421768462b58e327b5b3ae9111825","Cargo.toml":"ac3f54d7667cfc0baac784fcc6f0a6cc0da9b496af69917fe7abb95f7e3b4a36","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"0dd882e53de11566d50f8e8e2d5a651bcf3fabee4987d70f306233cf39094ba7","README.md":"2810098d290f3df719e6f41ffca38bb954d0fe62d4e56905a9a2436c4784bebf","RELEASE-NOTES.md":"ef116f3596474c9920957f65e346d7d1954f194aa3458eac5b626781116c500b","benches/benchmarks.rs":"bc1f603c5aa87627a93eee71eaed64fbd767d013051bac00ea265c16fecb30b9","examples/base64.rs":"f397b8726df41fce0793a8c6ebe95d4651aa37ed746da305032f1e99d9c37235","examples/make_tables.rs":"392f51b3edb1b5a2c62b823337c7785a6b8535f39f09283b1913a5c68fb186bf","icon_CLion.svg":"cffa044ba75cb998ee3306991dc4a3755ec2f39ab95ddd4b74bc21988389020f","src/chunked_encoder.rs":"fba5ea5f1204b9bf11291ec3483bcb23d330101eb2f6635e33cd63e4de13b653","src/decode.rs":"ba67f53612c494281e2e4aae4350165d54ee827ea7e1170b8e02e2db81b55c6e","src/display.rs":"55f9cd05ba037b77689e2558fa174055fad5273959d1edce3a2289f94244fd5d","src/encode.rs":"8a0a6b71581b4c52c2844111a3611cf73522533452a27f5ef8d09eaa73594e2e","src/lib.rs":"c7b904fac8706bc4758c2763e7a43dc1edd99ed5641ac2355957f6aeff91eece","src/read/decoder.rs":"9a7b65e165f7aed6b007bf7436ac9ba9b03d3b03e9d5a1e16691874e21509ced","src/read/decoder_tests.rs":"aacb7624c33ed6b90e068ff9af6095c839b4088060b4c406c08dce25ce837f6d","src/read/mod.rs":"e0b714eda02d16b1ffa6f78fd09b2f963e01c881b1f7c17b39db4e904be5e746","src/tables.rs":"73ce100fd3f4917ec1e8d9277ff0b956cc2636b33145f101a7cf1a5a8b7bacc1","src/tests.rs":"202ddced9cf52205182c6202e583c4c4f929b9d225fd9d1ebdbfd389cb2df0ba","src/write/encoder.rs":"573f058a66f0a6af4215f5ae75a3e96b07a5e345975693abe30bd1e8ce2d235c","src/write/encoder_string_writer.rs":"3f9109585babe048230659f64973cb1633bbb2ed9de255177336260226127b81","src/write/encoder_tests.rs":"381d7c2871407157c36e909c928307ac0389b3d4504fb80607134e94ac59e68f","src/write/mod.rs":"1503b9457e4f5d2895b24136c3af893f0b7ce18dfe4de1096fc5d17f8d78e99b","tests/decode.rs":"da2cbd49b84e0d8b1d8a52136ba3d97cfb248920a45f9955db1e5bc5367218ce","tests/encode.rs":"5efb6904c36c6f899a05078e5c9be756fc58af1ee9940edfa8dea1ee53675364","tests/helpers.rs":"a76015e4a4e8f98213bdbaa592cd9574ccdc95a28e1b1f835a2753e09fa6037f","tests/tests.rs":"05753e5f1d4a6c75015a5342f9b5dc3073c00bdfe0a829a962f8723321c75549"},"package":"9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"}
\ No newline at end of file
diff --git a/vendor/base64/Cargo.lock b/vendor/base64/Cargo.lock
new file mode 100644
index 000000000..94e03eedc
--- /dev/null
+++ b/vendor/base64/Cargo.lock
@@ -0,0 +1,826 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 3
+
+[[package]]
+name = "ansi_term"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2"
+dependencies = [
+ "winapi",
+]
+
+[[package]]
+name = "atty"
+version = "0.2.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
+dependencies = [
+ "hermit-abi",
+ "libc",
+ "winapi",
+]
+
+[[package]]
+name = "autocfg"
+version = "0.1.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0dde43e75fd43e8a1bf86103336bc699aa8d17ad1be60c76c0bdfd4828e19b78"
+dependencies = [
+ "autocfg 1.1.0",
+]
+
+[[package]]
+name = "autocfg"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
+
+[[package]]
+name = "base64"
+version = "0.13.1"
+dependencies = [
+ "criterion",
+ "rand",
+ "structopt",
+]
+
+[[package]]
+name = "bitflags"
+version = "1.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
+
+[[package]]
+name = "bstr"
+version = "0.2.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba3569f383e8f1598449f1a423e72e99569137b47740b1da11ef19af3d5c3223"
+dependencies = [
+ "lazy_static",
+ "memchr",
+ "regex-automata",
+ "serde",
+]
+
+[[package]]
+name = "bumpalo"
+version = "3.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "572f695136211188308f16ad2ca5c851a712c464060ae6974944458eb83880ba"
+
+[[package]]
+name = "cast"
+version = "0.2.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4c24dab4283a142afa2fdca129b80ad2c6284e073930f964c3a1293c225ee39a"
+dependencies = [
+ "rustc_version",
+]
+
+[[package]]
+name = "cast"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "37b2a672a2cb129a2e41c10b1224bb368f9f37a2b16b612598138befd7b37eb5"
+
+[[package]]
+name = "cfg-if"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
+
+[[package]]
+name = "clap"
+version = "2.34.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a0610544180c38b88101fecf2dd634b174a62eef6946f84dfc6a7127512b381c"
+dependencies = [
+ "ansi_term",
+ "atty",
+ "bitflags",
+ "strsim",
+ "textwrap",
+ "unicode-width",
+ "vec_map",
+]
+
+[[package]]
+name = "cloudabi"
+version = "0.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f"
+dependencies = [
+ "bitflags",
+]
+
+[[package]]
+name = "criterion"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "63f696897c88b57f4ffe3c69d8e1a0613c7d0e6c4833363c8560fbde9c47b966"
+dependencies = [
+ "atty",
+ "cast 0.2.7",
+ "clap",
+ "criterion-plot",
+ "csv",
+ "itertools 0.9.0",
+ "lazy_static",
+ "num-traits",
+ "oorandom",
+ "plotters",
+ "rayon",
+ "regex",
+ "serde",
+ "serde_derive",
+ "serde_json",
+ "tinytemplate",
+ "walkdir",
+]
+
+[[package]]
+name = "criterion-plot"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2673cc8207403546f45f5fd319a974b1e6983ad1a3ee7e6041650013be041876"
+dependencies = [
+ "cast 0.3.0",
+ "itertools 0.10.5",
+]
+
+[[package]]
+name = "crossbeam-channel"
+version = "0.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c2dd04ddaf88237dc3b8d8f9a3c1004b506b54b3313403944054d23c0870c521"
+dependencies = [
+ "cfg-if",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-deque"
+version = "0.8.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "715e8152b692bba2d374b53d4875445368fdf21a94751410af607a5ac677d1fc"
+dependencies = [
+ "cfg-if",
+ "crossbeam-epoch",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-epoch"
+version = "0.9.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f916dfc5d356b0ed9dae65f1db9fc9770aa2851d2662b988ccf4fe3516e86348"
+dependencies = [
+ "autocfg 1.1.0",
+ "cfg-if",
+ "crossbeam-utils",
+ "memoffset",
+ "scopeguard",
+]
+
+[[package]]
+name = "crossbeam-utils"
+version = "0.8.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "edbafec5fa1f196ca66527c1b12c2ec4745ca14b50f1ad8f9f6f720b55d11fac"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "csv"
+version = "1.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "22813a6dc45b335f9bade10bf7271dc477e81113e89eb251a0bc2a8a81c536e1"
+dependencies = [
+ "bstr",
+ "csv-core",
+ "itoa 0.4.8",
+ "ryu",
+ "serde",
+]
+
+[[package]]
+name = "csv-core"
+version = "0.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b2466559f260f48ad25fe6317b3c8dac77b5bdb5763ac7d9d6103530663bc90"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "either"
+version = "1.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "90e5c1c8368803113bf0c9584fc495a58b86dc8a29edbf8fe877d21d9507e797"
+
+[[package]]
+name = "fuchsia-cprng"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba"
+
+[[package]]
+name = "heck"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c"
+dependencies = [
+ "unicode-segmentation",
+]
+
+[[package]]
+name = "hermit-abi"
+version = "0.1.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "itertools"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "284f18f85651fe11e8a991b2adb42cb078325c996ed026d994719efcfca1d54b"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "itertools"
+version = "0.10.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
+dependencies = [
+ "either",
+]
+
+[[package]]
+name = "itoa"
+version = "0.4.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b71991ff56294aa922b450139ee08b3bfc70982c6b2c7562771375cf73542dd4"
+
+[[package]]
+name = "itoa"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4217ad341ebadf8d8e724e264f13e593e0648f5b3e94b3896a5df283be015ecc"
+
+[[package]]
+name = "js-sys"
+version = "0.3.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "49409df3e3bf0856b916e2ceaca09ee28e6871cf7d9ce97a692cacfdb2a25a47"
+dependencies = [
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "lazy_static"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
+
+[[package]]
+name = "libc"
+version = "0.2.135"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c"
+
+[[package]]
+name = "log"
+version = "0.4.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "memchr"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"
+
+[[package]]
+name = "memoffset"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce"
+dependencies = [
+ "autocfg 1.1.0",
+]
+
+[[package]]
+name = "num-traits"
+version = "0.2.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "578ede34cf02f8924ab9447f50c28075b4d3e5b269972345e7e0372b38c6cdcd"
+dependencies = [
+ "autocfg 1.1.0",
+]
+
+[[package]]
+name = "num_cpus"
+version = "1.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19e64526ebdee182341572e50e9ad03965aa510cd94427a4549448f285e957a1"
+dependencies = [
+ "hermit-abi",
+ "libc",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.15.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e82dad04139b71a90c080c8463fe0dc7902db5192d939bd0950f074d014339e1"
+
+[[package]]
+name = "oorandom"
+version = "11.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0ab1bc2a289d34bd04a330323ac98a1b4bc82c9d9fcb1e66b63caa84da26b575"
+
+[[package]]
+name = "plotters"
+version = "0.2.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0d1685fbe7beba33de0330629da9d955ac75bd54f33d7b79f9a895590124f6bb"
+dependencies = [
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "web-sys",
+]
+
+[[package]]
+name = "proc-macro-error"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
+dependencies = [
+ "proc-macro-error-attr",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "version_check",
+]
+
+[[package]]
+name = "proc-macro-error-attr"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "version_check",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.47"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5ea3d908b0e36316caf9e9e2c4625cdde190a7e6f440d794667ed17a1855e725"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bbe448f377a7d6961e30f5955f9b8d106c3f5e449d493ee1b125c1d43c2b5179"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "rand"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca"
+dependencies = [
+ "autocfg 0.1.8",
+ "libc",
+ "rand_chacha",
+ "rand_core 0.4.2",
+ "rand_hc",
+ "rand_isaac",
+ "rand_jitter",
+ "rand_os",
+ "rand_pcg",
+ "rand_xorshift",
+ "winapi",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "556d3a1ca6600bfcbab7c7c91ccb085ac7fbbcd70e008a98742e7847f4f7bcef"
+dependencies = [
+ "autocfg 0.1.8",
+ "rand_core 0.3.1",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b"
+dependencies = [
+ "rand_core 0.4.2",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c33a3c44ca05fa6f1807d8e6743f3824e8509beca625669633be0acbdf509dc"
+
+[[package]]
+name = "rand_hc"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4"
+dependencies = [
+ "rand_core 0.3.1",
+]
+
+[[package]]
+name = "rand_isaac"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08"
+dependencies = [
+ "rand_core 0.3.1",
+]
+
+[[package]]
+name = "rand_jitter"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1166d5c91dc97b88d1decc3285bb0a99ed84b05cfd0bc2341bdf2d43fc41e39b"
+dependencies = [
+ "libc",
+ "rand_core 0.4.2",
+ "winapi",
+]
+
+[[package]]
+name = "rand_os"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b75f676a1e053fc562eafbb47838d67c84801e38fc1ba459e8f180deabd5071"
+dependencies = [
+ "cloudabi",
+ "fuchsia-cprng",
+ "libc",
+ "rand_core 0.4.2",
+ "rdrand",
+ "winapi",
+]
+
+[[package]]
+name = "rand_pcg"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "abf9b09b01790cfe0364f52bf32995ea3c39f4d2dd011eac241d2914146d0b44"
+dependencies = [
+ "autocfg 0.1.8",
+ "rand_core 0.4.2",
+]
+
+[[package]]
+name = "rand_xorshift"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cbf7e9e623549b0e21f6e97cf8ecf247c1a8fd2e8a992ae265314300b2455d5c"
+dependencies = [
+ "rand_core 0.3.1",
+]
+
+[[package]]
+name = "rayon"
+version = "1.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd99e5772ead8baa5215278c9b15bf92087709e9c1b2d1f97cdb5a183c933a7d"
+dependencies = [
+ "autocfg 1.1.0",
+ "crossbeam-deque",
+ "either",
+ "rayon-core",
+]
+
+[[package]]
+name = "rayon-core"
+version = "1.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "258bcdb5ac6dad48491bb2992db6b7cf74878b0384908af124823d118c99683f"
+dependencies = [
+ "crossbeam-channel",
+ "crossbeam-deque",
+ "crossbeam-utils",
+ "num_cpus",
+]
+
+[[package]]
+name = "rdrand"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2"
+dependencies = [
+ "rand_core 0.3.1",
+]
+
+[[package]]
+name = "regex"
+version = "1.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4c4eb3267174b8c6c2f654116623910a0fef09c4753f8dd83db29c48a0df988b"
+dependencies = [
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-automata"
+version = "0.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
+
+[[package]]
+name = "regex-syntax"
+version = "0.6.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a3f87b73ce11b1619a3c6332f45341e0047173771e8b8b73f87bfeefb7b56244"
+
+[[package]]
+name = "rustc_version"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
+dependencies = [
+ "semver",
+]
+
+[[package]]
+name = "ryu"
+version = "1.0.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4501abdff3ae82a1c1b477a17252eb69cee9e66eb915c1abaa4f44d873df9f09"
+
+[[package]]
+name = "same-file"
+version = "1.0.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
+dependencies = [
+ "winapi-util",
+]
+
+[[package]]
+name = "scopeguard"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
+
+[[package]]
+name = "semver"
+version = "1.0.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e25dfac463d778e353db5be2449d1cce89bd6fd23c9f1ea21310ce6e5a1b29c4"
+
+[[package]]
+name = "serde"
+version = "1.0.146"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6df50b7a60a0ad48e1b42eb38373eac8ff785d619fb14db917b4e63d5439361f"
+
+[[package]]
+name = "serde_derive"
+version = "1.0.146"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a714fd32ba1d66047ce7d53dabd809e9922d538f9047de13cc4cffca47b36205"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.87"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ce777b7b150d76b9cf60d28b55f5847135a003f7d7350c6be7a773508ce7d45"
+dependencies = [
+ "itoa 1.0.4",
+ "ryu",
+ "serde",
+]
+
+[[package]]
+name = "strsim"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a"
+
+[[package]]
+name = "structopt"
+version = "0.3.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0c6b5c64445ba8094a6ab0c3cd2ad323e07171012d9c98b0b15651daf1787a10"
+dependencies = [
+ "clap",
+ "lazy_static",
+ "structopt-derive",
+]
+
+[[package]]
+name = "structopt-derive"
+version = "0.4.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dcb5ae327f9cc13b68763b5749770cb9e048a99bd9dfdfa58d0cf05d5f64afe0"
+dependencies = [
+ "heck",
+ "proc-macro-error",
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "syn"
+version = "1.0.103"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a864042229133ada95abf3b54fdc62ef5ccabe9515b64717bcb9a1919e59445d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
+[[package]]
+name = "textwrap"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060"
+dependencies = [
+ "unicode-width",
+]
+
+[[package]]
+name = "tinytemplate"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "be4d6b5f19ff7664e8c98d03e2139cb510db9b0a60b55f8e8709b689d939b6bc"
+dependencies = [
+ "serde",
+ "serde_json",
+]
+
+[[package]]
+name = "unicode-ident"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ceab39d59e4c9499d4e5a8ee0e2735b891bb7308ac83dfb4e80cad195c9f6f3"
+
+[[package]]
+name = "unicode-segmentation"
+version = "1.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fdbf052a0783de01e944a6ce7a8cb939e295b1e7be835a1112c3b9a7f047a5a"
+
+[[package]]
+name = "unicode-width"
+version = "0.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c0edd1e5b14653f783770bce4a4dabb4a5108a5370a5f5d8cfe8710c361f6c8b"
+
+[[package]]
+name = "vec_map"
+version = "0.8.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191"
+
+[[package]]
+name = "version_check"
+version = "0.9.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"
+
+[[package]]
+name = "walkdir"
+version = "2.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "808cf2735cd4b6866113f648b791c6adc5714537bc222d9347bb203386ffda56"
+dependencies = [
+ "same-file",
+ "winapi",
+ "winapi-util",
+]
+
+[[package]]
+name = "wasm-bindgen"
+version = "0.2.83"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eaf9f5aceeec8be17c128b2e93e031fb8a4d469bb9c4ae2d7dc1888b26887268"
+dependencies = [
+ "cfg-if",
+ "wasm-bindgen-macro",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.83"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4c8ffb332579b0557b52d268b91feab8df3615f265d5270fec2a8c95b17c1142"
+dependencies = [
+ "bumpalo",
+ "log",
+ "once_cell",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.83"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "052be0f94026e6cbc75cdefc9bae13fd6052cdcaf532fa6c45e7ae33a1e6c810"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.83"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "07bc0c051dc5f23e307b13285f9d75df86bfdf816c5721e573dec1f9b8aa193c"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.83"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1c38c045535d93ec4f0b4defec448e4291638ee608530863b1e2ba115d4fff7f"
+
+[[package]]
+name = "web-sys"
+version = "0.3.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bcda906d8be16e728fd5adc5b729afad4e444e106ab28cd1c7256e54fa61510f"
+dependencies = [
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "winapi"
+version = "0.3.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
+dependencies = [
+ "winapi-i686-pc-windows-gnu",
+ "winapi-x86_64-pc-windows-gnu",
+]
+
+[[package]]
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
+
+[[package]]
+name = "winapi-util"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178"
+dependencies = [
+ "winapi",
+]
+
+[[package]]
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
diff --git a/vendor/base64/Cargo.toml b/vendor/base64/Cargo.toml
new file mode 100644
index 000000000..64179e1aa
--- /dev/null
+++ b/vendor/base64/Cargo.toml
@@ -0,0 +1,53 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g., crates.io) dependencies.
+#
+# If you are reading this file be aware that the original Cargo.toml
+# will likely look very different (and much more reasonable).
+# See Cargo.toml.orig for the original contents.
+
+[package]
+edition = "2018"
+name = "base64"
+version = "0.13.1"
+authors = [
+    "Alice Maz <alice@alicemaz.com>",
+    "Marshall Pierce <marshall@mpierce.org>",
+]
+description = "encodes and decodes base64 as bytes or utf8"
+documentation = "https://docs.rs/base64"
+readme = "README.md"
+keywords = [
+    "base64",
+    "utf8",
+    "encode",
+    "decode",
+    "no_std",
+]
+categories = ["encoding"]
+license = "MIT/Apache-2.0"
+repository = "https://github.com/marshallpierce/rust-base64"
+
+[profile.bench]
+debug = true
+
+[[bench]]
+name = "benchmarks"
+harness = false
+
+[dev-dependencies.criterion]
+version = "=0.3.2"
+
+[dev-dependencies.rand]
+version = "0.6.1"
+
+[dev-dependencies.structopt]
+version = "0.3"
+
+[features]
+alloc = []
+default = ["std"]
+std = []
diff --git a/vendor/base64/LICENSE-APACHE b/vendor/base64/LICENSE-APACHE
new file mode 100644
index 000000000..16fe87b06
--- /dev/null
+++ b/vendor/base64/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/vendor/base64/LICENSE-MIT b/vendor/base64/LICENSE-MIT
new file mode 100644
index 000000000..7bc10f80a
--- /dev/null
+++ b/vendor/base64/LICENSE-MIT
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2015 Alice Maz
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/vendor/base64/README.md b/vendor/base64/README.md
new file mode 100644
index 000000000..7815966c3
--- /dev/null
+++ b/vendor/base64/README.md
@@ -0,0 +1,114 @@
+[base64](https://crates.io/crates/base64)
+===
+
+[![](https://img.shields.io/crates/v/base64.svg)](https://crates.io/crates/base64) [![Docs](https://docs.rs/base64/badge.svg)](https://docs.rs/base64) [![Build](https://travis-ci.org/marshallpierce/rust-base64.svg?branch=master)](https://travis-ci.org/marshallpierce/rust-base64) [![codecov](https://codecov.io/gh/marshallpierce/rust-base64/branch/master/graph/badge.svg)](https://codecov.io/gh/marshallpierce/rust-base64) [![unsafe forbidden](https://img.shields.io/badge/unsafe-forbidden-success.svg)](https://github.com/rust-secure-code/safety-dance/)
+
+<a href="https://www.jetbrains.com/?from=rust-base64"><img src="/icon_CLion.svg" height="40px"/></a>
+
+Made with CLion. Thanks to JetBrains for supporting open source!
+
+It's base64. What more could anyone want?
+
+This library's goals are to be *correct* and *fast*. It's thoroughly tested and widely used. It exposes functionality at multiple levels of abstraction so you can choose the level of convenience vs performance that you want, e.g. `decode_config_slice` decodes into an existing `&mut [u8]` and is pretty fast (2.6GiB/s for a 3 KiB input), whereas `decode_config` allocates a new `Vec<u8>` and returns it, which might be more convenient in some cases, but is slower (although still fast enough for almost any purpose) at 2.1 GiB/s.
+
+Example
+---
+
+```rust
+extern crate base64;
+
+use base64::{encode, decode};
+
+fn main() {
+    let a = b"hello world";
+    let b = "aGVsbG8gd29ybGQ=";
+
+    assert_eq!(encode(a), b);
+    assert_eq!(a, &decode(b).unwrap()[..]);
+}
+```
+
+See the [docs](https://docs.rs/base64) for all the details.
+
+Rust version compatibility
+---
+
+The minimum required Rust version is 1.34.0.
+
+Developing
+---
+
+Benchmarks are in `benches/`. Running them requires nightly rust, but `rustup` makes it easy:
+
+```bash
+rustup run nightly cargo bench
+```
+
+Decoding is aided by some pre-calculated tables, which are generated by:
+
+```bash
+cargo run --example make_tables > src/tables.rs.tmp && mv src/tables.rs.tmp src/tables.rs
+```
+
+no_std
+---
+
+This crate supports no_std. By default the crate targets std via the `std` feature. You can deactivate the `default-features` to target core instead. In that case you lose out on all the functionality revolving around `std::io`, `std::error::Error` and heap allocations. There is an additional `alloc` feature that you can activate to bring back the support for heap allocations.
+
+Profiling
+---
+
+On Linux, you can use [perf](https://perf.wiki.kernel.org/index.php/Main_Page) for profiling. Then compile the benchmarks with `rustup nightly run cargo bench --no-run`.
+
+Run the benchmark binary with `perf` (shown here filtering to one particular benchmark, which will make the results easier to read). `perf` is only available to the root user on most systems as it fiddles with event counters in your CPU, so use `sudo`. We need to run the actual benchmark binary, hence the path into `target`. You can see the actual full path with `rustup run nightly cargo bench -v`; it will print out the commands it runs. If you use the exact path that `bench` outputs, make sure you get the one that's for the benchmarks, not the tests. You may also want to `cargo clean` so you have only one `benchmarks-` binary (they tend to accumulate).
+
+```bash
+sudo perf record target/release/deps/benchmarks-* --bench decode_10mib_reuse
+```
+
+Then analyze the results, again with perf:
+
+```bash
+sudo perf annotate -l
+```
+
+You'll see a bunch of interleaved rust source and assembly like this. The section with `lib.rs:327` is telling us that 4.02% of samples saw the `movzbl` aka bit shift as the active instruction. However, this percentage is not as exact as it seems due to a phenomenon called *skid*. Basically, a consequence of how fancy modern CPUs are is that this sort of instruction profiling is inherently inaccurate, especially in branch-heavy code.
+
+```text
+ lib.rs:322    0.70 :     10698:       mov    %rdi,%rax
+    2.82 :        1069b:       shr    $0x38,%rax
+         :                  if morsel == decode_tables::INVALID_VALUE {
+         :                      bad_byte_index = input_index;
+         :                      break;
+         :                  };
+         :                  accum = (morsel as u64) << 58;
+ lib.rs:327    4.02 :     1069f:       movzbl (%r9,%rax,1),%r15d
+         :              // fast loop of 8 bytes at a time
+         :              while input_index < length_of_full_chunks {
+         :                  let mut accum: u64;
+         :
+         :                  let input_chunk = BigEndian::read_u64(&input_bytes[input_index..(input_index + 8)]);
+         :                  morsel = decode_table[(input_chunk >> 56) as usize];
+ lib.rs:322    3.68 :     106a4:       cmp    $0xff,%r15
+         :                  if morsel == decode_tables::INVALID_VALUE {
+    0.00 :        106ab:       je     1090e <base64::decode_config_buf::hbf68a45fefa299c1+0x46e>
+```
+
+
+Fuzzing
+---
+
+This uses [cargo-fuzz](https://github.com/rust-fuzz/cargo-fuzz). See `fuzz/fuzzers` for the available fuzzing scripts. To run, use an invocation like these:
+
+```bash
+cargo +nightly fuzz run roundtrip
+cargo +nightly fuzz run roundtrip_no_pad
+cargo +nightly fuzz run roundtrip_random_config -- -max_len=10240
+cargo +nightly fuzz run decode_random
+```
+
+
+License
+---
+
+This project is dual-licensed under MIT and Apache 2.0.
diff --git a/vendor/base64/RELEASE-NOTES.md b/vendor/base64/RELEASE-NOTES.md
new file mode 100644
index 000000000..6a2e3cae7
--- /dev/null
+++ b/vendor/base64/RELEASE-NOTES.md
@@ -0,0 +1,109 @@
+# 0.13.1
+
+- More precise decode buffer sizing, avoiding unnecessary allocation in `decode_config`.
+
+# 0.13.0
+
+- Config methods are const
+- Added `EncoderStringWriter` to allow encoding directly to a String
+- `EncoderWriter` now owns its delegate writer rather than keeping a reference to it (though refs still work)
+    - As a consequence, it is now possible to extract the delegate writer from an `EncoderWriter` via `finish()`, which returns `Result<W>` instead of `Result<()>`. If you were calling `finish()` explicitly, you will now need to use `let _ = foo.finish()` instead of just `foo.finish()` to avoid a warning about the unused value.
+- When decoding input that has both an invalid length and an invalid symbol as the last byte, `InvalidByte` will be emitted instead of `InvalidLength` to make the problem more obvious.
+
+# 0.12.2
+
+- Add `BinHex` alphabet
+
+# 0.12.1
+
+- Add `Bcrypt` alphabet
+
+# 0.12.0
+
+- A `Read` implementation (`DecoderReader`) to let users transparently decoded data from a b64 input source
+- IMAP's modified b64 alphabet
+- Relaxed type restrictions to just `AsRef<[ut8]>` for main `encode*`/`decode*` functions
+- A minor performance improvement in encoding
+
+# 0.11.0
+- Minimum rust version 1.34.0
+- `no_std` is now supported via the two new features `alloc` and `std`.
+
+# 0.10.1
+
+- Minimum rust version 1.27.2
+- Fix bug in streaming encoding ([#90](https://github.com/marshallpierce/rust-base64/pull/90)): if the underlying writer didn't write all the bytes given to it, the remaining bytes would not be retried later. See the docs on `EncoderWriter::write`.
+- Make it configurable whether or not to return an error when decoding detects excess trailing bits.
+
+# 0.10.0
+
+- Remove line wrapping. Line wrapping was never a great conceptual fit in this library, and other features (streaming encoding, etc) either couldn't support it or could support only special cases of it with a great increase in complexity. Line wrapping has been pulled out into a [line-wrap](https://crates.io/crates/line-wrap) crate, so it's still available if you need it.
+  - `Base64Display` creation no longer uses a `Result` because it can't fail, which means its helper methods for common
+  configs that `unwrap()` for you are no longer needed
+- Add a streaming encoder `Write` impl to transparently base64 as you write.
+- Remove the remaining `unsafe` code.
+- Remove whitespace stripping to simplify `no_std` support. No out of the box configs use it, and it's trivial to do yourself if needed: `filter(|b| !b" \n\t\r\x0b\x0c".contains(b)`.
+- Detect invalid trailing symbols when decoding and return an error rather than silently ignoring them.
+
+# 0.9.3
+
+- Update safemem
+
+# 0.9.2
+
+- Derive `Clone` for `DecodeError`.
+
+# 0.9.1
+
+- Add support for `crypt(3)`'s base64 variant.
+
+# 0.9.0
+
+- `decode_config_slice` function for no-allocation decoding, analogous to `encode_config_slice`
+- Decode performance optimization
+
+# 0.8.0
+
+- `encode_config_slice` function for no-allocation encoding
+
+# 0.7.0
+
+- `STANDARD_NO_PAD` config
+- `Base64Display` heap-free wrapper for use in format strings, etc
+
+# 0.6.0
+
+- Decode performance improvements
+- Use `unsafe` in fewer places
+- Added fuzzers
+
+# 0.5.2
+
+- Avoid usize overflow when calculating length
+- Better line wrapping performance
+
+# 0.5.1
+
+- Temporarily disable line wrapping
+- Add Apache 2.0 license
+
+# 0.5.0
+
+- MIME support, including configurable line endings and line wrapping
+- Removed `decode_ws`
+- Renamed `Base64Error` to `DecodeError`
+
+# 0.4.1
+
+- Allow decoding a `AsRef<[u8]>` instead of just a `&str`
+
+# 0.4.0
+
+- Configurable padding
+- Encode performance improvements
+
+# 0.3.0
+
+- Added encode/decode functions that do not allocate their own storage
+- Decode performance improvements
+- Extraneous padding bytes are no longer ignored. Now, an error will be returned.
diff --git a/vendor/base64/benches/benchmarks.rs b/vendor/base64/benches/benchmarks.rs
new file mode 100644
index 000000000..ddcb7349b
--- /dev/null
+++ b/vendor/base64/benches/benchmarks.rs
@@ -0,0 +1,210 @@
+extern crate base64;
+#[macro_use]
+extern crate criterion;
+extern crate rand;
+
+use base64::display;
+use base64::{
+    decode, decode_config_buf, decode_config_slice, encode, encode_config_buf, encode_config_slice,
+    write, Config,
+};
+
+use criterion::{black_box, Bencher, Criterion, ParameterizedBenchmark, Throughput};
+use rand::{FromEntropy, Rng};
+use std::io::{self, Read, Write};
+
+const TEST_CONFIG: Config = base64::STANDARD;
+
+fn do_decode_bench(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size * 3 / 4);
+    fill(&mut v);
+    let encoded = encode(&v);
+
+    b.iter(|| {
+        let orig = decode(&encoded);
+        black_box(&orig);
+    });
+}
+
+fn do_decode_bench_reuse_buf(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size * 3 / 4);
+    fill(&mut v);
+    let encoded = encode(&v);
+
+    let mut buf = Vec::new();
+    b.iter(|| {
+        decode_config_buf(&encoded, TEST_CONFIG, &mut buf).unwrap();
+        black_box(&buf);
+        buf.clear();
+    });
+}
+
+fn do_decode_bench_slice(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size * 3 / 4);
+    fill(&mut v);
+    let encoded = encode(&v);
+
+    let mut buf = Vec::new();
+    buf.resize(size, 0);
+    b.iter(|| {
+        decode_config_slice(&encoded, TEST_CONFIG, &mut buf).unwrap();
+        black_box(&buf);
+    });
+}
+
+fn do_decode_bench_stream(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size * 3 / 4);
+    fill(&mut v);
+    let encoded = encode(&v);
+
+    let mut buf = Vec::new();
+    buf.resize(size, 0);
+    buf.truncate(0);
+
+    b.iter(|| {
+        let mut cursor = io::Cursor::new(&encoded[..]);
+        let mut decoder = base64::read::DecoderReader::new(&mut cursor, TEST_CONFIG);
+        decoder.read_to_end(&mut buf).unwrap();
+        buf.clear();
+        black_box(&buf);
+    });
+}
+
+fn do_encode_bench(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size);
+    fill(&mut v);
+    b.iter(|| {
+        let e = encode(&v);
+        black_box(&e);
+    });
+}
+
+fn do_encode_bench_display(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size);
+    fill(&mut v);
+    b.iter(|| {
+        let e = format!("{}", display::Base64Display::with_config(&v, TEST_CONFIG));
+        black_box(&e);
+    });
+}
+
+fn do_encode_bench_reuse_buf(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size);
+    fill(&mut v);
+    let mut buf = String::new();
+    b.iter(|| {
+        encode_config_buf(&v, TEST_CONFIG, &mut buf);
+        buf.clear();
+    });
+}
+
+fn do_encode_bench_slice(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size);
+    fill(&mut v);
+    let mut buf = Vec::new();
+    // conservative estimate of encoded size
+    buf.resize(v.len() * 2, 0);
+    b.iter(|| {
+        encode_config_slice(&v, TEST_CONFIG, &mut buf);
+    });
+}
+
+fn do_encode_bench_stream(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size);
+    fill(&mut v);
+    let mut buf = Vec::new();
+
+    buf.reserve(size * 2);
+    b.iter(|| {
+        buf.clear();
+        let mut stream_enc = write::EncoderWriter::new(&mut buf, TEST_CONFIG);
+        stream_enc.write_all(&v).unwrap();
+        stream_enc.flush().unwrap();
+    });
+}
+
+fn do_encode_bench_string_stream(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size);
+    fill(&mut v);
+
+    b.iter(|| {
+        let mut stream_enc = write::EncoderStringWriter::new(TEST_CONFIG);
+        stream_enc.write_all(&v).unwrap();
+        stream_enc.flush().unwrap();
+        let _ = stream_enc.into_inner();
+    });
+}
+
+fn do_encode_bench_string_reuse_buf_stream(b: &mut Bencher, &size: &usize) {
+    let mut v: Vec<u8> = Vec::with_capacity(size);
+    fill(&mut v);
+
+    let mut buf = String::new();
+    b.iter(|| {
+        buf.clear();
+        let mut stream_enc = write::EncoderStringWriter::from(&mut buf, TEST_CONFIG);
+        stream_enc.write_all(&v).unwrap();
+        stream_enc.flush().unwrap();
+        let _ = stream_enc.into_inner();
+    });
+}
+
+fn fill(v: &mut Vec<u8>) {
+    let cap = v.capacity();
+    // weak randomness is plenty; we just want to not be completely friendly to the branch predictor
+    let mut r = rand::rngs::SmallRng::from_entropy();
+    while v.len() < cap {
+        v.push(r.gen::<u8>());
+    }
+}
+
+const BYTE_SIZES: [usize; 5] = [3, 50, 100, 500, 3 * 1024];
+
+// Benchmarks over these byte sizes take longer so we will run fewer samples to
+// keep the benchmark runtime reasonable.
+const LARGE_BYTE_SIZES: [usize; 3] = [3 * 1024 * 1024, 10 * 1024 * 1024, 30 * 1024 * 1024];
+
+fn encode_benchmarks(byte_sizes: &[usize]) -> ParameterizedBenchmark<usize> {
+    ParameterizedBenchmark::new("encode", do_encode_bench, byte_sizes.iter().cloned())
+        .warm_up_time(std::time::Duration::from_millis(500))
+        .measurement_time(std::time::Duration::from_secs(3))
+        .throughput(|s| Throughput::Bytes(*s as u64))
+        .with_function("encode_display", do_encode_bench_display)
+        .with_function("encode_reuse_buf", do_encode_bench_reuse_buf)
+        .with_function("encode_slice", do_encode_bench_slice)
+        .with_function("encode_reuse_buf_stream", do_encode_bench_stream)
+        .with_function("encode_string_stream", do_encode_bench_string_stream)
+        .with_function(
+            "encode_string_reuse_buf_stream",
+            do_encode_bench_string_reuse_buf_stream,
+        )
+}
+
+fn decode_benchmarks(byte_sizes: &[usize]) -> ParameterizedBenchmark<usize> {
+    ParameterizedBenchmark::new("decode", do_decode_bench, byte_sizes.iter().cloned())
+        .warm_up_time(std::time::Duration::from_millis(500))
+        .measurement_time(std::time::Duration::from_secs(3))
+        .throughput(|s| Throughput::Bytes(*s as u64))
+        .with_function("decode_reuse_buf", do_decode_bench_reuse_buf)
+        .with_function("decode_slice", do_decode_bench_slice)
+        .with_function("decode_stream", do_decode_bench_stream)
+}
+
+fn bench(c: &mut Criterion) {
+    c.bench("bench_small_input", encode_benchmarks(&BYTE_SIZES[..]));
+
+    c.bench(
+        "bench_large_input",
+        encode_benchmarks(&LARGE_BYTE_SIZES[..]).sample_size(10),
+    );
+
+    c.bench("bench_small_input", decode_benchmarks(&BYTE_SIZES[..]));
+
+    c.bench(
+        "bench_large_input",
+        decode_benchmarks(&LARGE_BYTE_SIZES[..]).sample_size(10),
+    );
+}
+
+criterion_group!(benches, bench);
+criterion_main!(benches);
diff --git a/vendor/base64/examples/base64.rs b/vendor/base64/examples/base64.rs
new file mode 100644
index 000000000..cba745b05
--- /dev/null
+++ b/vendor/base64/examples/base64.rs
@@ -0,0 +1,89 @@
+use std::fs::File;
+use std::io::{self, Read};
+use std::path::PathBuf;
+use std::process;
+use std::str::FromStr;
+
+use base64::{read, write};
+use structopt::StructOpt;
+
+#[derive(Debug, StructOpt)]
+enum CharacterSet {
+    Standard,
+    UrlSafe,
+}
+
+impl Default for CharacterSet {
+    fn default() -> Self {
+        CharacterSet::Standard
+    }
+}
+
+impl Into<base64::Config> for CharacterSet {
+    fn into(self) -> base64::Config {
+        match self {
+            CharacterSet::Standard => base64::STANDARD,
+            CharacterSet::UrlSafe => base64::URL_SAFE,
+        }
+    }
+}
+
+impl FromStr for CharacterSet {
+    type Err = String;
+    fn from_str(s: &str) -> Result<CharacterSet, String> {
+        match s {
+            "standard" => Ok(CharacterSet::Standard),
+            "urlsafe" => Ok(CharacterSet::UrlSafe),
+            _ => Err(format!("charset '{}' unrecognized", s)),
+        }
+    }
+}
+
+/// Base64 encode or decode FILE (or standard input), to standard output.
+#[derive(Debug, StructOpt)]
+struct Opt {
+    /// decode data
+    #[structopt(short = "d", long = "decode")]
+    decode: bool,
+    /// The character set to choose. Defaults to the standard base64 character set.
+    /// Supported character sets include "standard" and "urlsafe".
+    #[structopt(long = "charset")]
+    charset: Option<CharacterSet>,
+    /// The file to encode/decode.
+    #[structopt(parse(from_os_str))]
+    file: Option<PathBuf>,
+}
+
+fn main() {
+    let opt = Opt::from_args();
+    let stdin;
+    let mut input: Box<dyn Read> = match opt.file {
+        None => {
+            stdin = io::stdin();
+            Box::new(stdin.lock())
+        }
+        Some(ref f) if f.as_os_str() == "-" => {
+            stdin = io::stdin();
+            Box::new(stdin.lock())
+        }
+        Some(f) => Box::new(File::open(f).unwrap()),
+    };
+    let config = opt.charset.unwrap_or_default().into();
+    let stdout = io::stdout();
+    let mut stdout = stdout.lock();
+    let r = if opt.decode {
+        let mut decoder = read::DecoderReader::new(&mut input, config);
+        io::copy(&mut decoder, &mut stdout)
+    } else {
+        let mut encoder = write::EncoderWriter::new(&mut stdout, config);
+        io::copy(&mut input, &mut encoder)
+    };
+    if let Err(e) = r {
+        eprintln!(
+            "Base64 {} failed with {}",
+            if opt.decode { "decode" } else { "encode" },
+            e
+        );
+        process::exit(1);
+    }
+}
diff --git a/vendor/base64/examples/make_tables.rs b/vendor/base64/examples/make_tables.rs
new file mode 100644
index 000000000..2f27c0eb9
--- /dev/null
+++ b/vendor/base64/examples/make_tables.rs
@@ -0,0 +1,179 @@
+use std::collections::{HashMap, HashSet};
+use std::iter::Iterator;
+
+fn main() {
+    println!("pub const INVALID_VALUE: u8 = 255;");
+
+    // A-Z
+    let standard_alphabet: Vec<u8> = (0x41..0x5B)
+        // a-z
+        .chain(0x61..0x7B)
+        // 0-9
+        .chain(0x30..0x3A)
+        // +
+        .chain(0x2B..0x2C)
+        // /
+        .chain(0x2F..0x30)
+        .collect();
+    print_encode_table(&standard_alphabet, "STANDARD_ENCODE", 0);
+    print_decode_table(&standard_alphabet, "STANDARD_DECODE", 0);
+
+    // A-Z
+    let url_alphabet: Vec<u8> = (0x41..0x5B)
+        // a-z
+        .chain(0x61..0x7B)
+        // 0-9
+        .chain(0x30..0x3A)
+        // -
+        .chain(0x2D..0x2E)
+        // _
+        .chain(0x5F..0x60)
+        .collect();
+    print_encode_table(&url_alphabet, "URL_SAFE_ENCODE", 0);
+    print_decode_table(&url_alphabet, "URL_SAFE_DECODE", 0);
+
+    // ./0123456789
+    let crypt_alphabet: Vec<u8> = (b'.'..(b'9' + 1))
+        // A-Z
+        .chain(b'A'..(b'Z' + 1))
+        // a-z
+        .chain(b'a'..(b'z' + 1))
+        .collect();
+    print_encode_table(&crypt_alphabet, "CRYPT_ENCODE", 0);
+    print_decode_table(&crypt_alphabet, "CRYPT_DECODE", 0);
+
+    // ./
+    let bcrypt_alphabet: Vec<u8> = (b'.'..(b'/' + 1))
+        // A-Z
+        .chain(b'A'..(b'Z' + 1))
+        // a-z
+        .chain(b'a'..(b'z' + 1))
+        // 0-9
+        .chain(b'0'..(b'9' + 1))
+        .collect();
+    print_encode_table(&bcrypt_alphabet, "BCRYPT_ENCODE", 0);
+    print_decode_table(&bcrypt_alphabet, "BCRYPT_DECODE", 0);
+
+    // A-Z
+    let imap_alphabet: Vec<u8> = (0x41..0x5B)
+        // a-z
+        .chain(0x61..0x7B)
+        // 0-9
+        .chain(0x30..0x3A)
+        // +
+        .chain(0x2B..0x2C)
+        // ,
+        .chain(0x2C..0x2D)
+        .collect();
+    print_encode_table(&imap_alphabet, "IMAP_MUTF7_ENCODE", 0);
+    print_decode_table(&imap_alphabet, "IMAP_MUTF7_DECODE", 0);
+
+    // '!' - '-'
+    let binhex_alphabet: Vec<u8> = (0x21..0x2E)
+        // 0-9
+        .chain(0x30..0x3A)
+        // @-N
+        .chain(0x40..0x4F)
+        // P-V
+        .chain(0x50..0x57)
+        // X-[
+        .chain(0x58..0x5C)
+        // `-f
+        .chain(0x60..0x66)
+        // h-m
+        .chain(0x68..0x6E)
+        // p-r
+        .chain(0x70..0x73)
+        .collect();
+    print_encode_table(&binhex_alphabet, "BINHEX_ENCODE", 0);
+    print_decode_table(&binhex_alphabet, "BINHEX_DECODE", 0);
+}
+
+fn print_encode_table(alphabet: &[u8], const_name: &str, indent_depth: usize) {
+    check_alphabet(alphabet);
+    println!("#[rustfmt::skip]");
+    println!(
+        "{:width$}pub const {}: &[u8; 64] = &[",
+        "",
+        const_name,
+        width = indent_depth
+    );
+
+    for (i, b) in alphabet.iter().enumerate() {
+        println!(
+            "{:width$}{}, // input {} (0x{:X}) => '{}' (0x{:X})",
+            "",
+            b,
+            i,
+            i,
+            String::from_utf8(vec![*b as u8]).unwrap(),
+            b,
+            width = indent_depth + 4
+        );
+    }
+
+    println!("{:width$}];", "", width = indent_depth);
+}
+
+fn print_decode_table(alphabet: &[u8], const_name: &str, indent_depth: usize) {
+    check_alphabet(alphabet);
+    // map of alphabet bytes to 6-bit morsels
+    let mut input_to_morsel = HashMap::<u8, u8>::new();
+
+    // standard base64 alphabet bytes, in order
+    for (morsel, ascii_byte) in alphabet.iter().enumerate() {
+        // truncation cast is fine here
+        let _ = input_to_morsel.insert(*ascii_byte, morsel as u8);
+    }
+
+    println!("#[rustfmt::skip]");
+    println!(
+        "{:width$}pub const {}: &[u8; 256] = &[",
+        "",
+        const_name,
+        width = indent_depth
+    );
+    for ascii_byte in 0..256 {
+        let (value, comment) = match input_to_morsel.get(&(ascii_byte as u8)) {
+            None => (
+                "INVALID_VALUE".to_string(),
+                format!("input {} (0x{:X})", ascii_byte, ascii_byte),
+            ),
+            Some(v) => (
+                format!("{}", *v),
+                format!(
+                    "input {} (0x{:X} char '{}') => {} (0x{:X})",
+                    ascii_byte,
+                    ascii_byte,
+                    String::from_utf8(vec![ascii_byte as u8]).unwrap(),
+                    *v,
+                    *v
+                ),
+            ),
+        };
+
+        println!(
+            "{:width$}{}, // {}",
+            "",
+            value,
+            comment,
+            width = indent_depth + 4
+        );
+    }
+    println!("{:width$}];", "", width = indent_depth);
+}
+
+fn check_alphabet(alphabet: &[u8]) {
+    // ensure all characters are distinct
+    assert_eq!(64, alphabet.len());
+    let mut set: HashSet<u8> = HashSet::new();
+    set.extend(alphabet);
+    assert_eq!(64, set.len());
+
+    // must be ASCII to be valid as single UTF-8 bytes
+    for &b in alphabet {
+        assert!(b <= 0x7F_u8);
+        // = is assumed to be padding, so cannot be used as a symbol
+        assert_ne!(b'=', b);
+    }
+}
diff --git a/vendor/base64/icon_CLion.svg b/vendor/base64/icon_CLion.svg
new file mode 100644
index 000000000..e9edb0445
--- /dev/null
+++ b/vendor/base64/icon_CLion.svg
@@ -0,0 +1,34 @@
+<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 128 128">
+  <defs>
+    <linearGradient id="linear-gradient" x1="40.69" y1="-676.56" x2="83.48" y2="-676.56" gradientTransform="matrix(1, 0, 0, -1, 0, -648.86)" gradientUnits="userSpaceOnUse">
+      <stop offset="0" stop-color="#ed358c"/>
+      <stop offset="0.16" stop-color="#e9388c"/>
+      <stop offset="0.3" stop-color="#de418c"/>
+      <stop offset="0.43" stop-color="#cc508c"/>
+      <stop offset="0.57" stop-color="#b2658d"/>
+      <stop offset="0.7" stop-color="#90808d"/>
+      <stop offset="0.83" stop-color="#67a18e"/>
+      <stop offset="0.95" stop-color="#37c78f"/>
+      <stop offset="1" stop-color="#22d88f"/>
+    </linearGradient>
+    <linearGradient id="linear-gradient-2" x1="32.58" y1="-665.27" x2="13.76" y2="-791.59" gradientTransform="matrix(1, 0, 0, -1, 0, -648.86)" gradientUnits="userSpaceOnUse">
+      <stop offset="0.09" stop-color="#22d88f"/>
+      <stop offset="0.9" stop-color="#029de0"/>
+    </linearGradient>
+    <linearGradient id="linear-gradient-3" x1="116.68" y1="-660.66" x2="-12.09" y2="-796.66" xlink:href="#linear-gradient-2"/>
+    <linearGradient id="linear-gradient-4" x1="73.35" y1="-739.1" x2="122.29" y2="-746.06" xlink:href="#linear-gradient-2"/>
+  </defs>
+  <title>icon_CLion</title>
+  <g>
+    <polygon points="49.2 51.8 40.6 55.4 48.4 0 77.8 16.2 49.2 51.8" fill="url(#linear-gradient)"/>
+    <polygon points="44.6 76.8 48.8 0 11.8 23.2 0 94 44.6 76.8" fill="url(#linear-gradient-2)"/>
+    <polygon points="125.4 38.4 109 4.8 77.8 16.2 55 41.4 0 94 41.6 124.4 93.6 77.2 125.4 38.4" fill="url(#linear-gradient-3)"/>
+    <polygon points="53.8 54.6 46.6 98.4 75.8 121 107.8 128 128 82.4 53.8 54.6" fill="url(#linear-gradient-4)"/>
+  </g>
+  <g>
+    <rect x="24" y="24" width="80" height="80"/>
+    <rect x="31.6" y="89" width="30" height="5" fill="#fff"/>
+    <path d="M31,51.2h0A16.83,16.83,0,0,1,48.2,34c6.2,0,10,2,13,5.2l-4.6,5.4c-2.6-2.4-5.2-3.8-8.4-3.8-5.6,0-9.6,4.6-9.6,10.4h0c0,5.6,4,10.4,9.6,10.4,3.8,0,6.2-1.6,8.8-3.8l4.6,4.6c-3.4,3.6-7.2,6-13.6,6A17,17,0,0,1,31,51.2" fill="#fff"/>
+    <path d="M66.6,34.4H74v27H88.4v6.2H66.6V34.4Z" fill="#fff"/>
+  </g>
+</svg>
diff --git a/vendor/base64/src/chunked_encoder.rs b/vendor/base64/src/chunked_encoder.rs
new file mode 100644
index 000000000..bd45ec9e2
--- /dev/null
+++ b/vendor/base64/src/chunked_encoder.rs
@@ -0,0 +1,247 @@
+use crate::{
+    encode::{add_padding, encode_to_slice},
+    Config,
+};
+#[cfg(any(feature = "alloc", feature = "std", test))]
+use alloc::string::String;
+use core::cmp;
+#[cfg(any(feature = "alloc", feature = "std", test))]
+use core::str;
+
+/// The output mechanism for ChunkedEncoder's encoded bytes.
+pub trait Sink {
+    type Error;
+
+    /// Handle a chunk of encoded base64 data (as UTF-8 bytes)
+    fn write_encoded_bytes(&mut self, encoded: &[u8]) -> Result<(), Self::Error>;
+}
+
+const BUF_SIZE: usize = 1024;
+
+/// A base64 encoder that emits encoded bytes in chunks without heap allocation.
+pub struct ChunkedEncoder {
+    config: Config,
+    max_input_chunk_len: usize,
+}
+
+impl ChunkedEncoder {
+    pub fn new(config: Config) -> ChunkedEncoder {
+        ChunkedEncoder {
+            config,
+            max_input_chunk_len: max_input_length(BUF_SIZE, config),
+        }
+    }
+
+    pub fn encode<S: Sink>(&self, bytes: &[u8], sink: &mut S) -> Result<(), S::Error> {
+        let mut encode_buf: [u8; BUF_SIZE] = [0; BUF_SIZE];
+        let encode_table = self.config.char_set.encode_table();
+
+        let mut input_index = 0;
+
+        while input_index < bytes.len() {
+            // either the full input chunk size, or it's the last iteration
+            let input_chunk_len = cmp::min(self.max_input_chunk_len, bytes.len() - input_index);
+
+            let chunk = &bytes[input_index..(input_index + input_chunk_len)];
+
+            let mut b64_bytes_written = encode_to_slice(chunk, &mut encode_buf, encode_table);
+
+            input_index += input_chunk_len;
+            let more_input_left = input_index < bytes.len();
+
+            if self.config.pad && !more_input_left {
+                // no more input, add padding if needed. Buffer will have room because
+                // max_input_length leaves room for it.
+                b64_bytes_written += add_padding(bytes.len(), &mut encode_buf[b64_bytes_written..]);
+            }
+
+            sink.write_encoded_bytes(&encode_buf[0..b64_bytes_written])?;
+        }
+
+        Ok(())
+    }
+}
+
+/// Calculate the longest input that can be encoded for the given output buffer size.
+///
+/// If the config requires padding, two bytes of buffer space will be set aside so that the last
+/// chunk of input can be encoded safely.
+///
+/// The input length will always be a multiple of 3 so that no encoding state has to be carried over
+/// between chunks.
+fn max_input_length(encoded_buf_len: usize, config: Config) -> usize {
+    let effective_buf_len = if config.pad {
+        // make room for padding
+        encoded_buf_len
+            .checked_sub(2)
+            .expect("Don't use a tiny buffer")
+    } else {
+        encoded_buf_len
+    };
+
+    // No padding, so just normal base64 expansion.
+    (effective_buf_len / 4) * 3
+}
+
+// A really simple sink that just appends to a string
+#[cfg(any(feature = "alloc", feature = "std", test))]
+pub(crate) struct StringSink<'a> {
+    string: &'a mut String,
+}
+
+#[cfg(any(feature = "alloc", feature = "std", test))]
+impl<'a> StringSink<'a> {
+    pub(crate) fn new(s: &mut String) -> StringSink {
+        StringSink { string: s }
+    }
+}
+
+#[cfg(any(feature = "alloc", feature = "std", test))]
+impl<'a> Sink for StringSink<'a> {
+    type Error = ();
+
+    fn write_encoded_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error> {
+        self.string.push_str(str::from_utf8(s).unwrap());
+
+        Ok(())
+    }
+}
+
+#[cfg(test)]
+pub mod tests {
+    use super::*;
+    use crate::{encode_config_buf, tests::random_config, CharacterSet, STANDARD};
+
+    use rand::{
+        distributions::{Distribution, Uniform},
+        FromEntropy, Rng,
+    };
+
+    #[test]
+    fn chunked_encode_empty() {
+        assert_eq!("", chunked_encode_str(&[], STANDARD));
+    }
+
+    #[test]
+    fn chunked_encode_intermediate_fast_loop() {
+        // > 8 bytes input, will enter the pretty fast loop
+        assert_eq!(
+            "Zm9vYmFyYmF6cXV4",
+            chunked_encode_str(b"foobarbazqux", STANDARD)
+        );
+    }
+
+    #[test]
+    fn chunked_encode_fast_loop() {
+        // > 32 bytes input, will enter the uber fast loop
+        assert_eq!(
+            "Zm9vYmFyYmF6cXV4cXV1eGNvcmdlZ3JhdWx0Z2FycGx5eg==",
+            chunked_encode_str(b"foobarbazquxquuxcorgegraultgarplyz", STANDARD)
+        );
+    }
+
+    #[test]
+    fn chunked_encode_slow_loop_only() {
+        // < 8 bytes input, slow loop only
+        assert_eq!("Zm9vYmFy", chunked_encode_str(b"foobar", STANDARD));
+    }
+
+    #[test]
+    fn chunked_encode_matches_normal_encode_random_string_sink() {
+        let helper = StringSinkTestHelper;
+        chunked_encode_matches_normal_encode_random(&helper);
+    }
+
+    #[test]
+    fn max_input_length_no_pad() {
+        let config = config_with_pad(false);
+        assert_eq!(768, max_input_length(1024, config));
+    }
+
+    #[test]
+    fn max_input_length_with_pad_decrements_one_triple() {
+        let config = config_with_pad(true);
+        assert_eq!(765, max_input_length(1024, config));
+    }
+
+    #[test]
+    fn max_input_length_with_pad_one_byte_short() {
+        let config = config_with_pad(true);
+        assert_eq!(765, max_input_length(1025, config));
+    }
+
+    #[test]
+    fn max_input_length_with_pad_fits_exactly() {
+        let config = config_with_pad(true);
+        assert_eq!(768, max_input_length(1026, config));
+    }
+
+    #[test]
+    fn max_input_length_cant_use_extra_single_encoded_byte() {
+        let config = Config::new(crate::CharacterSet::Standard, false);
+        assert_eq!(300, max_input_length(401, config));
+    }
+
+    pub fn chunked_encode_matches_normal_encode_random<S: SinkTestHelper>(sink_test_helper: &S) {
+        let mut input_buf: Vec<u8> = Vec::new();
+        let mut output_buf = String::new();
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+        let input_len_range = Uniform::new(1, 10_000);
+
+        for _ in 0..5_000 {
+            input_buf.clear();
+            output_buf.clear();
+
+            let buf_len = input_len_range.sample(&mut rng);
+            for _ in 0..buf_len {
+                input_buf.push(rng.gen());
+            }
+
+            let config = random_config(&mut rng);
+
+            let chunk_encoded_string = sink_test_helper.encode_to_string(config, &input_buf);
+            encode_config_buf(&input_buf, config, &mut output_buf);
+
+            assert_eq!(
+                output_buf, chunk_encoded_string,
+                "input len={}, config: pad={}",
+                buf_len, config.pad
+            );
+        }
+    }
+
+    fn chunked_encode_str(bytes: &[u8], config: Config) -> String {
+        let mut s = String::new();
+        {
+            let mut sink = StringSink::new(&mut s);
+            let encoder = ChunkedEncoder::new(config);
+            encoder.encode(bytes, &mut sink).unwrap();
+        }
+
+        return s;
+    }
+
+    fn config_with_pad(pad: bool) -> Config {
+        Config::new(CharacterSet::Standard, pad)
+    }
+
+    // An abstraction around sinks so that we can have tests that easily to any sink implementation
+    pub trait SinkTestHelper {
+        fn encode_to_string(&self, config: Config, bytes: &[u8]) -> String;
+    }
+
+    struct StringSinkTestHelper;
+
+    impl SinkTestHelper for StringSinkTestHelper {
+        fn encode_to_string(&self, config: Config, bytes: &[u8]) -> String {
+            let encoder = ChunkedEncoder::new(config);
+            let mut s = String::new();
+            {
+                let mut sink = StringSink::new(&mut s);
+                encoder.encode(bytes, &mut sink).unwrap();
+            }
+
+            s
+        }
+    }
+}
diff --git a/vendor/base64/src/decode.rs b/vendor/base64/src/decode.rs
new file mode 100644
index 000000000..e349240ac
--- /dev/null
+++ b/vendor/base64/src/decode.rs
@@ -0,0 +1,893 @@
+use crate::{tables, Config, PAD_BYTE};
+
+#[cfg(any(feature = "alloc", feature = "std", test))]
+use crate::STANDARD;
+#[cfg(any(feature = "alloc", feature = "std", test))]
+use alloc::vec::Vec;
+use core::fmt;
+#[cfg(any(feature = "std", test))]
+use std::error;
+
+// decode logic operates on chunks of 8 input bytes without padding
+const INPUT_CHUNK_LEN: usize = 8;
+const DECODED_CHUNK_LEN: usize = 6;
+// we read a u64 and write a u64, but a u64 of input only yields 6 bytes of output, so the last
+// 2 bytes of any output u64 should not be counted as written to (but must be available in a
+// slice).
+const DECODED_CHUNK_SUFFIX: usize = 2;
+
+// how many u64's of input to handle at a time
+const CHUNKS_PER_FAST_LOOP_BLOCK: usize = 4;
+const INPUT_BLOCK_LEN: usize = CHUNKS_PER_FAST_LOOP_BLOCK * INPUT_CHUNK_LEN;
+// includes the trailing 2 bytes for the final u64 write
+const DECODED_BLOCK_LEN: usize =
+    CHUNKS_PER_FAST_LOOP_BLOCK * DECODED_CHUNK_LEN + DECODED_CHUNK_SUFFIX;
+
+/// Errors that can occur while decoding.
+#[derive(Clone, Debug, PartialEq, Eq)]
+pub enum DecodeError {
+    /// An invalid byte was found in the input. The offset and offending byte are provided.
+    InvalidByte(usize, u8),
+    /// The length of the input is invalid.
+    /// A typical cause of this is stray trailing whitespace or other separator bytes.
+    /// In the case where excess trailing bytes have produced an invalid length *and* the last byte
+    /// is also an invalid base64 symbol (as would be the case for whitespace, etc), `InvalidByte`
+    /// will be emitted instead of `InvalidLength` to make the issue easier to debug.
+    InvalidLength,
+    /// The last non-padding input symbol's encoded 6 bits have nonzero bits that will be discarded.
+    /// This is indicative of corrupted or truncated Base64.
+    /// Unlike InvalidByte, which reports symbols that aren't in the alphabet, this error is for
+    /// symbols that are in the alphabet but represent nonsensical encodings.
+    InvalidLastSymbol(usize, u8),
+}
+
+impl fmt::Display for DecodeError {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        match *self {
+            DecodeError::InvalidByte(index, byte) => {
+                write!(f, "Invalid byte {}, offset {}.", byte, index)
+            }
+            DecodeError::InvalidLength => write!(f, "Encoded text cannot have a 6-bit remainder."),
+            DecodeError::InvalidLastSymbol(index, byte) => {
+                write!(f, "Invalid last symbol {}, offset {}.", byte, index)
+            }
+        }
+    }
+}
+
+#[cfg(any(feature = "std", test))]
+impl error::Error for DecodeError {
+    fn description(&self) -> &str {
+        match *self {
+            DecodeError::InvalidByte(_, _) => "invalid byte",
+            DecodeError::InvalidLength => "invalid length",
+            DecodeError::InvalidLastSymbol(_, _) => "invalid last symbol",
+        }
+    }
+
+    fn cause(&self) -> Option<&dyn error::Error> {
+        None
+    }
+}
+
+///Decode from string reference as octets.
+///Returns a Result containing a Vec<u8>.
+///Convenience `decode_config(input, base64::STANDARD);`.
+///
+///# Example
+///
+///```rust
+///extern crate base64;
+///
+///fn main() {
+///    let bytes = base64::decode("aGVsbG8gd29ybGQ=").unwrap();
+///    println!("{:?}", bytes);
+///}
+///```
+#[cfg(any(feature = "alloc", feature = "std", test))]
+pub fn decode<T: AsRef<[u8]>>(input: T) -> Result<Vec<u8>, DecodeError> {
+    decode_config(input, STANDARD)
+}
+
+///Decode from string reference as octets.
+///Returns a Result containing a Vec<u8>.
+///
+///# Example
+///
+///```rust
+///extern crate base64;
+///
+///fn main() {
+///    let bytes = base64::decode_config("aGVsbG8gd29ybGR+Cg==", base64::STANDARD).unwrap();
+///    println!("{:?}", bytes);
+///
+///    let bytes_url = base64::decode_config("aGVsbG8gaW50ZXJuZXR-Cg==", base64::URL_SAFE).unwrap();
+///    println!("{:?}", bytes_url);
+///}
+///```
+#[cfg(any(feature = "alloc", feature = "std", test))]
+pub fn decode_config<T: AsRef<[u8]>>(input: T, config: Config) -> Result<Vec<u8>, DecodeError> {
+    let decoded_length_estimate = (input
+        .as_ref()
+        .len()
+        .checked_add(3)
+        .expect("decoded length calculation overflow"))
+        / 4
+        * 3;
+    let mut buffer = Vec::<u8>::with_capacity(decoded_length_estimate);
+
+    decode_config_buf(input, config, &mut buffer).map(|_| buffer)
+}
+
+///Decode from string reference as octets.
+///Writes into the supplied buffer to avoid allocation.
+///Returns a Result containing an empty tuple, aka ().
+///
+///# Example
+///
+///```rust
+///extern crate base64;
+///
+///fn main() {
+///    let mut buffer = Vec::<u8>::new();
+///    base64::decode_config_buf("aGVsbG8gd29ybGR+Cg==", base64::STANDARD, &mut buffer).unwrap();
+///    println!("{:?}", buffer);
+///
+///    buffer.clear();
+///
+///    base64::decode_config_buf("aGVsbG8gaW50ZXJuZXR-Cg==", base64::URL_SAFE, &mut buffer)
+///        .unwrap();
+///    println!("{:?}", buffer);
+///}
+///```
+#[cfg(any(feature = "alloc", feature = "std", test))]
+pub fn decode_config_buf<T: AsRef<[u8]>>(
+    input: T,
+    config: Config,
+    buffer: &mut Vec<u8>,
+) -> Result<(), DecodeError> {
+    let input_bytes = input.as_ref();
+
+    let starting_output_len = buffer.len();
+
+    let num_chunks = num_chunks(input_bytes);
+    let decoded_len_estimate = num_chunks
+        .checked_mul(DECODED_CHUNK_LEN)
+        .and_then(|p| p.checked_add(starting_output_len))
+        .expect("Overflow when calculating output buffer length");
+    buffer.resize(decoded_len_estimate, 0);
+
+    let bytes_written;
+    {
+        let buffer_slice = &mut buffer.as_mut_slice()[starting_output_len..];
+        bytes_written = decode_helper(input_bytes, num_chunks, config, buffer_slice)?;
+    }
+
+    buffer.truncate(starting_output_len + bytes_written);
+
+    Ok(())
+}
+
+/// Decode the input into the provided output slice.
+///
+/// This will not write any bytes past exactly what is decoded (no stray garbage bytes at the end).
+///
+/// If you don't know ahead of time what the decoded length should be, size your buffer with a
+/// conservative estimate for the decoded length of an input: 3 bytes of output for every 4 bytes of
+/// input, rounded up, or in other words `(input_len + 3) / 4 * 3`.
+///
+/// If the slice is not large enough, this will panic.
+pub fn decode_config_slice<T: AsRef<[u8]>>(
+    input: T,
+    config: Config,
+    output: &mut [u8],
+) -> Result<usize, DecodeError> {
+    let input_bytes = input.as_ref();
+
+    decode_helper(input_bytes, num_chunks(input_bytes), config, output)
+}
+
+/// Return the number of input chunks (including a possibly partial final chunk) in the input
+fn num_chunks(input: &[u8]) -> usize {
+    input
+        .len()
+        .checked_add(INPUT_CHUNK_LEN - 1)
+        .expect("Overflow when calculating number of chunks in input")
+        / INPUT_CHUNK_LEN
+}
+
+/// Helper to avoid duplicating num_chunks calculation, which is costly on short inputs.
+/// Returns the number of bytes written, or an error.
+// We're on the fragile edge of compiler heuristics here. If this is not inlined, slow. If this is
+// inlined(always), a different slow. plain ol' inline makes the benchmarks happiest at the moment,
+// but this is fragile and the best setting changes with only minor code modifications.
+#[inline]
+fn decode_helper(
+    input: &[u8],
+    num_chunks: usize,
+    config: Config,
+    output: &mut [u8],
+) -> Result<usize, DecodeError> {
+    let char_set = config.char_set;
+    let decode_table = char_set.decode_table();
+
+    let remainder_len = input.len() % INPUT_CHUNK_LEN;
+
+    // Because the fast decode loop writes in groups of 8 bytes (unrolled to
+    // CHUNKS_PER_FAST_LOOP_BLOCK times 8 bytes, where possible) and outputs 8 bytes at a time (of
+    // which only 6 are valid data), we need to be sure that we stop using the fast decode loop
+    // soon enough that there will always be 2 more bytes of valid data written after that loop.
+    let trailing_bytes_to_skip = match remainder_len {
+        // if input is a multiple of the chunk size, ignore the last chunk as it may have padding,
+        // and the fast decode logic cannot handle padding
+        0 => INPUT_CHUNK_LEN,
+        // 1 and 5 trailing bytes are illegal: can't decode 6 bits of input into a byte
+        1 | 5 => {
+            // trailing whitespace is so common that it's worth it to check the last byte to
+            // possibly return a better error message
+            if let Some(b) = input.last() {
+                if *b != PAD_BYTE && decode_table[*b as usize] == tables::INVALID_VALUE {
+                    return Err(DecodeError::InvalidByte(input.len() - 1, *b));
+                }
+            }
+
+            return Err(DecodeError::InvalidLength);
+        }
+        // This will decode to one output byte, which isn't enough to overwrite the 2 extra bytes
+        // written by the fast decode loop. So, we have to ignore both these 2 bytes and the
+        // previous chunk.
+        2 => INPUT_CHUNK_LEN + 2,
+        // If this is 3 unpadded chars, then it would actually decode to 2 bytes. However, if this
+        // is an erroneous 2 chars + 1 pad char that would decode to 1 byte, then it should fail
+        // with an error, not panic from going past the bounds of the output slice, so we let it
+        // use stage 3 + 4.
+        3 => INPUT_CHUNK_LEN + 3,
+        // This can also decode to one output byte because it may be 2 input chars + 2 padding
+        // chars, which would decode to 1 byte.
+        4 => INPUT_CHUNK_LEN + 4,
+        // Everything else is a legal decode len (given that we don't require padding), and will
+        // decode to at least 2 bytes of output.
+        _ => remainder_len,
+    };
+
+    // rounded up to include partial chunks
+    let mut remaining_chunks = num_chunks;
+
+    let mut input_index = 0;
+    let mut output_index = 0;
+
+    {
+        let length_of_fast_decode_chunks = input.len().saturating_sub(trailing_bytes_to_skip);
+
+        // Fast loop, stage 1
+        // manual unroll to CHUNKS_PER_FAST_LOOP_BLOCK of u64s to amortize slice bounds checks
+        if let Some(max_start_index) = length_of_fast_decode_chunks.checked_sub(INPUT_BLOCK_LEN) {
+            while input_index <= max_start_index {
+                let input_slice = &input[input_index..(input_index + INPUT_BLOCK_LEN)];
+                let output_slice = &mut output[output_index..(output_index + DECODED_BLOCK_LEN)];
+
+                decode_chunk(
+                    &input_slice[0..],
+                    input_index,
+                    decode_table,
+                    &mut output_slice[0..],
+                )?;
+                decode_chunk(
+                    &input_slice[8..],
+                    input_index + 8,
+                    decode_table,
+                    &mut output_slice[6..],
+                )?;
+                decode_chunk(
+                    &input_slice[16..],
+                    input_index + 16,
+                    decode_table,
+                    &mut output_slice[12..],
+                )?;
+                decode_chunk(
+                    &input_slice[24..],
+                    input_index + 24,
+                    decode_table,
+                    &mut output_slice[18..],
+                )?;
+
+                input_index += INPUT_BLOCK_LEN;
+                output_index += DECODED_BLOCK_LEN - DECODED_CHUNK_SUFFIX;
+                remaining_chunks -= CHUNKS_PER_FAST_LOOP_BLOCK;
+            }
+        }
+
+        // Fast loop, stage 2 (aka still pretty fast loop)
+        // 8 bytes at a time for whatever we didn't do in stage 1.
+        if let Some(max_start_index) = length_of_fast_decode_chunks.checked_sub(INPUT_CHUNK_LEN) {
+            while input_index < max_start_index {
+                decode_chunk(
+                    &input[input_index..(input_index + INPUT_CHUNK_LEN)],
+                    input_index,
+                    decode_table,
+                    &mut output
+                        [output_index..(output_index + DECODED_CHUNK_LEN + DECODED_CHUNK_SUFFIX)],
+                )?;
+
+                output_index += DECODED_CHUNK_LEN;
+                input_index += INPUT_CHUNK_LEN;
+                remaining_chunks -= 1;
+            }
+        }
+    }
+
+    // Stage 3
+    // If input length was such that a chunk had to be deferred until after the fast loop
+    // because decoding it would have produced 2 trailing bytes that wouldn't then be
+    // overwritten, we decode that chunk here. This way is slower but doesn't write the 2
+    // trailing bytes.
+    // However, we still need to avoid the last chunk (partial or complete) because it could
+    // have padding, so we always do 1 fewer to avoid the last chunk.
+    for _ in 1..remaining_chunks {
+        decode_chunk_precise(
+            &input[input_index..],
+            input_index,
+            decode_table,
+            &mut output[output_index..(output_index + DECODED_CHUNK_LEN)],
+        )?;
+
+        input_index += INPUT_CHUNK_LEN;
+        output_index += DECODED_CHUNK_LEN;
+    }
+
+    // always have one more (possibly partial) block of 8 input
+    debug_assert!(input.len() - input_index > 1 || input.is_empty());
+    debug_assert!(input.len() - input_index <= 8);
+
+    // Stage 4
+    // Finally, decode any leftovers that aren't a complete input block of 8 bytes.
+    // Use a u64 as a stack-resident 8 byte buffer.
+    let mut leftover_bits: u64 = 0;
+    let mut morsels_in_leftover = 0;
+    let mut padding_bytes = 0;
+    let mut first_padding_index: usize = 0;
+    let mut last_symbol = 0_u8;
+    let start_of_leftovers = input_index;
+    for (i, b) in input[start_of_leftovers..].iter().enumerate() {
+        // '=' padding
+        if *b == PAD_BYTE {
+            // There can be bad padding in a few ways:
+            // 1 - Padding with non-padding characters after it
+            // 2 - Padding after zero or one non-padding characters before it
+            //     in the current quad.
+            // 3 - More than two characters of padding. If 3 or 4 padding chars
+            //     are in the same quad, that implies it will be caught by #2.
+            //     If it spreads from one quad to another, it will be caught by
+            //     #2 in the second quad.
+
+            if i % 4 < 2 {
+                // Check for case #2.
+                let bad_padding_index = start_of_leftovers
+                    + if padding_bytes > 0 {
+                        // If we've already seen padding, report the first padding index.
+                        // This is to be consistent with the faster logic above: it will report an
+                        // error on the first padding character (since it doesn't expect to see
+                        // anything but actual encoded data).
+                        first_padding_index
+                    } else {
+                        // haven't seen padding before, just use where we are now
+                        i
+                    };
+                return Err(DecodeError::InvalidByte(bad_padding_index, *b));
+            }
+
+            if padding_bytes == 0 {
+                first_padding_index = i;
+            }
+
+            padding_bytes += 1;
+            continue;
+        }
+
+        // Check for case #1.
+        // To make '=' handling consistent with the main loop, don't allow
+        // non-suffix '=' in trailing chunk either. Report error as first
+        // erroneous padding.
+        if padding_bytes > 0 {
+            return Err(DecodeError::InvalidByte(
+                start_of_leftovers + first_padding_index,
+                PAD_BYTE,
+            ));
+        }
+        last_symbol = *b;
+
+        // can use up to 8 * 6 = 48 bits of the u64, if last chunk has no padding.
+        // To minimize shifts, pack the leftovers from left to right.
+        let shift = 64 - (morsels_in_leftover + 1) * 6;
+        // tables are all 256 elements, lookup with a u8 index always succeeds
+        let morsel = decode_table[*b as usize];
+        if morsel == tables::INVALID_VALUE {
+            return Err(DecodeError::InvalidByte(start_of_leftovers + i, *b));
+        }
+
+        leftover_bits |= (morsel as u64) << shift;
+        morsels_in_leftover += 1;
+    }
+
+    let leftover_bits_ready_to_append = match morsels_in_leftover {
+        0 => 0,
+        2 => 8,
+        3 => 16,
+        4 => 24,
+        6 => 32,
+        7 => 40,
+        8 => 48,
+        _ => unreachable!(
+            "Impossible: must only have 0 to 8 input bytes in last chunk, with no invalid lengths"
+        ),
+    };
+
+    // if there are bits set outside the bits we care about, last symbol encodes trailing bits that
+    // will not be included in the output
+    let mask = !0 >> leftover_bits_ready_to_append;
+    if !config.decode_allow_trailing_bits && (leftover_bits & mask) != 0 {
+        // last morsel is at `morsels_in_leftover` - 1
+        return Err(DecodeError::InvalidLastSymbol(
+            start_of_leftovers + morsels_in_leftover - 1,
+            last_symbol,
+        ));
+    }
+
+    let mut leftover_bits_appended_to_buf = 0;
+    while leftover_bits_appended_to_buf < leftover_bits_ready_to_append {
+        // `as` simply truncates the higher bits, which is what we want here
+        let selected_bits = (leftover_bits >> (56 - leftover_bits_appended_to_buf)) as u8;
+        output[output_index] = selected_bits;
+        output_index += 1;
+
+        leftover_bits_appended_to_buf += 8;
+    }
+
+    Ok(output_index)
+}
+
+#[inline]
+fn write_u64(output: &mut [u8], value: u64) {
+    output[..8].copy_from_slice(&value.to_be_bytes());
+}
+
+/// Decode 8 bytes of input into 6 bytes of output. 8 bytes of output will be written, but only the
+/// first 6 of those contain meaningful data.
+///
+/// `input` is the bytes to decode, of which the first 8 bytes will be processed.
+/// `index_at_start_of_input` is the offset in the overall input (used for reporting errors
+/// accurately)
+/// `decode_table` is the lookup table for the particular base64 alphabet.
+/// `output` will have its first 8 bytes overwritten, of which only the first 6 are valid decoded
+/// data.
+// yes, really inline (worth 30-50% speedup)
+#[inline(always)]
+fn decode_chunk(
+    input: &[u8],
+    index_at_start_of_input: usize,
+    decode_table: &[u8; 256],
+    output: &mut [u8],
+) -> Result<(), DecodeError> {
+    let mut accum: u64;
+
+    let morsel = decode_table[input[0] as usize];
+    if morsel == tables::INVALID_VALUE {
+        return Err(DecodeError::InvalidByte(index_at_start_of_input, input[0]));
+    }
+    accum = (morsel as u64) << 58;
+
+    let morsel = decode_table[input[1] as usize];
+    if morsel == tables::INVALID_VALUE {
+        return Err(DecodeError::InvalidByte(
+            index_at_start_of_input + 1,
+            input[1],
+        ));
+    }
+    accum |= (morsel as u64) << 52;
+
+    let morsel = decode_table[input[2] as usize];
+    if morsel == tables::INVALID_VALUE {
+        return Err(DecodeError::InvalidByte(
+            index_at_start_of_input + 2,
+            input[2],
+        ));
+    }
+    accum |= (morsel as u64) << 46;
+
+    let morsel = decode_table[input[3] as usize];
+    if morsel == tables::INVALID_VALUE {
+        return Err(DecodeError::InvalidByte(
+            index_at_start_of_input + 3,
+            input[3],
+        ));
+    }
+    accum |= (morsel as u64) << 40;
+
+    let morsel = decode_table[input[4] as usize];
+    if morsel == tables::INVALID_VALUE {
+        return Err(DecodeError::InvalidByte(
+            index_at_start_of_input + 4,
+            input[4],
+        ));
+    }
+    accum |= (morsel as u64) << 34;
+
+    let morsel = decode_table[input[5] as usize];
+    if morsel == tables::INVALID_VALUE {
+        return Err(DecodeError::InvalidByte(
+            index_at_start_of_input + 5,
+            input[5],
+        ));
+    }
+    accum |= (morsel as u64) << 28;
+
+    let morsel = decode_table[input[6] as usize];
+    if morsel == tables::INVALID_VALUE {
+        return Err(DecodeError::InvalidByte(
+            index_at_start_of_input + 6,
+            input[6],
+        ));
+    }
+    accum |= (morsel as u64) << 22;
+
+    let morsel = decode_table[input[7] as usize];
+    if morsel == tables::INVALID_VALUE {
+        return Err(DecodeError::InvalidByte(
+            index_at_start_of_input + 7,
+            input[7],
+        ));
+    }
+    accum |= (morsel as u64) << 16;
+
+    write_u64(output, accum);
+
+    Ok(())
+}
+
+/// Decode an 8-byte chunk, but only write the 6 bytes actually decoded instead of including 2
+/// trailing garbage bytes.
+#[inline]
+fn decode_chunk_precise(
+    input: &[u8],
+    index_at_start_of_input: usize,
+    decode_table: &[u8; 256],
+    output: &mut [u8],
+) -> Result<(), DecodeError> {
+    let mut tmp_buf = [0_u8; 8];
+
+    decode_chunk(
+        input,
+        index_at_start_of_input,
+        decode_table,
+        &mut tmp_buf[..],
+    )?;
+
+    output[0..6].copy_from_slice(&tmp_buf[0..6]);
+
+    Ok(())
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::{
+        encode::encode_config_buf,
+        encode::encode_config_slice,
+        tests::{assert_encode_sanity, random_config},
+    };
+
+    use rand::{
+        distributions::{Distribution, Uniform},
+        FromEntropy, Rng,
+    };
+
+    #[test]
+    fn decode_chunk_precise_writes_only_6_bytes() {
+        let input = b"Zm9vYmFy"; // "foobar"
+        let mut output = [0_u8, 1, 2, 3, 4, 5, 6, 7];
+        decode_chunk_precise(&input[..], 0, tables::STANDARD_DECODE, &mut output).unwrap();
+        assert_eq!(&vec![b'f', b'o', b'o', b'b', b'a', b'r', 6, 7], &output);
+    }
+
+    #[test]
+    fn decode_chunk_writes_8_bytes() {
+        let input = b"Zm9vYmFy"; // "foobar"
+        let mut output = [0_u8, 1, 2, 3, 4, 5, 6, 7];
+        decode_chunk(&input[..], 0, tables::STANDARD_DECODE, &mut output).unwrap();
+        assert_eq!(&vec![b'f', b'o', b'o', b'b', b'a', b'r', 0, 0], &output);
+    }
+
+    #[test]
+    fn decode_into_nonempty_vec_doesnt_clobber_existing_prefix() {
+        let mut orig_data = Vec::new();
+        let mut encoded_data = String::new();
+        let mut decoded_with_prefix = Vec::new();
+        let mut decoded_without_prefix = Vec::new();
+        let mut prefix = Vec::new();
+
+        let prefix_len_range = Uniform::new(0, 1000);
+        let input_len_range = Uniform::new(0, 1000);
+
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+
+        for _ in 0..10_000 {
+            orig_data.clear();
+            encoded_data.clear();
+            decoded_with_prefix.clear();
+            decoded_without_prefix.clear();
+            prefix.clear();
+
+            let input_len = input_len_range.sample(&mut rng);
+
+            for _ in 0..input_len {
+                orig_data.push(rng.gen());
+            }
+
+            let config = random_config(&mut rng);
+            encode_config_buf(&orig_data, config, &mut encoded_data);
+            assert_encode_sanity(&encoded_data, config, input_len);
+
+            let prefix_len = prefix_len_range.sample(&mut rng);
+
+            // fill the buf with a prefix
+            for _ in 0..prefix_len {
+                prefix.push(rng.gen());
+            }
+
+            decoded_with_prefix.resize(prefix_len, 0);
+            decoded_with_prefix.copy_from_slice(&prefix);
+
+            // decode into the non-empty buf
+            decode_config_buf(&encoded_data, config, &mut decoded_with_prefix).unwrap();
+            // also decode into the empty buf
+            decode_config_buf(&encoded_data, config, &mut decoded_without_prefix).unwrap();
+
+            assert_eq!(
+                prefix_len + decoded_without_prefix.len(),
+                decoded_with_prefix.len()
+            );
+            assert_eq!(orig_data, decoded_without_prefix);
+
+            // append plain decode onto prefix
+            prefix.append(&mut decoded_without_prefix);
+
+            assert_eq!(prefix, decoded_with_prefix);
+        }
+    }
+
+    #[test]
+    fn decode_into_slice_doesnt_clobber_existing_prefix_or_suffix() {
+        let mut orig_data = Vec::new();
+        let mut encoded_data = String::new();
+        let mut decode_buf = Vec::new();
+        let mut decode_buf_copy: Vec<u8> = Vec::new();
+
+        let input_len_range = Uniform::new(0, 1000);
+
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+
+        for _ in 0..10_000 {
+            orig_data.clear();
+            encoded_data.clear();
+            decode_buf.clear();
+            decode_buf_copy.clear();
+
+            let input_len = input_len_range.sample(&mut rng);
+
+            for _ in 0..input_len {
+                orig_data.push(rng.gen());
+            }
+
+            let config = random_config(&mut rng);
+            encode_config_buf(&orig_data, config, &mut encoded_data);
+            assert_encode_sanity(&encoded_data, config, input_len);
+
+            // fill the buffer with random garbage, long enough to have some room before and after
+            for _ in 0..5000 {
+                decode_buf.push(rng.gen());
+            }
+
+            // keep a copy for later comparison
+            decode_buf_copy.extend(decode_buf.iter());
+
+            let offset = 1000;
+
+            // decode into the non-empty buf
+            let decode_bytes_written =
+                decode_config_slice(&encoded_data, config, &mut decode_buf[offset..]).unwrap();
+
+            assert_eq!(orig_data.len(), decode_bytes_written);
+            assert_eq!(
+                orig_data,
+                &decode_buf[offset..(offset + decode_bytes_written)]
+            );
+            assert_eq!(&decode_buf_copy[0..offset], &decode_buf[0..offset]);
+            assert_eq!(
+                &decode_buf_copy[offset + decode_bytes_written..],
+                &decode_buf[offset + decode_bytes_written..]
+            );
+        }
+    }
+
+    #[test]
+    fn decode_into_slice_fits_in_precisely_sized_slice() {
+        let mut orig_data = Vec::new();
+        let mut encoded_data = String::new();
+        let mut decode_buf = Vec::new();
+
+        let input_len_range = Uniform::new(0, 1000);
+
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+
+        for _ in 0..10_000 {
+            orig_data.clear();
+            encoded_data.clear();
+            decode_buf.clear();
+
+            let input_len = input_len_range.sample(&mut rng);
+
+            for _ in 0..input_len {
+                orig_data.push(rng.gen());
+            }
+
+            let config = random_config(&mut rng);
+            encode_config_buf(&orig_data, config, &mut encoded_data);
+            assert_encode_sanity(&encoded_data, config, input_len);
+
+            decode_buf.resize(input_len, 0);
+
+            // decode into the non-empty buf
+            let decode_bytes_written =
+                decode_config_slice(&encoded_data, config, &mut decode_buf[..]).unwrap();
+
+            assert_eq!(orig_data.len(), decode_bytes_written);
+            assert_eq!(orig_data, decode_buf);
+        }
+    }
+
+    #[test]
+    fn detect_invalid_last_symbol_two_bytes() {
+        let decode =
+            |input, forgiving| decode_config(input, STANDARD.decode_allow_trailing_bits(forgiving));
+
+        // example from https://github.com/marshallpierce/rust-base64/issues/75
+        assert!(decode("iYU=", false).is_ok());
+        // trailing 01
+        assert_eq!(
+            Err(DecodeError::InvalidLastSymbol(2, b'V')),
+            decode("iYV=", false)
+        );
+        assert_eq!(Ok(vec![137, 133]), decode("iYV=", true));
+        // trailing 10
+        assert_eq!(
+            Err(DecodeError::InvalidLastSymbol(2, b'W')),
+            decode("iYW=", false)
+        );
+        assert_eq!(Ok(vec![137, 133]), decode("iYV=", true));
+        // trailing 11
+        assert_eq!(
+            Err(DecodeError::InvalidLastSymbol(2, b'X')),
+            decode("iYX=", false)
+        );
+        assert_eq!(Ok(vec![137, 133]), decode("iYV=", true));
+
+        // also works when there are 2 quads in the last block
+        assert_eq!(
+            Err(DecodeError::InvalidLastSymbol(6, b'X')),
+            decode("AAAAiYX=", false)
+        );
+        assert_eq!(Ok(vec![0, 0, 0, 137, 133]), decode("AAAAiYX=", true));
+    }
+
+    #[test]
+    fn detect_invalid_last_symbol_one_byte() {
+        // 0xFF -> "/w==", so all letters > w, 0-9, and '+', '/' should get InvalidLastSymbol
+
+        assert!(decode("/w==").is_ok());
+        // trailing 01
+        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'x')), decode("/x=="));
+        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'z')), decode("/z=="));
+        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'0')), decode("/0=="));
+        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'9')), decode("/9=="));
+        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'+')), decode("/+=="));
+        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'/')), decode("//=="));
+
+        // also works when there are 2 quads in the last block
+        assert_eq!(
+            Err(DecodeError::InvalidLastSymbol(5, b'x')),
+            decode("AAAA/x==")
+        );
+    }
+
+    #[test]
+    fn detect_invalid_last_symbol_every_possible_three_symbols() {
+        let mut base64_to_bytes = ::std::collections::HashMap::new();
+
+        let mut bytes = [0_u8; 2];
+        for b1 in 0_u16..256 {
+            bytes[0] = b1 as u8;
+            for b2 in 0_u16..256 {
+                bytes[1] = b2 as u8;
+                let mut b64 = vec![0_u8; 4];
+                assert_eq!(4, encode_config_slice(&bytes, STANDARD, &mut b64[..]));
+                let mut v = ::std::vec::Vec::with_capacity(2);
+                v.extend_from_slice(&bytes[..]);
+
+                assert!(base64_to_bytes.insert(b64, v).is_none());
+            }
+        }
+
+        // every possible combination of symbols must either decode to 2 bytes or get InvalidLastSymbol
+
+        let mut symbols = [0_u8; 4];
+        for &s1 in STANDARD.char_set.encode_table().iter() {
+            symbols[0] = s1;
+            for &s2 in STANDARD.char_set.encode_table().iter() {
+                symbols[1] = s2;
+                for &s3 in STANDARD.char_set.encode_table().iter() {
+                    symbols[2] = s3;
+                    symbols[3] = PAD_BYTE;
+
+                    match base64_to_bytes.get(&symbols[..]) {
+                        Some(bytes) => {
+                            assert_eq!(Ok(bytes.to_vec()), decode_config(&symbols, STANDARD))
+                        }
+                        None => assert_eq!(
+                            Err(DecodeError::InvalidLastSymbol(2, s3)),
+                            decode_config(&symbols[..], STANDARD)
+                        ),
+                    }
+                }
+            }
+        }
+    }
+
+    #[test]
+    fn detect_invalid_last_symbol_every_possible_two_symbols() {
+        let mut base64_to_bytes = ::std::collections::HashMap::new();
+
+        for b in 0_u16..256 {
+            let mut b64 = vec![0_u8; 4];
+            assert_eq!(4, encode_config_slice(&[b as u8], STANDARD, &mut b64[..]));
+            let mut v = ::std::vec::Vec::with_capacity(1);
+            v.push(b as u8);
+
+            assert!(base64_to_bytes.insert(b64, v).is_none());
+        }
+
+        // every possible combination of symbols must either decode to 1 byte or get InvalidLastSymbol
+
+        let mut symbols = [0_u8; 4];
+        for &s1 in STANDARD.char_set.encode_table().iter() {
+            symbols[0] = s1;
+            for &s2 in STANDARD.char_set.encode_table().iter() {
+                symbols[1] = s2;
+                symbols[2] = PAD_BYTE;
+                symbols[3] = PAD_BYTE;
+
+                match base64_to_bytes.get(&symbols[..]) {
+                    Some(bytes) => {
+                        assert_eq!(Ok(bytes.to_vec()), decode_config(&symbols, STANDARD))
+                    }
+                    None => assert_eq!(
+                        Err(DecodeError::InvalidLastSymbol(1, s2)),
+                        decode_config(&symbols[..], STANDARD)
+                    ),
+                }
+            }
+        }
+    }
+
+    #[test]
+    fn decode_config_estimation_works_for_various_lengths() {
+        for num_prefix_quads in 0..100 {
+            for suffix in &["AA", "AAA", "AAAA"] {
+                let mut prefix = "AAAA".repeat(num_prefix_quads);
+                prefix.push_str(suffix);
+                // make sure no overflow (and thus a panic) occurs
+                let res = decode_config(prefix, STANDARD);
+                assert!(res.is_ok());
+            }
+        }
+    }
+}
diff --git a/vendor/base64/src/display.rs b/vendor/base64/src/display.rs
new file mode 100644
index 000000000..cc70aac22
--- /dev/null
+++ b/vendor/base64/src/display.rs
@@ -0,0 +1,88 @@
+//! Enables base64'd output anywhere you might use a `Display` implementation, like a format string.
+//!
+//! ```
+//! use base64::display::Base64Display;
+//!
+//! let data = vec![0x0, 0x1, 0x2, 0x3];
+//! let wrapper = Base64Display::with_config(&data, base64::STANDARD);
+//!
+//! assert_eq!("base64: AAECAw==", format!("base64: {}", wrapper));
+//! ```
+
+use super::chunked_encoder::ChunkedEncoder;
+use super::Config;
+use core::fmt::{Display, Formatter};
+use core::{fmt, str};
+
+/// A convenience wrapper for base64'ing bytes into a format string without heap allocation.
+pub struct Base64Display<'a> {
+    bytes: &'a [u8],
+    chunked_encoder: ChunkedEncoder,
+}
+
+impl<'a> Base64Display<'a> {
+    /// Create a `Base64Display` with the provided config.
+    pub fn with_config(bytes: &[u8], config: Config) -> Base64Display {
+        Base64Display {
+            bytes,
+            chunked_encoder: ChunkedEncoder::new(config),
+        }
+    }
+}
+
+impl<'a> Display for Base64Display<'a> {
+    fn fmt(&self, formatter: &mut Formatter) -> Result<(), fmt::Error> {
+        let mut sink = FormatterSink { f: formatter };
+        self.chunked_encoder.encode(self.bytes, &mut sink)
+    }
+}
+
+struct FormatterSink<'a, 'b: 'a> {
+    f: &'a mut Formatter<'b>,
+}
+
+impl<'a, 'b: 'a> super::chunked_encoder::Sink for FormatterSink<'a, 'b> {
+    type Error = fmt::Error;
+
+    fn write_encoded_bytes(&mut self, encoded: &[u8]) -> Result<(), Self::Error> {
+        // Avoid unsafe. If max performance is needed, write your own display wrapper that uses
+        // unsafe here to gain about 10-15%.
+        self.f
+            .write_str(str::from_utf8(encoded).expect("base64 data was not utf8"))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::super::chunked_encoder::tests::{
+        chunked_encode_matches_normal_encode_random, SinkTestHelper,
+    };
+    use super::super::*;
+    use super::*;
+
+    #[test]
+    fn basic_display() {
+        assert_eq!(
+            "~$Zm9vYmFy#*",
+            format!("~${}#*", Base64Display::with_config(b"foobar", STANDARD))
+        );
+        assert_eq!(
+            "~$Zm9vYmFyZg==#*",
+            format!("~${}#*", Base64Display::with_config(b"foobarf", STANDARD))
+        );
+    }
+
+    #[test]
+    fn display_encode_matches_normal_encode() {
+        let helper = DisplaySinkTestHelper;
+        chunked_encode_matches_normal_encode_random(&helper);
+    }
+
+    struct DisplaySinkTestHelper;
+
+    impl SinkTestHelper for DisplaySinkTestHelper {
+        fn encode_to_string(&self, config: Config, bytes: &[u8]) -> String {
+            format!("{}", Base64Display::with_config(bytes, config))
+        }
+    }
+}
diff --git a/vendor/base64/src/encode.rs b/vendor/base64/src/encode.rs
new file mode 100644
index 000000000..b32bbfff0
--- /dev/null
+++ b/vendor/base64/src/encode.rs
@@ -0,0 +1,675 @@
+use crate::{Config, PAD_BYTE};
+#[cfg(any(feature = "alloc", feature = "std", test))]
+use crate::{chunked_encoder, STANDARD};
+#[cfg(any(feature = "alloc", feature = "std", test))]
+use alloc::{string::String, vec};
+use core::convert::TryInto;
+
+///Encode arbitrary octets as base64.
+///Returns a String.
+///Convenience for `encode_config(input, base64::STANDARD);`.
+///
+///# Example
+///
+///```rust
+///extern crate base64;
+///
+///fn main() {
+///    let b64 = base64::encode(b"hello world");
+///    println!("{}", b64);
+///}
+///```
+#[cfg(any(feature = "alloc", feature = "std", test))]
+pub fn encode<T: AsRef<[u8]>>(input: T) -> String {
+    encode_config(input, STANDARD)
+}
+
+///Encode arbitrary octets as base64.
+///Returns a String.
+///
+///# Example
+///
+///```rust
+///extern crate base64;
+///
+///fn main() {
+///    let b64 = base64::encode_config(b"hello world~", base64::STANDARD);
+///    println!("{}", b64);
+///
+///    let b64_url = base64::encode_config(b"hello internet~", base64::URL_SAFE);
+///    println!("{}", b64_url);
+///}
+///```
+#[cfg(any(feature = "alloc", feature = "std", test))]
+pub fn encode_config<T: AsRef<[u8]>>(input: T, config: Config) -> String {
+    let mut buf = match encoded_size(input.as_ref().len(), config) {
+        Some(n) => vec![0; n],
+        None => panic!("integer overflow when calculating buffer size"),
+    };
+
+    encode_with_padding(input.as_ref(), config, buf.len(), &mut buf[..]);
+
+    String::from_utf8(buf).expect("Invalid UTF8")
+}
+
+///Encode arbitrary octets as base64.
+///Writes into the supplied output buffer, which will grow the buffer if needed.
+///
+///# Example
+///
+///```rust
+///extern crate base64;
+///
+///fn main() {
+///    let mut buf = String::new();
+///    base64::encode_config_buf(b"hello world~", base64::STANDARD, &mut buf);
+///    println!("{}", buf);
+///
+///    buf.clear();
+///    base64::encode_config_buf(b"hello internet~", base64::URL_SAFE, &mut buf);
+///    println!("{}", buf);
+///}
+///```
+#[cfg(any(feature = "alloc", feature = "std", test))]
+pub fn encode_config_buf<T: AsRef<[u8]>>(input: T, config: Config, buf: &mut String) {
+    let input_bytes = input.as_ref();
+
+    {
+        let mut sink = chunked_encoder::StringSink::new(buf);
+        let encoder = chunked_encoder::ChunkedEncoder::new(config);
+
+        encoder
+            .encode(input_bytes, &mut sink)
+            .expect("Writing to a String shouldn't fail")
+    }
+}
+
+/// Encode arbitrary octets as base64.
+/// Writes into the supplied output buffer.
+///
+/// This is useful if you wish to avoid allocation entirely (e.g. encoding into a stack-resident
+/// or statically-allocated buffer).
+///
+/// # Panics
+///
+/// If `output` is too small to hold the encoded version of `input`, a panic will result.
+///
+/// # Example
+///
+/// ```rust
+/// extern crate base64;
+///
+/// fn main() {
+///     let s = b"hello internet!";
+///     let mut buf = Vec::new();
+///     // make sure we'll have a slice big enough for base64 + padding
+///     buf.resize(s.len() * 4 / 3 + 4, 0);
+///
+///     let bytes_written = base64::encode_config_slice(s,
+///                             base64::STANDARD, &mut buf);
+///
+///     // shorten our vec down to just what was written
+///     buf.resize(bytes_written, 0);
+///
+///     assert_eq!(s, base64::decode(&buf).unwrap().as_slice());
+/// }
+/// ```
+pub fn encode_config_slice<T: AsRef<[u8]>>(input: T, config: Config, output: &mut [u8]) -> usize {
+    let input_bytes = input.as_ref();
+
+    let encoded_size = encoded_size(input_bytes.len(), config)
+        .expect("usize overflow when calculating buffer size");
+
+    let mut b64_output = &mut output[0..encoded_size];
+
+    encode_with_padding(&input_bytes, config, encoded_size, &mut b64_output);
+
+    encoded_size
+}
+
+/// B64-encode and pad (if configured).
+///
+/// This helper exists to avoid recalculating encoded_size, which is relatively expensive on short
+/// inputs.
+///
+/// `encoded_size` is the encoded size calculated for `input`.
+///
+/// `output` must be of size `encoded_size`.
+///
+/// All bytes in `output` will be written to since it is exactly the size of the output.
+fn encode_with_padding(input: &[u8], config: Config, encoded_size: usize, output: &mut [u8]) {
+    debug_assert_eq!(encoded_size, output.len());
+
+    let b64_bytes_written = encode_to_slice(input, output, config.char_set.encode_table());
+
+    let padding_bytes = if config.pad {
+        add_padding(input.len(), &mut output[b64_bytes_written..])
+    } else {
+        0
+    };
+
+    let encoded_bytes = b64_bytes_written
+        .checked_add(padding_bytes)
+        .expect("usize overflow when calculating b64 length");
+
+    debug_assert_eq!(encoded_size, encoded_bytes);
+}
+
+#[inline]
+fn read_u64(s: &[u8]) -> u64 {
+    u64::from_be_bytes(s[..8].try_into().unwrap())
+}
+
+/// Encode input bytes to utf8 base64 bytes. Does not pad.
+/// `output` must be long enough to hold the encoded `input` without padding.
+/// Returns the number of bytes written.
+#[inline]
+pub fn encode_to_slice(input: &[u8], output: &mut [u8], encode_table: &[u8; 64]) -> usize {
+    let mut input_index: usize = 0;
+
+    const BLOCKS_PER_FAST_LOOP: usize = 4;
+    const LOW_SIX_BITS: u64 = 0x3F;
+
+    // we read 8 bytes at a time (u64) but only actually consume 6 of those bytes. Thus, we need
+    // 2 trailing bytes to be available to read..
+    let last_fast_index = input.len().saturating_sub(BLOCKS_PER_FAST_LOOP * 6 + 2);
+    let mut output_index = 0;
+
+    if last_fast_index > 0 {
+        while input_index <= last_fast_index {
+            // Major performance wins from letting the optimizer do the bounds check once, mostly
+            // on the output side
+            let input_chunk = &input[input_index..(input_index + (BLOCKS_PER_FAST_LOOP * 6 + 2))];
+            let output_chunk = &mut output[output_index..(output_index + BLOCKS_PER_FAST_LOOP * 8)];
+
+            // Hand-unrolling for 32 vs 16 or 8 bytes produces yields performance about equivalent
+            // to unsafe pointer code on a Xeon E5-1650v3. 64 byte unrolling was slightly better for
+            // large inputs but significantly worse for 50-byte input, unsurprisingly. I suspect
+            // that it's a not uncommon use case to encode smallish chunks of data (e.g. a 64-byte
+            // SHA-512 digest), so it would be nice if that fit in the unrolled loop at least once.
+            // Plus, single-digit percentage performance differences might well be quite different
+            // on different hardware.
+
+            let input_u64 = read_u64(&input_chunk[0..]);
+
+            output_chunk[0] = encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];
+            output_chunk[1] = encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];
+            output_chunk[2] = encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];
+            output_chunk[3] = encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];
+            output_chunk[4] = encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];
+            output_chunk[5] = encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];
+            output_chunk[6] = encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];
+            output_chunk[7] = encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];
+
+            let input_u64 = read_u64(&input_chunk[6..]);
+
+            output_chunk[8] = encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];
+            output_chunk[9] = encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];
+            output_chunk[10] = encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];
+            output_chunk[11] = encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];
+            output_chunk[12] = encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];
+            output_chunk[13] = encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];
+            output_chunk[14] = encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];
+            output_chunk[15] = encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];
+
+            let input_u64 = read_u64(&input_chunk[12..]);
+
+            output_chunk[16] = encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];
+            output_chunk[17] = encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];
+            output_chunk[18] = encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];
+            output_chunk[19] = encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];
+            output_chunk[20] = encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];
+            output_chunk[21] = encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];
+            output_chunk[22] = encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];
+            output_chunk[23] = encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];
+
+            let input_u64 = read_u64(&input_chunk[18..]);
+
+            output_chunk[24] = encode_table[((input_u64 >> 58) & LOW_SIX_BITS) as usize];
+            output_chunk[25] = encode_table[((input_u64 >> 52) & LOW_SIX_BITS) as usize];
+            output_chunk[26] = encode_table[((input_u64 >> 46) & LOW_SIX_BITS) as usize];
+            output_chunk[27] = encode_table[((input_u64 >> 40) & LOW_SIX_BITS) as usize];
+            output_chunk[28] = encode_table[((input_u64 >> 34) & LOW_SIX_BITS) as usize];
+            output_chunk[29] = encode_table[((input_u64 >> 28) & LOW_SIX_BITS) as usize];
+            output_chunk[30] = encode_table[((input_u64 >> 22) & LOW_SIX_BITS) as usize];
+            output_chunk[31] = encode_table[((input_u64 >> 16) & LOW_SIX_BITS) as usize];
+
+            output_index += BLOCKS_PER_FAST_LOOP * 8;
+            input_index += BLOCKS_PER_FAST_LOOP * 6;
+        }
+    }
+
+    // Encode what's left after the fast loop.
+
+    const LOW_SIX_BITS_U8: u8 = 0x3F;
+
+    let rem = input.len() % 3;
+    let start_of_rem = input.len() - rem;
+
+    // start at the first index not handled by fast loop, which may be 0.
+
+    while input_index < start_of_rem {
+        let input_chunk = &input[input_index..(input_index + 3)];
+        let output_chunk = &mut output[output_index..(output_index + 4)];
+
+        output_chunk[0] = encode_table[(input_chunk[0] >> 2) as usize];
+        output_chunk[1] =
+            encode_table[((input_chunk[0] << 4 | input_chunk[1] >> 4) & LOW_SIX_BITS_U8) as usize];
+        output_chunk[2] =
+            encode_table[((input_chunk[1] << 2 | input_chunk[2] >> 6) & LOW_SIX_BITS_U8) as usize];
+        output_chunk[3] = encode_table[(input_chunk[2] & LOW_SIX_BITS_U8) as usize];
+
+        input_index += 3;
+        output_index += 4;
+    }
+
+    if rem == 2 {
+        output[output_index] = encode_table[(input[start_of_rem] >> 2) as usize];
+        output[output_index + 1] = encode_table[((input[start_of_rem] << 4
+            | input[start_of_rem + 1] >> 4)
+            & LOW_SIX_BITS_U8) as usize];
+        output[output_index + 2] =
+            encode_table[((input[start_of_rem + 1] << 2) & LOW_SIX_BITS_U8) as usize];
+        output_index += 3;
+    } else if rem == 1 {
+        output[output_index] = encode_table[(input[start_of_rem] >> 2) as usize];
+        output[output_index + 1] =
+            encode_table[((input[start_of_rem] << 4) & LOW_SIX_BITS_U8) as usize];
+        output_index += 2;
+    }
+
+    output_index
+}
+
+/// calculate the base64 encoded string size, including padding if appropriate
+pub fn encoded_size(bytes_len: usize, config: Config) -> Option<usize> {
+    let rem = bytes_len % 3;
+
+    let complete_input_chunks = bytes_len / 3;
+    let complete_chunk_output = complete_input_chunks.checked_mul(4);
+
+    if rem > 0 {
+        if config.pad {
+            complete_chunk_output.and_then(|c| c.checked_add(4))
+        } else {
+            let encoded_rem = match rem {
+                1 => 2,
+                2 => 3,
+                _ => unreachable!("Impossible remainder"),
+            };
+            complete_chunk_output.and_then(|c| c.checked_add(encoded_rem))
+        }
+    } else {
+        complete_chunk_output
+    }
+}
+
+/// Write padding characters.
+/// `output` is the slice where padding should be written, of length at least 2.
+///
+/// Returns the number of padding bytes written.
+pub fn add_padding(input_len: usize, output: &mut [u8]) -> usize {
+    let rem = input_len % 3;
+    let mut bytes_written = 0;
+    for _ in 0..((3 - rem) % 3) {
+        output[bytes_written] = PAD_BYTE;
+        bytes_written += 1;
+    }
+
+    bytes_written
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::{
+        decode::decode_config_buf,
+        tests::{assert_encode_sanity, random_config},
+        Config, STANDARD, URL_SAFE_NO_PAD,
+    };
+
+    use rand::{
+        distributions::{Distribution, Uniform},
+        FromEntropy, Rng,
+    };
+    use std;
+    use std::str;
+
+    #[test]
+    fn encoded_size_correct_standard() {
+        assert_encoded_length(0, 0, STANDARD);
+
+        assert_encoded_length(1, 4, STANDARD);
+        assert_encoded_length(2, 4, STANDARD);
+        assert_encoded_length(3, 4, STANDARD);
+
+        assert_encoded_length(4, 8, STANDARD);
+        assert_encoded_length(5, 8, STANDARD);
+        assert_encoded_length(6, 8, STANDARD);
+
+        assert_encoded_length(7, 12, STANDARD);
+        assert_encoded_length(8, 12, STANDARD);
+        assert_encoded_length(9, 12, STANDARD);
+
+        assert_encoded_length(54, 72, STANDARD);
+
+        assert_encoded_length(55, 76, STANDARD);
+        assert_encoded_length(56, 76, STANDARD);
+        assert_encoded_length(57, 76, STANDARD);
+
+        assert_encoded_length(58, 80, STANDARD);
+    }
+
+    #[test]
+    fn encoded_size_correct_no_pad() {
+        assert_encoded_length(0, 0, URL_SAFE_NO_PAD);
+
+        assert_encoded_length(1, 2, URL_SAFE_NO_PAD);
+        assert_encoded_length(2, 3, URL_SAFE_NO_PAD);
+        assert_encoded_length(3, 4, URL_SAFE_NO_PAD);
+
+        assert_encoded_length(4, 6, URL_SAFE_NO_PAD);
+        assert_encoded_length(5, 7, URL_SAFE_NO_PAD);
+        assert_encoded_length(6, 8, URL_SAFE_NO_PAD);
+
+        assert_encoded_length(7, 10, URL_SAFE_NO_PAD);
+        assert_encoded_length(8, 11, URL_SAFE_NO_PAD);
+        assert_encoded_length(9, 12, URL_SAFE_NO_PAD);
+
+        assert_encoded_length(54, 72, URL_SAFE_NO_PAD);
+
+        assert_encoded_length(55, 74, URL_SAFE_NO_PAD);
+        assert_encoded_length(56, 75, URL_SAFE_NO_PAD);
+        assert_encoded_length(57, 76, URL_SAFE_NO_PAD);
+
+        assert_encoded_length(58, 78, URL_SAFE_NO_PAD);
+    }
+
+    #[test]
+    fn encoded_size_overflow() {
+        assert_eq!(None, encoded_size(std::usize::MAX, STANDARD));
+    }
+
+    #[test]
+    fn encode_config_buf_into_nonempty_buffer_doesnt_clobber_prefix() {
+        let mut orig_data = Vec::new();
+        let mut prefix = String::new();
+        let mut encoded_data_no_prefix = String::new();
+        let mut encoded_data_with_prefix = String::new();
+        let mut decoded = Vec::new();
+
+        let prefix_len_range = Uniform::new(0, 1000);
+        let input_len_range = Uniform::new(0, 1000);
+
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+
+        for _ in 0..10_000 {
+            orig_data.clear();
+            prefix.clear();
+            encoded_data_no_prefix.clear();
+            encoded_data_with_prefix.clear();
+            decoded.clear();
+
+            let input_len = input_len_range.sample(&mut rng);
+
+            for _ in 0..input_len {
+                orig_data.push(rng.gen());
+            }
+
+            let prefix_len = prefix_len_range.sample(&mut rng);
+            for _ in 0..prefix_len {
+                // getting convenient random single-byte printable chars that aren't base64 is
+                // annoying
+                prefix.push('#');
+            }
+            encoded_data_with_prefix.push_str(&prefix);
+
+            let config = random_config(&mut rng);
+            encode_config_buf(&orig_data, config, &mut encoded_data_no_prefix);
+            encode_config_buf(&orig_data, config, &mut encoded_data_with_prefix);
+
+            assert_eq!(
+                encoded_data_no_prefix.len() + prefix_len,
+                encoded_data_with_prefix.len()
+            );
+            assert_encode_sanity(&encoded_data_no_prefix, config, input_len);
+            assert_encode_sanity(&encoded_data_with_prefix[prefix_len..], config, input_len);
+
+            // append plain encode onto prefix
+            prefix.push_str(&mut encoded_data_no_prefix);
+
+            assert_eq!(prefix, encoded_data_with_prefix);
+
+            decode_config_buf(&encoded_data_no_prefix, config, &mut decoded).unwrap();
+            assert_eq!(orig_data, decoded);
+        }
+    }
+
+    #[test]
+    fn encode_config_slice_into_nonempty_buffer_doesnt_clobber_suffix() {
+        let mut orig_data = Vec::new();
+        let mut encoded_data = Vec::new();
+        let mut encoded_data_original_state = Vec::new();
+        let mut decoded = Vec::new();
+
+        let input_len_range = Uniform::new(0, 1000);
+
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+
+        for _ in 0..10_000 {
+            orig_data.clear();
+            encoded_data.clear();
+            encoded_data_original_state.clear();
+            decoded.clear();
+
+            let input_len = input_len_range.sample(&mut rng);
+
+            for _ in 0..input_len {
+                orig_data.push(rng.gen());
+            }
+
+            // plenty of existing garbage in the encoded buffer
+            for _ in 0..10 * input_len {
+                encoded_data.push(rng.gen());
+            }
+
+            encoded_data_original_state.extend_from_slice(&encoded_data);
+
+            let config = random_config(&mut rng);
+
+            let encoded_size = encoded_size(input_len, config).unwrap();
+
+            assert_eq!(
+                encoded_size,
+                encode_config_slice(&orig_data, config, &mut encoded_data)
+            );
+
+            assert_encode_sanity(
+                std::str::from_utf8(&encoded_data[0..encoded_size]).unwrap(),
+                config,
+                input_len,
+            );
+
+            assert_eq!(
+                &encoded_data[encoded_size..],
+                &encoded_data_original_state[encoded_size..]
+            );
+
+            decode_config_buf(&encoded_data[0..encoded_size], config, &mut decoded).unwrap();
+            assert_eq!(orig_data, decoded);
+        }
+    }
+
+    #[test]
+    fn encode_config_slice_fits_into_precisely_sized_slice() {
+        let mut orig_data = Vec::new();
+        let mut encoded_data = Vec::new();
+        let mut decoded = Vec::new();
+
+        let input_len_range = Uniform::new(0, 1000);
+
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+
+        for _ in 0..10_000 {
+            orig_data.clear();
+            encoded_data.clear();
+            decoded.clear();
+
+            let input_len = input_len_range.sample(&mut rng);
+
+            for _ in 0..input_len {
+                orig_data.push(rng.gen());
+            }
+
+            let config = random_config(&mut rng);
+
+            let encoded_size = encoded_size(input_len, config).unwrap();
+
+            encoded_data.resize(encoded_size, 0);
+
+            assert_eq!(
+                encoded_size,
+                encode_config_slice(&orig_data, config, &mut encoded_data)
+            );
+
+            assert_encode_sanity(
+                std::str::from_utf8(&encoded_data[0..encoded_size]).unwrap(),
+                config,
+                input_len,
+            );
+
+            decode_config_buf(&encoded_data[0..encoded_size], config, &mut decoded).unwrap();
+            assert_eq!(orig_data, decoded);
+        }
+    }
+
+    #[test]
+    fn encode_to_slice_random_valid_utf8() {
+        let mut input = Vec::new();
+        let mut output = Vec::new();
+
+        let input_len_range = Uniform::new(0, 1000);
+
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+
+        for _ in 0..10_000 {
+            input.clear();
+            output.clear();
+
+            let input_len = input_len_range.sample(&mut rng);
+
+            for _ in 0..input_len {
+                input.push(rng.gen());
+            }
+
+            let config = random_config(&mut rng);
+
+            // fill up the output buffer with garbage
+            let encoded_size = encoded_size(input_len, config).unwrap();
+            for _ in 0..encoded_size {
+                output.push(rng.gen());
+            }
+
+            let orig_output_buf = output.to_vec();
+
+            let bytes_written =
+                encode_to_slice(&input, &mut output, config.char_set.encode_table());
+
+            // make sure the part beyond bytes_written is the same garbage it was before
+            assert_eq!(orig_output_buf[bytes_written..], output[bytes_written..]);
+
+            // make sure the encoded bytes are UTF-8
+            let _ = str::from_utf8(&output[0..bytes_written]).unwrap();
+        }
+    }
+
+    #[test]
+    fn encode_with_padding_random_valid_utf8() {
+        let mut input = Vec::new();
+        let mut output = Vec::new();
+
+        let input_len_range = Uniform::new(0, 1000);
+
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+
+        for _ in 0..10_000 {
+            input.clear();
+            output.clear();
+
+            let input_len = input_len_range.sample(&mut rng);
+
+            for _ in 0..input_len {
+                input.push(rng.gen());
+            }
+
+            let config = random_config(&mut rng);
+
+            // fill up the output buffer with garbage
+            let encoded_size = encoded_size(input_len, config).unwrap();
+            for _ in 0..encoded_size + 1000 {
+                output.push(rng.gen());
+            }
+
+            let orig_output_buf = output.to_vec();
+
+            encode_with_padding(&input, config, encoded_size, &mut output[0..encoded_size]);
+
+            // make sure the part beyond b64 is the same garbage it was before
+            assert_eq!(orig_output_buf[encoded_size..], output[encoded_size..]);
+
+            // make sure the encoded bytes are UTF-8
+            let _ = str::from_utf8(&output[0..encoded_size]).unwrap();
+        }
+    }
+
+    #[test]
+    fn add_padding_random_valid_utf8() {
+        let mut output = Vec::new();
+
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+
+        // cover our bases for length % 3
+        for input_len in 0..10 {
+            output.clear();
+
+            // fill output with random
+            for _ in 0..10 {
+                output.push(rng.gen());
+            }
+
+            let orig_output_buf = output.to_vec();
+
+            let bytes_written = add_padding(input_len, &mut output);
+
+            // make sure the part beyond bytes_written is the same garbage it was before
+            assert_eq!(orig_output_buf[bytes_written..], output[bytes_written..]);
+
+            // make sure the encoded bytes are UTF-8
+            let _ = str::from_utf8(&output[0..bytes_written]).unwrap();
+        }
+    }
+
+    fn assert_encoded_length(input_len: usize, encoded_len: usize, config: Config) {
+        assert_eq!(encoded_len, encoded_size(input_len, config).unwrap());
+
+        let mut bytes: Vec<u8> = Vec::new();
+        let mut rng = rand::rngs::SmallRng::from_entropy();
+
+        for _ in 0..input_len {
+            bytes.push(rng.gen());
+        }
+
+        let encoded = encode_config(&bytes, config);
+        assert_encode_sanity(&encoded, config, input_len);
+
+        assert_eq!(encoded_len, encoded.len());
+    }
+
+    #[test]
+    fn encode_imap() {
+        assert_eq!(
+            encode_config(b"\xFB\xFF", crate::IMAP_MUTF7),
+            encode_config(b"\xFB\xFF", crate::STANDARD_NO_PAD).replace("/", ",")
+        );
+    }
+}
diff --git a/vendor/base64/src/lib.rs b/vendor/base64/src/lib.rs
new file mode 100644
index 000000000..6bded1606
--- /dev/null
+++ b/vendor/base64/src/lib.rs
@@ -0,0 +1,245 @@
+//! # Configs
+//!
+//! There isn't just one type of Base64; that would be too simple. You need to choose a character
+//! set (standard, URL-safe, etc) and padding suffix (yes/no).
+//! The `Config` struct encapsulates this info. There are some common configs included: `STANDARD`,
+//! `URL_SAFE`, etc. You can also make your own `Config` if needed.
+//!
+//! The functions that don't have `config` in the name (e.g. `encode()` and `decode()`) use the
+//! `STANDARD` config .
+//!
+//! The functions that write to a slice (the ones that end in `_slice`) are generally the fastest
+//! because they don't need to resize anything. If it fits in your workflow and you care about
+//! performance, keep using the same buffer (growing as need be) and use the `_slice` methods for
+//! the best performance.
+//!
+//! # Encoding
+//!
+//! Several different encoding functions are available to you depending on your desire for
+//! convenience vs performance.
+//!
+//! | Function                | Output                       | Allocates                      |
+//! | ----------------------- | ---------------------------- | ------------------------------ |
+//! | `encode`                | Returns a new `String`       | Always                         |
+//! | `encode_config`         | Returns a new `String`       | Always                         |
+//! | `encode_config_buf`     | Appends to provided `String` | Only if `String` needs to grow |
+//! | `encode_config_slice`   | Writes to provided `&[u8]`   | Never                          |
+//!
+//! All of the encoding functions that take a `Config` will pad as per the config.
+//!
+//! # Decoding
+//!
+//! Just as for encoding, there are different decoding functions available.
+//!
+//! | Function                | Output                        | Allocates                      |
+//! | ----------------------- | ----------------------------- | ------------------------------ |
+//! | `decode`                | Returns a new `Vec<u8>`       | Always                         |
+//! | `decode_config`         | Returns a new `Vec<u8>`       | Always                         |
+//! | `decode_config_buf`     | Appends to provided `Vec<u8>` | Only if `Vec` needs to grow    |
+//! | `decode_config_slice`   | Writes to provided `&[u8]`    | Never                          |
+//!
+//! Unlike encoding, where all possible input is valid, decoding can fail (see `DecodeError`).
+//!
+//! Input can be invalid because it has invalid characters or invalid padding. (No padding at all is
+//! valid, but excess padding is not.) Whitespace in the input is invalid.
+//!
+//! # `Read` and `Write`
+//!
+//! To map a `Read` of b64 bytes to the decoded bytes, wrap a reader (file, network socket, etc)
+//! with `base64::read::DecoderReader`. To write raw bytes and have them b64 encoded on the fly,
+//! wrap a writer with `base64::write::EncoderWriter`. There is some performance overhead (15% or
+//! so) because of the necessary buffer shuffling -- still fast enough that almost nobody cares.
+//! Also, these implementations do not heap allocate.
+//!
+//! # Panics
+//!
+//! If length calculations result in overflowing `usize`, a panic will result.
+//!
+//! The `_slice` flavors of encode or decode will panic if the provided output slice is too small,
+
+#![cfg_attr(feature = "cargo-clippy", allow(clippy::cast_lossless))]
+#![deny(
+    missing_docs,
+    trivial_casts,
+    trivial_numeric_casts,
+    unused_extern_crates,
+    unused_import_braces,
+    unused_results,
+    variant_size_differences,
+    warnings
+)]
+#![forbid(unsafe_code)]
+#![cfg_attr(not(any(feature = "std", test)), no_std)]
+
+#[cfg(all(feature = "alloc", not(any(feature = "std", test))))]
+extern crate alloc;
+#[cfg(any(feature = "std", test))]
+extern crate std as alloc;
+
+mod chunked_encoder;
+pub mod display;
+#[cfg(any(feature = "std", test))]
+pub mod read;
+mod tables;
+#[cfg(any(feature = "std", test))]
+pub mod write;
+
+mod encode;
+pub use crate::encode::encode_config_slice;
+#[cfg(any(feature = "alloc", feature = "std", test))]
+pub use crate::encode::{encode, encode_config, encode_config_buf};
+
+mod decode;
+#[cfg(any(feature = "alloc", feature = "std", test))]
+pub use crate::decode::{decode, decode_config, decode_config_buf};
+pub use crate::decode::{decode_config_slice, DecodeError};
+
+#[cfg(test)]
+mod tests;
+
+/// Available encoding character sets
+#[derive(Clone, Copy, Debug)]
+pub enum CharacterSet {
+    /// The standard character set (uses `+` and `/`).
+    ///
+    /// See [RFC 3548](https://tools.ietf.org/html/rfc3548#section-3).
+    Standard,
+    /// The URL safe character set (uses `-` and `_`).
+    ///
+    /// See [RFC 3548](https://tools.ietf.org/html/rfc3548#section-4).
+    UrlSafe,
+    /// The `crypt(3)` character set (uses `./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`).
+    ///
+    /// Not standardized, but folk wisdom on the net asserts that this alphabet is what crypt uses.
+    Crypt,
+    /// The bcrypt character set (uses `./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`).
+    Bcrypt,
+    /// The character set used in IMAP-modified UTF-7 (uses `+` and `,`).
+    ///
+    /// See [RFC 3501](https://tools.ietf.org/html/rfc3501#section-5.1.3)
+    ImapMutf7,
+    /// The character set used in BinHex 4.0 files.
+    ///
+    /// See [BinHex 4.0 Definition](http://files.stairways.com/other/binhex-40-specs-info.txt)
+    BinHex,
+}
+
+impl CharacterSet {
+    fn encode_table(self) -> &'static [u8; 64] {
+        match self {
+            CharacterSet::Standard => tables::STANDARD_ENCODE,
+            CharacterSet::UrlSafe => tables::URL_SAFE_ENCODE,
+            CharacterSet::Crypt => tables::CRYPT_ENCODE,
+            CharacterSet::Bcrypt => tables::BCRYPT_ENCODE,
+            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_ENCODE,
+            CharacterSet::BinHex => tables::BINHEX_ENCODE,
+        }
+    }
+
+    fn decode_table(self) -> &'static [u8; 256] {
+        match self {
+            CharacterSet::Standard => tables::STANDARD_DECODE,
+            CharacterSet::UrlSafe => tables::URL_SAFE_DECODE,
+            CharacterSet::Crypt => tables::CRYPT_DECODE,
+            CharacterSet::Bcrypt => tables::BCRYPT_DECODE,
+            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_DECODE,
+            CharacterSet::BinHex => tables::BINHEX_DECODE,
+        }
+    }
+}
+
+/// Contains configuration parameters for base64 encoding
+#[derive(Clone, Copy, Debug)]
+pub struct Config {
+    /// Character set to use
+    char_set: CharacterSet,
+    /// True to pad output with `=` characters
+    pad: bool,
+    /// True to ignore excess nonzero bits in the last few symbols, otherwise an error is returned.
+    decode_allow_trailing_bits: bool,
+}
+
+impl Config {
+    /// Create a new `Config`.
+    pub const fn new(char_set: CharacterSet, pad: bool) -> Config {
+        Config {
+            char_set,
+            pad,
+            decode_allow_trailing_bits: false,
+        }
+    }
+
+    /// Sets whether to pad output with `=` characters.
+    pub const fn pad(self, pad: bool) -> Config {
+        Config { pad, ..self }
+    }
+
+    /// Sets whether to emit errors for nonzero trailing bits.
+    ///
+    /// This is useful when implementing
+    /// [forgiving-base64 decode](https://infra.spec.whatwg.org/#forgiving-base64-decode).
+    pub const fn decode_allow_trailing_bits(self, allow: bool) -> Config {
+        Config {
+            decode_allow_trailing_bits: allow,
+            ..self
+        }
+    }
+}
+
+/// Standard character set with padding.
+pub const STANDARD: Config = Config {
+    char_set: CharacterSet::Standard,
+    pad: true,
+    decode_allow_trailing_bits: false,
+};
+
+/// Standard character set without padding.
+pub const STANDARD_NO_PAD: Config = Config {
+    char_set: CharacterSet::Standard,
+    pad: false,
+    decode_allow_trailing_bits: false,
+};
+
+/// URL-safe character set with padding
+pub const URL_SAFE: Config = Config {
+    char_set: CharacterSet::UrlSafe,
+    pad: true,
+    decode_allow_trailing_bits: false,
+};
+
+/// URL-safe character set without padding
+pub const URL_SAFE_NO_PAD: Config = Config {
+    char_set: CharacterSet::UrlSafe,
+    pad: false,
+    decode_allow_trailing_bits: false,
+};
+
+/// As per `crypt(3)` requirements
+pub const CRYPT: Config = Config {
+    char_set: CharacterSet::Crypt,
+    pad: false,
+    decode_allow_trailing_bits: false,
+};
+
+/// Bcrypt character set
+pub const BCRYPT: Config = Config {
+    char_set: CharacterSet::Bcrypt,
+    pad: false,
+    decode_allow_trailing_bits: false,
+};
+
+/// IMAP modified UTF-7 requirements
+pub const IMAP_MUTF7: Config = Config {
+    char_set: CharacterSet::ImapMutf7,
+    pad: false,
+    decode_allow_trailing_bits: false,
+};
+
+/// BinHex character set
+pub const BINHEX: Config = Config {
+    char_set: CharacterSet::BinHex,
+    pad: false,
+    decode_allow_trailing_bits: false,
+};
+
+const PAD_BYTE: u8 = b'=';
diff --git a/vendor/base64/src/read/decoder.rs b/vendor/base64/src/read/decoder.rs
new file mode 100644
index 000000000..7a9c4cd29
--- /dev/null
+++ b/vendor/base64/src/read/decoder.rs
@@ -0,0 +1,282 @@
+use crate::{decode_config_slice, Config, DecodeError};
+use std::io::Read;
+use std::{cmp, fmt, io};
+
+// This should be large, but it has to fit on the stack.
+pub(crate) const BUF_SIZE: usize = 1024;
+
+// 4 bytes of base64 data encode 3 bytes of raw data (modulo padding).
+const BASE64_CHUNK_SIZE: usize = 4;
+const DECODED_CHUNK_SIZE: usize = 3;
+
+/// A `Read` implementation that decodes base64 data read from an underlying reader.
+///
+/// # Examples
+///
+/// ```
+/// use std::io::Read;
+/// use std::io::Cursor;
+///
+/// // use a cursor as the simplest possible `Read` -- in real code this is probably a file, etc.
+/// let mut wrapped_reader = Cursor::new(b"YXNkZg==");
+/// let mut decoder = base64::read::DecoderReader::new(
+///     &mut wrapped_reader, base64::STANDARD);
+///
+/// // handle errors as you normally would
+/// let mut result = Vec::new();
+/// decoder.read_to_end(&mut result).unwrap();
+///
+/// assert_eq!(b"asdf", &result[..]);
+///
+/// ```
+pub struct DecoderReader<'a, R: 'a + io::Read> {
+    config: Config,
+    /// Where b64 data is read from
+    r: &'a mut R,
+
+    // Holds b64 data read from the delegate reader.
+    b64_buffer: [u8; BUF_SIZE],
+    // The start of the pending buffered data in b64_buffer.
+    b64_offset: usize,
+    // The amount of buffered b64 data.
+    b64_len: usize,
+    // Since the caller may provide us with a buffer of size 1 or 2 that's too small to copy a
+    // decoded chunk in to, we have to be able to hang on to a few decoded bytes.
+    // Technically we only need to hold 2 bytes but then we'd need a separate temporary buffer to
+    // decode 3 bytes into and then juggle copying one byte into the provided read buf and the rest
+    // into here, which seems like a lot of complexity for 1 extra byte of storage.
+    decoded_buffer: [u8; 3],
+    // index of start of decoded data
+    decoded_offset: usize,
+    // length of decoded data
+    decoded_len: usize,
+    // used to provide accurate offsets in errors
+    total_b64_decoded: usize,
+}
+
+impl<'a, R: io::Read> fmt::Debug for DecoderReader<'a, R> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        f.debug_struct("DecoderReader")
+            .field("config", &self.config)
+            .field("b64_offset", &self.b64_offset)
+            .field("b64_len", &self.b64_len)
+            .field("decoded_buffer", &self.decoded_buffer)
+            .field("decoded_offset", &self.decoded_offset)
+            .field("decoded_len", &self.decoded_len)
+            .field("total_b64_decoded", &self.total_b64_decoded)
+            .finish()
+    }
+}
+
+impl<'a, R: io::Read> DecoderReader<'a, R> {
+    /// Create a new decoder that will read from the provided reader `r`.
+    pub fn new(r: &'a mut R, config: Config) -> Self {
+        DecoderReader {
+            config,
+            r,
+            b64_buffer: [0; BUF_SIZE],
+            b64_offset: 0,
+            b64_len: 0,
+            decoded_buffer: [0; DECODED_CHUNK_SIZE],
+            decoded_offset: 0,
+            decoded_len: 0,
+            total_b64_decoded: 0,
+        }
+    }
+
+    /// Write as much as possible of the decoded buffer into the target buffer.
+    /// Must only be called when there is something to write and space to write into.
+    /// Returns a Result with the number of (decoded) bytes copied.
+    fn flush_decoded_buf(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+        debug_assert!(self.decoded_len > 0);
+        debug_assert!(buf.len() > 0);
+
+        let copy_len = cmp::min(self.decoded_len, buf.len());
+        debug_assert!(copy_len > 0);
+        debug_assert!(copy_len <= self.decoded_len);
+
+        buf[..copy_len].copy_from_slice(
+            &self.decoded_buffer[self.decoded_offset..self.decoded_offset + copy_len],
+        );
+
+        self.decoded_offset += copy_len;
+        self.decoded_len -= copy_len;
+
+        debug_assert!(self.decoded_len < DECODED_CHUNK_SIZE);
+
+        Ok(copy_len)
+    }
+
+    /// Read into the remaining space in the buffer after the current contents.
+    /// Must only be called when there is space to read into in the buffer.
+    /// Returns the number of bytes read.
+    fn read_from_delegate(&mut self) -> io::Result<usize> {
+        debug_assert!(self.b64_offset + self.b64_len < BUF_SIZE);
+
+        let read = self
+            .r
+            .read(&mut self.b64_buffer[self.b64_offset + self.b64_len..])?;
+        self.b64_len += read;
+
+        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);
+
+        return Ok(read);
+    }
+
+    /// Decode the requested number of bytes from the b64 buffer into the provided buffer. It's the
+    /// caller's responsibility to choose the number of b64 bytes to decode correctly.
+    ///
+    /// Returns a Result with the number of decoded bytes written to `buf`.
+    fn decode_to_buf(&mut self, num_bytes: usize, buf: &mut [u8]) -> io::Result<usize> {
+        debug_assert!(self.b64_len >= num_bytes);
+        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);
+        debug_assert!(buf.len() > 0);
+
+        let decoded = decode_config_slice(
+            &self.b64_buffer[self.b64_offset..self.b64_offset + num_bytes],
+            self.config,
+            &mut buf[..],
+        )
+        .map_err(|e| match e {
+            DecodeError::InvalidByte(offset, byte) => {
+                DecodeError::InvalidByte(self.total_b64_decoded + offset, byte)
+            }
+            DecodeError::InvalidLength => DecodeError::InvalidLength,
+            DecodeError::InvalidLastSymbol(offset, byte) => {
+                DecodeError::InvalidLastSymbol(self.total_b64_decoded + offset, byte)
+            }
+        })
+        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
+
+        self.total_b64_decoded += num_bytes;
+        self.b64_offset += num_bytes;
+        self.b64_len -= num_bytes;
+
+        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);
+
+        Ok(decoded)
+    }
+}
+
+impl<'a, R: Read> Read for DecoderReader<'a, R> {
+    /// Decode input from the wrapped reader.
+    ///
+    /// Under non-error circumstances, this returns `Ok` with the value being the number of bytes
+    /// written in `buf`.
+    ///
+    /// Where possible, this function buffers base64 to minimize the number of read() calls to the
+    /// delegate reader.
+    ///
+    /// # Errors
+    ///
+    /// Any errors emitted by the delegate reader are returned. Decoding errors due to invalid
+    /// base64 are also possible, and will have `io::ErrorKind::InvalidData`.
+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+        if buf.len() == 0 {
+            return Ok(0);
+        }
+
+        // offset == BUF_SIZE when we copied it all last time
+        debug_assert!(self.b64_offset <= BUF_SIZE);
+        debug_assert!(self.b64_offset + self.b64_len <= BUF_SIZE);
+        debug_assert!(if self.b64_offset == BUF_SIZE {
+            self.b64_len == 0
+        } else {
+            self.b64_len <= BUF_SIZE
+        });
+
+        debug_assert!(if self.decoded_len == 0 {
+            // can be = when we were able to copy the complete chunk
+            self.decoded_offset <= DECODED_CHUNK_SIZE
+        } else {
+            self.decoded_offset < DECODED_CHUNK_SIZE
+        });
+
+        // We shouldn't ever decode into here when we can't immediately write at least one byte into
+        // the provided buf, so the effective length should only be 3 momentarily between when we
+        // decode and when we copy into the target buffer.
+        debug_assert!(self.decoded_len < DECODED_CHUNK_SIZE);
+        debug_assert!(self.decoded_len + self.decoded_offset <= DECODED_CHUNK_SIZE);
+
+        if self.decoded_len > 0 {
+            // we have a few leftover decoded bytes; flush that rather than pull in more b64
+            self.flush_decoded_buf(buf)
+        } else {
+            let mut at_eof = false;
+            while self.b64_len < BASE64_CHUNK_SIZE {
+                // Work around lack of copy_within, which is only present in 1.37
+                // Copy any bytes we have to the start of the buffer.
+                // We know we have < 1 chunk, so we can use a tiny tmp buffer.
+                let mut memmove_buf = [0_u8; BASE64_CHUNK_SIZE];
+                memmove_buf[..self.b64_len].copy_from_slice(
+                    &self.b64_buffer[self.b64_offset..self.b64_offset + self.b64_len],
+                );
+                self.b64_buffer[0..self.b64_len].copy_from_slice(&memmove_buf[..self.b64_len]);
+                self.b64_offset = 0;
+
+                // then fill in more data
+                let read = self.read_from_delegate()?;
+                if read == 0 {
+                    // we never pass in an empty buf, so 0 => we've hit EOF
+                    at_eof = true;
+                    break;
+                }
+            }
+
+            if self.b64_len == 0 {
+                debug_assert!(at_eof);
+                // we must be at EOF, and we have no data left to decode
+                return Ok(0);
+            };
+
+            debug_assert!(if at_eof {
+                // if we are at eof, we may not have a complete chunk
+                self.b64_len > 0
+            } else {
+                // otherwise, we must have at least one chunk
+                self.b64_len >= BASE64_CHUNK_SIZE
+            });
+
+            debug_assert_eq!(0, self.decoded_len);
+
+            if buf.len() < DECODED_CHUNK_SIZE {
+                // caller requested an annoyingly short read
+                // have to write to a tmp buf first to avoid double mutable borrow
+                let mut decoded_chunk = [0_u8; DECODED_CHUNK_SIZE];
+                // if we are at eof, could have less than BASE64_CHUNK_SIZE, in which case we have
+                // to assume that these last few tokens are, in fact, valid (i.e. must be 2-4 b64
+                // tokens, not 1, since 1 token can't decode to 1 byte).
+                let to_decode = cmp::min(self.b64_len, BASE64_CHUNK_SIZE);
+
+                let decoded = self.decode_to_buf(to_decode, &mut decoded_chunk[..])?;
+                self.decoded_buffer[..decoded].copy_from_slice(&decoded_chunk[..decoded]);
+
+                self.decoded_offset = 0;
+                self.decoded_len = decoded;
+
+                // can be less than 3 on last block due to padding
+                debug_assert!(decoded <= 3);
+
+                self.flush_decoded_buf(buf)
+            } else {
+                let b64_bytes_that_can_decode_into_buf = (buf.len() / DECODED_CHUNK_SIZE)
+                    .checked_mul(BASE64_CHUNK_SIZE)
+                    .expect("too many chunks");
+                debug_assert!(b64_bytes_that_can_decode_into_buf >= BASE64_CHUNK_SIZE);
+
+                let b64_bytes_available_to_decode = if at_eof {
+                    self.b64_len
+                } else {
+                    // only use complete chunks
+                    self.b64_len - self.b64_len % 4
+                };
+
+                let actual_decode_len = cmp::min(
+                    b64_bytes_that_can_decode_into_buf,
+                    b64_bytes_available_to_decode,
+                );
+                self.decode_to_buf(actual_decode_len, buf)
+            }
+        }
+    }
+}
diff --git a/vendor/base64/src/read/decoder_tests.rs b/vendor/base64/src/read/decoder_tests.rs
new file mode 100644
index 000000000..265d423a6
--- /dev/null
+++ b/vendor/base64/src/read/decoder_tests.rs
@@ -0,0 +1,335 @@
+use std::io::{self, Read};
+
+use rand::{Rng, RngCore};
+use std::{cmp, iter};
+
+use super::decoder::{DecoderReader, BUF_SIZE};
+use crate::encode::encode_config_buf;
+use crate::tests::random_config;
+use crate::{decode_config_buf, DecodeError, STANDARD};
+
+#[test]
+fn simple() {
+    let tests: &[(&[u8], &[u8])] = &[
+        (&b"0"[..], &b"MA=="[..]),
+        (b"01", b"MDE="),
+        (b"012", b"MDEy"),
+        (b"0123", b"MDEyMw=="),
+        (b"01234", b"MDEyMzQ="),
+        (b"012345", b"MDEyMzQ1"),
+        (b"0123456", b"MDEyMzQ1Ng=="),
+        (b"01234567", b"MDEyMzQ1Njc="),
+        (b"012345678", b"MDEyMzQ1Njc4"),
+        (b"0123456789", b"MDEyMzQ1Njc4OQ=="),
+    ][..];
+
+    for (text_expected, base64data) in tests.iter() {
+        // Read n bytes at a time.
+        for n in 1..base64data.len() + 1 {
+            let mut wrapped_reader = io::Cursor::new(base64data);
+            let mut decoder = DecoderReader::new(&mut wrapped_reader, STANDARD);
+
+            // handle errors as you normally would
+            let mut text_got = Vec::new();
+            let mut buffer = vec![0u8; n];
+            while let Ok(read) = decoder.read(&mut buffer[..]) {
+                if read == 0 {
+                    break;
+                }
+                text_got.extend_from_slice(&buffer[..read]);
+            }
+
+            assert_eq!(
+                text_got,
+                *text_expected,
+                "\nGot: {}\nExpected: {}",
+                String::from_utf8_lossy(&text_got[..]),
+                String::from_utf8_lossy(text_expected)
+            );
+        }
+    }
+}
+
+// Make sure we error out on trailing junk.
+#[test]
+fn trailing_junk() {
+    let tests: &[&[u8]] = &[&b"MDEyMzQ1Njc4*!@#$%^&"[..], b"MDEyMzQ1Njc4OQ== "][..];
+
+    for base64data in tests.iter() {
+        // Read n bytes at a time.
+        for n in 1..base64data.len() + 1 {
+            let mut wrapped_reader = io::Cursor::new(base64data);
+            let mut decoder = DecoderReader::new(&mut wrapped_reader, STANDARD);
+
+            // handle errors as you normally would
+            let mut buffer = vec![0u8; n];
+            let mut saw_error = false;
+            loop {
+                match decoder.read(&mut buffer[..]) {
+                    Err(_) => {
+                        saw_error = true;
+                        break;
+                    }
+                    Ok(read) if read == 0 => break,
+                    Ok(_) => (),
+                }
+            }
+
+            assert!(saw_error);
+        }
+    }
+}
+
+#[test]
+fn handles_short_read_from_delegate() {
+    let mut rng = rand::thread_rng();
+    let mut bytes = Vec::new();
+    let mut b64 = String::new();
+    let mut decoded = Vec::new();
+
+    for _ in 0..10_000 {
+        bytes.clear();
+        b64.clear();
+        decoded.clear();
+
+        let size = rng.gen_range(0, 10 * BUF_SIZE);
+        bytes.extend(iter::repeat(0).take(size));
+        bytes.truncate(size);
+        rng.fill_bytes(&mut bytes[..size]);
+        assert_eq!(size, bytes.len());
+
+        let config = random_config(&mut rng);
+        encode_config_buf(&bytes[..], config, &mut b64);
+
+        let mut wrapped_reader = io::Cursor::new(b64.as_bytes());
+        let mut short_reader = RandomShortRead {
+            delegate: &mut wrapped_reader,
+            rng: &mut rng,
+        };
+
+        let mut decoder = DecoderReader::new(&mut short_reader, config);
+
+        let decoded_len = decoder.read_to_end(&mut decoded).unwrap();
+        assert_eq!(size, decoded_len);
+        assert_eq!(&bytes[..], &decoded[..]);
+    }
+}
+
+#[test]
+fn read_in_short_increments() {
+    let mut rng = rand::thread_rng();
+    let mut bytes = Vec::new();
+    let mut b64 = String::new();
+    let mut decoded = Vec::new();
+
+    for _ in 0..10_000 {
+        bytes.clear();
+        b64.clear();
+        decoded.clear();
+
+        let size = rng.gen_range(0, 10 * BUF_SIZE);
+        bytes.extend(iter::repeat(0).take(size));
+        // leave room to play around with larger buffers
+        decoded.extend(iter::repeat(0).take(size * 3));
+
+        rng.fill_bytes(&mut bytes[..]);
+        assert_eq!(size, bytes.len());
+
+        let config = random_config(&mut rng);
+
+        encode_config_buf(&bytes[..], config, &mut b64);
+
+        let mut wrapped_reader = io::Cursor::new(&b64[..]);
+        let mut decoder = DecoderReader::new(&mut wrapped_reader, config);
+
+        consume_with_short_reads_and_validate(&mut rng, &bytes[..], &mut decoded, &mut decoder);
+    }
+}
+
+#[test]
+fn read_in_short_increments_with_short_delegate_reads() {
+    let mut rng = rand::thread_rng();
+    let mut bytes = Vec::new();
+    let mut b64 = String::new();
+    let mut decoded = Vec::new();
+
+    for _ in 0..10_000 {
+        bytes.clear();
+        b64.clear();
+        decoded.clear();
+
+        let size = rng.gen_range(0, 10 * BUF_SIZE);
+        bytes.extend(iter::repeat(0).take(size));
+        // leave room to play around with larger buffers
+        decoded.extend(iter::repeat(0).take(size * 3));
+
+        rng.fill_bytes(&mut bytes[..]);
+        assert_eq!(size, bytes.len());
+
+        let config = random_config(&mut rng);
+
+        encode_config_buf(&bytes[..], config, &mut b64);
+
+        let mut base_reader = io::Cursor::new(&b64[..]);
+        let mut decoder = DecoderReader::new(&mut base_reader, config);
+        let mut short_reader = RandomShortRead {
+            delegate: &mut decoder,
+            rng: &mut rand::thread_rng(),
+        };
+
+        consume_with_short_reads_and_validate(&mut rng, &bytes[..], &mut decoded, &mut short_reader)
+    }
+}
+
+#[test]
+fn reports_invalid_last_symbol_correctly() {
+    let mut rng = rand::thread_rng();
+    let mut bytes = Vec::new();
+    let mut b64 = String::new();
+    let mut b64_bytes = Vec::new();
+    let mut decoded = Vec::new();
+    let mut bulk_decoded = Vec::new();
+
+    for _ in 0..1_000 {
+        bytes.clear();
+        b64.clear();
+        b64_bytes.clear();
+
+        let size = rng.gen_range(1, 10 * BUF_SIZE);
+        bytes.extend(iter::repeat(0).take(size));
+        decoded.extend(iter::repeat(0).take(size));
+        rng.fill_bytes(&mut bytes[..]);
+        assert_eq!(size, bytes.len());
+
+        let mut config = random_config(&mut rng);
+        // changing padding will cause invalid padding errors when we twiddle the last byte
+        config.pad = false;
+
+        encode_config_buf(&bytes[..], config, &mut b64);
+        b64_bytes.extend(b64.bytes());
+        assert_eq!(b64_bytes.len(), b64.len());
+
+        // change the last character to every possible symbol. Should behave the same as bulk
+        // decoding whether invalid or valid.
+        for &s1 in config.char_set.encode_table().iter() {
+            decoded.clear();
+            bulk_decoded.clear();
+
+            // replace the last
+            *b64_bytes.last_mut().unwrap() = s1;
+            let bulk_res = decode_config_buf(&b64_bytes[..], config, &mut bulk_decoded);
+
+            let mut wrapped_reader = io::Cursor::new(&b64_bytes[..]);
+            let mut decoder = DecoderReader::new(&mut wrapped_reader, config);
+
+            let stream_res = decoder.read_to_end(&mut decoded).map(|_| ()).map_err(|e| {
+                e.into_inner()
+                    .and_then(|e| e.downcast::<DecodeError>().ok())
+            });
+
+            assert_eq!(bulk_res.map_err(|e| Some(Box::new(e))), stream_res);
+        }
+    }
+}
+
+#[test]
+fn reports_invalid_byte_correctly() {
+    let mut rng = rand::thread_rng();
+    let mut bytes = Vec::new();
+    let mut b64 = String::new();
+    let mut decoded = Vec::new();
+
+    for _ in 0..10_000 {
+        bytes.clear();
+        b64.clear();
+        decoded.clear();
+
+        let size = rng.gen_range(1, 10 * BUF_SIZE);
+        bytes.extend(iter::repeat(0).take(size));
+        rng.fill_bytes(&mut bytes[..size]);
+        assert_eq!(size, bytes.len());
+
+        let config = random_config(&mut rng);
+        encode_config_buf(&bytes[..], config, &mut b64);
+        // replace one byte, somewhere, with '*', which is invalid
+        let bad_byte_pos = rng.gen_range(0, &b64.len());
+        let mut b64_bytes = b64.bytes().collect::<Vec<u8>>();
+        b64_bytes[bad_byte_pos] = b'*';
+
+        let mut wrapped_reader = io::Cursor::new(b64_bytes.clone());
+        let mut decoder = DecoderReader::new(&mut wrapped_reader, config);
+
+        // some gymnastics to avoid double-moving the io::Error, which is not Copy
+        let read_decode_err = decoder
+            .read_to_end(&mut decoded)
+            .map_err(|e| {
+                let kind = e.kind();
+                let inner = e
+                    .into_inner()
+                    .and_then(|e| e.downcast::<DecodeError>().ok());
+                inner.map(|i| (*i, kind))
+            })
+            .err()
+            .and_then(|o| o);
+
+        let mut bulk_buf = Vec::new();
+        let bulk_decode_err = decode_config_buf(&b64_bytes[..], config, &mut bulk_buf).err();
+
+        // it's tricky to predict where the invalid data's offset will be since if it's in the last
+        // chunk it will be reported at the first padding location because it's treated as invalid
+        // padding. So, we just check that it's the same as it is for decoding all at once.
+        assert_eq!(
+            bulk_decode_err.map(|e| (e, io::ErrorKind::InvalidData)),
+            read_decode_err
+        );
+    }
+}
+
+fn consume_with_short_reads_and_validate<R: Read>(
+    rng: &mut rand::rngs::ThreadRng,
+    expected_bytes: &[u8],
+    decoded: &mut Vec<u8>,
+    short_reader: &mut R,
+) -> () {
+    let mut total_read = 0_usize;
+    loop {
+        assert!(
+            total_read <= expected_bytes.len(),
+            "tr {} size {}",
+            total_read,
+            expected_bytes.len()
+        );
+        if total_read == expected_bytes.len() {
+            assert_eq!(expected_bytes, &decoded[..total_read]);
+            // should be done
+            assert_eq!(0, short_reader.read(&mut decoded[..]).unwrap());
+            // didn't write anything
+            assert_eq!(expected_bytes, &decoded[..total_read]);
+
+            break;
+        }
+        let decode_len = rng.gen_range(1, cmp::max(2, expected_bytes.len() * 2));
+
+        let read = short_reader
+            .read(&mut decoded[total_read..total_read + decode_len])
+            .unwrap();
+        total_read += read;
+    }
+}
+
+/// Limits how many bytes a reader will provide in each read call.
+/// Useful for shaking out code that may work fine only with typical input sources that always fill
+/// the buffer.
+struct RandomShortRead<'a, 'b, R: io::Read, N: rand::Rng> {
+    delegate: &'b mut R,
+    rng: &'a mut N,
+}
+
+impl<'a, 'b, R: io::Read, N: rand::Rng> io::Read for RandomShortRead<'a, 'b, R, N> {
+    fn read(&mut self, buf: &mut [u8]) -> Result<usize, io::Error> {
+        // avoid 0 since it means EOF for non-empty buffers
+        let effective_len = cmp::min(self.rng.gen_range(1, 20), buf.len());
+
+        self.delegate.read(&mut buf[..effective_len])
+    }
+}
diff --git a/vendor/base64/src/read/mod.rs b/vendor/base64/src/read/mod.rs
new file mode 100644
index 000000000..856064481
--- /dev/null
+++ b/vendor/base64/src/read/mod.rs
@@ -0,0 +1,6 @@
+//! Implementations of `io::Read` to transparently decode base64.
+mod decoder;
+pub use self::decoder::DecoderReader;
+
+#[cfg(test)]
+mod decoder_tests;
diff --git a/vendor/base64/src/tables.rs b/vendor/base64/src/tables.rs
new file mode 100644
index 000000000..a45851cd2
--- /dev/null
+++ b/vendor/base64/src/tables.rs
@@ -0,0 +1,1957 @@
+pub const INVALID_VALUE: u8 = 255;
+#[rustfmt::skip]
+pub const STANDARD_ENCODE: &[u8; 64] = &[
+    65, // input 0 (0x0) => 'A' (0x41)
+    66, // input 1 (0x1) => 'B' (0x42)
+    67, // input 2 (0x2) => 'C' (0x43)
+    68, // input 3 (0x3) => 'D' (0x44)
+    69, // input 4 (0x4) => 'E' (0x45)
+    70, // input 5 (0x5) => 'F' (0x46)
+    71, // input 6 (0x6) => 'G' (0x47)
+    72, // input 7 (0x7) => 'H' (0x48)
+    73, // input 8 (0x8) => 'I' (0x49)
+    74, // input 9 (0x9) => 'J' (0x4A)
+    75, // input 10 (0xA) => 'K' (0x4B)
+    76, // input 11 (0xB) => 'L' (0x4C)
+    77, // input 12 (0xC) => 'M' (0x4D)
+    78, // input 13 (0xD) => 'N' (0x4E)
+    79, // input 14 (0xE) => 'O' (0x4F)
+    80, // input 15 (0xF) => 'P' (0x50)
+    81, // input 16 (0x10) => 'Q' (0x51)
+    82, // input 17 (0x11) => 'R' (0x52)
+    83, // input 18 (0x12) => 'S' (0x53)
+    84, // input 19 (0x13) => 'T' (0x54)
+    85, // input 20 (0x14) => 'U' (0x55)
+    86, // input 21 (0x15) => 'V' (0x56)
+    87, // input 22 (0x16) => 'W' (0x57)
+    88, // input 23 (0x17) => 'X' (0x58)
+    89, // input 24 (0x18) => 'Y' (0x59)
+    90, // input 25 (0x19) => 'Z' (0x5A)
+    97, // input 26 (0x1A) => 'a' (0x61)
+    98, // input 27 (0x1B) => 'b' (0x62)
+    99, // input 28 (0x1C) => 'c' (0x63)
+    100, // input 29 (0x1D) => 'd' (0x64)
+    101, // input 30 (0x1E) => 'e' (0x65)
+    102, // input 31 (0x1F) => 'f' (0x66)
+    103, // input 32 (0x20) => 'g' (0x67)
+    104, // input 33 (0x21) => 'h' (0x68)
+    105, // input 34 (0x22) => 'i' (0x69)
+    106, // input 35 (0x23) => 'j' (0x6A)
+    107, // input 36 (0x24) => 'k' (0x6B)
+    108, // input 37 (0x25) => 'l' (0x6C)
+    109, // input 38 (0x26) => 'm' (0x6D)
+    110, // input 39 (0x27) => 'n' (0x6E)
+    111, // input 40 (0x28) => 'o' (0x6F)
+    112, // input 41 (0x29) => 'p' (0x70)
+    113, // input 42 (0x2A) => 'q' (0x71)
+    114, // input 43 (0x2B) => 'r' (0x72)
+    115, // input 44 (0x2C) => 's' (0x73)
+    116, // input 45 (0x2D) => 't' (0x74)
+    117, // input 46 (0x2E) => 'u' (0x75)
+    118, // input 47 (0x2F) => 'v' (0x76)
+    119, // input 48 (0x30) => 'w' (0x77)
+    120, // input 49 (0x31) => 'x' (0x78)
+    121, // input 50 (0x32) => 'y' (0x79)
+    122, // input 51 (0x33) => 'z' (0x7A)
+    48, // input 52 (0x34) => '0' (0x30)
+    49, // input 53 (0x35) => '1' (0x31)
+    50, // input 54 (0x36) => '2' (0x32)
+    51, // input 55 (0x37) => '3' (0x33)
+    52, // input 56 (0x38) => '4' (0x34)
+    53, // input 57 (0x39) => '5' (0x35)
+    54, // input 58 (0x3A) => '6' (0x36)
+    55, // input 59 (0x3B) => '7' (0x37)
+    56, // input 60 (0x3C) => '8' (0x38)
+    57, // input 61 (0x3D) => '9' (0x39)
+    43, // input 62 (0x3E) => '+' (0x2B)
+    47, // input 63 (0x3F) => '/' (0x2F)
+];
+#[rustfmt::skip]
+pub const STANDARD_DECODE: &[u8; 256] = &[
+    INVALID_VALUE, // input 0 (0x0)
+    INVALID_VALUE, // input 1 (0x1)
+    INVALID_VALUE, // input 2 (0x2)
+    INVALID_VALUE, // input 3 (0x3)
+    INVALID_VALUE, // input 4 (0x4)
+    INVALID_VALUE, // input 5 (0x5)
+    INVALID_VALUE, // input 6 (0x6)
+    INVALID_VALUE, // input 7 (0x7)
+    INVALID_VALUE, // input 8 (0x8)
+    INVALID_VALUE, // input 9 (0x9)
+    INVALID_VALUE, // input 10 (0xA)
+    INVALID_VALUE, // input 11 (0xB)
+    INVALID_VALUE, // input 12 (0xC)
+    INVALID_VALUE, // input 13 (0xD)
+    INVALID_VALUE, // input 14 (0xE)
+    INVALID_VALUE, // input 15 (0xF)
+    INVALID_VALUE, // input 16 (0x10)
+    INVALID_VALUE, // input 17 (0x11)
+    INVALID_VALUE, // input 18 (0x12)
+    INVALID_VALUE, // input 19 (0x13)
+    INVALID_VALUE, // input 20 (0x14)
+    INVALID_VALUE, // input 21 (0x15)
+    INVALID_VALUE, // input 22 (0x16)
+    INVALID_VALUE, // input 23 (0x17)
+    INVALID_VALUE, // input 24 (0x18)
+    INVALID_VALUE, // input 25 (0x19)
+    INVALID_VALUE, // input 26 (0x1A)
+    INVALID_VALUE, // input 27 (0x1B)
+    INVALID_VALUE, // input 28 (0x1C)
+    INVALID_VALUE, // input 29 (0x1D)
+    INVALID_VALUE, // input 30 (0x1E)
+    INVALID_VALUE, // input 31 (0x1F)
+    INVALID_VALUE, // input 32 (0x20)
+    INVALID_VALUE, // input 33 (0x21)
+    INVALID_VALUE, // input 34 (0x22)
+    INVALID_VALUE, // input 35 (0x23)
+    INVALID_VALUE, // input 36 (0x24)
+    INVALID_VALUE, // input 37 (0x25)
+    INVALID_VALUE, // input 38 (0x26)
+    INVALID_VALUE, // input 39 (0x27)
+    INVALID_VALUE, // input 40 (0x28)
+    INVALID_VALUE, // input 41 (0x29)
+    INVALID_VALUE, // input 42 (0x2A)
+    62, // input 43 (0x2B char '+') => 62 (0x3E)
+    INVALID_VALUE, // input 44 (0x2C)
+    INVALID_VALUE, // input 45 (0x2D)
+    INVALID_VALUE, // input 46 (0x2E)
+    63, // input 47 (0x2F char '/') => 63 (0x3F)
+    52, // input 48 (0x30 char '0') => 52 (0x34)
+    53, // input 49 (0x31 char '1') => 53 (0x35)
+    54, // input 50 (0x32 char '2') => 54 (0x36)
+    55, // input 51 (0x33 char '3') => 55 (0x37)
+    56, // input 52 (0x34 char '4') => 56 (0x38)
+    57, // input 53 (0x35 char '5') => 57 (0x39)
+    58, // input 54 (0x36 char '6') => 58 (0x3A)
+    59, // input 55 (0x37 char '7') => 59 (0x3B)
+    60, // input 56 (0x38 char '8') => 60 (0x3C)
+    61, // input 57 (0x39 char '9') => 61 (0x3D)
+    INVALID_VALUE, // input 58 (0x3A)
+    INVALID_VALUE, // input 59 (0x3B)
+    INVALID_VALUE, // input 60 (0x3C)
+    INVALID_VALUE, // input 61 (0x3D)
+    INVALID_VALUE, // input 62 (0x3E)
+    INVALID_VALUE, // input 63 (0x3F)
+    INVALID_VALUE, // input 64 (0x40)
+    0, // input 65 (0x41 char 'A') => 0 (0x0)
+    1, // input 66 (0x42 char 'B') => 1 (0x1)
+    2, // input 67 (0x43 char 'C') => 2 (0x2)
+    3, // input 68 (0x44 char 'D') => 3 (0x3)
+    4, // input 69 (0x45 char 'E') => 4 (0x4)
+    5, // input 70 (0x46 char 'F') => 5 (0x5)
+    6, // input 71 (0x47 char 'G') => 6 (0x6)
+    7, // input 72 (0x48 char 'H') => 7 (0x7)
+    8, // input 73 (0x49 char 'I') => 8 (0x8)
+    9, // input 74 (0x4A char 'J') => 9 (0x9)
+    10, // input 75 (0x4B char 'K') => 10 (0xA)
+    11, // input 76 (0x4C char 'L') => 11 (0xB)
+    12, // input 77 (0x4D char 'M') => 12 (0xC)
+    13, // input 78 (0x4E char 'N') => 13 (0xD)
+    14, // input 79 (0x4F char 'O') => 14 (0xE)
+    15, // input 80 (0x50 char 'P') => 15 (0xF)
+    16, // input 81 (0x51 char 'Q') => 16 (0x10)
+    17, // input 82 (0x52 char 'R') => 17 (0x11)
+    18, // input 83 (0x53 char 'S') => 18 (0x12)
+    19, // input 84 (0x54 char 'T') => 19 (0x13)
+    20, // input 85 (0x55 char 'U') => 20 (0x14)
+    21, // input 86 (0x56 char 'V') => 21 (0x15)
+    22, // input 87 (0x57 char 'W') => 22 (0x16)
+    23, // input 88 (0x58 char 'X') => 23 (0x17)
+    24, // input 89 (0x59 char 'Y') => 24 (0x18)
+    25, // input 90 (0x5A char 'Z') => 25 (0x19)
+    INVALID_VALUE, // input 91 (0x5B)
+    INVALID_VALUE, // input 92 (0x5C)
+    INVALID_VALUE, // input 93 (0x5D)
+    INVALID_VALUE, // input 94 (0x5E)
+    INVALID_VALUE, // input 95 (0x5F)
+    INVALID_VALUE, // input 96 (0x60)
+    26, // input 97 (0x61 char 'a') => 26 (0x1A)
+    27, // input 98 (0x62 char 'b') => 27 (0x1B)
+    28, // input 99 (0x63 char 'c') => 28 (0x1C)
+    29, // input 100 (0x64 char 'd') => 29 (0x1D)
+    30, // input 101 (0x65 char 'e') => 30 (0x1E)
+    31, // input 102 (0x66 char 'f') => 31 (0x1F)
+    32, // input 103 (0x67 char 'g') => 32 (0x20)
+    33, // input 104 (0x68 char 'h') => 33 (0x21)
+    34, // input 105 (0x69 char 'i') => 34 (0x22)
+    35, // input 106 (0x6A char 'j') => 35 (0x23)
+    36, // input 107 (0x6B char 'k') => 36 (0x24)
+    37, // input 108 (0x6C char 'l') => 37 (0x25)
+    38, // input 109 (0x6D char 'm') => 38 (0x26)
+    39, // input 110 (0x6E char 'n') => 39 (0x27)
+    40, // input 111 (0x6F char 'o') => 40 (0x28)
+    41, // input 112 (0x70 char 'p') => 41 (0x29)
+    42, // input 113 (0x71 char 'q') => 42 (0x2A)
+    43, // input 114 (0x72 char 'r') => 43 (0x2B)
+    44, // input 115 (0x73 char 's') => 44 (0x2C)
+    45, // input 116 (0x74 char 't') => 45 (0x2D)
+    46, // input 117 (0x75 char 'u') => 46 (0x2E)
+    47, // input 118 (0x76 char 'v') => 47 (0x2F)
+    48, // input 119 (0x77 char 'w') => 48 (0x30)
+    49, // input 120 (0x78 char 'x') => 49 (0x31)
+    50, // input 121 (0x79 char 'y') => 50 (0x32)
+    51, // input 122 (0x7A char 'z') => 51 (0x33)
+    INVALID_VALUE, // input 123 (0x7B)
+    INVALID_VALUE, // input 124 (0x7C)
+    INVALID_VALUE, // input 125 (0x7D)
+    INVALID_VALUE, // input 126 (0x7E)
+    INVALID_VALUE, // input 127 (0x7F)
+    INVALID_VALUE, // input 128 (0x80)
+    INVALID_VALUE, // input 129 (0x81)
+    INVALID_VALUE, // input 130 (0x82)
+    INVALID_VALUE, // input 131 (0x83)
+    INVALID_VALUE, // input 132 (0x84)
+    INVALID_VALUE, // input 133 (0x85)
+    INVALID_VALUE, // input 134 (0x86)
+    INVALID_VALUE, // input 135 (0x87)
+    INVALID_VALUE, // input 136 (0x88)
+    INVALID_VALUE, // input 137 (0x89)
+    INVALID_VALUE, // input 138 (0x8A)
+    INVALID_VALUE, // input 139 (0x8B)
+    INVALID_VALUE, // input 140 (0x8C)
+    INVALID_VALUE, // input 141 (0x8D)
+    INVALID_VALUE, // input 142 (0x8E)
+    INVALID_VALUE, // input 143 (0x8F)
+    INVALID_VALUE, // input 144 (0x90)
+    INVALID_VALUE, // input 145 (0x91)
+    INVALID_VALUE, // input 146 (0x92)
+    INVALID_VALUE, // input 147 (0x93)
+    INVALID_VALUE, // input 148 (0x94)
+    INVALID_VALUE, // input 149 (0x95)
+    INVALID_VALUE, // input 150 (0x96)
+    INVALID_VALUE, // input 151 (0x97)
+    INVALID_VALUE, // input 152 (0x98)
+    INVALID_VALUE, // input 153 (0x99)
+    INVALID_VALUE, // input 154 (0x9A)
+    INVALID_VALUE, // input 155 (0x9B)
+    INVALID_VALUE, // input 156 (0x9C)
+    INVALID_VALUE, // input 157 (0x9D)
+    INVALID_VALUE, // input 158 (0x9E)
+    INVALID_VALUE, // input 159 (0x9F)
+    INVALID_VALUE, // input 160 (0xA0)
+    INVALID_VALUE, // input 161 (0xA1)
+    INVALID_VALUE, // input 162 (0xA2)
+    INVALID_VALUE, // input 163 (0xA3)
+    INVALID_VALUE, // input 164 (0xA4)
+    INVALID_VALUE, // input 165 (0xA5)
+    INVALID_VALUE, // input 166 (0xA6)
+    INVALID_VALUE, // input 167 (0xA7)
+    INVALID_VALUE, // input 168 (0xA8)
+    INVALID_VALUE, // input 169 (0xA9)
+    INVALID_VALUE, // input 170 (0xAA)
+    INVALID_VALUE, // input 171 (0xAB)
+    INVALID_VALUE, // input 172 (0xAC)
+    INVALID_VALUE, // input 173 (0xAD)
+    INVALID_VALUE, // input 174 (0xAE)
+    INVALID_VALUE, // input 175 (0xAF)
+    INVALID_VALUE, // input 176 (0xB0)
+    INVALID_VALUE, // input 177 (0xB1)
+    INVALID_VALUE, // input 178 (0xB2)
+    INVALID_VALUE, // input 179 (0xB3)
+    INVALID_VALUE, // input 180 (0xB4)
+    INVALID_VALUE, // input 181 (0xB5)
+    INVALID_VALUE, // input 182 (0xB6)
+    INVALID_VALUE, // input 183 (0xB7)
+    INVALID_VALUE, // input 184 (0xB8)
+    INVALID_VALUE, // input 185 (0xB9)
+    INVALID_VALUE, // input 186 (0xBA)
+    INVALID_VALUE, // input 187 (0xBB)
+    INVALID_VALUE, // input 188 (0xBC)
+    INVALID_VALUE, // input 189 (0xBD)
+    INVALID_VALUE, // input 190 (0xBE)
+    INVALID_VALUE, // input 191 (0xBF)
+    INVALID_VALUE, // input 192 (0xC0)
+    INVALID_VALUE, // input 193 (0xC1)
+    INVALID_VALUE, // input 194 (0xC2)
+    INVALID_VALUE, // input 195 (0xC3)
+    INVALID_VALUE, // input 196 (0xC4)
+    INVALID_VALUE, // input 197 (0xC5)
+    INVALID_VALUE, // input 198 (0xC6)
+    INVALID_VALUE, // input 199 (0xC7)
+    INVALID_VALUE, // input 200 (0xC8)
+    INVALID_VALUE, // input 201 (0xC9)
+    INVALID_VALUE, // input 202 (0xCA)
+    INVALID_VALUE, // input 203 (0xCB)
+    INVALID_VALUE, // input 204 (0xCC)
+    INVALID_VALUE, // input 205 (0xCD)
+    INVALID_VALUE, // input 206 (0xCE)
+    INVALID_VALUE, // input 207 (0xCF)
+    INVALID_VALUE, // input 208 (0xD0)
+    INVALID_VALUE, // input 209 (0xD1)
+    INVALID_VALUE, // input 210 (0xD2)
+    INVALID_VALUE, // input 211 (0xD3)
+    INVALID_VALUE, // input 212 (0xD4)
+    INVALID_VALUE, // input 213 (0xD5)
+    INVALID_VALUE, // input 214 (0xD6)
+    INVALID_VALUE, // input 215 (0xD7)
+    INVALID_VALUE, // input 216 (0xD8)
+    INVALID_VALUE, // input 217 (0xD9)
+    INVALID_VALUE, // input 218 (0xDA)
+    INVALID_VALUE, // input 219 (0xDB)
+    INVALID_VALUE, // input 220 (0xDC)
+    INVALID_VALUE, // input 221 (0xDD)
+    INVALID_VALUE, // input 222 (0xDE)
+    INVALID_VALUE, // input 223 (0xDF)
+    INVALID_VALUE, // input 224 (0xE0)
+    INVALID_VALUE, // input 225 (0xE1)
+    INVALID_VALUE, // input 226 (0xE2)
+    INVALID_VALUE, // input 227 (0xE3)
+    INVALID_VALUE, // input 228 (0xE4)
+    INVALID_VALUE, // input 229 (0xE5)
+    INVALID_VALUE, // input 230 (0xE6)
+    INVALID_VALUE, // input 231 (0xE7)
+    INVALID_VALUE, // input 232 (0xE8)
+    INVALID_VALUE, // input 233 (0xE9)
+    INVALID_VALUE, // input 234 (0xEA)
+    INVALID_VALUE, // input 235 (0xEB)
+    INVALID_VALUE, // input 236 (0xEC)
+    INVALID_VALUE, // input 237 (0xED)
+    INVALID_VALUE, // input 238 (0xEE)
+    INVALID_VALUE, // input 239 (0xEF)
+    INVALID_VALUE, // input 240 (0xF0)
+    INVALID_VALUE, // input 241 (0xF1)
+    INVALID_VALUE, // input 242 (0xF2)
+    INVALID_VALUE, // input 243 (0xF3)
+    INVALID_VALUE, // input 244 (0xF4)
+    INVALID_VALUE, // input 245 (0xF5)
+    INVALID_VALUE, // input 246 (0xF6)
+    INVALID_VALUE, // input 247 (0xF7)
+    INVALID_VALUE, // input 248 (0xF8)
+    INVALID_VALUE, // input 249 (0xF9)
+    INVALID_VALUE, // input 250 (0xFA)
+    INVALID_VALUE, // input 251 (0xFB)
+    INVALID_VALUE, // input 252 (0xFC)
+    INVALID_VALUE, // input 253 (0xFD)
+    INVALID_VALUE, // input 254 (0xFE)
+    INVALID_VALUE, // input 255 (0xFF)
+];
+#[rustfmt::skip]
+pub const URL_SAFE_ENCODE: &[u8; 64] = &[
+    65, // input 0 (0x0) => 'A' (0x41)
+    66, // input 1 (0x1) => 'B' (0x42)
+    67, // input 2 (0x2) => 'C' (0x43)
+    68, // input 3 (0x3) => 'D' (0x44)
+    69, // input 4 (0x4) => 'E' (0x45)
+    70, // input 5 (0x5) => 'F' (0x46)
+    71, // input 6 (0x6) => 'G' (0x47)
+    72, // input 7 (0x7) => 'H' (0x48)
+    73, // input 8 (0x8) => 'I' (0x49)
+    74, // input 9 (0x9) => 'J' (0x4A)
+    75, // input 10 (0xA) => 'K' (0x4B)
+    76, // input 11 (0xB) => 'L' (0x4C)
+    77, // input 12 (0xC) => 'M' (0x4D)
+    78, // input 13 (0xD) => 'N' (0x4E)
+    79, // input 14 (0xE) => 'O' (0x4F)
+    80, // input 15 (0xF) => 'P' (0x50)
+    81, // input 16 (0x10) => 'Q' (0x51)
+    82, // input 17 (0x11) => 'R' (0x52)
+    83, // input 18 (0x12) => 'S' (0x53)
+    84, // input 19 (0x13) => 'T' (0x54)
+    85, // input 20 (0x14) => 'U' (0x55)
+    86, // input 21 (0x15) => 'V' (0x56)
+    87, // input 22 (0x16) => 'W' (0x57)
+    88, // input 23 (0x17) => 'X' (0x58)
+    89, // input 24 (0x18) => 'Y' (0x59)
+    90, // input 25 (0x19) => 'Z' (0x5A)
+    97, // input 26 (0x1A) => 'a' (0x61)
+    98, // input 27 (0x1B) => 'b' (0x62)
+    99, // input 28 (0x1C) => 'c' (0x63)
+    100, // input 29 (0x1D) => 'd' (0x64)
+    101, // input 30 (0x1E) => 'e' (0x65)
+    102, // input 31 (0x1F) => 'f' (0x66)
+    103, // input 32 (0x20) => 'g' (0x67)
+    104, // input 33 (0x21) => 'h' (0x68)
+    105, // input 34 (0x22) => 'i' (0x69)
+    106, // input 35 (0x23) => 'j' (0x6A)
+    107, // input 36 (0x24) => 'k' (0x6B)
+    108, // input 37 (0x25) => 'l' (0x6C)
+    109, // input 38 (0x26) => 'm' (0x6D)
+    110, // input 39 (0x27) => 'n' (0x6E)
+    111, // input 40 (0x28) => 'o' (0x6F)
+    112, // input 41 (0x29) => 'p' (0x70)
+    113, // input 42 (0x2A) => 'q' (0x71)
+    114, // input 43 (0x2B) => 'r' (0x72)
+    115, // input 44 (0x2C) => 's' (0x73)
+    116, // input 45 (0x2D) => 't' (0x74)
+    117, // input 46 (0x2E) => 'u' (0x75)
+    118, // input 47 (0x2F) => 'v' (0x76)
+    119, // input 48 (0x30) => 'w' (0x77)
+    120, // input 49 (0x31) => 'x' (0x78)
+    121, // input 50 (0x32) => 'y' (0x79)
+    122, // input 51 (0x33) => 'z' (0x7A)
+    48, // input 52 (0x34) => '0' (0x30)
+    49, // input 53 (0x35) => '1' (0x31)
+    50, // input 54 (0x36) => '2' (0x32)
+    51, // input 55 (0x37) => '3' (0x33)
+    52, // input 56 (0x38) => '4' (0x34)
+    53, // input 57 (0x39) => '5' (0x35)
+    54, // input 58 (0x3A) => '6' (0x36)
+    55, // input 59 (0x3B) => '7' (0x37)
+    56, // input 60 (0x3C) => '8' (0x38)
+    57, // input 61 (0x3D) => '9' (0x39)
+    45, // input 62 (0x3E) => '-' (0x2D)
+    95, // input 63 (0x3F) => '_' (0x5F)
+];
+#[rustfmt::skip]
+pub const URL_SAFE_DECODE: &[u8; 256] = &[
+    INVALID_VALUE, // input 0 (0x0)
+    INVALID_VALUE, // input 1 (0x1)
+    INVALID_VALUE, // input 2 (0x2)
+    INVALID_VALUE, // input 3 (0x3)
+    INVALID_VALUE, // input 4 (0x4)
+    INVALID_VALUE, // input 5 (0x5)
+    INVALID_VALUE, // input 6 (0x6)
+    INVALID_VALUE, // input 7 (0x7)
+    INVALID_VALUE, // input 8 (0x8)
+    INVALID_VALUE, // input 9 (0x9)
+    INVALID_VALUE, // input 10 (0xA)
+    INVALID_VALUE, // input 11 (0xB)
+    INVALID_VALUE, // input 12 (0xC)
+    INVALID_VALUE, // input 13 (0xD)
+    INVALID_VALUE, // input 14 (0xE)
+    INVALID_VALUE, // input 15 (0xF)
+    INVALID_VALUE, // input 16 (0x10)
+    INVALID_VALUE, // input 17 (0x11)
+    INVALID_VALUE, // input 18 (0x12)
+    INVALID_VALUE, // input 19 (0x13)
+    INVALID_VALUE, // input 20 (0x14)
+    INVALID_VALUE, // input 21 (0x15)
+    INVALID_VALUE, // input 22 (0x16)
+    INVALID_VALUE, // input 23 (0x17)
+    INVALID_VALUE, // input 24 (0x18)
+    INVALID_VALUE, // input 25 (0x19)
+    INVALID_VALUE, // input 26 (0x1A)
+    INVALID_VALUE, // input 27 (0x1B)
+    INVALID_VALUE, // input 28 (0x1C)
+    INVALID_VALUE, // input 29 (0x1D)
+    INVALID_VALUE, // input 30 (0x1E)
+    INVALID_VALUE, // input 31 (0x1F)
+    INVALID_VALUE, // input 32 (0x20)
+    INVALID_VALUE, // input 33 (0x21)
+    INVALID_VALUE, // input 34 (0x22)
+    INVALID_VALUE, // input 35 (0x23)
+    INVALID_VALUE, // input 36 (0x24)
+    INVALID_VALUE, // input 37 (0x25)
+    INVALID_VALUE, // input 38 (0x26)
+    INVALID_VALUE, // input 39 (0x27)
+    INVALID_VALUE, // input 40 (0x28)
+    INVALID_VALUE, // input 41 (0x29)
+    INVALID_VALUE, // input 42 (0x2A)
+    INVALID_VALUE, // input 43 (0x2B)
+    INVALID_VALUE, // input 44 (0x2C)
+    62, // input 45 (0x2D char '-') => 62 (0x3E)
+    INVALID_VALUE, // input 46 (0x2E)
+    INVALID_VALUE, // input 47 (0x2F)
+    52, // input 48 (0x30 char '0') => 52 (0x34)
+    53, // input 49 (0x31 char '1') => 53 (0x35)
+    54, // input 50 (0x32 char '2') => 54 (0x36)
+    55, // input 51 (0x33 char '3') => 55 (0x37)
+    56, // input 52 (0x34 char '4') => 56 (0x38)
+    57, // input 53 (0x35 char '5') => 57 (0x39)
+    58, // input 54 (0x36 char '6') => 58 (0x3A)
+    59, // input 55 (0x37 char '7') => 59 (0x3B)
+    60, // input 56 (0x38 char '8') => 60 (0x3C)
+    61, // input 57 (0x39 char '9') => 61 (0x3D)
+    INVALID_VALUE, // input 58 (0x3A)
+    INVALID_VALUE, // input 59 (0x3B)
+    INVALID_VALUE, // input 60 (0x3C)
+    INVALID_VALUE, // input 61 (0x3D)
+    INVALID_VALUE, // input 62 (0x3E)
+    INVALID_VALUE, // input 63 (0x3F)
+    INVALID_VALUE, // input 64 (0x40)
+    0, // input 65 (0x41 char 'A') => 0 (0x0)
+    1, // input 66 (0x42 char 'B') => 1 (0x1)
+    2, // input 67 (0x43 char 'C') => 2 (0x2)
+    3, // input 68 (0x44 char 'D') => 3 (0x3)
+    4, // input 69 (0x45 char 'E') => 4 (0x4)
+    5, // input 70 (0x46 char 'F') => 5 (0x5)
+    6, // input 71 (0x47 char 'G') => 6 (0x6)
+    7, // input 72 (0x48 char 'H') => 7 (0x7)
+    8, // input 73 (0x49 char 'I') => 8 (0x8)
+    9, // input 74 (0x4A char 'J') => 9 (0x9)
+    10, // input 75 (0x4B char 'K') => 10 (0xA)
+    11, // input 76 (0x4C char 'L') => 11 (0xB)
+    12, // input 77 (0x4D char 'M') => 12 (0xC)
+    13, // input 78 (0x4E char 'N') => 13 (0xD)
+    14, // input 79 (0x4F char 'O') => 14 (0xE)
+    15, // input 80 (0x50 char 'P') => 15 (0xF)
+    16, // input 81 (0x51 char 'Q') => 16 (0x10)
+    17, // input 82 (0x52 char 'R') => 17 (0x11)
+    18, // input 83 (0x53 char 'S') => 18 (0x12)
+    19, // input 84 (0x54 char 'T') => 19 (0x13)
+    20, // input 85 (0x55 char 'U') => 20 (0x14)
+    21, // input 86 (0x56 char 'V') => 21 (0x15)
+    22, // input 87 (0x57 char 'W') => 22 (0x16)
+    23, // input 88 (0x58 char 'X') => 23 (0x17)
+    24, // input 89 (0x59 char 'Y') => 24 (0x18)
+    25, // input 90 (0x5A char 'Z') => 25 (0x19)
+    INVALID_VALUE, // input 91 (0x5B)
+    INVALID_VALUE, // input 92 (0x5C)
+    INVALID_VALUE, // input 93 (0x5D)
+    INVALID_VALUE, // input 94 (0x5E)
+    63, // input 95 (0x5F char '_') => 63 (0x3F)
+    INVALID_VALUE, // input 96 (0x60)
+    26, // input 97 (0x61 char 'a') => 26 (0x1A)
+    27, // input 98 (0x62 char 'b') => 27 (0x1B)
+    28, // input 99 (0x63 char 'c') => 28 (0x1C)
+    29, // input 100 (0x64 char 'd') => 29 (0x1D)
+    30, // input 101 (0x65 char 'e') => 30 (0x1E)
+    31, // input 102 (0x66 char 'f') => 31 (0x1F)
+    32, // input 103 (0x67 char 'g') => 32 (0x20)
+    33, // input 104 (0x68 char 'h') => 33 (0x21)
+    34, // input 105 (0x69 char 'i') => 34 (0x22)
+    35, // input 106 (0x6A char 'j') => 35 (0x23)
+    36, // input 107 (0x6B char 'k') => 36 (0x24)
+    37, // input 108 (0x6C char 'l') => 37 (0x25)
+    38, // input 109 (0x6D char 'm') => 38 (0x26)
+    39, // input 110 (0x6E char 'n') => 39 (0x27)
+    40, // input 111 (0x6F char 'o') => 40 (0x28)
+    41, // input 112 (0x70 char 'p') => 41 (0x29)
+    42, // input 113 (0x71 char 'q') => 42 (0x2A)
+    43, // input 114 (0x72 char 'r') => 43 (0x2B)
+    44, // input 115 (0x73 char 's') => 44 (0x2C)
+    45, // input 116 (0x74 char 't') => 45 (0x2D)
+    46, // input 117 (0x75 char 'u') => 46 (0x2E)
+    47, // input 118 (0x76 char 'v') => 47 (0x2F)
+    48, // input 119 (0x77 char 'w') => 48 (0x30)
+    49, // input 120 (0x78 char 'x') => 49 (0x31)
+    50, // input 121 (0x79 char 'y') => 50 (0x32)
+    51, // input 122 (0x7A char 'z') => 51 (0x33)
+    INVALID_VALUE, // input 123 (0x7B)
+    INVALID_VALUE, // input 124 (0x7C)
+    INVALID_VALUE, // input 125 (0x7D)
+    INVALID_VALUE, // input 126 (0x7E)
+    INVALID_VALUE, // input 127 (0x7F)
+    INVALID_VALUE, // input 128 (0x80)
+    INVALID_VALUE, // input 129 (0x81)
+    INVALID_VALUE, // input 130 (0x82)
+    INVALID_VALUE, // input 131 (0x83)
+    INVALID_VALUE, // input 132 (0x84)
+    INVALID_VALUE, // input 133 (0x85)
+    INVALID_VALUE, // input 134 (0x86)
+    INVALID_VALUE, // input 135 (0x87)
+    INVALID_VALUE, // input 136 (0x88)
+    INVALID_VALUE, // input 137 (0x89)
+    INVALID_VALUE, // input 138 (0x8A)
+    INVALID_VALUE, // input 139 (0x8B)
+    INVALID_VALUE, // input 140 (0x8C)
+    INVALID_VALUE, // input 141 (0x8D)
+    INVALID_VALUE, // input 142 (0x8E)
+    INVALID_VALUE, // input 143 (0x8F)
+    INVALID_VALUE, // input 144 (0x90)
+    INVALID_VALUE, // input 145 (0x91)
+    INVALID_VALUE, // input 146 (0x92)
+    INVALID_VALUE, // input 147 (0x93)
+    INVALID_VALUE, // input 148 (0x94)
+    INVALID_VALUE, // input 149 (0x95)
+    INVALID_VALUE, // input 150 (0x96)
+    INVALID_VALUE, // input 151 (0x97)
+    INVALID_VALUE, // input 152 (0x98)
+    INVALID_VALUE, // input 153 (0x99)
+    INVALID_VALUE, // input 154 (0x9A)
+    INVALID_VALUE, // input 155 (0x9B)
+    INVALID_VALUE, // input 156 (0x9C)
+    INVALID_VALUE, // input 157 (0x9D)
+    INVALID_VALUE, // input 158 (0x9E)
+    INVALID_VALUE, // input 159 (0x9F)
+    INVALID_VALUE, // input 160 (0xA0)
+    INVALID_VALUE, // input 161 (0xA1)
+    INVALID_VALUE, // input 162 (0xA2)
+    INVALID_VALUE, // input 163 (0xA3)
+    INVALID_VALUE, // input 164 (0xA4)
+    INVALID_VALUE, // input 165 (0xA5)
+    INVALID_VALUE, // input 166 (0xA6)
+    INVALID_VALUE, // input 167 (0xA7)
+    INVALID_VALUE, // input 168 (0xA8)
+    INVALID_VALUE, // input 169 (0xA9)
+    INVALID_VALUE, // input 170 (0xAA)
+    INVALID_VALUE, // input 171 (0xAB)
+    INVALID_VALUE, // input 172 (0xAC)
+    INVALID_VALUE, // input 173 (0xAD)
+    INVALID_VALUE, // input 174 (0xAE)
+    INVALID_VALUE, // input 175 (0xAF)
+    INVALID_VALUE, // input 176 (0xB0)
+    INVALID_VALUE, // input 177 (0xB1)
+    INVALID_VALUE, // input 178 (0xB2)
+    INVALID_VALUE, // input 179 (0xB3)
+    INVALID_VALUE, // input 180 (0xB4)
+    INVALID_VALUE, // input 181 (0xB5)
+    INVALID_VALUE, // input 182 (0xB6)
+    INVALID_VALUE, // input 183 (0xB7)
+    INVALID_VALUE, // input 184 (0xB8)
+    INVALID_VALUE, // input 185 (0xB9)
+    INVALID_VALUE, // input 186 (0xBA)
+    INVALID_VALUE, // input 187 (0xBB)
+    INVALID_VALUE, // input 188 (0xBC)
+    INVALID_VALUE, // input 189 (0xBD)
+    INVALID_VALUE, // input 190 (0xBE)
+    INVALID_VALUE, // input 191 (0xBF)
+    INVALID_VALUE, // input 192 (0xC0)
+    INVALID_VALUE, // input 193 (0xC1)
+    INVALID_VALUE, // input 194 (0xC2)
+    INVALID_VALUE, // input 195 (0xC3)
+    INVALID_VALUE, // input 196 (0xC4)
+    INVALID_VALUE, // input 197 (0xC5)
+    INVALID_VALUE, // input 198 (0xC6)
+    INVALID_VALUE, // input 199 (0xC7)
+    INVALID_VALUE, // input 200 (0xC8)
+    INVALID_VALUE, // input 201 (0xC9)
+    INVALID_VALUE, // input 202 (0xCA)
+    INVALID_VALUE, // input 203 (0xCB)
+    INVALID_VALUE, // input 204 (0xCC)
+    INVALID_VALUE, // input 205 (0xCD)
+    INVALID_VALUE, // input 206 (0xCE)
+    INVALID_VALUE, // input 207 (0xCF)
+    INVALID_VALUE, // input 208 (0xD0)
+    INVALID_VALUE, // input 209 (0xD1)
+    INVALID_VALUE, // input 210 (0xD2)
+    INVALID_VALUE, // input 211 (0xD3)
+    INVALID_VALUE, // input 212 (0xD4)
+    INVALID_VALUE, // input 213 (0xD5)
+    INVALID_VALUE, // input 214 (0xD6)
+    INVALID_VALUE, // input 215 (0xD7)
+    INVALID_VALUE, // input 216 (0xD8)
+    INVALID_VALUE, // input 217 (0xD9)
+    INVALID_VALUE, // input 218 (0xDA)
+    INVALID_VALUE, // input 219 (0xDB)
+    INVALID_VALUE, // input 220 (0xDC)
+    INVALID_VALUE, // input 221 (0xDD)
+    INVALID_VALUE, // input 222 (0xDE)
+    INVALID_VALUE, // input 223 (0xDF)
+    INVALID_VALUE, // input 224 (0xE0)
+    INVALID_VALUE, // input 225 (0xE1)
+    INVALID_VALUE, // input 226 (0xE2)
+    INVALID_VALUE, // input 227 (0xE3)
+    INVALID_VALUE, // input 228 (0xE4)
+    INVALID_VALUE, // input 229 (0xE5)
+    INVALID_VALUE, // input 230 (0xE6)
+    INVALID_VALUE, // input 231 (0xE7)
+    INVALID_VALUE, // input 232 (0xE8)
+    INVALID_VALUE, // input 233 (0xE9)
+    INVALID_VALUE, // input 234 (0xEA)
+    INVALID_VALUE, // input 235 (0xEB)
+    INVALID_VALUE, // input 236 (0xEC)
+    INVALID_VALUE, // input 237 (0xED)
+    INVALID_VALUE, // input 238 (0xEE)
+    INVALID_VALUE, // input 239 (0xEF)
+    INVALID_VALUE, // input 240 (0xF0)
+    INVALID_VALUE, // input 241 (0xF1)
+    INVALID_VALUE, // input 242 (0xF2)
+    INVALID_VALUE, // input 243 (0xF3)
+    INVALID_VALUE, // input 244 (0xF4)
+    INVALID_VALUE, // input 245 (0xF5)
+    INVALID_VALUE, // input 246 (0xF6)
+    INVALID_VALUE, // input 247 (0xF7)
+    INVALID_VALUE, // input 248 (0xF8)
+    INVALID_VALUE, // input 249 (0xF9)
+    INVALID_VALUE, // input 250 (0xFA)
+    INVALID_VALUE, // input 251 (0xFB)
+    INVALID_VALUE, // input 252 (0xFC)
+    INVALID_VALUE, // input 253 (0xFD)
+    INVALID_VALUE, // input 254 (0xFE)
+    INVALID_VALUE, // input 255 (0xFF)
+];
+#[rustfmt::skip]
+pub const CRYPT_ENCODE: &[u8; 64] = &[
+    46, // input 0 (0x0) => '.' (0x2E)
+    47, // input 1 (0x1) => '/' (0x2F)
+    48, // input 2 (0x2) => '0' (0x30)
+    49, // input 3 (0x3) => '1' (0x31)
+    50, // input 4 (0x4) => '2' (0x32)
+    51, // input 5 (0x5) => '3' (0x33)
+    52, // input 6 (0x6) => '4' (0x34)
+    53, // input 7 (0x7) => '5' (0x35)
+    54, // input 8 (0x8) => '6' (0x36)
+    55, // input 9 (0x9) => '7' (0x37)
+    56, // input 10 (0xA) => '8' (0x38)
+    57, // input 11 (0xB) => '9' (0x39)
+    65, // input 12 (0xC) => 'A' (0x41)
+    66, // input 13 (0xD) => 'B' (0x42)
+    67, // input 14 (0xE) => 'C' (0x43)
+    68, // input 15 (0xF) => 'D' (0x44)
+    69, // input 16 (0x10) => 'E' (0x45)
+    70, // input 17 (0x11) => 'F' (0x46)
+    71, // input 18 (0x12) => 'G' (0x47)
+    72, // input 19 (0x13) => 'H' (0x48)
+    73, // input 20 (0x14) => 'I' (0x49)
+    74, // input 21 (0x15) => 'J' (0x4A)
+    75, // input 22 (0x16) => 'K' (0x4B)
+    76, // input 23 (0x17) => 'L' (0x4C)
+    77, // input 24 (0x18) => 'M' (0x4D)
+    78, // input 25 (0x19) => 'N' (0x4E)
+    79, // input 26 (0x1A) => 'O' (0x4F)
+    80, // input 27 (0x1B) => 'P' (0x50)
+    81, // input 28 (0x1C) => 'Q' (0x51)
+    82, // input 29 (0x1D) => 'R' (0x52)
+    83, // input 30 (0x1E) => 'S' (0x53)
+    84, // input 31 (0x1F) => 'T' (0x54)
+    85, // input 32 (0x20) => 'U' (0x55)
+    86, // input 33 (0x21) => 'V' (0x56)
+    87, // input 34 (0x22) => 'W' (0x57)
+    88, // input 35 (0x23) => 'X' (0x58)
+    89, // input 36 (0x24) => 'Y' (0x59)
+    90, // input 37 (0x25) => 'Z' (0x5A)
+    97, // input 38 (0x26) => 'a' (0x61)
+    98, // input 39 (0x27) => 'b' (0x62)
+    99, // input 40 (0x28) => 'c' (0x63)
+    100, // input 41 (0x29) => 'd' (0x64)
+    101, // input 42 (0x2A) => 'e' (0x65)
+    102, // input 43 (0x2B) => 'f' (0x66)
+    103, // input 44 (0x2C) => 'g' (0x67)
+    104, // input 45 (0x2D) => 'h' (0x68)
+    105, // input 46 (0x2E) => 'i' (0x69)
+    106, // input 47 (0x2F) => 'j' (0x6A)
+    107, // input 48 (0x30) => 'k' (0x6B)
+    108, // input 49 (0x31) => 'l' (0x6C)
+    109, // input 50 (0x32) => 'm' (0x6D)
+    110, // input 51 (0x33) => 'n' (0x6E)
+    111, // input 52 (0x34) => 'o' (0x6F)
+    112, // input 53 (0x35) => 'p' (0x70)
+    113, // input 54 (0x36) => 'q' (0x71)
+    114, // input 55 (0x37) => 'r' (0x72)
+    115, // input 56 (0x38) => 's' (0x73)
+    116, // input 57 (0x39) => 't' (0x74)
+    117, // input 58 (0x3A) => 'u' (0x75)
+    118, // input 59 (0x3B) => 'v' (0x76)
+    119, // input 60 (0x3C) => 'w' (0x77)
+    120, // input 61 (0x3D) => 'x' (0x78)
+    121, // input 62 (0x3E) => 'y' (0x79)
+    122, // input 63 (0x3F) => 'z' (0x7A)
+];
+#[rustfmt::skip]
+pub const CRYPT_DECODE: &[u8; 256] = &[
+    INVALID_VALUE, // input 0 (0x0)
+    INVALID_VALUE, // input 1 (0x1)
+    INVALID_VALUE, // input 2 (0x2)
+    INVALID_VALUE, // input 3 (0x3)
+    INVALID_VALUE, // input 4 (0x4)
+    INVALID_VALUE, // input 5 (0x5)
+    INVALID_VALUE, // input 6 (0x6)
+    INVALID_VALUE, // input 7 (0x7)
+    INVALID_VALUE, // input 8 (0x8)
+    INVALID_VALUE, // input 9 (0x9)
+    INVALID_VALUE, // input 10 (0xA)
+    INVALID_VALUE, // input 11 (0xB)
+    INVALID_VALUE, // input 12 (0xC)
+    INVALID_VALUE, // input 13 (0xD)
+    INVALID_VALUE, // input 14 (0xE)
+    INVALID_VALUE, // input 15 (0xF)
+    INVALID_VALUE, // input 16 (0x10)
+    INVALID_VALUE, // input 17 (0x11)
+    INVALID_VALUE, // input 18 (0x12)
+    INVALID_VALUE, // input 19 (0x13)
+    INVALID_VALUE, // input 20 (0x14)
+    INVALID_VALUE, // input 21 (0x15)
+    INVALID_VALUE, // input 22 (0x16)
+    INVALID_VALUE, // input 23 (0x17)
+    INVALID_VALUE, // input 24 (0x18)
+    INVALID_VALUE, // input 25 (0x19)
+    INVALID_VALUE, // input 26 (0x1A)
+    INVALID_VALUE, // input 27 (0x1B)
+    INVALID_VALUE, // input 28 (0x1C)
+    INVALID_VALUE, // input 29 (0x1D)
+    INVALID_VALUE, // input 30 (0x1E)
+    INVALID_VALUE, // input 31 (0x1F)
+    INVALID_VALUE, // input 32 (0x20)
+    INVALID_VALUE, // input 33 (0x21)
+    INVALID_VALUE, // input 34 (0x22)
+    INVALID_VALUE, // input 35 (0x23)
+    INVALID_VALUE, // input 36 (0x24)
+    INVALID_VALUE, // input 37 (0x25)
+    INVALID_VALUE, // input 38 (0x26)
+    INVALID_VALUE, // input 39 (0x27)
+    INVALID_VALUE, // input 40 (0x28)
+    INVALID_VALUE, // input 41 (0x29)
+    INVALID_VALUE, // input 42 (0x2A)
+    INVALID_VALUE, // input 43 (0x2B)
+    INVALID_VALUE, // input 44 (0x2C)
+    INVALID_VALUE, // input 45 (0x2D)
+    0, // input 46 (0x2E char '.') => 0 (0x0)
+    1, // input 47 (0x2F char '/') => 1 (0x1)
+    2, // input 48 (0x30 char '0') => 2 (0x2)
+    3, // input 49 (0x31 char '1') => 3 (0x3)
+    4, // input 50 (0x32 char '2') => 4 (0x4)
+    5, // input 51 (0x33 char '3') => 5 (0x5)
+    6, // input 52 (0x34 char '4') => 6 (0x6)
+    7, // input 53 (0x35 char '5') => 7 (0x7)
+    8, // input 54 (0x36 char '6') => 8 (0x8)
+    9, // input 55 (0x37 char '7') => 9 (0x9)
+    10, // input 56 (0x38 char '8') => 10 (0xA)
+    11, // input 57 (0x39 char '9') => 11 (0xB)
+    INVALID_VALUE, // input 58 (0x3A)
+    INVALID_VALUE, // input 59 (0x3B)
+    INVALID_VALUE, // input 60 (0x3C)
+    INVALID_VALUE, // input 61 (0x3D)
+    INVALID_VALUE, // input 62 (0x3E)
+    INVALID_VALUE, // input 63 (0x3F)
+    INVALID_VALUE, // input 64 (0x40)
+    12, // input 65 (0x41 char 'A') => 12 (0xC)
+    13, // input 66 (0x42 char 'B') => 13 (0xD)
+    14, // input 67 (0x43 char 'C') => 14 (0xE)
+    15, // input 68 (0x44 char 'D') => 15 (0xF)
+    16, // input 69 (0x45 char 'E') => 16 (0x10)
+    17, // input 70 (0x46 char 'F') => 17 (0x11)
+    18, // input 71 (0x47 char 'G') => 18 (0x12)
+    19, // input 72 (0x48 char 'H') => 19 (0x13)
+    20, // input 73 (0x49 char 'I') => 20 (0x14)
+    21, // input 74 (0x4A char 'J') => 21 (0x15)
+    22, // input 75 (0x4B char 'K') => 22 (0x16)
+    23, // input 76 (0x4C char 'L') => 23 (0x17)
+    24, // input 77 (0x4D char 'M') => 24 (0x18)
+    25, // input 78 (0x4E char 'N') => 25 (0x19)
+    26, // input 79 (0x4F char 'O') => 26 (0x1A)
+    27, // input 80 (0x50 char 'P') => 27 (0x1B)
+    28, // input 81 (0x51 char 'Q') => 28 (0x1C)
+    29, // input 82 (0x52 char 'R') => 29 (0x1D)
+    30, // input 83 (0x53 char 'S') => 30 (0x1E)
+    31, // input 84 (0x54 char 'T') => 31 (0x1F)
+    32, // input 85 (0x55 char 'U') => 32 (0x20)
+    33, // input 86 (0x56 char 'V') => 33 (0x21)
+    34, // input 87 (0x57 char 'W') => 34 (0x22)
+    35, // input 88 (0x58 char 'X') => 35 (0x23)
+    36, // input 89 (0x59 char 'Y') => 36 (0x24)
+    37, // input 90 (0x5A char 'Z') => 37 (0x25)
+    INVALID_VALUE, // input 91 (0x5B)
+    INVALID_VALUE, // input 92 (0x5C)
+    INVALID_VALUE, // input 93 (0x5D)
+    INVALID_VALUE, // input 94 (0x5E)
+    INVALID_VALUE, // input 95 (0x5F)
+    INVALID_VALUE, // input 96 (0x60)
+    38, // input 97 (0x61 char 'a') => 38 (0x26)
+    39, // input 98 (0x62 char 'b') => 39 (0x27)
+    40, // input 99 (0x63 char 'c') => 40 (0x28)
+    41, // input 100 (0x64 char 'd') => 41 (0x29)
+    42, // input 101 (0x65 char 'e') => 42 (0x2A)
+    43, // input 102 (0x66 char 'f') => 43 (0x2B)
+    44, // input 103 (0x67 char 'g') => 44 (0x2C)
+    45, // input 104 (0x68 char 'h') => 45 (0x2D)
+    46, // input 105 (0x69 char 'i') => 46 (0x2E)
+    47, // input 106 (0x6A char 'j') => 47 (0x2F)
+    48, // input 107 (0x6B char 'k') => 48 (0x30)
+    49, // input 108 (0x6C char 'l') => 49 (0x31)
+    50, // input 109 (0x6D char 'm') => 50 (0x32)
+    51, // input 110 (0x6E char 'n') => 51 (0x33)
+    52, // input 111 (0x6F char 'o') => 52 (0x34)
+    53, // input 112 (0x70 char 'p') => 53 (0x35)
+    54, // input 113 (0x71 char 'q') => 54 (0x36)
+    55, // input 114 (0x72 char 'r') => 55 (0x37)
+    56, // input 115 (0x73 char 's') => 56 (0x38)
+    57, // input 116 (0x74 char 't') => 57 (0x39)
+    58, // input 117 (0x75 char 'u') => 58 (0x3A)
+    59, // input 118 (0x76 char 'v') => 59 (0x3B)
+    60, // input 119 (0x77 char 'w') => 60 (0x3C)
+    61, // input 120 (0x78 char 'x') => 61 (0x3D)
+    62, // input 121 (0x79 char 'y') => 62 (0x3E)
+    63, // input 122 (0x7A char 'z') => 63 (0x3F)
+    INVALID_VALUE, // input 123 (0x7B)
+    INVALID_VALUE, // input 124 (0x7C)
+    INVALID_VALUE, // input 125 (0x7D)
+    INVALID_VALUE, // input 126 (0x7E)
+    INVALID_VALUE, // input 127 (0x7F)
+    INVALID_VALUE, // input 128 (0x80)
+    INVALID_VALUE, // input 129 (0x81)
+    INVALID_VALUE, // input 130 (0x82)
+    INVALID_VALUE, // input 131 (0x83)
+    INVALID_VALUE, // input 132 (0x84)
+    INVALID_VALUE, // input 133 (0x85)
+    INVALID_VALUE, // input 134 (0x86)
+    INVALID_VALUE, // input 135 (0x87)
+    INVALID_VALUE, // input 136 (0x88)
+    INVALID_VALUE, // input 137 (0x89)
+    INVALID_VALUE, // input 138 (0x8A)
+    INVALID_VALUE, // input 139 (0x8B)
+    INVALID_VALUE, // input 140 (0x8C)
+    INVALID_VALUE, // input 141 (0x8D)
+    INVALID_VALUE, // input 142 (0x8E)
+    INVALID_VALUE, // input 143 (0x8F)
+    INVALID_VALUE, // input 144 (0x90)
+    INVALID_VALUE, // input 145 (0x91)
+    INVALID_VALUE, // input 146 (0x92)
+    INVALID_VALUE, // input 147 (0x93)
+    INVALID_VALUE, // input 148 (0x94)
+    INVALID_VALUE, // input 149 (0x95)
+    INVALID_VALUE, // input 150 (0x96)
+    INVALID_VALUE, // input 151 (0x97)
+    INVALID_VALUE, // input 152 (0x98)
+    INVALID_VALUE, // input 153 (0x99)
+    INVALID_VALUE, // input 154 (0x9A)
+    INVALID_VALUE, // input 155 (0x9B)
+    INVALID_VALUE, // input 156 (0x9C)
+    INVALID_VALUE, // input 157 (0x9D)
+    INVALID_VALUE, // input 158 (0x9E)
+    INVALID_VALUE, // input 159 (0x9F)
+    INVALID_VALUE, // input 160 (0xA0)
+    INVALID_VALUE, // input 161 (0xA1)
+    INVALID_VALUE, // input 162 (0xA2)
+    INVALID_VALUE, // input 163 (0xA3)
+    INVALID_VALUE, // input 164 (0xA4)
+    INVALID_VALUE, // input 165 (0xA5)
+    INVALID_VALUE, // input 166 (0xA6)
+    INVALID_VALUE, // input 167 (0xA7)
+    INVALID_VALUE, // input 168 (0xA8)
+    INVALID_VALUE, // input 169 (0xA9)
+    INVALID_VALUE, // input 170 (0xAA)
+    INVALID_VALUE, // input 171 (0xAB)
+    INVALID_VALUE, // input 172 (0xAC)
+    INVALID_VALUE, // input 173 (0xAD)
+    INVALID_VALUE, // input 174 (0xAE)
+    INVALID_VALUE, // input 175 (0xAF)
+    INVALID_VALUE, // input 176 (0xB0)
+    INVALID_VALUE, // input 177 (0xB1)
+    INVALID_VALUE, // input 178 (0xB2)
+    INVALID_VALUE, // input 179 (0xB3)
+    INVALID_VALUE, // input 180 (0xB4)
+    INVALID_VALUE, // input 181 (0xB5)
+    INVALID_VALUE, // input 182 (0xB6)
+    INVALID_VALUE, // input 183 (0xB7)
+    INVALID_VALUE, // input 184 (0xB8)
+    INVALID_VALUE, // input 185 (0xB9)
+    INVALID_VALUE, // input 186 (0xBA)
+    INVALID_VALUE, // input 187 (0xBB)
+    INVALID_VALUE, // input 188 (0xBC)
+    INVALID_VALUE, // input 189 (0xBD)
+    INVALID_VALUE, // input 190 (0xBE)
+    INVALID_VALUE, // input 191 (0xBF)
+    INVALID_VALUE, // input 192 (0xC0)
+    INVALID_VALUE, // input 193 (0xC1)
+    INVALID_VALUE, // input 194 (0xC2)
+    INVALID_VALUE, // input 195 (0xC3)
+    INVALID_VALUE, // input 196 (0xC4)
+    INVALID_VALUE, // input 197 (0xC5)
+    INVALID_VALUE, // input 198 (0xC6)
+    INVALID_VALUE, // input 199 (0xC7)
+    INVALID_VALUE, // input 200 (0xC8)
+    INVALID_VALUE, // input 201 (0xC9)
+    INVALID_VALUE, // input 202 (0xCA)
+    INVALID_VALUE, // input 203 (0xCB)
+    INVALID_VALUE, // input 204 (0xCC)
+    INVALID_VALUE, // input 205 (0xCD)
+    INVALID_VALUE, // input 206 (0xCE)
+    INVALID_VALUE, // input 207 (0xCF)
+    INVALID_VALUE, // input 208 (0xD0)
+    INVALID_VALUE, // input 209 (0xD1)
+    INVALID_VALUE, // input 210 (0xD2)
+    INVALID_VALUE, // input 211 (0xD3)
+    INVALID_VALUE, // input 212 (0xD4)
+    INVALID_VALUE, // input 213 (0xD5)
+    INVALID_VALUE, // input 214 (0xD6)
+    INVALID_VALUE, // input 215 (0xD7)
+    INVALID_VALUE, // input 216 (0xD8)
+    INVALID_VALUE, // input 217 (0xD9)
+    INVALID_VALUE, // input 218 (0xDA)
+    INVALID_VALUE, // input 219 (0xDB)
+    INVALID_VALUE, // input 220 (0xDC)
+    INVALID_VALUE, // input 221 (0xDD)
+    INVALID_VALUE, // input 222 (0xDE)
+    INVALID_VALUE, // input 223 (0xDF)
+    INVALID_VALUE, // input 224 (0xE0)
+    INVALID_VALUE, // input 225 (0xE1)
+    INVALID_VALUE, // input 226 (0xE2)
+    INVALID_VALUE, // input 227 (0xE3)
+    INVALID_VALUE, // input 228 (0xE4)
+    INVALID_VALUE, // input 229 (0xE5)
+    INVALID_VALUE, // input 230 (0xE6)
+    INVALID_VALUE, // input 231 (0xE7)
+    INVALID_VALUE, // input 232 (0xE8)
+    INVALID_VALUE, // input 233 (0xE9)
+    INVALID_VALUE, // input 234 (0xEA)
+    INVALID_VALUE, // input 235 (0xEB)
+    INVALID_VALUE, // input 236 (0xEC)
+    INVALID_VALUE, // input 237 (0xED)
+    INVALID_VALUE, // input 238 (0xEE)
+    INVALID_VALUE, // input 239 (0xEF)
+    INVALID_VALUE, // input 240 (0xF0)
+    INVALID_VALUE, // input 241 (0xF1)
+    INVALID_VALUE, // input 242 (0xF2)
+    INVALID_VALUE, // input 243 (0xF3)
+    INVALID_VALUE, // input 244 (0xF4)
+    INVALID_VALUE, // input 245 (0xF5)
+    INVALID_VALUE, // input 246 (0xF6)
+    INVALID_VALUE, // input 247 (0xF7)
+    INVALID_VALUE, // input 248 (0xF8)
+    INVALID_VALUE, // input 249 (0xF9)
+    INVALID_VALUE, // input 250 (0xFA)
+    INVALID_VALUE, // input 251 (0xFB)
+    INVALID_VALUE, // input 252 (0xFC)
+    INVALID_VALUE, // input 253 (0xFD)
+    INVALID_VALUE, // input 254 (0xFE)
+    INVALID_VALUE, // input 255 (0xFF)
+];
+#[rustfmt::skip]
+pub const BCRYPT_ENCODE: &[u8; 64] = &[
+    46, // input 0 (0x0) => '.' (0x2E)
+    47, // input 1 (0x1) => '/' (0x2F)
+    65, // input 2 (0x2) => 'A' (0x41)
+    66, // input 3 (0x3) => 'B' (0x42)
+    67, // input 4 (0x4) => 'C' (0x43)
+    68, // input 5 (0x5) => 'D' (0x44)
+    69, // input 6 (0x6) => 'E' (0x45)
+    70, // input 7 (0x7) => 'F' (0x46)
+    71, // input 8 (0x8) => 'G' (0x47)
+    72, // input 9 (0x9) => 'H' (0x48)
+    73, // input 10 (0xA) => 'I' (0x49)
+    74, // input 11 (0xB) => 'J' (0x4A)
+    75, // input 12 (0xC) => 'K' (0x4B)
+    76, // input 13 (0xD) => 'L' (0x4C)
+    77, // input 14 (0xE) => 'M' (0x4D)
+    78, // input 15 (0xF) => 'N' (0x4E)
+    79, // input 16 (0x10) => 'O' (0x4F)
+    80, // input 17 (0x11) => 'P' (0x50)
+    81, // input 18 (0x12) => 'Q' (0x51)
+    82, // input 19 (0x13) => 'R' (0x52)
+    83, // input 20 (0x14) => 'S' (0x53)
+    84, // input 21 (0x15) => 'T' (0x54)
+    85, // input 22 (0x16) => 'U' (0x55)
+    86, // input 23 (0x17) => 'V' (0x56)
+    87, // input 24 (0x18) => 'W' (0x57)
+    88, // input 25 (0x19) => 'X' (0x58)
+    89, // input 26 (0x1A) => 'Y' (0x59)
+    90, // input 27 (0x1B) => 'Z' (0x5A)
+    97, // input 28 (0x1C) => 'a' (0x61)
+    98, // input 29 (0x1D) => 'b' (0x62)
+    99, // input 30 (0x1E) => 'c' (0x63)
+    100, // input 31 (0x1F) => 'd' (0x64)
+    101, // input 32 (0x20) => 'e' (0x65)
+    102, // input 33 (0x21) => 'f' (0x66)
+    103, // input 34 (0x22) => 'g' (0x67)
+    104, // input 35 (0x23) => 'h' (0x68)
+    105, // input 36 (0x24) => 'i' (0x69)
+    106, // input 37 (0x25) => 'j' (0x6A)
+    107, // input 38 (0x26) => 'k' (0x6B)
+    108, // input 39 (0x27) => 'l' (0x6C)
+    109, // input 40 (0x28) => 'm' (0x6D)
+    110, // input 41 (0x29) => 'n' (0x6E)
+    111, // input 42 (0x2A) => 'o' (0x6F)
+    112, // input 43 (0x2B) => 'p' (0x70)
+    113, // input 44 (0x2C) => 'q' (0x71)
+    114, // input 45 (0x2D) => 'r' (0x72)
+    115, // input 46 (0x2E) => 's' (0x73)
+    116, // input 47 (0x2F) => 't' (0x74)
+    117, // input 48 (0x30) => 'u' (0x75)
+    118, // input 49 (0x31) => 'v' (0x76)
+    119, // input 50 (0x32) => 'w' (0x77)
+    120, // input 51 (0x33) => 'x' (0x78)
+    121, // input 52 (0x34) => 'y' (0x79)
+    122, // input 53 (0x35) => 'z' (0x7A)
+    48, // input 54 (0x36) => '0' (0x30)
+    49, // input 55 (0x37) => '1' (0x31)
+    50, // input 56 (0x38) => '2' (0x32)
+    51, // input 57 (0x39) => '3' (0x33)
+    52, // input 58 (0x3A) => '4' (0x34)
+    53, // input 59 (0x3B) => '5' (0x35)
+    54, // input 60 (0x3C) => '6' (0x36)
+    55, // input 61 (0x3D) => '7' (0x37)
+    56, // input 62 (0x3E) => '8' (0x38)
+    57, // input 63 (0x3F) => '9' (0x39)
+];
+#[rustfmt::skip]
+pub const BCRYPT_DECODE: &[u8; 256] = &[
+    INVALID_VALUE, // input 0 (0x0)
+    INVALID_VALUE, // input 1 (0x1)
+    INVALID_VALUE, // input 2 (0x2)
+    INVALID_VALUE, // input 3 (0x3)
+    INVALID_VALUE, // input 4 (0x4)
+    INVALID_VALUE, // input 5 (0x5)
+    INVALID_VALUE, // input 6 (0x6)
+    INVALID_VALUE, // input 7 (0x7)
+    INVALID_VALUE, // input 8 (0x8)
+    INVALID_VALUE, // input 9 (0x9)
+    INVALID_VALUE, // input 10 (0xA)
+    INVALID_VALUE, // input 11 (0xB)
+    INVALID_VALUE, // input 12 (0xC)
+    INVALID_VALUE, // input 13 (0xD)
+    INVALID_VALUE, // input 14 (0xE)
+    INVALID_VALUE, // input 15 (0xF)
+    INVALID_VALUE, // input 16 (0x10)
+    INVALID_VALUE, // input 17 (0x11)
+    INVALID_VALUE, // input 18 (0x12)
+    INVALID_VALUE, // input 19 (0x13)
+    INVALID_VALUE, // input 20 (0x14)
+    INVALID_VALUE, // input 21 (0x15)
+    INVALID_VALUE, // input 22 (0x16)
+    INVALID_VALUE, // input 23 (0x17)
+    INVALID_VALUE, // input 24 (0x18)
+    INVALID_VALUE, // input 25 (0x19)
+    INVALID_VALUE, // input 26 (0x1A)
+    INVALID_VALUE, // input 27 (0x1B)
+    INVALID_VALUE, // input 28 (0x1C)
+    INVALID_VALUE, // input 29 (0x1D)
+    INVALID_VALUE, // input 30 (0x1E)
+    INVALID_VALUE, // input 31 (0x1F)
+    INVALID_VALUE, // input 32 (0x20)
+    INVALID_VALUE, // input 33 (0x21)
+    INVALID_VALUE, // input 34 (0x22)
+    INVALID_VALUE, // input 35 (0x23)
+    INVALID_VALUE, // input 36 (0x24)
+    INVALID_VALUE, // input 37 (0x25)
+    INVALID_VALUE, // input 38 (0x26)
+    INVALID_VALUE, // input 39 (0x27)
+    INVALID_VALUE, // input 40 (0x28)
+    INVALID_VALUE, // input 41 (0x29)
+    INVALID_VALUE, // input 42 (0x2A)
+    INVALID_VALUE, // input 43 (0x2B)
+    INVALID_VALUE, // input 44 (0x2C)
+    INVALID_VALUE, // input 45 (0x2D)
+    0, // input 46 (0x2E char '.') => 0 (0x0)
+    1, // input 47 (0x2F char '/') => 1 (0x1)
+    54, // input 48 (0x30 char '0') => 54 (0x36)
+    55, // input 49 (0x31 char '1') => 55 (0x37)
+    56, // input 50 (0x32 char '2') => 56 (0x38)
+    57, // input 51 (0x33 char '3') => 57 (0x39)
+    58, // input 52 (0x34 char '4') => 58 (0x3A)
+    59, // input 53 (0x35 char '5') => 59 (0x3B)
+    60, // input 54 (0x36 char '6') => 60 (0x3C)
+    61, // input 55 (0x37 char '7') => 61 (0x3D)
+    62, // input 56 (0x38 char '8') => 62 (0x3E)
+    63, // input 57 (0x39 char '9') => 63 (0x3F)
+    INVALID_VALUE, // input 58 (0x3A)
+    INVALID_VALUE, // input 59 (0x3B)
+    INVALID_VALUE, // input 60 (0x3C)
+    INVALID_VALUE, // input 61 (0x3D)
+    INVALID_VALUE, // input 62 (0x3E)
+    INVALID_VALUE, // input 63 (0x3F)
+    INVALID_VALUE, // input 64 (0x40)
+    2, // input 65 (0x41 char 'A') => 2 (0x2)
+    3, // input 66 (0x42 char 'B') => 3 (0x3)
+    4, // input 67 (0x43 char 'C') => 4 (0x4)
+    5, // input 68 (0x44 char 'D') => 5 (0x5)
+    6, // input 69 (0x45 char 'E') => 6 (0x6)
+    7, // input 70 (0x46 char 'F') => 7 (0x7)
+    8, // input 71 (0x47 char 'G') => 8 (0x8)
+    9, // input 72 (0x48 char 'H') => 9 (0x9)
+    10, // input 73 (0x49 char 'I') => 10 (0xA)
+    11, // input 74 (0x4A char 'J') => 11 (0xB)
+    12, // input 75 (0x4B char 'K') => 12 (0xC)
+    13, // input 76 (0x4C char 'L') => 13 (0xD)
+    14, // input 77 (0x4D char 'M') => 14 (0xE)
+    15, // input 78 (0x4E char 'N') => 15 (0xF)
+    16, // input 79 (0x4F char 'O') => 16 (0x10)
+    17, // input 80 (0x50 char 'P') => 17 (0x11)
+    18, // input 81 (0x51 char 'Q') => 18 (0x12)
+    19, // input 82 (0x52 char 'R') => 19 (0x13)
+    20, // input 83 (0x53 char 'S') => 20 (0x14)
+    21, // input 84 (0x54 char 'T') => 21 (0x15)
+    22, // input 85 (0x55 char 'U') => 22 (0x16)
+    23, // input 86 (0x56 char 'V') => 23 (0x17)
+    24, // input 87 (0x57 char 'W') => 24 (0x18)
+    25, // input 88 (0x58 char 'X') => 25 (0x19)
+    26, // input 89 (0x59 char 'Y') => 26 (0x1A)
+    27, // input 90 (0x5A char 'Z') => 27 (0x1B)
+    INVALID_VALUE, // input 91 (0x5B)
+    INVALID_VALUE, // input 92 (0x5C)
+    INVALID_VALUE, // input 93 (0x5D)
+    INVALID_VALUE, // input 94 (0x5E)
+    INVALID_VALUE, // input 95 (0x5F)
+    INVALID_VALUE, // input 96 (0x60)
+    28, // input 97 (0x61 char 'a') => 28 (0x1C)
+    29, // input 98 (0x62 char 'b') => 29 (0x1D)
+    30, // input 99 (0x63 char 'c') => 30 (0x1E)
+    31, // input 100 (0x64 char 'd') => 31 (0x1F)
+    32, // input 101 (0x65 char 'e') => 32 (0x20)
+    33, // input 102 (0x66 char 'f') => 33 (0x21)
+    34, // input 103 (0x67 char 'g') => 34 (0x22)
+    35, // input 104 (0x68 char 'h') => 35 (0x23)
+    36, // input 105 (0x69 char 'i') => 36 (0x24)
+    37, // input 106 (0x6A char 'j') => 37 (0x25)
+    38, // input 107 (0x6B char 'k') => 38 (0x26)
+    39, // input 108 (0x6C char 'l') => 39 (0x27)
+    40, // input 109 (0x6D char 'm') => 40 (0x28)
+    41, // input 110 (0x6E char 'n') => 41 (0x29)
+    42, // input 111 (0x6F char 'o') => 42 (0x2A)
+    43, // input 112 (0x70 char 'p') => 43 (0x2B)
+    44, // input 113 (0x71 char 'q') => 44 (0x2C)
+    45, // input 114 (0x72 char 'r') => 45 (0x2D)
+    46, // input 115 (0x73 char 's') => 46 (0x2E)
+    47, // input 116 (0x74 char 't') => 47 (0x2F)
+    48, // input 117 (0x75 char 'u') => 48 (0x30)
+    49, // input 118 (0x76 char 'v') => 49 (0x31)
+    50, // input 119 (0x77 char 'w') => 50 (0x32)
+    51, // input 120 (0x78 char 'x') => 51 (0x33)
+    52, // input 121 (0x79 char 'y') => 52 (0x34)
+    53, // input 122 (0x7A char 'z') => 53 (0x35)
+    INVALID_VALUE, // input 123 (0x7B)
+    INVALID_VALUE, // input 124 (0x7C)
+    INVALID_VALUE, // input 125 (0x7D)
+    INVALID_VALUE, // input 126 (0x7E)
+    INVALID_VALUE, // input 127 (0x7F)
+    INVALID_VALUE, // input 128 (0x80)
+    INVALID_VALUE, // input 129 (0x81)
+    INVALID_VALUE, // input 130 (0x82)
+    INVALID_VALUE, // input 131 (0x83)
+    INVALID_VALUE, // input 132 (0x84)
+    INVALID_VALUE, // input 133 (0x85)
+    INVALID_VALUE, // input 134 (0x86)
+    INVALID_VALUE, // input 135 (0x87)
+    INVALID_VALUE, // input 136 (0x88)
+    INVALID_VALUE, // input 137 (0x89)
+    INVALID_VALUE, // input 138 (0x8A)
+    INVALID_VALUE, // input 139 (0x8B)
+    INVALID_VALUE, // input 140 (0x8C)
+    INVALID_VALUE, // input 141 (0x8D)
+    INVALID_VALUE, // input 142 (0x8E)
+    INVALID_VALUE, // input 143 (0x8F)
+    INVALID_VALUE, // input 144 (0x90)
+    INVALID_VALUE, // input 145 (0x91)
+    INVALID_VALUE, // input 146 (0x92)
+    INVALID_VALUE, // input 147 (0x93)
+    INVALID_VALUE, // input 148 (0x94)
+    INVALID_VALUE, // input 149 (0x95)
+    INVALID_VALUE, // input 150 (0x96)
+    INVALID_VALUE, // input 151 (0x97)
+    INVALID_VALUE, // input 152 (0x98)
+    INVALID_VALUE, // input 153 (0x99)
+    INVALID_VALUE, // input 154 (0x9A)
+    INVALID_VALUE, // input 155 (0x9B)
+    INVALID_VALUE, // input 156 (0x9C)
+    INVALID_VALUE, // input 157 (0x9D)
+    INVALID_VALUE, // input 158 (0x9E)
+    INVALID_VALUE, // input 159 (0x9F)
+    INVALID_VALUE, // input 160 (0xA0)
+    INVALID_VALUE, // input 161 (0xA1)
+    INVALID_VALUE, // input 162 (0xA2)
+    INVALID_VALUE, // input 163 (0xA3)
+    INVALID_VALUE, // input 164 (0xA4)
+    INVALID_VALUE, // input 165 (0xA5)
+    INVALID_VALUE, // input 166 (0xA6)
+    INVALID_VALUE, // input 167 (0xA7)
+    INVALID_VALUE, // input 168 (0xA8)
+    INVALID_VALUE, // input 169 (0xA9)
+    INVALID_VALUE, // input 170 (0xAA)
+    INVALID_VALUE, // input 171 (0xAB)
+    INVALID_VALUE, // input 172 (0xAC)
+    INVALID_VALUE, // input 173 (0xAD)
+    INVALID_VALUE, // input 174 (0xAE)
+    INVALID_VALUE, // input 175 (0xAF)
+    INVALID_VALUE, // input 176 (0xB0)
+    INVALID_VALUE, // input 177 (0xB1)
+    INVALID_VALUE, // input 178 (0xB2)
+    INVALID_VALUE, // input 179 (0xB3)
+    INVALID_VALUE, // input 180 (0xB4)
+    INVALID_VALUE, // input 181 (0xB5)
+    INVALID_VALUE, // input 182 (0xB6)
+    INVALID_VALUE, // input 183 (0xB7)
+    INVALID_VALUE, // input 184 (0xB8)
+    INVALID_VALUE, // input 185 (0xB9)
+    INVALID_VALUE, // input 186 (0xBA)
+    INVALID_VALUE, // input 187 (0xBB)
+    INVALID_VALUE, // input 188 (0xBC)
+    INVALID_VALUE, // input 189 (0xBD)
+    INVALID_VALUE, // input 190 (0xBE)
+    INVALID_VALUE, // input 191 (0xBF)
+    INVALID_VALUE, // input 192 (0xC0)
+    INVALID_VALUE, // input 193 (0xC1)
+    INVALID_VALUE, // input 194 (0xC2)
+    INVALID_VALUE, // input 195 (0xC3)
+    INVALID_VALUE, // input 196 (0xC4)
+    INVALID_VALUE, // input 197 (0xC5)
+    INVALID_VALUE, // input 198 (0xC6)
+    INVALID_VALUE, // input 199 (0xC7)
+    INVALID_VALUE, // input 200 (0xC8)
+    INVALID_VALUE, // input 201 (0xC9)
+    INVALID_VALUE, // input 202 (0xCA)
+    INVALID_VALUE, // input 203 (0xCB)
+    INVALID_VALUE, // input 204 (0xCC)
+    INVALID_VALUE, // input 205 (0xCD)
+    INVALID_VALUE, // input 206 (0xCE)
+    INVALID_VALUE, // input 207 (0xCF)
+    INVALID_VALUE, // input 208 (0xD0)
+    INVALID_VALUE, // input 209 (0xD1)
+    INVALID_VALUE, // input 210 (0xD2)
+    INVALID_VALUE, // input 211 (0xD3)
+    INVALID_VALUE, // input 212 (0xD4)
+    INVALID_VALUE, // input 213 (0xD5)
+    INVALID_VALUE, // input 214 (0xD6)
+    INVALID_VALUE, // input 215 (0xD7)
+    INVALID_VALUE, // input 216 (0xD8)
+    INVALID_VALUE, // input 217 (0xD9)
+    INVALID_VALUE, // input 218 (0xDA)
+    INVALID_VALUE, // input 219 (0xDB)
+    INVALID_VALUE, // input 220 (0xDC)
+    INVALID_VALUE, // input 221 (0xDD)
+    INVALID_VALUE, // input 222 (0xDE)
+    INVALID_VALUE, // input 223 (0xDF)
+    INVALID_VALUE, // input 224 (0xE0)
+    INVALID_VALUE, // input 225 (0xE1)
+    INVALID_VALUE, // input 226 (0xE2)
+    INVALID_VALUE, // input 227 (0xE3)
+    INVALID_VALUE, // input 228 (0xE4)
+    INVALID_VALUE, // input 229 (0xE5)
+    INVALID_VALUE, // input 230 (0xE6)
+    INVALID_VALUE, // input 231 (0xE7)
+    INVALID_VALUE, // input 232 (0xE8)
+    INVALID_VALUE, // input 233 (0xE9)
+    INVALID_VALUE, // input 234 (0xEA)
+    INVALID_VALUE, // input 235 (0xEB)
+    INVALID_VALUE, // input 236 (0xEC)
+    INVALID_VALUE, // input 237 (0xED)
+    INVALID_VALUE, // input 238 (0xEE)
+    INVALID_VALUE, // input 239 (0xEF)
+    INVALID_VALUE, // input 240 (0xF0)
+    INVALID_VALUE, // input 241 (0xF1)
+    INVALID_VALUE, // input 242 (0xF2)
+    INVALID_VALUE, // input 243 (0xF3)
+    INVALID_VALUE, // input 244 (0xF4)
+    INVALID_VALUE, // input 245 (0xF5)
+    INVALID_VALUE, // input 246 (0xF6)
+    INVALID_VALUE, // input 247 (0xF7)
+    INVALID_VALUE, // input 248 (0xF8)
+    INVALID_VALUE, // input 249 (0xF9)
+    INVALID_VALUE, // input 250 (0xFA)
+    INVALID_VALUE, // input 251 (0xFB)
+    INVALID_VALUE, // input 252 (0xFC)
+    INVALID_VALUE, // input 253 (0xFD)
+    INVALID_VALUE, // input 254 (0xFE)
+    INVALID_VALUE, // input 255 (0xFF)
+];
+#[rustfmt::skip]
+pub const IMAP_MUTF7_ENCODE: &[u8; 64] = &[
+    65, // input 0 (0x0) => 'A' (0x41)
+    66, // input 1 (0x1) => 'B' (0x42)
+    67, // input 2 (0x2) => 'C' (0x43)
+    68, // input 3 (0x3) => 'D' (0x44)
+    69, // input 4 (0x4) => 'E' (0x45)
+    70, // input 5 (0x5) => 'F' (0x46)
+    71, // input 6 (0x6) => 'G' (0x47)
+    72, // input 7 (0x7) => 'H' (0x48)
+    73, // input 8 (0x8) => 'I' (0x49)
+    74, // input 9 (0x9) => 'J' (0x4A)
+    75, // input 10 (0xA) => 'K' (0x4B)
+    76, // input 11 (0xB) => 'L' (0x4C)
+    77, // input 12 (0xC) => 'M' (0x4D)
+    78, // input 13 (0xD) => 'N' (0x4E)
+    79, // input 14 (0xE) => 'O' (0x4F)
+    80, // input 15 (0xF) => 'P' (0x50)
+    81, // input 16 (0x10) => 'Q' (0x51)
+    82, // input 17 (0x11) => 'R' (0x52)
+    83, // input 18 (0x12) => 'S' (0x53)
+    84, // input 19 (0x13) => 'T' (0x54)
+    85, // input 20 (0x14) => 'U' (0x55)
+    86, // input 21 (0x15) => 'V' (0x56)
+    87, // input 22 (0x16) => 'W' (0x57)
+    88, // input 23 (0x17) => 'X' (0x58)
+    89, // input 24 (0x18) => 'Y' (0x59)
+    90, // input 25 (0x19) => 'Z' (0x5A)
+    97, // input 26 (0x1A) => 'a' (0x61)
+    98, // input 27 (0x1B) => 'b' (0x62)
+    99, // input 28 (0x1C) => 'c' (0x63)
+    100, // input 29 (0x1D) => 'd' (0x64)
+    101, // input 30 (0x1E) => 'e' (0x65)
+    102, // input 31 (0x1F) => 'f' (0x66)
+    103, // input 32 (0x20) => 'g' (0x67)
+    104, // input 33 (0x21) => 'h' (0x68)
+    105, // input 34 (0x22) => 'i' (0x69)
+    106, // input 35 (0x23) => 'j' (0x6A)
+    107, // input 36 (0x24) => 'k' (0x6B)
+    108, // input 37 (0x25) => 'l' (0x6C)
+    109, // input 38 (0x26) => 'm' (0x6D)
+    110, // input 39 (0x27) => 'n' (0x6E)
+    111, // input 40 (0x28) => 'o' (0x6F)
+    112, // input 41 (0x29) => 'p' (0x70)
+    113, // input 42 (0x2A) => 'q' (0x71)
+    114, // input 43 (0x2B) => 'r' (0x72)
+    115, // input 44 (0x2C) => 's' (0x73)
+    116, // input 45 (0x2D) => 't' (0x74)
+    117, // input 46 (0x2E) => 'u' (0x75)
+    118, // input 47 (0x2F) => 'v' (0x76)
+    119, // input 48 (0x30) => 'w' (0x77)
+    120, // input 49 (0x31) => 'x' (0x78)
+    121, // input 50 (0x32) => 'y' (0x79)
+    122, // input 51 (0x33) => 'z' (0x7A)
+    48, // input 52 (0x34) => '0' (0x30)
+    49, // input 53 (0x35) => '1' (0x31)
+    50, // input 54 (0x36) => '2' (0x32)
+    51, // input 55 (0x37) => '3' (0x33)
+    52, // input 56 (0x38) => '4' (0x34)
+    53, // input 57 (0x39) => '5' (0x35)
+    54, // input 58 (0x3A) => '6' (0x36)
+    55, // input 59 (0x3B) => '7' (0x37)
+    56, // input 60 (0x3C) => '8' (0x38)
+    57, // input 61 (0x3D) => '9' (0x39)
+    43, // input 62 (0x3E) => '+' (0x2B)
+    44, // input 63 (0x3F) => ',' (0x2C)
+];
+#[rustfmt::skip]
+pub const IMAP_MUTF7_DECODE: &[u8; 256] = &[
+    INVALID_VALUE, // input 0 (0x0)
+    INVALID_VALUE, // input 1 (0x1)
+    INVALID_VALUE, // input 2 (0x2)
+    INVALID_VALUE, // input 3 (0x3)
+    INVALID_VALUE, // input 4 (0x4)
+    INVALID_VALUE, // input 5 (0x5)
+    INVALID_VALUE, // input 6 (0x6)
+    INVALID_VALUE, // input 7 (0x7)
+    INVALID_VALUE, // input 8 (0x8)
+    INVALID_VALUE, // input 9 (0x9)
+    INVALID_VALUE, // input 10 (0xA)
+    INVALID_VALUE, // input 11 (0xB)
+    INVALID_VALUE, // input 12 (0xC)
+    INVALID_VALUE, // input 13 (0xD)
+    INVALID_VALUE, // input 14 (0xE)
+    INVALID_VALUE, // input 15 (0xF)
+    INVALID_VALUE, // input 16 (0x10)
+    INVALID_VALUE, // input 17 (0x11)
+    INVALID_VALUE, // input 18 (0x12)
+    INVALID_VALUE, // input 19 (0x13)
+    INVALID_VALUE, // input 20 (0x14)
+    INVALID_VALUE, // input 21 (0x15)
+    INVALID_VALUE, // input 22 (0x16)
+    INVALID_VALUE, // input 23 (0x17)
+    INVALID_VALUE, // input 24 (0x18)
+    INVALID_VALUE, // input 25 (0x19)
+    INVALID_VALUE, // input 26 (0x1A)
+    INVALID_VALUE, // input 27 (0x1B)
+    INVALID_VALUE, // input 28 (0x1C)
+    INVALID_VALUE, // input 29 (0x1D)
+    INVALID_VALUE, // input 30 (0x1E)
+    INVALID_VALUE, // input 31 (0x1F)
+    INVALID_VALUE, // input 32 (0x20)
+    INVALID_VALUE, // input 33 (0x21)
+    INVALID_VALUE, // input 34 (0x22)
+    INVALID_VALUE, // input 35 (0x23)
+    INVALID_VALUE, // input 36 (0x24)
+    INVALID_VALUE, // input 37 (0x25)
+    INVALID_VALUE, // input 38 (0x26)
+    INVALID_VALUE, // input 39 (0x27)
+    INVALID_VALUE, // input 40 (0x28)
+    INVALID_VALUE, // input 41 (0x29)
+    INVALID_VALUE, // input 42 (0x2A)
+    62, // input 43 (0x2B char '+') => 62 (0x3E)
+    63, // input 44 (0x2C char ',') => 63 (0x3F)
+    INVALID_VALUE, // input 45 (0x2D)
+    INVALID_VALUE, // input 46 (0x2E)
+    INVALID_VALUE, // input 47 (0x2F)
+    52, // input 48 (0x30 char '0') => 52 (0x34)
+    53, // input 49 (0x31 char '1') => 53 (0x35)
+    54, // input 50 (0x32 char '2') => 54 (0x36)
+    55, // input 51 (0x33 char '3') => 55 (0x37)
+    56, // input 52 (0x34 char '4') => 56 (0x38)
+    57, // input 53 (0x35 char '5') => 57 (0x39)
+    58, // input 54 (0x36 char '6') => 58 (0x3A)
+    59, // input 55 (0x37 char '7') => 59 (0x3B)
+    60, // input 56 (0x38 char '8') => 60 (0x3C)
+    61, // input 57 (0x39 char '9') => 61 (0x3D)
+    INVALID_VALUE, // input 58 (0x3A)
+    INVALID_VALUE, // input 59 (0x3B)
+    INVALID_VALUE, // input 60 (0x3C)
+    INVALID_VALUE, // input 61 (0x3D)
+    INVALID_VALUE, // input 62 (0x3E)
+    INVALID_VALUE, // input 63 (0x3F)
+    INVALID_VALUE, // input 64 (0x40)
+    0, // input 65 (0x41 char 'A') => 0 (0x0)
+    1, // input 66 (0x42 char 'B') => 1 (0x1)
+    2, // input 67 (0x43 char 'C') => 2 (0x2)
+    3, // input 68 (0x44 char 'D') => 3 (0x3)
+    4, // input 69 (0x45 char 'E') => 4 (0x4)
+    5, // input 70 (0x46 char 'F') => 5 (0x5)
+    6, // input 71 (0x47 char 'G') => 6 (0x6)
+    7, // input 72 (0x48 char 'H') => 7 (0x7)
+    8, // input 73 (0x49 char 'I') => 8 (0x8)
+    9, // input 74 (0x4A char 'J') => 9 (0x9)
+    10, // input 75 (0x4B char 'K') => 10 (0xA)
+    11, // input 76 (0x4C char 'L') => 11 (0xB)
+    12, // input 77 (0x4D char 'M') => 12 (0xC)
+    13, // input 78 (0x4E char 'N') => 13 (0xD)
+    14, // input 79 (0x4F char 'O') => 14 (0xE)
+    15, // input 80 (0x50 char 'P') => 15 (0xF)
+    16, // input 81 (0x51 char 'Q') => 16 (0x10)
+    17, // input 82 (0x52 char 'R') => 17 (0x11)
+    18, // input 83 (0x53 char 'S') => 18 (0x12)
+    19, // input 84 (0x54 char 'T') => 19 (0x13)
+    20, // input 85 (0x55 char 'U') => 20 (0x14)
+    21, // input 86 (0x56 char 'V') => 21 (0x15)
+    22, // input 87 (0x57 char 'W') => 22 (0x16)
+    23, // input 88 (0x58 char 'X') => 23 (0x17)
+    24, // input 89 (0x59 char 'Y') => 24 (0x18)
+    25, // input 90 (0x5A char 'Z') => 25 (0x19)
+    INVALID_VALUE, // input 91 (0x5B)
+    INVALID_VALUE, // input 92 (0x5C)
+    INVALID_VALUE, // input 93 (0x5D)
+    INVALID_VALUE, // input 94 (0x5E)
+    INVALID_VALUE, // input 95 (0x5F)
+    INVALID_VALUE, // input 96 (0x60)
+    26, // input 97 (0x61 char 'a') => 26 (0x1A)
+    27, // input 98 (0x62 char 'b') => 27 (0x1B)
+    28, // input 99 (0x63 char 'c') => 28 (0x1C)
+    29, // input 100 (0x64 char 'd') => 29 (0x1D)
+    30, // input 101 (0x65 char 'e') => 30 (0x1E)
+    31, // input 102 (0x66 char 'f') => 31 (0x1F)
+    32, // input 103 (0x67 char 'g') => 32 (0x20)
+    33, // input 104 (0x68 char 'h') => 33 (0x21)
+    34, // input 105 (0x69 char 'i') => 34 (0x22)
+    35, // input 106 (0x6A char 'j') => 35 (0x23)
+    36, // input 107 (0x6B char 'k') => 36 (0x24)
+    37, // input 108 (0x6C char 'l') => 37 (0x25)
+    38, // input 109 (0x6D char 'm') => 38 (0x26)
+    39, // input 110 (0x6E char 'n') => 39 (0x27)
+    40, // input 111 (0x6F char 'o') => 40 (0x28)
+    41, // input 112 (0x70 char 'p') => 41 (0x29)
+    42, // input 113 (0x71 char 'q') => 42 (0x2A)
+    43, // input 114 (0x72 char 'r') => 43 (0x2B)
+    44, // input 115 (0x73 char 's') => 44 (0x2C)
+    45, // input 116 (0x74 char 't') => 45 (0x2D)
+    46, // input 117 (0x75 char 'u') => 46 (0x2E)
+    47, // input 118 (0x76 char 'v') => 47 (0x2F)
+    48, // input 119 (0x77 char 'w') => 48 (0x30)
+    49, // input 120 (0x78 char 'x') => 49 (0x31)
+    50, // input 121 (0x79 char 'y') => 50 (0x32)
+    51, // input 122 (0x7A char 'z') => 51 (0x33)
+    INVALID_VALUE, // input 123 (0x7B)
+    INVALID_VALUE, // input 124 (0x7C)
+    INVALID_VALUE, // input 125 (0x7D)
+    INVALID_VALUE, // input 126 (0x7E)
+    INVALID_VALUE, // input 127 (0x7F)
+    INVALID_VALUE, // input 128 (0x80)
+    INVALID_VALUE, // input 129 (0x81)
+    INVALID_VALUE, // input 130 (0x82)
+    INVALID_VALUE, // input 131 (0x83)
+    INVALID_VALUE, // input 132 (0x84)
+    INVALID_VALUE, // input 133 (0x85)
+    INVALID_VALUE, // input 134 (0x86)
+    INVALID_VALUE, // input 135 (0x87)
+    INVALID_VALUE, // input 136 (0x88)
+    INVALID_VALUE, // input 137 (0x89)
+    INVALID_VALUE, // input 138 (0x8A)
+    INVALID_VALUE, // input 139 (0x8B)
+    INVALID_VALUE, // input 140 (0x8C)
+    INVALID_VALUE, // input 141 (0x8D)
+    INVALID_VALUE, // input 142 (0x8E)
+    INVALID_VALUE, // input 143 (0x8F)
+    INVALID_VALUE, // input 144 (0x90)
+    INVALID_VALUE, // input 145 (0x91)
+    INVALID_VALUE, // input 146 (0x92)
+    INVALID_VALUE, // input 147 (0x93)
+    INVALID_VALUE, // input 148 (0x94)
+    INVALID_VALUE, // input 149 (0x95)
+    INVALID_VALUE, // input 150 (0x96)
+    INVALID_VALUE, // input 151 (0x97)
+    INVALID_VALUE, // input 152 (0x98)
+    INVALID_VALUE, // input 153 (0x99)
+    INVALID_VALUE, // input 154 (0x9A)
+    INVALID_VALUE, // input 155 (0x9B)
+    INVALID_VALUE, // input 156 (0x9C)
+    INVALID_VALUE, // input 157 (0x9D)
+    INVALID_VALUE, // input 158 (0x9E)
+    INVALID_VALUE, // input 159 (0x9F)
+    INVALID_VALUE, // input 160 (0xA0)
+    INVALID_VALUE, // input 161 (0xA1)
+    INVALID_VALUE, // input 162 (0xA2)
+    INVALID_VALUE, // input 163 (0xA3)
+    INVALID_VALUE, // input 164 (0xA4)
+    INVALID_VALUE, // input 165 (0xA5)
+    INVALID_VALUE, // input 166 (0xA6)
+    INVALID_VALUE, // input 167 (0xA7)
+    INVALID_VALUE, // input 168 (0xA8)
+    INVALID_VALUE, // input 169 (0xA9)
+    INVALID_VALUE, // input 170 (0xAA)
+    INVALID_VALUE, // input 171 (0xAB)
+    INVALID_VALUE, // input 172 (0xAC)
+    INVALID_VALUE, // input 173 (0xAD)
+    INVALID_VALUE, // input 174 (0xAE)
+    INVALID_VALUE, // input 175 (0xAF)
+    INVALID_VALUE, // input 176 (0xB0)
+    INVALID_VALUE, // input 177 (0xB1)
+    INVALID_VALUE, // input 178 (0xB2)
+    INVALID_VALUE, // input 179 (0xB3)
+    INVALID_VALUE, // input 180 (0xB4)
+    INVALID_VALUE, // input 181 (0xB5)
+    INVALID_VALUE, // input 182 (0xB6)
+    INVALID_VALUE, // input 183 (0xB7)
+    INVALID_VALUE, // input 184 (0xB8)
+    INVALID_VALUE, // input 185 (0xB9)
+    INVALID_VALUE, // input 186 (0xBA)
+    INVALID_VALUE, // input 187 (0xBB)
+    INVALID_VALUE, // input 188 (0xBC)
+    INVALID_VALUE, // input 189 (0xBD)
+    INVALID_VALUE, // input 190 (0xBE)
+    INVALID_VALUE, // input 191 (0xBF)
+    INVALID_VALUE, // input 192 (0xC0)
+    INVALID_VALUE, // input 193 (0xC1)
+    INVALID_VALUE, // input 194 (0xC2)
+    INVALID_VALUE, // input 195 (0xC3)
+    INVALID_VALUE, // input 196 (0xC4)
+    INVALID_VALUE, // input 197 (0xC5)
+    INVALID_VALUE, // input 198 (0xC6)
+    INVALID_VALUE, // input 199 (0xC7)
+    INVALID_VALUE, // input 200 (0xC8)
+    INVALID_VALUE, // input 201 (0xC9)
+    INVALID_VALUE, // input 202 (0xCA)
+    INVALID_VALUE, // input 203 (0xCB)
+    INVALID_VALUE, // input 204 (0xCC)
+    INVALID_VALUE, // input 205 (0xCD)
+    INVALID_VALUE, // input 206 (0xCE)
+    INVALID_VALUE, // input 207 (0xCF)
+    INVALID_VALUE, // input 208 (0xD0)
+    INVALID_VALUE, // input 209 (0xD1)
+    INVALID_VALUE, // input 210 (0xD2)
+    INVALID_VALUE, // input 211 (0xD3)
+    INVALID_VALUE, // input 212 (0xD4)
+    INVALID_VALUE, // input 213 (0xD5)
+    INVALID_VALUE, // input 214 (0xD6)
+    INVALID_VALUE, // input 215 (0xD7)
+    INVALID_VALUE, // input 216 (0xD8)
+    INVALID_VALUE, // input 217 (0xD9)
+    INVALID_VALUE, // input 218 (0xDA)
+    INVALID_VALUE, // input 219 (0xDB)
+    INVALID_VALUE, // input 220 (0xDC)
+    INVALID_VALUE, // input 221 (0xDD)
+    INVALID_VALUE, // input 222 (0xDE)
+    INVALID_VALUE, // input 223 (0xDF)
+    INVALID_VALUE, // input 224 (0xE0)
+    INVALID_VALUE, // input 225 (0xE1)
+    INVALID_VALUE, // input 226 (0xE2)
+    INVALID_VALUE, // input 227 (0xE3)
+    INVALID_VALUE, // input 228 (0xE4)
+    INVALID_VALUE, // input 229 (0xE5)
+    INVALID_VALUE, // input 230 (0xE6)
+    INVALID_VALUE, // input 231 (0xE7)
+    INVALID_VALUE, // input 232 (0xE8)
+    INVALID_VALUE, // input 233 (0xE9)
+    INVALID_VALUE, // input 234 (0xEA)
+    INVALID_VALUE, // input 235 (0xEB)
+    INVALID_VALUE, // input 236 (0xEC)
+    INVALID_VALUE, // input 237 (0xED)
+    INVALID_VALUE, // input 238 (0xEE)
+    INVALID_VALUE, // input 239 (0xEF)
+    INVALID_VALUE, // input 240 (0xF0)
+    INVALID_VALUE, // input 241 (0xF1)
+    INVALID_VALUE, // input 242 (0xF2)
+    INVALID_VALUE, // input 243 (0xF3)
+    INVALID_VALUE, // input 244 (0xF4)
+    INVALID_VALUE, // input 245 (0xF5)
+    INVALID_VALUE, // input 246 (0xF6)
+    INVALID_VALUE, // input 247 (0xF7)
+    INVALID_VALUE, // input 248 (0xF8)
+    INVALID_VALUE, // input 249 (0xF9)
+    INVALID_VALUE, // input 250 (0xFA)
+    INVALID_VALUE, // input 251 (0xFB)
+    INVALID_VALUE, // input 252 (0xFC)
+    INVALID_VALUE, // input 253 (0xFD)
+    INVALID_VALUE, // input 254 (0xFE)
+    INVALID_VALUE, // input 255 (0xFF)
+];
+#[rustfmt::skip]
+pub const BINHEX_ENCODE: &[u8; 64] = &[
+    33, // input 0 (0x0) => '!' (0x21)
+    34, // input 1 (0x1) => '"' (0x22)
+    35, // input 2 (0x2) => '#' (0x23)
+    36, // input 3 (0x3) => '$' (0x24)
+    37, // input 4 (0x4) => '%' (0x25)
+    38, // input 5 (0x5) => '&' (0x26)
+    39, // input 6 (0x6) => ''' (0x27)
+    40, // input 7 (0x7) => '(' (0x28)
+    41, // input 8 (0x8) => ')' (0x29)
+    42, // input 9 (0x9) => '*' (0x2A)
+    43, // input 10 (0xA) => '+' (0x2B)
+    44, // input 11 (0xB) => ',' (0x2C)
+    45, // input 12 (0xC) => '-' (0x2D)
+    48, // input 13 (0xD) => '0' (0x30)
+    49, // input 14 (0xE) => '1' (0x31)
+    50, // input 15 (0xF) => '2' (0x32)
+    51, // input 16 (0x10) => '3' (0x33)
+    52, // input 17 (0x11) => '4' (0x34)
+    53, // input 18 (0x12) => '5' (0x35)
+    54, // input 19 (0x13) => '6' (0x36)
+    55, // input 20 (0x14) => '7' (0x37)
+    56, // input 21 (0x15) => '8' (0x38)
+    57, // input 22 (0x16) => '9' (0x39)
+    64, // input 23 (0x17) => '@' (0x40)
+    65, // input 24 (0x18) => 'A' (0x41)
+    66, // input 25 (0x19) => 'B' (0x42)
+    67, // input 26 (0x1A) => 'C' (0x43)
+    68, // input 27 (0x1B) => 'D' (0x44)
+    69, // input 28 (0x1C) => 'E' (0x45)
+    70, // input 29 (0x1D) => 'F' (0x46)
+    71, // input 30 (0x1E) => 'G' (0x47)
+    72, // input 31 (0x1F) => 'H' (0x48)
+    73, // input 32 (0x20) => 'I' (0x49)
+    74, // input 33 (0x21) => 'J' (0x4A)
+    75, // input 34 (0x22) => 'K' (0x4B)
+    76, // input 35 (0x23) => 'L' (0x4C)
+    77, // input 36 (0x24) => 'M' (0x4D)
+    78, // input 37 (0x25) => 'N' (0x4E)
+    80, // input 38 (0x26) => 'P' (0x50)
+    81, // input 39 (0x27) => 'Q' (0x51)
+    82, // input 40 (0x28) => 'R' (0x52)
+    83, // input 41 (0x29) => 'S' (0x53)
+    84, // input 42 (0x2A) => 'T' (0x54)
+    85, // input 43 (0x2B) => 'U' (0x55)
+    86, // input 44 (0x2C) => 'V' (0x56)
+    88, // input 45 (0x2D) => 'X' (0x58)
+    89, // input 46 (0x2E) => 'Y' (0x59)
+    90, // input 47 (0x2F) => 'Z' (0x5A)
+    91, // input 48 (0x30) => '[' (0x5B)
+    96, // input 49 (0x31) => '`' (0x60)
+    97, // input 50 (0x32) => 'a' (0x61)
+    98, // input 51 (0x33) => 'b' (0x62)
+    99, // input 52 (0x34) => 'c' (0x63)
+    100, // input 53 (0x35) => 'd' (0x64)
+    101, // input 54 (0x36) => 'e' (0x65)
+    104, // input 55 (0x37) => 'h' (0x68)
+    105, // input 56 (0x38) => 'i' (0x69)
+    106, // input 57 (0x39) => 'j' (0x6A)
+    107, // input 58 (0x3A) => 'k' (0x6B)
+    108, // input 59 (0x3B) => 'l' (0x6C)
+    109, // input 60 (0x3C) => 'm' (0x6D)
+    112, // input 61 (0x3D) => 'p' (0x70)
+    113, // input 62 (0x3E) => 'q' (0x71)
+    114, // input 63 (0x3F) => 'r' (0x72)
+];
+#[rustfmt::skip]
+pub const BINHEX_DECODE: &[u8; 256] = &[
+    INVALID_VALUE, // input 0 (0x0)
+    INVALID_VALUE, // input 1 (0x1)
+    INVALID_VALUE, // input 2 (0x2)
+    INVALID_VALUE, // input 3 (0x3)
+    INVALID_VALUE, // input 4 (0x4)
+    INVALID_VALUE, // input 5 (0x5)
+    INVALID_VALUE, // input 6 (0x6)
+    INVALID_VALUE, // input 7 (0x7)
+    INVALID_VALUE, // input 8 (0x8)
+    INVALID_VALUE, // input 9 (0x9)
+    INVALID_VALUE, // input 10 (0xA)
+    INVALID_VALUE, // input 11 (0xB)
+    INVALID_VALUE, // input 12 (0xC)
+    INVALID_VALUE, // input 13 (0xD)
+    INVALID_VALUE, // input 14 (0xE)
+    INVALID_VALUE, // input 15 (0xF)
+    INVALID_VALUE, // input 16 (0x10)
+    INVALID_VALUE, // input 17 (0x11)
+    INVALID_VALUE, // input 18 (0x12)
+    INVALID_VALUE, // input 19 (0x13)
+    INVALID_VALUE, // input 20 (0x14)
+    INVALID_VALUE, // input 21 (0x15)
+    INVALID_VALUE, // input 22 (0x16)
+    INVALID_VALUE, // input 23 (0x17)
+    INVALID_VALUE, // input 24 (0x18)
+    INVALID_VALUE, // input 25 (0x19)
+    INVALID_VALUE, // input 26 (0x1A)
+    INVALID_VALUE, // input 27 (0x1B)
+    INVALID_VALUE, // input 28 (0x1C)
+    INVALID_VALUE, // input 29 (0x1D)
+    INVALID_VALUE, // input 30 (0x1E)
+    INVALID_VALUE, // input 31 (0x1F)
+    INVALID_VALUE, // input 32 (0x20)
+    0, // input 33 (0x21 char '!') => 0 (0x0)
+    1, // input 34 (0x22 char '"') => 1 (0x1)
+    2, // input 35 (0x23 char '#') => 2 (0x2)
+    3, // input 36 (0x24 char '$') => 3 (0x3)
+    4, // input 37 (0x25 char '%') => 4 (0x4)
+    5, // input 38 (0x26 char '&') => 5 (0x5)
+    6, // input 39 (0x27 char ''') => 6 (0x6)
+    7, // input 40 (0x28 char '(') => 7 (0x7)
+    8, // input 41 (0x29 char ')') => 8 (0x8)
+    9, // input 42 (0x2A char '*') => 9 (0x9)
+    10, // input 43 (0x2B char '+') => 10 (0xA)
+    11, // input 44 (0x2C char ',') => 11 (0xB)
+    12, // input 45 (0x2D char '-') => 12 (0xC)
+    INVALID_VALUE, // input 46 (0x2E)
+    INVALID_VALUE, // input 47 (0x2F)
+    13, // input 48 (0x30 char '0') => 13 (0xD)
+    14, // input 49 (0x31 char '1') => 14 (0xE)
+    15, // input 50 (0x32 char '2') => 15 (0xF)
+    16, // input 51 (0x33 char '3') => 16 (0x10)
+    17, // input 52 (0x34 char '4') => 17 (0x11)
+    18, // input 53 (0x35 char '5') => 18 (0x12)
+    19, // input 54 (0x36 char '6') => 19 (0x13)
+    20, // input 55 (0x37 char '7') => 20 (0x14)
+    21, // input 56 (0x38 char '8') => 21 (0x15)
+    22, // input 57 (0x39 char '9') => 22 (0x16)
+    INVALID_VALUE, // input 58 (0x3A)
+    INVALID_VALUE, // input 59 (0x3B)
+    INVALID_VALUE, // input 60 (0x3C)
+    INVALID_VALUE, // input 61 (0x3D)
+    INVALID_VALUE, // input 62 (0x3E)
+    INVALID_VALUE, // input 63 (0x3F)
+    23, // input 64 (0x40 char '@') => 23 (0x17)
+    24, // input 65 (0x41 char 'A') => 24 (0x18)
+    25, // input 66 (0x42 char 'B') => 25 (0x19)
+    26, // input 67 (0x43 char 'C') => 26 (0x1A)
+    27, // input 68 (0x44 char 'D') => 27 (0x1B)
+    28, // input 69 (0x45 char 'E') => 28 (0x1C)
+    29, // input 70 (0x46 char 'F') => 29 (0x1D)
+    30, // input 71 (0x47 char 'G') => 30 (0x1E)
+    31, // input 72 (0x48 char 'H') => 31 (0x1F)
+    32, // input 73 (0x49 char 'I') => 32 (0x20)
+    33, // input 74 (0x4A char 'J') => 33 (0x21)
+    34, // input 75 (0x4B char 'K') => 34 (0x22)
+    35, // input 76 (0x4C char 'L') => 35 (0x23)
+    36, // input 77 (0x4D char 'M') => 36 (0x24)
+    37, // input 78 (0x4E char 'N') => 37 (0x25)
+    INVALID_VALUE, // input 79 (0x4F)
+    38, // input 80 (0x50 char 'P') => 38 (0x26)
+    39, // input 81 (0x51 char 'Q') => 39 (0x27)
+    40, // input 82 (0x52 char 'R') => 40 (0x28)
+    41, // input 83 (0x53 char 'S') => 41 (0x29)
+    42, // input 84 (0x54 char 'T') => 42 (0x2A)
+    43, // input 85 (0x55 char 'U') => 43 (0x2B)
+    44, // input 86 (0x56 char 'V') => 44 (0x2C)
+    INVALID_VALUE, // input 87 (0x57)
+    45, // input 88 (0x58 char 'X') => 45 (0x2D)
+    46, // input 89 (0x59 char 'Y') => 46 (0x2E)
+    47, // input 90 (0x5A char 'Z') => 47 (0x2F)
+    48, // input 91 (0x5B char '[') => 48 (0x30)
+    INVALID_VALUE, // input 92 (0x5C)
+    INVALID_VALUE, // input 93 (0x5D)
+    INVALID_VALUE, // input 94 (0x5E)
+    INVALID_VALUE, // input 95 (0x5F)
+    49, // input 96 (0x60 char '`') => 49 (0x31)
+    50, // input 97 (0x61 char 'a') => 50 (0x32)
+    51, // input 98 (0x62 char 'b') => 51 (0x33)
+    52, // input 99 (0x63 char 'c') => 52 (0x34)
+    53, // input 100 (0x64 char 'd') => 53 (0x35)
+    54, // input 101 (0x65 char 'e') => 54 (0x36)
+    INVALID_VALUE, // input 102 (0x66)
+    INVALID_VALUE, // input 103 (0x67)
+    55, // input 104 (0x68 char 'h') => 55 (0x37)
+    56, // input 105 (0x69 char 'i') => 56 (0x38)
+    57, // input 106 (0x6A char 'j') => 57 (0x39)
+    58, // input 107 (0x6B char 'k') => 58 (0x3A)
+    59, // input 108 (0x6C char 'l') => 59 (0x3B)
+    60, // input 109 (0x6D char 'm') => 60 (0x3C)
+    INVALID_VALUE, // input 110 (0x6E)
+    INVALID_VALUE, // input 111 (0x6F)
+    61, // input 112 (0x70 char 'p') => 61 (0x3D)
+    62, // input 113 (0x71 char 'q') => 62 (0x3E)
+    63, // input 114 (0x72 char 'r') => 63 (0x3F)
+    INVALID_VALUE, // input 115 (0x73)
+    INVALID_VALUE, // input 116 (0x74)
+    INVALID_VALUE, // input 117 (0x75)
+    INVALID_VALUE, // input 118 (0x76)
+    INVALID_VALUE, // input 119 (0x77)
+    INVALID_VALUE, // input 120 (0x78)
+    INVALID_VALUE, // input 121 (0x79)
+    INVALID_VALUE, // input 122 (0x7A)
+    INVALID_VALUE, // input 123 (0x7B)
+    INVALID_VALUE, // input 124 (0x7C)
+    INVALID_VALUE, // input 125 (0x7D)
+    INVALID_VALUE, // input 126 (0x7E)
+    INVALID_VALUE, // input 127 (0x7F)
+    INVALID_VALUE, // input 128 (0x80)
+    INVALID_VALUE, // input 129 (0x81)
+    INVALID_VALUE, // input 130 (0x82)
+    INVALID_VALUE, // input 131 (0x83)
+    INVALID_VALUE, // input 132 (0x84)
+    INVALID_VALUE, // input 133 (0x85)
+    INVALID_VALUE, // input 134 (0x86)
+    INVALID_VALUE, // input 135 (0x87)
+    INVALID_VALUE, // input 136 (0x88)
+    INVALID_VALUE, // input 137 (0x89)
+    INVALID_VALUE, // input 138 (0x8A)
+    INVALID_VALUE, // input 139 (0x8B)
+    INVALID_VALUE, // input 140 (0x8C)
+    INVALID_VALUE, // input 141 (0x8D)
+    INVALID_VALUE, // input 142 (0x8E)
+    INVALID_VALUE, // input 143 (0x8F)
+    INVALID_VALUE, // input 144 (0x90)
+    INVALID_VALUE, // input 145 (0x91)
+    INVALID_VALUE, // input 146 (0x92)
+    INVALID_VALUE, // input 147 (0x93)
+    INVALID_VALUE, // input 148 (0x94)
+    INVALID_VALUE, // input 149 (0x95)
+    INVALID_VALUE, // input 150 (0x96)
+    INVALID_VALUE, // input 151 (0x97)
+    INVALID_VALUE, // input 152 (0x98)
+    INVALID_VALUE, // input 153 (0x99)
+    INVALID_VALUE, // input 154 (0x9A)
+    INVALID_VALUE, // input 155 (0x9B)
+    INVALID_VALUE, // input 156 (0x9C)
+    INVALID_VALUE, // input 157 (0x9D)
+    INVALID_VALUE, // input 158 (0x9E)
+    INVALID_VALUE, // input 159 (0x9F)
+    INVALID_VALUE, // input 160 (0xA0)
+    INVALID_VALUE, // input 161 (0xA1)
+    INVALID_VALUE, // input 162 (0xA2)
+    INVALID_VALUE, // input 163 (0xA3)
+    INVALID_VALUE, // input 164 (0xA4)
+    INVALID_VALUE, // input 165 (0xA5)
+    INVALID_VALUE, // input 166 (0xA6)
+    INVALID_VALUE, // input 167 (0xA7)
+    INVALID_VALUE, // input 168 (0xA8)
+    INVALID_VALUE, // input 169 (0xA9)
+    INVALID_VALUE, // input 170 (0xAA)
+    INVALID_VALUE, // input 171 (0xAB)
+    INVALID_VALUE, // input 172 (0xAC)
+    INVALID_VALUE, // input 173 (0xAD)
+    INVALID_VALUE, // input 174 (0xAE)
+    INVALID_VALUE, // input 175 (0xAF)
+    INVALID_VALUE, // input 176 (0xB0)
+    INVALID_VALUE, // input 177 (0xB1)
+    INVALID_VALUE, // input 178 (0xB2)
+    INVALID_VALUE, // input 179 (0xB3)
+    INVALID_VALUE, // input 180 (0xB4)
+    INVALID_VALUE, // input 181 (0xB5)
+    INVALID_VALUE, // input 182 (0xB6)
+    INVALID_VALUE, // input 183 (0xB7)
+    INVALID_VALUE, // input 184 (0xB8)
+    INVALID_VALUE, // input 185 (0xB9)
+    INVALID_VALUE, // input 186 (0xBA)
+    INVALID_VALUE, // input 187 (0xBB)
+    INVALID_VALUE, // input 188 (0xBC)
+    INVALID_VALUE, // input 189 (0xBD)
+    INVALID_VALUE, // input 190 (0xBE)
+    INVALID_VALUE, // input 191 (0xBF)
+    INVALID_VALUE, // input 192 (0xC0)
+    INVALID_VALUE, // input 193 (0xC1)
+    INVALID_VALUE, // input 194 (0xC2)
+    INVALID_VALUE, // input 195 (0xC3)
+    INVALID_VALUE, // input 196 (0xC4)
+    INVALID_VALUE, // input 197 (0xC5)
+    INVALID_VALUE, // input 198 (0xC6)
+    INVALID_VALUE, // input 199 (0xC7)
+    INVALID_VALUE, // input 200 (0xC8)
+    INVALID_VALUE, // input 201 (0xC9)
+    INVALID_VALUE, // input 202 (0xCA)
+    INVALID_VALUE, // input 203 (0xCB)
+    INVALID_VALUE, // input 204 (0xCC)
+    INVALID_VALUE, // input 205 (0xCD)
+    INVALID_VALUE, // input 206 (0xCE)
+    INVALID_VALUE, // input 207 (0xCF)
+    INVALID_VALUE, // input 208 (0xD0)
+    INVALID_VALUE, // input 209 (0xD1)
+    INVALID_VALUE, // input 210 (0xD2)
+    INVALID_VALUE, // input 211 (0xD3)
+    INVALID_VALUE, // input 212 (0xD4)
+    INVALID_VALUE, // input 213 (0xD5)
+    INVALID_VALUE, // input 214 (0xD6)
+    INVALID_VALUE, // input 215 (0xD7)
+    INVALID_VALUE, // input 216 (0xD8)
+    INVALID_VALUE, // input 217 (0xD9)
+    INVALID_VALUE, // input 218 (0xDA)
+    INVALID_VALUE, // input 219 (0xDB)
+    INVALID_VALUE, // input 220 (0xDC)
+    INVALID_VALUE, // input 221 (0xDD)
+    INVALID_VALUE, // input 222 (0xDE)
+    INVALID_VALUE, // input 223 (0xDF)
+    INVALID_VALUE, // input 224 (0xE0)
+    INVALID_VALUE, // input 225 (0xE1)
+    INVALID_VALUE, // input 226 (0xE2)
+    INVALID_VALUE, // input 227 (0xE3)
+    INVALID_VALUE, // input 228 (0xE4)
+    INVALID_VALUE, // input 229 (0xE5)
+    INVALID_VALUE, // input 230 (0xE6)
+    INVALID_VALUE, // input 231 (0xE7)
+    INVALID_VALUE, // input 232 (0xE8)
+    INVALID_VALUE, // input 233 (0xE9)
+    INVALID_VALUE, // input 234 (0xEA)
+    INVALID_VALUE, // input 235 (0xEB)
+    INVALID_VALUE, // input 236 (0xEC)
+    INVALID_VALUE, // input 237 (0xED)
+    INVALID_VALUE, // input 238 (0xEE)
+    INVALID_VALUE, // input 239 (0xEF)
+    INVALID_VALUE, // input 240 (0xF0)
+    INVALID_VALUE, // input 241 (0xF1)
+    INVALID_VALUE, // input 242 (0xF2)
+    INVALID_VALUE, // input 243 (0xF3)
+    INVALID_VALUE, // input 244 (0xF4)
+    INVALID_VALUE, // input 245 (0xF5)
+    INVALID_VALUE, // input 246 (0xF6)
+    INVALID_VALUE, // input 247 (0xF7)
+    INVALID_VALUE, // input 248 (0xF8)
+    INVALID_VALUE, // input 249 (0xF9)
+    INVALID_VALUE, // input 250 (0xFA)
+    INVALID_VALUE, // input 251 (0xFB)
+    INVALID_VALUE, // input 252 (0xFC)
+    INVALID_VALUE, // input 253 (0xFD)
+    INVALID_VALUE, // input 254 (0xFE)
+    INVALID_VALUE, // input 255 (0xFF)
+];
diff --git a/vendor/base64/src/tests.rs b/vendor/base64/src/tests.rs
new file mode 100644
index 000000000..88748de79
--- /dev/null
+++ b/vendor/base64/src/tests.rs
@@ -0,0 +1,81 @@
+use crate::{decode_config, encode::encoded_size, encode_config_buf, CharacterSet, Config};
+
+use std::str;
+
+use rand::{
+    distributions::{Distribution, Uniform},
+    seq::SliceRandom,
+    FromEntropy, Rng,
+};
+
+#[test]
+fn roundtrip_random_config_short() {
+    // exercise the slower encode/decode routines that operate on shorter buffers more vigorously
+    roundtrip_random_config(Uniform::new(0, 50), 10_000);
+}
+
+#[test]
+fn roundtrip_random_config_long() {
+    roundtrip_random_config(Uniform::new(0, 1000), 10_000);
+}
+
+pub fn assert_encode_sanity(encoded: &str, config: Config, input_len: usize) {
+    let input_rem = input_len % 3;
+    let expected_padding_len = if input_rem > 0 {
+        if config.pad {
+            3 - input_rem
+        } else {
+            0
+        }
+    } else {
+        0
+    };
+
+    let expected_encoded_len = encoded_size(input_len, config).unwrap();
+
+    assert_eq!(expected_encoded_len, encoded.len());
+
+    let padding_len = encoded.chars().filter(|&c| c == '=').count();
+
+    assert_eq!(expected_padding_len, padding_len);
+
+    let _ = str::from_utf8(encoded.as_bytes()).expect("Base64 should be valid utf8");
+}
+
+fn roundtrip_random_config(input_len_range: Uniform<usize>, iterations: u32) {
+    let mut input_buf: Vec<u8> = Vec::new();
+    let mut encoded_buf = String::new();
+    let mut rng = rand::rngs::SmallRng::from_entropy();
+
+    for _ in 0..iterations {
+        input_buf.clear();
+        encoded_buf.clear();
+
+        let input_len = input_len_range.sample(&mut rng);
+
+        let config = random_config(&mut rng);
+
+        for _ in 0..input_len {
+            input_buf.push(rng.gen());
+        }
+
+        encode_config_buf(&input_buf, config, &mut encoded_buf);
+
+        assert_encode_sanity(&encoded_buf, config, input_len);
+
+        assert_eq!(input_buf, decode_config(&encoded_buf, config).unwrap());
+    }
+}
+
+pub fn random_config<R: Rng>(rng: &mut R) -> Config {
+    const CHARSETS: &[CharacterSet] = &[
+        CharacterSet::UrlSafe,
+        CharacterSet::Standard,
+        CharacterSet::Crypt,
+        CharacterSet::ImapMutf7,
+        CharacterSet::BinHex,
+    ];
+    let charset = *CHARSETS.choose(rng).unwrap();
+
+    Config::new(charset, rng.gen())
+}
diff --git a/vendor/base64/src/write/encoder.rs b/vendor/base64/src/write/encoder.rs
new file mode 100644
index 000000000..4bb57eb06
--- /dev/null
+++ b/vendor/base64/src/write/encoder.rs
@@ -0,0 +1,381 @@
+use crate::encode::encode_to_slice;
+use crate::{encode_config_slice, Config};
+use std::{
+    cmp, fmt,
+    io::{ErrorKind, Result, Write},
+};
+
+pub(crate) const BUF_SIZE: usize = 1024;
+/// The most bytes whose encoding will fit in `BUF_SIZE`
+const MAX_INPUT_LEN: usize = BUF_SIZE / 4 * 3;
+// 3 bytes of input = 4 bytes of base64, always (because we don't allow line wrapping)
+const MIN_ENCODE_CHUNK_SIZE: usize = 3;
+
+/// A `Write` implementation that base64 encodes data before delegating to the wrapped writer.
+///
+/// Because base64 has special handling for the end of the input data (padding, etc), there's a
+/// `finish()` method on this type that encodes any leftover input bytes and adds padding if
+/// appropriate. It's called automatically when deallocated (see the `Drop` implementation), but
+/// any error that occurs when invoking the underlying writer will be suppressed. If you want to
+/// handle such errors, call `finish()` yourself.
+///
+/// # Examples
+///
+/// ```
+/// use std::io::Write;
+///
+/// // use a vec as the simplest possible `Write` -- in real code this is probably a file, etc.
+/// let mut enc = base64::write::EncoderWriter::new(Vec::new(), base64::STANDARD);
+///
+/// // handle errors as you normally would
+/// enc.write_all(b"asdf").unwrap();
+///
+/// // could leave this out to be called by Drop, if you don't care
+/// // about handling errors or getting the delegate writer back
+/// let delegate = enc.finish().unwrap();
+///
+/// // base64 was written to the writer
+/// assert_eq!(b"YXNkZg==", &delegate[..]);
+///
+/// ```
+///
+/// # Panics
+///
+/// Calling `write()` (or related methods) or `finish()` after `finish()` has completed without
+/// error is invalid and will panic.
+///
+/// # Errors
+///
+/// Base64 encoding itself does not generate errors, but errors from the wrapped writer will be
+/// returned as per the contract of `Write`.
+///
+/// # Performance
+///
+/// It has some minor performance loss compared to encoding slices (a couple percent).
+/// It does not do any heap allocation.
+pub struct EncoderWriter<W: Write> {
+    config: Config,
+    /// Where encoded data is written to. It's an Option as it's None immediately before Drop is
+    /// called so that finish() can return the underlying writer. None implies that finish() has
+    /// been called successfully.
+    delegate: Option<W>,
+    /// Holds a partial chunk, if any, after the last `write()`, so that we may then fill the chunk
+    /// with the next `write()`, encode it, then proceed with the rest of the input normally.
+    extra_input: [u8; MIN_ENCODE_CHUNK_SIZE],
+    /// How much of `extra` is occupied, in `[0, MIN_ENCODE_CHUNK_SIZE]`.
+    extra_input_occupied_len: usize,
+    /// Buffer to encode into. May hold leftover encoded bytes from a previous write call that the underlying writer
+    /// did not write last time.
+    output: [u8; BUF_SIZE],
+    /// How much of `output` is occupied with encoded data that couldn't be written last time
+    output_occupied_len: usize,
+    /// panic safety: don't write again in destructor if writer panicked while we were writing to it
+    panicked: bool,
+}
+
+impl<W: Write> fmt::Debug for EncoderWriter<W> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        write!(
+            f,
+            "extra_input: {:?} extra_input_occupied_len:{:?} output[..5]: {:?} output_occupied_len: {:?}",
+            self.extra_input,
+            self.extra_input_occupied_len,
+            &self.output[0..5],
+            self.output_occupied_len
+        )
+    }
+}
+
+impl<W: Write> EncoderWriter<W> {
+    /// Create a new encoder that will write to the provided delegate writer `w`.
+    pub fn new(w: W, config: Config) -> EncoderWriter<W> {
+        EncoderWriter {
+            config,
+            delegate: Some(w),
+            extra_input: [0u8; MIN_ENCODE_CHUNK_SIZE],
+            extra_input_occupied_len: 0,
+            output: [0u8; BUF_SIZE],
+            output_occupied_len: 0,
+            panicked: false,
+        }
+    }
+
+    /// Encode all remaining buffered data and write it, including any trailing incomplete input
+    /// triples and associated padding.
+    ///
+    /// Once this succeeds, no further writes or calls to this method are allowed.
+    ///
+    /// This may write to the delegate writer multiple times if the delegate writer does not accept
+    /// all input provided to its `write` each invocation.
+    ///
+    /// If you don't care about error handling, it is not necessary to call this function, as the
+    /// equivalent finalization is done by the Drop impl.
+    ///
+    /// Returns the writer that this was constructed around.
+    ///
+    /// # Errors
+    ///
+    /// The first error that is not of `ErrorKind::Interrupted` will be returned.
+    pub fn finish(&mut self) -> Result<W> {
+        // If we could consume self in finish(), we wouldn't have to worry about this case, but
+        // finish() is retryable in the face of I/O errors, so we can't consume here.
+        if self.delegate.is_none() {
+            panic!("Encoder has already had finish() called")
+        };
+
+        self.write_final_leftovers()?;
+
+        let writer = self.delegate.take().expect("Writer must be present");
+
+        Ok(writer)
+    }
+
+    /// Write any remaining buffered data to the delegate writer.
+    fn write_final_leftovers(&mut self) -> Result<()> {
+        if self.delegate.is_none() {
+            // finish() has already successfully called this, and we are now in drop() with a None
+            // writer, so just no-op
+            return Ok(());
+        }
+
+        self.write_all_encoded_output()?;
+
+        if self.extra_input_occupied_len > 0 {
+            let encoded_len = encode_config_slice(
+                &self.extra_input[..self.extra_input_occupied_len],
+                self.config,
+                &mut self.output[..],
+            );
+
+            self.output_occupied_len = encoded_len;
+
+            self.write_all_encoded_output()?;
+
+            // write succeeded, do not write the encoding of extra again if finish() is retried
+            self.extra_input_occupied_len = 0;
+        }
+
+        Ok(())
+    }
+
+    /// Write as much of the encoded output to the delegate writer as it will accept, and store the
+    /// leftovers to be attempted at the next write() call. Updates `self.output_occupied_len`.
+    ///
+    /// # Errors
+    ///
+    /// Errors from the delegate writer are returned. In the case of an error,
+    /// `self.output_occupied_len` will not be updated, as errors from `write` are specified to mean
+    /// that no write took place.
+    fn write_to_delegate(&mut self, current_output_len: usize) -> Result<()> {
+        self.panicked = true;
+        let res = self
+            .delegate
+            .as_mut()
+            .expect("Writer must be present")
+            .write(&self.output[..current_output_len]);
+        self.panicked = false;
+
+        res.map(|consumed| {
+            debug_assert!(consumed <= current_output_len);
+
+            if consumed < current_output_len {
+                self.output_occupied_len = current_output_len.checked_sub(consumed).unwrap();
+                // If we're blocking on I/O, the minor inefficiency of copying bytes to the
+                // start of the buffer is the least of our concerns...
+                // Rotate moves more than we need to, but copy_within isn't stabilized yet.
+                self.output.rotate_left(consumed);
+            } else {
+                self.output_occupied_len = 0;
+            }
+        })
+    }
+
+    /// Write all buffered encoded output. If this returns `Ok`, `self.output_occupied_len` is `0`.
+    ///
+    /// This is basically write_all for the remaining buffered data but without the undesirable
+    /// abort-on-`Ok(0)` behavior.
+    ///
+    /// # Errors
+    ///
+    /// Any error emitted by the delegate writer abort the write loop and is returned, unless it's
+    /// `Interrupted`, in which case the error is ignored and writes will continue.
+    fn write_all_encoded_output(&mut self) -> Result<()> {
+        while self.output_occupied_len > 0 {
+            let remaining_len = self.output_occupied_len;
+            match self.write_to_delegate(remaining_len) {
+                // try again on interrupts ala write_all
+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}
+                // other errors return
+                Err(e) => return Err(e),
+                // success no-ops because remaining length is already updated
+                Ok(_) => {}
+            };
+        }
+
+        debug_assert_eq!(0, self.output_occupied_len);
+        Ok(())
+    }
+}
+
+impl<W: Write> Write for EncoderWriter<W> {
+    /// Encode input and then write to the delegate writer.
+    ///
+    /// Under non-error circumstances, this returns `Ok` with the value being the number of bytes
+    /// of `input` consumed. The value may be `0`, which interacts poorly with `write_all`, which
+    /// interprets `Ok(0)` as an error, despite it being allowed by the contract of `write`. See
+    /// <https://github.com/rust-lang/rust/issues/56889> for more on that.
+    ///
+    /// If the previous call to `write` provided more (encoded) data than the delegate writer could
+    /// accept in a single call to its `write`, the remaining data is buffered. As long as buffered
+    /// data is present, subsequent calls to `write` will try to write the remaining buffered data
+    /// to the delegate and return either `Ok(0)` -- and therefore not consume any of `input` -- or
+    /// an error.
+    ///
+    /// # Errors
+    ///
+    /// Any errors emitted by the delegate writer are returned.
+    fn write(&mut self, input: &[u8]) -> Result<usize> {
+        if self.delegate.is_none() {
+            panic!("Cannot write more after calling finish()");
+        }
+
+        if input.is_empty() {
+            return Ok(0);
+        }
+
+        // The contract of `Write::write` places some constraints on this implementation:
+        // - a call to `write()` represents at most one call to a wrapped `Write`, so we can't
+        // iterate over the input and encode multiple chunks.
+        // - Errors mean that "no bytes were written to this writer", so we need to reset the
+        // internal state to what it was before the error occurred
+
+        // before reading any input, write any leftover encoded output from last time
+        if self.output_occupied_len > 0 {
+            let current_len = self.output_occupied_len;
+            return self
+                .write_to_delegate(current_len)
+                // did not read any input
+                .map(|_| 0);
+        }
+
+        debug_assert_eq!(0, self.output_occupied_len);
+
+        // how many bytes, if any, were read into `extra` to create a triple to encode
+        let mut extra_input_read_len = 0;
+        let mut input = input;
+
+        let orig_extra_len = self.extra_input_occupied_len;
+
+        let mut encoded_size = 0;
+        // always a multiple of MIN_ENCODE_CHUNK_SIZE
+        let mut max_input_len = MAX_INPUT_LEN;
+
+        // process leftover un-encoded input from last write
+        if self.extra_input_occupied_len > 0 {
+            debug_assert!(self.extra_input_occupied_len < 3);
+            if input.len() + self.extra_input_occupied_len >= MIN_ENCODE_CHUNK_SIZE {
+                // Fill up `extra`, encode that into `output`, and consume as much of the rest of
+                // `input` as possible.
+                // We could write just the encoding of `extra` by itself but then we'd have to
+                // return after writing only 4 bytes, which is inefficient if the underlying writer
+                // would make a syscall.
+                extra_input_read_len = MIN_ENCODE_CHUNK_SIZE - self.extra_input_occupied_len;
+                debug_assert!(extra_input_read_len > 0);
+                // overwrite only bytes that weren't already used. If we need to rollback extra_len
+                // (when the subsequent write errors), the old leading bytes will still be there.
+                self.extra_input[self.extra_input_occupied_len..MIN_ENCODE_CHUNK_SIZE]
+                    .copy_from_slice(&input[0..extra_input_read_len]);
+
+                let len = encode_to_slice(
+                    &self.extra_input[0..MIN_ENCODE_CHUNK_SIZE],
+                    &mut self.output[..],
+                    self.config.char_set.encode_table(),
+                );
+                debug_assert_eq!(4, len);
+
+                input = &input[extra_input_read_len..];
+
+                // consider extra to be used up, since we encoded it
+                self.extra_input_occupied_len = 0;
+                // don't clobber where we just encoded to
+                encoded_size = 4;
+                // and don't read more than can be encoded
+                max_input_len = MAX_INPUT_LEN - MIN_ENCODE_CHUNK_SIZE;
+
+            // fall through to normal encoding
+            } else {
+                // `extra` and `input` are non empty, but `|extra| + |input| < 3`, so there must be
+                // 1 byte in each.
+                debug_assert_eq!(1, input.len());
+                debug_assert_eq!(1, self.extra_input_occupied_len);
+
+                self.extra_input[self.extra_input_occupied_len] = input[0];
+                self.extra_input_occupied_len += 1;
+                return Ok(1);
+            };
+        } else if input.len() < MIN_ENCODE_CHUNK_SIZE {
+            // `extra` is empty, and `input` fits inside it
+            self.extra_input[0..input.len()].copy_from_slice(input);
+            self.extra_input_occupied_len = input.len();
+            return Ok(input.len());
+        };
+
+        // either 0 or 1 complete chunks encoded from extra
+        debug_assert!(encoded_size == 0 || encoded_size == 4);
+        debug_assert!(
+            // didn't encode extra input
+            MAX_INPUT_LEN == max_input_len
+                // encoded one triple
+                || MAX_INPUT_LEN == max_input_len + MIN_ENCODE_CHUNK_SIZE
+        );
+
+        // encode complete triples only
+        let input_complete_chunks_len = input.len() - (input.len() % MIN_ENCODE_CHUNK_SIZE);
+        let input_chunks_to_encode_len = cmp::min(input_complete_chunks_len, max_input_len);
+        debug_assert_eq!(0, max_input_len % MIN_ENCODE_CHUNK_SIZE);
+        debug_assert_eq!(0, input_chunks_to_encode_len % MIN_ENCODE_CHUNK_SIZE);
+
+        encoded_size += encode_to_slice(
+            &input[..(input_chunks_to_encode_len)],
+            &mut self.output[encoded_size..],
+            self.config.char_set.encode_table(),
+        );
+
+        // not updating `self.output_occupied_len` here because if the below write fails, it should
+        // "never take place" -- the buffer contents we encoded are ignored and perhaps retried
+        // later, if the consumer chooses.
+
+        self.write_to_delegate(encoded_size)
+            // no matter whether we wrote the full encoded buffer or not, we consumed the same
+            // input
+            .map(|_| extra_input_read_len + input_chunks_to_encode_len)
+            .map_err(|e| {
+                // in case we filled and encoded `extra`, reset extra_len
+                self.extra_input_occupied_len = orig_extra_len;
+
+                e
+            })
+    }
+
+    /// Because this is usually treated as OK to call multiple times, it will *not* flush any
+    /// incomplete chunks of input or write padding.
+    /// # Errors
+    ///
+    /// The first error that is not of [`ErrorKind::Interrupted`] will be returned.
+    fn flush(&mut self) -> Result<()> {
+        self.write_all_encoded_output()?;
+        self.delegate
+            .as_mut()
+            .expect("Writer must be present")
+            .flush()
+    }
+}
+
+impl<W: Write> Drop for EncoderWriter<W> {
+    fn drop(&mut self) {
+        if !self.panicked {
+            // like `BufWriter`, ignore errors during drop
+            let _ = self.write_final_leftovers();
+        }
+    }
+}
diff --git a/vendor/base64/src/write/encoder_string_writer.rs b/vendor/base64/src/write/encoder_string_writer.rs
new file mode 100644
index 000000000..58b1c0ab1
--- /dev/null
+++ b/vendor/base64/src/write/encoder_string_writer.rs
@@ -0,0 +1,176 @@
+use super::encoder::EncoderWriter;
+use crate::Config;
+use std::io;
+use std::io::Write;
+
+/// A `Write` implementation that base64-encodes data using the provided config and accumulates the
+/// resulting base64 in memory, which is then exposed as a String via `into_inner()`.
+///
+/// # Examples
+///
+/// Buffer base64 in a new String:
+///
+/// ```
+/// use std::io::Write;
+///
+/// let mut enc = base64::write::EncoderStringWriter::new(base64::STANDARD);
+///
+/// enc.write_all(b"asdf").unwrap();
+///
+/// // get the resulting String
+/// let b64_string = enc.into_inner();
+///
+/// assert_eq!("YXNkZg==", &b64_string);
+/// ```
+///
+/// Or, append to an existing String:
+///
+/// ```
+/// use std::io::Write;
+///
+/// let mut buf = String::from("base64: ");
+///
+/// let mut enc = base64::write::EncoderStringWriter::from(&mut buf, base64::STANDARD);
+///
+/// enc.write_all(b"asdf").unwrap();
+///
+/// // release the &mut reference on buf
+/// let _ = enc.into_inner();
+///
+/// assert_eq!("base64: YXNkZg==", &buf);
+/// ```
+///
+/// # Panics
+///
+/// Calling `write()` (or related methods) or `finish()` after `finish()` has completed without
+/// error is invalid and will panic.
+///
+/// # Performance
+///
+/// Because it has to validate that the base64 is UTF-8, it is about 80% as fast as writing plain
+/// bytes to a `io::Write`.
+pub struct EncoderStringWriter<S: StrConsumer> {
+    encoder: EncoderWriter<Utf8SingleCodeUnitWriter<S>>,
+}
+
+impl<S: StrConsumer> EncoderStringWriter<S> {
+    /// Create a EncoderStringWriter that will append to the provided `StrConsumer`.
+    pub fn from(str_consumer: S, config: Config) -> Self {
+        EncoderStringWriter {
+            encoder: EncoderWriter::new(Utf8SingleCodeUnitWriter { str_consumer }, config),
+        }
+    }
+
+    /// Encode all remaining buffered data, including any trailing incomplete input triples and
+    /// associated padding.
+    ///
+    /// Once this succeeds, no further writes or calls to this method are allowed.
+    ///
+    /// Returns the base64-encoded form of the accumulated written data.
+    pub fn into_inner(mut self) -> S {
+        self.encoder
+            .finish()
+            .expect("Writing to a Vec<u8> should never fail")
+            .str_consumer
+    }
+}
+
+impl EncoderStringWriter<String> {
+    /// Create a EncoderStringWriter that will encode into a new String with the provided config.
+    pub fn new(config: Config) -> Self {
+        EncoderStringWriter::from(String::new(), config)
+    }
+}
+
+impl<S: StrConsumer> Write for EncoderStringWriter<S> {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        self.encoder.write(buf)
+    }
+
+    fn flush(&mut self) -> io::Result<()> {
+        self.encoder.flush()
+    }
+}
+
+/// An abstraction around consuming `str`s produced by base64 encoding.
+pub trait StrConsumer {
+    /// Consume the base64 encoded data in `buf`
+    fn consume(&mut self, buf: &str);
+}
+
+/// As for io::Write, `StrConsumer` is implemented automatically for `&mut S`.
+impl<S: StrConsumer + ?Sized> StrConsumer for &mut S {
+    fn consume(&mut self, buf: &str) {
+        (**self).consume(buf)
+    }
+}
+
+/// Pushes the str onto the end of the String
+impl StrConsumer for String {
+    fn consume(&mut self, buf: &str) {
+        self.push_str(buf)
+    }
+}
+
+/// A `Write` that only can handle bytes that are valid single-byte UTF-8 code units.
+///
+/// This is safe because we only use it when writing base64, which is always valid UTF-8.
+struct Utf8SingleCodeUnitWriter<S: StrConsumer> {
+    str_consumer: S,
+}
+
+impl<S: StrConsumer> io::Write for Utf8SingleCodeUnitWriter<S> {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        // Because we expect all input to be valid utf-8 individual bytes, we can encode any buffer
+        // length
+        let s = std::str::from_utf8(buf).expect("Input must be valid UTF-8");
+
+        self.str_consumer.consume(s);
+
+        Ok(buf.len())
+    }
+
+    fn flush(&mut self) -> io::Result<()> {
+        // no op
+        Ok(())
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use crate::encode_config_buf;
+    use crate::tests::random_config;
+    use crate::write::encoder_string_writer::EncoderStringWriter;
+    use rand::Rng;
+    use std::io::Write;
+
+    #[test]
+    fn every_possible_split_of_input() {
+        let mut rng = rand::thread_rng();
+        let mut orig_data = Vec::<u8>::new();
+        let mut normal_encoded = String::new();
+
+        let size = 5_000;
+
+        for i in 0..size {
+            orig_data.clear();
+            normal_encoded.clear();
+
+            for _ in 0..size {
+                orig_data.push(rng.gen());
+            }
+
+            let config = random_config(&mut rng);
+            encode_config_buf(&orig_data, config, &mut normal_encoded);
+
+            let mut stream_encoder = EncoderStringWriter::new(config);
+            // Write the first i bytes, then the rest
+            stream_encoder.write_all(&orig_data[0..i]).unwrap();
+            stream_encoder.write_all(&orig_data[i..]).unwrap();
+
+            let stream_encoded = stream_encoder.into_inner();
+
+            assert_eq!(normal_encoded, stream_encoded);
+        }
+    }
+}
diff --git a/vendor/base64/src/write/encoder_tests.rs b/vendor/base64/src/write/encoder_tests.rs
new file mode 100644
index 000000000..09b4d3a21
--- /dev/null
+++ b/vendor/base64/src/write/encoder_tests.rs
@@ -0,0 +1,568 @@
+use super::EncoderWriter;
+use crate::tests::random_config;
+use crate::{encode_config, encode_config_buf, STANDARD_NO_PAD, URL_SAFE};
+
+use std::io::{Cursor, Write};
+use std::{cmp, io, str};
+
+use rand::Rng;
+
+#[test]
+fn encode_three_bytes() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, URL_SAFE);
+
+        let sz = enc.write(b"abc").unwrap();
+        assert_eq!(sz, 3);
+    }
+    assert_eq!(&c.get_ref()[..], encode_config("abc", URL_SAFE).as_bytes());
+}
+
+#[test]
+fn encode_nine_bytes_two_writes() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, URL_SAFE);
+
+        let sz = enc.write(b"abcdef").unwrap();
+        assert_eq!(sz, 6);
+        let sz = enc.write(b"ghi").unwrap();
+        assert_eq!(sz, 3);
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abcdefghi", URL_SAFE).as_bytes()
+    );
+}
+
+#[test]
+fn encode_one_then_two_bytes() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, URL_SAFE);
+
+        let sz = enc.write(b"a").unwrap();
+        assert_eq!(sz, 1);
+        let sz = enc.write(b"bc").unwrap();
+        assert_eq!(sz, 2);
+    }
+    assert_eq!(&c.get_ref()[..], encode_config("abc", URL_SAFE).as_bytes());
+}
+
+#[test]
+fn encode_one_then_five_bytes() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, URL_SAFE);
+
+        let sz = enc.write(b"a").unwrap();
+        assert_eq!(sz, 1);
+        let sz = enc.write(b"bcdef").unwrap();
+        assert_eq!(sz, 5);
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abcdef", URL_SAFE).as_bytes()
+    );
+}
+
+#[test]
+fn encode_1_2_3_bytes() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, URL_SAFE);
+
+        let sz = enc.write(b"a").unwrap();
+        assert_eq!(sz, 1);
+        let sz = enc.write(b"bc").unwrap();
+        assert_eq!(sz, 2);
+        let sz = enc.write(b"def").unwrap();
+        assert_eq!(sz, 3);
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abcdef", URL_SAFE).as_bytes()
+    );
+}
+
+#[test]
+fn encode_with_padding() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, URL_SAFE);
+
+        enc.write_all(b"abcd").unwrap();
+
+        enc.flush().unwrap();
+    }
+    assert_eq!(&c.get_ref()[..], encode_config("abcd", URL_SAFE).as_bytes());
+}
+
+#[test]
+fn encode_with_padding_multiple_writes() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, URL_SAFE);
+
+        assert_eq!(1, enc.write(b"a").unwrap());
+        assert_eq!(2, enc.write(b"bc").unwrap());
+        assert_eq!(3, enc.write(b"def").unwrap());
+        assert_eq!(1, enc.write(b"g").unwrap());
+
+        enc.flush().unwrap();
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abcdefg", URL_SAFE).as_bytes()
+    );
+}
+
+#[test]
+fn finish_writes_extra_byte() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, URL_SAFE);
+
+        assert_eq!(6, enc.write(b"abcdef").unwrap());
+
+        // will be in extra
+        assert_eq!(1, enc.write(b"g").unwrap());
+
+        // 1 trailing byte = 2 encoded chars
+        let _ = enc.finish().unwrap();
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abcdefg", URL_SAFE).as_bytes()
+    );
+}
+
+#[test]
+fn write_partial_chunk_encodes_partial_chunk() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, STANDARD_NO_PAD);
+
+        // nothing encoded yet
+        assert_eq!(2, enc.write(b"ab").unwrap());
+        // encoded here
+        let _ = enc.finish().unwrap();
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("ab", STANDARD_NO_PAD).as_bytes()
+    );
+    assert_eq!(3, c.get_ref().len());
+}
+
+#[test]
+fn write_1_chunk_encodes_complete_chunk() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, STANDARD_NO_PAD);
+
+        assert_eq!(3, enc.write(b"abc").unwrap());
+        let _ = enc.finish().unwrap();
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abc", STANDARD_NO_PAD).as_bytes()
+    );
+    assert_eq!(4, c.get_ref().len());
+}
+
+#[test]
+fn write_1_chunk_and_partial_encodes_only_complete_chunk() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, STANDARD_NO_PAD);
+
+        // "d" not written
+        assert_eq!(3, enc.write(b"abcd").unwrap());
+        let _ = enc.finish().unwrap();
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abc", STANDARD_NO_PAD).as_bytes()
+    );
+    assert_eq!(4, c.get_ref().len());
+}
+
+#[test]
+fn write_2_partials_to_exactly_complete_chunk_encodes_complete_chunk() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, STANDARD_NO_PAD);
+
+        assert_eq!(1, enc.write(b"a").unwrap());
+        assert_eq!(2, enc.write(b"bc").unwrap());
+        let _ = enc.finish().unwrap();
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abc", STANDARD_NO_PAD).as_bytes()
+    );
+    assert_eq!(4, c.get_ref().len());
+}
+
+#[test]
+fn write_partial_then_enough_to_complete_chunk_but_not_complete_another_chunk_encodes_complete_chunk_without_consuming_remaining(
+) {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, STANDARD_NO_PAD);
+
+        assert_eq!(1, enc.write(b"a").unwrap());
+        // doesn't consume "d"
+        assert_eq!(2, enc.write(b"bcd").unwrap());
+        let _ = enc.finish().unwrap();
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abc", STANDARD_NO_PAD).as_bytes()
+    );
+    assert_eq!(4, c.get_ref().len());
+}
+
+#[test]
+fn write_partial_then_enough_to_complete_chunk_and_another_chunk_encodes_complete_chunks() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, STANDARD_NO_PAD);
+
+        assert_eq!(1, enc.write(b"a").unwrap());
+        // completes partial chunk, and another chunk
+        assert_eq!(5, enc.write(b"bcdef").unwrap());
+        let _ = enc.finish().unwrap();
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abcdef", STANDARD_NO_PAD).as_bytes()
+    );
+    assert_eq!(8, c.get_ref().len());
+}
+
+#[test]
+fn write_partial_then_enough_to_complete_chunk_and_another_chunk_and_another_partial_chunk_encodes_only_complete_chunks(
+) {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, STANDARD_NO_PAD);
+
+        assert_eq!(1, enc.write(b"a").unwrap());
+        // completes partial chunk, and another chunk, with one more partial chunk that's not
+        // consumed
+        assert_eq!(5, enc.write(b"bcdefe").unwrap());
+        let _ = enc.finish().unwrap();
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("abcdef", STANDARD_NO_PAD).as_bytes()
+    );
+    assert_eq!(8, c.get_ref().len());
+}
+
+#[test]
+fn drop_calls_finish_for_you() {
+    let mut c = Cursor::new(Vec::new());
+    {
+        let mut enc = EncoderWriter::new(&mut c, STANDARD_NO_PAD);
+        assert_eq!(1, enc.write(b"a").unwrap());
+    }
+    assert_eq!(
+        &c.get_ref()[..],
+        encode_config("a", STANDARD_NO_PAD).as_bytes()
+    );
+    assert_eq!(2, c.get_ref().len());
+}
+
+#[test]
+fn every_possible_split_of_input() {
+    let mut rng = rand::thread_rng();
+    let mut orig_data = Vec::<u8>::new();
+    let mut stream_encoded = Vec::<u8>::new();
+    let mut normal_encoded = String::new();
+
+    let size = 5_000;
+
+    for i in 0..size {
+        orig_data.clear();
+        stream_encoded.clear();
+        normal_encoded.clear();
+
+        for _ in 0..size {
+            orig_data.push(rng.gen());
+        }
+
+        let config = random_config(&mut rng);
+        encode_config_buf(&orig_data, config, &mut normal_encoded);
+
+        {
+            let mut stream_encoder = EncoderWriter::new(&mut stream_encoded, config);
+            // Write the first i bytes, then the rest
+            stream_encoder.write_all(&orig_data[0..i]).unwrap();
+            stream_encoder.write_all(&orig_data[i..]).unwrap();
+        }
+
+        assert_eq!(normal_encoded, str::from_utf8(&stream_encoded).unwrap());
+    }
+}
+
+#[test]
+fn encode_random_config_matches_normal_encode_reasonable_input_len() {
+    // choose up to 2 * buf size, so ~half the time it'll use a full buffer
+    do_encode_random_config_matches_normal_encode(super::encoder::BUF_SIZE * 2)
+}
+
+#[test]
+fn encode_random_config_matches_normal_encode_tiny_input_len() {
+    do_encode_random_config_matches_normal_encode(10)
+}
+
+#[test]
+fn retrying_writes_that_error_with_interrupted_works() {
+    let mut rng = rand::thread_rng();
+    let mut orig_data = Vec::<u8>::new();
+    let mut stream_encoded = Vec::<u8>::new();
+    let mut normal_encoded = String::new();
+
+    for _ in 0..1_000 {
+        orig_data.clear();
+        stream_encoded.clear();
+        normal_encoded.clear();
+
+        let orig_len: usize = rng.gen_range(100, 20_000);
+        for _ in 0..orig_len {
+            orig_data.push(rng.gen());
+        }
+
+        // encode the normal way
+        let config = random_config(&mut rng);
+        encode_config_buf(&orig_data, config, &mut normal_encoded);
+
+        // encode via the stream encoder
+        {
+            let mut interrupt_rng = rand::thread_rng();
+            let mut interrupting_writer = InterruptingWriter {
+                w: &mut stream_encoded,
+                rng: &mut interrupt_rng,
+                fraction: 0.8,
+            };
+
+            let mut stream_encoder = EncoderWriter::new(&mut interrupting_writer, config);
+            let mut bytes_consumed = 0;
+            while bytes_consumed < orig_len {
+                // use short inputs since we want to use `extra` a lot as that's what needs rollback
+                // when errors occur
+                let input_len: usize = cmp::min(rng.gen_range(0, 10), orig_len - bytes_consumed);
+
+                retry_interrupted_write_all(
+                    &mut stream_encoder,
+                    &orig_data[bytes_consumed..bytes_consumed + input_len],
+                )
+                .unwrap();
+
+                bytes_consumed += input_len;
+            }
+
+            loop {
+                let res = stream_encoder.finish();
+                match res {
+                    Ok(_) => break,
+                    Err(e) => match e.kind() {
+                        io::ErrorKind::Interrupted => continue,
+                        _ => Err(e).unwrap(), // bail
+                    },
+                }
+            }
+
+            assert_eq!(orig_len, bytes_consumed);
+        }
+
+        assert_eq!(normal_encoded, str::from_utf8(&stream_encoded).unwrap());
+    }
+}
+
+#[test]
+fn writes_that_only_write_part_of_input_and_sometimes_interrupt_produce_correct_encoded_data() {
+    let mut rng = rand::thread_rng();
+    let mut orig_data = Vec::<u8>::new();
+    let mut stream_encoded = Vec::<u8>::new();
+    let mut normal_encoded = String::new();
+
+    for _ in 0..1_000 {
+        orig_data.clear();
+        stream_encoded.clear();
+        normal_encoded.clear();
+
+        let orig_len: usize = rng.gen_range(100, 20_000);
+        for _ in 0..orig_len {
+            orig_data.push(rng.gen());
+        }
+
+        // encode the normal way
+        let config = random_config(&mut rng);
+        encode_config_buf(&orig_data, config, &mut normal_encoded);
+
+        // encode via the stream encoder
+        {
+            let mut partial_rng = rand::thread_rng();
+            let mut partial_writer = PartialInterruptingWriter {
+                w: &mut stream_encoded,
+                rng: &mut partial_rng,
+                full_input_fraction: 0.1,
+                no_interrupt_fraction: 0.1,
+            };
+
+            let mut stream_encoder = EncoderWriter::new(&mut partial_writer, config);
+            let mut bytes_consumed = 0;
+            while bytes_consumed < orig_len {
+                // use at most medium-length inputs to exercise retry logic more aggressively
+                let input_len: usize = cmp::min(rng.gen_range(0, 100), orig_len - bytes_consumed);
+
+                let res =
+                    stream_encoder.write(&orig_data[bytes_consumed..bytes_consumed + input_len]);
+
+                // retry on interrupt
+                match res {
+                    Ok(len) => bytes_consumed += len,
+                    Err(e) => match e.kind() {
+                        io::ErrorKind::Interrupted => continue,
+                        _ => {
+                            panic!("should not see other errors");
+                        }
+                    },
+                }
+            }
+
+            let _ = stream_encoder.finish().unwrap();
+
+            assert_eq!(orig_len, bytes_consumed);
+        }
+
+        assert_eq!(normal_encoded, str::from_utf8(&stream_encoded).unwrap());
+    }
+}
+
+/// Retry writes until all the data is written or an error that isn't Interrupted is returned.
+fn retry_interrupted_write_all<W: Write>(w: &mut W, buf: &[u8]) -> io::Result<()> {
+    let mut bytes_consumed = 0;
+
+    while bytes_consumed < buf.len() {
+        let res = w.write(&buf[bytes_consumed..]);
+
+        match res {
+            Ok(len) => bytes_consumed += len,
+            Err(e) => match e.kind() {
+                io::ErrorKind::Interrupted => continue,
+                _ => return Err(e),
+            },
+        }
+    }
+
+    Ok(())
+}
+
+fn do_encode_random_config_matches_normal_encode(max_input_len: usize) {
+    let mut rng = rand::thread_rng();
+    let mut orig_data = Vec::<u8>::new();
+    let mut stream_encoded = Vec::<u8>::new();
+    let mut normal_encoded = String::new();
+
+    for _ in 0..1_000 {
+        orig_data.clear();
+        stream_encoded.clear();
+        normal_encoded.clear();
+
+        let orig_len: usize = rng.gen_range(100, 20_000);
+        for _ in 0..orig_len {
+            orig_data.push(rng.gen());
+        }
+
+        // encode the normal way
+        let config = random_config(&mut rng);
+        encode_config_buf(&orig_data, config, &mut normal_encoded);
+
+        // encode via the stream encoder
+        {
+            let mut stream_encoder = EncoderWriter::new(&mut stream_encoded, config);
+            let mut bytes_consumed = 0;
+            while bytes_consumed < orig_len {
+                let input_len: usize =
+                    cmp::min(rng.gen_range(0, max_input_len), orig_len - bytes_consumed);
+
+                // write a little bit of the data
+                stream_encoder
+                    .write_all(&orig_data[bytes_consumed..bytes_consumed + input_len])
+                    .unwrap();
+
+                bytes_consumed += input_len;
+            }
+
+            let _ = stream_encoder.finish().unwrap();
+
+            assert_eq!(orig_len, bytes_consumed);
+        }
+
+        assert_eq!(normal_encoded, str::from_utf8(&stream_encoded).unwrap());
+    }
+}
+
+/// A `Write` implementation that returns Interrupted some fraction of the time, randomly.
+struct InterruptingWriter<'a, W: 'a + Write, R: 'a + Rng> {
+    w: &'a mut W,
+    rng: &'a mut R,
+    /// In [0, 1]. If a random number in [0, 1] is  `<= threshold`, `Write` methods will return
+    /// an `Interrupted` error
+    fraction: f64,
+}
+
+impl<'a, W: Write, R: Rng> Write for InterruptingWriter<'a, W, R> {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        if self.rng.gen_range(0.0, 1.0) <= self.fraction {
+            return Err(io::Error::new(io::ErrorKind::Interrupted, "interrupted"));
+        }
+
+        self.w.write(buf)
+    }
+
+    fn flush(&mut self) -> io::Result<()> {
+        if self.rng.gen_range(0.0, 1.0) <= self.fraction {
+            return Err(io::Error::new(io::ErrorKind::Interrupted, "interrupted"));
+        }
+
+        self.w.flush()
+    }
+}
+
+/// A `Write` implementation that sometimes will only write part of its input.
+struct PartialInterruptingWriter<'a, W: 'a + Write, R: 'a + Rng> {
+    w: &'a mut W,
+    rng: &'a mut R,
+    /// In [0, 1]. If a random number in [0, 1] is  `<= threshold`, `write()` will write all its
+    /// input. Otherwise, it will write a random substring
+    full_input_fraction: f64,
+    no_interrupt_fraction: f64,
+}
+
+impl<'a, W: Write, R: Rng> Write for PartialInterruptingWriter<'a, W, R> {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        if self.rng.gen_range(0.0, 1.0) > self.no_interrupt_fraction {
+            return Err(io::Error::new(io::ErrorKind::Interrupted, "interrupted"));
+        }
+
+        if self.rng.gen_range(0.0, 1.0) <= self.full_input_fraction || buf.len() == 0 {
+            // pass through the buf untouched
+            self.w.write(buf)
+        } else {
+            // only use a prefix of it
+            self.w
+                .write(&buf[0..(self.rng.gen_range(0, buf.len() - 1))])
+        }
+    }
+
+    fn flush(&mut self) -> io::Result<()> {
+        self.w.flush()
+    }
+}
diff --git a/vendor/base64/src/write/mod.rs b/vendor/base64/src/write/mod.rs
new file mode 100644
index 000000000..98cb48c4a
--- /dev/null
+++ b/vendor/base64/src/write/mod.rs
@@ -0,0 +1,8 @@
+//! Implementations of `io::Write` to transparently handle base64.
+mod encoder;
+mod encoder_string_writer;
+pub use self::encoder::EncoderWriter;
+pub use self::encoder_string_writer::EncoderStringWriter;
+
+#[cfg(test)]
+mod encoder_tests;
diff --git a/vendor/base64/tests/decode.rs b/vendor/base64/tests/decode.rs
new file mode 100644
index 000000000..282bccd9c
--- /dev/null
+++ b/vendor/base64/tests/decode.rs
@@ -0,0 +1,330 @@
+extern crate base64;
+
+use base64::*;
+
+mod helpers;
+
+use self::helpers::*;
+
+#[test]
+fn decode_rfc4648_0() {
+    compare_decode("", "");
+}
+
+#[test]
+fn decode_rfc4648_1() {
+    compare_decode("f", "Zg==");
+}
+
+#[test]
+fn decode_rfc4648_1_just_a_bit_of_padding() {
+    // allows less padding than required
+    compare_decode("f", "Zg=");
+}
+
+#[test]
+fn decode_rfc4648_1_no_padding() {
+    compare_decode("f", "Zg");
+}
+
+#[test]
+fn decode_rfc4648_2() {
+    compare_decode("fo", "Zm8=");
+}
+
+#[test]
+fn decode_rfc4648_2_no_padding() {
+    compare_decode("fo", "Zm8");
+}
+
+#[test]
+fn decode_rfc4648_3() {
+    compare_decode("foo", "Zm9v");
+}
+
+#[test]
+fn decode_rfc4648_4() {
+    compare_decode("foob", "Zm9vYg==");
+}
+
+#[test]
+fn decode_rfc4648_4_no_padding() {
+    compare_decode("foob", "Zm9vYg");
+}
+
+#[test]
+fn decode_rfc4648_5() {
+    compare_decode("fooba", "Zm9vYmE=");
+}
+
+#[test]
+fn decode_rfc4648_5_no_padding() {
+    compare_decode("fooba", "Zm9vYmE");
+}
+
+#[test]
+fn decode_rfc4648_6() {
+    compare_decode("foobar", "Zm9vYmFy");
+}
+
+#[test]
+fn decode_reject_null() {
+    assert_eq!(
+        DecodeError::InvalidByte(3, 0x0),
+        decode_config("YWx\0pY2U==", config_std_pad()).unwrap_err()
+    );
+}
+
+#[test]
+fn decode_single_pad_byte_after_2_chars_in_trailing_quad_ok() {
+    for num_quads in 0..25 {
+        let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+        s.push_str("Zg=");
+
+        let input_len = num_quads * 3 + 1;
+
+        // Since there are 3 bytes in the trailing quad, want to be sure this allows for the fact
+        // that it could be bad padding rather than assuming that it will decode to 2 bytes and
+        // therefore allow 1 extra round of fast decode logic (stage 1 / 2).
+
+        let mut decoded = Vec::new();
+        decoded.resize(input_len, 0);
+
+        assert_eq!(
+            input_len,
+            decode_config_slice(&s, STANDARD, &mut decoded).unwrap()
+        );
+    }
+}
+
+//this is a MAY in the rfc: https://tools.ietf.org/html/rfc4648#section-3.3
+#[test]
+fn decode_1_pad_byte_in_fast_loop_then_extra_padding_chunk_error() {
+    for num_quads in 0..25 {
+        let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+        s.push_str("YWxpY2U=====");
+
+        // since the first 8 bytes are handled in stage 1 or 2, the padding is detected as a
+        // generic invalid byte, not specifcally a padding issue.
+        // Could argue that the *next* padding byte (in the next quad) is technically the first
+        // erroneous one, but reporting that accurately is more complex and probably nobody cares
+        assert_eq!(
+            DecodeError::InvalidByte(num_quads * 4 + 7, b'='),
+            decode(&s).unwrap_err()
+        );
+    }
+}
+
+#[test]
+fn decode_2_pad_bytes_in_leftovers_then_extra_padding_chunk_error() {
+    for num_quads in 0..25 {
+        let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+        s.push_str("YWxpY2UABB====");
+
+        // 6 bytes (4 padding) after last 8-byte chunk, so it's decoded by stage 4.
+        // First padding byte is invalid.
+        assert_eq!(
+            DecodeError::InvalidByte(num_quads * 4 + 10, b'='),
+            decode(&s).unwrap_err()
+        );
+    }
+}
+
+#[test]
+fn decode_valid_bytes_after_padding_in_leftovers_error() {
+    for num_quads in 0..25 {
+        let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+        s.push_str("YWxpY2UABB=B");
+
+        // 4 bytes after last 8-byte chunk, so it's decoded by stage 4.
+        // First (and only) padding byte is invalid.
+        assert_eq!(
+            DecodeError::InvalidByte(num_quads * 4 + 10, b'='),
+            decode(&s).unwrap_err()
+        );
+    }
+}
+
+#[test]
+fn decode_absurd_pad_error() {
+    for num_quads in 0..25 {
+        let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+        s.push_str("==Y=Wx===pY=2U=====");
+
+        // Plenty of remaining bytes, so handled by stage 1 or 2.
+        // first padding byte
+        assert_eq!(
+            DecodeError::InvalidByte(num_quads * 4, b'='),
+            decode(&s).unwrap_err()
+        );
+    }
+}
+
+#[test]
+fn decode_extra_padding_after_1_pad_bytes_in_trailing_quad_returns_error() {
+    for num_quads in 0..25 {
+        let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+        s.push_str("EEE===");
+
+        // handled by stage 1, 2, or 4 depending on length
+        // first padding byte -- which would be legal if it was the only padding
+        assert_eq!(
+            DecodeError::InvalidByte(num_quads * 4 + 3, b'='),
+            decode(&s).unwrap_err()
+        );
+    }
+}
+
+#[test]
+fn decode_extra_padding_after_2_pad_bytes_in_trailing_quad_2_returns_error() {
+    for num_quads in 0..25 {
+        let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+        s.push_str("EE====");
+
+        // handled by stage 1, 2, or 4 depending on length
+        // first padding byte -- which would be legal if it was by itself
+        assert_eq!(
+            DecodeError::InvalidByte(num_quads * 4 + 2, b'='),
+            decode(&s).unwrap_err()
+        );
+    }
+}
+
+#[test]
+fn decode_start_quad_with_padding_returns_error() {
+    for num_quads in 0..25 {
+        // add enough padding to ensure that we'll hit all 4 stages at the different lengths
+        for pad_bytes in 1..32 {
+            let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+            let padding: String = std::iter::repeat("=").take(pad_bytes).collect();
+            s.push_str(&padding);
+
+            if pad_bytes % 4 == 1 {
+                // detected in early length check
+                assert_eq!(DecodeError::InvalidLength, decode(&s).unwrap_err());
+            } else {
+                // padding lengths 2 - 8 are handled by stage 4
+                // padding length >= 8 will hit at least one chunk at stages 1, 2, 3 at different
+                // prefix lengths
+                assert_eq!(
+                    DecodeError::InvalidByte(num_quads * 4, b'='),
+                    decode(&s).unwrap_err()
+                );
+            }
+        }
+    }
+}
+
+#[test]
+fn decode_padding_followed_by_non_padding_returns_error() {
+    for num_quads in 0..25 {
+        for pad_bytes in 0..31 {
+            let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+            let padding: String = std::iter::repeat("=").take(pad_bytes).collect();
+            s.push_str(&padding);
+            s.push_str("E");
+
+            if pad_bytes % 4 == 0 {
+                assert_eq!(DecodeError::InvalidLength, decode(&s).unwrap_err());
+            } else {
+                // pad len 1 - 8 will be handled by stage 4
+                // pad len 9 (suffix len 10) will have 8 bytes of padding handled by stage 3
+                // first padding byte
+                assert_eq!(
+                    DecodeError::InvalidByte(num_quads * 4, b'='),
+                    decode(&s).unwrap_err()
+                );
+            }
+        }
+    }
+}
+
+#[test]
+fn decode_one_char_in_quad_with_padding_error() {
+    for num_quads in 0..25 {
+        let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+        s.push_str("E=");
+
+        assert_eq!(
+            DecodeError::InvalidByte(num_quads * 4 + 1, b'='),
+            decode(&s).unwrap_err()
+        );
+
+        // more padding doesn't change the error
+        s.push_str("=");
+        assert_eq!(
+            DecodeError::InvalidByte(num_quads * 4 + 1, b'='),
+            decode(&s).unwrap_err()
+        );
+
+        s.push_str("=");
+        assert_eq!(
+            DecodeError::InvalidByte(num_quads * 4 + 1, b'='),
+            decode(&s).unwrap_err()
+        );
+    }
+}
+
+#[test]
+fn decode_one_char_in_quad_without_padding_error() {
+    for num_quads in 0..25 {
+        let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+        s.push('E');
+
+        assert_eq!(DecodeError::InvalidLength, decode(&s).unwrap_err());
+    }
+}
+
+#[test]
+fn decode_reject_invalid_bytes_with_correct_error() {
+    for length in 1..100 {
+        for index in 0_usize..length {
+            for invalid_byte in " \t\n\r\x0C\x0B\x00%*.".bytes() {
+                let prefix: String = std::iter::repeat("A").take(index).collect();
+                let suffix: String = std::iter::repeat("B").take(length - index - 1).collect();
+
+                let input = prefix + &String::from_utf8(vec![invalid_byte]).unwrap() + &suffix;
+                assert_eq!(
+                    length,
+                    input.len(),
+                    "length {} error position {}",
+                    length,
+                    index
+                );
+
+                if length % 4 == 1 && !suffix.is_empty() {
+                    assert_eq!(DecodeError::InvalidLength, decode(&input).unwrap_err());
+                } else {
+                    assert_eq!(
+                        DecodeError::InvalidByte(index, invalid_byte),
+                        decode(&input).unwrap_err()
+                    );
+                }
+            }
+        }
+    }
+}
+
+#[test]
+fn decode_imap() {
+    assert_eq!(
+        decode_config(b"+,,+", crate::IMAP_MUTF7),
+        decode_config(b"+//+", crate::STANDARD_NO_PAD)
+    );
+}
+
+#[test]
+fn decode_invalid_trailing_bytes() {
+    // The case of trailing newlines is common enough to warrant a test for a good error
+    // message.
+    assert_eq!(
+        Err(DecodeError::InvalidByte(8, b'\n')),
+        decode(b"Zm9vCg==\n")
+    );
+    // extra padding, however, is still InvalidLength
+    assert_eq!(Err(DecodeError::InvalidLength), decode(b"Zm9vCg==="));
+}
+
+fn config_std_pad() -> Config {
+    Config::new(CharacterSet::Standard, true)
+}
diff --git a/vendor/base64/tests/encode.rs b/vendor/base64/tests/encode.rs
new file mode 100644
index 000000000..0004be00f
--- /dev/null
+++ b/vendor/base64/tests/encode.rs
@@ -0,0 +1,105 @@
+extern crate base64;
+
+use base64::*;
+
+fn compare_encode(expected: &str, target: &[u8]) {
+    assert_eq!(expected, encode(target));
+}
+
+#[test]
+fn encode_rfc4648_0() {
+    compare_encode("", b"");
+}
+
+#[test]
+fn encode_rfc4648_1() {
+    compare_encode("Zg==", b"f");
+}
+
+#[test]
+fn encode_rfc4648_2() {
+    compare_encode("Zm8=", b"fo");
+}
+
+#[test]
+fn encode_rfc4648_3() {
+    compare_encode("Zm9v", b"foo");
+}
+
+#[test]
+fn encode_rfc4648_4() {
+    compare_encode("Zm9vYg==", b"foob");
+}
+
+#[test]
+fn encode_rfc4648_5() {
+    compare_encode("Zm9vYmE=", b"fooba");
+}
+
+#[test]
+fn encode_rfc4648_6() {
+    compare_encode("Zm9vYmFy", b"foobar");
+}
+
+#[test]
+fn encode_all_ascii() {
+    let mut ascii = Vec::<u8>::with_capacity(128);
+
+    for i in 0..128 {
+        ascii.push(i);
+    }
+
+    compare_encode(
+        "AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7P\
+         D0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn8\
+         =",
+        &ascii,
+    );
+}
+
+#[test]
+fn encode_all_bytes() {
+    let mut bytes = Vec::<u8>::with_capacity(256);
+
+    for i in 0..255 {
+        bytes.push(i);
+    }
+    bytes.push(255); //bug with "overflowing" ranges?
+
+    compare_encode(
+        "AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7P\
+         D0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn\
+         +AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6\
+         /wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/w==",
+        &bytes,
+    );
+}
+
+#[test]
+fn encode_all_bytes_url() {
+    let mut bytes = Vec::<u8>::with_capacity(256);
+
+    for i in 0..255 {
+        bytes.push(i);
+    }
+    bytes.push(255); //bug with "overflowing" ranges?
+
+    assert_eq!(
+        "AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0\
+         -P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn\
+         -AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq\
+         -wsbKztLW2t7i5uru8vb6_wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t_g4eLj5OXm5-jp6uvs7e7v8PHy\
+         8_T19vf4-fr7_P3-_w==",
+        encode_config(&bytes, URL_SAFE)
+    );
+}
+
+#[test]
+fn encode_url_safe_without_padding() {
+    let encoded = encode_config(b"alice", URL_SAFE_NO_PAD);
+    assert_eq!(&encoded, "YWxpY2U");
+    assert_eq!(
+        String::from_utf8(decode(&encoded).unwrap()).unwrap(),
+        "alice"
+    );
+}
diff --git a/vendor/base64/tests/helpers.rs b/vendor/base64/tests/helpers.rs
new file mode 100644
index 000000000..514498844
--- /dev/null
+++ b/vendor/base64/tests/helpers.rs
@@ -0,0 +1,14 @@
+extern crate base64;
+
+use base64::*;
+
+pub fn compare_decode(expected: &str, target: &str) {
+    assert_eq!(
+        expected,
+        String::from_utf8(decode(target).unwrap()).unwrap()
+    );
+    assert_eq!(
+        expected,
+        String::from_utf8(decode(target.as_bytes()).unwrap()).unwrap()
+    );
+}
diff --git a/vendor/base64/tests/tests.rs b/vendor/base64/tests/tests.rs
new file mode 100644
index 000000000..11fed960f
--- /dev/null
+++ b/vendor/base64/tests/tests.rs
@@ -0,0 +1,194 @@
+extern crate base64;
+extern crate rand;
+
+use rand::{FromEntropy, Rng};
+
+use base64::*;
+
+mod helpers;
+use self::helpers::*;
+
+// generate random contents of the specified length and test encode/decode roundtrip
+fn roundtrip_random(
+    byte_buf: &mut Vec<u8>,
+    str_buf: &mut String,
+    config: Config,
+    byte_len: usize,
+    approx_values_per_byte: u8,
+    max_rounds: u64,
+) {
+    // let the short ones be short but don't let it get too crazy large
+    let num_rounds = calculate_number_of_rounds(byte_len, approx_values_per_byte, max_rounds);
+    let mut r = rand::rngs::SmallRng::from_entropy();
+    let mut decode_buf = Vec::new();
+
+    for _ in 0..num_rounds {
+        byte_buf.clear();
+        str_buf.clear();
+        decode_buf.clear();
+        while byte_buf.len() < byte_len {
+            byte_buf.push(r.gen::<u8>());
+        }
+
+        encode_config_buf(&byte_buf, config, str_buf);
+        decode_config_buf(&str_buf, config, &mut decode_buf).unwrap();
+
+        assert_eq!(byte_buf, &decode_buf);
+    }
+}
+
+fn calculate_number_of_rounds(byte_len: usize, approx_values_per_byte: u8, max: u64) -> u64 {
+    // don't overflow
+    let mut prod = approx_values_per_byte as u64;
+
+    for _ in 0..byte_len {
+        if prod > max {
+            return max;
+        }
+
+        prod = prod.saturating_mul(prod);
+    }
+
+    prod
+}
+
+fn no_pad_config() -> Config {
+    Config::new(CharacterSet::Standard, false)
+}
+
+#[test]
+fn roundtrip_random_short_standard() {
+    let mut byte_buf: Vec<u8> = Vec::new();
+    let mut str_buf = String::new();
+
+    for input_len in 0..40 {
+        roundtrip_random(&mut byte_buf, &mut str_buf, STANDARD, input_len, 4, 10000);
+    }
+}
+
+#[test]
+fn roundtrip_random_with_fast_loop_standard() {
+    let mut byte_buf: Vec<u8> = Vec::new();
+    let mut str_buf = String::new();
+
+    for input_len in 40..100 {
+        roundtrip_random(&mut byte_buf, &mut str_buf, STANDARD, input_len, 4, 1000);
+    }
+}
+
+#[test]
+fn roundtrip_random_short_no_padding() {
+    let mut byte_buf: Vec<u8> = Vec::new();
+    let mut str_buf = String::new();
+
+    for input_len in 0..40 {
+        roundtrip_random(
+            &mut byte_buf,
+            &mut str_buf,
+            no_pad_config(),
+            input_len,
+            4,
+            10000,
+        );
+    }
+}
+
+#[test]
+fn roundtrip_random_no_padding() {
+    let mut byte_buf: Vec<u8> = Vec::new();
+    let mut str_buf = String::new();
+
+    for input_len in 40..100 {
+        roundtrip_random(
+            &mut byte_buf,
+            &mut str_buf,
+            no_pad_config(),
+            input_len,
+            4,
+            1000,
+        );
+    }
+}
+
+#[test]
+fn roundtrip_decode_trailing_10_bytes() {
+    // This is a special case because we decode 8 byte blocks of input at a time as much as we can,
+    // ideally unrolled to 32 bytes at a time, in stages 1 and 2. Since we also write a u64's worth
+    // of bytes (8) to the output, we always write 2 garbage bytes that then will be overwritten by
+    // the NEXT block. However, if the next block only contains 2 bytes, it will decode to 1 byte,
+    // and therefore be too short to cover up the trailing 2 garbage bytes. Thus, we have stage 3
+    // to handle that case.
+
+    for num_quads in 0..25 {
+        let mut s: String = std::iter::repeat("ABCD").take(num_quads).collect();
+        s.push_str("EFGHIJKLZg");
+
+        let decoded = decode(&s).unwrap();
+        assert_eq!(num_quads * 3 + 7, decoded.len());
+
+        assert_eq!(s, encode_config(&decoded, STANDARD_NO_PAD));
+    }
+}
+
+#[test]
+fn display_wrapper_matches_normal_encode() {
+    let mut bytes = Vec::<u8>::with_capacity(256);
+
+    for i in 0..255 {
+        bytes.push(i);
+    }
+    bytes.push(255);
+
+    assert_eq!(
+        encode(&bytes),
+        format!(
+            "{}",
+            base64::display::Base64Display::with_config(&bytes, STANDARD)
+        )
+    );
+}
+
+#[test]
+fn because_we_can() {
+    compare_decode("alice", "YWxpY2U=");
+    compare_decode("alice", &encode(b"alice"));
+    compare_decode("alice", &encode(&decode(&encode(b"alice")).unwrap()));
+}
+
+#[test]
+fn encode_config_slice_can_use_inline_buffer() {
+    let mut buf: [u8; 22] = [0; 22];
+    let mut larger_buf: [u8; 24] = [0; 24];
+    let mut input: [u8; 16] = [0; 16];
+
+    let mut rng = rand::rngs::SmallRng::from_entropy();
+    for elt in &mut input {
+        *elt = rng.gen();
+    }
+
+    assert_eq!(22, encode_config_slice(&input, STANDARD_NO_PAD, &mut buf));
+    let decoded = decode_config(&buf, STANDARD_NO_PAD).unwrap();
+
+    assert_eq!(decoded, input);
+
+    // let's try it again with padding
+
+    assert_eq!(24, encode_config_slice(&input, STANDARD, &mut larger_buf));
+    let decoded = decode_config(&buf, STANDARD).unwrap();
+
+    assert_eq!(decoded, input);
+}
+
+#[test]
+#[should_panic(expected = "index 24 out of range for slice of length 22")]
+fn encode_config_slice_panics_when_buffer_too_small() {
+    let mut buf: [u8; 22] = [0; 22];
+    let mut input: [u8; 16] = [0; 16];
+
+    let mut rng = rand::rngs::SmallRng::from_entropy();
+    for elt in &mut input {
+        *elt = rng.gen();
+    }
+
+    encode_config_slice(&input, STANDARD, &mut buf);
+}
diff --git a/vendor/git2/.cargo-checksum.json b/vendor/git2/.cargo-checksum.json
index decaf04b2..d52a43d10 100644
--- a/vendor/git2/.cargo-checksum.json
+++ b/vendor/git2/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"CONTRIBUTING.md":"ed1b35c16d94c5c8e447f444a78bf06459f57bf63ce9e9dcaa562d3950700fd8","Cargo.lock":"a2ddb214740ac4c90271ab30f789e88744dd1ddab6dfab358469f2673b591225","Cargo.toml":"cf9e2f0ba502175754c1ffee2b3169c0bff5dbe4685e249c9f9547500fa50fca","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397","README.md":"c4d4a30ebb88024ba9db3989d383458e4a7ca51b1124c4fb3d0acabf333df9ca","examples/add.rs":"a9903f7a1af1b199783099509de3b640a3d039e9ad0b8c752c908e7fedf59b88","examples/blame.rs":"b59dc1daff18dee256038ea5e66c478678e51df1aacd20325f01d4e270fe3f20","examples/cat-file.rs":"93da1bf8891e43c308390e02f3c32106fcc085755e7f3e184d58aa2288c30cf4","examples/clone.rs":"822e6dac8f71877e8966ab72d3896dc82dfd7b525dbd54b1867964c2a9b241fd","examples/diff.rs":"d92d25865621aabccdc70087fb366211bb3fad4604d5b68bd8a580e8e4ee8412","examples/fetch.rs":"a34826b1f4448b688313b0322c951401e19b62c8f6cf28d06251bd148d842128","examples/init.rs":"3a88038e2e6eb1ff555db5cec0beff466ee500de03eaa075af3a5920d59db81b","examples/log.rs":"ea825b4b3c1410e7c14832ca87e4c1f291b5f8f83c527672be8d61d188326a16","examples/ls-remote.rs":"9e1d2fb2441c535f8abc5f1d146dd1d499e518f583baaae99b5234195153cf82","examples/pull.rs":"1b5b7a31f25b6b9168d279d3c055c99c8b174c69e7cf64806b481d088d85270f","examples/rev-list.rs":"2e18eea067c0d684dd89f6d86b4ddb052a3d594471b17eddfac9d0c18f64ae67","examples/rev-parse.rs":"125e80a916a3476d894aa555e2b780a8cf1316a0b5b850b9918b3c1af5c00dd4","examples/status.rs":"89ec5127e44123afaf429233c885cd547d7a28670512bf87c30770eba615e061","examples/tag.rs":"881ba5797fe5133c6321927518198c3ad42dd81499b57e9f32df590505b49d17","src/apply.rs":"1ca5b0c06b96cd0af13dc322bf858e375a50f76d887c61052115ea8af2245847","src/attr.rs":"bc1957f495cf3aed4a663b50b43dd8deee6770ab259283673a883ac3c66908a7","src/blame.rs":"538944e8264a1dfea2868247a1f3b44817df583131370bb6785caeafd3fdf1da","src/blob.rs":"7cb0326521dec9548a05c155283495c33f629678d9f7263e9de500c32052fb74","src/branch.rs":"1afa850c4c3a22531baddf5636bf55c9122a76b0d010e8392fbf04f1b76067ed","src/buf.rs":"d4d9795afc04eba6eb6a08c5dbcbc8e3e8341adc11701c65198d514f6cdfbac0","src/build.rs":"12ad0e2cc806123b5d23589a48dfa3fec954b0e42a01c030a21de6262aaae1b5","src/call.rs":"e5d3c59df621224c44f8caf8bd71997c33306ba251fbb58f411020377b1bc354","src/cert.rs":"023630970f1428526443afff3349cfde8439d7fdb8010c750fc8224b5362f700","src/cherrypick.rs":"1ce882b6be825243d5551f11e1f48f53acc4aa52c4c5fb5510e69fd077a512bc","src/commit.rs":"9903f1656c695947164f18291a6659726897db782b6b84f0bca14f3e829d3b45","src/config.rs":"e11b7460fd90695951c40311e97d3a43b6568af33911e310ad0312d139519f2f","src/cred.rs":"465872992de3fd9fc11137bffed19fe60d75ffbc352809061969a00d1c1d56f5","src/describe.rs":"3adb68b3118bfa18c09f7ca767afa38d76e22130b1cebf20cc3b97c9a198957a","src/diff.rs":"59b09fb0bd40f5a5736ef9fdbbf762eae832f55be9dab4faf72b4b6965809a57","src/email.rs":"b95f32739a2adac55016e892d913fb4b03d10c0583569a613f6c13946238759d","src/error.rs":"7f8d91a25b1b2801a10603020e889a65f52d44e49b34cc37621c6c974335106b","src/index.rs":"b6fb87fecc6e3d59e867d07166583c1d9c190c8ee8c6bd019248767be6acf5ba","src/indexer.rs":"bf9a61849d937fbcf544aabf5bf251659a2ff11171d4817d24ab78881f3c8097","src/lib.rs":"aa30bb78888ed59d482c4ec749a5a4b8d57409f2049ff7ad7dcf0d912402157c","src/mailmap.rs":"a034b1c86c8a8d4362939e2e2c1d0b1b2f5c71bac883b2b1b65b64078c70349e","src/mempack.rs":"8549f984360ac12868018e4f107a60386474c58cfb6c41993cbb0a820bd28908","src/merge.rs":"681f2f1e59cec49a8618a894e22645915e8f8a815a71d4ca7c6ab10fbdaeb919","src/message.rs":"77d42388ff836c6c3b49f8c8da24ca0cf42d8f8631bf8d31e68cdb6299030c38","src/note.rs":"55b286c3736833432d391184136f0fb0928e337990d1558166e2d998dc63f0dd","src/object.rs":"8b66f1c34570b37d204d0b3f626edbdd0baa7eb9734e3e444b72bf3e8fc46a27","src/odb.rs":"0d567288a02ffdd6780986e9cabac0dde5e2b36b94561867bfecb4503b1d8e20","src/oid.rs":"dc284f1523b3109e9721165289adcd820733fe72d5807f7739d307c2f88d2006","src/oid_array.rs":"3cac8e5220e01e4cbd32f9898d48ec610e27cf3f0ce4970f63bd7585e0b953fa","src/opts.rs":"7b06c13fa1124d9dce7132963fd94540bdd0bb9de241e2b1dea4cf0a7120e52b","src/packbuilder.rs":"649246626d600f7d023e73ab3e3d4ca691d482d85de11338f3c5cea66f7f84ee","src/panic.rs":"62ef0684379f4cdebf9477e2f63c9f0ecc80fe608de2df32bca13ce0086249d6","src/patch.rs":"740fa2a29148605e3dac16f58fd603b408283cfe148b922fbe6b5a5d62f18db0","src/pathspec.rs":"4687cbfdf26081ba25323e2ba03bfd0f9d56d1e71cc29f0c91d082540171b339","src/proxy_options.rs":"cfa029317ae00a15074d4fd5de5d7c8da982459b915399c1d6010ddbee43ab28","src/rebase.rs":"179fc17e402d902300de8d37a65ceb0c29d6e8f4ba50cc8b7a7d8b09cfe9ef55","src/reference.rs":"a6d7569f381071e7bb97b1dcd3a9f6bea4409475114b0df232fbe4c5e3660fc6","src/reflog.rs":"45e05e0cb5418be7a0f15a2992802391d31806ed459e8c49864db5d67c6aedd7","src/refspec.rs":"5107582963524fe9ff312a280232dba08d25be06fdf8f278c0bbfdbfa7a50402","src/remote.rs":"ee2b40c48601cfe49ad03c424dcc316ce8c744183f9f6f5af12e0269631a1f7b","src/remote_callbacks.rs":"bb359251e53b2d49786e1793cf2625214aaa12a2c5c09499ff50f8c337418573","src/repo.rs":"a2783aba84fbeae521add58867e86703a8b67d53c8dfec88d6bc200a1951c4a9","src/revert.rs":"b51dd98a9775e80dfd56b2fe13737e15baf64d3ac9c56546b2bbdfd53d1de7f9","src/revspec.rs":"29df0754775603ed1189bbe28f933f5851d50936eda380a57f175ec35496d637","src/revwalk.rs":"abbe43b3e3884cb9d74eee6773dff7d341620b125d004f4d1309da62fa9651fc","src/signature.rs":"89be2b042b7b26e8d2ea4b98136ce289e29ecd24735dca356af1379f58cc05db","src/stash.rs":"c320ed9288731067a9135fdf3e964ac8a85c99587ffa66dd16ee452ead3675d0","src/status.rs":"c3f661659d23300383a3bfef9e68a519b8204f20c50e0e6ef7bfe60e0fe159c1","src/string_array.rs":"7a73a0aac41f5bad1d9329910540b9d7065e86449688035d0f2c0eb6d18a7d7a","src/submodule.rs":"ae56e4adffc5849332ec02f3351f36160bcb0471991d0013bb5f2e20dcdbc69d","src/tag.rs":"96ffa3ddd96349032e5e97323ed8fd7a3054a4f3263db38fda0d501749db3b6b","src/tagforeach.rs":"04ea7ff4072a270c5febaee8133ae93040eb81a139ed987238e0b500e9626c4c","src/test.rs":"74c34ed48ff74bdcf3f92d8d44ba15d2b3bc0960847c6839e7c9d2e9c4518369","src/time.rs":"7fd2bcdda9baf24c6292edd04be6112c83a57e8f9e566d6d219563ad98c12203","src/tracing.rs":"48d37e08040242117ba043448786cff7a81adf6b315a688b4f66a01f2285d6ac","src/transaction.rs":"fcaaae2135ef209593cf5c5ac9693e6cf63cfe2f343df49aa22b572bb19e832f","src/transport.rs":"d81db6973b36532a248b6f5366e89daa35d09e1f2c3474d277db897e250f0073","src/tree.rs":"bc0699ae40b49f7979c05db3df640b18493a85dfa17699b02501e3bb7d432235","src/treebuilder.rs":"337c5898c42ffe72a96c3d3871b49d83d673c2a4e3e7d9fa715fcba59d042187","src/util.rs":"84be65355ca3d4666ed208ef23806ff46699553dfb9c3cfe769726e162b47424","src/version.rs":"bcc26c9dcc5bf872afd0741233f07981df0a4be28faeba9ad52eb437961eb30f","src/worktree.rs":"b2f4910730ee520b48b8311a196702461b13d4c63b2feb5536549a1dfde7261d","tests/add_extensions.rs":"b800abd0f208bfe64fe0c78a3d2934939408916edb87cc35607e659e312f26cc","tests/get_extensions.rs":"22182deb909b46486a88b1a21cc99b64a3c93a321c5524c9c144486c04ccd3e1","tests/global_state.rs":"c75947eca9718277da08722ca9a58d9b4154b36b1aca6453bb198238c17904ce","tests/remove_extensions.rs":"a7940866b4712d330a0e8d854fe98c8de9c6d37d5809a003828b2b4b5ef00bc7"},"package":"2994bee4a3a6a51eb90c218523be382fd7ea09b16380b9312e9dbe955ff7c7d1"}
\ No newline at end of file
+{"files":{"CONTRIBUTING.md":"ed1b35c16d94c5c8e447f444a78bf06459f57bf63ce9e9dcaa562d3950700fd8","Cargo.lock":"a2ddb214740ac4c90271ab30f789e88744dd1ddab6dfab358469f2673b591225","Cargo.toml":"cf9e2f0ba502175754c1ffee2b3169c0bff5dbe4685e249c9f9547500fa50fca","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397","README.md":"c4d4a30ebb88024ba9db3989d383458e4a7ca51b1124c4fb3d0acabf333df9ca","examples/add.rs":"a9903f7a1af1b199783099509de3b640a3d039e9ad0b8c752c908e7fedf59b88","examples/blame.rs":"b59dc1daff18dee256038ea5e66c478678e51df1aacd20325f01d4e270fe3f20","examples/cat-file.rs":"93da1bf8891e43c308390e02f3c32106fcc085755e7f3e184d58aa2288c30cf4","examples/clone.rs":"822e6dac8f71877e8966ab72d3896dc82dfd7b525dbd54b1867964c2a9b241fd","examples/diff.rs":"d92d25865621aabccdc70087fb366211bb3fad4604d5b68bd8a580e8e4ee8412","examples/fetch.rs":"a34826b1f4448b688313b0322c951401e19b62c8f6cf28d06251bd148d842128","examples/init.rs":"3a88038e2e6eb1ff555db5cec0beff466ee500de03eaa075af3a5920d59db81b","examples/log.rs":"ea825b4b3c1410e7c14832ca87e4c1f291b5f8f83c527672be8d61d188326a16","examples/ls-remote.rs":"9e1d2fb2441c535f8abc5f1d146dd1d499e518f583baaae99b5234195153cf82","examples/pull.rs":"1b5b7a31f25b6b9168d279d3c055c99c8b174c69e7cf64806b481d088d85270f","examples/rev-list.rs":"2e18eea067c0d684dd89f6d86b4ddb052a3d594471b17eddfac9d0c18f64ae67","examples/rev-parse.rs":"125e80a916a3476d894aa555e2b780a8cf1316a0b5b850b9918b3c1af5c00dd4","examples/status.rs":"89ec5127e44123afaf429233c885cd547d7a28670512bf87c30770eba615e061","examples/tag.rs":"881ba5797fe5133c6321927518198c3ad42dd81499b57e9f32df590505b49d17","src/apply.rs":"1ca5b0c06b96cd0af13dc322bf858e375a50f76d887c61052115ea8af2245847","src/attr.rs":"bc1957f495cf3aed4a663b50b43dd8deee6770ab259283673a883ac3c66908a7","src/blame.rs":"538944e8264a1dfea2868247a1f3b44817df583131370bb6785caeafd3fdf1da","src/blob.rs":"7cb0326521dec9548a05c155283495c33f629678d9f7263e9de500c32052fb74","src/branch.rs":"1afa850c4c3a22531baddf5636bf55c9122a76b0d010e8392fbf04f1b76067ed","src/buf.rs":"d4d9795afc04eba6eb6a08c5dbcbc8e3e8341adc11701c65198d514f6cdfbac0","src/build.rs":"12ad0e2cc806123b5d23589a48dfa3fec954b0e42a01c030a21de6262aaae1b5","src/call.rs":"e5d3c59df621224c44f8caf8bd71997c33306ba251fbb58f411020377b1bc354","src/cert.rs":"6e8a78340cb8b3908977892d6d1723cebe70ff63819b28a63688e0fb4428b859","src/cherrypick.rs":"1ce882b6be825243d5551f11e1f48f53acc4aa52c4c5fb5510e69fd077a512bc","src/commit.rs":"9903f1656c695947164f18291a6659726897db782b6b84f0bca14f3e829d3b45","src/config.rs":"e11b7460fd90695951c40311e97d3a43b6568af33911e310ad0312d139519f2f","src/cred.rs":"465872992de3fd9fc11137bffed19fe60d75ffbc352809061969a00d1c1d56f5","src/describe.rs":"3adb68b3118bfa18c09f7ca767afa38d76e22130b1cebf20cc3b97c9a198957a","src/diff.rs":"59b09fb0bd40f5a5736ef9fdbbf762eae832f55be9dab4faf72b4b6965809a57","src/email.rs":"b95f32739a2adac55016e892d913fb4b03d10c0583569a613f6c13946238759d","src/error.rs":"7f8d91a25b1b2801a10603020e889a65f52d44e49b34cc37621c6c974335106b","src/index.rs":"b6fb87fecc6e3d59e867d07166583c1d9c190c8ee8c6bd019248767be6acf5ba","src/indexer.rs":"bf9a61849d937fbcf544aabf5bf251659a2ff11171d4817d24ab78881f3c8097","src/lib.rs":"73e26af4df8fd4e34f02d17de45f3cbf89f2c10b06f8a93d3590e3ce3f4e1517","src/mailmap.rs":"a034b1c86c8a8d4362939e2e2c1d0b1b2f5c71bac883b2b1b65b64078c70349e","src/mempack.rs":"8549f984360ac12868018e4f107a60386474c58cfb6c41993cbb0a820bd28908","src/merge.rs":"681f2f1e59cec49a8618a894e22645915e8f8a815a71d4ca7c6ab10fbdaeb919","src/message.rs":"77d42388ff836c6c3b49f8c8da24ca0cf42d8f8631bf8d31e68cdb6299030c38","src/note.rs":"55b286c3736833432d391184136f0fb0928e337990d1558166e2d998dc63f0dd","src/object.rs":"8b66f1c34570b37d204d0b3f626edbdd0baa7eb9734e3e444b72bf3e8fc46a27","src/odb.rs":"0d567288a02ffdd6780986e9cabac0dde5e2b36b94561867bfecb4503b1d8e20","src/oid.rs":"dc284f1523b3109e9721165289adcd820733fe72d5807f7739d307c2f88d2006","src/oid_array.rs":"3cac8e5220e01e4cbd32f9898d48ec610e27cf3f0ce4970f63bd7585e0b953fa","src/opts.rs":"7b06c13fa1124d9dce7132963fd94540bdd0bb9de241e2b1dea4cf0a7120e52b","src/packbuilder.rs":"649246626d600f7d023e73ab3e3d4ca691d482d85de11338f3c5cea66f7f84ee","src/panic.rs":"62ef0684379f4cdebf9477e2f63c9f0ecc80fe608de2df32bca13ce0086249d6","src/patch.rs":"740fa2a29148605e3dac16f58fd603b408283cfe148b922fbe6b5a5d62f18db0","src/pathspec.rs":"4687cbfdf26081ba25323e2ba03bfd0f9d56d1e71cc29f0c91d082540171b339","src/proxy_options.rs":"cfa029317ae00a15074d4fd5de5d7c8da982459b915399c1d6010ddbee43ab28","src/rebase.rs":"179fc17e402d902300de8d37a65ceb0c29d6e8f4ba50cc8b7a7d8b09cfe9ef55","src/reference.rs":"a6d7569f381071e7bb97b1dcd3a9f6bea4409475114b0df232fbe4c5e3660fc6","src/reflog.rs":"45e05e0cb5418be7a0f15a2992802391d31806ed459e8c49864db5d67c6aedd7","src/refspec.rs":"5107582963524fe9ff312a280232dba08d25be06fdf8f278c0bbfdbfa7a50402","src/remote.rs":"ee2b40c48601cfe49ad03c424dcc316ce8c744183f9f6f5af12e0269631a1f7b","src/remote_callbacks.rs":"516b39f5c2b5ce064167a21f323a9b6f5f5f10c464f76b9f36c2326d2be771f7","src/repo.rs":"a2783aba84fbeae521add58867e86703a8b67d53c8dfec88d6bc200a1951c4a9","src/revert.rs":"b51dd98a9775e80dfd56b2fe13737e15baf64d3ac9c56546b2bbdfd53d1de7f9","src/revspec.rs":"29df0754775603ed1189bbe28f933f5851d50936eda380a57f175ec35496d637","src/revwalk.rs":"abbe43b3e3884cb9d74eee6773dff7d341620b125d004f4d1309da62fa9651fc","src/signature.rs":"89be2b042b7b26e8d2ea4b98136ce289e29ecd24735dca356af1379f58cc05db","src/stash.rs":"c320ed9288731067a9135fdf3e964ac8a85c99587ffa66dd16ee452ead3675d0","src/status.rs":"c3f661659d23300383a3bfef9e68a519b8204f20c50e0e6ef7bfe60e0fe159c1","src/string_array.rs":"7a73a0aac41f5bad1d9329910540b9d7065e86449688035d0f2c0eb6d18a7d7a","src/submodule.rs":"ae56e4adffc5849332ec02f3351f36160bcb0471991d0013bb5f2e20dcdbc69d","src/tag.rs":"96ffa3ddd96349032e5e97323ed8fd7a3054a4f3263db38fda0d501749db3b6b","src/tagforeach.rs":"04ea7ff4072a270c5febaee8133ae93040eb81a139ed987238e0b500e9626c4c","src/test.rs":"74c34ed48ff74bdcf3f92d8d44ba15d2b3bc0960847c6839e7c9d2e9c4518369","src/time.rs":"7fd2bcdda9baf24c6292edd04be6112c83a57e8f9e566d6d219563ad98c12203","src/tracing.rs":"48d37e08040242117ba043448786cff7a81adf6b315a688b4f66a01f2285d6ac","src/transaction.rs":"fcaaae2135ef209593cf5c5ac9693e6cf63cfe2f343df49aa22b572bb19e832f","src/transport.rs":"d81db6973b36532a248b6f5366e89daa35d09e1f2c3474d277db897e250f0073","src/tree.rs":"bc0699ae40b49f7979c05db3df640b18493a85dfa17699b02501e3bb7d432235","src/treebuilder.rs":"337c5898c42ffe72a96c3d3871b49d83d673c2a4e3e7d9fa715fcba59d042187","src/util.rs":"84be65355ca3d4666ed208ef23806ff46699553dfb9c3cfe769726e162b47424","src/version.rs":"bcc26c9dcc5bf872afd0741233f07981df0a4be28faeba9ad52eb437961eb30f","src/worktree.rs":"b2f4910730ee520b48b8311a196702461b13d4c63b2feb5536549a1dfde7261d","tests/add_extensions.rs":"b800abd0f208bfe64fe0c78a3d2934939408916edb87cc35607e659e312f26cc","tests/get_extensions.rs":"22182deb909b46486a88b1a21cc99b64a3c93a321c5524c9c144486c04ccd3e1","tests/global_state.rs":"c75947eca9718277da08722ca9a58d9b4154b36b1aca6453bb198238c17904ce","tests/remove_extensions.rs":"a7940866b4712d330a0e8d854fe98c8de9c6d37d5809a003828b2b4b5ef00bc7"},"package":"2994bee4a3a6a51eb90c218523be382fd7ea09b16380b9312e9dbe955ff7c7d1"}
diff --git a/vendor/git2/src/cert.rs b/vendor/git2/src/cert.rs
index d62b8304c..b232cc3ce 100644
--- a/vendor/git2/src/cert.rs
+++ b/vendor/git2/src/cert.rs
@@ -27,6 +27,54 @@ pub struct CertX509<'a> {
     _marker: marker::PhantomData<&'a raw::git_cert>,
 }
 
+/// The SSH host key type.
+#[derive(Copy, Clone, Debug)]
+#[non_exhaustive]
+pub enum SshHostKeyType {
+    /// Unknown key type
+    Unknown = raw::GIT_CERT_SSH_RAW_TYPE_UNKNOWN as isize,
+    /// RSA key type
+    Rsa = raw::GIT_CERT_SSH_RAW_TYPE_RSA as isize,
+    /// DSS key type
+    Dss = raw::GIT_CERT_SSH_RAW_TYPE_DSS as isize,
+    /// ECDSA 256 key type
+    Ecdsa256 = raw::GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256 as isize,
+    /// ECDSA 384 key type
+    Ecdsa384 = raw::GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384 as isize,
+    /// ECDSA 521 key type
+    Ecdsa521 = raw::GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521 as isize,
+    /// ED25519 key type
+    Ed255219 = raw::GIT_CERT_SSH_RAW_TYPE_KEY_ED25519 as isize,
+}
+
+impl SshHostKeyType {
+    /// The name of the key type as encoded in the known_hosts file.
+    pub fn name(&self) -> &'static str {
+        match self {
+            SshHostKeyType::Unknown => "unknown",
+            SshHostKeyType::Rsa => "ssh-rsa",
+            SshHostKeyType::Dss => "ssh-dss",
+            SshHostKeyType::Ecdsa256 => "ecdsa-sha2-nistp256",
+            SshHostKeyType::Ecdsa384 => "ecdsa-sha2-nistp384",
+            SshHostKeyType::Ecdsa521 => "ecdsa-sha2-nistp521",
+            SshHostKeyType::Ed255219 => "ssh-ed25519",
+        }
+    }
+
+    /// A short name of the key type, the colloquial form used as a human-readable description.
+    pub fn short_name(&self) -> &'static str {
+        match self {
+            SshHostKeyType::Unknown => "Unknown",
+            SshHostKeyType::Rsa => "RSA",
+            SshHostKeyType::Dss => "DSA",
+            SshHostKeyType::Ecdsa256 => "ECDSA",
+            SshHostKeyType::Ecdsa384 => "ECDSA",
+            SshHostKeyType::Ecdsa521 => "ECDSA",
+            SshHostKeyType::Ed255219 => "ED25519",
+        }
+    }
+}
+
 impl<'a> Cert<'a> {
     /// Attempt to view this certificate as an SSH hostkey.
     ///
@@ -87,6 +135,39 @@ impl<'a> CertHostkey<'a> {
             }
         }
     }
+
+    /// Returns the raw host key.
+    pub fn hostkey(&self) -> Option<&[u8]> {
+        unsafe {
+            if (*self.raw).kind & raw::GIT_CERT_SSH_RAW == 0 {
+                return None;
+            }
+            Some(slice::from_raw_parts(
+                (*self.raw).hostkey as *const u8,
+                (*self.raw).hostkey_len as usize,
+            ))
+        }
+    }
+
+    /// Returns the type of the host key.
+    pub fn hostkey_type(&self) -> Option<SshHostKeyType> {
+        unsafe {
+            if (*self.raw).kind & raw::GIT_CERT_SSH_RAW == 0 {
+                return None;
+            }
+            let t = match (*self.raw).raw_type {
+                raw::GIT_CERT_SSH_RAW_TYPE_UNKNOWN => SshHostKeyType::Unknown,
+                raw::GIT_CERT_SSH_RAW_TYPE_RSA => SshHostKeyType::Rsa,
+                raw::GIT_CERT_SSH_RAW_TYPE_DSS => SshHostKeyType::Dss,
+                raw::GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256 => SshHostKeyType::Ecdsa256,
+                raw::GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384 => SshHostKeyType::Ecdsa384,
+                raw::GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521 => SshHostKeyType::Ecdsa521,
+                raw::GIT_CERT_SSH_RAW_TYPE_KEY_ED25519 => SshHostKeyType::Ed255219,
+                t => panic!("unexpected host key type {:?}", t),
+            };
+            Some(t)
+        }
+    }
 }
 
 impl<'a> CertX509<'a> {
diff --git a/vendor/git2/src/lib.rs b/vendor/git2/src/lib.rs
index c297ffe44..34287154e 100644
--- a/vendor/git2/src/lib.rs
+++ b/vendor/git2/src/lib.rs
@@ -123,7 +123,7 @@ pub use crate::refspec::Refspec;
 pub use crate::remote::{
     FetchOptions, PushOptions, Refspecs, Remote, RemoteConnection, RemoteHead, RemoteRedirect,
 };
-pub use crate::remote_callbacks::{Credentials, RemoteCallbacks};
+pub use crate::remote_callbacks::{CertificateCheckStatus, Credentials, RemoteCallbacks};
 pub use crate::remote_callbacks::{TransportMessage, UpdateTips};
 pub use crate::repo::{Repository, RepositoryInitOptions};
 pub use crate::revert::RevertOptions;
diff --git a/vendor/git2/src/remote_callbacks.rs b/vendor/git2/src/remote_callbacks.rs
index bcc73e85e..fe1802273 100644
--- a/vendor/git2/src/remote_callbacks.rs
+++ b/vendor/git2/src/remote_callbacks.rs
@@ -51,7 +51,18 @@ pub type UpdateTips<'a> = dyn FnMut(&str, Oid, Oid) -> bool + 'a;
 ///
 /// The second argument is the hostname for the connection is passed as the last
 /// argument.
-pub type CertificateCheck<'a> = dyn FnMut(&Cert<'_>, &str) -> bool + 'a;
+pub type CertificateCheck<'a> =
+    dyn FnMut(&Cert<'_>, &str) -> Result<CertificateCheckStatus, Error> + 'a;
+
+/// The return value for the [`CertificateCheck`] callback.
+pub enum CertificateCheckStatus {
+    /// Indicates that the certificate should be accepted.
+    CertificateOk,
+    /// Indicates that the certificate callback is neither accepting nor
+    /// rejecting the certificate. The result of the certificate checks
+    /// built-in to libgit2 will be used instead.
+    CertificatePassthrough,
+}
 
 /// Callback for each updated reference on push.
 ///
@@ -162,7 +173,7 @@ impl<'a> RemoteCallbacks<'a> {
     /// connection to proceed.
     pub fn certificate_check<F>(&mut self, cb: F) -> &mut RemoteCallbacks<'a>
     where
-        F: FnMut(&Cert<'_>, &str) -> bool + 'a,
+        F: FnMut(&Cert<'_>, &str) -> Result<CertificateCheckStatus, Error> + 'a,
     {
         self.certificate_check = Some(Box::new(cb) as Box<CertificateCheck<'a>>);
         self
@@ -371,16 +382,26 @@ extern "C" fn certificate_check_cb(
         let payload = &mut *(data as *mut RemoteCallbacks<'_>);
         let callback = match payload.certificate_check {
             Some(ref mut c) => c,
-            None => return true,
+            None => return Ok(CertificateCheckStatus::CertificatePassthrough),
         };
         let cert = Binding::from_raw(cert);
         let hostname = str::from_utf8(CStr::from_ptr(hostname).to_bytes()).unwrap();
         callback(&cert, hostname)
     });
-    if ok == Some(true) {
-        0
-    } else {
-        -1
+    match ok {
+        Some(Ok(CertificateCheckStatus::CertificateOk)) => 0,
+        Some(Ok(CertificateCheckStatus::CertificatePassthrough)) => raw::GIT_PASSTHROUGH as c_int,
+        Some(Err(e)) => {
+            let s = CString::new(e.message()).unwrap();
+            unsafe {
+                raw::git_error_set_str(e.class() as c_int, s.as_ptr());
+            }
+            e.raw_code() as c_int
+        }
+        None => {
+            // Panic. The *should* get resumed by some future call to check().
+            -1
+        }
     }
 }
 
diff --git a/vendor/hmac/.cargo-checksum.json b/vendor/hmac/.cargo-checksum.json
new file mode 100644
index 000000000..ade558309
--- /dev/null
+++ b/vendor/hmac/.cargo-checksum.json
@@ -0,0 +1 @@
+{"files":{"CHANGELOG.md":"9475fa89d1ca3bf8780d4eb95fc23fcf9e46bc80745136caf858cbe1a56da7bb","Cargo.toml":"b56253cfaec8c49b49ce90736dde78025f0b820f2a018edff569bba27e5a5080","LICENSE-APACHE":"a9040321c3712d8fd0b09cf52b17445de04a23a10165049ae187cd39e5c86be5","LICENSE-MIT":"9e0dfd2dd4173a530e238cb6adb37aa78c34c6bc7444e0e10c1ab5d8881f63ba","README.md":"d0b99c8c2b5a15bfa1315b2160fec26b9b59b4e5f242ed046b61474351520e82","src/lib.rs":"66ba692fd324d2b9d0fbb55ab96e978a2a72cc3bae7fc9efb14bba5534e79a16","src/optim.rs":"3c16b46effd4980cd2e98b5b2090aa57049dc9d4a9ea1c87e758875bf1ab0b63","src/simple.rs":"160abf6a160f606185d18ac15984b7e0eb6662f43588539d9533b7cb1b016cca","tests/data/md5.blb":"41f33f80dbc25391a47c474432362597a4ed1b45bae3a1b817fa8b5d7548dad7","tests/data/sha224.blb":"d5428cdd466e35fd954da1b8c5a222e9e3f37aaebb8c16a3c4204272bfd1dbfe","tests/data/sha256.blb":"98d4a64debfda8e232490cd464353d083fdf252333cca139d5379b5fd568b1a9","tests/data/sha384.blb":"35c0ef0537ad23aba89a2943e4a62c650af5d5c695ab9084c792149535f5e6ee","tests/data/sha512.blb":"cd881eab93b8bb07b892cf8a676673a48170f63db9c21b43b6e73f0d1b5b363f","tests/data/streebog256.blb":"66df5c6eb5aba37cfa0cc5a059d2ffa2ba6af6aead3b2bfe3122aae11bc7ea0c","tests/data/streebog512.blb":"13d5b55d89e2c7782db965ed779b67838acf5b09dbb4f3332fed146471c90ee4","tests/data/wycheproof-sha1.blb":"8c364fb223c563d75d4b49ac4af582c92a9cb5dbca25af345b98b6122aa6aa40","tests/data/wycheproof-sha256.blb":"9855ca5a11de9a95024084e6999764de48ed3dee1bd445d7aebf7e72c379d62a","tests/data/wycheproof-sha384.blb":"a39b0e05cf9a47651722f0afe6294db053ad542dc5bd598271a358e884e771cc","tests/data/wycheproof-sha512.blb":"0329587a988335059c956a1bd62ac55c727749a6482f0eeb2e0d0954f2582462","tests/mod.rs":"27941c34466ba4fe43e7e1c6118cbf2f5c854d79c53b7d73a77636328bf7146e"},"package":"6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"}
\ No newline at end of file
diff --git a/vendor/hmac/CHANGELOG.md b/vendor/hmac/CHANGELOG.md
new file mode 100644
index 000000000..2569cc511
--- /dev/null
+++ b/vendor/hmac/CHANGELOG.md
@@ -0,0 +1,97 @@
+# Changelog
+
+All notable changes to this project will be documented in this file.
+
+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
+and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
+
+## 0.12.1 (2022-02-17)
+### Fixed
+- Minimal versions build ([#108])
+
+[#108]: https://github.com/RustCrypto/MACs/pull/108
+
+## 0.12.0 (2021-12-07)
+### Changed
+- Bump `digest` crate dependency to v0.10 and remove `crypto-mac` ([#97])
+- Use a more efficient state representation by using block-level hash API ([#97])
+
+### Added
+- `SimpleHmac` as a less constrained alternative to `Hmac` ([#97])
+
+[#97]: https://github.com/RustCrypto/MACs/pull/97
+
+## 0.11.0 (2021-04-29)
+### Changed
+- Bump `crypto-mac` crate dependency to v0.11 ([#73])
+
+[#73]: https://github.com/RustCrypto/MACs/pull/73
+
+## 0.10.1 (2020-10-16)
+### Added
+- Zulip badge ([#64])
+
+[#64]: https://github.com/RustCrypto/MACs/pull/64
+
+## 0.10.0 (2020-10-16)
+### Changed
+- Bump `crypto-mac` dependency to v0.10 ([#62])
+
+[#62]: https://github.com/RustCrypto/MACs/pull/62
+
+## 0.9.0 (2020-08-12)
+### Changed
+- Bump `crypto-mac` dependency to v0.9 ([#57])
+
+### Added
+- Implement `io::Write` ([#55])
+
+[#55]: https://github.com/RustCrypto/MACs/pull/55
+[#57]: https://github.com/RustCrypto/MACs/pull/57
+
+## 0.8.1 (2020-06-24)
+### Fixed
+- Replace outdated `code` with `into_bytes` in documentation ([#50])
+
+[#50]: https://github.com/RustCrypto/MACs/pull/50
+
+## 0.8.0 (2020-06-09)
+### Changed
+- Upgrade to `digest` v0.9 crate release; MSRV 1.41 ([#45])
+- Upgrade `crypto-mac` to v0.8 ([#33])
+- Rename `*result*` to `finalize` ([#38])
+- Upgrade to Rust 2018 edition  ([#33])
+
+[#45]: https://github.com/RustCrypto/MACs/pull/45
+[#38]: https://github.com/RustCrypto/MACs/pull/38
+[#33]: https://github.com/RustCrypto/MACs/pull/33
+
+## 0.7.1 (2019-07-11)
+
+## 0.7.0 (2018-10-03)
+
+## 0.6.3 (2018-08-15)
+
+## 0.6.2 (2018-04-15)
+
+## 0.6.1 (2018-04-05)
+
+## 0.6.0 (2018-03-30)
+
+## 0.5.0 (2017-11-15)
+
+## 0.4.2 (2017-07-24)
+
+## 0.4.1 (2017-07-24)
+
+## 0.4.0 (2017-07-24)
+
+## 0.3.1 (2017-06-12)
+
+## 0.1.2 (2017-07-24)
+
+## 0.1.1 (2017-05-14)
+
+## 0.1.0 (2017-05-14)
+
+## 0.0.1 (2016-10-21)
diff --git a/vendor/hmac/Cargo.toml b/vendor/hmac/Cargo.toml
new file mode 100644
index 000000000..ca1c001a3
--- /dev/null
+++ b/vendor/hmac/Cargo.toml
@@ -0,0 +1,55 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g., crates.io) dependencies.
+#
+# If you are reading this file be aware that the original Cargo.toml
+# will likely look very different (and much more reasonable).
+# See Cargo.toml.orig for the original contents.
+
+[package]
+edition = "2018"
+name = "hmac"
+version = "0.12.1"
+authors = ["RustCrypto Developers"]
+description = "Generic implementation of Hash-based Message Authentication Code (HMAC)"
+documentation = "https://docs.rs/hmac"
+readme = "README.md"
+keywords = ["crypto", "mac", "hmac", "digest"]
+categories = ["cryptography", "no-std"]
+license = "MIT OR Apache-2.0"
+repository = "https://github.com/RustCrypto/MACs"
+[package.metadata.docs.rs]
+all-features = true
+rustdoc-args = ["--cfg", "docsrs"]
+[dependencies.digest]
+version = "0.10.3"
+features = ["mac"]
+[dev-dependencies.digest]
+version = "0.10"
+features = ["dev"]
+
+[dev-dependencies.hex-literal]
+version = "0.2.2"
+
+[dev-dependencies.md-5]
+version = "0.10"
+default-features = false
+
+[dev-dependencies.sha-1]
+version = "0.10"
+default-features = false
+
+[dev-dependencies.sha2]
+version = "0.10"
+default-features = false
+
+[dev-dependencies.streebog]
+version = "0.10"
+default-features = false
+
+[features]
+reset = []
+std = ["digest/std"]
diff --git a/vendor/hmac/LICENSE-APACHE b/vendor/hmac/LICENSE-APACHE
new file mode 100644
index 000000000..78173fa2e
--- /dev/null
+++ b/vendor/hmac/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/vendor/hmac/LICENSE-MIT b/vendor/hmac/LICENSE-MIT
new file mode 100644
index 000000000..8dcb85b30
--- /dev/null
+++ b/vendor/hmac/LICENSE-MIT
@@ -0,0 +1,25 @@
+Copyright (c) 2017 Artyom Pavlov
+
+Permission is hereby granted, free of charge, to any
+person obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without
+limitation the rights to use, copy, modify, merge,
+publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software
+is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice
+shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/vendor/hmac/README.md b/vendor/hmac/README.md
new file mode 100644
index 000000000..52d4ef968
--- /dev/null
+++ b/vendor/hmac/README.md
@@ -0,0 +1,53 @@
+# RustCrypto: HMAC
+
+[![crate][crate-image]][crate-link]
+[![Docs][docs-image]][docs-link]
+![Apache2/MIT licensed][license-image]
+![Rust Version][rustc-image]
+[![Project Chat][chat-image]][chat-link]
+
+Pure Rust implementation of the [Hash-based Message Authentication Code (HMAC)][1].
+
+[Documentation][docs-link]
+
+## Minimum Supported Rust Version
+
+Rust **1.41** or higher.
+
+Minimum supported Rust version can be changed in the future, but it will be
+done with a minor version bump.
+
+## SemVer Policy
+
+- All on-by-default features of this library are covered by SemVer
+- MSRV is considered exempt from SemVer as noted above
+
+## License
+
+Licensed under either of:
+
+ * [Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0)
+ * [MIT license](http://opensource.org/licenses/MIT)
+
+at your option.
+
+### Contribution
+
+Unless you explicitly state otherwise, any contribution intentionally submitted
+for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
+dual licensed as above, without any additional terms or conditions.
+
+[//]: # (badges)
+
+[crate-image]: https://img.shields.io/crates/v/hmac.svg
+[crate-link]: https://crates.io/crates/hmac
+[docs-image]: https://docs.rs/hmac/badge.svg
+[docs-link]: https://docs.rs/hmac/
+[license-image]: https://img.shields.io/badge/license-Apache2.0/MIT-blue.svg
+[rustc-image]: https://img.shields.io/badge/rustc-1.41+-blue.svg
+[chat-image]: https://img.shields.io/badge/zulip-join_chat-blue.svg
+[chat-link]: https://rustcrypto.zulipchat.com/#narrow/stream/260044-MACs
+
+[//]: # (general links)
+
+[1]: https://en.wikipedia.org/wiki/HMAC
diff --git a/vendor/hmac/src/lib.rs b/vendor/hmac/src/lib.rs
new file mode 100644
index 000000000..e79c068d8
--- /dev/null
+++ b/vendor/hmac/src/lib.rs
@@ -0,0 +1,131 @@
+//! Generic implementation of Hash-based Message Authentication Code (HMAC).
+//!
+//! To use it you will need a cryptographic hash function implementation which
+//! implements the [`digest`] crate traits. You can find compatible crates
+//! (e.g. [`sha2`]) in the [`RustCrypto/hashes`] repository.
+//!
+//! This crate provides two HMAC implementation [`Hmac`] and [`SimpleHmac`].
+//! The first one is a buffered wrapper around block-level [`HmacCore`].
+//! Internally it uses efficient state representation, but works only with
+//! hash functions which expose block-level API and consume blocks eagerly
+//! (e.g. it will not work with the BLAKE2 family of  hash functions).
+//! On the other hand, [`SimpleHmac`] is a bit less efficient memory-wise,
+//! but works with all hash functions which implement the [`Digest`] trait.
+//!
+//! # Examples
+//! Let us demonstrate how to use HMAC using the SHA-256 hash function.
+//!
+//! In the following examples [`Hmac`] is interchangeable with [`SimpleHmac`].
+//!
+//! To get authentication code:
+//!
+//! ```rust
+//! use sha2::Sha256;
+//! use hmac::{Hmac, Mac};
+//! use hex_literal::hex;
+//!
+//! // Create alias for HMAC-SHA256
+//! type HmacSha256 = Hmac<Sha256>;
+//!
+//! let mut mac = HmacSha256::new_from_slice(b"my secret and secure key")
+//!     .expect("HMAC can take key of any size");
+//! mac.update(b"input message");
+//!
+//! // `result` has type `CtOutput` which is a thin wrapper around array of
+//! // bytes for providing constant time equality check
+//! let result = mac.finalize();
+//! // To get underlying array use `into_bytes`, but be careful, since
+//! // incorrect use of the code value may permit timing attacks which defeats
+//! // the security provided by the `CtOutput`
+//! let code_bytes = result.into_bytes();
+//! let expected = hex!("
+//!     97d2a569059bbcd8ead4444ff99071f4
+//!     c01d005bcefe0d3567e1be628e5fdcd9
+//! ");
+//! assert_eq!(code_bytes[..], expected[..]);
+//! ```
+//!
+//! To verify the message:
+//!
+//! ```rust
+//! # use sha2::Sha256;
+//! # use hmac::{Hmac, Mac};
+//! # use hex_literal::hex;
+//! # type HmacSha256 = Hmac<Sha256>;
+//! let mut mac = HmacSha256::new_from_slice(b"my secret and secure key")
+//!     .expect("HMAC can take key of any size");
+//!
+//! mac.update(b"input message");
+//!
+//! let code_bytes = hex!("
+//!     97d2a569059bbcd8ead4444ff99071f4
+//!     c01d005bcefe0d3567e1be628e5fdcd9
+//! ");
+//! // `verify_slice` will return `Ok(())` if code is correct, `Err(MacError)` otherwise
+//! mac.verify_slice(&code_bytes[..]).unwrap();
+//! ```
+//!
+//! # Block and input sizes
+//! Usually it is assumed that block size is larger than output size. Due to the
+//! generic nature of the implementation, this edge case must be handled as well
+//! to remove potential panic. This is done by truncating hash output to the hash
+//! block size if needed.
+//!
+//! [`digest`]: https://docs.rs/digest
+//! [`sha2`]: https://docs.rs/sha2
+//! [`RustCrypto/hashes`]: https://github.com/RustCrypto/hashes
+
+#![no_std]
+#![doc(
+    html_logo_url = "https://raw.githubusercontent.com/RustCrypto/media/26acc39f/logo.svg",
+    html_favicon_url = "https://raw.githubusercontent.com/RustCrypto/media/26acc39f/logo.svg",
+    html_root_url = "https://docs.rs/hmac/0.12.1"
+)]
+#![forbid(unsafe_code)]
+#![cfg_attr(docsrs, feature(doc_cfg))]
+#![warn(missing_docs, rust_2018_idioms)]
+
+#[cfg(feature = "std")]
+extern crate std;
+
+pub use digest;
+pub use digest::Mac;
+
+use digest::{
+    core_api::{Block, BlockSizeUser},
+    Digest,
+};
+
+mod optim;
+mod simple;
+
+pub use optim::{Hmac, HmacCore};
+pub use simple::SimpleHmac;
+
+const IPAD: u8 = 0x36;
+const OPAD: u8 = 0x5C;
+
+fn get_der_key<D: Digest + BlockSizeUser>(key: &[u8]) -> Block<D> {
+    let mut der_key = Block::<D>::default();
+    // The key that HMAC processes must be the same as the block size of the
+    // underlying hash function. If the provided key is smaller than that,
+    // we just pad it with zeros. If its larger, we hash it and then pad it
+    // with zeros.
+    if key.len() <= der_key.len() {
+        der_key[..key.len()].copy_from_slice(key);
+    } else {
+        let hash = D::digest(key);
+        // All commonly used hash functions have block size bigger
+        // than output hash size, but to be extra rigorous we
+        // handle the potential uncommon cases as well.
+        // The condition is calcualted at compile time, so this
+        // branch gets removed from the final binary.
+        if hash.len() <= der_key.len() {
+            der_key[..hash.len()].copy_from_slice(&hash);
+        } else {
+            let n = der_key.len();
+            der_key.copy_from_slice(&hash[..n]);
+        }
+    }
+    der_key
+}
diff --git a/vendor/hmac/src/optim.rs b/vendor/hmac/src/optim.rs
new file mode 100644
index 000000000..32d6277ef
--- /dev/null
+++ b/vendor/hmac/src/optim.rs
@@ -0,0 +1,280 @@
+use super::{get_der_key, IPAD, OPAD};
+use core::{fmt, slice};
+#[cfg(feature = "reset")]
+use digest::Reset;
+use digest::{
+    block_buffer::Eager,
+    core_api::{
+        AlgorithmName, Block, BlockSizeUser, Buffer, BufferKindUser, CoreProxy, CoreWrapper,
+        FixedOutputCore, OutputSizeUser, UpdateCore,
+    },
+    crypto_common::{Key, KeySizeUser},
+    generic_array::typenum::{IsLess, Le, NonZero, U256},
+    HashMarker, InvalidLength, KeyInit, MacMarker, Output,
+};
+
+/// Generic HMAC instance.
+pub type Hmac<D> = CoreWrapper<HmacCore<D>>;
+
+/// Generic core HMAC instance, which operates over blocks.
+pub struct HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    digest: D::Core,
+    opad_digest: D::Core,
+    #[cfg(feature = "reset")]
+    ipad_digest: D::Core,
+}
+
+impl<D> Clone for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    fn clone(&self) -> Self {
+        Self {
+            digest: self.digest.clone(),
+            opad_digest: self.opad_digest.clone(),
+            #[cfg(feature = "reset")]
+            ipad_digest: self.ipad_digest.clone(),
+        }
+    }
+}
+
+impl<D> MacMarker for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+}
+
+impl<D> BufferKindUser for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    type BufferKind = Eager;
+}
+
+impl<D> KeySizeUser for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    type KeySize = <<D as CoreProxy>::Core as BlockSizeUser>::BlockSize;
+}
+
+impl<D> BlockSizeUser for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    type BlockSize = <<D as CoreProxy>::Core as BlockSizeUser>::BlockSize;
+}
+
+impl<D> OutputSizeUser for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    type OutputSize = <<D as CoreProxy>::Core as OutputSizeUser>::OutputSize;
+}
+
+impl<D> KeyInit for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    #[inline(always)]
+    fn new(key: &Key<Self>) -> Self {
+        Self::new_from_slice(key.as_slice()).unwrap()
+    }
+
+    #[inline(always)]
+    fn new_from_slice(key: &[u8]) -> Result<Self, InvalidLength> {
+        let mut buf = get_der_key::<CoreWrapper<D::Core>>(key);
+        for b in buf.iter_mut() {
+            *b ^= IPAD;
+        }
+        let mut digest = D::Core::default();
+        digest.update_blocks(slice::from_ref(&buf));
+
+        for b in buf.iter_mut() {
+            *b ^= IPAD ^ OPAD;
+        }
+
+        let mut opad_digest = D::Core::default();
+        opad_digest.update_blocks(slice::from_ref(&buf));
+
+        Ok(Self {
+            #[cfg(feature = "reset")]
+            ipad_digest: digest.clone(),
+            opad_digest,
+            digest,
+        })
+    }
+}
+
+impl<D> UpdateCore for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    #[inline(always)]
+    fn update_blocks(&mut self, blocks: &[Block<Self>]) {
+        self.digest.update_blocks(blocks);
+    }
+}
+
+impl<D> FixedOutputCore for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    #[inline(always)]
+    fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {
+        let mut hash = Output::<D::Core>::default();
+        self.digest.finalize_fixed_core(buffer, &mut hash);
+        // finalize_fixed_core should reset the buffer as well, but
+        // to be extra safe we reset it explicitly again.
+        buffer.reset();
+        #[cfg(not(feature = "reset"))]
+        let h = &mut self.opad_digest;
+        #[cfg(feature = "reset")]
+        let mut h = self.opad_digest.clone();
+        buffer.digest_blocks(&hash, |b| h.update_blocks(b));
+        h.finalize_fixed_core(buffer, out);
+    }
+}
+
+#[cfg(feature = "reset")]
+#[cfg_attr(docsrs, doc(cfg(feature = "reset")))]
+impl<D> Reset for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    #[inline(always)]
+    fn reset(&mut self) {
+        self.digest = self.ipad_digest.clone();
+    }
+}
+
+impl<D> AlgorithmName for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + AlgorithmName
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.write_str("Hmac<")?;
+        <D::Core as AlgorithmName>::write_alg_name(f)?;
+        f.write_str(">")
+    }
+}
+
+impl<D> fmt::Debug for HmacCore<D>
+where
+    D: CoreProxy,
+    D::Core: HashMarker
+        + AlgorithmName
+        + UpdateCore
+        + FixedOutputCore
+        + BufferKindUser<BufferKind = Eager>
+        + Default
+        + Clone,
+    <D::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
+    Le<<D::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
+{
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.write_str("HmacCore<")?;
+        <D::Core as AlgorithmName>::write_alg_name(f)?;
+        f.write_str("> { ... }")
+    }
+}
diff --git a/vendor/hmac/src/simple.rs b/vendor/hmac/src/simple.rs
new file mode 100644
index 000000000..e28c4c34b
--- /dev/null
+++ b/vendor/hmac/src/simple.rs
@@ -0,0 +1,106 @@
+use super::{get_der_key, IPAD, OPAD};
+use core::fmt;
+use digest::{
+    crypto_common::{Block, BlockSizeUser, InvalidLength, Key, KeySizeUser},
+    Digest, FixedOutput, KeyInit, MacMarker, Output, OutputSizeUser, Update,
+};
+#[cfg(feature = "reset")]
+use digest::{FixedOutputReset, Reset};
+
+/// Simplified HMAC instance able to operate over hash functions
+/// which do not expose block-level API and hash functions which
+/// process blocks lazily (e.g. BLAKE2).
+#[derive(Clone)]
+pub struct SimpleHmac<D: Digest + BlockSizeUser> {
+    digest: D,
+    opad_key: Block<D>,
+    #[cfg(feature = "reset")]
+    ipad_key: Block<D>,
+}
+
+impl<D: Digest + BlockSizeUser> KeySizeUser for SimpleHmac<D> {
+    type KeySize = D::BlockSize;
+}
+
+impl<D: Digest + BlockSizeUser> MacMarker for SimpleHmac<D> {}
+
+impl<D: Digest + BlockSizeUser> KeyInit for SimpleHmac<D> {
+    fn new(key: &Key<Self>) -> Self {
+        Self::new_from_slice(key.as_slice()).unwrap()
+    }
+
+    #[inline]
+    fn new_from_slice(key: &[u8]) -> Result<Self, InvalidLength> {
+        let der_key = get_der_key::<D>(key);
+        let mut ipad_key = der_key.clone();
+        for b in ipad_key.iter_mut() {
+            *b ^= IPAD;
+        }
+        let mut digest = D::new();
+        digest.update(&ipad_key);
+
+        let mut opad_key = der_key;
+        for b in opad_key.iter_mut() {
+            *b ^= OPAD;
+        }
+
+        Ok(Self {
+            digest,
+            opad_key,
+            #[cfg(feature = "reset")]
+            ipad_key,
+        })
+    }
+}
+
+impl<D: Digest + BlockSizeUser> Update for SimpleHmac<D> {
+    #[inline(always)]
+    fn update(&mut self, data: &[u8]) {
+        self.digest.update(data);
+    }
+}
+
+impl<D: Digest + BlockSizeUser> OutputSizeUser for SimpleHmac<D> {
+    type OutputSize = D::OutputSize;
+}
+
+impl<D: Digest + BlockSizeUser> FixedOutput for SimpleHmac<D> {
+    fn finalize_into(self, out: &mut Output<Self>) {
+        let mut h = D::new();
+        h.update(&self.opad_key);
+        h.update(&self.digest.finalize());
+        h.finalize_into(out);
+    }
+}
+
+impl<D: Digest + BlockSizeUser + fmt::Debug> fmt::Debug for SimpleHmac<D> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("SimpleHmac")
+            .field("digest", &self.digest)
+            // TODO: replace with `finish_non_exhaustive` on MSRV
+            // bump to 1.53
+            .field("..", &"..")
+            .finish()
+    }
+}
+
+#[cfg(feature = "reset")]
+#[cfg_attr(docsrs, doc(cfg(feature = "reset")))]
+impl<D: Digest + BlockSizeUser + Reset> Reset for SimpleHmac<D> {
+    fn reset(&mut self) {
+        Reset::reset(&mut self.digest);
+        self.digest.update(&self.ipad_key);
+    }
+}
+
+#[cfg(feature = "reset")]
+#[cfg_attr(docsrs, doc(cfg(feature = "reset")))]
+impl<D: Digest + BlockSizeUser + FixedOutputReset> FixedOutputReset for SimpleHmac<D> {
+    fn finalize_into_reset(&mut self, out: &mut Output<Self>) {
+        let mut h = D::new();
+        Update::update(&mut h, &self.opad_key);
+        Update::update(&mut h, &self.digest.finalize_reset());
+        Update::update(&mut self.digest, &self.ipad_key);
+        Digest::finalize_into(h, out);
+    }
+}
diff --git a/vendor/hmac/tests/data/md5.blb b/vendor/hmac/tests/data/md5.blb
new file mode 100644
index 000000000..731a0ae4d
--- /dev/null
+++ b/vendor/hmac/tests/data/md5.blb
@@ -0,0 +1,2 @@
+  Hi There rz68Jefe8what do ya want for nothing? ux>jn1
+]8 d V4RL۸3keyVThe quick brown fox jumps over the lazy dog F>wI-Iu
\ No newline at end of file
diff --git a/vendor/hmac/tests/data/sha224.blb b/vendor/hmac/tests/data/sha224.blb
new file mode 100644
index 000000000..dabb20b3d
--- /dev/null
+++ b/vendor/hmac/tests/data/sha224.blb
@@ -0,0 +1,2 @@
+(Hi There8oh2|ԝ?GOShK"Jefe8what do ya want for nothing?8	ۿEi:~maH ^D(d85iM}jde]i32	
+d8lPht<j*b|jn-Z((Test With Truncation8*h7Ɉ۟o	WJLlTest Using Larger Than Block-Size Key - Hash Key First8ۖ -oԙҷ'?0This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.8:Af]?Tгgpۜ+e
\ No newline at end of file
diff --git a/vendor/hmac/tests/data/sha256.blb b/vendor/hmac/tests/data/sha256.blb
new file mode 100644
index 000000000..6b5b288e1
--- /dev/null
+++ b/vendor/hmac/tests/data/sha256.blb
@@ -0,0 +1,3 @@
+(Hi There@4La8S\ί+ Ƀ=&7l.2Jefe8what do ya want for nothing?@[F`uNj$&uZ ?'9Xd8C(d@w>6FMБ)Y	>"cUe2	
+d@U8D<́:xz.?g)f[((Test With Truncation@tsnyl)UU+o|
+j` lTest Using Larger Than Block-Size Key - Hash Key First@`1Y&!7(FT0This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.@	/'c_հDcdOQS\:5
\ No newline at end of file
diff --git a/vendor/hmac/tests/data/sha384.blb b/vendor/hmac/tests/data/sha384.blb
new file mode 100644
index 000000000..d5cddb312
--- /dev/null
+++ b/vendor/hmac/tests/data/sha384.blb
@@ -0,0 +1,4 @@
+(Hi There`9DHbk%FƂL|ŜꞩnJRJefe8what do ya want for nothing?`EvH@1axҵk~dG.sc"D^"@^iǋ29I(d`&歊
+Ȩo
+5G>YfK*Z8N:O'2	
+d`>ix<%3blzHP W|nW;Nh#ħyt((Test With Truncation`:4P;*#na,L\ˮ@b&*7͈cAlTest Using Larger Than Block-Size Key - Hash Key First`ND>:ŴO*+X<:.@0$cIR0This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.`f5/%N,`$ λFŦx1m8`FR>
\ No newline at end of file
diff --git a/vendor/hmac/tests/data/sha512.blb b/vendor/hmac/tests/data/sha512.blb
new file mode 100644
index 000000000..b79ae49fe
--- /dev/null
+++ b/vendor/hmac/tests/data/sha512.blb
@@ -0,0 +1,5 @@
+(Hi There |ޥaO$l#yNxzгE|ڨ3ָ'N依Nap.il :hTJefe8what do ya want for nothing? Kz{;Vࣇd".'%TXuZJmOe걣MJkKcn
+87(d݀ sVul鱵ݎ6U>3'9>y"~gF7&t'Y22	
+d̀ FV7EiJvK-oP6۩^y'\xcAO-((Test With Truncation A_bqX
+SAyP*O6f:mq[P#P3dEOg)gsfklTest Using Larger Than Block-Size Key - Hash Key First Bc{贛FJ7RkV7_%!]jROs?
+싑Z]xe0This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm. {jw]}ߩn^?޽qr]- D,<I^UFvmD`et@jX
\ No newline at end of file
diff --git a/vendor/hmac/tests/data/streebog256.blb b/vendor/hmac/tests/data/streebog256.blb
new file mode 100644
index 000000000..99d972294
--- /dev/null
+++ b/vendor/hmac/tests/data/streebog256.blb
@@ -0,0 +1,3 @@
+ @ 	
+ &x !CAEecx @_}׳#E417
+uOЯm|Ԓ.
\ No newline at end of file
diff --git a/vendor/hmac/tests/data/streebog512.blb b/vendor/hmac/tests/data/streebog512.blb
new file mode 100644
index 000000000..8f0f151fc
--- /dev/null
+++ b/vendor/hmac/tests/data/streebog512.blb
@@ -0,0 +1,2 @@
+ @ 	
+ &x !CAEecx  "_T17ߛU q:w=_0~L)/:Oy fQ
\ No newline at end of file
diff --git a/vendor/hmac/tests/data/wycheproof-sha1.blb b/vendor/hmac/tests/data/wycheproof-sha1.blb
new file mode 100644
index 000000000..a4f8f4363
--- /dev/null
+++ b/vendor/hmac/tests/data/wycheproof-sha1.blb
@@ -0,0 +1,17 @@
+ ((,M( (}ѴtwPb$6X(LNm]=4pk=l(m=7U]--{{*ԇ(RP%)緓܎O}1/' )($--n`( =B.w׬&($L#9G76o+(KNڡl(gW;,(A%S.kb^|ZC4g(S,<ɊsLdg0
+<o&(%@mzEHMV(>n6au{[,?)Ϊ(i$3KHAsV_ߌtp(S_4K9B1-~3(K('=>$-#O5R@(" $b?`O)kzPc(8;<LJ1m3O(Flٲ%s?L<N(v5#3[hQ
+(QA)@L-j'bˮ$(+ȝajdl(o,) M&U,(+TxAdQ>(*)4@qلvK*ڬ=~R(ufjY(VJV)"񐈨B<́j(mXQ$޻WQK Pu(E'/;!VIX]?^U"e{,(x!pukѼe7y(}\?FNu8/z=kR8+@B.(?hC,&'f#C18(3uQ/HH3cV }̃)e$8(4kG#Vg&f(|zꁂ8,42"[@mFE(xS!>~R:%)B( <!zM;(0҉ٖx7I)XZ('mSPSjc(AnskXs@@|ӄ]+{Dg0N}($2;~~:ݏU˙ |U(o<U5p/p7Y^6"<]HeJ@W!1q -4}=(4<KT0&7(b_x `+|:`F;w\dד)O>S3J	yF
+%l(Y!Bv.bzD(LAg-Bjbsyo?sWYhV:u-ΤE,"Drϥ(?TcXƟt(PzYk1sc6`xJx״nVɖ{ؼ-$߈p/u)c.9ok_B5EiONܑ(Mt<RaPK-/"mIJU:@<(ӓ.3?O()f3$RWU=(F~L7YQTD"Gvb%Hc{D7[eAc71)Yf\2jhǮ:`&Lm OC/|,_KgBjTAe3"D/j"(@3e|*Y@_(c):dfD T	a
+\?`_kk)~^.ёӜ;]eG)P:U+32zw㮄ANMˮ>V95"
+;k-ݫ.hEI(]e@(#֩7r/EW]ޙ(ikeZ ɢ8+HsB5~2P0}19dp| [K HՍ!g?^9'G^A՜s3?K\'ÿa;uYIt[0OR[APzQfJ. 6c|GUEHf٨HvEuѕN[	Uz%|.
+Q5tBj8pHXK:NicB,|F}7(HkY`J:-La/zZ-h	d>M&~1(3F#"1ss卑(^it/fDF&C&ޱ& 4OQw<(N;-Q(9|D!:-:,/+@(\`_;"4÷"0H(~Y#^ȳ 7w
+x|V_(eᕦ$PC|hqGND@b@f@(I]l.W>jwa2
+fcE͜~z(gQLLuҋpޠik"g&Pj7-(%n8Áe凼,r![!A,Yh(w9Pj}22UߍSo<$I(UU[@)v<3"
+iS<i;-܌(7;(dձ\b/'U1mZ<w$$ͭSw(T[|%+Ŗ'rxjs-T8n0!6Z¬i(%8^`bEV6CDۆGb&݆(hL0;1dhg+coۈ-۬(÷^uDBK06i<;okLq=aP(gGQaPUqxq<uvS3={Ή(RԢ`p(Fz%M<^m
+ =ЙNQFWu n'i}(8("}ĴE=F]ղ"z4DBD">zTJ (!@UjMZg0?Vޙjod^^a/%	\o(+D$"K,-@
+6T'4)zP`Bͳp]Au(HÐ|6&`=^hC%N^K;QBU>EAj\"<8\("}ykxg@<7gO`9:v%tJjīs~<2RS*zt(W Ċyq5wTUb̕(n<61x9|F9R@d9Z6(Z豭yG@CC(jy^:@qJlĭÀ`zMZӍ{ôAsi}Ra ht
+6Q	[M|r;/ݤ_cwZ ߴ	)7Sc{ `G\33Q]^2"z?(  4&3]NPb5O~cB
+T?`#N`9Q^O@tMj[?ӗ^ߛËr5Ö>M_4S5>paR!f?$ h2, !y:n=:wZ(źPBDPSŎ)b&9 |r'mڈd0	BChnh1䍴PZ>9Y>fC7g9+dYDi_$z*>@L崆"$%ߡ?lx'jKD+I-^n0(kԆΓL/_B=%{g~aKn5n3>\N`$x^cLNƻ!=%OX=c[ԃWQ<Ef+0	Yk3D	@E]KUSetqmlBXq%XTaq ,y:q]nXϫ	@RM-2Qu &yP`(rWJv=U`%<f=lpJ/~OН*#i3
+'m;@c5D: (t6)B<5~f VF ).WXDM(m#\R7?T#b.vz
+u@Q7(dk?P"> Upp2T1K( &e1mjr:"Ziq/}X =m=!# f]/ nvmFFִt|(U8g@Q8Vmos }JYNvX ӪЀ@@D-g|w(%;S eU Ď pJNs1qd  (z)ɕs">+f;Gշ+`ۜZAe֏PuY72[uO0pZ b4"2_(#wE&p߈zKAnlCߛƸAJ>s[&9ᗛTh6"3T#l5)_+0^Bތ@𤹣n=s
+;7węoPT|(e<Y:<(Z;,O %*ژ(]t?اǞEL+ABTqn|\V,ʆ컉# hRmf.hgprcP,uB_$TԵG(/܉8k*ةk,R5q'UZf Cd@eUPԒŨ_n\~" )`.B	)#FW~脗N<u"+;߄Mԛ[`7<j@Xo]rqw}4]bUo4l\n10$Zn
\ No newline at end of file
diff --git a/vendor/hmac/tests/data/wycheproof-sha256.blb b/vendor/hmac/tests/data/wycheproof-sha256.blb
new file mode 100644
index 000000000..62f1d3570
--- /dev/null
+++ b/vendor/hmac/tests/data/wycheproof-sha256.blb
@@ -0,0 +1,28 @@
+ @"\9@v l>yU]OZwy @u}l3cSsJ[3@Y<dɦL&o?lѳ=*w@]^{vYLArUQBhr@˪%ɶ¯Z=mcҩ<HA@;!ݡ0NjV{2$Cs@H4\te,6}#7t4çmǸ@lն˵ˁzf ͈wBYm@ދ[[/	d[~dƳ:%5}5z19e@u8~b#f?JiMt_@2i <5dA)|
+n@?Nвcfg^kjZn3@M襣\;G[cxf~]@9##\<RtTse66꤭+F@2Bl-*
+KhDrVm=:QTAc~A@rHw+2j]3J @#>O #[iwfc]|f<I8Km
+@&U4bQ<y"޶0=a-n@sN+7z8@!@{TfޥJ@"~ىSGXm4FS:=@EjUja5)Pq6?5a&<SFf@x<&k,-׆!OQGE+tX>@[$s^L>JJďc&>KNM@lѧ[=(dnESvb"@_F	W^ߥbu]0\N@ӫu֠"_2@m\
+k<H$B0V8Pc @z>4~vul#v)<ʼ2J?ǄtdE@W $4r¸G_}Y/:5@ Aa^p!w?#.M7l8(QHXK^qF@\r`<`v/p4Jw ^F@?RdL2S\Ήy*vByrIF,@&45z`ݘq!@oSqIT#~.< >MLH.&@8zȚdVIYtWŪƞ@S Hʆ"S*yd3u8$"+I33v@[i,Oí˰50?*IwP"@8>|\Gjb&# G6ŠD*02pZU@'iq\x@NIY+dv@u5ѴhΪx9@n$$2eN?wS'@/F~8-w&Ξ]L1y@?=Ԩģ>խp! 89JY&(sH@(\~2%g0	3XoUT/%O^	 7GܩTME^y%tG2i5oAXe@x G+A4!=n+u@Tj⥕5]H*pU ~	`Pb=K_3WV=ECc
+B6}.us)@9i~pt3 bٸ7նќ,@iRt5B$=N^[]@jCb%Z((!vKy>H;^E&!@KM.Xo&i4֚+@# |Z?ryǮʪS獿`755dx}GHާjJF4cیQ73ui]V%^?	>i-BVs{倕ɘ?!caE[# )H@JyesRHJUP!ݪݪIF@|guHfG13ԅ17:M݋iπ~3;IQe,ݮt7 \vД}7֩9bYX#c*?i3j@I-jeq H{TKUq5Fs@Jn(pAzQkV5SR9sb0@D39	»0vPPQ }<
+lpO@1E@VN0Y&@)sP'GHā jm/Eο'W3ƆgwȷkҎ~qcI0Uey*Y񉤞pF	]w=@lUgS)!p4	740o_V2sD,@Y[@	 S]4,3Wuko94L@ɦ6RAy_H R{Q':DQۂ~im$Vޅ?(7ѵ0G^) Z@.CDɸkxC0[S!z%cL}IK)cnа*Hj;~2}wtW]gNb $<3;W@l$.-T$}q`]eVyUϢ~LicIhS2E}J/
+M΢tza=ӂƕ6ۓ@)wꭥε:_uBp۸@{6j!\"#?ڪt:˟xp=nC  `UG&8r@TlOʷs|dr@ r׋a@;k8}M|qh85SYNRG?_f )k6;YHh/iI̪@sp7}jزRGdO|[  -%Rst@9L=mEn{GJ.$maw*< M!	՘@%! ?Y7aX]ME|(M
+:^ ˊKA3P/JS<xd@fZ&Zfu	g&f<fxb<?V]? EޚD U@u"!8 G0[Ɂp⡯8:kWo umOm):@PZ;6"E<-yfPۢ.N~( @j\+Y_}`Y@B	8Bd'5kFm
+('*!(H' 
+yO\	>%y@d+9-gMn$C!MJ;Z;)/
+, q?`!XS@YUK H/89-ڦ5;g>Ll13n( Kv7.^\VN\Y@,o-whidfc{
+="p{MkgY.Q ŀBjNwwU@]Q)@(6WSj蒞RnA*NS Z Ͱ8-]
+@=](tXer%3?k	i~6/0W{I >D(uoRc@1LlCBTg*|5l!HYΆ]j :|3 W:{PD	@a.xCήaԖ%IOSΦQ+96 7_tZ/@ȱ k {6V@s!o-nq'%xݟDFd7Ed"${l>ܿՑ># nY|L8ahTF*@'%u(pd],]UR0DBpugk3n 1@#!4Fy@o3 V	<!"i@~Mj&|neO($s[[ $>HJJS@A gNnm)_bW1%ح껤^X;?5Gxxi$ )d%^Upsbٱ 43g qB]@d7>h.<&Tu	2(O|
+ڳ`9G:<aV֐ b6jޏr=طW ;Sॉf@{#{Sn,iPaa3=i Eő2N?ytb=b%b}?pzGv.}:_yG  ?+6	@&ct.[qNaL-YHabiTŊ*-`ja1?f5}^_񌊰c>G.z7XQ\lJk)VҪ al0Sݦ!~Eh`;R46B0?rNc vMyqF-@BLk"`o	J/L"wJ8R~obITŨZf=|+F8g'FЏ'O,?|jR~8 4X϶=udAМt%"^ @.:Ǫm^
+kS;yF`nKl 	 r֦=i@SC=SPIʫWy(Λ0.1 ;sO&C2&<u7r (ll!+Mh8h	*j:lp68ZM|WM[e*~yQR~Њ-=A*+$ @+#D*{%(@YF1߳KX!m_.YZܠV~#J<RGA3$	̓Lm|fm8E'v'_U\xT
+
+5ٿ/;痾|d\Z6;ta +Mcl!C b5$,yڏVV&R9bxep[r.؃_ߔG)}}$1L\
+Xn?I#f~y;ƑC 8#(2n6hcQü,` 0mVj>} I
+t	 @:7w\MuYhiq==K5Y hkNV /:P޹Z2@ 2=
+ '$#7St#	3WBu s"^Q:O@8)%=77jOdDC
+@|FWdsJݺ@RG Oǽ0ff  vZ☒)uK Z?^Vy3s N7B>SG y`m@r Ӑ.ЙlW"ro8@Ԟ𘪎0@ؓEl)@@HNؠ
+U> PrثF)Ye3 yv3ACW=~S͗N,7ݟՉ~.GJ?pw @@VsI.Haq1g(w3O3tFZԣ&[
+ш+K
+goUl2s7[M[o DOwP(u-@Ad(޹"p7N
+HB$1n!d!&(|b
+bpum|ycn4U
+د-Тp;5,W:9'@}_k4R:CuvFÔ?İz,51@Bdڋzw5 Ϣ>"uwNB5	.U L,qw\lBqΪS(1k03  joQ?&'W40V*kU5A`GZNB3XYrV.;*otjM?v錛k(doE_5 qq-Vs*BW e}^$+9sr_4AN(dѮwAS "3{᷅o+C)<i.S@C3-JGr<CR᎘ /Eד9}ݺh4
\ No newline at end of file
diff --git a/vendor/hmac/tests/data/wycheproof-sha384.blb b/vendor/hmac/tests/data/wycheproof-sha384.blb
new file mode 100644
index 000000000..69a787437
--- /dev/null
+++ b/vendor/hmac/tests/data/wycheproof-sha384.blb
@@ -0,0 +1,31 @@
+ `g}0	ya'p+玩l	~g `UM3FbI<BdNIyB0o{l)}Y`fܗ,q\9(ht)(X`h͎^a]+`6>s ߮pec[`sUf`Yb`^J
+cJ%Y|k$cjWa?hQCiߺ\S nZ`_J}bk4T	M-wZKϋ;V7px/%>`)(e/ rʝgvnIU4 <WӾpUl6Xؠ߇|`g*FnLIW(ľ&	FRy -FWo+kT`hj70\D(Ab!+'HmB+Mnnօfƃ`997j{o6<'$@koظ9I !j`-{+#.?DJHהp|pe+awYovX`fSs/
+w`.N iE	i񢖭LGA${;]$	֠`:ɫ=^EߙNRRx2pq8'Ga]F2=Z4[`x=ѢCtb_Hgwzmbi_p	(s:e@`:O5rқӤ	A\/>V`!aK#c@a8[[xq`"l{o%;y&W̑>M9ipo1=k*w`DRʼ]*jF[zѕLYr/Ik 缫6C%`V8?oH|LuI in 4Ұ@W9[%`yϱHv3ĥً_^`m09L(]`H%I35y=z`f_ĥH%(+"i==!EuT	(`H@Vӝ@;)BYO^<vK8Qg䕻
+]<ٺ1D`!=i6(	taYhcR2K6Bxgj:1`we`w|I3hv<kwf<lj(D0?W;"k%`ϴTI6N,BgH
+SB.b`D	go-`怱P1~N!xE¯T%
+VNHeeUe]Åxc`Gn}.>k4Na`u2#haUB~Ƚ+` ZbNPH>;o.̽Z*WYZEA#-m`ַ>~εR%xlqS\mn;`,#1 +SM(Fi{pW.VJrǎ?k'jnC^`\#¦n'ba=螴=y2b*9ӺjZ`Q~* ..y8־%k#hJҡBsbG ~
+,!⠡gxkr-7/`"dɸ5i_]FYAu+(sȡV	dV`P=txsRp<ȼVIʸ3-ʍI3o+V%?PN> no:7ON4`8fx&?W6Qf8)XH,c p1_Q>x_Dϑ`A4.v}MdF+dU	}Tf!m\ X"LC}coM/涥R`<1Kpp2wٮdAbz<.{mW*4Q)Gy>/j`;{~LOCoGb9;VH*m0xl 	(=i$2#ŕ`ul} ɓ_iIC:,[p6zVH\p>a`kҮݘֶ`΂Xo}v(d?8q`@3#jd"G@b} >d#!y`͋h֓@KI@DdcېQkl9h`/,ź
+5 ܇
+W4Kxm;H.ѳp^-tm.ۅ0s"49]"KO|Ah&A'`rYYbHr`l
+.QHn4._V҃Y~`^_`&;ns
+xo.Zi[;벅X`.jgb5R'J,F:,:D%]Q mG`n	~=N	;Vj QXi/+ķG2!Ȝŕ`1Ñ= XPSM%a6 l|SꭙA=`AbG9kSa trPe?EyJ{۾`:Ix~/g}-on# 3Mt7Ga6C`ޮ`wdnCt:*ҋmƲ>5jyb 4LϠw`@?QSXaB	x%m9mV  gAo(aU&2b'U'QD	+E?{MX[*Η a^05`Odtnz43DA0hւQ0A`_H6I]	`̩){&\#6^s@9\n\%Ęɀ~[@ӧ{us	ɽUREccdKD M&E{s	W$8
+&hsp5Z EE35NrKqFRO6{ù5&A`k[HFQw-l79d$ـeE'm|.~z`(^)oI0%iN2;NcURX$TF ƺ|iqCLVExDJn<ڵ[C&XZ#jㆳaFŕ*J.9nޘIѓr KynVcJ!!.2$t$Xxܣi`S9  j&KmғcB$q&Bk2dg/=uf`!]7CPGc3?o>3^brڟd
+>{~"da^in3K>g!&]Uyb6hH]8^vC]&tQ}""}e	lm:"KkN\l멩W; sO|8T~M-s1ǶWz}Ej=[4#&X6j`4P	(&y{<_9KhR'=z)a$O#]!qg?:!ǔ+Qxx;k >), `+ndxQ3N] *n6_E](@j/)7""k`ggd([0;ݜpAR]
+\G 0mfgcY15`ũĚ
+` do.Ve"+6!;j0\Pi$v?Ϯ`|0Z	ʜ]̈́V>;BI`[gY%ի &6Ksvש)N=GPȵۮ@G0M#G*4(w`<k\_efϳf33'WhG-biTQϫ07eZ!6,`:;L`+%{81).ƩX^H5{)Õx~>8[9wS0F8B~`lSnabb`( _3"Iɱf>l|wù=fK7]
+lʤ0r#_`+Lt$2Y&e`"ڿ2*cdD1!+1?~)%6^<R\BZׇ+v0?Dfm~"`V8E1
+=2	)WF9>CM\2%%vP0Hd; *oH`l&V,<E<dxr>2Èƌ6|1Z[yCh403Y:E^X^F`SA`DIpL~ƝH;oHDUNa.-\dI0.@:j@) /N8 Ǟ`h,rP${ϳ#-eg7窬ÆIW+
+.M0֏
+ѺPeR8HD`274tطJFղɨXPsM+4RCRn3MU6|e|y&0@YEx?KXv`	/.h3]G5Nt5ɬr!ߡr>! :OCZ%IWkpl0}EUx~qpߏwrՂou`
+c`^A"\#R4՚<HS"5fC۠ڳ]C]l0')pYwxIF($"`)~lFUl'+J]61UtO߷!_n0&Mm0oJ@z@u~gە`:%ͅO9XNMj?MYS=M(A?I)jH`_,%w	EK!0XZȗTp,'``:hZΟGǴagWNIr<% YxQ~ZO0zG섂4U89E`[b~ޤ{~ƿ krLGD"Wgd^c0?z#Y3:V!8ʴW-`vløʗWK2@8LRĶ`+!d2plfHH0޳G0"So@}}N`S$;0bS6L'eu-` VS<4ߘRʊ9.d1ӝ`bm8QnbaPd@TѤ1(A(};4vD0'rYij[
+Ԣ`_k)ag1x7[`|-@~wTT|Hnp&^j'iAN.#Sֱm-ؘ˷#N(6Jo:0 %҆*?BҸ`VmutMW'4DHϹ8cA	ha%b_&7ҍ`Q~Zf&]y&#>E`phɌ8^ wk0<G1xm`ANYMzBا-˥מ^Յ\|IF̯~Y=}#̏}bRyaASI9ZxhC^.B#1 0 ΅0ϠW1uk1{o}H`HtƊ;)R1:Q鍚t>dF!|1#&obˀ`qKe{_K^{C?۳`IcC{U YcP&,΢zZ0%,^c]iȻD(hֳl˧w0*2(Q\,]j`$,"ѵLȄU(!5#Cp:hQSmJQha ~^kf\p5>24SFYٱ#.fƹɭ 0?G6x9c.\O&9S
+nǋ.%;]C5XA"4m*vO0w9+W{vsP)^~X `1K|WZ.Jd抁o]bQ]rIKc5X`uvHF cÄL2<ΒhwHIJq/tg`uɌL
+6cbv&4dt Rzޯ'DT^ۏ		I{:*IY.܋>p/wMs/*E0gJ"Sl%+ʮ`y(gȒ$G|.Fap	yEu!R6jn'	
+~
+czjۭ:Q@lghyG0'AkaٸSmC,^dY	CD%HC\15D,%MT
+on/T
+!%q_+ eҺDFAYd.q%;g\my2D45Tl*|gղ뒒&S2y%cʶ?*aI:4&ny={[\gdh)xW=\eo 峛0l
+ǑP]90sfW2J0GnII_RTYA `l	Te.4={	)}ϟ^([ 2TE>G0!;D~T/. M|`TPʹMVNLhQ(!LF_o&	_U 0ڪMs2!+4N5x@`jNʁ_#S.(3͏`d	ñC?A`FEGmFN8UJ	`ri0kf Hb";I㸕0 0K,N*B~K7$A0c5Ds'=23 4w0-DGOA 70tD,Şr&{3Ph{@4t%wqd˶40o5.ܜ7`U0添).F5PؾqDG⅀oVnAF)Ly5>態EWwS"AX4dpA$zOA
+ `%[Y5RJ^lR6Tm!tYgmPޕ54SL:_]#`\cH=
+N9ʻI)r&W> :-|:p sퟢlŭV`.RD=?\AӰr(4`䶛͖Hy%RKƲZgTA}l]sm+6~K
+.%OG0(q@pJ :Y@>}x$$FqDZne	[/``AfPXףjnLx le-Mʂ@Z^=np	ھh #7mq?CaЄm?&j`}?+>p.0wkMl 0¬zԱďΕ5'uؕڜ28}Õ*UYvY< rkzk82]m  z	a[r,T-0Acs|!|^t8C=6e]N|Oؘ 52ڀWoUe-pPʶCn%MsN:{;@|wЯ]	vYvSw<0;ş0Rzt7pzc0
\ No newline at end of file
diff --git a/vendor/hmac/tests/data/wycheproof-sha512.blb b/vendor/hmac/tests/data/wycheproof-sha512.blb
new file mode 100644
index 000000000..e061fd554
--- /dev/null
+++ b/vendor/hmac/tests/data/wycheproof-sha512.blb
@@ -0,0 +1,35 @@
+  Se$K?#bGA(-)^
+	{}wtM$䉒QT  ХVh:$P>-./Sd!ngLUxȡAiQj^)1՟O  iw,gi>XǶizd"8M/WNNƷ-/	$Hu.6 M	,/X]F&~zLF$w+&Bg;v= m]ګS
+5xTluP¤OR3Ј(*Yhv@mͲp:B W~YL@ԗSuQNt	>Spو+y|IODL0 F<^imxCw]GF=, VT()@N5T~dJ3d e^[V K	9\#``uc/,t{gHɁGjɾgvѨ*k/Qg K.\98 d'ZS"K		\7^'qJxH v@g[8d7{. 6Alܔ#ˀ@# zZ# cP;dT3|}/oѴ	e1\4 oq@3R@	fq71+ݘ
+; /WFʸipq[@SjU3P>QkX}<VhC5ZbUf o%X
+zWUV.'<lg4Mt t~eG'=]07z6X) @7zyz%}?utmegW,Ns_{e[:DW},= p$RQƷȇQPAFr|2@`2xvz+esZ(tB,?Z/፣ HTylp]z͢ymn'bXg@Ԉ#o)%ȁh`rSoI=#f N=	q茴γ`+3I1ǯIeQrπ8ZKK{KsQ:lsMf)52À hn+N/YNi́UO3ZkE"c&^ԕA3LG]D)" ,CvrێntFKݔHDT/.w]G|F
+ITvKJ8Xj(<Ā ƛ4[H:CEjv&@]-¼;~6퀺lM+jQD51{yǩ L?k!7Q6czйq?ɳo=R-rSDTӍzߜ&:qլWV;}e D )4]}N/"P.)e]gjHGH%=UL\tZhśiZC:0E [5w+@\g',F)zoYgZ"Qu~fvרR1M'HZ4-E c{+ԥg6%fnE^=uG	mowN#%6
+6{!r4ꜮOs!]3z Mv# ~-X~ch)c	aS`r近VE^G;K$S[<)$,1نmjİ OIJo`UBjsͯٍ&1xovܩZC_f>r`=K5}
+׀ ]!yQCͨ#-qvN(ۨbo6PHxdG?r/Pn_`jQf<B) v/hN?D]2frLui.Gb䃫_td%	4Ԇ^h3G]MKL/ ^٠ JxN2UO*go2'k{csPuy?M3غfQ	AD鸽 Ɵx~bYOƫ Ǘ՝J9nыR㪲&Bd VIT (<BY#;uN~0=v$ĺ"' ;w0630$ͩǀ ʃ>vOA+M~HG=ir/c@f'01%u 1?O|$Ԕ?G]@	wp!wrɌuOBS	,Aۍ$ tb<'ZE* GUGX׃}\3bkv^ԺBy9{^TW,A-,/ 2=_u-{!P -o8降#! H.K7tAyKR݌"M" 5L.> B |N/C|#ge=cLXYdE"
+5TE?m=dF	wݲ<hA F[!%̢)D㓰g}ݓ$dW#mn=Jtv6}-`g!)s0݄YGgC>߷ɘ C<q2ie7f4)]wf"=ph~aʒ+ &y/Acп<9,_y6YRXZ=ӑ+`ֱ@VE ?@)r6<e xn;Z3qcYT I:ru6}CJkpHLvE_ hV^h`{S0}|
++qoNufp u@9'Ώ{Jbt͖\Az7ah4VTi{A%05^uߧD['Td?|d"/誰OG*%NQ4CE* =V@EPS?+jutޛ4<h΋j=K_LlɚBiq Q>v"꼶iF@"Ha;,?u@ eAHBji%(`e	7qjOףuwL"43ET~MH#iZ .Et+2Q
+)pGdk*̬By4\.Z]rڶPXr b|r$}4bwF@">K5,z~4g8{6P6\Y-bh˵/9nHA,GsR [z]O8Po4`z w1Ի4*^SSB'}˼	KRs<8/
+X1>Y_ [ꔀ6pKvcYࢀEٸ]D]r0ofhd-$󼮢`D9D2L4Cb]ײN|Q
+!\><o`@O*䦧1k1u	T4s{alxpAހ .юhrH4*Aƀ钸	']Gɑi׀G&u*5N=|z!6_ *R~ sk[a cޖBŔvlsج0r<Ji\ucoWNUxM<~Vt$"ua`^Q*$ưr=IioiIT#!\}|J)>h\PYx: -KVC,^{P^69Sh*e2 g!.>,@3WhQX*}le,)\I%+Wt6U Nm цH'#4vnKȉ+XL#p^jjy2(ULxe WycsCeE<1D#Cfmqz;Ys#vr#Uf'9e9θ|~ewK[ڈ(押A`푲F6e~<PНgL	CJL8Fiΐn wß%uRVaW8T2(lw dyX1pdcBuxuI	5X q0;F9.`8.8Y|-Z@""#g/Eb x.N!,8~װ(/}?ebޢY|Oe\D'(6ێ7MӃV'3)ٺJw|iԷ,'[O{8T7a#myAouA o짺T	\$ AJ8JqZ@={`Ը<`Crd\r^t/k85~yL8(lcT7Tu& W͒-[ޣ':^"!US2w:z
+r0	eM;Ī>  /m=0̪rl%FX2pTc38p*1 IW n2j3-fP_K.O[,P24\*tT!؈%q @u^5 OVDt\{o8N+k L7cm`v	ѣ7^s宕Nt7Q9v*7	$
+@[DSp]փ$&uMހ ϼ\Co"$d^ g;ag7ђ ?:qołL4supik@r`pvbriT40h ?طYӵm8gcÞ5/Z֤^D*ؔ[\(
+XYqe)Esdʏ9<@Ė(7Pś'^^9Q* ?IwzZ)M9z QAEJ&.z͏A@h}gv> )栜KW̢ƕ J$<aG{	SQ2t%XrK>*JPq4$dwpSF|/
+@3@_6l4w-3,=-͠{K7 [ʲοXtz\HWjغ攣d卻ԓ0ѷW*eiVų[gwL&GZ@
+t7btѪRcbΒN!, 3Y<ymMc<F|P[cB	~JS-l/*+<K@~com4ilUkQ<`-< <VSEJl~~7hd07,ʐX0qT
+`-FFCZ4Cb3I@v3^>%7;YжV^ :vť _EβY6EAAD ?)6-`L<%=bdi.@B[y\P@s!DEj'63ҁr=}pM XvNsqdLpBmbT78֥hӰWÖ4&h=*`[@{L*ob!@[%4F{
+$ϫg'b?">] |Wx!:Z7fpB
+b4̅MA>M*S.Y(RX@ʬLH\@f7	4sn֬"sJ!6&qm {pڢ5 }u'QJ1Ĺ䴡P{G!J{[spx9iz@#R-2`<Y󅉦򮛕@@ 7c
+(u!qP ]#bE> 1m8TB8vʒ-&mʰ|o/>V{I@	Yf;̫Ʉ3?.+GXex RjdZ)h[Π
+`i^bG꩕R5Ϧ+¯u:omlhUS@P=[B19L	9e `&zK$rFsJ:_
+ܭsXIt]A/t͉JS_jz@-gqhȍ$ē5˘Z?: =,T<0)If/CLB=6%_IeSjy8VL|ˌ cu)T iv1jԸH=@W}b'9/4%Cb3Qf %6eӜ:駳B~+xR%gddidZ8%Q`#Cw]."t,MtBj`#@s_+G҈Di܁Ul&qߦ@ H1IbC`˿8+Brbs]|p*s~-ЉPJ};L@liK0(崿ҴFl!cc@d)\lΉٞV*Ա6DB|9(8 D}eQၛ<A"`YT1}v!"2"g2BB8n^+n.)nh@y NdCp<Y/ǖF,t}}@Tf},O?d[K) ͯD.+ p ٴ4*Am55ldӎ+gH("4=:Hm~qu^C{pgRA(7ڨP&G//`P@.F	'z3u߁FP3-ˀ p7بSE^4T-߬frwދ|CG2jnS,zyл[^S`J%QstqޓjV_eegTT7E]@MJVm'&}rTOZIpci[ ;^!xV&9@l^0y-}酕hNX|Y/EcCK}%䡡l=YbO|
+DlP880x0+Z!yxMM4jO (]o!e=,@NpA޶ֺbnkJ͟ SXk=lCeIPyubL ЗFa-̺,4VBaV fv.Eo`BUZAt^NiJm.^
+	Y3/%(+|QeXA0ٮ[1P7]sդBNh܁=U< '{t-i#A|@j[br1R"H5 <4k9JwA x#]Yi&0<%	_0Nb^R	Z4so"ƎW܀~9W8zI^sN\yXǮ:X`&l{dm^;_s% >=Z"d+Şhzzуژ&t\Aͅp̥0MX~cz@38Xf wwcA#IatշC6k C{	>
+0hsm~7+l_MT3#Z
+2bhBdwgPǄ C=I4˫ڒ{<YGƢO%XpRJ$hV"[Xc	-]eթ81g81طf0ew7s쑉U`oE'_}bmGCoCb'5Ml@KQ%&[5%q\F7Cf Ғ%+Cz$BK[Mِ1ȫ	ӦXLǺk]CmAWڤ?|0S1ԍ~71a]az\[ շ0IUѴ
+b>9vŷվ6Uc.ÐIFkOiY.H-fkh>}J+,&m]{?zUIS=`-zҦdvK@#^H=;z}m&+??DK5R~vWb}I$}1iq'E\0@ B	ۄ ߗhЬxO@7Y(1Kgt 24Mt~Pax'  hMw.قT;lȿ^v+7,]#	EA~AW1Fi@qosb8zK2Z}mmu 1r-2,נqHe 4_jlLHfD$ ^'8$}->BBQkl<ڄ-c@@cRk dYryXmZՑAi(O@D93m$LqVSϰ_hʀ >' 
+DuPю1ytw_9~끭qhlpR[J@@'w9@"\9@v l>yU]OZwy @#Ԃ\~4kc­ղ3ǖL@oSqIT#~.< >MLH.&@ZE[Y̕=$5@n$$2eN?wS'@/F~8-w&Ξ]L1y@'8[o+="35F/^d-t۶bdf1E_Q_rm7l#oN˧\u=Eom%ٚ0  ~O}K;%mb'PtQ=l9 k 	Zm.7M`0vSMfp8NōC+1FpnǇ߾U΍PɠrZB3[ND/ױӅCnL&؍ݗJ$ 63^|G0d  ,h04ړwuE9y'G|#ܺ`81*j *>2` yU;N&yA ,*t>y("&ؐUMquiM@W|%$Rh{:i:GQm Op&{Of)LBC<*e!: 	9 	 $ne9vj=+ـF)Ye3 yv3ACW=~S͗N,7ݟՉ~.GJ?pw @eD^m
+,a. 0WtN(w3O3tFZԣ&[
+ш+K
+goUl2s7[M[o DOwP(u-@3բљXhI4rq$J";xD!&(|b
+bpum|ycn4U
+د-Тp;5,W:9'@}_k4R:CuvFÔ?İz,51@yν,q{ܯa<MA2
\ No newline at end of file
diff --git a/vendor/hmac/tests/mod.rs b/vendor/hmac/tests/mod.rs
new file mode 100644
index 000000000..d1798c891
--- /dev/null
+++ b/vendor/hmac/tests/mod.rs
@@ -0,0 +1,88 @@
+#[cfg(not(feature = "reset"))]
+use digest::new_mac_test as test;
+#[cfg(feature = "reset")]
+use digest::new_resettable_mac_test as test;
+use hmac::{Hmac, SimpleHmac};
+use sha1::Sha1;
+use sha2::{Sha224, Sha256, Sha384, Sha512};
+use streebog::{Streebog256, Streebog512};
+
+// Test vectors from RFC 2104, plus wiki test
+test!(hmac_md5_rfc2104, "md5", Hmac<md5::Md5>);
+test!(hmac_md5_rfc2104_simple, "md5", SimpleHmac<md5::Md5>);
+
+// Test vectors from RFC 4231
+test!(hmac_sha224_rfc4231, "sha224", Hmac<Sha224>);
+test!(hmac_sha256_rfc4231, "sha256", Hmac<Sha256>);
+test!(hmac_sha384_rfc4231, "sha384", Hmac<Sha384>);
+test!(hmac_sha512_rfc4231, "sha512", Hmac<Sha512>);
+test!(hmac_sha224_rfc4231_simple, "sha224", SimpleHmac<Sha224>);
+test!(hmac_sha256_rfc4231_simple, "sha256", SimpleHmac<Sha256>);
+test!(hmac_sha384_rfc4231_simple, "sha384", SimpleHmac<Sha384>);
+test!(hmac_sha512_rfc4231_simple, "sha512", SimpleHmac<Sha512>);
+
+// Test vectors from R 50.1.113-2016:
+// https://tc26.ru/standard/rs/Р 50.1.113-2016.pdf
+test!(hmac_streebog256, "streebog256", Hmac<Streebog256>);
+test!(hmac_streebog512, "streebog512", Hmac<Streebog512>);
+test!(
+    hmac_streebog256_simple,
+    "streebog256",
+    SimpleHmac<Streebog256>
+);
+test!(
+    hmac_streebog512_simple,
+    "streebog512",
+    SimpleHmac<Streebog512>
+);
+
+// Tests from Project Wycheproof:
+// https://github.com/google/wycheproof
+test!(
+    hmac_sha1_wycheproof,
+    "wycheproof-sha1",
+    Hmac<Sha1>,
+    trunc_left,
+);
+test!(
+    hmac_sha256_wycheproof,
+    "wycheproof-sha256",
+    Hmac<Sha256>,
+    trunc_left,
+);
+test!(
+    hmac_sha384_wycheproof,
+    "wycheproof-sha384",
+    Hmac<Sha384>,
+    trunc_left,
+);
+test!(
+    hmac_sha512_wycheproof,
+    "wycheproof-sha512",
+    Hmac<Sha512>,
+    trunc_left,
+);
+test!(
+    hmac_sha1_wycheproof_simple,
+    "wycheproof-sha1",
+    SimpleHmac<Sha1>,
+    trunc_left,
+);
+test!(
+    hmac_sha256_wycheproof_simple,
+    "wycheproof-sha256",
+    SimpleHmac<Sha256>,
+    trunc_left,
+);
+test!(
+    hmac_sha384_wycheproof_simple,
+    "wycheproof-sha384",
+    SimpleHmac<Sha384>,
+    trunc_left,
+);
+test!(
+    hmac_sha512_wycheproof_simple,
+    "wycheproof-sha512",
+    SimpleHmac<Sha512>,
+    trunc_left,
+);
diff --git a/vendor/libgit2-sys/.cargo-checksum.json b/vendor/libgit2-sys/.cargo-checksum.json
index 2bd1c3b82..5156706c7 100644
--- a/vendor/libgit2-sys/.cargo-checksum.json
+++ b/vendor/libgit2-sys/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"393446c2e70ebbe2bcec7ecddf72ad7e78a2b50d5637e58930cf627238563018","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397","build.rs":"aca064d4f60d2661a769604e0fddd2d0eb7ecbb6b7544a29361a36e7d6ba7468","lib.rs":"a11f5fbab6b8fc420c58b539de0ed99ca6239f380e83664ff6a035635895c70f","libgit2/AUTHORS":"d7d4f16a8e4303cc515fd4410b2c64b7ded924b1e8784a125d15195555e986b2","libgit2/CMakeLists.txt":"37f666fe9b6c7fb69a6edace16cff583f260626662c8edca59abeb1c7bc9266e","libgit2/COPYING":"0fc09da43d666b5b0cf5695defc3100d5cf387936b260ebab37e396d7e0dbc83","libgit2/README.md":"70e61736b253d42da3828d0ef16c052c48d9d1690a75ab476055144475757a2c","libgit2/SECURITY.md":"566da5b3e26904232486c2b7107a1ebb0dc90e8eb2f32b9468d0da41e1cd5543","libgit2/api.docurium":"c77dc54504945864b3270877a9ddcabe85d6d1a742c07232f6faf847958c0dd2","libgit2/cmake/AddCFlagIfSupported.cmake":"4be37a9752e3859c9ab8525f365fcb4392d1e5135ea222795c304b42dcf11b13","libgit2/cmake/AddClarTest.cmake":"022f6d1a498bead384338fd1b17ddcf72ce18d6ce54b6c0298ee3ea61c0d63ea","libgit2/cmake/DefaultCFlags.cmake":"a2b5a645f29bb3be74aea7bf5f5d83a77f68d3190363e83b43f9ba70a41c5963","libgit2/cmake/EnableWarnings.cmake":"f5690cb37a672c92696f618890da93d44eaa07f3cdad9a3515bb08125909ac0f","libgit2/cmake/FindCoreFoundation.cmake":"5f71227384a4914df198dc7766b6b8474942730a16c22de0c987c9548808f1c6","libgit2/cmake/FindGSSAPI.cmake":"6704673fcbc0c94c02395a3e4fd96f41fbe0111397f0f06dd9a912d11c1ddb91","libgit2/cmake/FindGSSFramework.cmake":"136f3282657cd83aa5a9ea4a3d11ffd14d839e637c6e2669aa5f0c0eb9d9daab","libgit2/cmake/FindHTTPParser.cmake":"ca1d95edef14b1e05449d45dcbdd93c386025c408cbf27a00cb4af4ab0d62a7f","libgit2/cmake/FindIconv.cmake":"b11c24e5fe2dd98662f87058eb9439e530f38aab4f27a9d241df48a087e6b4c2","libgit2/cmake/FindLibSSH2.cmake":"0cfe918a5d00dbceeae55ffeb5546f8c5595eb48558c2e9584561db17f29b91f","libgit2/cmake/FindPCRE.cmake":"2b1e7b45cf0410320e706573ecce75b8be4eeda6b9b4fa19893a248c57096a71","libgit2/cmake/FindPCRE2.cmake":"d8045c217a1856963badd52548406cab2881d2ae304608d6b40bd77bcb590f0e","libgit2/cmake/FindPkgLibraries.cmake":"e50a58f9d39ed58d5bfc39e6f18066b436cf92ccabd6683fed4f30cee9689627","libgit2/cmake/FindSecurity.cmake":"1c16ac77018f28efac83cd848c130d5127c22999dc48efe44bc8ee9b501deb29","libgit2/cmake/FindStatNsec.cmake":"4b3bb2337ce205580703704a2725eba085044810d54a0e0cc5680b6f71eb494f","libgit2/cmake/Findfutimens.cmake":"281fa0a75648482e3b13841d92db2c5332147fa8c7f96afe7ee11eae77a6bfd3","libgit2/cmake/FindmbedTLS.cmake":"23d2c96094b525b7a333427776cf51f0a1466a70d9358af48c8d851e20ebad64","libgit2/cmake/IdeSplitSources.cmake":"0c1725438bac95a6c56627408b81017a88748944b0ff83cc45c0824421e3aeee","libgit2/cmake/PkgBuildConfig.cmake":"fdf17c32ee3621b671695f29a1373f4e2d05606dad03a658a751e94a37385f91","libgit2/cmake/SanitizeBool.cmake":"6d93d776331f1cc9d4052ed53731789d6e141bba9ac8681dba70a80abb2cdc00","libgit2/cmake/SelectGSSAPI.cmake":"12bf9cc930b90c913906982979d84a3c6fc31afd439583779c408b525e57c6bb","libgit2/cmake/SelectHTTPParser.cmake":"1258d26dd0a1a23c37f02d8f8cdaa58e5e1fe4a6ad71863e1a573faff4abdbbd","libgit2/cmake/SelectHTTPSBackend.cmake":"3e945fb0ae9fad47b50046d5457522668dd106a3dd81464d723e1a969c0a1a22","libgit2/cmake/SelectHashes.cmake":"1686299ea6802989778176b4d37d86297a62a0200dcf3c25b394c4130e3966b4","libgit2/cmake/SelectRegex.cmake":"6c32e01fec5c3bc099a3b20fd10a08ce1594fcdccee2cd3f9386f6f7d77a9c82","libgit2/cmake/SelectSSH.cmake":"d913763a6342d50c49a2c42a4bd77dc3fc530c70bac193b34cbfe74b7c83ce8b","libgit2/cmake/SelectWinHTTP.cmake":"2916180fa2c0aa79f65866e5b0ff5b1c560cd4e0cd1b8a5162d401b660b4b6c9","libgit2/cmake/SelectZlib.cmake":"fa08bea6c807ac97f1790ca46590a4f7d63570e1b51e76240483f5cc4762e3a9","libgit2/deps/chromium-zlib/CMakeLists.txt":"f8c70a5cede31712527ba84f3eb0c0a8319cbf7643c6afb63c1fdfbed1e757d7","libgit2/deps/http-parser/CMakeLists.txt":"f3fb5bb432aa7267ce9f6aee3780346ee6d0899154a3f05a1e57eb13bc5a1822","libgit2/deps/http-parser/COPYING":"2996a1c43ee757f9c997a829d82bdd584052323e73cf02ff8126c6fbd95c2d87","libgit2/deps/http-parser/http_parser.c":"80930f8b6c15827a3ae571e77ddbdccca366e8f6c98874062cb8c0c6dc877ee2","libgit2/deps/http-parser/http_parser.h":"d3fd211486e4352f57a47e856a5a10dfce06c46211119d0f6d9935713d2ad08a","libgit2/deps/ntlmclient/CMakeLists.txt":"9740dba96683b30a304735acd2e2d6464441b22677058bb4a5baa5f20037087e","libgit2/deps/ntlmclient/compat.h":"f27a8e91c75ed75a71140c597548b43fae19b28eda1a09ab28e367a196bdad84","libgit2/deps/ntlmclient/crypt.h":"38647af40b21a8baf2c2e73e80ff631718b7fb0db51b0c2079d4bc85793a2032","libgit2/deps/ntlmclient/crypt_commoncrypto.c":"445b2f9d8f2cc820515d0bdf262d699e635061c81c2d617d7e3da9780817f7a9","libgit2/deps/ntlmclient/crypt_commoncrypto.h":"55a6fe82280421e5fd61f20be1938cc92efef1a211147072790eecc91eb87e6f","libgit2/deps/ntlmclient/crypt_mbedtls.c":"162fa2759c1073ce61a6bc2e7898a8c8557b8b4cda1191fca8af75200d971cc0","libgit2/deps/ntlmclient/crypt_mbedtls.h":"d10c8dee39844ad68a6f408d4134300b984279da9dfb9c7ff070a7065e5ecc26","libgit2/deps/ntlmclient/crypt_openssl.c":"ada5b18064c3dd95c4aa352103096c5a24fd6c843f3995c236be7a45a52c5fc0","libgit2/deps/ntlmclient/crypt_openssl.h":"8c87194b5fd0220f4b40ec5ddaed151c8a189a157ed3b3ab3595f5358cf4a62d","libgit2/deps/ntlmclient/ntlm.c":"98556b43c4e8cc3b2559c86c447d0df02338ce949dc84a691ecef9900cbedb2c","libgit2/deps/ntlmclient/ntlm.h":"5328219af7251999ea78a2d2d648a6d98943af7ace5fbce0d8cb5ad4b0bb4c60","libgit2/deps/ntlmclient/ntlmclient.h":"fa223a164392f53822703c80dfb1299d3483bab3b9ad02fec1058a0f50a55eca","libgit2/deps/ntlmclient/unicode.h":"ddb0cbb25cca1a2f413865070fd47c354f87caf66f868022dd288b90fe93711d","libgit2/deps/ntlmclient/unicode_builtin.c":"3bafcf95dd5c6b3ea3d54d7b24e7333c4af13f6051922d6f27cb6497f9962329","libgit2/deps/ntlmclient/unicode_builtin.h":"fb1674d49fc240f33d8120fea10504021a61f69967d933ed386d57d0b267127a","libgit2/deps/ntlmclient/unicode_iconv.c":"45f30469fa188781f5b61a645368d9fd9249f5c9d8aa8512708e98b242259f5a","libgit2/deps/ntlmclient/unicode_iconv.h":"7dd5cfe97dbbbcec94f3e1dcd6edf51785f6eb5510ef96607fce45ce1cc818a3","libgit2/deps/ntlmclient/utf8.h":"0b57540746cfe500009216ba3bb7bcbd1555c158648ec82fe26f16bef75adb97","libgit2/deps/ntlmclient/util.c":"94ec747cd810c90ccc966688d89ef8dbfb91e41aea2f665a13db5fa18ac26443","libgit2/deps/ntlmclient/util.h":"3b15e99337fa1555fd99b2434894cdef7c0ea96167f7b4ff4ae772a1d0982bb8","libgit2/deps/pcre/CMakeLists.txt":"1d4158a8b4f8f380e93c5764c8fa8c1820c0b517ad8f40d47084a06975bec6a7","libgit2/deps/pcre/COPYING":"17abe1dbb92b21ab173cf9757dd57b0b15cd8d863b2ccdef635fdbef03077fb0","libgit2/deps/pcre/LICENCE":"0dd9c13864dbb9ee4d77a1557e96be29b2d719fb6584192ee36611aae264c4a3","libgit2/deps/pcre/cmake/COPYING-CMAKE-SCRIPTS":"46cde7dc11e64c78d650b4851b88f6704b4665ff60f22a1caf68ceb15e217e5b","libgit2/deps/pcre/cmake/FindEditline.cmake":"44788ac3e7c8c4b4da3e5e0f467c7ee49de7ba9e1c13024dcf1e2501f8fe9684","libgit2/deps/pcre/cmake/FindPackageHandleStandardArgs.cmake":"aa3ef1f1c8742da54813aab0ac58c71edd1e58cd3b6b157b856bfd525adc2e5d","libgit2/deps/pcre/cmake/FindReadline.cmake":"055e1df8bd29e6837d8ebb8c15dd5dcb28c88e23aabda8538b76a249dff829b0","libgit2/deps/pcre/config.h.in":"480e3e1a1eea810516e59f19375575e83f62980d20b9cfc990ecf8e8cb17f79f","libgit2/deps/pcre/pcre.h":"885609063157d6eb0e3c74af413b608dcd60a94efa023319648a7a8a6e4daa20","libgit2/deps/pcre/pcre_byte_order.c":"4030a1156da8690352226b5de2c9c5f52cc6955409e4a7ab9ba4d6b223e74b3c","libgit2/deps/pcre/pcre_chartables.c":"3386fd60b4a4175a7baf474223522540abd6e006e8507a04d3485f84973424ae","libgit2/deps/pcre/pcre_compile.c":"74526b16f6683efd56742a6cacf31ec1d55dfd8a9fc04f66df59e5e1fbb4354b","libgit2/deps/pcre/pcre_config.c":"fb9e1e766291b2b4b3066ecfd0795db398762b9597fb2af23cc784617984609e","libgit2/deps/pcre/pcre_dfa_exec.c":"1cbf3a680388110bddff833983d3653630eedf6e6e9d9e656a737e3b85de9dd0","libgit2/deps/pcre/pcre_exec.c":"2a6871b9a56de682ce28a467d26b42caf71f4323e44b555db720cd51c0f2c505","libgit2/deps/pcre/pcre_fullinfo.c":"a84fc4cb4d22b2ddfcd4d0f0a0ff333cc9f623e1fbf2a7c90623a212e0bde54d","libgit2/deps/pcre/pcre_get.c":"c93ded768f96cc392f911776e6d993b565114936e08247dfa79080b35dada4e7","libgit2/deps/pcre/pcre_globals.c":"8b2fda23b42715eff2f01188c4911dd8453868ff77fccfe34b99126aa775fa5d","libgit2/deps/pcre/pcre_internal.h":"f713de1fa2c20b5414f6746c80d10878ab48c9186462b074c5bb6a74a822fa80","libgit2/deps/pcre/pcre_jit_compile.c":"76ed39027b25f2bdab581c0bb12b95fa3659baa53c81e10f8f17819d6255199b","libgit2/deps/pcre/pcre_maketables.c":"8564fab861c7eb4037ffcd53fda789a747a30c4a462f460a5ef824f534fb06dc","libgit2/deps/pcre/pcre_newline.c":"3163ed2193fa74d8cc9e1db2bba672bcebf8efe85c2465cc0aefda51966bd929","libgit2/deps/pcre/pcre_ord2utf8.c":"fa926e32ae8d6e5610c500e7b6971a5149765a1881f798b18904a0a88bf549de","libgit2/deps/pcre/pcre_printint.c":"71751d151efbe935e9d8bbf58bbe143d617b34acd13d1bf237330c7c7736c422","libgit2/deps/pcre/pcre_refcount.c":"0dd8b7273243545fdafab585890fa12e210cf526030eb6b877325ce89250fa39","libgit2/deps/pcre/pcre_string_utils.c":"b83225f9cf2658654d6a0af01199050f6fb36d903041b33cd4d0c06e762b66df","libgit2/deps/pcre/pcre_study.c":"f5285714b59af9503dacff268cb37ab4944fbdf74a78c5a7b9bc49043a00ba40","libgit2/deps/pcre/pcre_tables.c":"fcdd9f705a7a1640ae5e5e5b7148761fc5e82896d84b1a287dd7e55b8b87eb15","libgit2/deps/pcre/pcre_ucd.c":"b35ad7e532f52c5fb1f4ab1d48f5d80618abff2a115099220d95cd13ac64c346","libgit2/deps/pcre/pcre_valid_utf8.c":"4265abf04c03acba9ea90351da662eb89aaed79e7eef03329ccf030ef28ef907","libgit2/deps/pcre/pcre_version.c":"5bb67c3373a934a2d9263ba9f9fe3cd79e381e6aed8507e5319202330bc5275e","libgit2/deps/pcre/pcre_xclass.c":"b2c3b2c7600e18e562a333df017ee35c69233e9427b866726d944122a9560e28","libgit2/deps/pcre/pcreposix.c":"49e996bbf43cb2d4acec350410ab40f811a9fefe21fc68004c6182a8da884aba","libgit2/deps/pcre/pcreposix.h":"85a6a09b806d8506e5710e9862b6716b2b88761abe0d05aeda5071257537d9c3","libgit2/deps/pcre/ucp.h":"ea98e4eb999d8e777f2ba709e68b5aff7108a4eaa169f4eefa4510056551b724","libgit2/deps/winhttp/CMakeLists.txt":"e9012f9e9812df5a744551a9b57982fe8c8ffbdd3ddf41a8d96e58546fcb72c6","libgit2/deps/winhttp/COPYING.GPL":"d9a8038088df84fde493fa33a0f1e537252eeb9642122aa4b862690197152813","libgit2/deps/winhttp/COPYING.LGPL":"dc626520dcd53a22f727af3ee42c770e56c97a64fe3adb063799d8ab032fe551","libgit2/deps/winhttp/urlmon.h":"6cdb0f5ce5f0aea2daefc44c4806697ed31ad759f8baa18fb38a5b220ddc7d7f","libgit2/deps/winhttp/winhttp.def":"89601b95ac2515619426ea52ca093fac1a16ef0bfb5586c1385a028947ab6513","libgit2/deps/winhttp/winhttp.h":"a51828d65b1b260a727f596c41cf3257cac2ef6cfebb11726234fd7ccb1537f6","libgit2/deps/winhttp/winhttp64.def":"7cd0bc8dd2c06d288c241d175da06146e940c28d7201fb63de8a75730d09fcd4","libgit2/deps/zlib/CMakeLists.txt":"5d583227eeecfe65a9b59742e128b7bf33f0bcbd8749a17f551ef8b7a4b2671c","libgit2/deps/zlib/COPYING":"864943392878a2479350e12a04f6e8e0ae434b5573bae350823c4d6c4474c755","libgit2/deps/zlib/adler32.c":"d7f1b6e44fee20ab41cef1d650776a039a2348935eb96bcbd294a4096139be3a","libgit2/deps/zlib/crc32.c":"6b136ac32aeda10adeea8e8927b74b52129625e0d5b73b10e5324fdf28c6c572","libgit2/deps/zlib/crc32.h":"9a2223575183ac2ee8a247f20bf3ac066e8bd0140369556bdbdffc777435749e","libgit2/deps/zlib/deflate.c":"26562ff9e6b5fa539e394a1d8355ca350b80567f59d6296973dcf209ee11693d","libgit2/deps/zlib/deflate.h":"0db1b5ef79ca6ba0f508b7b8bdaa11af45c5ebe2c89ab4f1086dc22b963a52fa","libgit2/deps/zlib/gzguts.h":"fa85c9dabe24e42ba95c702870416ff67ecc58906321f8e74b72a50dfd7df400","libgit2/deps/zlib/infback.c":"f8ca8ed0ce4271886efa0ddea45fd1306f2bf0b675748804737f7dfa8552e630","libgit2/deps/zlib/inffast.c":"41d93aefdbfee5455809130af74fcc76cf7259b1aa8b34d0060d14e57463e8bb","libgit2/deps/zlib/inffast.h":"7d8c1c873ce9bc346ad6005bb9d75cce5c6352aaf7395385be216a9452a34908","libgit2/deps/zlib/inffixed.h":"237ba710f090e432b62ebf963bee8b302867e9691406b2d3f8ee89ee7bfef9b0","libgit2/deps/zlib/inflate.c":"a268c9231441898893c0e2212c5304625c88d12371f1c09fcd2b2a7a54d57d43","libgit2/deps/zlib/inflate.h":"e8d4a51b07694bf48cb91979c19974cf6a5ab0b8a09d26ec0d14df349230673e","libgit2/deps/zlib/inftrees.c":"14a07279ef4c2e7c176a3d5571c45fcffb223b327b92e66a0f5c41d52bef8b9e","libgit2/deps/zlib/inftrees.h":"c510b36402784b1f898be3b049b923469aa92701de2d9195aed19f6b65c0dce2","libgit2/deps/zlib/trees.c":"7ca01688547ec147fc1714f475a6146abcd65f5b5806e914038277b4b5dfd8df","libgit2/deps/zlib/trees.h":"bb0a9d3ca88ee00c81adb7c636e73b97085f6ef1b52d6d58edbe2b6dc3adeb4d","libgit2/deps/zlib/zconf.h":"9c0087f31cd45fe4bfa0ca79b51df2c69d67c44f2fbb2223d7cf9ab8d971c360","libgit2/deps/zlib/zlib.h":"1a8c17389c6aaca0a52697c49bb2bfb403527bdd266ce626a331bb03322a2f68","libgit2/deps/zlib/zutil.c":"b5d725d43b43317c2b7c8fcc9622b0c7861f0f963c3da33f0b2c55cfffbcc448","libgit2/deps/zlib/zutil.h":"ae060141efbf6856488e646075e564c33b0fc429ec80f5fc9b1134e967d711a9","libgit2/git.git-authors":"807ee76d5d1f87f87bb4deff8196b7854530521ebe52bde5d52b9e2bb82a75e4","libgit2/include/git2.h":"3cc2ff96db345c2dae88c2168a9e4f0d23da336d9e0391a096320e0f08ef2c24","libgit2/include/git2/annotated_commit.h":"b416a1418b38c638cfd331022cf0fd059ec693090ffd29df3e649fbf502605a2","libgit2/include/git2/apply.h":"754163b99c945f1b2481cd6b50e89a66f297ad4a738d54b013620524d207c8c2","libgit2/include/git2/attr.h":"976d36632e3484981d5c7df133e7216a99701162a5c29565c6ee94e22ba8fe7a","libgit2/include/git2/blame.h":"58d6b7ffb8b4039ec75450206366e874c224339b326545ec7de8d7c2e20b99b6","libgit2/include/git2/blob.h":"d75a234addee2f8d5759cb47a80cb6d063b6d83895558538a05d2d3c723fdd6f","libgit2/include/git2/branch.h":"f93416a192759d06673fcaae761f2414bd8156a8b86b4ea5bdeb7e05786c61dd","libgit2/include/git2/buffer.h":"58e37b5487f578ab15472d9d117297fe417f9a4e6e9da1a5d2e185df311f3a00","libgit2/include/git2/cert.h":"1904a8d944de4d1fb6168cf0a4f5f166de7c06721ae9d564d2566927e37c6ae7","libgit2/include/git2/checkout.h":"d25583f792c94f0d2d0f18e890cdaa3d71cde815088d9236bcb08eb910507a3c","libgit2/include/git2/cherrypick.h":"9d55b4dcf4a3db3cc432d9ab60bb6788c5a0a22525f3d2c5c071e6e693df3824","libgit2/include/git2/clone.h":"9467e527a03ef4857e028b8494af6a663ddbc9af8d6503bca603484b9539270c","libgit2/include/git2/commit.h":"a0a545f449737130cd771daa3247bfb73da3fbb59617258de9b0c9b58215ce0b","libgit2/include/git2/common.h":"dd35fd29906a094039c5ef3e62f3338782a18999f8eb11c2429b18e0bb426173","libgit2/include/git2/config.h":"6d7364d182f3865d7b5ed7872a86abb56a1aea2b083c91b3c38169b47ff3433f","libgit2/include/git2/cred_helpers.h":"4478aa5e3f82cd754333311939c3c0d5deeff7be636f68e03a7f5b1c5f4bf73b","libgit2/include/git2/credential.h":"068d3e80ab9a5742ba97ca42e8d1c4d122168d7fe38f666848acfb1811884c72","libgit2/include/git2/credential_helpers.h":"efb330eceb6aa54313a1bd69bfbeee05fd4de59bdd0da676dc7a3649df3dddd8","libgit2/include/git2/deprecated.h":"102a29081a34f45405605f45295ecfc6a7e60363026259b564f0277fe574bcc8","libgit2/include/git2/describe.h":"7ed1552f3989171af8055ecac535fdaa34dbfa1a63f9622646a1270e522705a5","libgit2/include/git2/diff.h":"3b2c8e876104eff0bdd9cb3a65d73bc51c0f4b512ce0b87db5fd664ff1cc5037","libgit2/include/git2/email.h":"6f23dad8044f6a38ae3115022308d27fa4d52e054f53ef275a64fafa8f594d3e","libgit2/include/git2/errors.h":"19ff7353f8f03683a6bd7d25482c496a4b339aa6269730e601ef8bc8dbecadb2","libgit2/include/git2/filter.h":"2d10cd829385dad197307e82991c7ffab845e588dd0ff025b2a51797721cdd77","libgit2/include/git2/global.h":"88e49fa7593012aa9575df08755b907b5b613f43278f477e9ca8e4feedbe6786","libgit2/include/git2/graph.h":"c0bb3f0ae78d58c9bd23f0c41192f7f14aab09b67bfdb01f46974ab4f2a4df89","libgit2/include/git2/ignore.h":"a8bc1a437e37b6d73e9520023eff88c85c134c19a50b796234c6b884e5e0cef2","libgit2/include/git2/index.h":"ff58b50593a9e5ef0dfc662cf69bb78284902c7d17c058262b1e6c2253b0fd43","libgit2/include/git2/indexer.h":"d6506558f99f8ee2b3e0d7e381c7986da862e79edbaa170f0e2d38ce078c1b58","libgit2/include/git2/mailmap.h":"4f0d18eb0ab5ffdacdd716a9649319683fb84a33627bb4dfa6fed8aedff55d73","libgit2/include/git2/merge.h":"f66f9f7d13162a9bad2652b4217863e3ef9e59e1dc9cdf7defb84cbcd6d64eff","libgit2/include/git2/message.h":"8e517062c86668c667132deda83fc3cd07f4d07f064a09cb04b586d50c8abde9","libgit2/include/git2/net.h":"aa6ce5cde1a1c0dc586b3ac22bfd68689505d05fd91ee4c128c0225fdc7676ca","libgit2/include/git2/notes.h":"59256cc18452a945e1712c210a957685501448225f57f3ade0a839cb9124fe12","libgit2/include/git2/object.h":"8406b242bdd0cd60db8dddd508d7fcb58d44bc30d0008d4032dfef41f28c24ac","libgit2/include/git2/odb.h":"0def8d5f1e445e65509f1bf24e7f358c757f7841018dc4de793475f48a6cd28e","libgit2/include/git2/odb_backend.h":"1b2f3cb6a50bbd2a4c0747554b36191b4224e44a2b8baed8b30c53bdda79e236","libgit2/include/git2/oid.h":"a2510249c32905b3f4d8e149341f81d4f56c1481be3fe2ee21edb49e1ac2ec72","libgit2/include/git2/oidarray.h":"aaf8e8102afe1f35429c8738976ae1f886c5d831fc2d19737ec3577c901741bb","libgit2/include/git2/pack.h":"a13a500f23e2d37cfb2024d7241e5b0ff91e9d725b6fea1709be5890aa3535fe","libgit2/include/git2/patch.h":"0db799834e35d61733ad636a66e873030721a7b82ea965a42e1039184b9e48c2","libgit2/include/git2/pathspec.h":"78a7fa9ad4b7637e23fb7987ac960584ae2b8b51ec10016f0a75e006f7ab35c4","libgit2/include/git2/proxy.h":"b58b7f080ca56ebdfc51d9807d97c32023c5d3fdbd670a4bb28b81ba842cb87b","libgit2/include/git2/rebase.h":"9635cbd62c80a2ac6f54d9591cd210fadd1feaa5c0e9a08a8e9622c0bdb8eaf2","libgit2/include/git2/refdb.h":"689516e9bc72b8c569800b0100df3c2f3b870158c996ab48c90b8638ef8c251b","libgit2/include/git2/reflog.h":"3f9202628c60cd7ddd15a6d759439b758616ddf542b011b15490077bb4446903","libgit2/include/git2/refs.h":"9fc384e8e3b6151a722985beb69cc58e927e53c39a437413373999d340f45036","libgit2/include/git2/refspec.h":"3fac2002e7bcc36fba7e353e728846423c121520e8caf00836d232493eda2db0","libgit2/include/git2/remote.h":"f8479a944c2c7c3ea25689e0747e76c4c119a96a50a5f83c14a162082375c5c7","libgit2/include/git2/repository.h":"d406dbd472b64d444f9eabac3554bebab34bca37693d28db72b62cc3506eed4b","libgit2/include/git2/reset.h":"29c8b65e30cd7b7274d3fa2c88b95512f03ea6a705e26636026b77685c208efc","libgit2/include/git2/revert.h":"fdc9b2a8106191b36edac31d586375f82257614050b1d75fdcd0066e36da2243","libgit2/include/git2/revparse.h":"dd1295cd373cf0493090123d76d7fffe1f573f5cdae46d4bb48a9ee1cfc94d32","libgit2/include/git2/revwalk.h":"ef5edd2d05eeb4b6d60428d53e1474a1af37348d375c749b3e445f8704df0e87","libgit2/include/git2/signature.h":"8eb48ed252cf68b7d9a3d8dfb183a8474c395cc6bd7abc20e70d9ea728b042d4","libgit2/include/git2/stash.h":"bbb860b2c01e856fc2c3b53cc48c5be053a66bc83f958768079cd1f31f92466c","libgit2/include/git2/status.h":"bc1a3daf6b85aff463645e8ab45bef0d86e2058311282bd8bd97e12d4fcec151","libgit2/include/git2/stdint.h":"ff41f7b6917b7c4955a685a28072e2dc141f626f5f09068e33fbb2e05b866bf1","libgit2/include/git2/strarray.h":"9a1133c71aa242661c684f78f5028e00d2c520a4a833906b125c05038448658a","libgit2/include/git2/submodule.h":"6a8de8e3505de2d2f6dfbf294bf758545649114f977af1dfa0c3fb7980aea99e","libgit2/include/git2/sys/alloc.h":"9a19fb88e2c70146520d63e01778e22938976a4b754e4bb9e487c4d5a2ca486b","libgit2/include/git2/sys/commit.h":"3d1b2220325a82983ecb271c2eb8383a8db134dfc0da96b1f050f3664871252a","libgit2/include/git2/sys/commit_graph.h":"d178cae2b2d36e6b07bb7ec8e3f616ca6db591d207116b946e065f267fca6282","libgit2/include/git2/sys/config.h":"7888b5265f18640820d43f8ffc31e3e6b3153398ee2851d657ae8b28bdcd10a4","libgit2/include/git2/sys/cred.h":"b2ea956401c5554f26cec0f428dd9d0d9661d1ef3d9368769b415193df98ed1a","libgit2/include/git2/sys/credential.h":"8cfe0a41b027f8196f43fd2e81c15bbe1a26ed7c15468711f900dfaad0a3705f","libgit2/include/git2/sys/diff.h":"e341f693acb25645f6ed47c041fc4eda8996a6f1d42905ae4f87fffba22520f3","libgit2/include/git2/sys/email.h":"c90da62e7696a61eed3f21ecb7c9feb39569130746a6bd317e3e82e18c070bcd","libgit2/include/git2/sys/filter.h":"84830316c546511631506cb7b833a1cd39fb9deb76249e2ce6b02c524d00db19","libgit2/include/git2/sys/hashsig.h":"5677f86c02e557c7897e98d395e83d8168c532916ecfb7f9ca5bf7b4057141f4","libgit2/include/git2/sys/index.h":"bc6a371ea47773019e17e5ed5951dbb5b9d773c437d6d49e79e20fa175993c87","libgit2/include/git2/sys/mempack.h":"677bbdd7c613d82cc07966318f133c6ef4101b1a1dbfc0f3b1979a925ae50810","libgit2/include/git2/sys/merge.h":"48bd0d3a80046712287e5c396ca7dd6d81af5cd2e765f96ee89fb298d17a79db","libgit2/include/git2/sys/midx.h":"d191831dd85832e62c3a940370e355dff7e7432fb8d11c27d6698a7e8c4555f6","libgit2/include/git2/sys/odb_backend.h":"da9ac8662c9ae94b2eb51167ba81ef9adb6a537382a6eebd2b98b1c908ab8b1f","libgit2/include/git2/sys/openssl.h":"011d45d1991a7d4467b5de5c574718af5b16198fb1581639845fd8d07bef7758","libgit2/include/git2/sys/path.h":"97adf0e0751e456546c7c0119743e50aa428fad8a29184fcc637db1eaae08b67","libgit2/include/git2/sys/refdb_backend.h":"6be92a5c1b660e4adf99f4604fefc9e93d2e639ae53295b722a1364723d036bb","libgit2/include/git2/sys/reflog.h":"c307ce8e9c8b0483ec45ce34a200f74e1ee73bfea9c4c7b0cc3923e3881360ca","libgit2/include/git2/sys/refs.h":"ee98c1aa0596b1cb409795a94de4891392e1675c42e8877a1e38bd0a5c3fd2d0","libgit2/include/git2/sys/remote.h":"f1f7b7d5cd5baf9caa5d048ef3d63ca5a4a30464e34226a64755863ccddf1134","libgit2/include/git2/sys/repository.h":"63a142623683376fe11f498685525ba33d3cd184708338f2461067b7aa5b92c1","libgit2/include/git2/sys/stream.h":"8555a6a2dc13ddf21cf4e3edc137d5a02cab23f0e73f9f6f7859768af25d11b1","libgit2/include/git2/sys/transport.h":"0e81dd2e8d16c2737b20b86f6bd2a53e8f7ff2840c599efb355013fb74e83d4d","libgit2/include/git2/tag.h":"799b7c0726c077e13a1e0a194d98d2605e59ad4800db956e92e7dfc938bf6353","libgit2/include/git2/trace.h":"f9aaff56cd6e6ea2dc5f7e221f198016f7d4a947829340a45c12714bf32f6738","libgit2/include/git2/transaction.h":"4c7969130a952134c597e84a06f38ca4b19e0b372df88085cb4f846292681c5b","libgit2/include/git2/transport.h":"7272a0f8cc321ac012a3fbb8cf4d1be0bc6d34fc266a09b72d604a30ad0a91c5","libgit2/include/git2/tree.h":"b33a83cce6b92d3e4197c1124394431ef2865d0a6978b2dff29fb8f4a9d93106","libgit2/include/git2/types.h":"3dcf1cba9c3724f6adca09a5147e5e9afbfbad873c579314e5a93db55199b3ed","libgit2/include/git2/version.h":"0efba27fa3c2cd9e1fb7304cc450c388c771553b7e616ebd7deff16ed7ccc459","libgit2/include/git2/worktree.h":"0f819ee1a2f74433cc54172c86aed43cbc6ca26c9c44794a8fd8c7fc5c5e316d","libgit2/package.json":"72e43b29bd85abef8782b7333cb40eafb19e66cdd69126c12131451a36f78768","libgit2/script/backport.sh":"6ef93a8c4a15ef74d2639638db3b24d20a76fc31faa53b1c34b07e3759c78fe6","libgit2/script/leaks.sh":"62532838555750cfdbff91709c40b1c1356e399238fc29379a45802922530a51","libgit2/script/release.py":"28a113a377422d7aebab4ce25c672f134ccb8a81cbbcece4d6af4354c44c4711","libgit2/script/sanitizers.supp":"8ac23fc907490c5ba1dd641f97201878e195c3bec0c1f224a9a4dda1fbd1f5b9","libgit2/script/thread-sanitizer.supp":"6497c98a2c0c83d867b0d88c36095a609731e7f6f4ad5a73dfe5287d6f2ba0d2","libgit2/script/user_model.c":"073e0b631f2d50af9c326dc009c626dfb9d31707d36bc61396ad9960160652bf","libgit2/script/user_nodefs.h":"4287333a6d7484a5a5796e6deadea53ec1ef587e4c571351e3fab61cf8badb45","libgit2/script/valgrind.sh":"13d1e34010c351992ac5950dbadf35928eaabfc9ba3acad336e7677fbda0946c","libgit2/script/valgrind.supp":"f959d829f41bd3cdf663a3ec0861ebf98f5c69b4b46005d754d748d7b90d1734","libgit2/src/CMakeLists.txt":"5112ff9c7f288a01fe0782a420f66eb71c7d1d378d0fe08d04b5d01dfbd4e3ad","libgit2/src/README.md":"acfbe0a4ed6cd7d806b30582cde06b871fe2b16f5a9eec3af717ff819030c6d3","libgit2/src/cli/CMakeLists.txt":"ffaeb4de3adc9dc9910e19ea600ad3509853862662e0223c30c9b4db2a4281f7","libgit2/src/cli/README.md":"84ea472e6be8c7e14558749a6b9207b8acf45ce78ce2278a525813d6c66c09d8","libgit2/src/cli/cli.h":"a2c8e0f0bfddc539edd3179f23604920ded78f725d753f891ceb029ba64b0a65","libgit2/src/cli/cmd.c":"fa7c4fa3d3178308dc47347c1c0d2c59c242173e01b35e9da1594b6b1a84821d","libgit2/src/cli/cmd.h":"353089987b6c3600eea464e1bec4a181f026bf2389f238bd4064609208ef7306","libgit2/src/cli/cmd_cat_file.c":"96b00ca5ad95464dcb1b82a3896c9c4d3d4a2b3f3cd0dfadffd4486745bca454","libgit2/src/cli/cmd_clone.c":"fb9a318c8dc424cc91e819652941a57d6094208c621e64a74defa8f407b76d6b","libgit2/src/cli/cmd_hash_object.c":"ee4548e9e02964ac3bde6e99d42a1b219f7d43c84fd6f41a4c5a3f6972754aa2","libgit2/src/cli/cmd_help.c":"11959d8d9bfe40db63254b576d4c40a6f89459e8a31b1a595fa64362a72db74c","libgit2/src/cli/error.h":"77ae9d6e6b273b433d6f926fc0fe3ead0a608e2d4ea3751a481b07d445cec254","libgit2/src/cli/main.c":"48c96ae62cf75078c95fab55c97a87119fc20ad30aacbcbf3a3f9e2acbec3655","libgit2/src/cli/opt.c":"87721cce2b835c16263f76063bd0c4b9ddea1714a5a2ec8198c8a69a485bc5cf","libgit2/src/cli/opt.h":"21e0fa46e11bc7ec8de209cafa30d944c5157da9187cb66990f81fe1a8975a76","libgit2/src/cli/opt_usage.c":"0eb8e704b234dd955ad33798e330c083a4a5114347040ba949235003b17a6f92","libgit2/src/cli/opt_usage.h":"a9234a8277001d8a0252b3e9b73c581bbfe64fb209eef565dd082beba81b3053","libgit2/src/cli/progress.c":"fc583205433555e1077264e179900b4c960c2d50af2569637794f9d25c5f6052","libgit2/src/cli/progress.h":"b1886426d2ce266c3da212bbb2a658df9c386c5e297b9e760464cf51081548bb","libgit2/src/cli/sighandler.h":"4ebd5db9e9368f8001bffd2e43f8cd7e2ba7428d0a56eea8255c1d1252c50d88","libgit2/src/cli/unix/sighandler.c":"53756df33d9012aa71887555c53bed6c33bb31a9f8b7412632729bd6744b9dc1","libgit2/src/cli/win32/precompiled.c":"4dff04101bd64b95c8f708d1accd1bedc39e95a263444290f796c63f4734d4cd","libgit2/src/cli/win32/precompiled.h":"7f9896201b1ed335a630010def126430d3c9f718c180b2c0ea0865e4d8611297","libgit2/src/cli/win32/sighandler.c":"bedb324d57b3ff2e6d6ba2a2a46b6f8e67a81186f3c729ea9f3b2771ec9b6450","libgit2/src/features.h.in":"abf55911a25604fcfdfb82755f3c16b82b16ed869688806d20ba4b9ae6589179","libgit2/src/libgit2/CMakeLists.txt":"a01f0f8e133e9d061fcc4dabafb7c4df6d5d1939fafb4406bc114ff35c441c43","libgit2/src/libgit2/annotated_commit.c":"224e3bbd567ca961522cafb78c717d29f1710f2d2bea5c40305674b58b56f73c","libgit2/src/libgit2/annotated_commit.h":"35168115c4d881a75fafa455f319be0c69277748e2e147c42f8a38bf7b5bafe5","libgit2/src/libgit2/apply.c":"e838bc8c4a33e86c855d3905c8fd500b9f82c5225ef8ae7bd5def24f106d3e30","libgit2/src/libgit2/apply.h":"4b3cccfd8030ab006fe78a89bd6ded5e1d89f7122630da6efa792c1a5b6874ae","libgit2/src/libgit2/attr.c":"cbeaadd990153f473ba27a2bf41a844fdae38bf6823635820f9594cc5adf0eb1","libgit2/src/libgit2/attr.h":"c940426d88f00d1510d2698897d5fd1b9270d91ec0c86a7df10b9d07f598171e","libgit2/src/libgit2/attr_file.c":"9cd04700d4d3acf1aa70c293d9236218065a75b000606ae0032de604b81a6e2d","libgit2/src/libgit2/attr_file.h":"575b181fdbc1d4d864753d0237ff7d718ea1258449bd8376db461eab73cff0e8","libgit2/src/libgit2/attrcache.c":"a937e202ed1ea666792640ca6e522cd76eb2b30ed4a6bd30cbaf5374addf50e9","libgit2/src/libgit2/attrcache.h":"a47b509e5862731889fd1bda172f6dd2e3f9dff50b7296d4e2cee86daf508769","libgit2/src/libgit2/blame.c":"7e6a4a9cfd1382da134121d3b7b7677257e2ccbc692fa75e212b3495c0aaecb4","libgit2/src/libgit2/blame.h":"5cd24ffc72a646e373d5d0b850aaa86316fd83b6fb886b0aacfe57ef4fd9b760","libgit2/src/libgit2/blame_git.c":"f2909b494c1a18891f74223ffd675c0e092b58f52722f5519aabf26f9de59fd4","libgit2/src/libgit2/blame_git.h":"9b813f16b93512d27d93648e53d1438d5b931024701273b5976c1da41868e286","libgit2/src/libgit2/blob.c":"4defb1f6e9c33613bf49da58b74420e550b5d6d6b454c607038c25434eac3013","libgit2/src/libgit2/blob.h":"66005f2fde1565530b0066238d750acda5ca30e1c45757af2ad2f00fb7c6486d","libgit2/src/libgit2/branch.c":"9af7a9d3c2d8d411b9c91c19405259d59d460f09bdce54f422f5491d0ee4c239","libgit2/src/libgit2/branch.h":"a7512fb6c578721a8d0c47a250fee9ddbbd08fa5c53460420d8158d39511e042","libgit2/src/libgit2/buf.c":"491511777e2c68cbbb6e350e469da80fd240286d71b953230e688b920474ae27","libgit2/src/libgit2/buf.h":"4ed1bd58f01790c6b8505b9ce3f1cca443e8952c64611a36516d9c5d1cb96ac2","libgit2/src/libgit2/cache.c":"46385411ee06769a97c6d3f72568fcc34f0873444b27c8c1ba0c1f3e1255730a","libgit2/src/libgit2/cache.h":"7fb0a0a0898367f1489b0430c35ccbca440cf7119c45382ec67adeff443f83ac","libgit2/src/libgit2/checkout.c":"ed05c756353a82b9c4562941332c3177bb143f706cb4ad1f53079c369975ee3b","libgit2/src/libgit2/checkout.h":"deeaae59fbd6f4cb3d6c5b67133df66832ad3e49bc9585b6ce9c5d0aa4aa6ef0","libgit2/src/libgit2/cherrypick.c":"1c927976f659dda37d633859e55e7fe99abdb25f9b544ee0edfb97a816ab929f","libgit2/src/libgit2/clone.c":"ad46e57c84f8a0caf694b3a055e5d13c5379afccb20e647692c1ba4dff37dbbf","libgit2/src/libgit2/clone.h":"1820fe915f31a5346b28cf06c29e60cf7fa5dea92d521ed2bf2aa51d0eec3c18","libgit2/src/libgit2/commit.c":"91fa77c9313939cdf614765f61121ca72ef3fe7ab71861b53d49c274dd534d14","libgit2/src/libgit2/commit.h":"a7b563356ef1bd9e5c899b00c9828d04b9ec9e5c26a48fe4ff22cf491e203e34","libgit2/src/libgit2/commit_graph.c":"3cd03e3b6fc4049f232ecd36d2492ed3c8d092ec71e167b088df64eed6427843","libgit2/src/libgit2/commit_graph.h":"60d2df35b849fdfe24f89ee030fee4892f7a965739a7c0cfdadb7ac6c4c33e5e","libgit2/src/libgit2/commit_list.c":"ba67a2f6a8e2fc5c139852a7ad0625c795c2d65df911722d8fc6c5807d4f5f47","libgit2/src/libgit2/commit_list.h":"0ca7bb97dd4d33c49420c9b7eb5689ee0b3ec01f39be08bcbbfacd695820e249","libgit2/src/libgit2/common.h":"6c3fb69d1dd0a3656b76dccbae2f2ae11d67675c3695cf0de4521daa422c28ae","libgit2/src/libgit2/config.c":"6bba3d8f6c3a67a2800f0e7e73edaed1b2f75947226641591126b3ccfde00506","libgit2/src/libgit2/config.h":"ac67c3fd05fd79041759ac0218b8d4a06d0ffd31ba8ed42787d27a9ae0540069","libgit2/src/libgit2/config_backend.h":"8a368a7b9235aca7a6fc70e6192b1dc9ca85c881faabb69ce612c011a53cdaa2","libgit2/src/libgit2/config_cache.c":"46fec2adc322b57a2a85a1963aa4702893228a3ba90c1a156e127552a0a1a854","libgit2/src/libgit2/config_entries.c":"a938c81fce685b07aab19a30ee163bd1cdbb8a019aefcf704d1a97373f5f8da8","libgit2/src/libgit2/config_entries.h":"932abf82f5103fef5c6e991a6e50effeb33cb6ce90eb1b15f6606d9f370feb66","libgit2/src/libgit2/config_file.c":"e7edc5820f93f70d7ee960e62c2a3f8cbb6042e46af6af4a3f07d82d810074af","libgit2/src/libgit2/config_mem.c":"026461ece09e83d78fb65e1d876484d10bee9a09618e9ac03240afed947f87ab","libgit2/src/libgit2/config_parse.c":"4da07c1ff3a0a7d5aa359d07ae7871704125f18282aafbce5c3ea184ee8f39a3","libgit2/src/libgit2/config_parse.h":"ed2e0138e13fc0115fba047c80687eb20778984bb2ee13c261ae69893e11e5a9","libgit2/src/libgit2/config_snapshot.c":"ff6771e940ebc78bfcdb12b7dac205629e8e88732b44b10a35962e3289cd660b","libgit2/src/libgit2/crlf.c":"2b5a392b269eb2af132f790a7764271dfd8523c47d18ac0f2d9fca1bd631363e","libgit2/src/libgit2/delta.c":"3e5d84b81f8fa3b752f75e0853a548ec3863ac3f1070bf99a9367bf6ae8ab87c","libgit2/src/libgit2/delta.h":"c757526292144083a0e96e7ab259080e83158e28c4819c4fa8bc2523aec12a59","libgit2/src/libgit2/describe.c":"fba715e551640e6c4441a735772291bcf0f0151ced78319a506bd85dd00d8ff8","libgit2/src/libgit2/diff.c":"ce9aaf62d359e5c0c4620a2bbe41d3e3b334c1a60e1a303cd8c0483a961e28d6","libgit2/src/libgit2/diff.h":"1bcfa1246864e2148235d0ce64ab7ec3973c5b9fd2a8a44dba05304c9c9cbdc4","libgit2/src/libgit2/diff_driver.c":"a6b463204405019d58171ff81761ebf7296f9710a3b7e95eb0f5e9e7c7aa7c10","libgit2/src/libgit2/diff_driver.h":"2dbce036b80a1855e8fcaa0065b8f4458cda13b9424d368b4ce82f4e49ec4065","libgit2/src/libgit2/diff_file.c":"c03629dc08af16f04768139ef9e6f603978afbefaada99b132b75e749a12a051","libgit2/src/libgit2/diff_file.h":"f19e2a17d089591596325cfede708846c8df05a711e349ff84394db4af560c1c","libgit2/src/libgit2/diff_generate.c":"dfa4a210da65fc51ace0f82a72918944a6bdcec8496654d60105f50861af5830","libgit2/src/libgit2/diff_generate.h":"a856792a6febd862984ac01bd41f998a848a60cd5d72b4c04a94099d3ffc5c6b","libgit2/src/libgit2/diff_parse.c":"107d11e188e054538c29275f6755bde45523a4f04bbdbf30fcfaf18c54a88a1c","libgit2/src/libgit2/diff_parse.h":"8902d9ba9102f10898c14d0a41a8d5823450527266908cbbb06e676309e23f56","libgit2/src/libgit2/diff_print.c":"44969c28b9ebe85d5b5fb62da13e902ba6cc94a7db05a949bb1cd6020936a8a6","libgit2/src/libgit2/diff_stats.c":"63e5e55d9f59992927409b3fafbb2c203a4098e84b0b747617e1a53a327384ba","libgit2/src/libgit2/diff_stats.h":"4ce359d523ffa03df7c0592ec0b905dd693054b44f62c4d1a91af464ace119dd","libgit2/src/libgit2/diff_tform.c":"c2726291d202536cf120ea813e1847b1e8ef4cc8d39254b19c1665ad5a13b1f6","libgit2/src/libgit2/diff_tform.h":"a4a7433036cefffaa9d968ff45244afb4957313cd9c28980cc102f172f9eaf5a","libgit2/src/libgit2/diff_xdiff.c":"6980509ccc58b82b36c0ea42e319c402a19002bbe59c2c4ad5e7accec4cfec44","libgit2/src/libgit2/diff_xdiff.h":"f027a95aadb84a42fcc349b082ad50c0b6ce3a3c439fbdf90ffbb04f48968e81","libgit2/src/libgit2/email.c":"8d90259a3a187f830071b2b3d821ee1f4f64cdf0442fa26860f6ef1bdf818a98","libgit2/src/libgit2/email.h":"6b4a9dfb85b367e3423c2967f9cc257cf498fb9dd973c4400cea2be183065d2b","libgit2/src/libgit2/errors.c":"e4681de7db0a749d0dbd55b9f9b036b9a54cf365c78201c6bc6fe86634c5582e","libgit2/src/libgit2/errors.h":"c015656a92132544b81c95e21ed61eaaa06d9df8aa73d8a97591ed4e145727a9","libgit2/src/libgit2/fetch.c":"5e388a8c20dd03c337508037eb05ae21f383dfc0c45836cbedcb7474570ce2ab","libgit2/src/libgit2/fetch.h":"ebf610f3a62e107bf4f768fcb45a4cfe09d990380d8f0abcd48f258463925fc9","libgit2/src/libgit2/fetchhead.c":"0dd49b49766f2fbc057789dc7c374893f9ad07c5133eb35bcbb0c5f395d11620","libgit2/src/libgit2/fetchhead.h":"65681769629f670afcf739d582bb7ae90f702f0c6085de3f26b79fb3293d1dc7","libgit2/src/libgit2/filter.c":"dbed23ec686ed7853e542600852f905c51459f3e73e727ce2d1aadefc3deb869","libgit2/src/libgit2/filter.h":"b716cb38e4af7b9adca4e9b1538eb546ebf15f279906561fa8fa504bcc62ed24","libgit2/src/libgit2/git2.rc":"da3c8f58e8b133c52ce5184dfd9afa88801ec3e09ed76f2547a7851a25d3199d","libgit2/src/libgit2/graph.c":"babca47e94066357799c0ab823c9b3e454187202f7ab14068a6cf0fba28bdf41","libgit2/src/libgit2/hashsig.c":"fbe29bf41024a9bf9b556756a23bea451d1ca2aced680fe666d24b651a719a7a","libgit2/src/libgit2/ident.c":"9020d8910537d68cf92fdb21444ba09da950d66811482e72c7854d58633c22ba","libgit2/src/libgit2/idxmap.c":"015ba3e2f290fd817152f034208a55aa94b8ebd29fc8c80b3d053847d66de605","libgit2/src/libgit2/idxmap.h":"162a477b8faa3d37e83fd413bd53f6ba2801c1cf64a03c29513601058a6ed40b","libgit2/src/libgit2/ignore.c":"8b6bb768489a655f32f9f7543f83f2c951d6ca533236b2b33d7f7489c18fde75","libgit2/src/libgit2/ignore.h":"131aa84f9e474111db0f03797969e99493e67ef287cf8801606a889765e96ece","libgit2/src/libgit2/index.c":"42b108eb8c9cbfb17e6838387691f29192a82d54701fcff625aa4497ff168d93","libgit2/src/libgit2/index.h":"6c0f06f05bd26f6e41b317507b29ced630862e90a4f78c336286e9e81271d339","libgit2/src/libgit2/indexer.c":"ba01e3cf6305a2b42c6f33e5ee5bc308a4f9401397e0f7bbf9c5ec3a0aa60a97","libgit2/src/libgit2/indexer.h":"bd32fd65a3a7c6014e3e9846477b060033102c8c7baeb097506074f99c50a434","libgit2/src/libgit2/iterator.c":"4aa30c1c0ebfa0cc68d67e86e7bfe9de159089f5afd106fb587fd6034572aa0b","libgit2/src/libgit2/iterator.h":"6c68f151885f425c000831eac8de59aa5ef6ee9d12721ec3f56e179ef2a207cd","libgit2/src/libgit2/libgit2.c":"b0ebe594d7e63931b0097ead1ff1e72dda94c0ac308da0bfed37eca72406f3b5","libgit2/src/libgit2/libgit2.h":"4cc280df2f469e2c0dfedef5f895e95ff0b4eda3710b93fc10c9b0cc97f1207c","libgit2/src/libgit2/mailmap.c":"dabeb5e9520c2338e3a7496f3e3b8f593b6a422d4d083fb17ab8d33cd575cc14","libgit2/src/libgit2/mailmap.h":"edd8723b4c861c855708f2d7f9ed5e37cbb7523534349b0f69258a3557b93b36","libgit2/src/libgit2/merge.c":"a0e2e401609031fdc5ce3bc2ca663a15f9452a0179fc74cbf5d344a6a982092c","libgit2/src/libgit2/merge.h":"ee2d6ebc3328e33115a69f60f0323be4fcf7a586a6308d76b5d6b6451a2e06dc","libgit2/src/libgit2/merge_driver.c":"e9696fa44bdc4250c5bf5bacdbe51e9414ec38e7b1b8c9b8d4ef3c6a9f140318","libgit2/src/libgit2/merge_driver.h":"4f56c2965330a5cb08b9f26d6b83dc4e15fced9419540d2d793f2e75049bc121","libgit2/src/libgit2/merge_file.c":"06c669e98a0d6914b9171fc9ca1255dd05261d88fa3e637aecf8254c9627d7c7","libgit2/src/libgit2/message.c":"12b4d518b4f77b20d76e6b7062f56ddc7a7a666ee97f7f33909c9010ca3b5b0f","libgit2/src/libgit2/midx.c":"d82b692d463805ef3c018f298b812a1cce47dfbf4a200ac1bd0d9b01b9265217","libgit2/src/libgit2/midx.h":"9efbe994a15f4e495f0576bfbe6790e4677fa3587d94ed18cec5b6c9fbeeeaa7","libgit2/src/libgit2/mwindow.c":"8b62175ca5166d70cab2478a1fcd4a38c3e9e0c2e3e0cf16eff165f5ecb85319","libgit2/src/libgit2/mwindow.h":"e53463199e93747ebb5e84a404d05c18349a2af83ef5eba99528dc1e915eec25","libgit2/src/libgit2/netops.c":"823653e7ff3d0384b16c18bf5a531ab9478881f1c589633828e40da9022f399f","libgit2/src/libgit2/netops.h":"cab7bfe8d352f139f8058aac3b253963d7102decc86ab0eaa7691adfc4c7fda5","libgit2/src/libgit2/notes.c":"284c9bb2a694a1ac92af8b2c3bdab8fe5d0a4e309b50114774cdfbb0bd5a2d3a","libgit2/src/libgit2/notes.h":"650f92bbf875ab194b9e1d041f06fb8332bf5f402ea49cde528a81d2eac05694","libgit2/src/libgit2/object.c":"109929dca68cc87c99c290e61e23eced6e74fc8b35972f94d0df0140153aa522","libgit2/src/libgit2/object.h":"83bc66c16836d8a2311909e70b3cb8f5b8f0aca53b720129072068c1fec2e841","libgit2/src/libgit2/object_api.c":"ac963762a903ea36adb20f0d4317388159c23828a6e26e9a1b1333b7a9fa1317","libgit2/src/libgit2/odb.c":"48aadddcb42ee41fc0261feb71d190db1fa1bfab47a43c2f5d1e863fef87657c","libgit2/src/libgit2/odb.h":"e36684bea9a513946602f094636f74f6abbf187c671396a2191b94f633df90d2","libgit2/src/libgit2/odb_loose.c":"1af7f19df25b5df946741d250fb4412302ddf5156305077cc350c9ecfcba101e","libgit2/src/libgit2/odb_mempack.c":"86fb977ad58c48f7394728d7396b7e050482b35edfc87cf0a487284aa91abeda","libgit2/src/libgit2/odb_pack.c":"56b831375827947582e915342fd7f9cc5030ec738af4eec26a07f058c8457324","libgit2/src/libgit2/offmap.c":"0185030081a9d7df6ca8abea2e0b2c367278172ccd5ca5eb3601555a3ac1f665","libgit2/src/libgit2/offmap.h":"e902482f4727d30f786f48fbc143d7324ace0fa60877212f7ab3e982b0d46318","libgit2/src/libgit2/oid.c":"28c92cb7b5d81ada73c28c0d8f91134b6c4791f92b8a0de1500006b8db46e447","libgit2/src/libgit2/oid.h":"da5466006a80361e046d0f6731a31cd78f4fd76ee62c38a974c7b48e2c462f28","libgit2/src/libgit2/oidarray.c":"5919ea8d7a0138d9a4323a650c2ef9f2cd52da5d6c8922ce307a6ac6fa131a8d","libgit2/src/libgit2/oidarray.h":"17a745a4d1f2c464b91080279fb4a3163bb39456be5c7e9d6c8195724cc3cba4","libgit2/src/libgit2/oidmap.c":"5a1b7b02e7210bf8f439cd606200cea373a8d7e000f90aa3b6f6bbce5298f05f","libgit2/src/libgit2/oidmap.h":"7aff6a1568632f38f2acea1a526e11e24b42fffa7b05b75ac53ce18b9dd70e42","libgit2/src/libgit2/pack-objects.c":"483dace387cc5f9b0dd859444501eeb6164fd9e51b1d354843f0b385bd1ff303","libgit2/src/libgit2/pack-objects.h":"8ddb878f2ed2a45d298791622fe067fa0418414b8d2367f910f7abf71293a987","libgit2/src/libgit2/pack.c":"bedb3bd2094f4ebdbf6437435c7bb5befbca54171301743a188edb3f120d99a0","libgit2/src/libgit2/pack.h":"7991779473e017b205cc00c5fb8e0337ca0fe61418ca6397619e28878dbf5443","libgit2/src/libgit2/parse.c":"34410522f13568a6d061ed723ddd7049f21d1f054e530bd5d3c262a1105e1f74","libgit2/src/libgit2/parse.h":"d5f25a7d63d004bd3abe86255b2877f5c6415939338202c32fc78e218c9554fc","libgit2/src/libgit2/patch.c":"48eceeb2b8fd25f24f830f7abda25853f4ede673b38698b671a9aac8d84562ad","libgit2/src/libgit2/patch.h":"b9cd6f2a68b709db55767d92a9b8abe34534273645eb04cad4bc581c59723bf9","libgit2/src/libgit2/patch_generate.c":"f3ae83337cc9c6c9864f98a20842c548785c9bad300443026216c05a038b18fb","libgit2/src/libgit2/patch_generate.h":"c83a9d70e860b13940f70140199ee40e8cad310350a764e726672ed7133e2999","libgit2/src/libgit2/patch_parse.c":"ab526ab3e7add847a81d2e4517542188577f5e78d5329035479ccd43f464b389","libgit2/src/libgit2/patch_parse.h":"6883a184830f4c59427177eba5462d27737706a1be899db35423c5ad9d6c8c4a","libgit2/src/libgit2/path.c":"fd0059630dfa0b3b9b5654be35ac3b32f01cb4858971e1c0f246a65f378cfefb","libgit2/src/libgit2/path.h":"e5a2b8a9f717ebeafde09b3fb0330eac85c9d52213f334fedebaffefbe3575cb","libgit2/src/libgit2/pathspec.c":"e85ed481b15f0a1aba9f3c7e39f07be490cf2e32668dea10f93651eb12214e59","libgit2/src/libgit2/pathspec.h":"ab2ba851d4cd815aa25a910b792102230224ef7bb079879277d77f2984fe64cd","libgit2/src/libgit2/proxy.c":"2e979107904bc593f4d0a4a911a20efbf0956ab3441e21b10eff8661c8c7fc2a","libgit2/src/libgit2/proxy.h":"3758a64bea3691eb59a3c4d0bc70f7e1660b2a7f52e33513b03e9d7dc02bb617","libgit2/src/libgit2/push.c":"b0214f658bd2286aee34737ad32f313a32713b6cff01b2a7cf8229ec499d9ee3","libgit2/src/libgit2/push.h":"27762e4476e33c18c75bcc83051cbb26a67b8ea51407655c668c946daad46c79","libgit2/src/libgit2/reader.c":"01eba0311e0a63cbfbed7ebeed0dc16f648f9ced12b1c20522798761e3a77820","libgit2/src/libgit2/reader.h":"de0410d529d888feb13a8db4221e4d73f3575e3c815e6bb4ab9a4caf4d822e32","libgit2/src/libgit2/rebase.c":"dcb443109450016e7defac86ee9c4fc85eda0b99b2464190abb365f18473856a","libgit2/src/libgit2/refdb.c":"40cd4c55b0d0296bfa674541fb16936cb7c5a785be9afdbfca5e96b54adb7424","libgit2/src/libgit2/refdb.h":"ad8127049a89e43f49ffed64e82ee343e7c8acee31f7cb900b555193667cb99a","libgit2/src/libgit2/refdb_fs.c":"fc65dcca92d03f3793f1632fbdfad220f77871c33ade9e2cf0f25591a0071c92","libgit2/src/libgit2/reflog.c":"becf9c66068585bd1e93a1328db2529199a322cc212d60b6738183495f326327","libgit2/src/libgit2/reflog.h":"898ae0bf378c465673fef1a4221baa2cf6165a0700949952971f743ca73075da","libgit2/src/libgit2/refs.c":"82ac0ac10192ce29bde73b1abbd92dd716411ea424858a5fb92bcdc6ace82556","libgit2/src/libgit2/refs.h":"797e1177fe2a60c564b85c51d513e01df7d089c3a1d536e9a075a6eea3bdc3b7","libgit2/src/libgit2/refspec.c":"fb3f521b55c4be10e5459935918331ec6162de05bbf63ea336ac630017d2b7c3","libgit2/src/libgit2/refspec.h":"f521436fe4a8ca3600c54d77aa19a8a1926205e44b71c9e9f2fadfccc0f087dd","libgit2/src/libgit2/remote.c":"b21e5947ea7e51cc95dcff6d6e78a9f7259731b4f90e8af295d291c0b33df7aa","libgit2/src/libgit2/remote.h":"8821997f9c08e63a6841ddf90dcde7548096e326cb6c033aea59f2d10d66d5ca","libgit2/src/libgit2/repo_template.h":"bec227c595d193802723f81765487da76beaffafae40ec05b76a4db7de153c01","libgit2/src/libgit2/repository.c":"cba66fac67f156e81420c25f90555e2b0d5af7f0c1d8932bddcc6aa284897daf","libgit2/src/libgit2/repository.h":"b41514073138be704322d4ac8e96c87c0bf027cbebbb53cf4a148cdb19690211","libgit2/src/libgit2/reset.c":"9a9b3119fd1d649737487a882a3a1a6125a8b6b3aa444cf929ad2537056a3e2b","libgit2/src/libgit2/revert.c":"e45d6d14503600819f165dfeb4f4da277fade33d84a7600986525c38e4767cc2","libgit2/src/libgit2/revparse.c":"a9dd33510a2a604977600dfa9b6aac55edf942cd164a231d81dad8386fd510b3","libgit2/src/libgit2/revwalk.c":"484df7732114c705e2f355cf7d290ff2f4fa8831e4d05bb8f39ec7a5d698df1f","libgit2/src/libgit2/revwalk.h":"d341454f2b0f22e69f1c890fb9f3a2d8ef327797dc8f1dab5cb2b2734b57bebb","libgit2/src/libgit2/settings.h":"9addfd18452820405a0309f944f01bfb63b6918f740f8dd6e6e4f889cac51537","libgit2/src/libgit2/signature.c":"6ba02d287ab9acd93ff0fcf20bb803582e9a1da7c56202a45419de696983d75d","libgit2/src/libgit2/signature.h":"86819d4aa21214e2d28994cc0e8d3ac532980ad30ada61ab1666dec563f0483f","libgit2/src/libgit2/stash.c":"4baa85565c9af0ca7730ffc7f9072b1571a94c62407f21adc2290381760cff84","libgit2/src/libgit2/status.c":"231e6091e44e7da6168de1b65acb6c7e6a0aa57b5cd735beb2864d5cac8992bc","libgit2/src/libgit2/status.h":"68ed612f65430563ad5b3f50973b360f583c5865e54c9b9298eb082d441c4e79","libgit2/src/libgit2/strarray.c":"8beb44371f7dfdbe492fdc6bece0569c0732f11664aa735b6842df990ed2ed3e","libgit2/src/libgit2/stream.h":"a7755d211e19ea4a29d7d6151f71efd92bb92906d1668960e076ced663961784","libgit2/src/libgit2/streams/mbedtls.c":"f32d185df1933756fb8ba3ad3e7b454c38d28005521d634a45a7f56ca9d16df7","libgit2/src/libgit2/streams/mbedtls.h":"4aab96dac336790b4b172a7f355eb3fa6db35d31765edfa6524c581c10896ec3","libgit2/src/libgit2/streams/openssl.c":"a119df581f475c3a31e89ff6a3685818c973e5ecdde2dd7373caa8d3edc71c29","libgit2/src/libgit2/streams/openssl.h":"693e5d00ba86f206170630f3a23771cec7824017b26d6c6436620b6812a03833","libgit2/src/libgit2/streams/openssl_dynamic.c":"938d853510017e1fbe84322359c5b65b8cd2737bd3fe6bfd0cde85ea2b17d29e","libgit2/src/libgit2/streams/openssl_dynamic.h":"59ffb105d875ba2da6e4a5e1ad32780773323ff4477322c8a0562f6ca38d0a60","libgit2/src/libgit2/streams/openssl_legacy.c":"1c0643b0ea8cdd9d2f37dda38d777dc6aa6d3af8c631671f413da53b62470066","libgit2/src/libgit2/streams/openssl_legacy.h":"5a0f3da348dd5fb0cf4ddf7b9f65234bb5cf7017dfb084e5aad48e8d33d818a3","libgit2/src/libgit2/streams/registry.c":"079e2c8807d0cab10ab4363599e8a82e31042ba5ba2802cb52cdca0afad8222c","libgit2/src/libgit2/streams/registry.h":"42a887dd1fff029efa00a04a4e8716905149d3639a6881dc53254170cb8e18be","libgit2/src/libgit2/streams/socket.c":"7505512da233f7a37b2fbb9c7c5b1afd7fd41db6bef7542a2d2c6c9773f59951","libgit2/src/libgit2/streams/socket.h":"6ed5745f368fb167f24b8a733be0c2272f5bceb9fc40b5c550463428533c26f9","libgit2/src/libgit2/streams/stransport.c":"99085a58bd8a2f1cd5e37896a45b27268b7fe4a26fc137d98f5e16c7866def92","libgit2/src/libgit2/streams/stransport.h":"01c4555417713c415de10ea16222d44cd9c0c0db4ad5d7e3d5e9863d62f49eb4","libgit2/src/libgit2/streams/tls.c":"807146d607993810ad1b09362605596c067043aa78f7f062c5e92eb3b20789c8","libgit2/src/libgit2/streams/tls.h":"c989f0a996ba7a11f8732336da77266905ebbc371e5e5969955d096ae16b64ad","libgit2/src/libgit2/submodule.c":"aa3e51ce9cf7cfb7b5373948e37f92b4987b193a699644ae4ca1e249bb3ad8b3","libgit2/src/libgit2/submodule.h":"f5826a643562cc3f73ea13a7973d8f57d294c8003242f43f67ab863eb43fdc5a","libgit2/src/libgit2/sysdir.c":"6357092878a3454975c977ca536ac9e9bdc8e44aca955d43c0dea83d2e5190a5","libgit2/src/libgit2/sysdir.h":"8ddf427969d0ecec9d145e9f6d0b39a98400c31c1935ab2fe1e2a84561253f38","libgit2/src/libgit2/tag.c":"0fe6ddc24fa7b2a18fd13a186e85d2e3312d58baa5e088c72948ffb720e2be8a","libgit2/src/libgit2/tag.h":"e14485eafab3d4925bb6652158fb2f6abd211dbefe0655607a561b8bc6826ba9","libgit2/src/libgit2/threadstate.c":"f23c1ee9a2b4e175422950f713352be10049b4247641934ae00221726b341e31","libgit2/src/libgit2/threadstate.h":"e38212ab47493708e980cad9b035ad02fe3a648ea38a6bf23a460973b6cedb6f","libgit2/src/libgit2/trace.c":"f2e5041c5e688cf4e2c8ccc024ffa6a9c06b894cacfd1f967edfb5e11b513ce5","libgit2/src/libgit2/trace.h":"dc582e64181bbd55683b5afa6b400c9729a8daff22571c0ace7a3aada3b179bf","libgit2/src/libgit2/trailer.c":"b8c0cb9027532756b62c1ad6c6e96fbf7f4ef28db81d155efefa9f153458972c","libgit2/src/libgit2/transaction.c":"59f645e009b5c1a6919eb668b87215f422d7eaf9d9ae3b7ef27bf4f4a9adc3f8","libgit2/src/libgit2/transaction.h":"42e4b38d1fc7a8d57513da8230fff2f11ea4e1c2907130f99d77fdd2f099fc62","libgit2/src/libgit2/transport.c":"e366ada763261020d6293429fe0682e3df6130c98080c13659c4f5c100c4c79c","libgit2/src/libgit2/transports/auth.c":"e208690ebdec130e9737530a57835df13f5344906fbd9391aed1f665d3821458","libgit2/src/libgit2/transports/auth.h":"9354c6353908bf08a7720a1703958bf21c07556b862cea9f20d6dc94cbbe8bac","libgit2/src/libgit2/transports/auth_negotiate.c":"010ad1e83e06a6c5c9e3bdec10729038ed6adacf2c195f74baaec9bd2123659f","libgit2/src/libgit2/transports/auth_negotiate.h":"1125aec36ee74214a6a159027f6babd4299dbbc31d663202656cd12b6e83a245","libgit2/src/libgit2/transports/auth_ntlm.c":"35eaedb71b0636a996e776672fe2043a763e55b6340f63b67b1a67cb5171a526","libgit2/src/libgit2/transports/auth_ntlm.h":"66fe35444b362c6b74b07f0c01c36d00d86bf02d69526f5cdcec32d3ebe7b851","libgit2/src/libgit2/transports/credential.c":"058451ea233e7cf2d65f00b281a28caab16a84c9c83306e0ddc41479e7f93339","libgit2/src/libgit2/transports/credential_helpers.c":"e6ce81166b05d5f66c74c24086ec2025758ced7d8b85b041e190c2dab57e181b","libgit2/src/libgit2/transports/git.c":"fae194a7cfe1dae190de25d8438b9ef65e612ce0976bd2b7d651a1995094df8a","libgit2/src/libgit2/transports/http.c":"f3cff303f2e304abfc664afb2e15447202550fff723786d685024b47561ea8f4","libgit2/src/libgit2/transports/http.h":"2fb37a3a595652846d539c9a2378fefd452d3437a067721c37965557ccf42f27","libgit2/src/libgit2/transports/httpclient.c":"8c149c5c953e493314e13c57ee1255ef39a3b1beb4b2db2cb2b76f9605a18cfb","libgit2/src/libgit2/transports/httpclient.h":"58815a04492f73224f3bfc72b370c059279e76de1ffe0ac8829c12fe96f3f942","libgit2/src/libgit2/transports/local.c":"44c4271c35dd579a3beb158ac974a928e9e8a045d144be255a3f191b28f4e783","libgit2/src/libgit2/transports/smart.c":"b1b93ff7ce61b2fd5dd84dbb5ea72df2f09e73ac12ffef69c64c01da5ddf759c","libgit2/src/libgit2/transports/smart.h":"3bec37f6629184a8530654019edc37c77180f6226d09a8670cd1d044c3c518f5","libgit2/src/libgit2/transports/smart_pkt.c":"e505074f4aa13c098c45cb3051745d899dc7f8ea6c1270f793abbb027fc72fe1","libgit2/src/libgit2/transports/smart_protocol.c":"d64c3c698d50dfa9bc8814451ec50afc7d896527d90eb5a59a67024fb704f9ec","libgit2/src/libgit2/transports/ssh.c":"6db971df6caa46ac507d971ca3a351313e052ff7da6b0d0f8cb5dd90fcb00042","libgit2/src/libgit2/transports/ssh.h":"a4f6279848362d54f6ba4e9338443d6a3402c1ddb9eb85e2e3befb937cbea2ff","libgit2/src/libgit2/transports/winhttp.c":"64abbb5f4ae00f401870dd241ffa6c363166bd2b5fcde9264f38ac04c92ece49","libgit2/src/libgit2/tree-cache.c":"aa64a4c249d1701987a17aee6d9d060653f525dfef700bdbc2e779bcbf560a12","libgit2/src/libgit2/tree-cache.h":"f7ee6183b671c2ee185ca0680fa77cac32867f86f1915a63705a9c20dae57a6e","libgit2/src/libgit2/tree.c":"e4f31427c5d653aa3638b25fb778d10412dd9648b1eb893039f3962de9cc706c","libgit2/src/libgit2/tree.h":"af4f88a505dc5701073c3c41d43aa4826a49c8b63668d85a8a723b3fc82233a1","libgit2/src/libgit2/userdiff.h":"f623acbe67ce809a21541d0d665536f68df9e0ed8a4aa4556cbffd070960fc88","libgit2/src/libgit2/worktree.c":"527883a148ea7faf3353d226aba28a8d641784fda4bac570187a67457e56ccc2","libgit2/src/libgit2/worktree.h":"6962d0da3dc1ff1e967672fcbe84b8b09807924521e5d113df811ebee8e02664","libgit2/src/libgit2/xdiff/git-xdiff.h":"2d6c730b03adb9323f3bb7d25d005627542a821a71cc003e27bef57db0c0ea23","libgit2/src/libgit2/xdiff/xdiff.h":"6459a65d5e0f910f6bdcba30cd5332a58fbb75118acb5757f5596bd22c00a6cb","libgit2/src/libgit2/xdiff/xdiffi.c":"968d02087e76c5150edb850e6c454e2b98f9d315dd42eb971d58b2e5c512d741","libgit2/src/libgit2/xdiff/xdiffi.h":"3429a12de1a8c990005268801706fc2ced0f935813e12493c2dee68ba28dc94e","libgit2/src/libgit2/xdiff/xemit.c":"a08ac82b249fc1f000ca80e62a1207c1a2b9f76adc12675d48952bdb6ae734dd","libgit2/src/libgit2/xdiff/xemit.h":"0a8c569eec74bb4d6e8b7b9a50b457532550800e0566cbba6d185974613a2e6c","libgit2/src/libgit2/xdiff/xhistogram.c":"82adc783115873b48a4421e602aaef15c62ffdae828fd24f5214de4ee500a979","libgit2/src/libgit2/xdiff/xinclude.h":"cd17076d3909d1750044114719daa2acc0ee4b53afd9c2f3864cdba453f5f0fa","libgit2/src/libgit2/xdiff/xmacros.h":"d9cc54bfc6c0f9e6eef68f9d03594a8bd10f6243a2137776527bb5c849cc9de2","libgit2/src/libgit2/xdiff/xmerge.c":"c4a500ef89a3778bdfdeb70374534d6c1165a6c01b08d4b84df2de6d2fa98f38","libgit2/src/libgit2/xdiff/xpatience.c":"c0894cf798000a170efc1f6c5ba37e1cf1ffc650d4671c4643b34d99e4161842","libgit2/src/libgit2/xdiff/xprepare.c":"3fcdbb73bb8c605c4ec4fe353ae7abfb486a916dcff72ebe50dbe6ddd064f206","libgit2/src/libgit2/xdiff/xprepare.h":"4945e8fffe620cd4d687c12618d1a4b2aa95a7a8097abf3e5e341abf96c76e1b","libgit2/src/libgit2/xdiff/xtypes.h":"3336d046bf60e0dc99f3686dfe9ecf098456f0aebe96486be5d1cd64b5d9cefa","libgit2/src/libgit2/xdiff/xutils.c":"fb22cb13666372f2ede07a8d5558fb1d2908caebeb1c50579de5b35ce5880718","libgit2/src/libgit2/xdiff/xutils.h":"78e2813f0d604d4deaf29583f6709111d8368b4bbd71cfdc55d56769570abe3e","libgit2/src/util/CMakeLists.txt":"d827b6f3a8b73bfd75f84186cb2d232e2bde998210b80a0f2368c5ef46e5dc96","libgit2/src/util/alloc.c":"a203aa1aa433888642043576c031fdd01b230405d143511123dc8ef4b831356e","libgit2/src/util/alloc.h":"0897973a8dd43caeedf3806771930d163db62554af8efc61b1c536e7daeb4052","libgit2/src/util/allocators/failalloc.c":"60b00ca09e75ca103e15bff16533a46fece76962c9a5e2c0ebc5f18918240474","libgit2/src/util/allocators/failalloc.h":"b00b8786fb9954e3c65ddc99952efd8a09e0ef7598ae437e4f6d2a81fb56212d","libgit2/src/util/allocators/stdalloc.c":"e100fa204d60a0977c0334207aa8bf77d7787525a6bf2ed097138cbcd62d7605","libgit2/src/util/allocators/stdalloc.h":"e140c3b240622f36d7eeea232dd41711fa2c01e8b557a9d3393a5c2b416a5891","libgit2/src/util/allocators/win32_leakcheck.c":"e9817c98d0dfdf97846a24f9c0d5d25a038f26507ac2ca21b887fef3bc193f31","libgit2/src/util/allocators/win32_leakcheck.h":"1de31b13678ea2dcdae5177f5cb1b7d2d7560ff4069b8f77f07501bec4979913","libgit2/src/util/array.h":"fe58b44e15cc1c2cdcae9f1224ab17b02bedf049c2eb8af3e0ea5651f6eba8ab","libgit2/src/util/assert_safe.h":"0f2b8fa61e0dedbedbc6299618b98bc2c60dd78c386f2b9b8f7b8d747a2daf78","libgit2/src/util/bitvec.h":"281444c865be87104cff9c1b3998877a67bfd92af4b0e5b9b034fd48f6569f7a","libgit2/src/util/cc-compat.h":"555be819b4eb610bc2bf0a22c232efb90bf849c260fb6bbe1ae498f689e261f2","libgit2/src/util/date.c":"bbb6860f1c6c4c991707b0139b5cd52ac35e0bd34f6e224630fd1b6b4c895ba5","libgit2/src/util/date.h":"d24c6276fb168a0b7e9ed05ebcbb4a3ea8174588f348edb1be6ca09b8f6be2e3","libgit2/src/util/filebuf.c":"91181dc3a7a9091f6fceee639b815c2569403237f059bda88f5356f66a705485","libgit2/src/util/filebuf.h":"29e76e8f558651945448013c9d417928089470798004066316183f2505ca7355","libgit2/src/util/fs_path.c":"ef2f864a628cd8176cccc914534091aa2ece98fb098a5186ddc9cebd0b543dda","libgit2/src/util/fs_path.h":"07f44558b1c325254e1d672b15a5f705ea13d08d93f1afdd2dc2428664d897c0","libgit2/src/util/futils.c":"714a533efc8e90adceae1b8863587ca92b54aa5df8fa4af36d2848b3e1a6ae19","libgit2/src/util/futils.h":"99decafe797c40e591e45974c7a13751ee6ea45bdd9eb7d6b6be1fc10d33cfe5","libgit2/src/util/git2_util.h":"e993e8fc64bcfae846c348f47f66e62286e017a6ddc024faeb9b3ad88e44925c","libgit2/src/util/hash.c":"0c88b789d33f29229471a9dfba3da0a989214a08a8ea727582d81e7118c561ea","libgit2/src/util/hash.h":"da6504b76554f493c40ee3043f012bfd1d300c2a0de7d063f845bb0687e10079","libgit2/src/util/hash/builtin.c":"fe213c6a61b923cbd3acd6e55322f4d60c531617f3b9d5d281d2050c6e0a9524","libgit2/src/util/hash/builtin.h":"bbf1ce668c7d38412a5c7351b41da31352f5eba696ed453daaf442e97c225f00","libgit2/src/util/hash/collisiondetect.c":"50be16f2b8736ca61bbe657751a0e66b847affd6030a582f3366c27659e5d245","libgit2/src/util/hash/collisiondetect.h":"21d7b15068a89ed1537a6cdb5d1a3b78e5bb3bba318839579f9b20aa796518b6","libgit2/src/util/hash/common_crypto.c":"241d19fef0e60f08189405bb8ef3426438505bea0752ac57f10db06be6dc8dcb","libgit2/src/util/hash/common_crypto.h":"5b89841130c9d4b09cf90ff25874cec68d18df3f4883ad74b15c408bbaf77b9f","libgit2/src/util/hash/mbedtls.c":"97b33e8b549e9b1da4ae558db570679feed0f91e504b339e4be697084c721343","libgit2/src/util/hash/mbedtls.h":"42dc9f2db495d9440f0ec5dcca33b28395be7bce55d2560c33cc3a4c474623cc","libgit2/src/util/hash/openssl.c":"9ec342a094dbe414d596f708d8f9c86d63cd0702d3ff2e6b1e64afba8a0b444c","libgit2/src/util/hash/openssl.h":"38fe3d56238d70cba097d772f8f2ca14d403bb4f3666c5b217c5e1ee798a7fb6","libgit2/src/util/hash/rfc6234/sha.h":"aa3e10fb530d998eee40ed47db69775341c93a045c7317f2f5542be87b3f387c","libgit2/src/util/hash/rfc6234/sha224-256.c":"b01cf69e8bdb01a83465ec0d6551633d97c96307406d1595887aeea3f5512136","libgit2/src/util/hash/sha.h":"5f17d7991fdd745662601cc6d08482ad9a0ab1337ad6ffd535564898cd2b31ac","libgit2/src/util/hash/sha1dc/sha1.c":"fa40cc0830d58d340eb8942499181de72fd4cb4ad4c1d1216755b0367499661a","libgit2/src/util/hash/sha1dc/sha1.h":"78f97f092c20329d1fa8d9a8cbb3d53bb90be19cbc49f1917605a9ddf520de83","libgit2/src/util/hash/sha1dc/ubc_check.c":"7b0db83569ba82965dc0d16e51e9ad85167cdfdab343f9a02c2c475bfdd93956","libgit2/src/util/hash/sha1dc/ubc_check.h":"4a140693701da167b4709c4c1b330800a0c29f2a065d0d819567a27b3171a09f","libgit2/src/util/hash/win32.c":"fed73763276bc187e2f109eb4aff19653e5fc4fb092066a3be8fd02c9e3cb77b","libgit2/src/util/hash/win32.h":"43b90e70705dcfc28cd19b1ca2ef206a364db60af390d3dd73a8ec13d2a79e69","libgit2/src/util/integer.h":"2581341c6fbc03f9403e6184a40b0aa6d67d8dc1b127e1f4e003edc867e21226","libgit2/src/util/khash.h":"ea517b2c76adbe4480f2fb0dd4d7498adaee0ada831be1607ad9dc322bfce42b","libgit2/src/util/map.h":"f678e1aab0799a95a2152aa6cf6ef6b306eb783ba2a6b2b0e3df147e5596a917","libgit2/src/util/net.c":"2495e833346759949dd9d88b1a083dbce26d8953fe4f6cefe2470977f7a421bb","libgit2/src/util/net.h":"e0be81c875b7cc141bc89dfe1273c0fd591943c246e7d682be0002e83f55239e","libgit2/src/util/pool.c":"9a84fc9208d8cfeb4537d6e8575a43ed6ff56689f23b4b48ef61381c7b5f4303","libgit2/src/util/pool.h":"ac76ce784112b6053089e0c44f26295754388b298fe2272cc0d92d67857bcaac","libgit2/src/util/posix.c":"c21b022c4f3b9dd0a3b6ecbcf2bcc5e2ee57576d8ab2654f08558d6dbba1305d","libgit2/src/util/posix.h":"619074ecd891d4596a20fbb8ac201e7eb45ebbcc78cfd427b89baaf36ba73b04","libgit2/src/util/pqueue.c":"d5cd8f6c5639b50898fe0f9354dbb29de1a0be1d20c879242c8423907466c7c2","libgit2/src/util/pqueue.h":"6c84fffc0bfe473a0f1a7da38151b818826b488244ea660da02a78d4ef3bd3cf","libgit2/src/util/rand.c":"1b699cf44945b0171569d83f490b4d1981659c4a6c447301832fa91691432583","libgit2/src/util/rand.h":"102ce327cbbd6dcb9bdbe4c35addc7efa0095f335873860b06d85c4a070ebeac","libgit2/src/util/regexp.c":"b46bbb0df55b13817e7101559d8555505eff340a9a8bfe68424371c71f5e9649","libgit2/src/util/regexp.h":"855b271c6c8f5e1f3e5dc6648e9364d0448b2a9c1bc72cc3de0d1742e2905b32","libgit2/src/util/runtime.c":"b287e2f3d0a686b77736b725a86b8d6bea904b93c2f987513c608663b818a1d9","libgit2/src/util/runtime.h":"9aac7e20b2b879c49a423ef537bb0f51b8371c24503281b283b1fb74a8944f49","libgit2/src/util/sortedcache.c":"a77931c162e3280f6437c74cabf87b9ae16d5230c1ec54d401a9b9bc0fc6ad71","libgit2/src/util/sortedcache.h":"a15350fb05d181e00eedcd49dfef6cad77aafc0097121094cf60ea9c5bd3e1fd","libgit2/src/util/str.c":"8dca1dedcad4961e5f2389ede13708acb451ccab5c12819b8a7ec2e4057712f5","libgit2/src/util/str.h":"5c26b120517aa1b05ab78af401fa0e1f5848498100bc4204ca9f361451efec2c","libgit2/src/util/strmap.c":"02ee770dfbcc95f15bfe6755853f1c2795782f906d883d3102a904fedb2cda23","libgit2/src/util/strmap.h":"c1dfccefe0af68be84c1ba67fab05b03e866b75bb4a54fd434b0c3a5d9ced9cd","libgit2/src/util/strnlen.h":"27e73ccbe8be7c5bac1d022bf59f2458cc2998d0222e7658a687e02f89fcfd17","libgit2/src/util/thread.c":"6d741eabfe3739f6183e1d65935405f9fc457622d5b21978d4affdf6084e4fde","libgit2/src/util/thread.h":"cf40828f05d3fb3402731217155ce7986a894beec44fa0e8388f1444a83d5f13","libgit2/src/util/tsort.c":"d1dee30457c185e86bc47efecc5417459aefeabe7cfaf8aebe5eb2239296ee20","libgit2/src/util/unix/map.c":"1606c6c48126c72040f985492b6e6bd7b5df27d384f6f5bea9c35118ef7bb2de","libgit2/src/util/unix/posix.h":"672ff8c496693fd458a36c3f8d975a8c068e22597a6a9da4175ee2f985e401fc","libgit2/src/util/unix/pthread.h":"c716daa88e2e7ef2a2df23591a6061965dc11d77ed5fe1863d367a2b738a9fb0","libgit2/src/util/unix/realpath.c":"55a9016da6f89b1c740344e944593b311cfc5495328be915f38301915e560d7b","libgit2/src/util/utf8.c":"6cbf514d854524883a85a781e5e2a9003d71793fb2cd527795d26c972831a8ef","libgit2/src/util/utf8.h":"ca0239005ee004df1b2593aa727036a82f1ce3953000c3acf712b2639acd9206","libgit2/src/util/util.c":"52f384935855140d481c9a3d3c72df1679d1e777351bb11185b9c80ad956f766","libgit2/src/util/util.h":"ff16fdc19fcad0182367fa513676c033fc6aea0af13e04209e16fb3522954f44","libgit2/src/util/varint.c":"f93c5ba3498ac04d98ba13d3a320263892452356f797c4091411e5833dfe82f2","libgit2/src/util/varint.h":"b429d5e8b69d579cc6dab5e12ab4acf904c66947b41ca5372dfc3e327e59f533","libgit2/src/util/vector.c":"03cfd9059ffac7ada3c208379eea8ba9bb3b47e33e11d944ea333d3760ff08e8","libgit2/src/util/vector.h":"9fbf45c39ea5f2b5859022cd73b5cb857b162a7981b1838de584abe7d7316828","libgit2/src/util/wildmatch.c":"0102685757a40046a5fdee4be5be784989a84d3b4be9160d48120c4485c37133","libgit2/src/util/wildmatch.h":"7d59454a8271f810622ccfebb26c8408bd85f64c99d4411028e8482ab2c333d0","libgit2/src/util/win32/dir.c":"a0490ab8fe3be9213093afca1923a0fc472d368f2907ab23a86bb392520359cc","libgit2/src/util/win32/dir.h":"7835a64f082860bee53530a381fe9d6917be39f0d756562e8306dfd78154d3f7","libgit2/src/util/win32/error.c":"f1d2bcb2b6e60ca76c1ee0ca0f236e928331aa9755afc16926a5dab5de26d255","libgit2/src/util/win32/error.h":"44175c12d291bdf80df65a41cf669708c252ec04c8e084c41777c7a0b53569d1","libgit2/src/util/win32/findfile.c":"a6dbd2a8939699c9d534e3fb26db8b04c90377dc78ad9502bfbeb9e727f94d25","libgit2/src/util/win32/findfile.h":"fb00f3bc24bc7e2d7503df666b7ea8654d65cb40331dd51570ae793fd6f285e4","libgit2/src/util/win32/map.c":"6ce9c0a15df639d1d5b334685eeef03698b3ed006924e60b67461336fd7afc20","libgit2/src/util/win32/mingw-compat.h":"f7b0c7e9dd7147e8930782cdf54ce4be385172966dd1e27435446f38cd2f6d68","libgit2/src/util/win32/msvc-compat.h":"36e4c9515a8d53e70f78794826700c4a5472235aef703ac439308dd005e31454","libgit2/src/util/win32/path_w32.c":"c2629f35267e96f2e94e4a64a1cc98c8a88e687bc51073b68309745303950d4c","libgit2/src/util/win32/path_w32.h":"de01a65de67423157b23202bcba550f4ed1d5de2ac0e06a4f2ae8177aa4319ba","libgit2/src/util/win32/posix.h":"4dd2fc1529fc7e625180b649b9212d83462c654e47ba799fa62353aed5f60e14","libgit2/src/util/win32/posix_w32.c":"c4f8844b93e91e94bd0d55178f6ebc60a310fd531b0151ee3292df47f4077fca","libgit2/src/util/win32/precompiled.c":"4dff04101bd64b95c8f708d1accd1bedc39e95a263444290f796c63f4734d4cd","libgit2/src/util/win32/precompiled.h":"3f763f472fbf822314807b91ee9a2f88fe7f2fbcd165ee4e57f3f90e2715f14c","libgit2/src/util/win32/reparse.h":"ba254a97aba283930306f39f73e297d5eb30350276b3dd86deecbf10b4094c97","libgit2/src/util/win32/thread.c":"bce98dd6a635b66d811fab98b943ec448751a8b55c7261732277ca2804862fb9","libgit2/src/util/win32/thread.h":"8141cdc5c89901c2259a64c8f070950f69d4b742ed743ee1c520fd47b5b6948c","libgit2/src/util/win32/utf-conv.c":"fce8f7998d93fcd4f043d4d643f466a854b9611389487250e65fbc987a455bca","libgit2/src/util/win32/utf-conv.h":"3c19df554ce6f006e6a6b0ca46b8cb81fd64ad0f000e92685a681fd33d8ed408","libgit2/src/util/win32/version.h":"d9d9546728ee78923ba7ea1c16c000d44450ca80f8c0c3268bf58fa9966ba38f","libgit2/src/util/win32/w32_buffer.c":"1099be7c74b5bb265614787be285505e18dcaf71412607d8ec108639762a5b8d","libgit2/src/util/win32/w32_buffer.h":"a11005a0f3b2ecb3220ea9cdfd1df4b61d90f10e0e68ed2716b2f9502f2fa8f7","libgit2/src/util/win32/w32_common.h":"214cd67bcbdf89bb7effb78ee50c60b0504319117984c1a990f8301cffd78e0d","libgit2/src/util/win32/w32_leakcheck.c":"844ae1c7a959c8f181b45cc49a6f34262d03510f7748b6be7a159d7fd5c5e56d","libgit2/src/util/win32/w32_leakcheck.h":"cace8320ae9e8ef1d5b4836905a2d318e9e2a536ad3e232393e5f42b428554e7","libgit2/src/util/win32/w32_util.c":"fbe85eac432d4d1462ba659726557f782e811353170df8838ea1f967950d8711","libgit2/src/util/win32/w32_util.h":"f052487c469e5ba2fd327e55db1721e8f3f8d8947872ac63c6a3591fe7768853","libgit2/src/util/win32/win32-compat.h":"5ea7b1837a159d66a89365ee2bf3724b32579a6a78d94b0b205d44c8697a8e6f","libgit2/src/util/zstream.c":"51e507d17742366b91e6f427a48b566b52013f06502c3f05fbd6f5120b3d6afb","libgit2/src/util/zstream.h":"daa41460cf0ed019ef62a1936fb18626e8abac2b9a05061b6a377d4ab74a4cc5"},"package":"47a00859c70c8a4f7218e6d1cc32875c4b55f6799445b842b0d8ed5e4c3d959b"}
\ No newline at end of file
+{"files":{"Cargo.toml":"393446c2e70ebbe2bcec7ecddf72ad7e78a2b50d5637e58930cf627238563018","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397","build.rs":"aca064d4f60d2661a769604e0fddd2d0eb7ecbb6b7544a29361a36e7d6ba7468","lib.rs":"68570a9143d6aa3de08fbfa0eb3f31d93c6bb5999076b60061d2b90858c0417a","libgit2/AUTHORS":"d7d4f16a8e4303cc515fd4410b2c64b7ded924b1e8784a125d15195555e986b2","libgit2/CMakeLists.txt":"37f666fe9b6c7fb69a6edace16cff583f260626662c8edca59abeb1c7bc9266e","libgit2/COPYING":"0fc09da43d666b5b0cf5695defc3100d5cf387936b260ebab37e396d7e0dbc83","libgit2/README.md":"70e61736b253d42da3828d0ef16c052c48d9d1690a75ab476055144475757a2c","libgit2/SECURITY.md":"566da5b3e26904232486c2b7107a1ebb0dc90e8eb2f32b9468d0da41e1cd5543","libgit2/api.docurium":"c77dc54504945864b3270877a9ddcabe85d6d1a742c07232f6faf847958c0dd2","libgit2/cmake/AddCFlagIfSupported.cmake":"4be37a9752e3859c9ab8525f365fcb4392d1e5135ea222795c304b42dcf11b13","libgit2/cmake/AddClarTest.cmake":"022f6d1a498bead384338fd1b17ddcf72ce18d6ce54b6c0298ee3ea61c0d63ea","libgit2/cmake/DefaultCFlags.cmake":"a2b5a645f29bb3be74aea7bf5f5d83a77f68d3190363e83b43f9ba70a41c5963","libgit2/cmake/EnableWarnings.cmake":"f5690cb37a672c92696f618890da93d44eaa07f3cdad9a3515bb08125909ac0f","libgit2/cmake/FindCoreFoundation.cmake":"5f71227384a4914df198dc7766b6b8474942730a16c22de0c987c9548808f1c6","libgit2/cmake/FindGSSAPI.cmake":"6704673fcbc0c94c02395a3e4fd96f41fbe0111397f0f06dd9a912d11c1ddb91","libgit2/cmake/FindGSSFramework.cmake":"136f3282657cd83aa5a9ea4a3d11ffd14d839e637c6e2669aa5f0c0eb9d9daab","libgit2/cmake/FindHTTPParser.cmake":"ca1d95edef14b1e05449d45dcbdd93c386025c408cbf27a00cb4af4ab0d62a7f","libgit2/cmake/FindIconv.cmake":"b11c24e5fe2dd98662f87058eb9439e530f38aab4f27a9d241df48a087e6b4c2","libgit2/cmake/FindLibSSH2.cmake":"0cfe918a5d00dbceeae55ffeb5546f8c5595eb48558c2e9584561db17f29b91f","libgit2/cmake/FindPCRE.cmake":"2b1e7b45cf0410320e706573ecce75b8be4eeda6b9b4fa19893a248c57096a71","libgit2/cmake/FindPCRE2.cmake":"d8045c217a1856963badd52548406cab2881d2ae304608d6b40bd77bcb590f0e","libgit2/cmake/FindPkgLibraries.cmake":"e50a58f9d39ed58d5bfc39e6f18066b436cf92ccabd6683fed4f30cee9689627","libgit2/cmake/FindSecurity.cmake":"1c16ac77018f28efac83cd848c130d5127c22999dc48efe44bc8ee9b501deb29","libgit2/cmake/FindStatNsec.cmake":"4b3bb2337ce205580703704a2725eba085044810d54a0e0cc5680b6f71eb494f","libgit2/cmake/Findfutimens.cmake":"281fa0a75648482e3b13841d92db2c5332147fa8c7f96afe7ee11eae77a6bfd3","libgit2/cmake/FindmbedTLS.cmake":"23d2c96094b525b7a333427776cf51f0a1466a70d9358af48c8d851e20ebad64","libgit2/cmake/IdeSplitSources.cmake":"0c1725438bac95a6c56627408b81017a88748944b0ff83cc45c0824421e3aeee","libgit2/cmake/PkgBuildConfig.cmake":"fdf17c32ee3621b671695f29a1373f4e2d05606dad03a658a751e94a37385f91","libgit2/cmake/SanitizeBool.cmake":"6d93d776331f1cc9d4052ed53731789d6e141bba9ac8681dba70a80abb2cdc00","libgit2/cmake/SelectGSSAPI.cmake":"12bf9cc930b90c913906982979d84a3c6fc31afd439583779c408b525e57c6bb","libgit2/cmake/SelectHTTPParser.cmake":"1258d26dd0a1a23c37f02d8f8cdaa58e5e1fe4a6ad71863e1a573faff4abdbbd","libgit2/cmake/SelectHTTPSBackend.cmake":"3e945fb0ae9fad47b50046d5457522668dd106a3dd81464d723e1a969c0a1a22","libgit2/cmake/SelectHashes.cmake":"1686299ea6802989778176b4d37d86297a62a0200dcf3c25b394c4130e3966b4","libgit2/cmake/SelectRegex.cmake":"6c32e01fec5c3bc099a3b20fd10a08ce1594fcdccee2cd3f9386f6f7d77a9c82","libgit2/cmake/SelectSSH.cmake":"d913763a6342d50c49a2c42a4bd77dc3fc530c70bac193b34cbfe74b7c83ce8b","libgit2/cmake/SelectWinHTTP.cmake":"2916180fa2c0aa79f65866e5b0ff5b1c560cd4e0cd1b8a5162d401b660b4b6c9","libgit2/cmake/SelectZlib.cmake":"fa08bea6c807ac97f1790ca46590a4f7d63570e1b51e76240483f5cc4762e3a9","libgit2/deps/chromium-zlib/CMakeLists.txt":"f8c70a5cede31712527ba84f3eb0c0a8319cbf7643c6afb63c1fdfbed1e757d7","libgit2/deps/http-parser/CMakeLists.txt":"f3fb5bb432aa7267ce9f6aee3780346ee6d0899154a3f05a1e57eb13bc5a1822","libgit2/deps/http-parser/COPYING":"2996a1c43ee757f9c997a829d82bdd584052323e73cf02ff8126c6fbd95c2d87","libgit2/deps/http-parser/http_parser.c":"80930f8b6c15827a3ae571e77ddbdccca366e8f6c98874062cb8c0c6dc877ee2","libgit2/deps/http-parser/http_parser.h":"d3fd211486e4352f57a47e856a5a10dfce06c46211119d0f6d9935713d2ad08a","libgit2/deps/ntlmclient/CMakeLists.txt":"9740dba96683b30a304735acd2e2d6464441b22677058bb4a5baa5f20037087e","libgit2/deps/ntlmclient/compat.h":"f27a8e91c75ed75a71140c597548b43fae19b28eda1a09ab28e367a196bdad84","libgit2/deps/ntlmclient/crypt.h":"38647af40b21a8baf2c2e73e80ff631718b7fb0db51b0c2079d4bc85793a2032","libgit2/deps/ntlmclient/crypt_commoncrypto.c":"445b2f9d8f2cc820515d0bdf262d699e635061c81c2d617d7e3da9780817f7a9","libgit2/deps/ntlmclient/crypt_commoncrypto.h":"55a6fe82280421e5fd61f20be1938cc92efef1a211147072790eecc91eb87e6f","libgit2/deps/ntlmclient/crypt_mbedtls.c":"162fa2759c1073ce61a6bc2e7898a8c8557b8b4cda1191fca8af75200d971cc0","libgit2/deps/ntlmclient/crypt_mbedtls.h":"d10c8dee39844ad68a6f408d4134300b984279da9dfb9c7ff070a7065e5ecc26","libgit2/deps/ntlmclient/crypt_openssl.c":"ada5b18064c3dd95c4aa352103096c5a24fd6c843f3995c236be7a45a52c5fc0","libgit2/deps/ntlmclient/crypt_openssl.h":"8c87194b5fd0220f4b40ec5ddaed151c8a189a157ed3b3ab3595f5358cf4a62d","libgit2/deps/ntlmclient/ntlm.c":"98556b43c4e8cc3b2559c86c447d0df02338ce949dc84a691ecef9900cbedb2c","libgit2/deps/ntlmclient/ntlm.h":"5328219af7251999ea78a2d2d648a6d98943af7ace5fbce0d8cb5ad4b0bb4c60","libgit2/deps/ntlmclient/ntlmclient.h":"fa223a164392f53822703c80dfb1299d3483bab3b9ad02fec1058a0f50a55eca","libgit2/deps/ntlmclient/unicode.h":"ddb0cbb25cca1a2f413865070fd47c354f87caf66f868022dd288b90fe93711d","libgit2/deps/ntlmclient/unicode_builtin.c":"3bafcf95dd5c6b3ea3d54d7b24e7333c4af13f6051922d6f27cb6497f9962329","libgit2/deps/ntlmclient/unicode_builtin.h":"fb1674d49fc240f33d8120fea10504021a61f69967d933ed386d57d0b267127a","libgit2/deps/ntlmclient/unicode_iconv.c":"45f30469fa188781f5b61a645368d9fd9249f5c9d8aa8512708e98b242259f5a","libgit2/deps/ntlmclient/unicode_iconv.h":"7dd5cfe97dbbbcec94f3e1dcd6edf51785f6eb5510ef96607fce45ce1cc818a3","libgit2/deps/ntlmclient/utf8.h":"0b57540746cfe500009216ba3bb7bcbd1555c158648ec82fe26f16bef75adb97","libgit2/deps/ntlmclient/util.c":"94ec747cd810c90ccc966688d89ef8dbfb91e41aea2f665a13db5fa18ac26443","libgit2/deps/ntlmclient/util.h":"3b15e99337fa1555fd99b2434894cdef7c0ea96167f7b4ff4ae772a1d0982bb8","libgit2/deps/pcre/CMakeLists.txt":"1d4158a8b4f8f380e93c5764c8fa8c1820c0b517ad8f40d47084a06975bec6a7","libgit2/deps/pcre/COPYING":"17abe1dbb92b21ab173cf9757dd57b0b15cd8d863b2ccdef635fdbef03077fb0","libgit2/deps/pcre/LICENCE":"0dd9c13864dbb9ee4d77a1557e96be29b2d719fb6584192ee36611aae264c4a3","libgit2/deps/pcre/cmake/COPYING-CMAKE-SCRIPTS":"46cde7dc11e64c78d650b4851b88f6704b4665ff60f22a1caf68ceb15e217e5b","libgit2/deps/pcre/cmake/FindEditline.cmake":"44788ac3e7c8c4b4da3e5e0f467c7ee49de7ba9e1c13024dcf1e2501f8fe9684","libgit2/deps/pcre/cmake/FindPackageHandleStandardArgs.cmake":"aa3ef1f1c8742da54813aab0ac58c71edd1e58cd3b6b157b856bfd525adc2e5d","libgit2/deps/pcre/cmake/FindReadline.cmake":"055e1df8bd29e6837d8ebb8c15dd5dcb28c88e23aabda8538b76a249dff829b0","libgit2/deps/pcre/config.h.in":"480e3e1a1eea810516e59f19375575e83f62980d20b9cfc990ecf8e8cb17f79f","libgit2/deps/pcre/pcre.h":"885609063157d6eb0e3c74af413b608dcd60a94efa023319648a7a8a6e4daa20","libgit2/deps/pcre/pcre_byte_order.c":"4030a1156da8690352226b5de2c9c5f52cc6955409e4a7ab9ba4d6b223e74b3c","libgit2/deps/pcre/pcre_chartables.c":"3386fd60b4a4175a7baf474223522540abd6e006e8507a04d3485f84973424ae","libgit2/deps/pcre/pcre_compile.c":"74526b16f6683efd56742a6cacf31ec1d55dfd8a9fc04f66df59e5e1fbb4354b","libgit2/deps/pcre/pcre_config.c":"fb9e1e766291b2b4b3066ecfd0795db398762b9597fb2af23cc784617984609e","libgit2/deps/pcre/pcre_dfa_exec.c":"1cbf3a680388110bddff833983d3653630eedf6e6e9d9e656a737e3b85de9dd0","libgit2/deps/pcre/pcre_exec.c":"2a6871b9a56de682ce28a467d26b42caf71f4323e44b555db720cd51c0f2c505","libgit2/deps/pcre/pcre_fullinfo.c":"a84fc4cb4d22b2ddfcd4d0f0a0ff333cc9f623e1fbf2a7c90623a212e0bde54d","libgit2/deps/pcre/pcre_get.c":"c93ded768f96cc392f911776e6d993b565114936e08247dfa79080b35dada4e7","libgit2/deps/pcre/pcre_globals.c":"8b2fda23b42715eff2f01188c4911dd8453868ff77fccfe34b99126aa775fa5d","libgit2/deps/pcre/pcre_internal.h":"f713de1fa2c20b5414f6746c80d10878ab48c9186462b074c5bb6a74a822fa80","libgit2/deps/pcre/pcre_jit_compile.c":"76ed39027b25f2bdab581c0bb12b95fa3659baa53c81e10f8f17819d6255199b","libgit2/deps/pcre/pcre_maketables.c":"8564fab861c7eb4037ffcd53fda789a747a30c4a462f460a5ef824f534fb06dc","libgit2/deps/pcre/pcre_newline.c":"3163ed2193fa74d8cc9e1db2bba672bcebf8efe85c2465cc0aefda51966bd929","libgit2/deps/pcre/pcre_ord2utf8.c":"fa926e32ae8d6e5610c500e7b6971a5149765a1881f798b18904a0a88bf549de","libgit2/deps/pcre/pcre_printint.c":"71751d151efbe935e9d8bbf58bbe143d617b34acd13d1bf237330c7c7736c422","libgit2/deps/pcre/pcre_refcount.c":"0dd8b7273243545fdafab585890fa12e210cf526030eb6b877325ce89250fa39","libgit2/deps/pcre/pcre_string_utils.c":"b83225f9cf2658654d6a0af01199050f6fb36d903041b33cd4d0c06e762b66df","libgit2/deps/pcre/pcre_study.c":"f5285714b59af9503dacff268cb37ab4944fbdf74a78c5a7b9bc49043a00ba40","libgit2/deps/pcre/pcre_tables.c":"fcdd9f705a7a1640ae5e5e5b7148761fc5e82896d84b1a287dd7e55b8b87eb15","libgit2/deps/pcre/pcre_ucd.c":"b35ad7e532f52c5fb1f4ab1d48f5d80618abff2a115099220d95cd13ac64c346","libgit2/deps/pcre/pcre_valid_utf8.c":"4265abf04c03acba9ea90351da662eb89aaed79e7eef03329ccf030ef28ef907","libgit2/deps/pcre/pcre_version.c":"5bb67c3373a934a2d9263ba9f9fe3cd79e381e6aed8507e5319202330bc5275e","libgit2/deps/pcre/pcre_xclass.c":"b2c3b2c7600e18e562a333df017ee35c69233e9427b866726d944122a9560e28","libgit2/deps/pcre/pcreposix.c":"49e996bbf43cb2d4acec350410ab40f811a9fefe21fc68004c6182a8da884aba","libgit2/deps/pcre/pcreposix.h":"85a6a09b806d8506e5710e9862b6716b2b88761abe0d05aeda5071257537d9c3","libgit2/deps/pcre/ucp.h":"ea98e4eb999d8e777f2ba709e68b5aff7108a4eaa169f4eefa4510056551b724","libgit2/deps/winhttp/CMakeLists.txt":"e9012f9e9812df5a744551a9b57982fe8c8ffbdd3ddf41a8d96e58546fcb72c6","libgit2/deps/winhttp/COPYING.GPL":"d9a8038088df84fde493fa33a0f1e537252eeb9642122aa4b862690197152813","libgit2/deps/winhttp/COPYING.LGPL":"dc626520dcd53a22f727af3ee42c770e56c97a64fe3adb063799d8ab032fe551","libgit2/deps/winhttp/urlmon.h":"6cdb0f5ce5f0aea2daefc44c4806697ed31ad759f8baa18fb38a5b220ddc7d7f","libgit2/deps/winhttp/winhttp.def":"89601b95ac2515619426ea52ca093fac1a16ef0bfb5586c1385a028947ab6513","libgit2/deps/winhttp/winhttp.h":"a51828d65b1b260a727f596c41cf3257cac2ef6cfebb11726234fd7ccb1537f6","libgit2/deps/winhttp/winhttp64.def":"7cd0bc8dd2c06d288c241d175da06146e940c28d7201fb63de8a75730d09fcd4","libgit2/deps/zlib/CMakeLists.txt":"5d583227eeecfe65a9b59742e128b7bf33f0bcbd8749a17f551ef8b7a4b2671c","libgit2/deps/zlib/COPYING":"864943392878a2479350e12a04f6e8e0ae434b5573bae350823c4d6c4474c755","libgit2/deps/zlib/adler32.c":"d7f1b6e44fee20ab41cef1d650776a039a2348935eb96bcbd294a4096139be3a","libgit2/deps/zlib/crc32.c":"6b136ac32aeda10adeea8e8927b74b52129625e0d5b73b10e5324fdf28c6c572","libgit2/deps/zlib/crc32.h":"9a2223575183ac2ee8a247f20bf3ac066e8bd0140369556bdbdffc777435749e","libgit2/deps/zlib/deflate.c":"26562ff9e6b5fa539e394a1d8355ca350b80567f59d6296973dcf209ee11693d","libgit2/deps/zlib/deflate.h":"0db1b5ef79ca6ba0f508b7b8bdaa11af45c5ebe2c89ab4f1086dc22b963a52fa","libgit2/deps/zlib/gzguts.h":"fa85c9dabe24e42ba95c702870416ff67ecc58906321f8e74b72a50dfd7df400","libgit2/deps/zlib/infback.c":"f8ca8ed0ce4271886efa0ddea45fd1306f2bf0b675748804737f7dfa8552e630","libgit2/deps/zlib/inffast.c":"41d93aefdbfee5455809130af74fcc76cf7259b1aa8b34d0060d14e57463e8bb","libgit2/deps/zlib/inffast.h":"7d8c1c873ce9bc346ad6005bb9d75cce5c6352aaf7395385be216a9452a34908","libgit2/deps/zlib/inffixed.h":"237ba710f090e432b62ebf963bee8b302867e9691406b2d3f8ee89ee7bfef9b0","libgit2/deps/zlib/inflate.c":"a268c9231441898893c0e2212c5304625c88d12371f1c09fcd2b2a7a54d57d43","libgit2/deps/zlib/inflate.h":"e8d4a51b07694bf48cb91979c19974cf6a5ab0b8a09d26ec0d14df349230673e","libgit2/deps/zlib/inftrees.c":"14a07279ef4c2e7c176a3d5571c45fcffb223b327b92e66a0f5c41d52bef8b9e","libgit2/deps/zlib/inftrees.h":"c510b36402784b1f898be3b049b923469aa92701de2d9195aed19f6b65c0dce2","libgit2/deps/zlib/trees.c":"7ca01688547ec147fc1714f475a6146abcd65f5b5806e914038277b4b5dfd8df","libgit2/deps/zlib/trees.h":"bb0a9d3ca88ee00c81adb7c636e73b97085f6ef1b52d6d58edbe2b6dc3adeb4d","libgit2/deps/zlib/zconf.h":"9c0087f31cd45fe4bfa0ca79b51df2c69d67c44f2fbb2223d7cf9ab8d971c360","libgit2/deps/zlib/zlib.h":"1a8c17389c6aaca0a52697c49bb2bfb403527bdd266ce626a331bb03322a2f68","libgit2/deps/zlib/zutil.c":"b5d725d43b43317c2b7c8fcc9622b0c7861f0f963c3da33f0b2c55cfffbcc448","libgit2/deps/zlib/zutil.h":"ae060141efbf6856488e646075e564c33b0fc429ec80f5fc9b1134e967d711a9","libgit2/git.git-authors":"807ee76d5d1f87f87bb4deff8196b7854530521ebe52bde5d52b9e2bb82a75e4","libgit2/include/git2.h":"3cc2ff96db345c2dae88c2168a9e4f0d23da336d9e0391a096320e0f08ef2c24","libgit2/include/git2/annotated_commit.h":"b416a1418b38c638cfd331022cf0fd059ec693090ffd29df3e649fbf502605a2","libgit2/include/git2/apply.h":"754163b99c945f1b2481cd6b50e89a66f297ad4a738d54b013620524d207c8c2","libgit2/include/git2/attr.h":"976d36632e3484981d5c7df133e7216a99701162a5c29565c6ee94e22ba8fe7a","libgit2/include/git2/blame.h":"58d6b7ffb8b4039ec75450206366e874c224339b326545ec7de8d7c2e20b99b6","libgit2/include/git2/blob.h":"d75a234addee2f8d5759cb47a80cb6d063b6d83895558538a05d2d3c723fdd6f","libgit2/include/git2/branch.h":"f93416a192759d06673fcaae761f2414bd8156a8b86b4ea5bdeb7e05786c61dd","libgit2/include/git2/buffer.h":"58e37b5487f578ab15472d9d117297fe417f9a4e6e9da1a5d2e185df311f3a00","libgit2/include/git2/cert.h":"1904a8d944de4d1fb6168cf0a4f5f166de7c06721ae9d564d2566927e37c6ae7","libgit2/include/git2/checkout.h":"d25583f792c94f0d2d0f18e890cdaa3d71cde815088d9236bcb08eb910507a3c","libgit2/include/git2/cherrypick.h":"9d55b4dcf4a3db3cc432d9ab60bb6788c5a0a22525f3d2c5c071e6e693df3824","libgit2/include/git2/clone.h":"9467e527a03ef4857e028b8494af6a663ddbc9af8d6503bca603484b9539270c","libgit2/include/git2/commit.h":"a0a545f449737130cd771daa3247bfb73da3fbb59617258de9b0c9b58215ce0b","libgit2/include/git2/common.h":"dd35fd29906a094039c5ef3e62f3338782a18999f8eb11c2429b18e0bb426173","libgit2/include/git2/config.h":"6d7364d182f3865d7b5ed7872a86abb56a1aea2b083c91b3c38169b47ff3433f","libgit2/include/git2/cred_helpers.h":"4478aa5e3f82cd754333311939c3c0d5deeff7be636f68e03a7f5b1c5f4bf73b","libgit2/include/git2/credential.h":"068d3e80ab9a5742ba97ca42e8d1c4d122168d7fe38f666848acfb1811884c72","libgit2/include/git2/credential_helpers.h":"efb330eceb6aa54313a1bd69bfbeee05fd4de59bdd0da676dc7a3649df3dddd8","libgit2/include/git2/deprecated.h":"102a29081a34f45405605f45295ecfc6a7e60363026259b564f0277fe574bcc8","libgit2/include/git2/describe.h":"7ed1552f3989171af8055ecac535fdaa34dbfa1a63f9622646a1270e522705a5","libgit2/include/git2/diff.h":"3b2c8e876104eff0bdd9cb3a65d73bc51c0f4b512ce0b87db5fd664ff1cc5037","libgit2/include/git2/email.h":"6f23dad8044f6a38ae3115022308d27fa4d52e054f53ef275a64fafa8f594d3e","libgit2/include/git2/errors.h":"19ff7353f8f03683a6bd7d25482c496a4b339aa6269730e601ef8bc8dbecadb2","libgit2/include/git2/filter.h":"2d10cd829385dad197307e82991c7ffab845e588dd0ff025b2a51797721cdd77","libgit2/include/git2/global.h":"88e49fa7593012aa9575df08755b907b5b613f43278f477e9ca8e4feedbe6786","libgit2/include/git2/graph.h":"c0bb3f0ae78d58c9bd23f0c41192f7f14aab09b67bfdb01f46974ab4f2a4df89","libgit2/include/git2/ignore.h":"a8bc1a437e37b6d73e9520023eff88c85c134c19a50b796234c6b884e5e0cef2","libgit2/include/git2/index.h":"ff58b50593a9e5ef0dfc662cf69bb78284902c7d17c058262b1e6c2253b0fd43","libgit2/include/git2/indexer.h":"d6506558f99f8ee2b3e0d7e381c7986da862e79edbaa170f0e2d38ce078c1b58","libgit2/include/git2/mailmap.h":"4f0d18eb0ab5ffdacdd716a9649319683fb84a33627bb4dfa6fed8aedff55d73","libgit2/include/git2/merge.h":"f66f9f7d13162a9bad2652b4217863e3ef9e59e1dc9cdf7defb84cbcd6d64eff","libgit2/include/git2/message.h":"8e517062c86668c667132deda83fc3cd07f4d07f064a09cb04b586d50c8abde9","libgit2/include/git2/net.h":"aa6ce5cde1a1c0dc586b3ac22bfd68689505d05fd91ee4c128c0225fdc7676ca","libgit2/include/git2/notes.h":"59256cc18452a945e1712c210a957685501448225f57f3ade0a839cb9124fe12","libgit2/include/git2/object.h":"8406b242bdd0cd60db8dddd508d7fcb58d44bc30d0008d4032dfef41f28c24ac","libgit2/include/git2/odb.h":"0def8d5f1e445e65509f1bf24e7f358c757f7841018dc4de793475f48a6cd28e","libgit2/include/git2/odb_backend.h":"1b2f3cb6a50bbd2a4c0747554b36191b4224e44a2b8baed8b30c53bdda79e236","libgit2/include/git2/oid.h":"a2510249c32905b3f4d8e149341f81d4f56c1481be3fe2ee21edb49e1ac2ec72","libgit2/include/git2/oidarray.h":"aaf8e8102afe1f35429c8738976ae1f886c5d831fc2d19737ec3577c901741bb","libgit2/include/git2/pack.h":"a13a500f23e2d37cfb2024d7241e5b0ff91e9d725b6fea1709be5890aa3535fe","libgit2/include/git2/patch.h":"0db799834e35d61733ad636a66e873030721a7b82ea965a42e1039184b9e48c2","libgit2/include/git2/pathspec.h":"78a7fa9ad4b7637e23fb7987ac960584ae2b8b51ec10016f0a75e006f7ab35c4","libgit2/include/git2/proxy.h":"b58b7f080ca56ebdfc51d9807d97c32023c5d3fdbd670a4bb28b81ba842cb87b","libgit2/include/git2/rebase.h":"9635cbd62c80a2ac6f54d9591cd210fadd1feaa5c0e9a08a8e9622c0bdb8eaf2","libgit2/include/git2/refdb.h":"689516e9bc72b8c569800b0100df3c2f3b870158c996ab48c90b8638ef8c251b","libgit2/include/git2/reflog.h":"3f9202628c60cd7ddd15a6d759439b758616ddf542b011b15490077bb4446903","libgit2/include/git2/refs.h":"9fc384e8e3b6151a722985beb69cc58e927e53c39a437413373999d340f45036","libgit2/include/git2/refspec.h":"3fac2002e7bcc36fba7e353e728846423c121520e8caf00836d232493eda2db0","libgit2/include/git2/remote.h":"f8479a944c2c7c3ea25689e0747e76c4c119a96a50a5f83c14a162082375c5c7","libgit2/include/git2/repository.h":"d406dbd472b64d444f9eabac3554bebab34bca37693d28db72b62cc3506eed4b","libgit2/include/git2/reset.h":"29c8b65e30cd7b7274d3fa2c88b95512f03ea6a705e26636026b77685c208efc","libgit2/include/git2/revert.h":"fdc9b2a8106191b36edac31d586375f82257614050b1d75fdcd0066e36da2243","libgit2/include/git2/revparse.h":"dd1295cd373cf0493090123d76d7fffe1f573f5cdae46d4bb48a9ee1cfc94d32","libgit2/include/git2/revwalk.h":"ef5edd2d05eeb4b6d60428d53e1474a1af37348d375c749b3e445f8704df0e87","libgit2/include/git2/signature.h":"8eb48ed252cf68b7d9a3d8dfb183a8474c395cc6bd7abc20e70d9ea728b042d4","libgit2/include/git2/stash.h":"bbb860b2c01e856fc2c3b53cc48c5be053a66bc83f958768079cd1f31f92466c","libgit2/include/git2/status.h":"bc1a3daf6b85aff463645e8ab45bef0d86e2058311282bd8bd97e12d4fcec151","libgit2/include/git2/stdint.h":"ff41f7b6917b7c4955a685a28072e2dc141f626f5f09068e33fbb2e05b866bf1","libgit2/include/git2/strarray.h":"9a1133c71aa242661c684f78f5028e00d2c520a4a833906b125c05038448658a","libgit2/include/git2/submodule.h":"6a8de8e3505de2d2f6dfbf294bf758545649114f977af1dfa0c3fb7980aea99e","libgit2/include/git2/sys/alloc.h":"9a19fb88e2c70146520d63e01778e22938976a4b754e4bb9e487c4d5a2ca486b","libgit2/include/git2/sys/commit.h":"3d1b2220325a82983ecb271c2eb8383a8db134dfc0da96b1f050f3664871252a","libgit2/include/git2/sys/commit_graph.h":"d178cae2b2d36e6b07bb7ec8e3f616ca6db591d207116b946e065f267fca6282","libgit2/include/git2/sys/config.h":"7888b5265f18640820d43f8ffc31e3e6b3153398ee2851d657ae8b28bdcd10a4","libgit2/include/git2/sys/cred.h":"b2ea956401c5554f26cec0f428dd9d0d9661d1ef3d9368769b415193df98ed1a","libgit2/include/git2/sys/credential.h":"8cfe0a41b027f8196f43fd2e81c15bbe1a26ed7c15468711f900dfaad0a3705f","libgit2/include/git2/sys/diff.h":"e341f693acb25645f6ed47c041fc4eda8996a6f1d42905ae4f87fffba22520f3","libgit2/include/git2/sys/email.h":"c90da62e7696a61eed3f21ecb7c9feb39569130746a6bd317e3e82e18c070bcd","libgit2/include/git2/sys/filter.h":"84830316c546511631506cb7b833a1cd39fb9deb76249e2ce6b02c524d00db19","libgit2/include/git2/sys/hashsig.h":"5677f86c02e557c7897e98d395e83d8168c532916ecfb7f9ca5bf7b4057141f4","libgit2/include/git2/sys/index.h":"bc6a371ea47773019e17e5ed5951dbb5b9d773c437d6d49e79e20fa175993c87","libgit2/include/git2/sys/mempack.h":"677bbdd7c613d82cc07966318f133c6ef4101b1a1dbfc0f3b1979a925ae50810","libgit2/include/git2/sys/merge.h":"48bd0d3a80046712287e5c396ca7dd6d81af5cd2e765f96ee89fb298d17a79db","libgit2/include/git2/sys/midx.h":"d191831dd85832e62c3a940370e355dff7e7432fb8d11c27d6698a7e8c4555f6","libgit2/include/git2/sys/odb_backend.h":"da9ac8662c9ae94b2eb51167ba81ef9adb6a537382a6eebd2b98b1c908ab8b1f","libgit2/include/git2/sys/openssl.h":"011d45d1991a7d4467b5de5c574718af5b16198fb1581639845fd8d07bef7758","libgit2/include/git2/sys/path.h":"97adf0e0751e456546c7c0119743e50aa428fad8a29184fcc637db1eaae08b67","libgit2/include/git2/sys/refdb_backend.h":"6be92a5c1b660e4adf99f4604fefc9e93d2e639ae53295b722a1364723d036bb","libgit2/include/git2/sys/reflog.h":"c307ce8e9c8b0483ec45ce34a200f74e1ee73bfea9c4c7b0cc3923e3881360ca","libgit2/include/git2/sys/refs.h":"ee98c1aa0596b1cb409795a94de4891392e1675c42e8877a1e38bd0a5c3fd2d0","libgit2/include/git2/sys/remote.h":"f1f7b7d5cd5baf9caa5d048ef3d63ca5a4a30464e34226a64755863ccddf1134","libgit2/include/git2/sys/repository.h":"63a142623683376fe11f498685525ba33d3cd184708338f2461067b7aa5b92c1","libgit2/include/git2/sys/stream.h":"8555a6a2dc13ddf21cf4e3edc137d5a02cab23f0e73f9f6f7859768af25d11b1","libgit2/include/git2/sys/transport.h":"0e81dd2e8d16c2737b20b86f6bd2a53e8f7ff2840c599efb355013fb74e83d4d","libgit2/include/git2/tag.h":"799b7c0726c077e13a1e0a194d98d2605e59ad4800db956e92e7dfc938bf6353","libgit2/include/git2/trace.h":"f9aaff56cd6e6ea2dc5f7e221f198016f7d4a947829340a45c12714bf32f6738","libgit2/include/git2/transaction.h":"4c7969130a952134c597e84a06f38ca4b19e0b372df88085cb4f846292681c5b","libgit2/include/git2/transport.h":"7272a0f8cc321ac012a3fbb8cf4d1be0bc6d34fc266a09b72d604a30ad0a91c5","libgit2/include/git2/tree.h":"b33a83cce6b92d3e4197c1124394431ef2865d0a6978b2dff29fb8f4a9d93106","libgit2/include/git2/types.h":"3dcf1cba9c3724f6adca09a5147e5e9afbfbad873c579314e5a93db55199b3ed","libgit2/include/git2/version.h":"0efba27fa3c2cd9e1fb7304cc450c388c771553b7e616ebd7deff16ed7ccc459","libgit2/include/git2/worktree.h":"0f819ee1a2f74433cc54172c86aed43cbc6ca26c9c44794a8fd8c7fc5c5e316d","libgit2/package.json":"72e43b29bd85abef8782b7333cb40eafb19e66cdd69126c12131451a36f78768","libgit2/script/backport.sh":"6ef93a8c4a15ef74d2639638db3b24d20a76fc31faa53b1c34b07e3759c78fe6","libgit2/script/leaks.sh":"62532838555750cfdbff91709c40b1c1356e399238fc29379a45802922530a51","libgit2/script/release.py":"28a113a377422d7aebab4ce25c672f134ccb8a81cbbcece4d6af4354c44c4711","libgit2/script/sanitizers.supp":"8ac23fc907490c5ba1dd641f97201878e195c3bec0c1f224a9a4dda1fbd1f5b9","libgit2/script/thread-sanitizer.supp":"6497c98a2c0c83d867b0d88c36095a609731e7f6f4ad5a73dfe5287d6f2ba0d2","libgit2/script/user_model.c":"073e0b631f2d50af9c326dc009c626dfb9d31707d36bc61396ad9960160652bf","libgit2/script/user_nodefs.h":"4287333a6d7484a5a5796e6deadea53ec1ef587e4c571351e3fab61cf8badb45","libgit2/script/valgrind.sh":"13d1e34010c351992ac5950dbadf35928eaabfc9ba3acad336e7677fbda0946c","libgit2/script/valgrind.supp":"f959d829f41bd3cdf663a3ec0861ebf98f5c69b4b46005d754d748d7b90d1734","libgit2/src/CMakeLists.txt":"5112ff9c7f288a01fe0782a420f66eb71c7d1d378d0fe08d04b5d01dfbd4e3ad","libgit2/src/README.md":"acfbe0a4ed6cd7d806b30582cde06b871fe2b16f5a9eec3af717ff819030c6d3","libgit2/src/cli/CMakeLists.txt":"ffaeb4de3adc9dc9910e19ea600ad3509853862662e0223c30c9b4db2a4281f7","libgit2/src/cli/README.md":"84ea472e6be8c7e14558749a6b9207b8acf45ce78ce2278a525813d6c66c09d8","libgit2/src/cli/cli.h":"a2c8e0f0bfddc539edd3179f23604920ded78f725d753f891ceb029ba64b0a65","libgit2/src/cli/cmd.c":"fa7c4fa3d3178308dc47347c1c0d2c59c242173e01b35e9da1594b6b1a84821d","libgit2/src/cli/cmd.h":"353089987b6c3600eea464e1bec4a181f026bf2389f238bd4064609208ef7306","libgit2/src/cli/cmd_cat_file.c":"96b00ca5ad95464dcb1b82a3896c9c4d3d4a2b3f3cd0dfadffd4486745bca454","libgit2/src/cli/cmd_clone.c":"fb9a318c8dc424cc91e819652941a57d6094208c621e64a74defa8f407b76d6b","libgit2/src/cli/cmd_hash_object.c":"ee4548e9e02964ac3bde6e99d42a1b219f7d43c84fd6f41a4c5a3f6972754aa2","libgit2/src/cli/cmd_help.c":"11959d8d9bfe40db63254b576d4c40a6f89459e8a31b1a595fa64362a72db74c","libgit2/src/cli/error.h":"77ae9d6e6b273b433d6f926fc0fe3ead0a608e2d4ea3751a481b07d445cec254","libgit2/src/cli/main.c":"48c96ae62cf75078c95fab55c97a87119fc20ad30aacbcbf3a3f9e2acbec3655","libgit2/src/cli/opt.c":"87721cce2b835c16263f76063bd0c4b9ddea1714a5a2ec8198c8a69a485bc5cf","libgit2/src/cli/opt.h":"21e0fa46e11bc7ec8de209cafa30d944c5157da9187cb66990f81fe1a8975a76","libgit2/src/cli/opt_usage.c":"0eb8e704b234dd955ad33798e330c083a4a5114347040ba949235003b17a6f92","libgit2/src/cli/opt_usage.h":"a9234a8277001d8a0252b3e9b73c581bbfe64fb209eef565dd082beba81b3053","libgit2/src/cli/progress.c":"fc583205433555e1077264e179900b4c960c2d50af2569637794f9d25c5f6052","libgit2/src/cli/progress.h":"b1886426d2ce266c3da212bbb2a658df9c386c5e297b9e760464cf51081548bb","libgit2/src/cli/sighandler.h":"4ebd5db9e9368f8001bffd2e43f8cd7e2ba7428d0a56eea8255c1d1252c50d88","libgit2/src/cli/unix/sighandler.c":"53756df33d9012aa71887555c53bed6c33bb31a9f8b7412632729bd6744b9dc1","libgit2/src/cli/win32/precompiled.c":"4dff04101bd64b95c8f708d1accd1bedc39e95a263444290f796c63f4734d4cd","libgit2/src/cli/win32/precompiled.h":"7f9896201b1ed335a630010def126430d3c9f718c180b2c0ea0865e4d8611297","libgit2/src/cli/win32/sighandler.c":"bedb324d57b3ff2e6d6ba2a2a46b6f8e67a81186f3c729ea9f3b2771ec9b6450","libgit2/src/features.h.in":"abf55911a25604fcfdfb82755f3c16b82b16ed869688806d20ba4b9ae6589179","libgit2/src/libgit2/CMakeLists.txt":"a01f0f8e133e9d061fcc4dabafb7c4df6d5d1939fafb4406bc114ff35c441c43","libgit2/src/libgit2/annotated_commit.c":"224e3bbd567ca961522cafb78c717d29f1710f2d2bea5c40305674b58b56f73c","libgit2/src/libgit2/annotated_commit.h":"35168115c4d881a75fafa455f319be0c69277748e2e147c42f8a38bf7b5bafe5","libgit2/src/libgit2/apply.c":"e838bc8c4a33e86c855d3905c8fd500b9f82c5225ef8ae7bd5def24f106d3e30","libgit2/src/libgit2/apply.h":"4b3cccfd8030ab006fe78a89bd6ded5e1d89f7122630da6efa792c1a5b6874ae","libgit2/src/libgit2/attr.c":"cbeaadd990153f473ba27a2bf41a844fdae38bf6823635820f9594cc5adf0eb1","libgit2/src/libgit2/attr.h":"c940426d88f00d1510d2698897d5fd1b9270d91ec0c86a7df10b9d07f598171e","libgit2/src/libgit2/attr_file.c":"9cd04700d4d3acf1aa70c293d9236218065a75b000606ae0032de604b81a6e2d","libgit2/src/libgit2/attr_file.h":"575b181fdbc1d4d864753d0237ff7d718ea1258449bd8376db461eab73cff0e8","libgit2/src/libgit2/attrcache.c":"a937e202ed1ea666792640ca6e522cd76eb2b30ed4a6bd30cbaf5374addf50e9","libgit2/src/libgit2/attrcache.h":"a47b509e5862731889fd1bda172f6dd2e3f9dff50b7296d4e2cee86daf508769","libgit2/src/libgit2/blame.c":"7e6a4a9cfd1382da134121d3b7b7677257e2ccbc692fa75e212b3495c0aaecb4","libgit2/src/libgit2/blame.h":"5cd24ffc72a646e373d5d0b850aaa86316fd83b6fb886b0aacfe57ef4fd9b760","libgit2/src/libgit2/blame_git.c":"f2909b494c1a18891f74223ffd675c0e092b58f52722f5519aabf26f9de59fd4","libgit2/src/libgit2/blame_git.h":"9b813f16b93512d27d93648e53d1438d5b931024701273b5976c1da41868e286","libgit2/src/libgit2/blob.c":"4defb1f6e9c33613bf49da58b74420e550b5d6d6b454c607038c25434eac3013","libgit2/src/libgit2/blob.h":"66005f2fde1565530b0066238d750acda5ca30e1c45757af2ad2f00fb7c6486d","libgit2/src/libgit2/branch.c":"9af7a9d3c2d8d411b9c91c19405259d59d460f09bdce54f422f5491d0ee4c239","libgit2/src/libgit2/branch.h":"a7512fb6c578721a8d0c47a250fee9ddbbd08fa5c53460420d8158d39511e042","libgit2/src/libgit2/buf.c":"491511777e2c68cbbb6e350e469da80fd240286d71b953230e688b920474ae27","libgit2/src/libgit2/buf.h":"4ed1bd58f01790c6b8505b9ce3f1cca443e8952c64611a36516d9c5d1cb96ac2","libgit2/src/libgit2/cache.c":"46385411ee06769a97c6d3f72568fcc34f0873444b27c8c1ba0c1f3e1255730a","libgit2/src/libgit2/cache.h":"7fb0a0a0898367f1489b0430c35ccbca440cf7119c45382ec67adeff443f83ac","libgit2/src/libgit2/checkout.c":"ed05c756353a82b9c4562941332c3177bb143f706cb4ad1f53079c369975ee3b","libgit2/src/libgit2/checkout.h":"deeaae59fbd6f4cb3d6c5b67133df66832ad3e49bc9585b6ce9c5d0aa4aa6ef0","libgit2/src/libgit2/cherrypick.c":"1c927976f659dda37d633859e55e7fe99abdb25f9b544ee0edfb97a816ab929f","libgit2/src/libgit2/clone.c":"ad46e57c84f8a0caf694b3a055e5d13c5379afccb20e647692c1ba4dff37dbbf","libgit2/src/libgit2/clone.h":"1820fe915f31a5346b28cf06c29e60cf7fa5dea92d521ed2bf2aa51d0eec3c18","libgit2/src/libgit2/commit.c":"91fa77c9313939cdf614765f61121ca72ef3fe7ab71861b53d49c274dd534d14","libgit2/src/libgit2/commit.h":"a7b563356ef1bd9e5c899b00c9828d04b9ec9e5c26a48fe4ff22cf491e203e34","libgit2/src/libgit2/commit_graph.c":"3cd03e3b6fc4049f232ecd36d2492ed3c8d092ec71e167b088df64eed6427843","libgit2/src/libgit2/commit_graph.h":"60d2df35b849fdfe24f89ee030fee4892f7a965739a7c0cfdadb7ac6c4c33e5e","libgit2/src/libgit2/commit_list.c":"ba67a2f6a8e2fc5c139852a7ad0625c795c2d65df911722d8fc6c5807d4f5f47","libgit2/src/libgit2/commit_list.h":"0ca7bb97dd4d33c49420c9b7eb5689ee0b3ec01f39be08bcbbfacd695820e249","libgit2/src/libgit2/common.h":"6c3fb69d1dd0a3656b76dccbae2f2ae11d67675c3695cf0de4521daa422c28ae","libgit2/src/libgit2/config.c":"6bba3d8f6c3a67a2800f0e7e73edaed1b2f75947226641591126b3ccfde00506","libgit2/src/libgit2/config.h":"ac67c3fd05fd79041759ac0218b8d4a06d0ffd31ba8ed42787d27a9ae0540069","libgit2/src/libgit2/config_backend.h":"8a368a7b9235aca7a6fc70e6192b1dc9ca85c881faabb69ce612c011a53cdaa2","libgit2/src/libgit2/config_cache.c":"46fec2adc322b57a2a85a1963aa4702893228a3ba90c1a156e127552a0a1a854","libgit2/src/libgit2/config_entries.c":"a938c81fce685b07aab19a30ee163bd1cdbb8a019aefcf704d1a97373f5f8da8","libgit2/src/libgit2/config_entries.h":"932abf82f5103fef5c6e991a6e50effeb33cb6ce90eb1b15f6606d9f370feb66","libgit2/src/libgit2/config_file.c":"e7edc5820f93f70d7ee960e62c2a3f8cbb6042e46af6af4a3f07d82d810074af","libgit2/src/libgit2/config_mem.c":"026461ece09e83d78fb65e1d876484d10bee9a09618e9ac03240afed947f87ab","libgit2/src/libgit2/config_parse.c":"4da07c1ff3a0a7d5aa359d07ae7871704125f18282aafbce5c3ea184ee8f39a3","libgit2/src/libgit2/config_parse.h":"ed2e0138e13fc0115fba047c80687eb20778984bb2ee13c261ae69893e11e5a9","libgit2/src/libgit2/config_snapshot.c":"ff6771e940ebc78bfcdb12b7dac205629e8e88732b44b10a35962e3289cd660b","libgit2/src/libgit2/crlf.c":"2b5a392b269eb2af132f790a7764271dfd8523c47d18ac0f2d9fca1bd631363e","libgit2/src/libgit2/delta.c":"3e5d84b81f8fa3b752f75e0853a548ec3863ac3f1070bf99a9367bf6ae8ab87c","libgit2/src/libgit2/delta.h":"c757526292144083a0e96e7ab259080e83158e28c4819c4fa8bc2523aec12a59","libgit2/src/libgit2/describe.c":"fba715e551640e6c4441a735772291bcf0f0151ced78319a506bd85dd00d8ff8","libgit2/src/libgit2/diff.c":"ce9aaf62d359e5c0c4620a2bbe41d3e3b334c1a60e1a303cd8c0483a961e28d6","libgit2/src/libgit2/diff.h":"1bcfa1246864e2148235d0ce64ab7ec3973c5b9fd2a8a44dba05304c9c9cbdc4","libgit2/src/libgit2/diff_driver.c":"a6b463204405019d58171ff81761ebf7296f9710a3b7e95eb0f5e9e7c7aa7c10","libgit2/src/libgit2/diff_driver.h":"2dbce036b80a1855e8fcaa0065b8f4458cda13b9424d368b4ce82f4e49ec4065","libgit2/src/libgit2/diff_file.c":"c03629dc08af16f04768139ef9e6f603978afbefaada99b132b75e749a12a051","libgit2/src/libgit2/diff_file.h":"f19e2a17d089591596325cfede708846c8df05a711e349ff84394db4af560c1c","libgit2/src/libgit2/diff_generate.c":"dfa4a210da65fc51ace0f82a72918944a6bdcec8496654d60105f50861af5830","libgit2/src/libgit2/diff_generate.h":"a856792a6febd862984ac01bd41f998a848a60cd5d72b4c04a94099d3ffc5c6b","libgit2/src/libgit2/diff_parse.c":"107d11e188e054538c29275f6755bde45523a4f04bbdbf30fcfaf18c54a88a1c","libgit2/src/libgit2/diff_parse.h":"8902d9ba9102f10898c14d0a41a8d5823450527266908cbbb06e676309e23f56","libgit2/src/libgit2/diff_print.c":"44969c28b9ebe85d5b5fb62da13e902ba6cc94a7db05a949bb1cd6020936a8a6","libgit2/src/libgit2/diff_stats.c":"63e5e55d9f59992927409b3fafbb2c203a4098e84b0b747617e1a53a327384ba","libgit2/src/libgit2/diff_stats.h":"4ce359d523ffa03df7c0592ec0b905dd693054b44f62c4d1a91af464ace119dd","libgit2/src/libgit2/diff_tform.c":"c2726291d202536cf120ea813e1847b1e8ef4cc8d39254b19c1665ad5a13b1f6","libgit2/src/libgit2/diff_tform.h":"a4a7433036cefffaa9d968ff45244afb4957313cd9c28980cc102f172f9eaf5a","libgit2/src/libgit2/diff_xdiff.c":"6980509ccc58b82b36c0ea42e319c402a19002bbe59c2c4ad5e7accec4cfec44","libgit2/src/libgit2/diff_xdiff.h":"f027a95aadb84a42fcc349b082ad50c0b6ce3a3c439fbdf90ffbb04f48968e81","libgit2/src/libgit2/email.c":"8d90259a3a187f830071b2b3d821ee1f4f64cdf0442fa26860f6ef1bdf818a98","libgit2/src/libgit2/email.h":"6b4a9dfb85b367e3423c2967f9cc257cf498fb9dd973c4400cea2be183065d2b","libgit2/src/libgit2/errors.c":"e4681de7db0a749d0dbd55b9f9b036b9a54cf365c78201c6bc6fe86634c5582e","libgit2/src/libgit2/errors.h":"c015656a92132544b81c95e21ed61eaaa06d9df8aa73d8a97591ed4e145727a9","libgit2/src/libgit2/fetch.c":"5e388a8c20dd03c337508037eb05ae21f383dfc0c45836cbedcb7474570ce2ab","libgit2/src/libgit2/fetch.h":"ebf610f3a62e107bf4f768fcb45a4cfe09d990380d8f0abcd48f258463925fc9","libgit2/src/libgit2/fetchhead.c":"0dd49b49766f2fbc057789dc7c374893f9ad07c5133eb35bcbb0c5f395d11620","libgit2/src/libgit2/fetchhead.h":"65681769629f670afcf739d582bb7ae90f702f0c6085de3f26b79fb3293d1dc7","libgit2/src/libgit2/filter.c":"dbed23ec686ed7853e542600852f905c51459f3e73e727ce2d1aadefc3deb869","libgit2/src/libgit2/filter.h":"b716cb38e4af7b9adca4e9b1538eb546ebf15f279906561fa8fa504bcc62ed24","libgit2/src/libgit2/git2.rc":"da3c8f58e8b133c52ce5184dfd9afa88801ec3e09ed76f2547a7851a25d3199d","libgit2/src/libgit2/graph.c":"babca47e94066357799c0ab823c9b3e454187202f7ab14068a6cf0fba28bdf41","libgit2/src/libgit2/hashsig.c":"fbe29bf41024a9bf9b556756a23bea451d1ca2aced680fe666d24b651a719a7a","libgit2/src/libgit2/ident.c":"9020d8910537d68cf92fdb21444ba09da950d66811482e72c7854d58633c22ba","libgit2/src/libgit2/idxmap.c":"015ba3e2f290fd817152f034208a55aa94b8ebd29fc8c80b3d053847d66de605","libgit2/src/libgit2/idxmap.h":"162a477b8faa3d37e83fd413bd53f6ba2801c1cf64a03c29513601058a6ed40b","libgit2/src/libgit2/ignore.c":"8b6bb768489a655f32f9f7543f83f2c951d6ca533236b2b33d7f7489c18fde75","libgit2/src/libgit2/ignore.h":"131aa84f9e474111db0f03797969e99493e67ef287cf8801606a889765e96ece","libgit2/src/libgit2/index.c":"42b108eb8c9cbfb17e6838387691f29192a82d54701fcff625aa4497ff168d93","libgit2/src/libgit2/index.h":"6c0f06f05bd26f6e41b317507b29ced630862e90a4f78c336286e9e81271d339","libgit2/src/libgit2/indexer.c":"ba01e3cf6305a2b42c6f33e5ee5bc308a4f9401397e0f7bbf9c5ec3a0aa60a97","libgit2/src/libgit2/indexer.h":"bd32fd65a3a7c6014e3e9846477b060033102c8c7baeb097506074f99c50a434","libgit2/src/libgit2/iterator.c":"4aa30c1c0ebfa0cc68d67e86e7bfe9de159089f5afd106fb587fd6034572aa0b","libgit2/src/libgit2/iterator.h":"6c68f151885f425c000831eac8de59aa5ef6ee9d12721ec3f56e179ef2a207cd","libgit2/src/libgit2/libgit2.c":"b0ebe594d7e63931b0097ead1ff1e72dda94c0ac308da0bfed37eca72406f3b5","libgit2/src/libgit2/libgit2.h":"4cc280df2f469e2c0dfedef5f895e95ff0b4eda3710b93fc10c9b0cc97f1207c","libgit2/src/libgit2/mailmap.c":"dabeb5e9520c2338e3a7496f3e3b8f593b6a422d4d083fb17ab8d33cd575cc14","libgit2/src/libgit2/mailmap.h":"edd8723b4c861c855708f2d7f9ed5e37cbb7523534349b0f69258a3557b93b36","libgit2/src/libgit2/merge.c":"a0e2e401609031fdc5ce3bc2ca663a15f9452a0179fc74cbf5d344a6a982092c","libgit2/src/libgit2/merge.h":"ee2d6ebc3328e33115a69f60f0323be4fcf7a586a6308d76b5d6b6451a2e06dc","libgit2/src/libgit2/merge_driver.c":"e9696fa44bdc4250c5bf5bacdbe51e9414ec38e7b1b8c9b8d4ef3c6a9f140318","libgit2/src/libgit2/merge_driver.h":"4f56c2965330a5cb08b9f26d6b83dc4e15fced9419540d2d793f2e75049bc121","libgit2/src/libgit2/merge_file.c":"06c669e98a0d6914b9171fc9ca1255dd05261d88fa3e637aecf8254c9627d7c7","libgit2/src/libgit2/message.c":"12b4d518b4f77b20d76e6b7062f56ddc7a7a666ee97f7f33909c9010ca3b5b0f","libgit2/src/libgit2/midx.c":"d82b692d463805ef3c018f298b812a1cce47dfbf4a200ac1bd0d9b01b9265217","libgit2/src/libgit2/midx.h":"9efbe994a15f4e495f0576bfbe6790e4677fa3587d94ed18cec5b6c9fbeeeaa7","libgit2/src/libgit2/mwindow.c":"8b62175ca5166d70cab2478a1fcd4a38c3e9e0c2e3e0cf16eff165f5ecb85319","libgit2/src/libgit2/mwindow.h":"e53463199e93747ebb5e84a404d05c18349a2af83ef5eba99528dc1e915eec25","libgit2/src/libgit2/netops.c":"823653e7ff3d0384b16c18bf5a531ab9478881f1c589633828e40da9022f399f","libgit2/src/libgit2/netops.h":"cab7bfe8d352f139f8058aac3b253963d7102decc86ab0eaa7691adfc4c7fda5","libgit2/src/libgit2/notes.c":"284c9bb2a694a1ac92af8b2c3bdab8fe5d0a4e309b50114774cdfbb0bd5a2d3a","libgit2/src/libgit2/notes.h":"650f92bbf875ab194b9e1d041f06fb8332bf5f402ea49cde528a81d2eac05694","libgit2/src/libgit2/object.c":"109929dca68cc87c99c290e61e23eced6e74fc8b35972f94d0df0140153aa522","libgit2/src/libgit2/object.h":"83bc66c16836d8a2311909e70b3cb8f5b8f0aca53b720129072068c1fec2e841","libgit2/src/libgit2/object_api.c":"ac963762a903ea36adb20f0d4317388159c23828a6e26e9a1b1333b7a9fa1317","libgit2/src/libgit2/odb.c":"48aadddcb42ee41fc0261feb71d190db1fa1bfab47a43c2f5d1e863fef87657c","libgit2/src/libgit2/odb.h":"e36684bea9a513946602f094636f74f6abbf187c671396a2191b94f633df90d2","libgit2/src/libgit2/odb_loose.c":"1af7f19df25b5df946741d250fb4412302ddf5156305077cc350c9ecfcba101e","libgit2/src/libgit2/odb_mempack.c":"86fb977ad58c48f7394728d7396b7e050482b35edfc87cf0a487284aa91abeda","libgit2/src/libgit2/odb_pack.c":"56b831375827947582e915342fd7f9cc5030ec738af4eec26a07f058c8457324","libgit2/src/libgit2/offmap.c":"0185030081a9d7df6ca8abea2e0b2c367278172ccd5ca5eb3601555a3ac1f665","libgit2/src/libgit2/offmap.h":"e902482f4727d30f786f48fbc143d7324ace0fa60877212f7ab3e982b0d46318","libgit2/src/libgit2/oid.c":"28c92cb7b5d81ada73c28c0d8f91134b6c4791f92b8a0de1500006b8db46e447","libgit2/src/libgit2/oid.h":"da5466006a80361e046d0f6731a31cd78f4fd76ee62c38a974c7b48e2c462f28","libgit2/src/libgit2/oidarray.c":"5919ea8d7a0138d9a4323a650c2ef9f2cd52da5d6c8922ce307a6ac6fa131a8d","libgit2/src/libgit2/oidarray.h":"17a745a4d1f2c464b91080279fb4a3163bb39456be5c7e9d6c8195724cc3cba4","libgit2/src/libgit2/oidmap.c":"5a1b7b02e7210bf8f439cd606200cea373a8d7e000f90aa3b6f6bbce5298f05f","libgit2/src/libgit2/oidmap.h":"7aff6a1568632f38f2acea1a526e11e24b42fffa7b05b75ac53ce18b9dd70e42","libgit2/src/libgit2/pack-objects.c":"483dace387cc5f9b0dd859444501eeb6164fd9e51b1d354843f0b385bd1ff303","libgit2/src/libgit2/pack-objects.h":"8ddb878f2ed2a45d298791622fe067fa0418414b8d2367f910f7abf71293a987","libgit2/src/libgit2/pack.c":"bedb3bd2094f4ebdbf6437435c7bb5befbca54171301743a188edb3f120d99a0","libgit2/src/libgit2/pack.h":"7991779473e017b205cc00c5fb8e0337ca0fe61418ca6397619e28878dbf5443","libgit2/src/libgit2/parse.c":"34410522f13568a6d061ed723ddd7049f21d1f054e530bd5d3c262a1105e1f74","libgit2/src/libgit2/parse.h":"d5f25a7d63d004bd3abe86255b2877f5c6415939338202c32fc78e218c9554fc","libgit2/src/libgit2/patch.c":"48eceeb2b8fd25f24f830f7abda25853f4ede673b38698b671a9aac8d84562ad","libgit2/src/libgit2/patch.h":"b9cd6f2a68b709db55767d92a9b8abe34534273645eb04cad4bc581c59723bf9","libgit2/src/libgit2/patch_generate.c":"f3ae83337cc9c6c9864f98a20842c548785c9bad300443026216c05a038b18fb","libgit2/src/libgit2/patch_generate.h":"c83a9d70e860b13940f70140199ee40e8cad310350a764e726672ed7133e2999","libgit2/src/libgit2/patch_parse.c":"ab526ab3e7add847a81d2e4517542188577f5e78d5329035479ccd43f464b389","libgit2/src/libgit2/patch_parse.h":"6883a184830f4c59427177eba5462d27737706a1be899db35423c5ad9d6c8c4a","libgit2/src/libgit2/path.c":"fd0059630dfa0b3b9b5654be35ac3b32f01cb4858971e1c0f246a65f378cfefb","libgit2/src/libgit2/path.h":"e5a2b8a9f717ebeafde09b3fb0330eac85c9d52213f334fedebaffefbe3575cb","libgit2/src/libgit2/pathspec.c":"e85ed481b15f0a1aba9f3c7e39f07be490cf2e32668dea10f93651eb12214e59","libgit2/src/libgit2/pathspec.h":"ab2ba851d4cd815aa25a910b792102230224ef7bb079879277d77f2984fe64cd","libgit2/src/libgit2/proxy.c":"2e979107904bc593f4d0a4a911a20efbf0956ab3441e21b10eff8661c8c7fc2a","libgit2/src/libgit2/proxy.h":"3758a64bea3691eb59a3c4d0bc70f7e1660b2a7f52e33513b03e9d7dc02bb617","libgit2/src/libgit2/push.c":"b0214f658bd2286aee34737ad32f313a32713b6cff01b2a7cf8229ec499d9ee3","libgit2/src/libgit2/push.h":"27762e4476e33c18c75bcc83051cbb26a67b8ea51407655c668c946daad46c79","libgit2/src/libgit2/reader.c":"01eba0311e0a63cbfbed7ebeed0dc16f648f9ced12b1c20522798761e3a77820","libgit2/src/libgit2/reader.h":"de0410d529d888feb13a8db4221e4d73f3575e3c815e6bb4ab9a4caf4d822e32","libgit2/src/libgit2/rebase.c":"dcb443109450016e7defac86ee9c4fc85eda0b99b2464190abb365f18473856a","libgit2/src/libgit2/refdb.c":"40cd4c55b0d0296bfa674541fb16936cb7c5a785be9afdbfca5e96b54adb7424","libgit2/src/libgit2/refdb.h":"ad8127049a89e43f49ffed64e82ee343e7c8acee31f7cb900b555193667cb99a","libgit2/src/libgit2/refdb_fs.c":"fc65dcca92d03f3793f1632fbdfad220f77871c33ade9e2cf0f25591a0071c92","libgit2/src/libgit2/reflog.c":"becf9c66068585bd1e93a1328db2529199a322cc212d60b6738183495f326327","libgit2/src/libgit2/reflog.h":"898ae0bf378c465673fef1a4221baa2cf6165a0700949952971f743ca73075da","libgit2/src/libgit2/refs.c":"82ac0ac10192ce29bde73b1abbd92dd716411ea424858a5fb92bcdc6ace82556","libgit2/src/libgit2/refs.h":"797e1177fe2a60c564b85c51d513e01df7d089c3a1d536e9a075a6eea3bdc3b7","libgit2/src/libgit2/refspec.c":"fb3f521b55c4be10e5459935918331ec6162de05bbf63ea336ac630017d2b7c3","libgit2/src/libgit2/refspec.h":"f521436fe4a8ca3600c54d77aa19a8a1926205e44b71c9e9f2fadfccc0f087dd","libgit2/src/libgit2/remote.c":"b21e5947ea7e51cc95dcff6d6e78a9f7259731b4f90e8af295d291c0b33df7aa","libgit2/src/libgit2/remote.h":"8821997f9c08e63a6841ddf90dcde7548096e326cb6c033aea59f2d10d66d5ca","libgit2/src/libgit2/repo_template.h":"bec227c595d193802723f81765487da76beaffafae40ec05b76a4db7de153c01","libgit2/src/libgit2/repository.c":"cba66fac67f156e81420c25f90555e2b0d5af7f0c1d8932bddcc6aa284897daf","libgit2/src/libgit2/repository.h":"b41514073138be704322d4ac8e96c87c0bf027cbebbb53cf4a148cdb19690211","libgit2/src/libgit2/reset.c":"9a9b3119fd1d649737487a882a3a1a6125a8b6b3aa444cf929ad2537056a3e2b","libgit2/src/libgit2/revert.c":"e45d6d14503600819f165dfeb4f4da277fade33d84a7600986525c38e4767cc2","libgit2/src/libgit2/revparse.c":"a9dd33510a2a604977600dfa9b6aac55edf942cd164a231d81dad8386fd510b3","libgit2/src/libgit2/revwalk.c":"484df7732114c705e2f355cf7d290ff2f4fa8831e4d05bb8f39ec7a5d698df1f","libgit2/src/libgit2/revwalk.h":"d341454f2b0f22e69f1c890fb9f3a2d8ef327797dc8f1dab5cb2b2734b57bebb","libgit2/src/libgit2/settings.h":"9addfd18452820405a0309f944f01bfb63b6918f740f8dd6e6e4f889cac51537","libgit2/src/libgit2/signature.c":"6ba02d287ab9acd93ff0fcf20bb803582e9a1da7c56202a45419de696983d75d","libgit2/src/libgit2/signature.h":"86819d4aa21214e2d28994cc0e8d3ac532980ad30ada61ab1666dec563f0483f","libgit2/src/libgit2/stash.c":"4baa85565c9af0ca7730ffc7f9072b1571a94c62407f21adc2290381760cff84","libgit2/src/libgit2/status.c":"231e6091e44e7da6168de1b65acb6c7e6a0aa57b5cd735beb2864d5cac8992bc","libgit2/src/libgit2/status.h":"68ed612f65430563ad5b3f50973b360f583c5865e54c9b9298eb082d441c4e79","libgit2/src/libgit2/strarray.c":"8beb44371f7dfdbe492fdc6bece0569c0732f11664aa735b6842df990ed2ed3e","libgit2/src/libgit2/stream.h":"a7755d211e19ea4a29d7d6151f71efd92bb92906d1668960e076ced663961784","libgit2/src/libgit2/streams/mbedtls.c":"f32d185df1933756fb8ba3ad3e7b454c38d28005521d634a45a7f56ca9d16df7","libgit2/src/libgit2/streams/mbedtls.h":"4aab96dac336790b4b172a7f355eb3fa6db35d31765edfa6524c581c10896ec3","libgit2/src/libgit2/streams/openssl.c":"a119df581f475c3a31e89ff6a3685818c973e5ecdde2dd7373caa8d3edc71c29","libgit2/src/libgit2/streams/openssl.h":"693e5d00ba86f206170630f3a23771cec7824017b26d6c6436620b6812a03833","libgit2/src/libgit2/streams/openssl_dynamic.c":"938d853510017e1fbe84322359c5b65b8cd2737bd3fe6bfd0cde85ea2b17d29e","libgit2/src/libgit2/streams/openssl_dynamic.h":"59ffb105d875ba2da6e4a5e1ad32780773323ff4477322c8a0562f6ca38d0a60","libgit2/src/libgit2/streams/openssl_legacy.c":"1c0643b0ea8cdd9d2f37dda38d777dc6aa6d3af8c631671f413da53b62470066","libgit2/src/libgit2/streams/openssl_legacy.h":"5a0f3da348dd5fb0cf4ddf7b9f65234bb5cf7017dfb084e5aad48e8d33d818a3","libgit2/src/libgit2/streams/registry.c":"079e2c8807d0cab10ab4363599e8a82e31042ba5ba2802cb52cdca0afad8222c","libgit2/src/libgit2/streams/registry.h":"42a887dd1fff029efa00a04a4e8716905149d3639a6881dc53254170cb8e18be","libgit2/src/libgit2/streams/socket.c":"7505512da233f7a37b2fbb9c7c5b1afd7fd41db6bef7542a2d2c6c9773f59951","libgit2/src/libgit2/streams/socket.h":"6ed5745f368fb167f24b8a733be0c2272f5bceb9fc40b5c550463428533c26f9","libgit2/src/libgit2/streams/stransport.c":"99085a58bd8a2f1cd5e37896a45b27268b7fe4a26fc137d98f5e16c7866def92","libgit2/src/libgit2/streams/stransport.h":"01c4555417713c415de10ea16222d44cd9c0c0db4ad5d7e3d5e9863d62f49eb4","libgit2/src/libgit2/streams/tls.c":"807146d607993810ad1b09362605596c067043aa78f7f062c5e92eb3b20789c8","libgit2/src/libgit2/streams/tls.h":"c989f0a996ba7a11f8732336da77266905ebbc371e5e5969955d096ae16b64ad","libgit2/src/libgit2/submodule.c":"aa3e51ce9cf7cfb7b5373948e37f92b4987b193a699644ae4ca1e249bb3ad8b3","libgit2/src/libgit2/submodule.h":"f5826a643562cc3f73ea13a7973d8f57d294c8003242f43f67ab863eb43fdc5a","libgit2/src/libgit2/sysdir.c":"6357092878a3454975c977ca536ac9e9bdc8e44aca955d43c0dea83d2e5190a5","libgit2/src/libgit2/sysdir.h":"8ddf427969d0ecec9d145e9f6d0b39a98400c31c1935ab2fe1e2a84561253f38","libgit2/src/libgit2/tag.c":"0fe6ddc24fa7b2a18fd13a186e85d2e3312d58baa5e088c72948ffb720e2be8a","libgit2/src/libgit2/tag.h":"e14485eafab3d4925bb6652158fb2f6abd211dbefe0655607a561b8bc6826ba9","libgit2/src/libgit2/threadstate.c":"f23c1ee9a2b4e175422950f713352be10049b4247641934ae00221726b341e31","libgit2/src/libgit2/threadstate.h":"e38212ab47493708e980cad9b035ad02fe3a648ea38a6bf23a460973b6cedb6f","libgit2/src/libgit2/trace.c":"f2e5041c5e688cf4e2c8ccc024ffa6a9c06b894cacfd1f967edfb5e11b513ce5","libgit2/src/libgit2/trace.h":"dc582e64181bbd55683b5afa6b400c9729a8daff22571c0ace7a3aada3b179bf","libgit2/src/libgit2/trailer.c":"b8c0cb9027532756b62c1ad6c6e96fbf7f4ef28db81d155efefa9f153458972c","libgit2/src/libgit2/transaction.c":"59f645e009b5c1a6919eb668b87215f422d7eaf9d9ae3b7ef27bf4f4a9adc3f8","libgit2/src/libgit2/transaction.h":"42e4b38d1fc7a8d57513da8230fff2f11ea4e1c2907130f99d77fdd2f099fc62","libgit2/src/libgit2/transport.c":"e366ada763261020d6293429fe0682e3df6130c98080c13659c4f5c100c4c79c","libgit2/src/libgit2/transports/auth.c":"e208690ebdec130e9737530a57835df13f5344906fbd9391aed1f665d3821458","libgit2/src/libgit2/transports/auth.h":"9354c6353908bf08a7720a1703958bf21c07556b862cea9f20d6dc94cbbe8bac","libgit2/src/libgit2/transports/auth_negotiate.c":"010ad1e83e06a6c5c9e3bdec10729038ed6adacf2c195f74baaec9bd2123659f","libgit2/src/libgit2/transports/auth_negotiate.h":"1125aec36ee74214a6a159027f6babd4299dbbc31d663202656cd12b6e83a245","libgit2/src/libgit2/transports/auth_ntlm.c":"35eaedb71b0636a996e776672fe2043a763e55b6340f63b67b1a67cb5171a526","libgit2/src/libgit2/transports/auth_ntlm.h":"66fe35444b362c6b74b07f0c01c36d00d86bf02d69526f5cdcec32d3ebe7b851","libgit2/src/libgit2/transports/credential.c":"058451ea233e7cf2d65f00b281a28caab16a84c9c83306e0ddc41479e7f93339","libgit2/src/libgit2/transports/credential_helpers.c":"e6ce81166b05d5f66c74c24086ec2025758ced7d8b85b041e190c2dab57e181b","libgit2/src/libgit2/transports/git.c":"fae194a7cfe1dae190de25d8438b9ef65e612ce0976bd2b7d651a1995094df8a","libgit2/src/libgit2/transports/http.c":"f3cff303f2e304abfc664afb2e15447202550fff723786d685024b47561ea8f4","libgit2/src/libgit2/transports/http.h":"2fb37a3a595652846d539c9a2378fefd452d3437a067721c37965557ccf42f27","libgit2/src/libgit2/transports/httpclient.c":"8c149c5c953e493314e13c57ee1255ef39a3b1beb4b2db2cb2b76f9605a18cfb","libgit2/src/libgit2/transports/httpclient.h":"58815a04492f73224f3bfc72b370c059279e76de1ffe0ac8829c12fe96f3f942","libgit2/src/libgit2/transports/local.c":"44c4271c35dd579a3beb158ac974a928e9e8a045d144be255a3f191b28f4e783","libgit2/src/libgit2/transports/smart.c":"b1b93ff7ce61b2fd5dd84dbb5ea72df2f09e73ac12ffef69c64c01da5ddf759c","libgit2/src/libgit2/transports/smart.h":"3bec37f6629184a8530654019edc37c77180f6226d09a8670cd1d044c3c518f5","libgit2/src/libgit2/transports/smart_pkt.c":"e505074f4aa13c098c45cb3051745d899dc7f8ea6c1270f793abbb027fc72fe1","libgit2/src/libgit2/transports/smart_protocol.c":"d64c3c698d50dfa9bc8814451ec50afc7d896527d90eb5a59a67024fb704f9ec","libgit2/src/libgit2/transports/ssh.c":"6db971df6caa46ac507d971ca3a351313e052ff7da6b0d0f8cb5dd90fcb00042","libgit2/src/libgit2/transports/ssh.h":"a4f6279848362d54f6ba4e9338443d6a3402c1ddb9eb85e2e3befb937cbea2ff","libgit2/src/libgit2/transports/winhttp.c":"64abbb5f4ae00f401870dd241ffa6c363166bd2b5fcde9264f38ac04c92ece49","libgit2/src/libgit2/tree-cache.c":"aa64a4c249d1701987a17aee6d9d060653f525dfef700bdbc2e779bcbf560a12","libgit2/src/libgit2/tree-cache.h":"f7ee6183b671c2ee185ca0680fa77cac32867f86f1915a63705a9c20dae57a6e","libgit2/src/libgit2/tree.c":"e4f31427c5d653aa3638b25fb778d10412dd9648b1eb893039f3962de9cc706c","libgit2/src/libgit2/tree.h":"af4f88a505dc5701073c3c41d43aa4826a49c8b63668d85a8a723b3fc82233a1","libgit2/src/libgit2/userdiff.h":"f623acbe67ce809a21541d0d665536f68df9e0ed8a4aa4556cbffd070960fc88","libgit2/src/libgit2/worktree.c":"527883a148ea7faf3353d226aba28a8d641784fda4bac570187a67457e56ccc2","libgit2/src/libgit2/worktree.h":"6962d0da3dc1ff1e967672fcbe84b8b09807924521e5d113df811ebee8e02664","libgit2/src/libgit2/xdiff/git-xdiff.h":"2d6c730b03adb9323f3bb7d25d005627542a821a71cc003e27bef57db0c0ea23","libgit2/src/libgit2/xdiff/xdiff.h":"6459a65d5e0f910f6bdcba30cd5332a58fbb75118acb5757f5596bd22c00a6cb","libgit2/src/libgit2/xdiff/xdiffi.c":"968d02087e76c5150edb850e6c454e2b98f9d315dd42eb971d58b2e5c512d741","libgit2/src/libgit2/xdiff/xdiffi.h":"3429a12de1a8c990005268801706fc2ced0f935813e12493c2dee68ba28dc94e","libgit2/src/libgit2/xdiff/xemit.c":"a08ac82b249fc1f000ca80e62a1207c1a2b9f76adc12675d48952bdb6ae734dd","libgit2/src/libgit2/xdiff/xemit.h":"0a8c569eec74bb4d6e8b7b9a50b457532550800e0566cbba6d185974613a2e6c","libgit2/src/libgit2/xdiff/xhistogram.c":"82adc783115873b48a4421e602aaef15c62ffdae828fd24f5214de4ee500a979","libgit2/src/libgit2/xdiff/xinclude.h":"cd17076d3909d1750044114719daa2acc0ee4b53afd9c2f3864cdba453f5f0fa","libgit2/src/libgit2/xdiff/xmacros.h":"d9cc54bfc6c0f9e6eef68f9d03594a8bd10f6243a2137776527bb5c849cc9de2","libgit2/src/libgit2/xdiff/xmerge.c":"c4a500ef89a3778bdfdeb70374534d6c1165a6c01b08d4b84df2de6d2fa98f38","libgit2/src/libgit2/xdiff/xpatience.c":"c0894cf798000a170efc1f6c5ba37e1cf1ffc650d4671c4643b34d99e4161842","libgit2/src/libgit2/xdiff/xprepare.c":"3fcdbb73bb8c605c4ec4fe353ae7abfb486a916dcff72ebe50dbe6ddd064f206","libgit2/src/libgit2/xdiff/xprepare.h":"4945e8fffe620cd4d687c12618d1a4b2aa95a7a8097abf3e5e341abf96c76e1b","libgit2/src/libgit2/xdiff/xtypes.h":"3336d046bf60e0dc99f3686dfe9ecf098456f0aebe96486be5d1cd64b5d9cefa","libgit2/src/libgit2/xdiff/xutils.c":"fb22cb13666372f2ede07a8d5558fb1d2908caebeb1c50579de5b35ce5880718","libgit2/src/libgit2/xdiff/xutils.h":"78e2813f0d604d4deaf29583f6709111d8368b4bbd71cfdc55d56769570abe3e","libgit2/src/util/CMakeLists.txt":"d827b6f3a8b73bfd75f84186cb2d232e2bde998210b80a0f2368c5ef46e5dc96","libgit2/src/util/alloc.c":"a203aa1aa433888642043576c031fdd01b230405d143511123dc8ef4b831356e","libgit2/src/util/alloc.h":"0897973a8dd43caeedf3806771930d163db62554af8efc61b1c536e7daeb4052","libgit2/src/util/allocators/failalloc.c":"60b00ca09e75ca103e15bff16533a46fece76962c9a5e2c0ebc5f18918240474","libgit2/src/util/allocators/failalloc.h":"b00b8786fb9954e3c65ddc99952efd8a09e0ef7598ae437e4f6d2a81fb56212d","libgit2/src/util/allocators/stdalloc.c":"e100fa204d60a0977c0334207aa8bf77d7787525a6bf2ed097138cbcd62d7605","libgit2/src/util/allocators/stdalloc.h":"e140c3b240622f36d7eeea232dd41711fa2c01e8b557a9d3393a5c2b416a5891","libgit2/src/util/allocators/win32_leakcheck.c":"e9817c98d0dfdf97846a24f9c0d5d25a038f26507ac2ca21b887fef3bc193f31","libgit2/src/util/allocators/win32_leakcheck.h":"1de31b13678ea2dcdae5177f5cb1b7d2d7560ff4069b8f77f07501bec4979913","libgit2/src/util/array.h":"fe58b44e15cc1c2cdcae9f1224ab17b02bedf049c2eb8af3e0ea5651f6eba8ab","libgit2/src/util/assert_safe.h":"0f2b8fa61e0dedbedbc6299618b98bc2c60dd78c386f2b9b8f7b8d747a2daf78","libgit2/src/util/bitvec.h":"281444c865be87104cff9c1b3998877a67bfd92af4b0e5b9b034fd48f6569f7a","libgit2/src/util/cc-compat.h":"555be819b4eb610bc2bf0a22c232efb90bf849c260fb6bbe1ae498f689e261f2","libgit2/src/util/date.c":"bbb6860f1c6c4c991707b0139b5cd52ac35e0bd34f6e224630fd1b6b4c895ba5","libgit2/src/util/date.h":"d24c6276fb168a0b7e9ed05ebcbb4a3ea8174588f348edb1be6ca09b8f6be2e3","libgit2/src/util/filebuf.c":"91181dc3a7a9091f6fceee639b815c2569403237f059bda88f5356f66a705485","libgit2/src/util/filebuf.h":"29e76e8f558651945448013c9d417928089470798004066316183f2505ca7355","libgit2/src/util/fs_path.c":"ef2f864a628cd8176cccc914534091aa2ece98fb098a5186ddc9cebd0b543dda","libgit2/src/util/fs_path.h":"07f44558b1c325254e1d672b15a5f705ea13d08d93f1afdd2dc2428664d897c0","libgit2/src/util/futils.c":"714a533efc8e90adceae1b8863587ca92b54aa5df8fa4af36d2848b3e1a6ae19","libgit2/src/util/futils.h":"99decafe797c40e591e45974c7a13751ee6ea45bdd9eb7d6b6be1fc10d33cfe5","libgit2/src/util/git2_util.h":"e993e8fc64bcfae846c348f47f66e62286e017a6ddc024faeb9b3ad88e44925c","libgit2/src/util/hash.c":"0c88b789d33f29229471a9dfba3da0a989214a08a8ea727582d81e7118c561ea","libgit2/src/util/hash.h":"da6504b76554f493c40ee3043f012bfd1d300c2a0de7d063f845bb0687e10079","libgit2/src/util/hash/builtin.c":"fe213c6a61b923cbd3acd6e55322f4d60c531617f3b9d5d281d2050c6e0a9524","libgit2/src/util/hash/builtin.h":"bbf1ce668c7d38412a5c7351b41da31352f5eba696ed453daaf442e97c225f00","libgit2/src/util/hash/collisiondetect.c":"50be16f2b8736ca61bbe657751a0e66b847affd6030a582f3366c27659e5d245","libgit2/src/util/hash/collisiondetect.h":"21d7b15068a89ed1537a6cdb5d1a3b78e5bb3bba318839579f9b20aa796518b6","libgit2/src/util/hash/common_crypto.c":"241d19fef0e60f08189405bb8ef3426438505bea0752ac57f10db06be6dc8dcb","libgit2/src/util/hash/common_crypto.h":"5b89841130c9d4b09cf90ff25874cec68d18df3f4883ad74b15c408bbaf77b9f","libgit2/src/util/hash/mbedtls.c":"97b33e8b549e9b1da4ae558db570679feed0f91e504b339e4be697084c721343","libgit2/src/util/hash/mbedtls.h":"42dc9f2db495d9440f0ec5dcca33b28395be7bce55d2560c33cc3a4c474623cc","libgit2/src/util/hash/openssl.c":"9ec342a094dbe414d596f708d8f9c86d63cd0702d3ff2e6b1e64afba8a0b444c","libgit2/src/util/hash/openssl.h":"38fe3d56238d70cba097d772f8f2ca14d403bb4f3666c5b217c5e1ee798a7fb6","libgit2/src/util/hash/rfc6234/sha.h":"aa3e10fb530d998eee40ed47db69775341c93a045c7317f2f5542be87b3f387c","libgit2/src/util/hash/rfc6234/sha224-256.c":"b01cf69e8bdb01a83465ec0d6551633d97c96307406d1595887aeea3f5512136","libgit2/src/util/hash/sha.h":"5f17d7991fdd745662601cc6d08482ad9a0ab1337ad6ffd535564898cd2b31ac","libgit2/src/util/hash/sha1dc/sha1.c":"fa40cc0830d58d340eb8942499181de72fd4cb4ad4c1d1216755b0367499661a","libgit2/src/util/hash/sha1dc/sha1.h":"78f97f092c20329d1fa8d9a8cbb3d53bb90be19cbc49f1917605a9ddf520de83","libgit2/src/util/hash/sha1dc/ubc_check.c":"7b0db83569ba82965dc0d16e51e9ad85167cdfdab343f9a02c2c475bfdd93956","libgit2/src/util/hash/sha1dc/ubc_check.h":"4a140693701da167b4709c4c1b330800a0c29f2a065d0d819567a27b3171a09f","libgit2/src/util/hash/win32.c":"fed73763276bc187e2f109eb4aff19653e5fc4fb092066a3be8fd02c9e3cb77b","libgit2/src/util/hash/win32.h":"43b90e70705dcfc28cd19b1ca2ef206a364db60af390d3dd73a8ec13d2a79e69","libgit2/src/util/integer.h":"2581341c6fbc03f9403e6184a40b0aa6d67d8dc1b127e1f4e003edc867e21226","libgit2/src/util/khash.h":"ea517b2c76adbe4480f2fb0dd4d7498adaee0ada831be1607ad9dc322bfce42b","libgit2/src/util/map.h":"f678e1aab0799a95a2152aa6cf6ef6b306eb783ba2a6b2b0e3df147e5596a917","libgit2/src/util/net.c":"2495e833346759949dd9d88b1a083dbce26d8953fe4f6cefe2470977f7a421bb","libgit2/src/util/net.h":"e0be81c875b7cc141bc89dfe1273c0fd591943c246e7d682be0002e83f55239e","libgit2/src/util/pool.c":"9a84fc9208d8cfeb4537d6e8575a43ed6ff56689f23b4b48ef61381c7b5f4303","libgit2/src/util/pool.h":"ac76ce784112b6053089e0c44f26295754388b298fe2272cc0d92d67857bcaac","libgit2/src/util/posix.c":"c21b022c4f3b9dd0a3b6ecbcf2bcc5e2ee57576d8ab2654f08558d6dbba1305d","libgit2/src/util/posix.h":"619074ecd891d4596a20fbb8ac201e7eb45ebbcc78cfd427b89baaf36ba73b04","libgit2/src/util/pqueue.c":"d5cd8f6c5639b50898fe0f9354dbb29de1a0be1d20c879242c8423907466c7c2","libgit2/src/util/pqueue.h":"6c84fffc0bfe473a0f1a7da38151b818826b488244ea660da02a78d4ef3bd3cf","libgit2/src/util/rand.c":"1b699cf44945b0171569d83f490b4d1981659c4a6c447301832fa91691432583","libgit2/src/util/rand.h":"102ce327cbbd6dcb9bdbe4c35addc7efa0095f335873860b06d85c4a070ebeac","libgit2/src/util/regexp.c":"b46bbb0df55b13817e7101559d8555505eff340a9a8bfe68424371c71f5e9649","libgit2/src/util/regexp.h":"855b271c6c8f5e1f3e5dc6648e9364d0448b2a9c1bc72cc3de0d1742e2905b32","libgit2/src/util/runtime.c":"b287e2f3d0a686b77736b725a86b8d6bea904b93c2f987513c608663b818a1d9","libgit2/src/util/runtime.h":"9aac7e20b2b879c49a423ef537bb0f51b8371c24503281b283b1fb74a8944f49","libgit2/src/util/sortedcache.c":"a77931c162e3280f6437c74cabf87b9ae16d5230c1ec54d401a9b9bc0fc6ad71","libgit2/src/util/sortedcache.h":"a15350fb05d181e00eedcd49dfef6cad77aafc0097121094cf60ea9c5bd3e1fd","libgit2/src/util/str.c":"8dca1dedcad4961e5f2389ede13708acb451ccab5c12819b8a7ec2e4057712f5","libgit2/src/util/str.h":"5c26b120517aa1b05ab78af401fa0e1f5848498100bc4204ca9f361451efec2c","libgit2/src/util/strmap.c":"02ee770dfbcc95f15bfe6755853f1c2795782f906d883d3102a904fedb2cda23","libgit2/src/util/strmap.h":"c1dfccefe0af68be84c1ba67fab05b03e866b75bb4a54fd434b0c3a5d9ced9cd","libgit2/src/util/strnlen.h":"27e73ccbe8be7c5bac1d022bf59f2458cc2998d0222e7658a687e02f89fcfd17","libgit2/src/util/thread.c":"6d741eabfe3739f6183e1d65935405f9fc457622d5b21978d4affdf6084e4fde","libgit2/src/util/thread.h":"cf40828f05d3fb3402731217155ce7986a894beec44fa0e8388f1444a83d5f13","libgit2/src/util/tsort.c":"d1dee30457c185e86bc47efecc5417459aefeabe7cfaf8aebe5eb2239296ee20","libgit2/src/util/unix/map.c":"1606c6c48126c72040f985492b6e6bd7b5df27d384f6f5bea9c35118ef7bb2de","libgit2/src/util/unix/posix.h":"672ff8c496693fd458a36c3f8d975a8c068e22597a6a9da4175ee2f985e401fc","libgit2/src/util/unix/pthread.h":"c716daa88e2e7ef2a2df23591a6061965dc11d77ed5fe1863d367a2b738a9fb0","libgit2/src/util/unix/realpath.c":"55a9016da6f89b1c740344e944593b311cfc5495328be915f38301915e560d7b","libgit2/src/util/utf8.c":"6cbf514d854524883a85a781e5e2a9003d71793fb2cd527795d26c972831a8ef","libgit2/src/util/utf8.h":"ca0239005ee004df1b2593aa727036a82f1ce3953000c3acf712b2639acd9206","libgit2/src/util/util.c":"52f384935855140d481c9a3d3c72df1679d1e777351bb11185b9c80ad956f766","libgit2/src/util/util.h":"ff16fdc19fcad0182367fa513676c033fc6aea0af13e04209e16fb3522954f44","libgit2/src/util/varint.c":"f93c5ba3498ac04d98ba13d3a320263892452356f797c4091411e5833dfe82f2","libgit2/src/util/varint.h":"b429d5e8b69d579cc6dab5e12ab4acf904c66947b41ca5372dfc3e327e59f533","libgit2/src/util/vector.c":"03cfd9059ffac7ada3c208379eea8ba9bb3b47e33e11d944ea333d3760ff08e8","libgit2/src/util/vector.h":"9fbf45c39ea5f2b5859022cd73b5cb857b162a7981b1838de584abe7d7316828","libgit2/src/util/wildmatch.c":"0102685757a40046a5fdee4be5be784989a84d3b4be9160d48120c4485c37133","libgit2/src/util/wildmatch.h":"7d59454a8271f810622ccfebb26c8408bd85f64c99d4411028e8482ab2c333d0","libgit2/src/util/win32/dir.c":"a0490ab8fe3be9213093afca1923a0fc472d368f2907ab23a86bb392520359cc","libgit2/src/util/win32/dir.h":"7835a64f082860bee53530a381fe9d6917be39f0d756562e8306dfd78154d3f7","libgit2/src/util/win32/error.c":"f1d2bcb2b6e60ca76c1ee0ca0f236e928331aa9755afc16926a5dab5de26d255","libgit2/src/util/win32/error.h":"44175c12d291bdf80df65a41cf669708c252ec04c8e084c41777c7a0b53569d1","libgit2/src/util/win32/findfile.c":"a6dbd2a8939699c9d534e3fb26db8b04c90377dc78ad9502bfbeb9e727f94d25","libgit2/src/util/win32/findfile.h":"fb00f3bc24bc7e2d7503df666b7ea8654d65cb40331dd51570ae793fd6f285e4","libgit2/src/util/win32/map.c":"6ce9c0a15df639d1d5b334685eeef03698b3ed006924e60b67461336fd7afc20","libgit2/src/util/win32/mingw-compat.h":"f7b0c7e9dd7147e8930782cdf54ce4be385172966dd1e27435446f38cd2f6d68","libgit2/src/util/win32/msvc-compat.h":"36e4c9515a8d53e70f78794826700c4a5472235aef703ac439308dd005e31454","libgit2/src/util/win32/path_w32.c":"c2629f35267e96f2e94e4a64a1cc98c8a88e687bc51073b68309745303950d4c","libgit2/src/util/win32/path_w32.h":"de01a65de67423157b23202bcba550f4ed1d5de2ac0e06a4f2ae8177aa4319ba","libgit2/src/util/win32/posix.h":"4dd2fc1529fc7e625180b649b9212d83462c654e47ba799fa62353aed5f60e14","libgit2/src/util/win32/posix_w32.c":"c4f8844b93e91e94bd0d55178f6ebc60a310fd531b0151ee3292df47f4077fca","libgit2/src/util/win32/precompiled.c":"4dff04101bd64b95c8f708d1accd1bedc39e95a263444290f796c63f4734d4cd","libgit2/src/util/win32/precompiled.h":"3f763f472fbf822314807b91ee9a2f88fe7f2fbcd165ee4e57f3f90e2715f14c","libgit2/src/util/win32/reparse.h":"ba254a97aba283930306f39f73e297d5eb30350276b3dd86deecbf10b4094c97","libgit2/src/util/win32/thread.c":"bce98dd6a635b66d811fab98b943ec448751a8b55c7261732277ca2804862fb9","libgit2/src/util/win32/thread.h":"8141cdc5c89901c2259a64c8f070950f69d4b742ed743ee1c520fd47b5b6948c","libgit2/src/util/win32/utf-conv.c":"fce8f7998d93fcd4f043d4d643f466a854b9611389487250e65fbc987a455bca","libgit2/src/util/win32/utf-conv.h":"3c19df554ce6f006e6a6b0ca46b8cb81fd64ad0f000e92685a681fd33d8ed408","libgit2/src/util/win32/version.h":"d9d9546728ee78923ba7ea1c16c000d44450ca80f8c0c3268bf58fa9966ba38f","libgit2/src/util/win32/w32_buffer.c":"1099be7c74b5bb265614787be285505e18dcaf71412607d8ec108639762a5b8d","libgit2/src/util/win32/w32_buffer.h":"a11005a0f3b2ecb3220ea9cdfd1df4b61d90f10e0e68ed2716b2f9502f2fa8f7","libgit2/src/util/win32/w32_common.h":"214cd67bcbdf89bb7effb78ee50c60b0504319117984c1a990f8301cffd78e0d","libgit2/src/util/win32/w32_leakcheck.c":"844ae1c7a959c8f181b45cc49a6f34262d03510f7748b6be7a159d7fd5c5e56d","libgit2/src/util/win32/w32_leakcheck.h":"cace8320ae9e8ef1d5b4836905a2d318e9e2a536ad3e232393e5f42b428554e7","libgit2/src/util/win32/w32_util.c":"fbe85eac432d4d1462ba659726557f782e811353170df8838ea1f967950d8711","libgit2/src/util/win32/w32_util.h":"f052487c469e5ba2fd327e55db1721e8f3f8d8947872ac63c6a3591fe7768853","libgit2/src/util/win32/win32-compat.h":"5ea7b1837a159d66a89365ee2bf3724b32579a6a78d94b0b205d44c8697a8e6f","libgit2/src/util/zstream.c":"51e507d17742366b91e6f427a48b566b52013f06502c3f05fbd6f5120b3d6afb","libgit2/src/util/zstream.h":"daa41460cf0ed019ef62a1936fb18626e8abac2b9a05061b6a377d4ab74a4cc5"},"package":"47a00859c70c8a4f7218e6d1cc32875c4b55f6799445b842b0d8ed5e4c3d959b"}
diff --git a/vendor/libgit2-sys/lib.rs b/vendor/libgit2-sys/lib.rs
index a113a2952..51e8d7968 100644
--- a/vendor/libgit2-sys/lib.rs
+++ b/vendor/libgit2-sys/lib.rs
@@ -489,6 +489,10 @@ git_enum! {
         GIT_CERT_SSH_RAW_TYPE_UNKNOWN = 0,
         GIT_CERT_SSH_RAW_TYPE_RSA = 1,
         GIT_CERT_SSH_RAW_TYPE_DSS = 2,
+        GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256 = 3,
+        GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384 = 4,
+        GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521 = 5,
+        GIT_CERT_SSH_RAW_TYPE_KEY_ED25519 = 6,
     }
 }
 
diff --git a/vendor/subtle/.cargo-checksum.json b/vendor/subtle/.cargo-checksum.json
new file mode 100644
index 000000000..57f71292d
--- /dev/null
+++ b/vendor/subtle/.cargo-checksum.json
@@ -0,0 +1 @@
+{"files":{"CHANGELOG.md":"1d604ca36159c79a4341f0c15fc249da7bf2912cd5b1bbf4964ce03dd887fc02","CONTRIBUTING.md":"2fbb44138ececdef7c0950fae6ed1dcad481fb2f368df0e3734c9902be791f3e","Cargo.toml":"2206ebe5be7cca3ad0a5dcbb0b12f85ac091b4b6a58861cddc8ecd5d137d4c7c","LICENSE":"36c48715a280d334a995f26fc38103f21cb92425a20c8eeaa368b229b49b6d4d","README.md":"ee1a1768f9b119a36db27a170f7f6bb8bdb79f868db28b37a11d1a57a208e9f5","src/lib.rs":"d873dd52215caf21a385391ed88f75e09f8f32203e93e3530c2a22d19e5a6452","tests/mod.rs":"127c8ab8ddbfa554f11876d76926f710382e293629875673e3bc99d738a13733"},"package":"6bdef32e8150c2a081110b42772ffe7d7c9032b606bc226c8260fd97e0976601"}
\ No newline at end of file
diff --git a/vendor/subtle/CHANGELOG.md b/vendor/subtle/CHANGELOG.md
new file mode 100644
index 000000000..152e7bcac
--- /dev/null
+++ b/vendor/subtle/CHANGELOG.md
@@ -0,0 +1,59 @@
+# Changelog
+
+Entries are listed in reverse chronological order.
+
+## 2.4.1
+
+* Fix a bug in how the README was included in the documentation builds
+  which caused nightly builds to break.
+
+## 2.4.0
+
+* Add new `ConstantTimeGreater` and `ConstantTimeLess` traits, as well
+  as implementations for unsigned integers, by @isislovecruft.
+
+## 2.3.0
+
+* Add `impl ConstantTimeEq for Choice` by @tarcieri.
+* Add `impl From<CtOption<T>> for Option<T>` by @CPerezz.  This is useful for
+  handling library code that produces `CtOption`s in contexts where timing
+  doesn't matter.
+* Introduce an MSRV policy.
+
+## 2.2.3
+
+* Remove the `nightly`-only asm-based `black_box` barrier in favor of the
+  volatile-based one, fixing compilation on current nightlies.
+
+## 2.2.2
+
+* Update README.md to clarify that 2.2 and above do not require the `nightly`
+  feature.
+
+## 2.2.1
+
+* Adds an `or_else` combinator for `CtOption`, by @ebfull.
+* Optimized `black_box` for `nightly`, by @jethrogb.
+* Optimized `black_box` for `stable`, by @dsprenkels.
+* Fixed CI for `no_std`, by @dsprenkels.
+* Fixed fuzz target compilation, by @3for.
+
+## 2.2.0
+
+* Error during `cargo publish`, yanked.
+
+## 2.1.1
+
+* Adds the "crypto" tag to crate metadata.
+* New shorter, more efficient ct_eq() for integers, contributed by Thomas Pornin.
+
+## 2.1.0
+
+* Adds a new `CtOption<T>` which acts as a constant-time `Option<T>`
+  (thanks to @ebfull for the implementation).
+* `Choice` now itself implements `ConditionallySelectable`.
+
+## 2.0.0
+
+* Stable version with traits reworked from 1.0.0 to interact better
+  with the orphan rules.
diff --git a/vendor/subtle/CONTRIBUTING.md b/vendor/subtle/CONTRIBUTING.md
new file mode 100644
index 000000000..2d2460516
--- /dev/null
+++ b/vendor/subtle/CONTRIBUTING.md
@@ -0,0 +1,33 @@
+# Contributing to subtle
+
+If you have questions or comments, please feel free to email the
+authors. 
+
+For feature requests, suggestions, and bug reports, please open an
+issue on [our Github](https://github.com/dalek-cryptography/subtle).  (Or,
+send us an email if you're opposed to using Github for whatever reason.)
+
+Patches are welcomed as pull requests on
+[our Github](https://github.com/dalek-cryptography/subtle), as well as by
+email (preferably sent to all of the authors listed in `Cargo.toml`).
+
+We're happy to take generalised utility code, provided the code is:
+
+1. constant time for all potential valid invocations, and
+2. applicable to implementations of several different protocols/primitives.
+
+All issues on subtle are mentored, if you want help with a bug just ask
+@isislovecruft or @hdevalence.
+
+Some issues are easier than others. The `easy` label can be used to find the
+easy issues. If you want to work on an issue, please leave a comment so that we
+can assign it to you!
+
+# Code of Conduct
+
+We follow the [Rust Code of Conduct](http://www.rust-lang.org/conduct.html),
+with the following additional clauses:
+
+* We respect the rights to privacy and anonymity for contributors and people in
+  the community.  If someone wishes to contribute under a pseudonym different to
+  their primary identity, that wish is to be respected by all contributors.
diff --git a/vendor/subtle/Cargo.toml b/vendor/subtle/Cargo.toml
new file mode 100644
index 000000000..8689ad2f7
--- /dev/null
+++ b/vendor/subtle/Cargo.toml
@@ -0,0 +1,36 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g., crates.io) dependencies
+#
+# If you believe there's an error in this file please file an
+# issue against the rust-lang/cargo repository. If you're
+# editing this file be aware that the upstream Cargo.toml
+# will likely look very different (and much more reasonable)
+
+[package]
+name = "subtle"
+version = "2.4.1"
+authors = ["Isis Lovecruft <isis@patternsinthevoid.net>", "Henry de Valence <hdevalence@hdevalence.ca>"]
+exclude = ["**/.gitignore", ".travis.yml"]
+description = "Pure-Rust traits and utilities for constant-time cryptographic implementations."
+homepage = "https://dalek.rs/"
+documentation = "https://docs.rs/subtle"
+readme = "README.md"
+keywords = ["cryptography", "crypto", "constant-time", "utilities"]
+categories = ["cryptography", "no-std"]
+license = "BSD-3-Clause"
+repository = "https://github.com/dalek-cryptography/subtle"
+[dev-dependencies.rand]
+version = "0.7"
+
+[features]
+default = ["std", "i128"]
+i128 = []
+nightly = []
+std = []
+[badges.travis-ci]
+branch = "master"
+repository = "dalek-cryptography/subtle"
diff --git a/vendor/subtle/LICENSE b/vendor/subtle/LICENSE
new file mode 100644
index 000000000..927c02c80
--- /dev/null
+++ b/vendor/subtle/LICENSE
@@ -0,0 +1,28 @@
+Copyright (c) 2016-2017 Isis Agora Lovecruft, Henry de Valence. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its
+contributors may be used to endorse or promote products derived from
+this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
diff --git a/vendor/subtle/README.md b/vendor/subtle/README.md
new file mode 100644
index 000000000..81ac448fe
--- /dev/null
+++ b/vendor/subtle/README.md
@@ -0,0 +1,69 @@
+# subtle [![](https://img.shields.io/crates/v/subtle.svg)](https://crates.io/crates/subtle) [![](https://img.shields.io/badge/dynamic/json.svg?label=docs&uri=https%3A%2F%2Fcrates.io%2Fapi%2Fv1%2Fcrates%2Fsubtle%2Fversions&query=%24.versions%5B0%5D.num&colorB=4F74A6)](https://doc.dalek.rs/subtle) [![](https://travis-ci.org/dalek-cryptography/subtle.svg?branch=master)](https://travis-ci.org/dalek-cryptography/subtle)
+
+**Pure-Rust traits and utilities for constant-time cryptographic implementations.**
+
+It consists of a `Choice` type, and a collection of traits using `Choice`
+instead of `bool` which are intended to execute in constant-time.  The `Choice`
+type is a wrapper around a `u8` that holds a `0` or `1`.
+
+```toml
+subtle = "2.4"
+```
+
+This crate represents a “best-effort” attempt, since side-channels
+are ultimately a property of a deployed cryptographic system
+including the hardware it runs on, not just of software.
+
+The traits are implemented using bitwise operations, and should execute in
+constant time provided that a) the bitwise operations are constant-time and
+b) the bitwise operations are not recognized as a conditional assignment and
+optimized back into a branch.
+
+For a compiler to recognize that bitwise operations represent a conditional
+assignment, it needs to know that the value used to generate the bitmasks is
+really a boolean `i1` rather than an `i8` byte value. In an attempt to
+prevent this refinement, the crate tries to hide the value of a `Choice`'s
+inner `u8` by passing it through a volatile read. For more information, see
+the _About_ section below.
+
+Versions prior to `2.2` recommended use of the `nightly` feature to enable an
+optimization barrier; this is not required in versions `2.2` and above.
+
+Note: the `subtle` crate contains `debug_assert`s to check invariants during
+debug builds. These invariant checks involve secret-dependent branches, and
+are not present when compiled in release mode. This crate is intended to be
+used in release mode.
+
+## Documentation
+
+Documentation is available [here][docs].
+
+## Minimum Supported Rust Version
+
+Rust **1.41** or higher.
+
+Minimum supported Rust version can be changed in the future, but it will be done with a minor version bump.
+
+## About
+
+This library aims to be the Rust equivalent of Go’s `crypto/subtle` module.
+
+The optimization barrier in `impl From<u8> for Choice` was based on Tim
+Maclean's [work on `rust-timing-shield`][rust-timing-shield], which attempts to
+provide a more comprehensive approach for preventing software side-channels in
+Rust code.
+
+`subtle` is authored by isis agora lovecruft and Henry de Valence.
+
+## Warning
+
+This code is a low-level library, intended for specific use-cases implementing
+cryptographic protocols.  It represents a best-effort attempt to protect
+against some software side-channels.  Because side-channel resistance is not a
+property of software alone, but of software together with hardware, any such
+effort is fundamentally limited.
+
+**USE AT YOUR OWN RISK**
+
+[docs]: https://docs.rs/subtle
+[rust-timing-shield]: https://www.chosenplaintext.ca/open-source/rust-timing-shield/security
diff --git a/vendor/subtle/src/lib.rs b/vendor/subtle/src/lib.rs
new file mode 100644
index 000000000..27d05eeae
--- /dev/null
+++ b/vendor/subtle/src/lib.rs
@@ -0,0 +1,864 @@
+// -*- mode: rust; -*-
+//
+// This file is part of subtle, part of the dalek cryptography project.
+// Copyright (c) 2016-2018 isis lovecruft, Henry de Valence
+// See LICENSE for licensing information.
+//
+// Authors:
+// - isis agora lovecruft <isis@patternsinthevoid.net>
+// - Henry de Valence <hdevalence@hdevalence.ca>
+
+#![no_std]
+#![deny(missing_docs)]
+#![doc(html_logo_url = "https://doc.dalek.rs/assets/dalek-logo-clear.png")]
+#![doc(html_root_url = "https://docs.rs/subtle/2.4.1")]
+
+//! # subtle [![](https://img.shields.io/crates/v/subtle.svg)](https://crates.io/crates/subtle) [![](https://img.shields.io/badge/dynamic/json.svg?label=docs&uri=https%3A%2F%2Fcrates.io%2Fapi%2Fv1%2Fcrates%2Fsubtle%2Fversions&query=%24.versions%5B0%5D.num&colorB=4F74A6)](https://doc.dalek.rs/subtle) [![](https://travis-ci.org/dalek-cryptography/subtle.svg?branch=master)](https://travis-ci.org/dalek-cryptography/subtle)
+//!
+//! **Pure-Rust traits and utilities for constant-time cryptographic implementations.**
+//!
+//! It consists of a `Choice` type, and a collection of traits using `Choice`
+//! instead of `bool` which are intended to execute in constant-time.  The `Choice`
+//! type is a wrapper around a `u8` that holds a `0` or `1`.
+//!
+//! ```toml
+//! subtle = "2.4"
+//! ```
+//!
+//! This crate represents a “best-effort” attempt, since side-channels
+//! are ultimately a property of a deployed cryptographic system
+//! including the hardware it runs on, not just of software.
+//!
+//! The traits are implemented using bitwise operations, and should execute in
+//! constant time provided that a) the bitwise operations are constant-time and
+//! b) the bitwise operations are not recognized as a conditional assignment and
+//! optimized back into a branch.
+//!
+//! For a compiler to recognize that bitwise operations represent a conditional
+//! assignment, it needs to know that the value used to generate the bitmasks is
+//! really a boolean `i1` rather than an `i8` byte value. In an attempt to
+//! prevent this refinement, the crate tries to hide the value of a `Choice`'s
+//! inner `u8` by passing it through a volatile read. For more information, see
+//! the _About_ section below.
+//!
+//! Versions prior to `2.2` recommended use of the `nightly` feature to enable an
+//! optimization barrier; this is not required in versions `2.2` and above.
+//!
+//! Note: the `subtle` crate contains `debug_assert`s to check invariants during
+//! debug builds. These invariant checks involve secret-dependent branches, and
+//! are not present when compiled in release mode. This crate is intended to be
+//! used in release mode.
+//!
+//! ## Documentation
+//!
+//! Documentation is available [here][docs].
+//!
+//! ## Minimum Supported Rust Version
+//!
+//! Rust **1.41** or higher.
+//!
+//! Minimum supported Rust version can be changed in the future, but it will be done with a minor version bump.
+//!
+//! ## About
+//!
+//! This library aims to be the Rust equivalent of Go’s `crypto/subtle` module.
+//!
+//! The optimization barrier in `impl From<u8> for Choice` was based on Tim
+//! Maclean's [work on `rust-timing-shield`][rust-timing-shield], which attempts to
+//! provide a more comprehensive approach for preventing software side-channels in
+//! Rust code.
+//!
+//! `subtle` is authored by isis agora lovecruft and Henry de Valence.
+//!
+//! ## Warning
+//!
+//! This code is a low-level library, intended for specific use-cases implementing
+//! cryptographic protocols.  It represents a best-effort attempt to protect
+//! against some software side-channels.  Because side-channel resistance is not a
+//! property of software alone, but of software together with hardware, any such
+//! effort is fundamentally limited.
+//!
+//! **USE AT YOUR OWN RISK**
+//!
+//! [docs]: https://docs.rs/subtle
+//! [rust-timing-shield]: https://www.chosenplaintext.ca/open-source/rust-timing-shield/security
+
+#[cfg(feature = "std")]
+#[macro_use]
+extern crate std;
+
+use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Neg, Not};
+use core::option::Option;
+
+/// The `Choice` struct represents a choice for use in conditional assignment.
+///
+/// It is a wrapper around a `u8`, which should have the value either `1` (true)
+/// or `0` (false).
+///
+/// The conversion from `u8` to `Choice` passes the value through an optimization
+/// barrier, as a best-effort attempt to prevent the compiler from inferring that
+/// the `Choice` value is a boolean. This strategy is based on Tim Maclean's
+/// [work on `rust-timing-shield`][rust-timing-shield], which attempts to provide
+/// a more comprehensive approach for preventing software side-channels in Rust
+/// code.
+///
+/// The `Choice` struct implements operators for AND, OR, XOR, and NOT, to allow
+/// combining `Choice` values. These operations do not short-circuit.
+///
+/// [rust-timing-shield]:
+/// https://www.chosenplaintext.ca/open-source/rust-timing-shield/security
+#[derive(Copy, Clone, Debug)]
+pub struct Choice(u8);
+
+impl Choice {
+    /// Unwrap the `Choice` wrapper to reveal the underlying `u8`.
+    ///
+    /// # Note
+    ///
+    /// This function only exists as an **escape hatch** for the rare case
+    /// where it's not possible to use one of the `subtle`-provided
+    /// trait impls.
+    ///
+    /// **To convert a `Choice` to a `bool`, use the `From` implementation instead.**
+    #[inline]
+    pub fn unwrap_u8(&self) -> u8 {
+        self.0
+    }
+}
+
+impl From<Choice> for bool {
+    /// Convert the `Choice` wrapper into a `bool`, depending on whether
+    /// the underlying `u8` was a `0` or a `1`.
+    ///
+    /// # Note
+    ///
+    /// This function exists to avoid having higher-level cryptographic protocol
+    /// implementations duplicating this pattern.
+    ///
+    /// The intended use case for this conversion is at the _end_ of a
+    /// higher-level primitive implementation: for example, in checking a keyed
+    /// MAC, where the verification should happen in constant-time (and thus use
+    /// a `Choice`) but it is safe to return a `bool` at the end of the
+    /// verification.
+    #[inline]
+    fn from(source: Choice) -> bool {
+        debug_assert!((source.0 == 0u8) | (source.0 == 1u8));
+        source.0 != 0
+    }
+}
+
+impl BitAnd for Choice {
+    type Output = Choice;
+    #[inline]
+    fn bitand(self, rhs: Choice) -> Choice {
+        (self.0 & rhs.0).into()
+    }
+}
+
+impl BitAndAssign for Choice {
+    #[inline]
+    fn bitand_assign(&mut self, rhs: Choice) {
+        *self = *self & rhs;
+    }
+}
+
+impl BitOr for Choice {
+    type Output = Choice;
+    #[inline]
+    fn bitor(self, rhs: Choice) -> Choice {
+        (self.0 | rhs.0).into()
+    }
+}
+
+impl BitOrAssign for Choice {
+    #[inline]
+    fn bitor_assign(&mut self, rhs: Choice) {
+        *self = *self | rhs;
+    }
+}
+
+impl BitXor for Choice {
+    type Output = Choice;
+    #[inline]
+    fn bitxor(self, rhs: Choice) -> Choice {
+        (self.0 ^ rhs.0).into()
+    }
+}
+
+impl BitXorAssign for Choice {
+    #[inline]
+    fn bitxor_assign(&mut self, rhs: Choice) {
+        *self = *self ^ rhs;
+    }
+}
+
+impl Not for Choice {
+    type Output = Choice;
+    #[inline]
+    fn not(self) -> Choice {
+        (1u8 & (!self.0)).into()
+    }
+}
+
+/// This function is a best-effort attempt to prevent the compiler from knowing
+/// anything about the value of the returned `u8`, other than its type.
+///
+/// Because we want to support stable Rust, we don't have access to inline
+/// assembly or test::black_box, so we use the fact that volatile values will
+/// never be elided to register values.
+///
+/// Note: Rust's notion of "volatile" is subject to change over time. While this
+/// code may break in a non-destructive way in the future, “constant-time” code
+/// is a continually moving target, and this is better than doing nothing.
+#[inline(never)]
+fn black_box(input: u8) -> u8 {
+    debug_assert!((input == 0u8) | (input == 1u8));
+
+    unsafe {
+        // Optimization barrier
+        //
+        // Unsafe is ok, because:
+        //   - &input is not NULL;
+        //   - size of input is not zero;
+        //   - u8 is neither Sync, nor Send;
+        //   - u8 is Copy, so input is always live;
+        //   - u8 type is always properly aligned.
+        core::ptr::read_volatile(&input as *const u8)
+    }
+}
+
+impl From<u8> for Choice {
+    #[inline]
+    fn from(input: u8) -> Choice {
+        // Our goal is to prevent the compiler from inferring that the value held inside the
+        // resulting `Choice` struct is really an `i1` instead of an `i8`.
+        Choice(black_box(input))
+    }
+}
+
+/// An `Eq`-like trait that produces a `Choice` instead of a `bool`.
+///
+/// # Example
+///
+/// ```
+/// use subtle::ConstantTimeEq;
+/// let x: u8 = 5;
+/// let y: u8 = 13;
+///
+/// assert_eq!(x.ct_eq(&y).unwrap_u8(), 0);
+/// assert_eq!(x.ct_eq(&x).unwrap_u8(), 1);
+/// ```
+pub trait ConstantTimeEq {
+    /// Determine if two items are equal.
+    ///
+    /// The `ct_eq` function should execute in constant time.
+    ///
+    /// # Returns
+    ///
+    /// * `Choice(1u8)` if `self == other`;
+    /// * `Choice(0u8)` if `self != other`.
+    #[inline]
+    fn ct_eq(&self, other: &Self) -> Choice;
+}
+
+impl<T: ConstantTimeEq> ConstantTimeEq for [T] {
+    /// Check whether two slices of `ConstantTimeEq` types are equal.
+    ///
+    /// # Note
+    ///
+    /// This function short-circuits if the lengths of the input slices
+    /// are different.  Otherwise, it should execute in time independent
+    /// of the slice contents.
+    ///
+    /// Since arrays coerce to slices, this function works with fixed-size arrays:
+    ///
+    /// ```
+    /// # use subtle::ConstantTimeEq;
+    /// #
+    /// let a: [u8; 8] = [0,1,2,3,4,5,6,7];
+    /// let b: [u8; 8] = [0,1,2,3,0,1,2,3];
+    ///
+    /// let a_eq_a = a.ct_eq(&a);
+    /// let a_eq_b = a.ct_eq(&b);
+    ///
+    /// assert_eq!(a_eq_a.unwrap_u8(), 1);
+    /// assert_eq!(a_eq_b.unwrap_u8(), 0);
+    /// ```
+    #[inline]
+    fn ct_eq(&self, _rhs: &[T]) -> Choice {
+        let len = self.len();
+
+        // Short-circuit on the *lengths* of the slices, not their
+        // contents.
+        if len != _rhs.len() {
+            return Choice::from(0);
+        }
+
+        // This loop shouldn't be shortcircuitable, since the compiler
+        // shouldn't be able to reason about the value of the `u8`
+        // unwrapped from the `ct_eq` result.
+        let mut x = 1u8;
+        for (ai, bi) in self.iter().zip(_rhs.iter()) {
+            x &= ai.ct_eq(bi).unwrap_u8();
+        }
+
+        x.into()
+    }
+}
+
+impl ConstantTimeEq for Choice {
+    #[inline]
+    fn ct_eq(&self, rhs: &Choice) -> Choice {
+        !(*self ^ *rhs)
+    }
+}
+
+/// Given the bit-width `$bit_width` and the corresponding primitive
+/// unsigned and signed types `$t_u` and `$t_i` respectively, generate
+/// an `ConstantTimeEq` implementation.
+macro_rules! generate_integer_equal {
+    ($t_u:ty, $t_i:ty, $bit_width:expr) => {
+        impl ConstantTimeEq for $t_u {
+            #[inline]
+            fn ct_eq(&self, other: &$t_u) -> Choice {
+                // x == 0 if and only if self == other
+                let x: $t_u = self ^ other;
+
+                // If x == 0, then x and -x are both equal to zero;
+                // otherwise, one or both will have its high bit set.
+                let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
+
+                // Result is the opposite of the high bit (now shifted to low).
+                ((y ^ (1 as $t_u)) as u8).into()
+            }
+        }
+        impl ConstantTimeEq for $t_i {
+            #[inline]
+            fn ct_eq(&self, other: &$t_i) -> Choice {
+                // Bitcast to unsigned and call that implementation.
+                (*self as $t_u).ct_eq(&(*other as $t_u))
+            }
+        }
+    };
+}
+
+generate_integer_equal!(u8, i8, 8);
+generate_integer_equal!(u16, i16, 16);
+generate_integer_equal!(u32, i32, 32);
+generate_integer_equal!(u64, i64, 64);
+#[cfg(feature = "i128")]
+generate_integer_equal!(u128, i128, 128);
+generate_integer_equal!(usize, isize, ::core::mem::size_of::<usize>() * 8);
+
+/// A type which can be conditionally selected in constant time.
+///
+/// This trait also provides generic implementations of conditional
+/// assignment and conditional swaps.
+pub trait ConditionallySelectable: Copy {
+    /// Select `a` or `b` according to `choice`.
+    ///
+    /// # Returns
+    ///
+    /// * `a` if `choice == Choice(0)`;
+    /// * `b` if `choice == Choice(1)`.
+    ///
+    /// This function should execute in constant time.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # extern crate subtle;
+    /// use subtle::ConditionallySelectable;
+    /// #
+    /// # fn main() {
+    /// let x: u8 = 13;
+    /// let y: u8 = 42;
+    ///
+    /// let z = u8::conditional_select(&x, &y, 0.into());
+    /// assert_eq!(z, x);
+    /// let z = u8::conditional_select(&x, &y, 1.into());
+    /// assert_eq!(z, y);
+    /// # }
+    /// ```
+    #[inline]
+    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self;
+
+    /// Conditionally assign `other` to `self`, according to `choice`.
+    ///
+    /// This function should execute in constant time.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # extern crate subtle;
+    /// use subtle::ConditionallySelectable;
+    /// #
+    /// # fn main() {
+    /// let mut x: u8 = 13;
+    /// let mut y: u8 = 42;
+    ///
+    /// x.conditional_assign(&y, 0.into());
+    /// assert_eq!(x, 13);
+    /// x.conditional_assign(&y, 1.into());
+    /// assert_eq!(x, 42);
+    /// # }
+    /// ```
+    #[inline]
+    fn conditional_assign(&mut self, other: &Self, choice: Choice) {
+        *self = Self::conditional_select(self, other, choice);
+    }
+
+    /// Conditionally swap `self` and `other` if `choice == 1`; otherwise,
+    /// reassign both unto themselves.
+    ///
+    /// This function should execute in constant time.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # extern crate subtle;
+    /// use subtle::ConditionallySelectable;
+    /// #
+    /// # fn main() {
+    /// let mut x: u8 = 13;
+    /// let mut y: u8 = 42;
+    ///
+    /// u8::conditional_swap(&mut x, &mut y, 0.into());
+    /// assert_eq!(x, 13);
+    /// assert_eq!(y, 42);
+    /// u8::conditional_swap(&mut x, &mut y, 1.into());
+    /// assert_eq!(x, 42);
+    /// assert_eq!(y, 13);
+    /// # }
+    /// ```
+    #[inline]
+    fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
+        let t: Self = *a;
+        a.conditional_assign(&b, choice);
+        b.conditional_assign(&t, choice);
+    }
+}
+
+macro_rules! to_signed_int {
+    (u8) => {
+        i8
+    };
+    (u16) => {
+        i16
+    };
+    (u32) => {
+        i32
+    };
+    (u64) => {
+        i64
+    };
+    (u128) => {
+        i128
+    };
+    (i8) => {
+        i8
+    };
+    (i16) => {
+        i16
+    };
+    (i32) => {
+        i32
+    };
+    (i64) => {
+        i64
+    };
+    (i128) => {
+        i128
+    };
+}
+
+macro_rules! generate_integer_conditional_select {
+    ($($t:tt)*) => ($(
+        impl ConditionallySelectable for $t {
+            #[inline]
+            fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
+                // if choice = 0, mask = (-0) = 0000...0000
+                // if choice = 1, mask = (-1) = 1111...1111
+                let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
+                a ^ (mask & (a ^ b))
+            }
+
+            #[inline]
+            fn conditional_assign(&mut self, other: &Self, choice: Choice) {
+                // if choice = 0, mask = (-0) = 0000...0000
+                // if choice = 1, mask = (-1) = 1111...1111
+                let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
+                *self ^= mask & (*self ^ *other);
+            }
+
+            #[inline]
+            fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
+                // if choice = 0, mask = (-0) = 0000...0000
+                // if choice = 1, mask = (-1) = 1111...1111
+                let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
+                let t = mask & (*a ^ *b);
+                *a ^= t;
+                *b ^= t;
+            }
+         }
+    )*)
+}
+
+generate_integer_conditional_select!(  u8   i8);
+generate_integer_conditional_select!( u16  i16);
+generate_integer_conditional_select!( u32  i32);
+generate_integer_conditional_select!( u64  i64);
+#[cfg(feature = "i128")]
+generate_integer_conditional_select!(u128 i128);
+
+impl ConditionallySelectable for Choice {
+    #[inline]
+    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
+        Choice(u8::conditional_select(&a.0, &b.0, choice))
+    }
+}
+
+/// A type which can be conditionally negated in constant time.
+///
+/// # Note
+///
+/// A generic implementation of `ConditionallyNegatable` is provided
+/// for types `T` which are `ConditionallySelectable` and have `Neg`
+/// implemented on `&T`.
+pub trait ConditionallyNegatable {
+    /// Negate `self` if `choice == Choice(1)`; otherwise, leave it
+    /// unchanged.
+    ///
+    /// This function should execute in constant time.
+    #[inline]
+    fn conditional_negate(&mut self, choice: Choice);
+}
+
+impl<T> ConditionallyNegatable for T
+where
+    T: ConditionallySelectable,
+    for<'a> &'a T: Neg<Output = T>,
+{
+    #[inline]
+    fn conditional_negate(&mut self, choice: Choice) {
+        // Need to cast to eliminate mutability
+        let self_neg: T = -(self as &T);
+        self.conditional_assign(&self_neg, choice);
+    }
+}
+
+/// The `CtOption<T>` type represents an optional value similar to the
+/// [`Option<T>`](core::option::Option) type but is intended for
+/// use in constant time APIs.
+///
+/// Any given `CtOption<T>` is either `Some` or `None`, but unlike
+/// `Option<T>` these variants are not exposed. The
+/// [`is_some()`](CtOption::is_some) method is used to determine if
+/// the value is `Some`, and [`unwrap_or()`](CtOption::unwrap_or) and
+/// [`unwrap_or_else()`](CtOption::unwrap_or_else) methods are
+/// provided to access the underlying value. The value can also be
+/// obtained with [`unwrap()`](CtOption::unwrap) but this will panic
+/// if it is `None`.
+///
+/// Functions that are intended to be constant time may not produce
+/// valid results for all inputs, such as square root and inversion
+/// operations in finite field arithmetic. Returning an `Option<T>`
+/// from these functions makes it difficult for the caller to reason
+/// about the result in constant time, and returning an incorrect
+/// value burdens the caller and increases the chance of bugs.
+#[derive(Clone, Copy, Debug)]
+pub struct CtOption<T> {
+    value: T,
+    is_some: Choice,
+}
+
+impl<T> From<CtOption<T>> for Option<T> {
+    /// Convert the `CtOption<T>` wrapper into an `Option<T>`, depending on whether
+    /// the underlying `is_some` `Choice` was a `0` or a `1` once unwrapped.
+    ///
+    /// # Note
+    ///
+    /// This function exists to avoid ending up with ugly, verbose and/or bad handled
+    /// conversions from the `CtOption<T>` wraps to an `Option<T>` or `Result<T, E>`.
+    /// This implementation doesn't intend to be constant-time nor try to protect the
+    /// leakage of the `T` since the `Option<T>` will do it anyways.
+    fn from(source: CtOption<T>) -> Option<T> {
+        if source.is_some().unwrap_u8() == 1u8 {
+            Option::Some(source.value)
+        } else {
+            None
+        }
+    }
+}
+
+impl<T> CtOption<T> {
+    /// This method is used to construct a new `CtOption<T>` and takes
+    /// a value of type `T`, and a `Choice` that determines whether
+    /// the optional value should be `Some` or not. If `is_some` is
+    /// false, the value will still be stored but its value is never
+    /// exposed.
+    #[inline]
+    pub fn new(value: T, is_some: Choice) -> CtOption<T> {
+        CtOption {
+            value: value,
+            is_some: is_some,
+        }
+    }
+
+    /// This returns the underlying value but panics if it
+    /// is not `Some`.
+    #[inline]
+    pub fn unwrap(self) -> T {
+        assert_eq!(self.is_some.unwrap_u8(), 1);
+
+        self.value
+    }
+
+    /// This returns the underlying value if it is `Some`
+    /// or the provided value otherwise.
+    #[inline]
+    pub fn unwrap_or(self, def: T) -> T
+    where
+        T: ConditionallySelectable,
+    {
+        T::conditional_select(&def, &self.value, self.is_some)
+    }
+
+    /// This returns the underlying value if it is `Some`
+    /// or the value produced by the provided closure otherwise.
+    #[inline]
+    pub fn unwrap_or_else<F>(self, f: F) -> T
+    where
+        T: ConditionallySelectable,
+        F: FnOnce() -> T,
+    {
+        T::conditional_select(&f(), &self.value, self.is_some)
+    }
+
+    /// Returns a true `Choice` if this value is `Some`.
+    #[inline]
+    pub fn is_some(&self) -> Choice {
+        self.is_some
+    }
+
+    /// Returns a true `Choice` if this value is `None`.
+    #[inline]
+    pub fn is_none(&self) -> Choice {
+        !self.is_some
+    }
+
+    /// Returns a `None` value if the option is `None`, otherwise
+    /// returns a `CtOption` enclosing the value of the provided closure.
+    /// The closure is given the enclosed value or, if the option is
+    /// `None`, it is provided a dummy value computed using
+    /// `Default::default()`.
+    ///
+    /// This operates in constant time, because the provided closure
+    /// is always called.
+    #[inline]
+    pub fn map<U, F>(self, f: F) -> CtOption<U>
+    where
+        T: Default + ConditionallySelectable,
+        F: FnOnce(T) -> U,
+    {
+        CtOption::new(
+            f(T::conditional_select(
+                &T::default(),
+                &self.value,
+                self.is_some,
+            )),
+            self.is_some,
+        )
+    }
+
+    /// Returns a `None` value if the option is `None`, otherwise
+    /// returns the result of the provided closure. The closure is
+    /// given the enclosed value or, if the option is `None`, it
+    /// is provided a dummy value computed using `Default::default()`.
+    ///
+    /// This operates in constant time, because the provided closure
+    /// is always called.
+    #[inline]
+    pub fn and_then<U, F>(self, f: F) -> CtOption<U>
+    where
+        T: Default + ConditionallySelectable,
+        F: FnOnce(T) -> CtOption<U>,
+    {
+        let mut tmp = f(T::conditional_select(
+            &T::default(),
+            &self.value,
+            self.is_some,
+        ));
+        tmp.is_some &= self.is_some;
+
+        tmp
+    }
+
+    /// Returns `self` if it contains a value, and otherwise returns the result of
+    /// calling `f`. The provided function `f` is always called.
+    #[inline]
+    pub fn or_else<F>(self, f: F) -> CtOption<T>
+    where
+        T: ConditionallySelectable,
+        F: FnOnce() -> CtOption<T>,
+    {
+        let is_none = self.is_none();
+        let f = f();
+
+        Self::conditional_select(&self, &f, is_none)
+    }
+}
+
+impl<T: ConditionallySelectable> ConditionallySelectable for CtOption<T> {
+    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
+        CtOption::new(
+            T::conditional_select(&a.value, &b.value, choice),
+            Choice::conditional_select(&a.is_some, &b.is_some, choice),
+        )
+    }
+}
+
+impl<T: ConstantTimeEq> ConstantTimeEq for CtOption<T> {
+    /// Two `CtOption<T>`s are equal if they are both `Some` and
+    /// their values are equal, or both `None`.
+    #[inline]
+    fn ct_eq(&self, rhs: &CtOption<T>) -> Choice {
+        let a = self.is_some();
+        let b = rhs.is_some();
+
+        (a & b & self.value.ct_eq(&rhs.value)) | (!a & !b)
+    }
+}
+
+/// A type which can be compared in some manner and be determined to be greater
+/// than another of the same type.
+pub trait ConstantTimeGreater {
+    /// Determine whether `self > other`.
+    ///
+    /// The bitwise-NOT of the return value of this function should be usable to
+    /// determine if `self <= other`.
+    ///
+    /// This function should execute in constant time.
+    ///
+    /// # Returns
+    ///
+    /// A `Choice` with a set bit if `self > other`, and with no set bits
+    /// otherwise.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # extern crate subtle;
+    /// use subtle::ConstantTimeGreater;
+    ///
+    /// let x: u8 = 13;
+    /// let y: u8 = 42;
+    ///
+    /// let x_gt_y = x.ct_gt(&y);
+    ///
+    /// assert_eq!(x_gt_y.unwrap_u8(), 0);
+    ///
+    /// let y_gt_x = y.ct_gt(&x);
+    ///
+    /// assert_eq!(y_gt_x.unwrap_u8(), 1);
+    ///
+    /// let x_gt_x = x.ct_gt(&x);
+    ///
+    /// assert_eq!(x_gt_x.unwrap_u8(), 0);
+    /// ```
+    fn ct_gt(&self, other: &Self) -> Choice;
+}
+
+macro_rules! generate_unsigned_integer_greater {
+    ($t_u: ty, $bit_width: expr) => {
+        impl ConstantTimeGreater for $t_u {
+            /// Returns Choice::from(1) iff x > y, and Choice::from(0) iff x <= y.
+            ///
+            /// # Note
+            ///
+            /// This algoritm would also work for signed integers if we first
+            /// flip the top bit, e.g. `let x: u8 = x ^ 0x80`, etc.
+            #[inline]
+            fn ct_gt(&self, other: &$t_u) -> Choice {
+                let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
+                let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
+                let mut pow = 1;
+
+                // Less-than operator is okay here because it's dependent on the bit-width.
+                while pow < $bit_width {
+                    ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
+                    pow += pow;
+                }
+                let mut bit = gtb & !ltb; // Select the highest set bit.
+                let mut pow = 1;
+
+                while pow < $bit_width {
+                    bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
+                    pow += pow;
+                }
+                // XXX We should possibly do the above flattening to 0 or 1 in the
+                //     Choice constructor rather than making it a debug error?
+                Choice::from((bit & 1) as u8)
+            }
+        }
+    }
+}
+
+generate_unsigned_integer_greater!(u8, 8);
+generate_unsigned_integer_greater!(u16, 16);
+generate_unsigned_integer_greater!(u32, 32);
+generate_unsigned_integer_greater!(u64, 64);
+#[cfg(feature = "i128")]
+generate_unsigned_integer_greater!(u128, 128);
+
+/// A type which can be compared in some manner and be determined to be less
+/// than another of the same type.
+pub trait ConstantTimeLess: ConstantTimeEq + ConstantTimeGreater {
+    /// Determine whether `self < other`.
+    ///
+    /// The bitwise-NOT of the return value of this function should be usable to
+    /// determine if `self >= other`.
+    ///
+    /// A default implementation is provided and implemented for the unsigned
+    /// integer types.
+    ///
+    /// This function should execute in constant time.
+    ///
+    /// # Returns
+    ///
+    /// A `Choice` with a set bit if `self < other`, and with no set bits
+    /// otherwise.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # extern crate subtle;
+    /// use subtle::ConstantTimeLess;
+    ///
+    /// let x: u8 = 13;
+    /// let y: u8 = 42;
+    ///
+    /// let x_lt_y = x.ct_lt(&y);
+    ///
+    /// assert_eq!(x_lt_y.unwrap_u8(), 1);
+    ///
+    /// let y_lt_x = y.ct_lt(&x);
+    ///
+    /// assert_eq!(y_lt_x.unwrap_u8(), 0);
+    ///
+    /// let x_lt_x = x.ct_lt(&x);
+    ///
+    /// assert_eq!(x_lt_x.unwrap_u8(), 0);
+    /// ```
+    #[inline]
+    fn ct_lt(&self, other: &Self) -> Choice {
+        !self.ct_gt(other) & !self.ct_eq(other)
+    }
+}
+
+impl ConstantTimeLess for u8 {}
+impl ConstantTimeLess for u16 {}
+impl ConstantTimeLess for u32 {}
+impl ConstantTimeLess for u64 {}
+#[cfg(feature = "i128")]
+impl ConstantTimeLess for u128 {}
diff --git a/vendor/subtle/tests/mod.rs b/vendor/subtle/tests/mod.rs
new file mode 100644
index 000000000..eaa98a460
--- /dev/null
+++ b/vendor/subtle/tests/mod.rs
@@ -0,0 +1,389 @@
+extern crate rand;
+extern crate subtle;
+
+use rand::rngs::OsRng;
+use rand::RngCore;
+
+use subtle::*;
+
+#[test]
+#[should_panic]
+fn slices_equal_different_lengths() {
+    let a: [u8; 3] = [0, 0, 0];
+    let b: [u8; 4] = [0, 0, 0, 0];
+
+    assert_eq!((&a).ct_eq(&b).unwrap_u8(), 1);
+}
+
+#[test]
+fn slices_equal() {
+    let a: [u8; 8] = [1, 2, 3, 4, 5, 6, 7, 8];
+    let b: [u8; 8] = [1, 2, 3, 4, 4, 3, 2, 1];
+
+    let a_eq_a = (&a).ct_eq(&a);
+    let a_eq_b = (&a).ct_eq(&b);
+
+    assert_eq!(a_eq_a.unwrap_u8(), 1);
+    assert_eq!(a_eq_b.unwrap_u8(), 0);
+
+    let c: [u8; 16] = [0u8; 16];
+
+    let a_eq_c = (&a).ct_eq(&c);
+    assert_eq!(a_eq_c.unwrap_u8(), 0);
+}
+
+#[test]
+fn conditional_assign_i32() {
+    let mut a: i32 = 5;
+    let b: i32 = 13;
+
+    a.conditional_assign(&b, 0.into());
+    assert_eq!(a, 5);
+    a.conditional_assign(&b, 1.into());
+    assert_eq!(a, 13);
+}
+
+#[test]
+fn conditional_assign_i64() {
+    let mut c: i64 = 2343249123;
+    let d: i64 = 8723884895;
+
+    c.conditional_assign(&d, 0.into());
+    assert_eq!(c, 2343249123);
+    c.conditional_assign(&d, 1.into());
+    assert_eq!(c, 8723884895);
+}
+
+macro_rules! generate_integer_conditional_select_tests {
+    ($($t:ty)*) => ($(
+        let x: $t = 0;  // all 0 bits
+        let y: $t = !0; // all 1 bits
+
+        assert_eq!(<$t>::conditional_select(&x, &y, 0.into()), 0);
+        assert_eq!(<$t>::conditional_select(&x, &y, 1.into()), y);
+
+        let mut z = x;
+        let mut w = y;
+
+        <$t>::conditional_swap(&mut z, &mut w, 0.into());
+        assert_eq!(z, x);
+        assert_eq!(w, y);
+        <$t>::conditional_swap(&mut z, &mut w, 1.into());
+        assert_eq!(z, y);
+        assert_eq!(w, x);
+
+        z.conditional_assign(&x, 1.into());
+        w.conditional_assign(&y, 0.into());
+        assert_eq!(z, x);
+        assert_eq!(w, x);
+    )*)
+}
+
+#[test]
+fn integer_conditional_select() {
+    generate_integer_conditional_select_tests!(u8 u16 u32 u64);
+    generate_integer_conditional_select_tests!(i8 i16 i32 i64);
+    #[cfg(feature = "i128")]
+    generate_integer_conditional_select_tests!(i128 u128);
+}
+
+#[test]
+fn custom_conditional_select_i16() {
+    let x: i16 = 257;
+    let y: i16 = 514;
+
+    assert_eq!(i16::conditional_select(&x, &y, 0.into()), 257);
+    assert_eq!(i16::conditional_select(&x, &y, 1.into()), 514);
+}
+
+macro_rules! generate_integer_equal_tests {
+    ($($t:ty),*) => ($(
+        let y: $t = 0;  // all 0 bits
+        let z: $t = !0; // all 1 bits
+
+        let x = z;
+
+        assert_eq!(x.ct_eq(&y).unwrap_u8(), 0);
+        assert_eq!(x.ct_eq(&z).unwrap_u8(), 1);
+    )*)
+}
+
+#[test]
+fn integer_equal() {
+    generate_integer_equal_tests!(u8, u16, u32, u64);
+    generate_integer_equal_tests!(i8, i16, i32, i64);
+    #[cfg(feature = "i128")]
+    generate_integer_equal_tests!(i128, u128);
+    generate_integer_equal_tests!(isize, usize);
+}
+
+#[test]
+fn choice_into_bool() {
+    let choice_true: bool = Choice::from(1).into();
+
+    assert!(choice_true);
+
+    let choice_false: bool = Choice::from(0).into();
+
+    assert!(!choice_false);
+}
+
+#[test]
+fn conditional_select_choice() {
+    let t = Choice::from(1);
+    let f = Choice::from(0);
+
+    assert_eq!(bool::from(Choice::conditional_select(&t, &f, f)), true);
+    assert_eq!(bool::from(Choice::conditional_select(&t, &f, t)), false);
+    assert_eq!(bool::from(Choice::conditional_select(&f, &t, f)), false);
+    assert_eq!(bool::from(Choice::conditional_select(&f, &t, t)), true);
+}
+
+#[test]
+fn choice_equal() {
+    assert!(Choice::from(0).ct_eq(&Choice::from(0)).unwrap_u8() == 1);
+    assert!(Choice::from(0).ct_eq(&Choice::from(1)).unwrap_u8() == 0);
+    assert!(Choice::from(1).ct_eq(&Choice::from(0)).unwrap_u8() == 0);
+    assert!(Choice::from(1).ct_eq(&Choice::from(1)).unwrap_u8() == 1);
+}
+
+#[test]
+fn test_ctoption() {
+    let a = CtOption::new(10, Choice::from(1));
+    let b = CtOption::new(9, Choice::from(1));
+    let c = CtOption::new(10, Choice::from(0));
+    let d = CtOption::new(9, Choice::from(0));
+
+    // Test is_some / is_none
+    assert!(bool::from(a.is_some()));
+    assert!(bool::from(!a.is_none()));
+    assert!(bool::from(b.is_some()));
+    assert!(bool::from(!b.is_none()));
+    assert!(bool::from(!c.is_some()));
+    assert!(bool::from(c.is_none()));
+    assert!(bool::from(!d.is_some()));
+    assert!(bool::from(d.is_none()));
+
+    // Test unwrap for Some
+    assert_eq!(a.unwrap(), 10);
+    assert_eq!(b.unwrap(), 9);
+
+    // Test equality
+    assert!(bool::from(a.ct_eq(&a)));
+    assert!(bool::from(!a.ct_eq(&b)));
+    assert!(bool::from(!a.ct_eq(&c)));
+    assert!(bool::from(!a.ct_eq(&d)));
+
+    // Test equality of None with different
+    // dummy value
+    assert!(bool::from(c.ct_eq(&d)));
+
+    // Test unwrap_or
+    assert_eq!(CtOption::new(1, Choice::from(1)).unwrap_or(2), 1);
+    assert_eq!(CtOption::new(1, Choice::from(0)).unwrap_or(2), 2);
+
+    // Test unwrap_or_else
+    assert_eq!(CtOption::new(1, Choice::from(1)).unwrap_or_else(|| 2), 1);
+    assert_eq!(CtOption::new(1, Choice::from(0)).unwrap_or_else(|| 2), 2);
+
+    // Test map
+    assert_eq!(
+        CtOption::new(1, Choice::from(1))
+            .map(|v| {
+                assert_eq!(v, 1);
+                2
+            })
+            .unwrap(),
+        2
+    );
+    assert_eq!(
+        CtOption::new(1, Choice::from(0))
+            .map(|_| 2)
+            .is_none()
+            .unwrap_u8(),
+        1
+    );
+
+    // Test and_then
+    assert_eq!(
+        CtOption::new(1, Choice::from(1))
+            .and_then(|v| {
+                assert_eq!(v, 1);
+                CtOption::new(2, Choice::from(0))
+            })
+            .is_none()
+            .unwrap_u8(),
+        1
+    );
+    assert_eq!(
+        CtOption::new(1, Choice::from(1))
+            .and_then(|v| {
+                assert_eq!(v, 1);
+                CtOption::new(2, Choice::from(1))
+            })
+            .unwrap(),
+        2
+    );
+
+    assert_eq!(
+        CtOption::new(1, Choice::from(0))
+            .and_then(|_| CtOption::new(2, Choice::from(0)))
+            .is_none()
+            .unwrap_u8(),
+        1
+    );
+    assert_eq!(
+        CtOption::new(1, Choice::from(0))
+            .and_then(|_| CtOption::new(2, Choice::from(1)))
+            .is_none()
+            .unwrap_u8(),
+        1
+    );
+
+    // Test or_else
+    assert_eq!(
+        CtOption::new(1, Choice::from(0))
+            .or_else(|| CtOption::new(2, Choice::from(1)))
+            .unwrap(),
+        2
+    );
+    assert_eq!(
+        CtOption::new(1, Choice::from(1))
+            .or_else(|| CtOption::new(2, Choice::from(0)))
+            .unwrap(),
+        1
+    );
+    assert_eq!(
+        CtOption::new(1, Choice::from(1))
+            .or_else(|| CtOption::new(2, Choice::from(1)))
+            .unwrap(),
+        1
+    );
+    assert!(bool::from(
+        CtOption::new(1, Choice::from(0))
+            .or_else(|| CtOption::new(2, Choice::from(0)))
+            .is_none()
+    ));
+
+    // Test (in)equality
+    assert!(CtOption::new(1, Choice::from(0)).ct_eq(&CtOption::new(1, Choice::from(1))).unwrap_u8() == 0);
+    assert!(CtOption::new(1, Choice::from(1)).ct_eq(&CtOption::new(1, Choice::from(0))).unwrap_u8() == 0);
+    assert!(CtOption::new(1, Choice::from(0)).ct_eq(&CtOption::new(2, Choice::from(1))).unwrap_u8() == 0);
+    assert!(CtOption::new(1, Choice::from(1)).ct_eq(&CtOption::new(2, Choice::from(0))).unwrap_u8() == 0);
+    assert!(CtOption::new(1, Choice::from(0)).ct_eq(&CtOption::new(1, Choice::from(0))).unwrap_u8() == 1);
+    assert!(CtOption::new(1, Choice::from(0)).ct_eq(&CtOption::new(2, Choice::from(0))).unwrap_u8() == 1);
+    assert!(CtOption::new(1, Choice::from(1)).ct_eq(&CtOption::new(2, Choice::from(1))).unwrap_u8() == 0);
+    assert!(CtOption::new(1, Choice::from(1)).ct_eq(&CtOption::new(2, Choice::from(1))).unwrap_u8() == 0);
+    assert!(CtOption::new(1, Choice::from(1)).ct_eq(&CtOption::new(1, Choice::from(1))).unwrap_u8() == 1);
+    assert!(CtOption::new(1, Choice::from(1)).ct_eq(&CtOption::new(1, Choice::from(1))).unwrap_u8() == 1);
+}
+
+#[test]
+#[should_panic]
+fn unwrap_none_ctoption() {
+    // This test might fail (in release mode?) if the
+    // compiler decides to optimize it away.
+    CtOption::new(10, Choice::from(0)).unwrap();
+}
+
+macro_rules! generate_greater_than_test {
+    ($ty: ty) => {
+        for _ in 0..100 {
+            let x = OsRng.next_u64() as $ty;
+            let y = OsRng.next_u64() as $ty;
+            let z = x.ct_gt(&y);
+
+            println!("x={}, y={}, z={:?}", x, y, z);
+
+            if x < y {
+                assert!(z.unwrap_u8() == 0);
+            } else if x == y {
+                assert!(z.unwrap_u8() == 0);
+            } else if x > y {
+                assert!(z.unwrap_u8() == 1);
+            }
+        }
+    }
+}
+
+#[test]
+fn greater_than_u8() {
+    generate_greater_than_test!(u8);
+}
+
+#[test]
+fn greater_than_u16() {
+    generate_greater_than_test!(u16);
+}
+
+#[test]
+fn greater_than_u32() {
+    generate_greater_than_test!(u32);
+}
+
+#[test]
+fn greater_than_u64() {
+    generate_greater_than_test!(u64);
+}
+
+#[cfg(feature = "i128")]
+#[test]
+fn greater_than_u128() {
+    generate_greater_than_test!(u128);
+}
+
+#[test]
+/// Test that the two's compliment min and max, i.e. 0000...0001 < 1111...1110,
+/// gives the correct result. (This fails using the bit-twiddling algorithm that
+/// go/crypto/subtle uses.)
+fn less_than_twos_compliment_minmax() {
+    let z = 1u32.ct_lt(&(2u32.pow(31)-1));
+
+    assert!(z.unwrap_u8() == 1);
+}
+
+macro_rules! generate_less_than_test {
+    ($ty: ty) => {
+        for _ in 0..100 {
+            let x = OsRng.next_u64() as $ty;
+            let y = OsRng.next_u64() as $ty;
+            let z = x.ct_gt(&y);
+
+            println!("x={}, y={}, z={:?}", x, y, z);
+
+            if x < y {
+                assert!(z.unwrap_u8() == 0);
+            } else if x == y {
+                assert!(z.unwrap_u8() == 0);
+            } else if x > y {
+                assert!(z.unwrap_u8() == 1);
+            }
+        }
+    }
+}
+
+#[test]
+fn less_than_u8() {
+    generate_less_than_test!(u8);
+}
+
+#[test]
+fn less_than_u16() {
+    generate_less_than_test!(u16);
+}
+
+#[test]
+fn less_than_u32() {
+    generate_less_than_test!(u32);
+}
+
+#[test]
+fn less_than_u64() {
+    generate_less_than_test!(u64);
+}
+
+#[cfg(feature = "i128")]
+#[test]
+fn less_than_u128() {
+    generate_less_than_test!(u128);
+}
-- 
2.39.0

