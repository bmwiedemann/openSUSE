Without nonblocking IO, g_io_channel_read_chars waits indefinitely for more
data without ever returning control to the event loop.

Set the IO channels to nonblocking to fix SIGTERM handling.

Signed-off-by: Fabian Vogt <fvogt@suse.de>
---
 restorecond/user.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/restorecond/user.c b/restorecond/user.c
index 7188c22e3119..25e70ae15b94 100644
--- a/restorecond/user.c
+++ b/restorecond/user.c
@@ -239,6 +239,7 @@ static int local_server(void) {
 	/* watch for stdin/terminal going away */
 	GIOChannel *in = g_io_channel_unix_new(0);
 	g_io_channel_set_encoding(in, NULL, NULL);
+	g_io_channel_set_flags(in, g_io_channel_get_flags(in) | G_IO_FLAG_NONBLOCK, NULL);
 	g_io_add_watch_full( in,
 			     G_PRIORITY_HIGH,
 			     G_IO_IN|G_IO_ERR|G_IO_HUP,
@@ -284,6 +285,7 @@ int server(int master_fd, const char *watch_file) {
 
 	GIOChannel *c = g_io_channel_unix_new(master_fd);
 	g_io_channel_set_encoding(c, NULL, NULL);
+	g_io_channel_set_flags(c, g_io_channel_get_flags(c) | G_IO_FLAG_NONBLOCK, NULL);
 
 	g_io_add_watch_full(c,
 			    G_PRIORITY_HIGH,
--
2.47.0
