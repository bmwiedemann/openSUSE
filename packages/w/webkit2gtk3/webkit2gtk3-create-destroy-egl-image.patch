From 855a2ca13f6a85b0aacb0576fbbc9a926e646b2e Mon Sep 17 00:00:00 2001
From: Carlos Garcia Campos <cgarcia@igalia.com>
Date: Thu, 31 Aug 2023 09:26:26 -0700
Subject: [PATCH] [GTK][WPE] Do not use epoxy
 PlatformDisplay::create|destroyEGLImage
 https://bugs.webkit.org/show_bug.cgi?id=260968

Reviewed by Michael Catanzaro.

libepoxy needs a current context to work, but creating EGL images
doesn't need any context, it's display API.

* Source/WebCore/platform/graphics/PlatformDisplay.cpp:
(WebCore::PlatformDisplay::createEGLImage const):
(WebCore::PlatformDisplay::destroyEGLImage const):

Canonical link: https://commits.webkit.org/267503@main
---
 .../platform/graphics/PlatformDisplay.cpp        | 16 ----------------
 1 file changed, 16 deletions(-)

diff -urp webkitgtk-2.42.1.orig/Source/WebCore/platform/graphics/PlatformDisplay.cpp webkitgtk-2.42.1/Source/WebCore/platform/graphics/PlatformDisplay.cpp
--- webkitgtk-2.42.1.orig/Source/WebCore/platform/graphics/PlatformDisplay.cpp	2023-09-19 03:27:49.807693000 -0500
+++ webkitgtk-2.42.1/Source/WebCore/platform/graphics/PlatformDisplay.cpp	2023-10-23 13:09:55.996812760 -0500
@@ -374,14 +374,10 @@ void PlatformDisplay::terminateEGLDispla
 EGLImage PlatformDisplay::createEGLImage(EGLContext context, EGLenum target, EGLClientBuffer clientBuffer, const Vector<EGLAttrib>& attributes) const
 {
     if (eglCheckVersion(1, 5)) {
-#if USE(LIBEPOXY)
-        return eglCreateImage(m_eglDisplay, context, target, clientBuffer, attributes.isEmpty() ? nullptr : attributes.data());
-#else
         static PFNEGLCREATEIMAGEPROC s_eglCreateImage = reinterpret_cast<PFNEGLCREATEIMAGEPROC>(eglGetProcAddress("eglCreateImage"));
         if (s_eglCreateImage)
             return s_eglCreateImage(m_eglDisplay, context, target, clientBuffer, attributes.isEmpty() ? nullptr : attributes.data());
         return EGL_NO_IMAGE;
-#endif
     }
 
     if (!m_eglExtensions.KHR_image_base)
@@ -390,40 +386,28 @@ EGLImage PlatformDisplay::createEGLImage
     Vector<EGLint> intAttributes = attributes.map<Vector<EGLint>>([] (EGLAttrib value) {
         return value;
     });
-#if USE(LIBEPOXY)
-    return eglCreateImageKHR(m_eglDisplay, context, target, clientBuffer, intAttributes.isEmpty() ? nullptr : intAttributes.data());
-#else
     static PFNEGLCREATEIMAGEKHRPROC s_eglCreateImageKHR = reinterpret_cast<PFNEGLCREATEIMAGEKHRPROC>(eglGetProcAddress("eglCreateImageKHR"));
     if (s_eglCreateImageKHR)
         return s_eglCreateImageKHR(m_eglDisplay, context, target, clientBuffer, intAttributes.isEmpty() ? nullptr : intAttributes.data());
     return EGL_NO_IMAGE_KHR;
-#endif
 }
 
 bool PlatformDisplay::destroyEGLImage(EGLImage image) const
 {
     if (eglCheckVersion(1, 5)) {
-#if USE(LIBEPOXY)
-        return eglDestroyImage(m_eglDisplay, image);
-#else
         static PFNEGLDESTROYIMAGEPROC s_eglDestroyImage = reinterpret_cast<PFNEGLDESTROYIMAGEPROC>(eglGetProcAddress("eglDestroyImage"));
         if (s_eglDestroyImage)
             return s_eglDestroyImage(m_eglDisplay, image);
         return false;
-#endif
     }
 
     if (!m_eglExtensions.KHR_image_base)
         return false;
 
-#if USE(LIBEPOXY)
-    return eglDestroyImageKHR(m_eglDisplay, image);
-#else
     static PFNEGLDESTROYIMAGEKHRPROC s_eglDestroyImageKHR = reinterpret_cast<PFNEGLDESTROYIMAGEKHRPROC>(eglGetProcAddress("eglDestroyImageKHR"));
     if (s_eglDestroyImageKHR)
         return s_eglDestroyImageKHR(m_eglDisplay, image);
     return false;
-#endif
 }
 
 #if USE(GBM)
