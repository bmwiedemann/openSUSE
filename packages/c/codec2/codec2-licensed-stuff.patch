Index: src/CMakeLists.txt
===================================================================
--- src/CMakeLists.txt.orig
+++ src/CMakeLists.txt
@@ -378,8 +378,8 @@ target_link_libraries(drs232 ${CMAKE_REQ
 add_executable(drs232_ldpc drs232_ldpc.c)
 target_link_libraries(drs232_ldpc ${CMAKE_REQUIRED_LIBRARIES} codec2)
 
-add_definitions(-DHORUS_L2_RX -DINTERLEAVER -DSCRAMBLER)
-add_executable(horus_demod horus_demod.c horus_api.c horus_l2.c fsk.c kiss_fft.c)
+add_definitions(-DHORUS_L2_RX -DINTERLEAVER -DSCRAMBLER -DRUN_TIME_TABLES)
+add_executable(horus_demod horus_demod.c horus_api.c horus_l2.c golay23.c fsk.c kiss_fft.c)
 target_link_libraries(horus_demod ${CMAKE_REQUIRED_LIBRARIES})
 
 install(TARGETS codec2 EXPORT codec2-config
Index: src/golay23.c
===================================================================
--- src/golay23.c.orig
+++ src/golay23.c
@@ -53,7 +53,7 @@ static int inited = 0;
 //since we want to avoid bit-reversing inside syndrome() we bit-reverse the polynomial instead
 #define GOLAY_POLYNOMIAL    0xC75   //AE3 reversed
 
-static int syndrome(int c) {
+int golay23_syndrome(int c) {
     //could probably be done slightly smarter, but works
     int x;
     for (x = 11; x >= 0; x--) {
@@ -85,7 +85,7 @@ static int popcount(unsigned int c) {
 #if defined(NO_TABLES) || defined(RUN_TIME_TABLES)
 static int golay23_encode_no_tables(int c) {
     c <<= 11;
-    return syndrome(c) | c;
+    return golay23_syndrome(c) | c;
 }
 #endif
 
@@ -101,7 +101,7 @@ static int golay23_decode_no_tables(int
 
     for (x = 0; x < 23; x++) {
         int t;
-        int s = syndrome(c);
+        int s = golay23_syndrome(c);
 
         if (popcount(s) <= 3) {
             return unrotate(c ^ s, x) & 0xFFF;
@@ -109,7 +109,7 @@ static int golay23_decode_no_tables(int
 
         for (t = 0; t < 23; t++) {
             int c2 = c ^ (1 << t);
-            int s = syndrome(c2);
+            int s = golay23_syndrome(c2);
 
             if (popcount(s) <= 2) {
                 return unrotate(c2 ^ s, x) & 0xFFF;
@@ -138,13 +138,13 @@ void golay23_init(void) {
     //1-bit errors
     for (x = 0; x < 23; x++) {
         int d = 1<<x;
-        decoding_table[syndrome(d)] = d;
+        decoding_table[golay23_syndrome(d)] = d;
     }
     //2-bit errors
     for (x = 0; x < 22; x++) {
         for (y = x+1; y < 23; y++) {
             int d = (1<<x) | (1<<y);
-            decoding_table[syndrome(d)] = d;
+            decoding_table[golay23_syndrome(d)] = d;
         }
     }
     //3-bit errors
@@ -152,7 +152,7 @@ void golay23_init(void) {
         for (y = x+1; y < 22; y++) {
             for (z = y+1; z < 23; z++) {
                 int d = (1<<x) | (1<<y) | (1<<z);
-                decoding_table[syndrome(d)] = d;
+                decoding_table[golay23_syndrome(d)] = d;
             }
         }
     }
@@ -183,7 +183,7 @@ int  golay23_decode(int c) {
     return unrotate(golay23_decode_no_tables(c), 11);
 #else
     //message is shifted 11 places left in the return value
-    return c ^ decoding_table[syndrome(c)];
+    return c ^ decoding_table[golay23_syndrome(c)];
 #endif
 }
 
Index: src/golay23.h
===================================================================
--- src/golay23.h.orig
+++ src/golay23.h
@@ -36,6 +36,7 @@ void golay23_init(void);
 int  golay23_encode(int data);
 int  golay23_decode(int received_codeword);
 int  golay23_count_errors(int recd_codeword, int corrected_codeword);
+int  golay23_syndrome(int c);
 
 #ifdef __cplusplus
 }
Index: src/horus_l2.c
===================================================================
--- src/horus_l2.c.orig
+++ src/horus_l2.c
@@ -9,9 +9,6 @@
   data and parity bits, pre-pends a Unique Word for modem sync.
   Caller is responsible for providing storage for output packet.
 
-  [ ] code based interleaver
-  [ ] test correction of 1,2 & 3 error patterms    
-
   1/ Unit test on a PC:
 
      $ gcc horus_l2.c -o horus_l2 -Wall -DHORUS_L2_UNITTEST
@@ -29,24 +26,24 @@
   2/ To build with just the tx function, ie for linking with the payload
   firmware:
 
-    $ gcc horus_l2.c -c -Wall
+    $ gcc horus_l2.c golay23.c -c -Wall
     
   By default the RX side is #ifdef-ed out, leaving the minimal amount
   of code for tx.
 
   3/ Generate some tx_bits as input for testing with fsk_horus:
  
-    $ gcc horus_l2.c -o horus_l2 -Wall -DGEN_TX_BITS -DSCRAMBLER
+    $ gcc horus_l2.c golay23.c -o horus_l2 -Wall -DGEN_TX_BITS -DSCRAMBLER
     $ ./horus_l2
     $ more ../octave/horus_tx_bits_binary.txt
    
   4/ Unit testing interleaver:
 
-    $ gcc horus_l2.c -o horus_l2 -Wall -DINTERLEAVER -DTEST_INTERLEAVER -DSCRAMBLER
+    $ gcc horus_l2.c golay23.c -o horus_l2 -Wall -DINTERLEAVER -DTEST_INTERLEAVER -DSCRAMBLER
 
   5/ Compile for use as decoder called by fsk_horus.m and fsk_horus_stream.m:
 
-    $ gcc horus_l2.c -o horus_l2 -Wall -DDEC_RX_BITS -DHORUS_L2_RX
+    $ gcc horus_l2.c golay23.c -o horus_l2 -Wall -DDEC_RX_BITS -DHORUS_L2_RX
 
 \*---------------------------------------------------------------------------*/
 
@@ -56,22 +53,23 @@
 #include <string.h>
 #include <stdint.h>
 #include "horus_l2.h"
+#include "golay23.h"
+
 
 #ifdef HORUS_L2_UNITTEST
 #define HORUS_L2_RX
 #endif
 
-#define RUN_TIME_TABLES
-
 static char uw[] = {'$','$'};
 
 /* Function Prototypes ------------------------------------------------*/
 
-int32_t get_syndrome(int32_t pattern);
-void golay23_init(void);
-int golay23_decode(int received_codeword);
+#ifdef INTERLEAVER
 void interleave(unsigned char *inout, int nbytes, int dir);
+#endif
+#ifdef SCRAMBLER
 void scramble(unsigned char *inout, int nbytes);
+#endif
 
 /* Functions ----------------------------------------------------------*/
 
@@ -177,7 +175,7 @@ int horus_l2_encode_tx_packet(unsigned c
             #ifdef DEBUG0
             fprintf(stderr, "  ningolay: %d ingolay: 0x%04x\n", ningolay, ingolay);
             #endif
-            golayparity = get_syndrome(ingolay<<11);
+            golayparity = golay23_syndrome(ingolay<<11);
             ingolay = 0;
 
             #ifdef DEBUG0
@@ -219,7 +217,7 @@ int horus_l2_encode_tx_packet(unsigned c
 
     if (ningolay % 12) {
         ingolay >>= 1;
-        golayparity = get_syndrome(ingolay<<12);
+        golayparity = golay23_syndrome(ingolay<<12);
         #ifdef DEBUG0
         fprintf(stderr, "  ningolay: %d ingolay: 0x%04x\n", ningolay, ingolay);
         fprintf(stderr, "  golayparity: 0x%04x\n", golayparity);
@@ -292,8 +290,10 @@ void horus_l2_decode_rx_packet(unsigned
     unsigned char *pin  = input_rx_data;
     int            ninbit, ingolay, ningolay, paritybyte, nparitybits;
     int            ninbyte, shift, inbit, golayparitybit, i, outbit, outbyte, noutbits, outdata;
+    #if defined(SCRAMBLER) || defined(INTERLEAVER)
     int num_tx_data_bytes = horus_l2_get_num_tx_data_bytes(num_payload_data_bytes);
-
+    #endif
+    
     /* optional scrambler and interleaver - we dont interleave UW */
 
     #ifdef SCRAMBLER
@@ -878,291 +878,6 @@ int main(void) {
 }
 #endif
 
-/*---------------------------------------------------------------------------*\
-
-                                   GOLAY FUNCTIONS
-
-\*---------------------------------------------------------------------------*/
-
-/* File:    golay23.c
- * Title:   Encoder/decoder for a binary (23,12,7) Golay code
- * Author:  Robert Morelos-Zaragoza (robert@spectra.eng.hawaii.edu)
- * Date:    August 1994
- *
- * The binary (23,12,7) Golay code is an example of a perfect code, that is,
- * the number of syndromes equals the number of correctable error patterns.
- * The minimum distance is 7, so all error patterns of Hamming weight up to
- * 3 can be corrected. The total number of these error patterns is:
- *
- *       Number of errors         Number of patterns
- *       ----------------         ------------------
- *              0                         1
- *              1                        23
- *              2                       253
- *              3                      1771
- *                                     ----
- *    Total number of error patterns = 2048 = 2^{11} = number of syndromes
- *                                               --
- *                number of redundant bits -------^
- *
- * Because of its relatively low length (23), dimension (12) and number of
- * redundant bits (11), the binary (23,12,7) Golay code can be encoded and
- * decoded simply by using look-up tables. The program below uses a 16K
- * encoding table and an 8K decoding table.
- *
- * For more information, suggestions, or other ideas on implementing error
- * correcting codes, please contact me at (I'm temporarily in Japan, but
- * below is my U.S. address):
- *
- *                    Robert Morelos-Zaragoza
- *                    770 S. Post Oak Ln. #200
- *                      Houston, Texas 77056
- *
- *             email: robert@spectra.eng.hawaii.edu
- *
- *       Homework: Add an overall parity-check bit to get the (24,12,8)
- *                 extended Golay code.
- *
- * COPYRIGHT NOTICE: This computer program is free for non-commercial purposes.
- * You may implement this program for any non-commercial application. You may
- * also implement this program for commercial purposes, provided that you
- * obtain my written permission. Any modification of this program is covered
- * by this copyright.
- *
- * ==   Copyright (c) 1994  Robert Morelos-Zaragoza. All rights reserved.   ==
- */
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#define X22             0x00400000   /* vector representation of X^{22} */
-#define X11             0x00000800   /* vector representation of X^{11} */
-#define MASK12          0xfffff800   /* auxiliary vector for testing */
-#define GENPOL          0x00000c75   /* generator polinomial, g(x) */
-
-/* Global variables:
- *
- * pattern = error pattern, or information, or received vector
- * encoding_table[] = encoding table
- * decoding_table[] = decoding table
- * data = information bits, i(x)
- * codeword = code bits = x^{11}i(x) + (x^{11}i(x) mod g(x))
- * numerr = number of errors = Hamming weight of error polynomial e(x)
- * position[] = error positions in the vector representation of e(x)
- * recd = representation of corrupted received polynomial r(x) = c(x) + e(x)
- * decerror = number of decoding errors
- * a[] = auxiliary array to generate correctable error patterns
- */
-
-#ifdef HORUS_L2_RX
-static int inited =  0;
-
-#ifdef RUN_TIME_TABLES
-static int encoding_table[4096], decoding_table[2048];
-#else
-#include "golayenctable.h"
-#include "golaydectable.h"
-#endif
-
-#ifdef RUN_TIME_TABLES
-static int arr2int(int a[], int r)
-/*
- * Convert a binary vector of Hamming weight r, and nonzero positions in
- * array a[1]...a[r], to a long integer \sum_{i=1}^r 2^{a[i]-1}.
- */
-{
-   int i;
-   long mul, result = 0, temp;
-
-   for (i=1; i<=r; i++) {
-      mul = 1;
-      temp = a[i]-1;
-      while (temp--)
-         mul = mul << 1;
-      result += mul;
-      }
-   return(result);
-}
-#endif
-#endif
-
-#ifdef HORUS_L2_RX
-void nextcomb(int n, int r, int a[])
-/*
- * Calculate next r-combination of an n-set.
- */
-{
-  int  i, j;
-
-  a[r]++;
-  if (a[r] <= n)
-      return;
-  j = r - 1;
-  while (a[j] == n - r + j)
-     j--;
-  for (i = r; i >= j; i--)
-      a[i] = a[j] + i - j + 1;
-  return;
-}
-#endif
-
-int32_t get_syndrome(int32_t pattern)
-/*
- * Compute the syndrome corresponding to the given pattern, i.e., the
- * remainder after dividing the pattern (when considering it as the vector
- * representation of a polynomial) by the generator polynomial, GENPOL.
- * In the program this pattern has several meanings: (1) pattern = infomation
- * bits, when constructing the encoding table; (2) pattern = error pattern,
- * when constructing the decoding table; and (3) pattern = received vector, to
- * obtain its syndrome in decoding.
- */
-{
-    int32_t aux = X22;
-
-    if (pattern >= X11)
-       while (pattern & MASK12) {
-           while (!(aux & pattern))
-              aux = aux >> 1;
-           pattern ^= (aux/X11) * GENPOL;
-           }
-    return(pattern);
-}
-
-#ifdef HORUS_L2_RX
-
-/*---------------------------------------------------------------------------*\
-
-  FUNCTION....: golay23_init()
-  AUTHOR......: David Rowe
-  DATE CREATED: 3 March 2013
-
-  Call this once when you start your program to init the Golay tables.
-
-\*---------------------------------------------------------------------------*/
-
-void golay23_init(void) {
-#ifdef RUN_TIME_TABLES
-   int  i;
-   long temp;
-   int  a[4];
-   int  pattern;
-
-   /*
-    * ---------------------------------------------------------------------
-    *                  Generate ENCODING TABLE
-    *
-    * An entry to the table is an information vector, a 32-bit integer,
-    * whose 12 least significant positions are the information bits. The
-    * resulting value is a codeword in the (23,12,7) Golay code: A 32-bit
-    * integer whose 23 least significant bits are coded bits: Of these, the
-    * 12 most significant bits are information bits and the 11 least
-    * significant bits are redundant bits (systematic encoding).
-    * ---------------------------------------------------------------------
-    */
-    for (pattern = 0; pattern < 4096; pattern++) {
-        temp = pattern << 11;          /* multiply information by X^{11} */
-        encoding_table[pattern] = temp + get_syndrome(temp);/* add redundancy */
-        }
-
-   /*
-    * ---------------------------------------------------------------------
-    *                  Generate DECODING TABLE
-    *
-    * An entry to the decoding table is a syndrome and the resulting value
-    * is the most likely error pattern. First an error pattern is generated.
-    * Then its syndrome is calculated and used as a pointer to the table
-    * where the error pattern value is stored.
-    * ---------------------------------------------------------------------
-    *
-    * (1) Error patterns of WEIGHT 1 (SINGLE ERRORS)
-    */
-    decoding_table[0] = 0;
-    decoding_table[1] = 1;
-    temp = 1;
-    for (i=2; i<= 23; i++) {
-        temp *= 2;
-        decoding_table[get_syndrome(temp)] = temp;
-        }
-   /*
-    * (2) Error patterns of WEIGHT 2 (DOUBLE ERRORS)
-    */
-    a[1] = 1; a[2] = 2;
-    temp = arr2int(a,2);
-    decoding_table[get_syndrome(temp)] = temp;
-    for (i=1; i<253; i++) {
-        nextcomb(23,2,a);
-        temp = arr2int(a,2);
-        decoding_table[get_syndrome(temp)] = temp;
-        }
-   /*
-    * (3) Error patterns of WEIGHT 3 (TRIPLE ERRORS)
-    */
-    a[1] = 1; a[2] = 2; a[3] = 3;
-    temp = arr2int(a,3);
-    decoding_table[get_syndrome(temp)] = temp;
-    for (i=1; i<1771; i++) {
-        nextcomb(23,3,a);
-        temp = arr2int(a,3);
-        decoding_table[get_syndrome(temp)] = temp;
-    }
-#endif
-    inited = 1;
-}
-
-/*---------------------------------------------------------------------------*\
-
-  FUNCTION....: golay23_encode()
-  AUTHOR......: David Rowe
-  DATE CREATED: 3 March 2013
-
-  Given 12 bits of data retiurns a 23 bit codeword for transmission
-  over the channel.
-
-\*---------------------------------------------------------------------------*/
-
-int golay23_encode(int data) {
-    assert(inited);
-    assert(data <= 0xfff);
-
-    //printf("data: 0x%x\n", data);
-    return encoding_table[data];
-}
-
-/*---------------------------------------------------------------------------*\
-
-  FUNCTION....: golay23_decode()
-  AUTHOR......: David Rowe
-  DATE CREATED: 3 March 2013
-
-  Given a 23 bit received codeword, returns the 12 bit corrected data.
-
-\*---------------------------------------------------------------------------*/
-
-int golay23_decode(int received_codeword) {
-    assert(inited);
-    assert((received_codeword < (1<<23)) && (received_codeword >= 0));
-
-    //printf("syndrome: 0x%x\n", get_syndrome(received_codeword));
-    return received_codeword ^= decoding_table[get_syndrome(received_codeword)];
-}
-
-int golay23_count_errors(int recd_codeword, int corrected_codeword)
-{
-    int errors = 0;
-    int diff, i;
-
-    diff = recd_codeword ^ corrected_codeword;
-    for(i=0; i<23; i++) {
-        if (diff & 0x1)
-            errors++;
-        diff >>= 1;
-    }
-
-    return errors;
-}
-
-#endif
-
 // from http://stackoverflow.com/questions/10564491/function-to-calculate-a-crc16-checksum
 
 unsigned short horus_l2_gen_crc16(unsigned char* data_p, unsigned char length) {
