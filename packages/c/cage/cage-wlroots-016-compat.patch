From 59a80818204eccc0527f1f166cc52e55eab456d4 Mon Sep 17 00:00:00 2001
From: Phil Jones <philj56@gmail.com>
Date: Thu, 20 Jan 2022 11:13:10 +0000
Subject: [PATCH 01/12] Explicitly create wlr_subcompositor.

Following wlroots b6f43ab2, the subcompositor must now be created
explicitly, rather than being handled by wlr_compositor_create.
---
 cage.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/cage.c b/cage.c
index 95f0cc7..6f23431 100644
--- a/cage.c
+++ b/cage.c
@@ -32,6 +32,7 @@
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_screencopy_v1.h>
 #include <wlr/types/wlr_server_decoration.h>
+#include <wlr/types/wlr_subcompositor.h>
 #include <wlr/types/wlr_viewporter.h>
 #if CAGE_HAS_XWAYLAND
 #include <wlr/types/wlr_xcursor_manager.h>
@@ -254,6 +255,7 @@ main(int argc, char *argv[])
 	struct wl_event_source *sigterm_source = NULL;
 	struct wl_event_source *sigchld_source = NULL;
 	struct wlr_compositor *compositor = NULL;
+	struct wlr_subcompositor *subcompositor = NULL;
 	struct wlr_data_device_manager *data_device_manager = NULL;
 	struct wlr_server_decoration_manager *server_decoration_manager = NULL;
 	struct wlr_xdg_decoration_manager_v1 *xdg_decoration_manager = NULL;
@@ -351,6 +353,13 @@ main(int argc, char *argv[])
 		goto end;
 	}
 
+	subcompositor = wlr_subcompositor_create(server.wl_display);
+	if (!subcompositor) {
+		wlr_log(WLR_ERROR, "Unable to create the wlroots subcompositor");
+		ret = 1;
+		goto end;
+	}
+
 	data_device_manager = wlr_data_device_manager_create(server.wl_display);
 	if (!data_device_manager) {
 		wlr_log(WLR_ERROR, "Unable to create the data device manager");

From db53fabe329f0379d0c97f16a98fabd7953d88e6 Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <orzechowski.alexander@gmail.com>
Date: Wed, 12 Oct 2022 03:37:05 -0400
Subject: [PATCH 02/12] seat: Port 0.16 device changes

---
 seat.c | 108 ++++++++++++++++++++++++++++-----------------------------
 seat.h |   4 +--
 2 files changed, 55 insertions(+), 57 deletions(-)

diff --git a/seat.c b/seat.c
index 4dce511..9aa2d6e 100644
--- a/seat.c
+++ b/seat.c
@@ -118,16 +118,16 @@ update_capabilities(struct cg_seat *seat)
 }
 
 static void
-map_input_device_to_output(struct cg_seat *seat, struct wlr_input_device *device)
+map_input_device_to_output(struct cg_seat *seat, struct wlr_input_device *device, const char *output_name)
 {
-	if (!device->output_name) {
+	if (!output_name) {
 		wlr_log(WLR_INFO, "Input device %s cannot be mapped to an output device\n", device->name);
 		return;
 	}
 
 	struct cg_output *output;
 	wl_list_for_each (output, &seat->server->outputs, link) {
-		if (strcmp(device->output_name, output->wlr_output->name) == 0) {
+		if (strcmp(output_name, output->wlr_output->name) == 0) {
 			wlr_log(WLR_INFO, "Mapping input device %s to output device %s\n", device->name,
 				output->wlr_output->name);
 			wlr_cursor_map_input_to_output(seat->cursor, device, output->wlr_output);
@@ -145,7 +145,7 @@ handle_touch_destroy(struct wl_listener *listener, void *data)
 	struct cg_seat *seat = touch->seat;
 
 	wl_list_remove(&touch->link);
-	wlr_cursor_detach_input_device(seat->cursor, touch->device);
+	wlr_cursor_detach_input_device(seat->cursor, &touch->touch->base);
 	wl_list_remove(&touch->destroy.link);
 	free(touch);
 
@@ -153,7 +153,7 @@ handle_touch_destroy(struct wl_listener *listener, void *data)
 }
 
 static void
-handle_new_touch(struct cg_seat *seat, struct wlr_input_device *device)
+handle_new_touch(struct cg_seat *seat, struct wlr_touch *wlr_touch)
 {
 	struct cg_touch *touch = calloc(1, sizeof(struct cg_touch));
 	if (!touch) {
@@ -162,14 +162,14 @@ handle_new_touch(struct cg_seat *seat, struct wlr_input_device *device)
 	}
 
 	touch->seat = seat;
-	touch->device = device;
-	wlr_cursor_attach_input_device(seat->cursor, device);
+	touch->touch = wlr_touch;
+	wlr_cursor_attach_input_device(seat->cursor, &wlr_touch->base);
 
 	wl_list_insert(&seat->touch, &touch->link);
 	touch->destroy.notify = handle_touch_destroy;
-	wl_signal_add(&touch->device->events.destroy, &touch->destroy);
+	wl_signal_add(&wlr_touch->base.events.destroy, &touch->destroy);
 
-	map_input_device_to_output(seat, device);
+	map_input_device_to_output(seat, &wlr_touch->base, wlr_touch->output_name);
 }
 
 static void
@@ -179,7 +179,7 @@ handle_pointer_destroy(struct wl_listener *listener, void *data)
 	struct cg_seat *seat = pointer->seat;
 
 	wl_list_remove(&pointer->link);
-	wlr_cursor_detach_input_device(seat->cursor, pointer->device);
+	wlr_cursor_detach_input_device(seat->cursor, &pointer->pointer->base);
 	wl_list_remove(&pointer->destroy.link);
 	free(pointer);
 
@@ -187,7 +187,7 @@ handle_pointer_destroy(struct wl_listener *listener, void *data)
 }
 
 static void
-handle_new_pointer(struct cg_seat *seat, struct wlr_input_device *device)
+handle_new_pointer(struct cg_seat *seat, struct wlr_pointer *wlr_pointer)
 {
 	struct cg_pointer *pointer = calloc(1, sizeof(struct cg_pointer));
 	if (!pointer) {
@@ -196,21 +196,21 @@ handle_new_pointer(struct cg_seat *seat, struct wlr_input_device *device)
 	}
 
 	pointer->seat = seat;
-	pointer->device = device;
-	wlr_cursor_attach_input_device(seat->cursor, device);
+	pointer->pointer = wlr_pointer;
+	wlr_cursor_attach_input_device(seat->cursor, &wlr_pointer->base);
 
 	wl_list_insert(&seat->pointers, &pointer->link);
 	pointer->destroy.notify = handle_pointer_destroy;
-	wl_signal_add(&device->events.destroy, &pointer->destroy);
+	wl_signal_add(&wlr_pointer->base.events.destroy, &pointer->destroy);
 
-	map_input_device_to_output(seat, device);
+	map_input_device_to_output(seat, &wlr_pointer->base, wlr_pointer->output_name);
 }
 
 static void
-handle_modifier_event(struct wlr_input_device *device, struct cg_seat *seat)
+handle_modifier_event(struct wlr_keyboard *keyboard, struct cg_seat *seat)
 {
-	wlr_seat_set_keyboard(seat->seat, device);
-	wlr_seat_keyboard_notify_modifiers(seat->seat, &device->keyboard->modifiers);
+	wlr_seat_set_keyboard(seat->seat, keyboard);
+	wlr_seat_keyboard_notify_modifiers(seat->seat, &keyboard->modifiers);
 
 	wlr_idle_notify_activity(seat->server->idle, seat->seat);
 }
@@ -240,18 +240,18 @@ handle_keybinding(struct cg_server *server, xkb_keysym_t sym)
 }
 
 static void
-handle_key_event(struct wlr_input_device *device, struct cg_seat *seat, void *data)
+handle_key_event(struct wlr_keyboard *keyboard, struct cg_seat *seat, void *data)
 {
-	struct wlr_event_keyboard_key *event = data;
+	struct wlr_keyboard_key_event *event = data;
 
 	/* Translate from libinput keycode to an xkbcommon keycode. */
 	xkb_keycode_t keycode = event->keycode + 8;
 
 	const xkb_keysym_t *syms;
-	int nsyms = xkb_state_key_get_syms(device->keyboard->xkb_state, keycode, &syms);
+	int nsyms = xkb_state_key_get_syms(keyboard->xkb_state, keycode, &syms);
 
 	bool handled = false;
-	uint32_t modifiers = wlr_keyboard_get_modifiers(device->keyboard);
+	uint32_t modifiers = wlr_keyboard_get_modifiers(keyboard);
 	if ((modifiers & WLR_MODIFIER_ALT) && event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
 		/* If Alt is held down and this button was pressed, we
 		 * attempt to process it as a compositor
@@ -263,7 +263,7 @@ handle_key_event(struct wlr_input_device *device, struct cg_seat *seat, void *da
 
 	if (!handled) {
 		/* Otherwise, we pass it along to the client. */
-		wlr_seat_set_keyboard(seat->seat, device);
+		wlr_seat_set_keyboard(seat->seat, keyboard);
 		wlr_seat_keyboard_notify_key(seat->seat, event->time_msec, event->keycode, event->state);
 	}
 
@@ -274,25 +274,23 @@ static void
 handle_keyboard_group_key(struct wl_listener *listener, void *data)
 {
 	struct cg_keyboard_group *cg_group = wl_container_of(listener, cg_group, key);
-	handle_key_event(cg_group->wlr_group->input_device, cg_group->seat, data);
+	handle_key_event(&cg_group->wlr_group->keyboard, cg_group->seat, data);
 }
 
 static void
 handle_keyboard_group_modifiers(struct wl_listener *listener, void *data)
 {
 	struct cg_keyboard_group *group = wl_container_of(listener, group, modifiers);
-	handle_modifier_event(group->wlr_group->input_device, group->seat);
+	handle_modifier_event(&group->wlr_group->keyboard, group->seat);
 }
 
 static void
-cg_keyboard_group_add(struct wlr_input_device *device, struct cg_seat *seat)
+cg_keyboard_group_add(struct wlr_keyboard *keyboard, struct cg_seat *seat)
 {
-	struct wlr_keyboard *wlr_keyboard = device->keyboard;
-
 	struct cg_keyboard_group *group;
 	wl_list_for_each (group, &seat->keyboard_groups, link) {
 		struct wlr_keyboard_group *wlr_group = group->wlr_group;
-		if (wlr_keyboard_group_add_keyboard(wlr_group, wlr_keyboard)) {
+		if (wlr_keyboard_group_add_keyboard(wlr_group, keyboard)) {
 			wlr_log(WLR_DEBUG, "Added new keyboard to existing group");
 			return;
 		}
@@ -313,14 +311,14 @@ cg_keyboard_group_add(struct wlr_input_device *device, struct cg_seat *seat)
 	}
 
 	cg_group->wlr_group->data = cg_group;
-	wlr_keyboard_set_keymap(&cg_group->wlr_group->keyboard, device->keyboard->keymap);
+	wlr_keyboard_set_keymap(&cg_group->wlr_group->keyboard, keyboard->keymap);
 
-	wlr_keyboard_set_repeat_info(&cg_group->wlr_group->keyboard, wlr_keyboard->repeat_info.rate,
-				     wlr_keyboard->repeat_info.delay);
+	wlr_keyboard_set_repeat_info(&cg_group->wlr_group->keyboard, keyboard->repeat_info.rate,
+				     keyboard->repeat_info.delay);
 
 	wlr_log(WLR_DEBUG, "Created keyboard group");
 
-	wlr_keyboard_group_add_keyboard(cg_group->wlr_group, wlr_keyboard);
+	wlr_keyboard_group_add_keyboard(cg_group->wlr_group, keyboard);
 	wl_list_insert(&seat->keyboard_groups, &cg_group->link);
 
 	wl_signal_add(&cg_group->wlr_group->keyboard.events.key, &cg_group->key);
@@ -338,7 +336,7 @@ cg_keyboard_group_add(struct wlr_input_device *device, struct cg_seat *seat)
 }
 
 static void
-handle_new_keyboard(struct cg_seat *seat, struct wlr_input_device *device)
+handle_new_keyboard(struct cg_seat *seat, struct wlr_keyboard *keyboard)
 {
 	struct xkb_context *context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
 	if (!context) {
@@ -353,15 +351,15 @@ handle_new_keyboard(struct cg_seat *seat, struct wlr_input_device *device)
 		return;
 	}
 
-	wlr_keyboard_set_keymap(device->keyboard, keymap);
+	wlr_keyboard_set_keymap(keyboard, keymap);
 
 	xkb_keymap_unref(keymap);
 	xkb_context_unref(context);
-	wlr_keyboard_set_repeat_info(device->keyboard, 25, 600);
+	wlr_keyboard_set_repeat_info(keyboard, 25, 600);
 
-	cg_keyboard_group_add(device, seat);
+	cg_keyboard_group_add(keyboard, seat);
 
-	wlr_seat_set_keyboard(seat->seat, device);
+	wlr_seat_set_keyboard(seat->seat, keyboard);
 }
 
 static void
@@ -372,13 +370,13 @@ handle_new_input(struct wl_listener *listener, void *data)
 
 	switch (device->type) {
 	case WLR_INPUT_DEVICE_KEYBOARD:
-		handle_new_keyboard(seat, device);
+		handle_new_keyboard(seat, wlr_keyboard_from_input_device(device));
 		break;
 	case WLR_INPUT_DEVICE_POINTER:
-		handle_new_pointer(seat, device);
+		handle_new_pointer(seat, wlr_pointer_from_input_device(device));
 		break;
 	case WLR_INPUT_DEVICE_TOUCH:
-		handle_new_touch(seat, device);
+		handle_new_touch(seat, wlr_touch_from_input_device(device));
 		break;
 	case WLR_INPUT_DEVICE_SWITCH:
 		wlr_log(WLR_DEBUG, "Switch input is not implemented");
@@ -433,10 +431,10 @@ static void
 handle_touch_down(struct wl_listener *listener, void *data)
 {
 	struct cg_seat *seat = wl_container_of(listener, seat, touch_down);
-	struct wlr_event_touch_down *event = data;
+	struct wlr_touch_down_event *event = data;
 
 	double lx, ly;
-	wlr_cursor_absolute_to_layout_coords(seat->cursor, event->device, event->x, event->y, &lx, &ly);
+	wlr_cursor_absolute_to_layout_coords(seat->cursor, &event->touch->base, event->x, event->y, &lx, &ly);
 
 	double sx, sy;
 	struct wlr_surface *surface;
@@ -451,7 +449,7 @@ handle_touch_down(struct wl_listener *listener, void *data)
 		seat->touch_id = event->touch_id;
 		seat->touch_lx = lx;
 		seat->touch_ly = ly;
-		press_cursor_button(seat, event->device, event->time_msec, BTN_LEFT, WLR_BUTTON_PRESSED, lx, ly);
+		press_cursor_button(seat, &event->touch->base, event->time_msec, BTN_LEFT, WLR_BUTTON_PRESSED, lx, ly);
 	}
 
 	wlr_idle_notify_activity(seat->server->idle, seat->seat);
@@ -461,14 +459,14 @@ static void
 handle_touch_up(struct wl_listener *listener, void *data)
 {
 	struct cg_seat *seat = wl_container_of(listener, seat, touch_up);
-	struct wlr_event_touch_up *event = data;
+	struct wlr_touch_up_event *event = data;
 
 	if (!wlr_seat_touch_get_point(seat->seat, event->touch_id)) {
 		return;
 	}
 
 	if (wlr_seat_touch_num_points(seat->seat) == 1) {
-		press_cursor_button(seat, event->device, event->time_msec, BTN_LEFT, WLR_BUTTON_RELEASED,
+		press_cursor_button(seat, &event->touch->base, event->time_msec, BTN_LEFT, WLR_BUTTON_RELEASED,
 				    seat->touch_lx, seat->touch_ly);
 	}
 
@@ -480,14 +478,14 @@ static void
 handle_touch_motion(struct wl_listener *listener, void *data)
 {
 	struct cg_seat *seat = wl_container_of(listener, seat, touch_motion);
-	struct wlr_event_touch_motion *event = data;
+	struct wlr_touch_motion_event *event = data;
 
 	if (!wlr_seat_touch_get_point(seat->seat, event->touch_id)) {
 		return;
 	}
 
 	double lx, ly;
-	wlr_cursor_absolute_to_layout_coords(seat->cursor, event->device, event->x, event->y, &lx, &ly);
+	wlr_cursor_absolute_to_layout_coords(seat->cursor, &event->touch->base, event->x, event->y, &lx, &ly);
 
 	double sx, sy;
 	struct wlr_surface *surface;
@@ -521,7 +519,7 @@ static void
 handle_cursor_axis(struct wl_listener *listener, void *data)
 {
 	struct cg_seat *seat = wl_container_of(listener, seat, cursor_axis);
-	struct wlr_event_pointer_axis *event = data;
+	struct wlr_pointer_axis_event *event = data;
 
 	wlr_seat_pointer_notify_axis(seat->seat, event->time_msec, event->orientation, event->delta,
 				     event->delta_discrete, event->source);
@@ -532,10 +530,10 @@ static void
 handle_cursor_button(struct wl_listener *listener, void *data)
 {
 	struct cg_seat *seat = wl_container_of(listener, seat, cursor_button);
-	struct wlr_event_pointer_button *event = data;
+	struct wlr_pointer_button_event *event = data;
 
 	wlr_seat_pointer_notify_button(seat->seat, event->time_msec, event->button, event->state);
-	press_cursor_button(seat, event->device, event->time_msec, event->button, event->state, seat->cursor->x,
+	press_cursor_button(seat, &event->pointer->base, event->time_msec, event->button, event->state, seat->cursor->x,
 			    seat->cursor->y);
 	wlr_idle_notify_activity(seat->server->idle, seat->seat);
 }
@@ -569,9 +567,9 @@ static void
 handle_cursor_motion_absolute(struct wl_listener *listener, void *data)
 {
 	struct cg_seat *seat = wl_container_of(listener, seat, cursor_motion_absolute);
-	struct wlr_event_pointer_motion_absolute *event = data;
+	struct wlr_pointer_motion_absolute_event *event = data;
 
-	wlr_cursor_warp_absolute(seat->cursor, event->device, event->x, event->y);
+	wlr_cursor_warp_absolute(seat->cursor, &event->pointer->base, event->x, event->y);
 	process_cursor_motion(seat, event->time_msec);
 	wlr_idle_notify_activity(seat->server->idle, seat->seat);
 }
@@ -580,9 +578,9 @@ static void
 handle_cursor_motion(struct wl_listener *listener, void *data)
 {
 	struct cg_seat *seat = wl_container_of(listener, seat, cursor_motion);
-	struct wlr_event_pointer_motion *event = data;
+	struct wlr_pointer_motion_event *event = data;
 
-	wlr_cursor_move(seat->cursor, event->device, event->delta_x, event->delta_y);
+	wlr_cursor_move(seat->cursor, &event->pointer->base, event->delta_x, event->delta_y);
 	process_cursor_motion(seat, event->time_msec);
 	wlr_idle_notify_activity(seat->server->idle, seat->seat);
 }
diff --git a/seat.h b/seat.h
index 5fb2db3..479dbaf 100644
--- a/seat.h
+++ b/seat.h
@@ -60,7 +60,7 @@ struct cg_keyboard_group {
 struct cg_pointer {
 	struct wl_list link; // seat::pointers
 	struct cg_seat *seat;
-	struct wlr_input_device *device;
+	struct wlr_pointer *pointer;
 
 	struct wl_listener destroy;
 };
@@ -68,7 +68,7 @@ struct cg_pointer {
 struct cg_touch {
 	struct wl_list link; // seat::touch
 	struct cg_seat *seat;
-	struct wlr_input_device *device;
+	struct wlr_touch *touch;
 
 	struct wl_listener destroy;
 };

From 3ccfee5cb23fcfa15848a9a63d77f3eebe3f2e19 Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <orzechowski.alexander@gmail.com>
Date: Wed, 12 Oct 2022 04:00:11 -0400
Subject: [PATCH 03/12] xdg_shell: Port 0.16 xdg_toplevel changes

---
 xdg_shell.c | 36 ++++++++++++++++--------------------
 xdg_shell.h |  2 +-
 2 files changed, 17 insertions(+), 21 deletions(-)

diff --git a/xdg_shell.c b/xdg_shell.c
index ede71f4..fcb3745 100644
--- a/xdg_shell.c
+++ b/xdg_shell.c
@@ -94,7 +94,7 @@ static char *
 get_title(struct cg_view *view)
 {
 	struct cg_xdg_shell_view *xdg_shell_view = xdg_shell_view_from_view(view);
-	return xdg_shell_view->xdg_surface->toplevel->title;
+	return xdg_shell_view->xdg_toplevel->title;
 }
 
 static void
@@ -103,7 +103,7 @@ get_geometry(struct cg_view *view, int *width_out, int *height_out)
 	struct cg_xdg_shell_view *xdg_shell_view = xdg_shell_view_from_view(view);
 	struct wlr_box geom;
 
-	wlr_xdg_surface_get_geometry(xdg_shell_view->xdg_surface, &geom);
+	wlr_xdg_surface_get_geometry(xdg_shell_view->xdg_toplevel->base, &geom);
 	*width_out = geom.width;
 	*height_out = geom.height;
 }
@@ -112,12 +112,9 @@ static bool
 is_primary(struct cg_view *view)
 {
 	struct cg_xdg_shell_view *xdg_shell_view = xdg_shell_view_from_view(view);
-	struct wlr_xdg_surface *xdg_surface = xdg_shell_view->xdg_surface;
+	struct wlr_xdg_toplevel *parent = xdg_shell_view->xdg_toplevel->parent;
 
-	struct wlr_xdg_surface *parent = xdg_surface->toplevel->parent;
-	enum wlr_xdg_surface_role role = xdg_surface->role;
-
-	return parent == NULL && role == WLR_XDG_SURFACE_ROLE_TOPLEVEL;
+	return parent == NULL;
 }
 
 static bool
@@ -127,14 +124,13 @@ is_transient_for(struct cg_view *child, struct cg_view *parent)
 		return false;
 	}
 	struct cg_xdg_shell_view *_child = xdg_shell_view_from_view(child);
-	struct wlr_xdg_surface *xdg_surface = _child->xdg_surface;
+	struct wlr_xdg_toplevel *xdg_toplevel = _child->xdg_toplevel;
 	struct cg_xdg_shell_view *_parent = xdg_shell_view_from_view(parent);
-	struct wlr_xdg_surface *parent_xdg_surface = _parent->xdg_surface;
-	while (xdg_surface) {
-		if (xdg_surface->toplevel->parent == parent_xdg_surface) {
+	while (xdg_toplevel) {
+		if (xdg_toplevel->parent == _parent->xdg_toplevel) {
 			return true;
 		}
-		xdg_surface = xdg_surface->toplevel->parent;
+		xdg_toplevel = xdg_toplevel->parent;
 	}
 	return false;
 }
@@ -143,15 +139,15 @@ static void
 activate(struct cg_view *view, bool activate)
 {
 	struct cg_xdg_shell_view *xdg_shell_view = xdg_shell_view_from_view(view);
-	wlr_xdg_toplevel_set_activated(xdg_shell_view->xdg_surface, activate);
+	wlr_xdg_toplevel_set_activated(xdg_shell_view->xdg_toplevel, activate);
 }
 
 static void
 maximize(struct cg_view *view, int output_width, int output_height)
 {
 	struct cg_xdg_shell_view *xdg_shell_view = xdg_shell_view_from_view(view);
-	wlr_xdg_toplevel_set_size(xdg_shell_view->xdg_surface, output_width, output_height);
-	wlr_xdg_toplevel_set_maximized(xdg_shell_view->xdg_surface, true);
+	wlr_xdg_toplevel_set_size(xdg_shell_view->xdg_toplevel, output_width, output_height);
+	wlr_xdg_toplevel_set_maximized(xdg_shell_view->xdg_toplevel, true);
 }
 
 static void
@@ -172,9 +168,9 @@ handle_xdg_shell_surface_request_fullscreen(struct wl_listener *listener, void *
 	 * display in fullscreen mode, so we set it here.
 	 */
 	struct wlr_box *layout_box = wlr_output_layout_get_box(xdg_shell_view->view.server->output_layout, NULL);
-	wlr_xdg_toplevel_set_size(xdg_shell_view->xdg_surface, layout_box->width, layout_box->height);
+	wlr_xdg_toplevel_set_size(xdg_shell_view->xdg_toplevel, layout_box->width, layout_box->height);
 
-	wlr_xdg_toplevel_set_fullscreen(xdg_shell_view->xdg_surface, event->fullscreen);
+	wlr_xdg_toplevel_set_fullscreen(xdg_shell_view->xdg_toplevel, event->fullscreen);
 }
 
 static void
@@ -192,7 +188,7 @@ handle_xdg_shell_surface_map(struct wl_listener *listener, void *data)
 	struct cg_xdg_shell_view *xdg_shell_view = wl_container_of(listener, xdg_shell_view, map);
 	struct cg_view *view = &xdg_shell_view->view;
 
-	view_map(view, xdg_shell_view->xdg_surface->surface);
+	view_map(view, xdg_shell_view->xdg_toplevel->base->surface);
 }
 
 static void
@@ -205,7 +201,7 @@ handle_xdg_shell_surface_destroy(struct wl_listener *listener, void *data)
 	wl_list_remove(&xdg_shell_view->unmap.link);
 	wl_list_remove(&xdg_shell_view->destroy.link);
 	wl_list_remove(&xdg_shell_view->request_fullscreen.link);
-	xdg_shell_view->xdg_surface = NULL;
+	xdg_shell_view->xdg_toplevel = NULL;
 
 	view_destroy(view);
 }
@@ -235,7 +231,7 @@ handle_xdg_shell_surface_new(struct wl_listener *listener, void *data)
 		}
 
 		view_init(&xdg_shell_view->view, server, CAGE_XDG_SHELL_VIEW, &xdg_shell_view_impl);
-		xdg_shell_view->xdg_surface = xdg_surface;
+		xdg_shell_view->xdg_toplevel = xdg_surface->toplevel;
 
 		xdg_shell_view->map.notify = handle_xdg_shell_surface_map;
 		wl_signal_add(&xdg_surface->events.map, &xdg_shell_view->map);
diff --git a/xdg_shell.h b/xdg_shell.h
index 9a101c6..2fd506a 100644
--- a/xdg_shell.h
+++ b/xdg_shell.h
@@ -9,7 +9,7 @@
 
 struct cg_xdg_shell_view {
 	struct cg_view view;
-	struct wlr_xdg_surface *xdg_surface;
+	struct wlr_xdg_toplevel *xdg_toplevel;
 
 	struct wl_listener destroy;
 	struct wl_listener unmap;

From 4a21ab981cea0ea7b775807e5866c51b8c8d6498 Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <orzechowski.alexander@gmail.com>
Date: Wed, 12 Oct 2022 04:00:33 -0400
Subject: [PATCH 04/12] xdg_shell: Port to 0.16 double buffered geometry

---
 xdg_shell.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xdg_shell.c b/xdg_shell.c
index fcb3745..a5287e6 100644
--- a/xdg_shell.c
+++ b/xdg_shell.c
@@ -67,7 +67,7 @@ static void
 popup_unconstrain(struct cg_view *view, struct wlr_xdg_popup *popup)
 {
 	struct cg_server *server = view->server;
-	struct wlr_box *popup_box = &popup->geometry;
+	struct wlr_box *popup_box = &popup->current.geometry;
 
 	struct wlr_output_layout *output_layout = server->output_layout;
 	struct wlr_output *wlr_output =

From 272a7e5cb093bff651705ba1533b3cdf0e68921c Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <orzechowski.alexander@gmail.com>
Date: Wed, 12 Oct 2022 04:02:01 -0400
Subject: [PATCH 05/12] xdg_shell: Port 0.16 configure changes

---
 xdg_shell.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/xdg_shell.c b/xdg_shell.c
index a5287e6..c15da65 100644
--- a/xdg_shell.c
+++ b/xdg_shell.c
@@ -161,7 +161,6 @@ static void
 handle_xdg_shell_surface_request_fullscreen(struct wl_listener *listener, void *data)
 {
 	struct cg_xdg_shell_view *xdg_shell_view = wl_container_of(listener, xdg_shell_view, request_fullscreen);
-	struct wlr_xdg_toplevel_set_fullscreen_event *event = data;
 
 	/**
 	 * Certain clients do not like figuring out their own window geometry if they
@@ -170,7 +169,7 @@ handle_xdg_shell_surface_request_fullscreen(struct wl_listener *listener, void *
 	struct wlr_box *layout_box = wlr_output_layout_get_box(xdg_shell_view->view.server->output_layout, NULL);
 	wlr_xdg_toplevel_set_size(xdg_shell_view->xdg_toplevel, layout_box->width, layout_box->height);
 
-	wlr_xdg_toplevel_set_fullscreen(xdg_shell_view->xdg_toplevel, event->fullscreen);
+	wlr_xdg_surface_schedule_configure(xdg_shell_view->xdg_toplevel->base);
 }
 
 static void

From 4769896ba4c944fd4e1c44ed6b751a65c1129053 Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <orzechowski.alexander@gmail.com>
Date: Wed, 12 Oct 2022 04:05:33 -0400
Subject: [PATCH 06/12] Port 0.16 wlr_output_layout_get_box changes Fixes
 memory leaks.

---
 cage.c      |  5 +++--
 view.c      |  9 +++++----
 xdg_shell.c | 16 +++++++++-------
 3 files changed, 17 insertions(+), 13 deletions(-)

diff --git a/cage.c b/cage.c
index 6f23431..02f0d32 100644
--- a/cage.c
+++ b/cage.c
@@ -531,8 +531,9 @@ main(int argc, char *argv[])
 	}
 
 	/* Place the cursor in the center of the output layout. */
-	struct wlr_box *layout_box = wlr_output_layout_get_box(server.output_layout, NULL);
-	wlr_cursor_warp(server.seat->cursor, NULL, layout_box->width / 2, layout_box->height / 2);
+	struct wlr_box layout_box;
+	wlr_output_layout_get_box(server.output_layout, NULL, &layout_box);
+	wlr_cursor_warp(server.seat->cursor, NULL, layout_box.width / 2, layout_box.height / 2);
 
 	wl_display_run(server.wl_display);
 
diff --git a/view.c b/view.c
index 6551142..788af3d 100644
--- a/view.c
+++ b/view.c
@@ -88,12 +88,13 @@ view_center(struct cg_view *view, struct wlr_box *layout_box)
 void
 view_position(struct cg_view *view)
 {
-	struct wlr_box *layout_box = wlr_output_layout_get_box(view->server->output_layout, NULL);
+	struct wlr_box layout_box;
+	wlr_output_layout_get_box(view->server->output_layout, NULL, &layout_box);
 
-	if (view_is_primary(view) || view_extends_output_layout(view, layout_box)) {
-		view_maximize(view, layout_box);
+	if (view_is_primary(view) || view_extends_output_layout(view, &layout_box)) {
+		view_maximize(view, &layout_box);
 	} else {
-		view_center(view, layout_box);
+		view_center(view, &layout_box);
 	}
 }
 
diff --git a/xdg_shell.c b/xdg_shell.c
index c15da65..e54594b 100644
--- a/xdg_shell.c
+++ b/xdg_shell.c
@@ -72,13 +72,14 @@ popup_unconstrain(struct cg_view *view, struct wlr_xdg_popup *popup)
 	struct wlr_output_layout *output_layout = server->output_layout;
 	struct wlr_output *wlr_output =
 		wlr_output_layout_output_at(output_layout, view->lx + popup_box->x, view->ly + popup_box->y);
-	struct wlr_box *output_box = wlr_output_layout_get_box(output_layout, wlr_output);
+	struct wlr_box output_box;
+	wlr_output_layout_get_box(output_layout, wlr_output, &output_box);
 
 	struct wlr_box output_toplevel_box = {
-		.x = output_box->x - view->lx,
-		.y = output_box->y - view->ly,
-		.width = output_box->width,
-		.height = output_box->height,
+		.x = output_box.x - view->lx,
+		.y = output_box.y - view->ly,
+		.width = output_box.width,
+		.height = output_box.height,
 	};
 
 	wlr_xdg_popup_unconstrain_from_box(popup, &output_toplevel_box);
@@ -166,8 +167,9 @@ handle_xdg_shell_surface_request_fullscreen(struct wl_listener *listener, void *
 	 * Certain clients do not like figuring out their own window geometry if they
 	 * display in fullscreen mode, so we set it here.
 	 */
-	struct wlr_box *layout_box = wlr_output_layout_get_box(xdg_shell_view->view.server->output_layout, NULL);
-	wlr_xdg_toplevel_set_size(xdg_shell_view->xdg_toplevel, layout_box->width, layout_box->height);
+	struct wlr_box layout_box;
+	wlr_output_layout_get_box(xdg_shell_view->view.server->output_layout, NULL, &layout_box);
+	wlr_xdg_toplevel_set_size(xdg_shell_view->xdg_toplevel, layout_box.width, layout_box.height);
 
 	wlr_xdg_surface_schedule_configure(xdg_shell_view->xdg_toplevel->base);
 }

From 46ef0d59f6d17ea4c641073b0d866b9d7b1ee129 Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <orzechowski.alexander@gmail.com>
Date: Wed, 12 Oct 2022 04:37:33 -0400
Subject: [PATCH 07/12] Port 0.16 scene changes

---
 seat.c      | 28 ++++++++++++++++++----------
 seat.h      |  2 +-
 view.c      | 12 ++++++------
 view.h      |  2 +-
 xdg_shell.c | 14 +++++++-------
 5 files changed, 33 insertions(+), 25 deletions(-)

diff --git a/seat.c b/seat.c
index 9aa2d6e..02fe8ee 100644
--- a/seat.c
+++ b/seat.c
@@ -53,20 +53,28 @@ static void drag_icon_update_position(struct cg_drag_icon *drag_icon);
 static struct cg_view *
 desktop_view_at(struct cg_server *server, double lx, double ly, struct wlr_surface **surface, double *sx, double *sy)
 {
-	struct wlr_scene_node *node = wlr_scene_node_at(&server->scene->node, lx, ly, sx, sy);
-	if (node == NULL || node->type != WLR_SCENE_NODE_SURFACE) {
+	struct wlr_scene_node *node = wlr_scene_node_at(&server->scene->tree.node, lx, ly, sx, sy);
+	if (node == NULL || node->type != WLR_SCENE_NODE_BUFFER) {
 		return NULL;
 	}
 
-	*surface = wlr_scene_surface_from_node(node)->surface;
+	struct wlr_scene_buffer *scene_buffer = wlr_scene_buffer_from_node(node);
+	struct wlr_scene_surface *scene_surface = wlr_scene_surface_from_buffer(scene_buffer);
+	if (!scene_surface) return NULL;
+	*surface = scene_surface->surface;
 
 	/* Walk up the tree until we find a node with a data pointer. When done,
 	 * we've found the node representing the view. */
-	while (node != NULL && node->data == NULL) {
-		node = node->parent;
+	while (!node->data) {
+		if (!node->parent) {
+			node = NULL;
+			break;
+		}
+
+		node = &node->parent->node;
 	}
-	assert(node != NULL);
 
+	assert(node != NULL);
 	return node->data;
 }
 
@@ -609,7 +617,7 @@ drag_icon_update_position(struct cg_drag_icon *drag_icon)
 		break;
 	}
 
-	wlr_scene_node_set_position(drag_icon->scene_node, drag_icon->lx, drag_icon->ly);
+	wlr_scene_node_set_position(&drag_icon->scene_tree->node, drag_icon->lx, drag_icon->ly);
 }
 
 static void
@@ -619,7 +627,7 @@ handle_drag_icon_destroy(struct wl_listener *listener, void *data)
 
 	wl_list_remove(&drag_icon->link);
 	wl_list_remove(&drag_icon->destroy.link);
-	wlr_scene_node_destroy(drag_icon->scene_node);
+	wlr_scene_node_destroy(&drag_icon->scene_tree->node);
 	free(drag_icon);
 }
 
@@ -662,8 +670,8 @@ handle_start_drag(struct wl_listener *listener, void *data)
 	}
 	drag_icon->seat = seat;
 	drag_icon->wlr_drag_icon = wlr_drag_icon;
-	drag_icon->scene_node = wlr_scene_subsurface_tree_create(&seat->server->scene->node, wlr_drag_icon->surface);
-	if (!drag_icon->scene_node) {
+	drag_icon->scene_tree = wlr_scene_subsurface_tree_create(&seat->server->scene->tree, wlr_drag_icon->surface);
+	if (!drag_icon->scene_tree) {
 		free(drag_icon);
 		return;
 	}
diff --git a/seat.h b/seat.h
index 479dbaf..7b5dabf 100644
--- a/seat.h
+++ b/seat.h
@@ -77,7 +77,7 @@ struct cg_drag_icon {
 	struct wl_list link; // seat::drag_icons
 	struct cg_seat *seat;
 	struct wlr_drag_icon *wlr_drag_icon;
-	struct wlr_scene_node *scene_node;
+	struct wlr_scene_tree *scene_tree;
 
 	/* The drag icon has a position in layout coordinates. */
 	double lx, ly;
diff --git a/view.c b/view.c
index 788af3d..dd8a8c1 100644
--- a/view.c
+++ b/view.c
@@ -68,7 +68,7 @@ view_maximize(struct cg_view *view, struct wlr_box *layout_box)
 	view->lx = layout_box->x;
 	view->ly = layout_box->y;
 
-	wlr_scene_node_set_position(view->scene_node, view->lx, view->ly);
+	wlr_scene_node_set_position(&view->scene_tree->node, view->lx, view->ly);
 
 	view->impl->maximize(view, layout_box->width, layout_box->height);
 }
@@ -82,7 +82,7 @@ view_center(struct cg_view *view, struct wlr_box *layout_box)
 	view->lx = (layout_box->width - width) / 2;
 	view->ly = (layout_box->height - height) / 2;
 
-	wlr_scene_node_set_position(view->scene_node, view->lx, view->ly);
+	wlr_scene_node_set_position(&view->scene_tree->node, view->lx, view->ly);
 }
 
 void
@@ -103,7 +103,7 @@ view_unmap(struct cg_view *view)
 {
 	wl_list_remove(&view->link);
 
-	wlr_scene_node_destroy(view->scene_node);
+	wlr_scene_node_destroy(&view->scene_tree->node);
 
 	view->wlr_surface->data = NULL;
 	view->wlr_surface = NULL;
@@ -112,12 +112,12 @@ view_unmap(struct cg_view *view)
 void
 view_map(struct cg_view *view, struct wlr_surface *surface)
 {
-	view->scene_node = wlr_scene_subsurface_tree_create(&view->server->scene->node, surface);
-	if (!view->scene_node) {
+	view->scene_tree = wlr_scene_subsurface_tree_create(&view->server->scene->tree, surface);
+	if (!view->scene_tree) {
 		wl_resource_post_no_memory(surface->resource);
 		return;
 	}
-	view->scene_node->data = view;
+	view->scene_tree->node.data = view;
 
 	view->wlr_surface = surface;
 	surface->data = view;
diff --git a/view.h b/view.h
index 677a949..11a7648 100644
--- a/view.h
+++ b/view.h
@@ -25,7 +25,7 @@ struct cg_view {
 	struct cg_server *server;
 	struct wl_list link; // server::views
 	struct wlr_surface *wlr_surface;
-	struct wlr_scene_node *scene_node;
+	struct wlr_scene_tree *scene_tree;
 
 	/* The view has a position in layout coordinates. */
 	int lx, ly;
diff --git a/xdg_shell.c b/xdg_shell.c
index e54594b..f82c469 100644
--- a/xdg_shell.c
+++ b/xdg_shell.c
@@ -252,31 +252,31 @@ handle_xdg_shell_surface_new(struct wl_listener *listener, void *data)
 			return;
 		}
 
-		struct wlr_scene_node *parent_scene_node = NULL;
+		struct wlr_scene_tree *parent_scene_tree = NULL;
 		struct wlr_xdg_surface *parent = wlr_xdg_surface_from_wlr_surface(popup->parent);
 		switch (parent->role) {
 		case WLR_XDG_SURFACE_ROLE_TOPLEVEL:;
-			parent_scene_node = view->scene_node;
+			parent_scene_tree = view->scene_tree;
 			break;
 		case WLR_XDG_SURFACE_ROLE_POPUP:
-			parent_scene_node = parent->data;
+			parent_scene_tree = parent->data;
 			break;
 		case WLR_XDG_SURFACE_ROLE_NONE:
 			break;
 		}
-		if (parent_scene_node == NULL) {
+		if (parent_scene_tree == NULL) {
 			return;
 		}
 
-		struct wlr_scene_node *popup_scene_node = wlr_scene_xdg_surface_create(parent_scene_node, xdg_surface);
-		if (popup_scene_node == NULL) {
+		struct wlr_scene_tree *popup_scene_tree = wlr_scene_xdg_surface_create(parent_scene_tree, xdg_surface);
+		if (popup_scene_tree == NULL) {
 			wlr_log(WLR_ERROR, "Failed to allocate scene-graph node for XDG popup");
 			return;
 		}
 
 		popup_unconstrain(view, popup);
 
-		xdg_surface->data = popup_scene_node;
+		xdg_surface->data = popup_scene_tree;
 		break;
 	case WLR_XDG_SURFACE_ROLE_NONE:
 		assert(false); // unreachable

From 662c83e66230b4364924360bb5ba275213e64399 Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <orzechowski.alexander@gmail.com>
Date: Wed, 12 Oct 2022 04:17:38 -0400
Subject: [PATCH 08/12] Give xdg_shell a version

---
 cage.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/cage.c b/cage.c
index 02f0d32..eb94832 100644
--- a/cage.c
+++ b/cage.c
@@ -397,7 +397,7 @@ main(int argc, char *argv[])
 	wl_signal_add(&server.idle_inhibit_v1->events.new_inhibitor, &server.new_idle_inhibitor_v1);
 	wl_list_init(&server.inhibitors);
 
-	xdg_shell = wlr_xdg_shell_create(server.wl_display);
+	xdg_shell = wlr_xdg_shell_create(server.wl_display, 4);
 	if (!xdg_shell) {
 		wlr_log(WLR_ERROR, "Unable to create the XDG shell interface");
 		ret = 1;

From 40f8fdefa05f048b5a8edf76bd4196c91472ff29 Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <orzechowski.alexander@gmail.com>
Date: Wed, 12 Oct 2022 04:25:11 -0400
Subject: [PATCH 09/12] Port 0.16 surface header includes

---
 output.c | 2 +-
 seat.c   | 1 -
 view.c   | 1 -
 view.h   | 2 +-
 4 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/output.c b/output.c
index c33bbe1..0df682c 100644
--- a/output.c
+++ b/output.c
@@ -23,12 +23,12 @@
 #endif
 #include <wlr/render/wlr_renderer.h>
 #include <wlr/types/wlr_data_device.h>
+#include <wlr/types/wlr_compositor.h>
 #include <wlr/types/wlr_matrix.h>
 #include <wlr/types/wlr_output.h>
 #include <wlr/types/wlr_output_damage.h>
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_scene.h>
-#include <wlr/types/wlr_surface.h>
 #include <wlr/types/wlr_xdg_shell.h>
 #include <wlr/util/log.h>
 #include <wlr/util/region.h>
diff --git a/seat.c b/seat.c
index 02fe8ee..56f4bdb 100644
--- a/seat.c
+++ b/seat.c
@@ -21,7 +21,6 @@
 #include <wlr/types/wlr_primary_selection.h>
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_seat.h>
-#include <wlr/types/wlr_surface.h>
 #include <wlr/types/wlr_touch.h>
 #include <wlr/types/wlr_xcursor_manager.h>
 #include <wlr/util/log.h>
diff --git a/view.c b/view.c
index dd8a8c1..b4a3eca 100644
--- a/view.c
+++ b/view.c
@@ -15,7 +15,6 @@
 #include <wayland-server-core.h>
 #include <wlr/types/wlr_output.h>
 #include <wlr/types/wlr_scene.h>
-#include <wlr/types/wlr_surface.h>
 
 #include "output.h"
 #include "seat.h"
diff --git a/view.h b/view.h
index 11a7648..5ae13dd 100644
--- a/view.h
+++ b/view.h
@@ -5,7 +5,7 @@
 
 #include <stdbool.h>
 #include <wayland-server-core.h>
-#include <wlr/types/wlr_surface.h>
+#include <wlr/types/wlr_compositor.h>
 #include <wlr/types/wlr_xdg_shell.h>
 #include <wlr/util/box.h>
 #if CAGE_HAS_XWAYLAND

From 7bb19563c382834a4c5ef72b5cb0562bb3084c05 Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <orzechowski.alexander@gmail.com>
Date: Wed, 12 Oct 2022 04:29:29 -0400
Subject: [PATCH 10/12] meson: Bump wlroots version

---
 meson.build | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/meson.build b/meson.build
index 5a8b28c..fbd7e16 100644
--- a/meson.build
+++ b/meson.build
@@ -35,7 +35,7 @@ if is_freebsd
   )
 endif
 
-wlroots        = dependency('wlroots', version: '>= 0.15.0', fallback: ['wlroots', 'wlroots'])
+wlroots        = dependency('wlroots', version: '>= 0.16.0', fallback: ['wlroots', 'wlroots'])
 wayland_protos = dependency('wayland-protocols', version: '>=1.14')
 wayland_server = dependency('wayland-server')
 xkbcommon      = dependency('xkbcommon')

From c93c9ce8b9dbfb742ffcd50b4788bdbe5883e305 Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <orzechowski.alexander@gmail.com>
Date: Wed, 12 Oct 2022 04:33:01 -0400
Subject: [PATCH 11/12] Enable single-pixel-buffer Why not.

---
 cage.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/cage.c b/cage.c
index eb94832..60ab908 100644
--- a/cage.c
+++ b/cage.c
@@ -31,6 +31,7 @@
 #include <wlr/types/wlr_presentation_time.h>
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_screencopy_v1.h>
+#include <wlr/types/wlr_single_pixel_buffer_v1.h>
 #include <wlr/types/wlr_server_decoration.h>
 #include <wlr/types/wlr_subcompositor.h>
 #include <wlr/types/wlr_viewporter.h>
@@ -261,6 +262,7 @@ main(int argc, char *argv[])
 	struct wlr_xdg_decoration_manager_v1 *xdg_decoration_manager = NULL;
 	struct wlr_export_dmabuf_manager_v1 *export_dmabuf_manager = NULL;
 	struct wlr_screencopy_manager_v1 *screencopy_manager = NULL;
+	struct wlr_single_pixel_buffer_manager_v1 *single_pixel_buffer = NULL;
 	struct wlr_xdg_output_manager_v1 *output_manager = NULL;
 	struct wlr_gamma_control_manager_v1 *gamma_control_manager = NULL;
 	struct wlr_viewporter *viewporter = NULL;
@@ -454,6 +456,13 @@ main(int argc, char *argv[])
 		goto end;
 	}
 
+	single_pixel_buffer = wlr_single_pixel_buffer_manager_v1_create(server.wl_display);
+	if (!single_pixel_buffer) {
+		wlr_log(WLR_ERROR, "Unable to create the single pixel buffer manager");
+		ret = 1;
+		goto end;
+	}
+
 	output_manager = wlr_xdg_output_manager_v1_create(server.wl_display, server.output_layout);
 	if (!output_manager) {
 		wlr_log(WLR_ERROR, "Unable to create the output manager");

From 44684095cb72e72293b8cc990f439624385e5604 Mon Sep 17 00:00:00 2001
From: Alexander Orzechowski <alex@ozal.ski>
Date: Sat, 19 Nov 2022 14:32:02 -0500
Subject: [PATCH 12/12] CI: bump to wlroots 0.16

---
 .github/workflows/main.yml | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
index 5e95347..18dc579 100644
--- a/.github/workflows/main.yml
+++ b/.github/workflows/main.yml
@@ -31,7 +31,7 @@ jobs:
           pacman -Syu --noconfirm xcb-util-wm seatd git clang meson libinput libdrm mesa libxkbcommon wayland wayland-protocols xorg-server-xwayland scdoc
 
       - name: Fetch wlroots as a subproject
-        run: git clone https://gitlab.freedesktop.org/wlroots/wlroots.git subprojects/wlroots -b 0.15.0
+        run: git clone https://gitlab.freedesktop.org/wlroots/wlroots.git subprojects/wlroots -b 0.16.0
 
       # TODO: use --fatal-meson-warnings when on wlroots 0.15.0
       - name: Compile Cage (XWayland=${{ matrix.xwayland }})
@@ -50,7 +50,7 @@ jobs:
           pacman-key --init
           pacman -Syu --noconfirm xcb-util-wm seatd git clang meson libinput libdrm mesa libxkbcommon wayland wayland-protocols xorg-server-xwayland scdoc
       - name: Fetch wlroots as a subproject
-        run: git clone https://gitlab.freedesktop.org/wlroots/wlroots.git subprojects/wlroots -b 0.15.0
+        run: git clone https://gitlab.freedesktop.org/wlroots/wlroots.git subprojects/wlroots -b 0.16.0
       - name: Check for formatting changes
         run: |
           meson build-clang-format -Dxwayland=true
@@ -69,7 +69,7 @@ jobs:
           pacman-key --init
           pacman -Syu --noconfirm xcb-util-wm seatd git clang meson libinput libdrm mesa libxkbcommon wayland wayland-protocols xorg-server-xwayland scdoc
       - name: Fetch wlroots as a subproject
-        run: git clone https://gitlab.freedesktop.org/wlroots/wlroots.git subprojects/wlroots -b 0.15.0
+        run: git clone https://gitlab.freedesktop.org/wlroots/wlroots.git subprojects/wlroots -b 0.16.0
       - name: Run scan-build
         run: |
           meson build-scan-build -Dxwayland=true
