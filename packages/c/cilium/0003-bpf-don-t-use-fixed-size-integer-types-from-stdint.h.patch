From 7daa01fc7a23f83f6088b6eb43917cefa9944937 Mon Sep 17 00:00:00 2001
From: Tobias Klauser <tklauser@distanz.ch>
Date: Mon, 17 Feb 2020 11:58:32 +0100
Subject: [PATCH 03/10] bpf: don't use fixed size integer types from stdint.h

Use stddef.h to get size_t, use kernel definitions for fixed size types
where appropriate (e.g. uint32_t -> __u32)

This allows to get rid of the x32 libc header dependency to pull in the
GNU libc stub headers needed by stdint.h. This should thus more easily
allow to compile the BPF programs on platforms other than amd64 (e.g.
arm64, ppc64).

Also clean up some other unused includes.

For some reason these changes lead to clang complaining about several
functions defined in .h files being unused. Mark these as __maybe_unused
or if they are used in a single place move them to the .c file.

Fixes #368
Fixes #8529

Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
---
 .travis.yml                                   |  2 +-
 .travis.yml.tmpl                              |  2 +-
 .../contributing/development/dev_setup.rst    |  2 -
 bpf/Makefile.bpf                              |  4 +-
 bpf/bpf_alignchecker.c                        |  3 +-
 bpf/bpf_hostdev_ingress.c                     |  3 -
 bpf/bpf_ipsec.c                               |  3 -
 bpf/bpf_lxc.c                                 |  3 -
 bpf/bpf_netdev.c                              |  3 -
 bpf/bpf_network.c                             |  3 -
 bpf/bpf_overlay.c                             |  3 -
 bpf/bpf_sock.c                                |  5 +-
 bpf/bpf_xdp.c                                 |  3 -
 bpf/include/bpf/api.h                         | 98 +++++++++----------
 bpf/include/iproute2/bpf_elf.h                |  2 +-
 bpf/include/linux/bpf.h                       |  2 +-
 bpf/include/linux/byteorder.h                 |  4 +-
 bpf/include/linux/byteorder/little_endian.h   |  2 +-
 bpf/include/linux/icmp.h                      |  2 +-
 bpf/include/linux/icmpv6.h                    |  2 +-
 bpf/include/linux/if_arp.h                    |  2 +-
 bpf/include/linux/if_ether.h                  |  2 +-
 bpf/include/linux/in.h                        |  2 +-
 bpf/include/linux/in6.h                       |  2 +-
 bpf/include/linux/ip.h                        |  2 +-
 bpf/include/linux/ipv6.h                      |  2 +-
 bpf/include/linux/perf_event.h                |  2 +-
 bpf/include/linux/swab.h                      |  2 +-
 bpf/include/linux/tcp.h                       |  2 +-
 bpf/include/linux/type_mapper.h               | 29 ------
 bpf/include/linux/udp.h                       |  2 +-
 bpf/init.sh                                   |  3 +
 bpf/lib/common.h                              |  4 +-
 bpf/lib/conntrack_test.h                      |  2 +-
 bpf/lib/dbg.h                                 |  8 +-
 bpf/lib/drop.h                                |  4 +-
 bpf/lib/eps.h                                 | 17 ++--
 bpf/lib/maps.h                                |  2 +-
 bpf/lib/metrics.h                             |  4 -
 bpf/lib/nat.h                                 | 52 +++++-----
 bpf/lib/nodeport.h                            |  4 +-
 bpf/lib/trace.h                               | 12 +--
 bpf/lib/utils.h                               | 12 ++-
 bpf/probes/raw_main.c                         | 21 ++--
 bpf/run_probes.sh                             |  6 +-
 bpf/sockops/bpf_redir.c                       | 18 +++-
 bpf/sockops/bpf_sockops.c                     | 31 +++++-
 bpf/sockops/bpf_sockops.h                     | 43 --------
 contrib/packaging/rpm/Dockerfile              |  2 +-
 contrib/packaging/rpm/cilium.spec.envsubst    |  3 +-
 pkg/datapath/linux/requirements.go            | 10 --
 pkg/datapath/loader/compile.go                | 27 ++++-
 test/bpf/Makefile                             |  2 +-
 test/bpf/elf-demo.c                           |  1 -
 test/bpf/unit-test.c                          |  3 +-
 55 files changed, 222 insertions(+), 269 deletions(-)
 delete mode 100644 bpf/include/linux/type_mapper.h

diff --git a/.travis.yml b/.travis.yml
index 1d4c88d5f..3e4f815b9 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -11,7 +11,7 @@ if: branch = master OR type = pull_request
 addons:
   apt:
     packages:
-      - kernel-package libc6-dev-i386
+      - kernel-package
 
 before_install: ./.travis/prepare.sh
 
diff --git a/.travis.yml.tmpl b/.travis.yml.tmpl
index ce1afe6f8..0c79a23ce 100644
--- a/.travis.yml.tmpl
+++ b/.travis.yml.tmpl
@@ -11,7 +11,7 @@ if: branch = master OR type = pull_request
 addons:
   apt:
     packages:
-      - kernel-package libc6-dev-i386
+      - kernel-package
 
 before_install: ./.travis/prepare.sh
 
diff --git a/Documentation/contributing/development/dev_setup.rst b/Documentation/contributing/development/dev_setup.rst
index e9d0371b6..903b2f363 100644
--- a/Documentation/contributing/development/dev_setup.rst
+++ b/Documentation/contributing/development/dev_setup.rst
@@ -20,8 +20,6 @@ contribute to Cilium:
 +==================================================================================+==========================+===============================================================================+
 |  git                                                                             | latest                   | N/A (OS-specific)                                                             |
 +----------------------------------------------------------------------------------+--------------------------+-------------------------------------------------------------------------------+
-|  glibc-devel (32-bit)                                                            | latest                   | N/A (OS-specific)                                                             |
-+----------------------------------------------------------------------------------+--------------------------+-------------------------------------------------------------------------------+
 |  clang                                                                           | >= 3.9.1                 | N/A (OS-specific)                                                             |
 +----------------------------------------------------------------------------------+--------------------------+-------------------------------------------------------------------------------+
 |  llvm                                                                            | >= 3.9.1                 | N/A (OS-specific)                                                             |
diff --git a/bpf/Makefile.bpf b/bpf/Makefile.bpf
index e433094a7..371f60e7b 100644
--- a/bpf/Makefile.bpf
+++ b/bpf/Makefile.bpf
@@ -1,6 +1,6 @@
-FLAGS := -I$(ROOT_DIR)/bpf/include -I$(ROOT_DIR)/bpf -D__NR_CPUS__=$(shell nproc) -O2 -g
+FLAGS := -I/usr/include/$(shell uname -m)-linux-gnu -I$(ROOT_DIR)/bpf/include -I$(ROOT_DIR)/bpf -D__NR_CPUS__=$(shell nproc) -O2 -g
 
-CLANG_FLAGS :=  ${FLAGS} -target bpf -emit-llvm
+CLANG_FLAGS := ${FLAGS} -target bpf -emit-llvm
 # eBPF verifier enforces unaligned access checks where necessary, so don't
 # let clang complain too early.
 CLANG_FLAGS += -Wall -Werror -Wno-address-of-packed-member -Wno-unknown-warning-option
diff --git a/bpf/bpf_alignchecker.c b/bpf/bpf_alignchecker.c
index 975340de5..abeeb0c02 100644
--- a/bpf/bpf_alignchecker.c
+++ b/bpf/bpf_alignchecker.c
@@ -15,8 +15,6 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
-#include <stdio.h>
-#include <linux/byteorder.h>
 
 /* Ensure declaration of notification event types */
 #define DEBUG
@@ -27,6 +25,7 @@
 #include "lib/conntrack.h"
 #include "lib/dbg.h"
 #include "lib/drop.h"
+#define SKIP_UNDEF_LPM_LOOKUP_FN
 #include "lib/maps.h"
 #include "lib/nat.h"
 #include "lib/trace.h"
diff --git a/bpf/bpf_hostdev_ingress.c b/bpf/bpf_hostdev_ingress.c
index e540a7c5e..2fa508a3b 100644
--- a/bpf/bpf_hostdev_ingress.c
+++ b/bpf/bpf_hostdev_ingress.c
@@ -21,9 +21,6 @@
 #include <netdev_config.h>
 #include <bpf/api.h>
 
-#include <stdint.h>
-#include <stdio.h>
-
 #include "lib/common.h"
 
 __section("to-host")
diff --git a/bpf/bpf_ipsec.c b/bpf/bpf_ipsec.c
index 11c6379d6..e5c882f0a 100644
--- a/bpf/bpf_ipsec.c
+++ b/bpf/bpf_ipsec.c
@@ -21,9 +21,6 @@
 #include <netdev_config.h>
 #include <bpf/api.h>
 
-#include <stdint.h>
-#include <stdio.h>
-
 #include "lib/common.h"
 #include "lib/dbg.h"
 
diff --git a/bpf/bpf_lxc.c b/bpf/bpf_lxc.c
index 497edf48c..41a951c38 100644
--- a/bpf/bpf_lxc.c
+++ b/bpf/bpf_lxc.c
@@ -22,9 +22,6 @@
 
 #include <bpf/api.h>
 
-#include <stdint.h>
-#include <stdio.h>
-
 #include <linux/icmpv6.h>
 #include <linux/if_packet.h>
 
diff --git a/bpf/bpf_netdev.c b/bpf/bpf_netdev.c
index 4291794ff..9c0ec50d5 100644
--- a/bpf/bpf_netdev.c
+++ b/bpf/bpf_netdev.c
@@ -29,9 +29,6 @@
 
 #include <bpf/api.h>
 
-#include <stdint.h>
-#include <stdio.h>
-
 #include "lib/utils.h"
 #include "lib/common.h"
 #include "lib/arp.h"
diff --git a/bpf/bpf_network.c b/bpf/bpf_network.c
index 135506647..a6eb69fe3 100644
--- a/bpf/bpf_network.c
+++ b/bpf/bpf_network.c
@@ -20,9 +20,6 @@
 
 #include <bpf/api.h>
 
-#include <stdint.h>
-#include <stdio.h>
-
 #include <linux/if_packet.h>
 
 #include "lib/utils.h"
diff --git a/bpf/bpf_overlay.c b/bpf/bpf_overlay.c
index 7894cfc26..1a2494e96 100644
--- a/bpf/bpf_overlay.c
+++ b/bpf/bpf_overlay.c
@@ -20,9 +20,6 @@
 
 #include <bpf/api.h>
 
-#include <stdint.h>
-#include <stdio.h>
-
 #include <linux/if_packet.h>
 
 #include "lib/tailcall.h"
diff --git a/bpf/bpf_sock.c b/bpf/bpf_sock.c
index 7ab29f0a8..965df6a6b 100644
--- a/bpf/bpf_sock.c
+++ b/bpf/bpf_sock.c
@@ -21,9 +21,6 @@
 
 #include <bpf/api.h>
 
-#include <stdint.h>
-#include <stdio.h>
-
 #define SKIP_POLICY_MAP	1
 #define SKIP_CALLS_MAP	1
 
@@ -124,7 +121,7 @@ __u64 sock_local_cookie(struct bpf_sock_addr *ctx)
 }
 
 static __always_inline __maybe_unused
-bool sock_proto_enabled(uint32_t proto)
+bool sock_proto_enabled(__u32 proto)
 {
 	switch (proto) {
 #ifdef ENABLE_HOST_SERVICES_TCP
diff --git a/bpf/bpf_xdp.c b/bpf/bpf_xdp.c
index 5eda135a3..169489bd6 100644
--- a/bpf/bpf_xdp.c
+++ b/bpf/bpf_xdp.c
@@ -23,9 +23,6 @@
 
 #include <bpf/api.h>
 
-#include <stdint.h>
-#include <stdio.h>
-
 #include <linux/bpf.h>
 #include <linux/if_ether.h>
 
diff --git a/bpf/include/bpf/api.h b/bpf/include/bpf/api.h
index b13c9347e..7cfda0ba8 100644
--- a/bpf/include/bpf/api.h
+++ b/bpf/include/bpf/api.h
@@ -8,7 +8,7 @@
  * misc macros and some eBPF specific LLVM built-ins.
  */
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 #include <linux/byteorder.h>
 #include <linux/bpf.h>
 
@@ -111,14 +111,14 @@
 /* Map access/manipulation */
 static void *BPF_FUNC(map_lookup_elem, const void *map, const void *key);
 static int BPF_FUNC(map_update_elem, const void *map, const void *key,
-		    const void *value, uint32_t flags);
+		    const void *value, __u32 flags);
 static int BPF_FUNC(map_delete_elem, const void *map, const void *key);
 
 /* Time access */
-static uint64_t BPF_FUNC(ktime_get_ns);
+static __u64 BPF_FUNC(ktime_get_ns);
 
 /* Sockets */
-static uint64_t BPF_FUNC(get_socket_cookie, void *ctx);
+static __u64 BPF_FUNC(get_socket_cookie, void *ctx);
 
 /* Debugging */
 
@@ -133,79 +133,79 @@ static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);
 #endif
 
 /* Random numbers */
-static uint32_t BPF_FUNC(get_prandom_u32);
+static __u32 BPF_FUNC(get_prandom_u32);
 
 /* Tail calls */
 static void BPF_FUNC(tail_call, struct __sk_buff *skb, void *map,
-		     uint32_t index);
+		     __u32 index);
 
 /* System helpers */
-static uint32_t BPF_FUNC(get_smp_processor_id);
+static __u32 BPF_FUNC(get_smp_processor_id);
 
 /* Packet misc meta data */
-static uint32_t BPF_FUNC(get_cgroup_classid, struct __sk_buff *skb);
-static uint32_t BPF_FUNC(get_route_realm, struct __sk_buff *skb);
-static uint32_t BPF_FUNC(get_hash_recalc, struct __sk_buff *skb);
-static uint32_t BPF_FUNC(set_hash_invalid, struct __sk_buff *skb);
+static __u32 BPF_FUNC(get_cgroup_classid, struct __sk_buff *skb);
+static __u32 BPF_FUNC(get_route_realm, struct __sk_buff *skb);
+static __u32 BPF_FUNC(get_hash_recalc, struct __sk_buff *skb);
+static __u32 BPF_FUNC(set_hash_invalid, struct __sk_buff *skb);
 
-static int BPF_FUNC(skb_under_cgroup, void *map, uint32_t index);
+static int BPF_FUNC(skb_under_cgroup, void *map, __u32 index);
 
 /* Packet redirection */
-static int BPF_FUNC(redirect, int ifindex, uint32_t flags);
+static int BPF_FUNC(redirect, int ifindex, __u32 flags);
 static int BPF_FUNC(clone_redirect, struct __sk_buff *skb, int ifindex,
-		    uint32_t flags);
+		    __u32 flags);
 
 /* Packet manipulation */
-static int BPF_FUNC(skb_load_bytes_relative, struct __sk_buff *skb, uint32_t off,
-		    void *to, uint32_t len, uint32_t hdr);
-static int BPF_FUNC(skb_load_bytes, struct __sk_buff *skb, uint32_t off,
-		    void *to, uint32_t len);
-static int BPF_FUNC(skb_store_bytes, struct __sk_buff *skb, uint32_t off,
-		    const void *from, uint32_t len, uint32_t flags);
-static int BPF_FUNC(skb_adjust_room, struct __sk_buff *skb, int32_t len_diff,
-		    uint32_t mode, uint64_t flags);
-
-static int BPF_FUNC(l3_csum_replace, struct __sk_buff *skb, uint32_t off,
-		    uint32_t from, uint32_t to, uint32_t flags);
-static int BPF_FUNC(l4_csum_replace, struct __sk_buff *skb, uint32_t off,
-		    uint32_t from, uint32_t to, uint32_t flags);
-static int BPF_FUNC(csum_diff, void *from, uint32_t from_size, void *to,
-		    uint32_t to_size, uint32_t seed);
-
-static int BPF_FUNC(skb_change_type, struct __sk_buff *skb, uint32_t type);
-static int BPF_FUNC(skb_change_proto, struct __sk_buff *skb, uint32_t proto,
-		    uint32_t flags);
-static int BPF_FUNC(skb_change_tail, struct __sk_buff *skb, uint32_t nlen,
-		    uint32_t flags);
-static int BPF_FUNC(skb_pull_data, struct __sk_buff *skb, uint32_t len);
+static int BPF_FUNC(skb_load_bytes_relative, struct __sk_buff *skb, __u32 off,
+		    void *to, __u32 len, __u32 hdr);
+static int BPF_FUNC(skb_load_bytes, struct __sk_buff *skb, __u32 off,
+		    void *to, __u32 len);
+static int BPF_FUNC(skb_store_bytes, struct __sk_buff *skb, __u32 off,
+		    const void *from, __u32 len, __u32 flags);
+static int BPF_FUNC(skb_adjust_room, struct __sk_buff *skb, __s32 len_diff,
+		    __u32 mode, __u64 flags);
+
+static int BPF_FUNC(l3_csum_replace, struct __sk_buff *skb, __u32 off,
+		    __u32 from, __u32 to, __u32 flags);
+static int BPF_FUNC(l4_csum_replace, struct __sk_buff *skb, __u32 off,
+		    __u32 from, __u32 to, __u32 flags);
+static int BPF_FUNC(csum_diff, void *from, __u32 from_size, void *to,
+		    __u32 to_size, __u32 seed);
+
+static int BPF_FUNC(skb_change_type, struct __sk_buff *skb, __u32 type);
+static int BPF_FUNC(skb_change_proto, struct __sk_buff *skb, __u32 proto,
+		    __u32 flags);
+static int BPF_FUNC(skb_change_tail, struct __sk_buff *skb, __u32 nlen,
+		    __u32 flags);
+static int BPF_FUNC(skb_pull_data, struct __sk_buff *skb, __u32 len);
 
 /* Packet vlan encap/decap */
-static int BPF_FUNC(skb_vlan_push, struct __sk_buff *skb, uint16_t proto,
-		    uint16_t vlan_tci);
+static int BPF_FUNC(skb_vlan_push, struct __sk_buff *skb, __u16 proto,
+		    __u16 vlan_tci);
 static int BPF_FUNC(skb_vlan_pop, struct __sk_buff *skb);
 
 /* Packet tunnel encap/decap */
 static int BPF_FUNC(skb_get_tunnel_key, struct __sk_buff *skb,
-		    struct bpf_tunnel_key *to, uint32_t size, uint32_t flags);
+		    struct bpf_tunnel_key *to, __u32 size, __u32 flags);
 static int BPF_FUNC(skb_set_tunnel_key, struct __sk_buff *skb,
-		    const struct bpf_tunnel_key *from, uint32_t size,
-		    uint32_t flags);
+		    const struct bpf_tunnel_key *from, __u32 size,
+		    __u32 flags);
 
 static int BPF_FUNC(skb_get_tunnel_opt, struct __sk_buff *skb,
-		    void *to, uint32_t size);
+		    void *to, __u32 size);
 static int BPF_FUNC(skb_set_tunnel_opt, struct __sk_buff *skb,
-		    const void *from, uint32_t size);
+		    const void *from, __u32 size);
 
 /* Events for user space */
-static int BPF_FUNC2(skb_event_output, struct __sk_buff *skb, void *map, uint64_t index,
-		     const void *data, uint32_t size) = (void *)BPF_FUNC_perf_event_output;
+static int BPF_FUNC2(skb_event_output, struct __sk_buff *skb, void *map, __u64 index,
+		     const void *data, __u32 size) = (void *)BPF_FUNC_perf_event_output;
 
 /* Sockops and SK_MSG helpers */
-static int BPF_FUNC(sock_map_update, struct bpf_sock_ops *skops, void *map, uint32_t key,  uint64_t flags);
-static int BPF_FUNC(sock_hash_update, struct bpf_sock_ops *skops, void *map, void *key,  uint64_t flags);
-static int BPF_FUNC(msg_redirect_hash, struct sk_msg_md *md, void *map, void *key, uint64_t flags);
+static int BPF_FUNC(sock_map_update, struct bpf_sock_ops *skops, void *map, __u32 key,  __u64 flags);
+static int BPF_FUNC(sock_hash_update, struct bpf_sock_ops *skops, void *map, void *key,  __u64 flags);
+static int BPF_FUNC(msg_redirect_hash, struct sk_msg_md *md, void *map, void *key, __u64 flags);
 
-static int BPF_FUNC(fib_lookup, void *ctx, struct bpf_fib_lookup *params, uint32_t plen, uint32_t flags);
+static int BPF_FUNC(fib_lookup, void *ctx, struct bpf_fib_lookup *params, __u32 plen, __u32 flags);
 
 /** LLVM built-ins, mem*() routines work for constant size */
 
diff --git a/bpf/include/iproute2/bpf_elf.h b/bpf/include/iproute2/bpf_elf.h
index 6b24d31df..342320bab 100644
--- a/bpf/include/iproute2/bpf_elf.h
+++ b/bpf/include/iproute2/bpf_elf.h
@@ -1,7 +1,7 @@
 #ifndef __BPF_ELF__
 #define __BPF_ELF__
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 
 /* Note:
  *
diff --git a/bpf/include/linux/bpf.h b/bpf/include/linux/bpf.h
index ab14eb8f1..4bccdae11 100644
--- a/bpf/include/linux/bpf.h
+++ b/bpf/include/linux/bpf.h
@@ -8,7 +8,7 @@
 #ifndef __LINUX_BPF_H__
 #define __LINUX_BPF_H__
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 #include <linux/bpf_common.h>
 
 /* Define BIT() here to avoid pulling in more headers */
diff --git a/bpf/include/linux/byteorder.h b/bpf/include/linux/byteorder.h
index 236e9a538..84273e7b3 100644
--- a/bpf/include/linux/byteorder.h
+++ b/bpf/include/linux/byteorder.h
@@ -1,9 +1,7 @@
 #ifndef _ASM_X86_BYTEORDER_H
 #define _ASM_X86_BYTEORDER_H
 
-#include <endian.h>
-
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
 #include <linux/byteorder/little_endian.h>
 #else
 #include <linux/byteorder/big_endian.h>
diff --git a/bpf/include/linux/byteorder/little_endian.h b/bpf/include/linux/byteorder/little_endian.h
index 501859e95..74e8a1591 100644
--- a/bpf/include/linux/byteorder/little_endian.h
+++ b/bpf/include/linux/byteorder/little_endian.h
@@ -8,7 +8,7 @@
 #define __LITTLE_ENDIAN_BITFIELD
 #endif
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 #include <linux/swab.h>
 
 #define __constant_htonl(x) ((__be32)___constant_swab32((x)))
diff --git a/bpf/include/linux/icmp.h b/bpf/include/linux/icmp.h
index ea3e30e62..ab58cee37 100644
--- a/bpf/include/linux/icmp.h
+++ b/bpf/include/linux/icmp.h
@@ -17,7 +17,7 @@
 #ifndef _LINUX_ICMP_H
 #define _LINUX_ICMP_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 
 #define ICMP_ECHOREPLY		0	/* Echo Reply			*/
 #define ICMP_DEST_UNREACH	3	/* Destination Unreachable	*/
diff --git a/bpf/include/linux/icmpv6.h b/bpf/include/linux/icmpv6.h
index 5144f6c88..eee9c2897 100644
--- a/bpf/include/linux/icmpv6.h
+++ b/bpf/include/linux/icmpv6.h
@@ -1,7 +1,7 @@
 #ifndef _LINUX_ICMPV6_H
 #define _LINUX_ICMPV6_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 #include <linux/in6.h>
 
 struct icmp6hdr {
diff --git a/bpf/include/linux/if_arp.h b/bpf/include/linux/if_arp.h
index 20d2dafad..7d3d741d2 100644
--- a/bpf/include/linux/if_arp.h
+++ b/bpf/include/linux/if_arp.h
@@ -23,7 +23,7 @@
 #ifndef _LINUX_IF_ARP_H
 #define _LINUX_IF_ARP_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 
 /* ARP protocol HARDWARE identifiers. */
 #define ARPHRD_NETROM	0		/* from KA9Q: NET/ROM pseudo	*/
diff --git a/bpf/include/linux/if_ether.h b/bpf/include/linux/if_ether.h
index cbfdfd585..bf278d65b 100644
--- a/bpf/include/linux/if_ether.h
+++ b/bpf/include/linux/if_ether.h
@@ -21,7 +21,7 @@
 #ifndef _LINUX_IF_ETHER_H
 #define _LINUX_IF_ETHER_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 
 /*
  *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
diff --git a/bpf/include/linux/in.h b/bpf/include/linux/in.h
index a22b842dd..75b2236d5 100644
--- a/bpf/include/linux/in.h
+++ b/bpf/include/linux/in.h
@@ -18,7 +18,7 @@
 #ifndef _LINUX_IN_H
 #define _LINUX_IN_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 
 /* Standard well-defined IP protocols.  */
 enum {
diff --git a/bpf/include/linux/in6.h b/bpf/include/linux/in6.h
index 1519e04d2..73d21c808 100644
--- a/bpf/include/linux/in6.h
+++ b/bpf/include/linux/in6.h
@@ -21,7 +21,7 @@
 #ifndef _LINUX_IN6_H
 #define _LINUX_IN6_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 
 /*
  *	IPv6 address structure
diff --git a/bpf/include/linux/ip.h b/bpf/include/linux/ip.h
index adcceec61..a6a235630 100644
--- a/bpf/include/linux/ip.h
+++ b/bpf/include/linux/ip.h
@@ -17,7 +17,7 @@
 #ifndef _LINUX_IP_H
 #define _LINUX_IP_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 #include <linux/in.h>
 
 #define IPTOS_TOS_MASK		0x1E
diff --git a/bpf/include/linux/ipv6.h b/bpf/include/linux/ipv6.h
index 259754512..e045ffdf5 100644
--- a/bpf/include/linux/ipv6.h
+++ b/bpf/include/linux/ipv6.h
@@ -1,7 +1,7 @@
 #ifndef _IPV6_H
 #define _IPV6_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 #include <linux/in6.h>
 
 /* The latest drafts declared increase in minimal mtu up to 1280. */
diff --git a/bpf/include/linux/perf_event.h b/bpf/include/linux/perf_event.h
index 654f11992..30dd3c8f8 100644
--- a/bpf/include/linux/perf_event.h
+++ b/bpf/include/linux/perf_event.h
@@ -14,7 +14,7 @@
 #ifndef _LINUX_PERF_EVENT_H
 #define _LINUX_PERF_EVENT_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 #include <linux/ioctl.h>
 
 /*
diff --git a/bpf/include/linux/swab.h b/bpf/include/linux/swab.h
index f8d7d6028..3dfc839e5 100644
--- a/bpf/include/linux/swab.h
+++ b/bpf/include/linux/swab.h
@@ -1,7 +1,7 @@
 #ifndef _LINUX_SWAB_H
 #define _LINUX_SWAB_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 
 /*
  * casts are necessary for constants, because we never know how for sure
diff --git a/bpf/include/linux/tcp.h b/bpf/include/linux/tcp.h
index 913b02cd1..bde4c5b35 100644
--- a/bpf/include/linux/tcp.h
+++ b/bpf/include/linux/tcp.h
@@ -17,7 +17,7 @@
 #ifndef _LINUX_TCP_H
 #define _LINUX_TCP_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 
 struct tcphdr {
 	__be16	source;
diff --git a/bpf/include/linux/type_mapper.h b/bpf/include/linux/type_mapper.h
deleted file mode 100644
index 6043f8299..000000000
--- a/bpf/include/linux/type_mapper.h
+++ /dev/null
@@ -1,29 +0,0 @@
-#ifndef __LINUX_TYPE_MAPPER_H__
-#define __LINUX_TYPE_MAPPER_H__
-
-#include <stdint.h>
-
-#define __u64 uint64_t
-#define __u32 uint32_t
-#define __u16 uint16_t
-#define __u8 uint8_t
-
-#define __s64 int64_t
-#define __s32 int32_t
-#define __s16 int16_t
-#define __s8 int8_t
-
-#define __aligned_u64 uint64_t
-
-#define __be64 uint64_t
-#define __be32 uint32_t
-#define __be16 uint16_t
-
-#define __le64 uint64_t
-#define __le32 uint32_t
-#define __le16 uint16_t
-
-#define __sum16 uint16_t
-
-#endif
-
diff --git a/bpf/include/linux/udp.h b/bpf/include/linux/udp.h
index 989633ff6..ab05413c9 100644
--- a/bpf/include/linux/udp.h
+++ b/bpf/include/linux/udp.h
@@ -17,7 +17,7 @@
 #ifndef _LINUX_UDP_H
 #define _LINUX_UDP_H
 
-#include <linux/type_mapper.h>
+#include <linux/types.h>
 
 struct udphdr {
 	__be16	source;
diff --git a/bpf/init.sh b/bpf/init.sh
index 8d18c4145..5036ca3f7 100755
--- a/bpf/init.sh
+++ b/bpf/init.sh
@@ -57,6 +57,8 @@ rm $RUNDIR/encap.state 2> /dev/null || true
 # This directory was created by the daemon and contains the per container header file
 DIR="$PWD/globals"
 
+MACHINE=$(uname -m)
+
 function setup_dev()
 {
 	local -r NAME=$1
@@ -270,6 +272,7 @@ function bpf_compile()
 
 	clang -O2 -g -target bpf -emit-llvm				\
 	      -Wno-address-of-packed-member -Wno-unknown-warning-option	\
+	      -I/usr/include/${MACHINE}-linux-gnu                       \
 	      -I. -I$DIR -I$LIB -I$LIB/include				\
 	      -D__NR_CPUS__=$(nproc)					\
 	      -DENABLE_ARP_RESPONDER					\
diff --git a/bpf/lib/common.h b/bpf/lib/common.h
index bde713507..ace0561dc 100644
--- a/bpf/lib/common.h
+++ b/bpf/lib/common.h
@@ -23,8 +23,8 @@
 #include <linux/if_ether.h>
 #include <linux/ipv6.h>
 #include <linux/in.h>
-#include <stdint.h>
 #include <stdbool.h>
+#include <stddef.h>
 
 // FIXME: GH-3239 LRU logic is not handling timeouts gracefully enough
 // #ifndef HAVE_LRU_MAP_TYPE
@@ -698,7 +698,7 @@ static inline int redirect_self(struct __sk_buff *skb)
 #endif
 }
 
-static inline int redirect_peer(int ifindex, uint32_t flags)
+static inline int redirect_peer(int ifindex, __u32 flags)
 {
 	/* If our datapath has proper redirect support, we make use
 	 * of it here, otherwise we terminate tc processing by letting
diff --git a/bpf/lib/conntrack_test.h b/bpf/lib/conntrack_test.h
index 475b730d6..f8a14df71 100644
--- a/bpf/lib/conntrack_test.h
+++ b/bpf/lib/conntrack_test.h
@@ -40,7 +40,7 @@ static void test___ct_update_timeout()
 {
 	struct ct_entry entry = {};
 	union tcp_flags flags = {};
-	uint32_t then;
+	__u32 then;
 	int monitor;
 
 	// No update initially; mostly just because __now is less than the
diff --git a/bpf/lib/dbg.h b/bpf/lib/dbg.h
index 11cb944aa..2eb9d28ca 100644
--- a/bpf/lib/dbg.h
+++ b/bpf/lib/dbg.h
@@ -161,7 +161,7 @@ struct debug_msg {
 
 static inline void cilium_dbg(struct __sk_buff *skb, __u8 type, __u32 arg1, __u32 arg2)
 {
-	uint32_t hash = get_hash_recalc(skb);
+	__u32 hash = get_hash_recalc(skb);
 	struct debug_msg msg = {
 		.type = CILIUM_NOTIFY_DBG_MSG,
 		.subtype = type,
@@ -177,7 +177,7 @@ static inline void cilium_dbg(struct __sk_buff *skb, __u8 type, __u32 arg1, __u3
 static inline void cilium_dbg3(struct __sk_buff *skb, __u8 type, __u32 arg1,
 			       __u32 arg2, __u32 arg3)
 {
-	uint32_t hash = get_hash_recalc(skb);
+	__u32 hash = get_hash_recalc(skb);
 	struct debug_msg msg = {
 		.type = CILIUM_NOTIFY_DBG_MSG,
 		.subtype = type,
@@ -199,8 +199,8 @@ struct debug_capture_msg {
 
 static inline void cilium_dbg_capture2(struct __sk_buff *skb, __u8 type, __u32 arg1, __u32 arg2)
 {
-	uint64_t skb_len = (uint64_t)skb->len, cap_len = min((uint64_t)TRACE_PAYLOAD_LEN, (uint64_t)skb_len);
-	uint32_t hash = get_hash_recalc(skb);
+	__u64 skb_len = (__u64)skb->len, cap_len = min((__u64)TRACE_PAYLOAD_LEN, (__u64)skb_len);
+	__u32 hash = get_hash_recalc(skb);
 	struct debug_capture_msg msg = {
 		.type = CILIUM_NOTIFY_DBG_CAPTURE,
 		.subtype = type,
diff --git a/bpf/lib/drop.h b/bpf/lib/drop.h
index c915b617a..ad39bd33a 100644
--- a/bpf/lib/drop.h
+++ b/bpf/lib/drop.h
@@ -46,8 +46,8 @@ struct drop_notify {
 
 __section_tail(CILIUM_MAP_CALLS, CILIUM_CALL_DROP_NOTIFY) int __send_drop_notify(struct __sk_buff *skb)
 {
-	uint64_t skb_len = (uint64_t)skb->len, cap_len = min((uint64_t)TRACE_PAYLOAD_LEN, (uint64_t)skb_len);
-	uint32_t hash = get_hash_recalc(skb);
+	__u64 skb_len = (__u64)skb->len, cap_len = min((__u64)TRACE_PAYLOAD_LEN, (__u64)skb_len);
+	__u32 hash = get_hash_recalc(skb);
 	struct drop_notify msg = {
 		.type = CILIUM_NOTIFY_DROP,
 		.source = EVENT_SOURCE,
diff --git a/bpf/lib/eps.h b/bpf/lib/eps.h
index 34be7e553..36580e56a 100644
--- a/bpf/lib/eps.h
+++ b/bpf/lib/eps.h
@@ -23,7 +23,7 @@
 
 #include "maps.h"
 
-static __always_inline struct endpoint_info *
+static __always_inline __maybe_unused struct endpoint_info *
 lookup_ip6_endpoint(struct ipv6hdr *ip6)
 {
 	struct endpoint_key key = {};
@@ -34,8 +34,8 @@ lookup_ip6_endpoint(struct ipv6hdr *ip6)
 	return map_lookup_elem(&ENDPOINTS_MAP, &key);
 }
 
-static __always_inline struct endpoint_info *
-__lookup_ip4_endpoint(uint32_t ip)
+static __always_inline __maybe_unused struct endpoint_info *
+__lookup_ip4_endpoint(__u32 ip)
 {
 	struct endpoint_key key = {};
 
@@ -45,7 +45,7 @@ __lookup_ip4_endpoint(uint32_t ip)
 	return map_lookup_elem(&ENDPOINTS_MAP, &key);
 }
 
-static __always_inline struct endpoint_info *
+static __always_inline __maybe_unused struct endpoint_info *
 lookup_ip4_endpoint(struct iphdr *ip4)
 {
 	return __lookup_ip4_endpoint(ip4->daddr);
@@ -53,7 +53,7 @@ lookup_ip4_endpoint(struct iphdr *ip4)
 
 #ifdef SOCKMAP
 static __always_inline void *
-lookup_ip4_endpoint_policy_map(uint32_t ip)
+lookup_ip4_endpoint_policy_map(__u32 ip)
 {
 	struct endpoint_key key = {};
 
@@ -72,7 +72,7 @@ lookup_ip4_endpoint_policy_map(uint32_t ip)
 
 #define V6_CACHE_KEY_LEN (sizeof(union v6addr)*8)
 
-static __always_inline struct remote_endpoint_info *
+static __always_inline __maybe_unused struct remote_endpoint_info *
 ipcache_lookup6(struct bpf_elf_map *map, union v6addr *addr, __u32 prefix)
 {
 	struct ipcache_key key = {
@@ -86,7 +86,7 @@ ipcache_lookup6(struct bpf_elf_map *map, union v6addr *addr, __u32 prefix)
 
 #define V4_CACHE_KEY_LEN (sizeof(__u32)*8)
 
-static __always_inline struct remote_endpoint_info *
+static __always_inline __maybe_unused struct remote_endpoint_info *
 ipcache_lookup4(struct bpf_elf_map *map, __be32 addr, __u32 prefix)
 {
 	struct ipcache_key key = {
@@ -104,7 +104,8 @@ ipcache_lookup4(struct bpf_elf_map *map, __be32 addr, __u32 prefix)
  * performing a lookup in MAP using LOOKUP_FN to find a provided IP of type
  * IPTYPE. */
 #define LPM_LOOKUP_FN(NAME, IPTYPE, PREFIXES, MAP, LOOKUP_FN)		\
-static __always_inline struct remote_endpoint_info *NAME(IPTYPE addr) \
+static __always_inline __maybe_unused struct remote_endpoint_info *	\
+NAME(IPTYPE addr)							\
 {									\
 	int prefixes[] = { PREFIXES };					\
 	const int size = (sizeof(prefixes) / sizeof(prefixes[0]));	\
diff --git a/bpf/lib/maps.h b/bpf/lib/maps.h
index 6bc583c5d..b26da2d47 100644
--- a/bpf/lib/maps.h
+++ b/bpf/lib/maps.h
@@ -168,7 +168,7 @@ struct bpf_elf_map __section_maps ENCRYPT_MAP = {
 };
 
 #ifndef SKIP_CALLS_MAP
-static __always_inline void ep_tail_call(struct __sk_buff *skb, uint32_t index)
+static __always_inline void ep_tail_call(struct __sk_buff *skb, __u32 index)
 {
 	tail_call(skb, &CALLS_MAP, index);
 }
diff --git a/bpf/lib/metrics.h b/bpf/lib/metrics.h
index 308462960..69e7dfb4e 100644
--- a/bpf/lib/metrics.h
+++ b/bpf/lib/metrics.h
@@ -23,14 +23,10 @@
 #ifndef __LIB_METRICS__
 #define __LIB_METRICS__
 
-
 #include "common.h"
 #include "utils.h"
 #include "maps.h"
 #include "dbg.h"
-#include <stdint.h>
-#include <stdbool.h>
-
 
 /**
  * update_metrics
diff --git a/bpf/lib/nat.h b/bpf/lib/nat.h
index 67be931c5..a8ccff000 100644
--- a/bpf/lib/nat.h
+++ b/bpf/lib/nat.h
@@ -70,20 +70,21 @@ static __always_inline __be16 __snat_clamp_port_range(__u16 start, __u16 end,
 	return (val % (__u16)(end - start)) + start;
 }
 
-static __always_inline __be16 __snat_try_keep_port(__u16 start, __u16 end,
-						   __u16 val)
+static __always_inline __maybe_unused __be16
+__snat_try_keep_port(__u16 start, __u16 end, __u16 val)
 {
 	return val >= start && val <= end ? val :
 	       __snat_clamp_port_range(start, end, get_prandom_u32());
 }
 
-static __always_inline void *__snat_lookup(void *map, void *tuple)
+static __always_inline __maybe_unused void *__snat_lookup(void *map, void *tuple)
 {
 	return map_lookup_elem(map, tuple);
 }
 
-static __always_inline int __snat_update(void *map, void *otuple, void *ostate,
-					 void *rtuple, void *rstate)
+static __always_inline __maybe_unused int __snat_update(void *map, void *otuple,
+							void *ostate, void *rtuple,
+							void *rstate)
 {
 	int ret = map_update_elem(map, rtuple, rstate, BPF_NOEXIST);
 	if (!ret) {
@@ -94,8 +95,8 @@ static __always_inline int __snat_update(void *map, void *otuple, void *ostate,
 	return ret;
 }
 
-static __always_inline void __snat_delete(void *map, void *otuple,
-					  void *rtuple)
+static __always_inline __maybe_unused void __snat_delete(void *map, void *otuple,
+							 void *rtuple)
 {
 	map_delete_elem(map, otuple);
 	map_delete_elem(map, rtuple);
@@ -441,8 +442,9 @@ static __always_inline bool snat_v4_can_skip(const struct ipv4_nat_target *targe
 	return false;
 }
 
-static __always_inline int snat_v4_create_dsr(struct __sk_buff *skb,
-					      __be32 to_saddr, __be16 to_sport)
+static __always_inline __maybe_unused int snat_v4_create_dsr(struct __sk_buff *skb,
+							     __be32 to_saddr,
+							     __be16 to_sport)
 {
 	void *data, *data_end;
 	struct ipv4_ct_tuple tuple = {};
@@ -553,13 +555,13 @@ static __always_inline int snat_v4_process(struct __sk_buff *skb, int dir,
 	       snat_v4_rewrite_ingress(skb, &tuple, state, off);
 }
 #else
-static __always_inline int snat_v4_process(struct __sk_buff *skb, int dir,
-					   const struct ipv4_nat_target *target)
+static __always_inline __maybe_unused int snat_v4_process(struct __sk_buff *skb, int dir,
+							  const struct ipv4_nat_target *target)
 {
 	return TC_ACT_OK;
 }
 
-static __always_inline void snat_v4_delete_tuples(struct ipv4_ct_tuple *tuple)
+static __always_inline __maybe_unused void snat_v4_delete_tuples(struct ipv4_ct_tuple *tuple)
 {
 }
 #endif
@@ -893,9 +895,9 @@ static __always_inline bool snat_v6_can_skip(const struct ipv6_nat_target *targe
 	return false;
 }
 
-static __always_inline int snat_v6_create_dsr(struct __sk_buff *skb,
-					      union v6addr *to_saddr,
-					      __be16 to_sport)
+static __always_inline __maybe_unused int snat_v6_create_dsr(struct __sk_buff *skb,
+							     union v6addr *to_saddr,
+							     __be16 to_sport)
 {
 	void *data, *data_end;
 	struct ipv6_ct_tuple tuple = {};
@@ -1020,7 +1022,7 @@ static __always_inline int snat_v6_process(struct __sk_buff *skb, int dir,
 	       snat_v6_rewrite_ingress(skb, &tuple, state, off);
 }
 #else
-static __always_inline int snat_v6_process(struct __sk_buff *skb, int dir,
+static __always_inline __maybe_unused int snat_v6_process(struct __sk_buff *skb, int dir,
 					   const struct ipv6_nat_target *target)
 {
 	return TC_ACT_OK;
@@ -1032,8 +1034,8 @@ static __always_inline void snat_v6_delete_tuples(struct ipv6_ct_tuple *tuple)
 #endif
 
 #ifdef CONNTRACK
-static __always_inline void ct_delete4(void *map, struct ipv4_ct_tuple *tuple,
-				       struct __sk_buff *skb)
+static __always_inline __maybe_unused void ct_delete4(void *map, struct ipv4_ct_tuple *tuple,
+						      struct __sk_buff *skb)
 {
 	int err;
 
@@ -1043,8 +1045,8 @@ static __always_inline void ct_delete4(void *map, struct ipv4_ct_tuple *tuple,
 		snat_v4_delete_tuples(tuple);
 }
 
-static __always_inline void ct_delete6(void *map, struct ipv6_ct_tuple *tuple,
-				       struct __sk_buff *skb)
+static __always_inline __maybe_unused void ct_delete6(void *map, struct ipv6_ct_tuple *tuple,
+						      struct __sk_buff *skb)
 {
 	int err;
 
@@ -1054,18 +1056,18 @@ static __always_inline void ct_delete6(void *map, struct ipv6_ct_tuple *tuple,
 		snat_v6_delete_tuples(tuple);
 }
 #else
-static __always_inline void ct_delete4(void *map, struct ipv4_ct_tuple *tuple,
-				       struct __sk_buff *skb)
+static __always_inline __maybe_unused void ct_delete4(void *map, struct ipv4_ct_tuple *tuple,
+						      struct __sk_buff *skb)
 {
 }
 
-static __always_inline void ct_delete6(void *map, struct ipv6_ct_tuple *tuple,
-				       struct __sk_buff *skb)
+static __always_inline __maybe_unused void ct_delete6(void *map, struct ipv6_ct_tuple *tuple,
+						      struct __sk_buff *skb)
 {
 }
 #endif
 
-static __always_inline int snat_process(struct __sk_buff *skb, int dir)
+static __always_inline __maybe_unused int snat_process(struct __sk_buff *skb, int dir)
 {
 	int ret = TC_ACT_OK;
 
diff --git a/bpf/lib/nodeport.h b/bpf/lib/nodeport.h
index 9ac89419b..50cc42890 100644
--- a/bpf/lib/nodeport.h
+++ b/bpf/lib/nodeport.h
@@ -758,8 +758,8 @@ static __always_inline int handle_dsr_v4(struct __sk_buff *skb, bool *dsr)
 	// Check whether IPv4 header contains a 64-bit option (IPv4 header
 	// w/o option (5 x 32-bit words) + the DSR option (2 x 32-bit words))
 	if (ip4->ihl == 0x7) {
-		uint32_t opt1 = 0;
-		uint32_t opt2 = 0;
+		__u32 opt1 = 0;
+		__u32 opt2 = 0;
 
 		if (skb_load_bytes(skb, ETH_HLEN + sizeof(struct iphdr),
 				   &opt1, sizeof(opt1)) < 0)
diff --git a/bpf/lib/trace.h b/bpf/lib/trace.h
index 1434497b9..169856699 100644
--- a/bpf/lib/trace.h
+++ b/bpf/lib/trace.h
@@ -167,8 +167,8 @@ send_trace_notify(struct __sk_buff *skb, __u8 obs_point, __u32 src, __u32 dst,
 	if (!monitor)
 		monitor = TRACE_PAYLOAD_LEN;
 
-	uint64_t skb_len = (uint64_t)skb->len, cap_len = min((uint64_t)monitor, (uint64_t)skb_len);
-	uint32_t hash = get_hash_recalc(skb);
+	__u64 skb_len = (__u64)skb->len, cap_len = min((__u64)monitor, (__u64)skb_len);
+	__u32 hash = get_hash_recalc(skb);
 	struct trace_notify msg = {
 		.type = CILIUM_NOTIFY_TRACE,
 		.subtype = obs_point,
@@ -206,8 +206,8 @@ send_trace_notify4(struct __sk_buff *skb, __u8 obs_point, __u32 src, __u32 dst,
 	if (!monitor)
 		monitor = TRACE_PAYLOAD_LEN;
 
-	uint64_t skb_len = (uint64_t)skb->len, cap_len = min((uint64_t)monitor, (uint64_t)skb_len);
-	uint32_t hash = get_hash_recalc(skb);
+	__u64 skb_len = (__u64)skb->len, cap_len = min((__u64)monitor, (__u64)skb_len);
+	__u32 hash = get_hash_recalc(skb);
 	struct trace_notify msg = {
 		.type = CILIUM_NOTIFY_TRACE,
 		.subtype = obs_point,
@@ -245,8 +245,8 @@ send_trace_notify6(struct __sk_buff *skb, __u8 obs_point, __u32 src, __u32 dst,
 	if (!monitor)
 		monitor = TRACE_PAYLOAD_LEN;
 
-	uint64_t skb_len = (uint64_t)skb->len, cap_len = min((uint64_t)monitor, (uint64_t)skb_len);
-	uint32_t hash = get_hash_recalc(skb);
+	__u64 skb_len = (__u64)skb->len, cap_len = min((__u64)monitor, (__u64)skb_len);
+	__u32 hash = get_hash_recalc(skb);
 	struct trace_notify msg = {
 		.type = CILIUM_NOTIFY_TRACE,
 		.subtype = obs_point,
diff --git a/bpf/lib/utils.h b/bpf/lib/utils.h
index 4da8fc264..19a830ea9 100644
--- a/bpf/lib/utils.h
+++ b/bpf/lib/utils.h
@@ -88,18 +88,20 @@ static inline __u32 bpf_ktime_get_sec(void)
 	return (__u64)(bpf_ktime_get_nsec() / NSEC_PER_SEC);
 }
 
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && \
+	__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
 # define __bpf_ntohs(x)		__builtin_bswap16(x)
 # define __bpf_htons(x)		__builtin_bswap16(x)
 # define __bpf_ntohl(x)		__builtin_bswap32(x)
 # define __bpf_htonl(x)		__builtin_bswap32(x)
-#elif __BYTE_ORDER == __BIG_ENDIAN
+#elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && \
+	__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 # define __bpf_ntohs(x)		(x)
 # define __bpf_htons(x)		(x)
 # define __bpf_ntohl(x)		(x)
 # define __bpf_htonl(x)		(x)
 #else
-# error "Fix your __BYTE_ORDER?!"
+# error "endianness detection needs to be set up for your compiler?!"
 #endif
 
 #define bpf_htons(x)				\
@@ -131,8 +133,8 @@ static inline __u32 bpf_ktime_get_sec(void)
 #define fetch_mac(x) { { fetch_u32_i(x, 1), (__u16)fetch_u32_i(x, 2) } }
 
 /* DEFINE_* macros help to declare static data. */
-#define DEFINE_U32(NAME, value) uint32_t NAME = value
-#define DEFINE_U32_I(NAME, i) uint32_t NAME ## _ ## i
+#define DEFINE_U32(NAME, value) __u32 NAME = value
+#define DEFINE_U32_I(NAME, i) __u32 NAME ## _ ## i
 #define DEFINE_IPV6(NAME, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)	\
 DEFINE_U32_I(NAME, 1) = bpf_htonl( (a1) << 24 |  (a2) << 16 |  (a3) << 8 |  (a4));			\
 DEFINE_U32_I(NAME, 2) = bpf_htonl( (a5) << 24 |  (a6) << 16 |  (a7) << 8 |  (a8));			\
diff --git a/bpf/probes/raw_main.c b/bpf/probes/raw_main.c
index 85ddf7201..b55336039 100644
--- a/bpf/probes/raw_main.c
+++ b/bpf/probes/raw_main.c
@@ -18,7 +18,6 @@
 
 #include <unistd.h>
 #include <stdio.h>
-#include <stdint.h>
 #include <string.h>
 #include <errno.h>
 
@@ -36,9 +35,9 @@
 struct bpf_map_fixup {
 	int off;
 	enum bpf_map_type type;
-	uint32_t size_key;
-	uint32_t size_val;
-	uint32_t flags;
+	__u32 size_key;
+	__u32 size_val;
+	__u32 flags;
 };
 
 struct bpf_test {
@@ -54,9 +53,9 @@ static struct bpf_test tests[] = {
 #include "raw_probe.t"
 };
 
-static uint64_t bpf_ptr_to_u64(const void *ptr)
+static __u64 bpf_ptr_to_u64(const void *ptr)
 {
-	return (uint64_t)(unsigned long)ptr;
+	return (__u64)(unsigned long)ptr;
 }
 
 #ifndef __NR_bpf
@@ -103,9 +102,9 @@ int bpf_prog_load(enum bpf_prog_type type, enum bpf_attach_type attach_type,
 	return bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
 }
 
-static int bpf_map_create(enum bpf_map_type type, uint32_t size_key,
-			  uint32_t size_value, uint32_t max_elem,
-			  uint32_t flags)
+static int bpf_map_create(enum bpf_map_type type, __u32 size_key,
+			  __u32 size_value, __u32 max_elem,
+			  __u32 flags)
 {
 	union bpf_attr attr;
 
@@ -261,7 +260,7 @@ static void bpf_run_test(struct bpf_test *test, int debug_mode)
 			.max_elem	= 1,
 			.flags		= map->flags,
 		};
-	  
+
 		fd = bpf_map_create(map->type, map->size_key,
 				    map->size_val, 1, map->flags);
 		if (fd < 0) {
@@ -274,7 +273,7 @@ static void bpf_run_test(struct bpf_test *test, int debug_mode)
 			/* We fail in verifier eventually. */
 			break;
 		}
-		
+
 		if (bpf_map_selfcheck_pinned(fd, &elf_map, sizeof elf_map, test->type) != 0)
 			break;
 
diff --git a/bpf/run_probes.sh b/bpf/run_probes.sh
index 842efba66..58a62babd 100755
--- a/bpf/run_probes.sh
+++ b/bpf/run_probes.sh
@@ -26,6 +26,8 @@ FEATURE_FILE="$RUNDIR/globals/bpf_features.h"
 INFO_FILE="$RUNDIR/bpf_features.log"
 WARNING_FILE="$RUNDIR/bpf_requirements.log"
 
+MACHINE=$(uname -m)
+
 function cleanup {
 	if [ ! -z "$PROBE_DIR" ]; then
 		rm -rf "$PROBE_DIR"
@@ -42,7 +44,7 @@ function probe_run_tc()
 	FEATURE=$2
 	tc qdisc del dev $DEV clsact 2> /dev/null
 
-	PROBE_OPTS="-D__NR_CPUS__=$(nproc) -O2 -target bpf -I$DIR -I. -I$LIB/include -Wall -Wno-address-of-packed-member -Wno-unknown-warning-option"
+	PROBE_OPTS="-D__NR_CPUS__=$(nproc) -O2 -target bpf -I/usr/include/${MACHINE}-linux-gnu -I$DIR -I. -I$LIB/include -Wall -Wno-address-of-packed-member -Wno-unknown-warning-option"
 
 	clang $PROBE_OPTS -c "$PROBE" -o "$OUT" &&
 	tc qdisc add dev $DEV clsact &&
@@ -64,7 +66,7 @@ function probe_run_ll()
 	PROBE_BASE="${LIB}/probes"
 	OUT="$PROBE_DIR"
 	LIB_INCLUDE="${LIB}/include"
-	PROBE_OPTS="-O2 -I$OUT -I$PROBE_BASE -I$LIB_INCLUDE -Wall"
+	PROBE_OPTS="-O2 -I/usr/include/${MACHINE}-linux-gnu -I$OUT -I$PROBE_BASE -I$LIB_INCLUDE -Wall"
 
 	for PROBE in "${PROBE_BASE}"/*.t
 	do
diff --git a/bpf/sockops/bpf_redir.c b/bpf/sockops/bpf_redir.c
index a72db2ce8..47b37dec3 100644
--- a/bpf/sockops/bpf_redir.c
+++ b/bpf/sockops/bpf_redir.c
@@ -22,9 +22,6 @@
 #include <node_config.h>
 #include <bpf/api.h>
 
-#include <stdint.h>
-#include <stdio.h>
-
 #include <linux/bpf.h>
 #include <linux/if_ether.h>
 
@@ -40,6 +37,21 @@
 
 #include "bpf_sockops.h"
 
+static __always_inline void sk_msg_extract4_key(struct sk_msg_md *msg,
+						struct sock_key *key)
+{
+	key->dip4 = msg->remote_ip4;
+	key->sip4 = msg->local_ip4;
+	key->family = ENDPOINT_KEY_IPV4;
+
+	key->sport = (bpf_ntohl(msg->local_port) >> 16);
+	/* clang-7.1 or higher seems to think it can do a 16-bit read here
+	 * which unfortunately most kernels (as of October 2019) do not
+	 * support, which leads to verifier failures. Insert a READ_ONCE
+	 * to make sure that a 32-bit read followed by shift is generated. */
+	key->dport = READ_ONCE(msg->remote_port) >> 16;
+}
+
 __section("sk_msg")
 int bpf_redir_proxy(struct sk_msg_md *msg)
 {
diff --git a/bpf/sockops/bpf_sockops.c b/bpf/sockops/bpf_sockops.c
index 2a9bbcd6f..87cf42530 100644
--- a/bpf/sockops/bpf_sockops.c
+++ b/bpf/sockops/bpf_sockops.c
@@ -22,9 +22,6 @@
 #include <node_config.h>
 #include <bpf/api.h>
 
-#include <stdint.h>
-#include <stdio.h>
-
 #include <linux/bpf.h>
 #include <linux/if_ether.h>
 
@@ -38,6 +35,34 @@
 
 #include "bpf_sockops.h"
 
+static __always_inline void sk_extract4_key(struct bpf_sock_ops *ops,
+					    struct sock_key *key)
+{
+	key->dip4 = ops->remote_ip4;
+	key->sip4 = ops->local_ip4;
+	key->family = ENDPOINT_KEY_IPV4;
+
+	key->sport = (bpf_ntohl(ops->local_port) >> 16);
+	/* clang-7.1 or higher seems to think it can do a 16-bit read here
+	 * which unfortunately most kernels (as of October 2019) do not
+	 * support, which leads to verifier failures. Insert a READ_ONCE
+	 * to make sure that a 32-bit read followed by shift is generated. */
+	key->dport = READ_ONCE(ops->remote_port) >> 16;
+}
+
+static __always_inline void sk_lb4_key(struct lb4_key *lb4,
+					  struct sock_key *key)
+{
+	/* SK MSG is always egress, so use daddr */
+	lb4->address = key->dip4;
+	lb4->dport = key->dport;
+}
+
+static __always_inline bool redirect_to_proxy(int verdict)
+{
+	return verdict > 0;
+}
+
 static inline void bpf_sock_ops_ipv4(struct bpf_sock_ops *skops)
 {
 	struct lb4_key lb4_key = {};
diff --git a/bpf/sockops/bpf_sockops.h b/bpf/sockops/bpf_sockops.h
index 2a87f945a..a3af156b9 100644
--- a/bpf/sockops/bpf_sockops.h
+++ b/bpf/sockops/bpf_sockops.h
@@ -52,46 +52,3 @@ struct bpf_elf_map __section_maps SOCK_OPS_MAP = {
 	.pinning        = PIN_GLOBAL_NS,
 	.max_elem       = SOCKOPS_MAP_SIZE,
 };
-
-static __always_inline void sk_extract4_key(struct bpf_sock_ops *ops,
-					    struct sock_key *key)
-{
-	key->dip4 = ops->remote_ip4;
-	key->sip4 = ops->local_ip4;
-	key->family = ENDPOINT_KEY_IPV4;
-
-	key->sport = (bpf_ntohl(ops->local_port) >> 16);
-	/* clang-7.1 or higher seems to think it can do a 16-bit read here
-	 * which unfortunately most kernels (as of October 2019) do not
-	 * support, which leads to verifier failures. Insert a READ_ONCE
-	 * to make sure that a 32-bit read followed by shift is generated. */
-	key->dport = READ_ONCE(ops->remote_port) >> 16;
-}
-
-static __always_inline void sk_msg_extract4_key(struct sk_msg_md *msg,
-						struct sock_key *key)
-{
-	key->dip4 = msg->remote_ip4;
-	key->sip4 = msg->local_ip4;
-	key->family = ENDPOINT_KEY_IPV4;
-
-	key->sport = (bpf_ntohl(msg->local_port) >> 16);
-	/* clang-7.1 or higher seems to think it can do a 16-bit read here
-	 * which unfortunately most kernels (as of October 2019) do not
-	 * support, which leads to verifier failures. Insert a READ_ONCE
-	 * to make sure that a 32-bit read followed by shift is generated. */
-	key->dport = READ_ONCE(msg->remote_port) >> 16;
-}
-
-static __always_inline void sk_lb4_key(struct lb4_key *lb4,
-					  struct sock_key *key)
-{
-	/* SK MSG is always egress, so use daddr */
-	lb4->address = key->dip4;
-	lb4->dport = key->dport;
-}
-
-static __always_inline bool redirect_to_proxy(int verdict)
-{
-	return verdict > 0;
-}
diff --git a/contrib/packaging/rpm/Dockerfile b/contrib/packaging/rpm/Dockerfile
index e93ac4320..e5f22bb37 100644
--- a/contrib/packaging/rpm/Dockerfile
+++ b/contrib/packaging/rpm/Dockerfile
@@ -7,7 +7,7 @@ RUN curl -sSL -o /etc/yum.repos.d/vbatts-bazel-fedora-28.repo \
 
 RUN dnf -y update && \
 	dnf -y install fedora-packager fedora-review golang gettext \
-		git glibc-devel.x86_64 glibc-devel.i686 cmake bazel libtool wget \
+		git glibc-devel.x86_64 cmake bazel libtool wget \
 		clang make gcc-c++ elfutils-libelf-devel libstdc++-static && \
     mkdir -p /opt/cilium/
 
diff --git a/contrib/packaging/rpm/cilium.spec.envsubst b/contrib/packaging/rpm/cilium.spec.envsubst
index cb35465f2..91dd0a938 100644
--- a/contrib/packaging/rpm/cilium.spec.envsubst
+++ b/contrib/packaging/rpm/cilium.spec.envsubst
@@ -52,14 +52,13 @@ ExclusiveArch: x86_64
 
 Requires:      git
 Requires:      llvm
-Requires:      docker-engine >= 1.12, glibc-devel(x86-32), iproute >= 4.10, clang
+Requires:      docker-engine >= 1.12, iproute >= 4.10, clang
 %{?fc25:Requires: clang >= 5.0}
 
 # If go_compiler is not set to 1, there is no virtual provide. Use golang instead.
 BuildRequires: %{?go_compiler:compiler(go-compiler)}%{!?go_compiler:golang}
 
 BuildRequires: golang
-BuildRequires: glibc-devel(x86-32)
 BuildRequires: cmake
 BuildRequires: bazel
 BuildRequires: ninja-build
diff --git a/pkg/datapath/linux/requirements.go b/pkg/datapath/linux/requirements.go
index 4902c0446..370321864 100644
--- a/pkg/datapath/linux/requirements.go
+++ b/pkg/datapath/linux/requirements.go
@@ -183,16 +183,6 @@ func CheckMinRequirements() {
 				log.Warn("llc version was compiled in debug mode, expect higher latency!")
 			}
 		}
-		// /usr/include/gnu/stubs-32.h is installed by 'glibc-devel.i686' in fedora
-		// /usr/include/sys/cdefs.h is installed by 'libc6-dev-i386' in ubuntu
-		// both files exist on both systems but cdefs.h already exists in fedora
-		// without 'glibc-devel.i686' so we check for 'stubs-32.h first.
-		if _, err := os.Stat("/usr/include/gnu/stubs-32.h"); os.IsNotExist(err) {
-			log.Fatal("linking environment: NOT OK, please make sure you have 'glibc-devel.i686' if you use fedora system or 'libc6-dev-i386' if you use ubuntu system")
-		}
-		if _, err := os.Stat("/usr/include/sys/cdefs.h"); os.IsNotExist(err) {
-			log.Fatal("linking environment: NOT OK, please make sure you have 'libc6-dev-i386' in your ubuntu system")
-		}
 		log.Info("linking environment: OK!")
 	}
 
diff --git a/pkg/datapath/loader/compile.go b/pkg/datapath/loader/compile.go
index 7fab412ab..b244d46ad 100644
--- a/pkg/datapath/loader/compile.go
+++ b/pkg/datapath/loader/compile.go
@@ -24,12 +24,14 @@ import (
 	"os"
 	"path"
 	"runtime"
+	"sync"
 
 	"github.com/cilium/cilium/pkg/command/exec"
 	"github.com/cilium/cilium/pkg/logging/logfields"
 	"github.com/cilium/cilium/pkg/option"
 
 	"github.com/sirupsen/logrus"
+	"golang.org/x/sys/unix"
 )
 
 // OutputType determines the type to be generated by the compilation steps.
@@ -192,7 +194,28 @@ func compileAndLink(ctx context.Context, prog *progInfo, dir *directoryInfo, deb
 	return err
 }
 
-// progLDFlags determines the compiler flags for the specified prog and paths.
+var (
+	unameOnce sync.Once
+
+	// default fallback
+	machineName = "x86_64"
+)
+
+// getMachineName returns the machine hardware name of this host.
+func getMachineName() string {
+	unameOnce.Do(func() {
+		var uts unix.Utsname
+		err := unix.Uname(&uts)
+		if err != nil {
+			log.WithError(err).Warning("Failed to get machine hardware name")
+		} else {
+			machineName = string(uts.Machine[:bytes.IndexByte(uts.Machine[:], 0)])
+		}
+	})
+	return machineName
+}
+
+// progCFlags determines the compiler flags for the specified prog and paths.
 func progCFlags(prog *progInfo, dir *directoryInfo) []string {
 	var output string
 
@@ -203,6 +226,7 @@ func progCFlags(prog *progInfo, dir *directoryInfo) []string {
 	}
 
 	return append(testIncludes,
+		fmt.Sprintf("-I/usr/include/%s-linux-gnu", getMachineName()),
 		fmt.Sprintf("-I%s", path.Join(dir.Runtime, "globals")),
 		fmt.Sprintf("-I%s", dir.State),
 		fmt.Sprintf("-I%s", dir.Library),
@@ -223,6 +247,7 @@ func compile(ctx context.Context, prog *progInfo, dir *directoryInfo, debug bool
 			args = append(args, "-g")
 		}
 	}
+
 	args = append(args, standardCFlags...)
 	args = append(args, progCFlags(prog, dir)...)
 
diff --git a/test/bpf/Makefile b/test/bpf/Makefile
index 063a9a019..49a85ce15 100644
--- a/test/bpf/Makefile
+++ b/test/bpf/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.defs
 
-FLAGS := -I../../bpf/ -I../../bpf/include -I. -D__NR_CPUS__=$(shell nproc) -O2
+FLAGS := -I/usr/include/$(shell uname -m)-linux-gnu  -I../../bpf/ -I../../bpf/include -I. -D__NR_CPUS__=$(shell nproc) -O2
 BPF_CC_FLAGS :=  ${FLAGS} -target bpf -emit-llvm
 BPF_LLC_FLAGS   := -march=bpf -mcpu=probe -filetype=obj
 
diff --git a/test/bpf/elf-demo.c b/test/bpf/elf-demo.c
index 144754718..e1c0a1469 100644
--- a/test/bpf/elf-demo.c
+++ b/test/bpf/elf-demo.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 // Copyright (c) 2018-2019 Authors of Cilium
 #include <linux/bpf.h>
-#include <string.h>
 
 #include "lib/utils.h"
 #include "lib/common.h"
diff --git a/test/bpf/unit-test.c b/test/bpf/unit-test.c
index 87876ec19..6d5acfc63 100644
--- a/test/bpf/unit-test.c
+++ b/test/bpf/unit-test.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 // Copyright (c) 2018-2019 Authors of Cilium
 #include <assert.h>
-#include <stdio.h>
 #include <string.h>
 
 #include "lib/utils.h"
@@ -12,7 +11,7 @@
 #define ntohl bpf_ntohl
 
 /* Declare before lib/conntrack.h or die! */
-static uint32_t __now = 0;
+static __u32 __now = 0;
 #define bpf_ktime_get_sec() __now
 
 #include "lib/conntrack_test.h"
-- 
2.26.2

