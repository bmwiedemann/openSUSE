From b80b16549e24769c7d5fe3a10c4b1a1c4b5161f3 Mon Sep 17 00:00:00 2001
From: Dave Anderson <anderson@redhat.com>
Date: Mon, 23 Mar 2020 15:52:11 -0400
Subject: [PATCH] Fix for reading compressed kdump dumpfiles from systems with
 physical memory located at extraordinarily high addresses.  In a system with
 a physical address range from 0x602770ecf000 to 0x6027ffffffff, the crash
 utility fails during session initialization due to an integer overflow,
 ending with the error message "crash: vmlinux and vmcore do not match!".
 (chenjialong@huawei.com)

References: bsc#1168233 ltc#184660
Upstream: merged
Git-commit: b80b16549e24769c7d5fe3a10c4b1a1c4b5161f3

---
 diskdump.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/diskdump.c b/diskdump.c
index e88243e616cc..328c932dad5a 100644
--- a/diskdump.c
+++ b/diskdump.c
@@ -233,7 +233,7 @@ clean_diskdump_data(void)
 }
 
 static inline int 
-get_bit(char *map, int byte, int bit)
+get_bit(char *map, unsigned long byte, int bit)
 {
 	return map[byte] & (1<<bit);
 }
@@ -694,7 +694,7 @@ restart:
 		dd->max_mapnr = header->max_mapnr;
 
 	/* read memory bitmap */
-	bitmap_len = block_size * header->bitmap_blocks;
+	bitmap_len = (off_t)block_size * header->bitmap_blocks;
 	dd->bitmap_len = bitmap_len;
 
 	offset = (off_t)block_size * (1 + header->sub_hdr_size);
@@ -744,7 +744,7 @@ restart:
 		memcpy(dd->dumpable_bitmap, dd->bitmap, bitmap_len);
 
 	dd->data_offset
-		= (1 + header->sub_hdr_size + header->bitmap_blocks)
+		= (1UL + header->sub_hdr_size + header->bitmap_blocks)
 		* header->block_size;
 
 	dd->header = header;
-- 
2.23.0

