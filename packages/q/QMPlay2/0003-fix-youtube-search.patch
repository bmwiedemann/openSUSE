From 491894bfded98ac674d6930b3cfc835f6a640094 Fri 27 11 11:20:23 2020
From: Simon Vogl <simon.vogl@gmx.net>
Date: Fri, 27 Nov 2020 11:20:23 UTC
Subject: [PATCH] Fix youtube search of QMPlay2

This patch is required to fix QMPlay2's YouTube search.
--- a/src/modules/Extensions/YouTube.cpp
+++ b/src/modules/Extensions/YouTube.cpp
@@ -18,6 +18,7 @@
 
 #include <YouTube.hpp>
 
+#include <Functions.hpp>
 #include <YouTubeDL.hpp>
 #include <LineEdit.hpp>

@@ -760,90 +755,96 @@ void YouTube::setSearchResults(const QByteArray &data)
 {
     const auto json = getYtInitialData(data);
 
-    const auto contents = json.object()
+    const auto sectionListRendererContents = json.object()
         ["contents"].toObject()
         ["twoColumnSearchResultsRenderer"].toObject()
         ["primaryContents"].toObject()
         ["sectionListRenderer"].toObject()
-        ["contents"].toArray().at(0).toObject()
-        ["itemSectionRenderer"].toObject()
         ["contents"].toArray()
     ;
 
-    for (auto &&obj : contents)
+    for (auto &&obj : sectionListRendererContents)
     {
-        const auto videoRenderer = obj.toObject()["videoRenderer"].toObject();
-        const auto playlistRenderer = obj.toObject()["playlistRenderer"].toObject();
+        const auto contents = obj.toObject()
+            ["itemSectionRenderer"].toObject()
+            ["contents"].toArray()
+        ;
 
-        const bool isVideo = !videoRenderer.isEmpty() && playlistRenderer.isEmpty();
-
-        QString title, contentId, length, user, publishedTime, viewCount, thumbnail, url;
-
-        if (isVideo)
+        for (auto &&obj : contents)
         {
-            title = videoRenderer["title"].toObject()["runs"].toArray().at(0).toObject()["text"].toString();
-            contentId = videoRenderer["videoId"].toString();
-            if (title.isEmpty() || contentId.isEmpty())
-                continue;
-
-            length = videoRenderer["lengthText"].toObject()["simpleText"].toString();
-            user = videoRenderer["ownerText"].toObject()["runs"].toArray().at(0).toObject()["text"].toString();
-            publishedTime = videoRenderer["publishedTimeText"].toObject()["simpleText"].toString();
-            viewCount = videoRenderer["shortViewCountText"].toObject()["simpleText"].toString();
-            thumbnail = videoRenderer["thumbnail"].toObject()["thumbnails"].toArray().at(0).toObject()["url"].toString();
+            const auto videoRenderer = obj.toObject()["videoRenderer"].toObject();
+            const auto playlistRenderer = obj.toObject()["playlistRenderer"].toObject();
 
-            url = YOUTUBE_URL "/watch?v=" + contentId;
-        }
-        else
-        {
-            title = playlistRenderer["title"].toObject()["simpleText"].toString();
-            contentId = playlistRenderer["playlistId"].toString();
-            if (title.isEmpty() || contentId.isEmpty())
-                continue;
+            const bool isVideo = !videoRenderer.isEmpty() && playlistRenderer.isEmpty();
 
-            user = playlistRenderer["longBylineText"].toObject()["runs"].toArray().at(0).toObject()["text"].toString();
-            thumbnail = playlistRenderer
-                ["thumbnailRenderer"].toObject()
-                ["playlistVideoThumbnailRenderer"].toObject()
-                ["thumbnail"].toObject()
-                ["thumbnails"].toArray().at(0).toObject()
-                ["url"].toString()
-            ;
+            QString title, contentId, length, user, publishedTime, viewCount, thumbnail, url;
 
-            url = YOUTUBE_URL "/playlist?list=" + contentId;
-        }
+            if (isVideo)
+            {
+                title = videoRenderer["title"].toObject()["runs"].toArray().at(0).toObject()["text"].toString();
+                contentId = videoRenderer["videoId"].toString();
+                if (title.isEmpty() || contentId.isEmpty())
+                    continue;
+
+                length = videoRenderer["lengthText"].toObject()["simpleText"].toString();
+                user = videoRenderer["ownerText"].toObject()["runs"].toArray().at(0).toObject()["text"].toString();
+                publishedTime = videoRenderer["publishedTimeText"].toObject()["simpleText"].toString();
+                viewCount = videoRenderer["shortViewCountText"].toObject()["simpleText"].toString();
+                thumbnail = videoRenderer["thumbnail"].toObject()["thumbnails"].toArray().at(0).toObject()["url"].toString();
+
+                url = YOUTUBE_URL "/watch?v=" + contentId;
+            }
+            else
+            {
+                title = playlistRenderer["title"].toObject()["simpleText"].toString();
+                contentId = playlistRenderer["playlistId"].toString();
+                if (title.isEmpty() || contentId.isEmpty())
+                    continue;
+
+                user = playlistRenderer["longBylineText"].toObject()["runs"].toArray().at(0).toObject()["text"].toString();
+                thumbnail = playlistRenderer
+                    ["thumbnailRenderer"].toObject()
+                    ["playlistVideoThumbnailRenderer"].toObject()
+                    ["thumbnail"].toObject()
+                    ["thumbnails"].toArray().at(0).toObject()
+                    ["url"].toString()
+                ;
+
+                url = YOUTUBE_URL "/playlist?list=" + contentId;
+            }
 
-        auto tWI = new QTreeWidgetItem(resultsW);
+            auto tWI = new QTreeWidgetItem(resultsW);
 
-        tWI->setText(0, title);
-        tWI->setText(1, isVideo ? length : tr("Playlist"));
-        tWI->setText(2, user);
+            tWI->setText(0, title);
+            tWI->setText(1, isVideo ? length : tr("Playlist"));
+            tWI->setText(2, user);
 
-        QString tooltip;
-        tooltip += QString("%1: %2\n").arg(resultsW->headerItem()->text(0), tWI->text(0));
-        tooltip += QString("%1: %2\n").arg(isVideo ? resultsW->headerItem()->text(1) : tr("Playlist"), isVideo ? tWI->text(1) : tr("yes"));
-        tooltip += QString("%1: %2\n").arg(resultsW->headerItem()->text(2), tWI->text(2));
-        tooltip += QString("%1: %2\n").arg(tr("Published time"), publishedTime);
-        tooltip += QString("%1: %2").arg(tr("View count"), viewCount);
-        tWI->setToolTip(0, tooltip);
+            QString tooltip;
+            tooltip += QString("%1: %2\n").arg(resultsW->headerItem()->text(0), tWI->text(0));
+            tooltip += QString("%1: %2\n").arg(isVideo ? resultsW->headerItem()->text(1) : tr("Playlist"), isVideo ? tWI->text(1) : tr("yes"));
+            tooltip += QString("%1: %2\n").arg(resultsW->headerItem()->text(2), tWI->text(2));
+            tooltip += QString("%1: %2\n").arg(tr("Published time"), publishedTime);
+            tooltip += QString("%1: %2").arg(tr("View count"), viewCount);
+            tWI->setToolTip(0, tooltip);
 
-        tWI->setData(0, Qt::UserRole, url);
-        tWI->setData(1, Qt::UserRole, !isVideo);
+            tWI->setData(0, Qt::UserRole, url);
+            tWI->setData(1, Qt::UserRole, !isVideo);
 
-        if (!isVideo)
-        {
-            tWI->setDisabled(true);
+            if (!isVideo)
+            {
+                tWI->setDisabled(true);
 
-            auto linkReply = net.start(url);
-            linkReply->setProperty("tWI", QVariant::fromValue((void *)tWI));
-            linkReplies += linkReply;
-        }
+                auto linkReply = net.start(url);
+                linkReply->setProperty("tWI", QVariant::fromValue((void *)tWI));
+                linkReplies += linkReply;
+            }
 
-        if (!thumbnail.isEmpty())
-        {
-            auto imageReply = net.start(thumbnail);
-            imageReply->setProperty("tWI", QVariant::fromValue((void *)tWI));
-            imageReplies += imageReply;
+            if (!thumbnail.isEmpty())
+            {
+                auto imageReply = net.start(thumbnail);
+                imageReply->setProperty("tWI", QVariant::fromValue((void *)tWI));
+                imageReplies += imageReply;
+            }
         }
     }
 
@@ -1048,7 +1049,7 @@ void YouTube::preparePlaylist(const QByteArray &data, QTreeWidgetItem *tWI)
     {
         const auto playlistRenderer = obj.toObject()["playlistVideoRenderer"].toObject();
 
-        const auto title = playlistRenderer["title"].toObject()["simpleText"].toString();
+        const auto title = playlistRenderer["title"].toObject()["runs"].toArray().at(0).toObject()["text"].toString();
         const auto videoId = playlistRenderer["videoId"].toString();
         if (title.isEmpty() || videoId.isEmpty())
             continue;
@@ -1076,13 +1077,10 @@ QJsonDocument YouTube::getYtInitialData(const QByteArray &data)
     if (idx < 0)
         return QJsonDocument();
 
-    int idx2 = data.indexOf("\n", idx);
+    int idx2 = Functions::findJsonEnd(data, idx);
     if (idx2 < 0)
         return QJsonDocument();
 
-    auto jsonData = data.mid(idx, idx2 - idx);
-    if (jsonData.endsWith(';'))
-        jsonData.chop(1);
-
+    const auto jsonData = data.mid(idx, idx2 - idx);
     return QJsonDocument::fromJson(jsonData);
 }

--- a/src/qmplay2/Functions.cpp
+++ b/src/qmplay2/Functions.cpp
@@ -940,6 +940,46 @@ QByteArray Functions::textWithFallbackEncoding(const QByteArray &data)
     return data;
 }
 
+int Functions::findJsonEnd(const QByteArray &data, int idx)
+{
+    const int dataLen = data.length();
+
+    if (dataLen < 1 || idx < 0 || idx >= dataLen || data.at(idx) != '{')
+        return -1;
+
+    int brackets = 1;
+    bool inString = false;
+    char prevChr = '\0';
+
+    for (int i = idx + 1; i < dataLen; ++i)
+    {
+        const char chr = data.at(i);
+
+        if (chr == '"')
+        {
+            if (!inString)
+                inString = true;
+            else if (prevChr != '\\')
+                inString = false;
+        }
+
+        prevChr = chr;
+
+        if (inString)
+            continue;
+
+        if (chr == '{')
+            ++brackets;
+        else if (chr == '}')
+            --brackets;
+
+        if (brackets == 0)
+            return i + 1;
+    }
+
+    return -1;
+}
+
 Functions::LumaCoefficients Functions::getLumaCoeff(AVColorSpace colorSpace)
 {
     switch (colorSpace)

--- a/src/qmplay2/Functions.hpp
+++ b/src/qmplay2/Functions.hpp
@@ -149,6 +149,8 @@ namespace Functions
 
     QMPLAY2SHAREDLIB_EXPORT QByteArray textWithFallbackEncoding(const QByteArray &data);
 
+    QMPLAY2SHAREDLIB_EXPORT int findJsonEnd(const QByteArray &data, int idx = 0);
+
     struct LumaCoefficients
     {
         float cR, cG, cB;

--- a/src/qmplay2/GPUInstance.cpp
+++ b/src/qmplay2/GPUInstance.cpp
@@ -73,6 +73,10 @@ shared_ptr<GPUInstance> GPUInstance::create()
     return nullptr;
 }
 
+void GPUInstance::prepareDestroy()
+{
+}
+
 shared_ptr<HWDecContext> GPUInstance::getHWDecContext() const
 {
     if (m_videoWriter)

--- a/src/qmplay2/GPUInstance.hpp
+++ b/src/qmplay2/GPUInstance.hpp
@@ -31,6 +31,8 @@ public:
 public:
     virtual ~GPUInstance() = default;
 
+    virtual void prepareDestroy();
+
     virtual QString name() const = 0;
     virtual QMPlay2CoreClass::Renderer renderer() const = 0;
 
--- a/src/qmplay2/QMPlay2Core.cpp
+++ b/src/qmplay2/QMPlay2Core.cpp
@@ -389,7 +389,11 @@ void QMPlay2CoreClass::quit()
     delete qtTranslator;
     delete translator;
     delete settings;
-    m_gpuInstance.reset();
+    if (m_gpuInstance)
+    {
+        m_gpuInstance->prepareDestroy();
+        m_gpuInstance.reset();
+    }
 }
 
 bool QMPlay2CoreClass::canSuspend()

--- a/src/qmplay2/vulkan/VulkanInstance.cpp
+++ b/src/qmplay2/vulkan/VulkanInstance.cpp
@@ -148,6 +148,11 @@ Instance::~Instance()
     delete m_qVulkanInstance;
 }
 
+void Instance::prepareDestroy()
+{
+    m_physicalDevice.reset();
+}
+
 void Instance::init()
 {
 #ifdef QT_DEBUG

--- a/src/qmplay2/vulkan/VulkanInstance.hpp
+++ b/src/qmplay2/vulkan/VulkanInstance.hpp
@@ -55,6 +55,8 @@ public:
     Instance(Priv);
     ~Instance();
 
+    void prepareDestroy() override;
+
 private:
     void init();
 
