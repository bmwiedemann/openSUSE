diff --git a/Cargo.lock b/Cargo.lock
index 6f54a9380d..09911c0273 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2063,8 +2063,6 @@ dependencies = [
 [[package]]
 name = "glslopt"
 version = "0.1.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "74a3f5c04450dfdadb4b08f6e5ee6f5110f674de1acbd6199bfec68392a8cbaf"
 dependencies = [
  "cc",
 ]
diff --git a/Cargo.toml b/Cargo.toml
index 09f3e7292f..3581baf2aa 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -83,6 +83,7 @@ rlbox_lucet_sandbox = { git = "https://github.com/PLSysSec/rlbox_lucet_sandbox/"
 nix = { git = "https://github.com/shravanrn/nix/", rev="4af6c367603869a30fddb5ffb0aba2b9477ba92e" }
 spirv_cross = { git = "https://github.com/kvark/spirv_cross", branch = "wgpu5" }
 minidump_writer_linux = { git = "https://github.com/msirringhaus/minidump_writer_linux.git", rev = "85551909b95a5cf553a85dbcddfa5f117cfbbe0e" }
+glslopt = { path = "third_party/rust/glslopt/" }
 
 
 [patch.crates-io.cranelift-codegen]
@@ -105,4 +106,4 @@ path = "third_party/rust/mio"
 
 # Patch failure 0.1.8 to disable the backtrace feature by default. See bug 1608157.
 [patch.crates-io.failure]
-path = "third_party/rust/failure"
\ No newline at end of file
+path = "third_party/rust/failure"
diff --git a/gfx/skia/skia/include/codec/SkEncodedOrigin.h b/gfx/skia/skia/include/codec/SkEncodedOrigin.h
index 2eed1c6ac6..49d0309034 100644
--- a/gfx/skia/skia/include/codec/SkEncodedOrigin.h
+++ b/gfx/skia/skia/include/codec/SkEncodedOrigin.h
@@ -41,6 +41,7 @@ static inline SkMatrix SkEncodedOriginToMatrix(SkEncodedOrigin origin, int w, in
         case  kLeftBottom_SkEncodedOrigin: return SkMatrix::MakeAll( 0,  1, 0, -1,  0, w, 0, 0, 1);
     }
     SK_ABORT("Unexpected origin");
+    SkUNREACHABLE;
 }
 
 
diff --git a/gfx/skia/skia/include/private/GrTypesPriv.h b/gfx/skia/skia/include/private/GrTypesPriv.h
index 90718038e0..4ec7729ab8 100644
--- a/gfx/skia/skia/include/private/GrTypesPriv.h
+++ b/gfx/skia/skia/include/private/GrTypesPriv.h
@@ -540,6 +540,7 @@ static inline GrSLType GrSLCombinedSamplerTypeForTextureType(GrTextureType type)
         default:
             SK_ABORT("Unexpected texture type");
     }
+    SkUNREACHABLE;
 }
 
 /** Rectangle and external textures only support the clamp wrap mode and do not support
@@ -556,6 +557,7 @@ static inline bool GrTextureTypeHasRestrictedSampling(GrTextureType type) {
         default:
             SK_ABORT("Unexpected texture type");
     }
+    SkUNREACHABLE;
 }
 
 static constexpr bool GrSLTypeIsCombinedSamplerType(GrSLType type) {
@@ -858,6 +860,7 @@ static inline size_t GrCompressedFormatDataSize(SkImage::CompressionType compres
     }
 
     SK_ABORT("Invalid pixel config");
+    SkUNREACHABLE;
 }
 
 /**
diff --git a/gfx/skia/skia/src/core/SkGeometry.h b/gfx/skia/skia/src/core/SkGeometry.h
index 23bdbc1c42..ea2d23f6e8 100644
--- a/gfx/skia/skia/src/core/SkGeometry.h
+++ b/gfx/skia/skia/src/core/SkGeometry.h
@@ -182,6 +182,7 @@ static inline bool SkCubicIsDegenerate(SkCubicType type) {
             return true;
     }
     SK_ABORT("Invalid SkCubicType");
+    SkUNREACHABLE;
 }
 
 static inline const char* SkCubicTypeName(SkCubicType type) {
@@ -194,6 +195,7 @@ static inline const char* SkCubicTypeName(SkCubicType type) {
         case SkCubicType::kLineOrPoint: return "kLineOrPoint";
     }
     SK_ABORT("Invalid SkCubicType");
+    SkUNREACHABLE;
 }
 
 /** Returns the cubic classification.
diff --git a/gfx/skia/skia/src/core/SkTextBlob.cpp b/gfx/skia/skia/src/core/SkTextBlob.cpp
index 3c84bda6f8..e2fba375cc 100644
--- a/gfx/skia/skia/src/core/SkTextBlob.cpp
+++ b/gfx/skia/skia/src/core/SkTextBlob.cpp
@@ -201,6 +201,7 @@ void SkTextBlob::operator delete(void* p) {
 
 void* SkTextBlob::operator new(size_t) {
     SK_ABORT("All blobs are created by placement new.");
+    SkUNREACHABLE;
 }
 
 void* SkTextBlob::operator new(size_t, void* p) {
diff --git a/gfx/skia/skia/src/core/SkTypeface_remote.cpp b/gfx/skia/skia/src/core/SkTypeface_remote.cpp
index 838a783313..d878fadc08 100644
--- a/gfx/skia/skia/src/core/SkTypeface_remote.cpp
+++ b/gfx/skia/skia/src/core/SkTypeface_remote.cpp
@@ -29,6 +29,7 @@ void SkScalerContextProxy::initCache(SkStrike* cache, SkStrikeCache* strikeCache
 
 unsigned SkScalerContextProxy::generateGlyphCount()  {
     SK_ABORT("Should never be called.");
+    SkUNREACHABLE;
 }
 
 bool SkScalerContextProxy::generateAdvance(SkGlyph* glyph) {
diff --git a/gfx/skia/skia/src/core/SkTypeface_remote.h b/gfx/skia/skia/src/core/SkTypeface_remote.h
index 3d454cf760..554f7c0617 100644
--- a/gfx/skia/skia/src/core/SkTypeface_remote.h
+++ b/gfx/skia/skia/src/core/SkTypeface_remote.h
@@ -63,23 +63,28 @@ public:
     bool isLogging() const {return fIsLogging;}
 
 protected:
-    int onGetUPEM() const override { SK_ABORT("Should never be called."); }
+    int onGetUPEM() const override { SK_ABORT("Should never be called."); SkUNREACHABLE; }
     std::unique_ptr<SkStreamAsset> onOpenStream(int* ttcIndex) const override {
         SK_ABORT("Should never be called.");
+	SkUNREACHABLE;
     }
     std::unique_ptr<SkFontData> onMakeFontData() const override {
         SK_ABORT("Should never be called.");
+	SkUNREACHABLE;
     }
     sk_sp<SkTypeface> onMakeClone(const SkFontArguments& args) const override {
         SK_ABORT("Should never be called.");
+	SkUNREACHABLE;
     }
     int onGetVariationDesignPosition(SkFontArguments::VariationPosition::Coordinate coordinates[],
                                      int coordinateCount) const override {
         SK_ABORT("Should never be called.");
+	SkUNREACHABLE;
     }
     int onGetVariationDesignParameters(SkFontParameters::Variation::Axis parameters[],
                                        int parameterCount) const override {
         SK_ABORT("Should never be called.");
+	SkUNREACHABLE;
     }
     void onGetFamilyName(SkString* familyName) const override {
         // Used by SkStrikeCache::DumpMemoryStatistics.
@@ -87,12 +92,15 @@ protected:
     }
     SkTypeface::LocalizedStrings* onCreateFamilyNameIterator() const override {
         SK_ABORT("Should never be called.");
+	SkUNREACHABLE;
     }
     int onGetTableTags(SkFontTableTag tags[]) const override {
         SK_ABORT("Should never be called.");
+	SkUNREACHABLE;
     }
     size_t onGetTableData(SkFontTableTag, size_t offset, size_t length, void* data) const override {
         SK_ABORT("Should never be called.");
+	SkUNREACHABLE;
     }
     SkScalerContext* onCreateScalerContext(const SkScalerContextEffects& effects,
                                            const SkDescriptor* desc) const override {
@@ -116,6 +124,7 @@ protected:
 
     std::unique_ptr<SkAdvancedTypefaceMetrics> onGetAdvancedMetrics() const override {
         SK_ABORT("Should never be called.");
+	SkUNREACHABLE;
     }
     void onCharsToGlyphs(const SkUnichar* chars, int count, SkGlyphID glyphs[]) const override {
         SK_ABORT("Should never be called.");
@@ -126,6 +135,7 @@ protected:
 
     void* onGetCTFontRef() const override {
         SK_ABORT("Should never be called.");
+	SkUNREACHABLE;
     }
 
 private:
diff --git a/gfx/skia/skia/src/effects/imagefilters/SkBlurImageFilter.cpp b/gfx/skia/skia/src/effects/imagefilters/SkBlurImageFilter.cpp
index 2dde5e2be7..dd8550dfad 100644
--- a/gfx/skia/skia/src/effects/imagefilters/SkBlurImageFilter.cpp
+++ b/gfx/skia/skia/src/effects/imagefilters/SkBlurImageFilter.cpp
@@ -144,6 +144,7 @@ static GrTextureDomain::Mode to_texture_domain_mode(SkTileMode tileMode) {
             return GrTextureDomain::kRepeat_Mode;
         default:
             SK_ABORT("Unsupported tile mode.");
+	    SkUNREACHABLE;
     }
 }
 #endif
diff --git a/gfx/skia/skia/src/effects/imagefilters/SkLightingImageFilter.cpp b/gfx/skia/skia/src/effects/imagefilters/SkLightingImageFilter.cpp
index 43d32dcc91..4a8143e2e2 100644
--- a/gfx/skia/skia/src/effects/imagefilters/SkLightingImageFilter.cpp
+++ b/gfx/skia/skia/src/effects/imagefilters/SkLightingImageFilter.cpp
@@ -1701,6 +1701,7 @@ static SkImageFilterLight* create_random_light(SkRandom* random) {
         }
         default:
             SK_ABORT("Unexpected value.");
+	    SkUNREACHABLE;
     }
 }
 
diff --git a/gfx/skia/skia/src/fonts/SkFontMgr_indirect.cpp b/gfx/skia/skia/src/fonts/SkFontMgr_indirect.cpp
index da7678a725..63330e58c2 100644
--- a/gfx/skia/skia/src/fonts/SkFontMgr_indirect.cpp
+++ b/gfx/skia/skia/src/fonts/SkFontMgr_indirect.cpp
@@ -69,6 +69,7 @@ void SkFontMgr_Indirect::onGetFamilyName(int index, SkString* familyName) const
 
 SkFontStyleSet* SkFontMgr_Indirect::onCreateStyleSet(int index) const {
     SK_ABORT("Not implemented");
+    SkUNREACHABLE;
 }
 
 SkFontStyleSet* SkFontMgr_Indirect::onMatchFamily(const char familyName[]) const {
diff --git a/gfx/skia/skia/src/gpu/GrDataUtils.cpp b/gfx/skia/skia/src/gpu/GrDataUtils.cpp
index 6265aaec28..0da5190e4a 100644
--- a/gfx/skia/skia/src/gpu/GrDataUtils.cpp
+++ b/gfx/skia/skia/src/gpu/GrDataUtils.cpp
@@ -128,6 +128,7 @@ size_t GrCompressedDataSize(SkImage::CompressionType type, int width, int height
             return numBlocks * sizeof(ETC1Block);
     }
     SK_ABORT("Unexpected compression type");
+    SkUNREACHABLE;
 }
 
 size_t GrCompressedRowBytes(SkImage::CompressionType type, int width) {
@@ -137,6 +138,7 @@ size_t GrCompressedRowBytes(SkImage::CompressionType type, int width) {
             return numBlocksWidth * sizeof(ETC1Block);
     }
     SK_ABORT("Unexpected compression type");
+    SkUNREACHABLE;
 }
 
 // Fill in 'dest' with ETC1 blocks derived from 'colorf'
diff --git a/gfx/skia/skia/src/gpu/GrFragmentProcessor.h b/gfx/skia/skia/src/gpu/GrFragmentProcessor.h
index 21e27b868b..5b96868075 100644
--- a/gfx/skia/skia/src/gpu/GrFragmentProcessor.h
+++ b/gfx/skia/skia/src/gpu/GrFragmentProcessor.h
@@ -375,6 +375,7 @@ protected:
 private:
     virtual SkPMColor4f constantOutputForConstantInput(const SkPMColor4f& /* inputColor */) const {
         SK_ABORT("Subclass must override this if advertising this optimization.");
+	SkUNREACHABLE;
     }
 
     /** Returns a new instance of the appropriate *GL* implementation class
diff --git a/gfx/skia/skia/src/gpu/GrPathRendering.cpp b/gfx/skia/skia/src/gpu/GrPathRendering.cpp
index 5e44531d2e..a6bd5e4cbc 100644
--- a/gfx/skia/skia/src/gpu/GrPathRendering.cpp
+++ b/gfx/skia/skia/src/gpu/GrPathRendering.cpp
@@ -19,6 +19,7 @@ const GrUserStencilSettings& GrPathRendering::GetStencilPassSettings(FillType fi
     switch (fill) {
         default:
             SK_ABORT("Unexpected path fill.");
+	    SkUNREACHABLE;
         case GrPathRendering::kWinding_FillType: {
             constexpr static GrUserStencilSettings kWindingStencilPass(
                 GrUserStencilSettings::StaticInit<
diff --git a/gfx/skia/skia/src/gpu/GrPathRendering.h b/gfx/skia/skia/src/gpu/GrPathRendering.h
index 3e143e4d0f..3a672fabc6 100644
--- a/gfx/skia/skia/src/gpu/GrPathRendering.h
+++ b/gfx/skia/skia/src/gpu/GrPathRendering.h
@@ -63,6 +63,7 @@ public:
 
             default:
                 SK_ABORT("Unknown path transform type");
+		SkUNREACHABLE;
         }
     }
 
diff --git a/gfx/skia/skia/src/gpu/GrProcessorUnitTest.cpp b/gfx/skia/skia/src/gpu/GrProcessorUnitTest.cpp
index 8d8efa7685..2d56d2cb09 100644
--- a/gfx/skia/skia/src/gpu/GrProcessorUnitTest.cpp
+++ b/gfx/skia/skia/src/gpu/GrProcessorUnitTest.cpp
@@ -20,6 +20,7 @@ std::unique_ptr<GrFragmentProcessor> GrProcessorUnitTest::MakeChildFP(GrProcesso
     return fp;
 #else
     SK_ABORT("Should not be called if !SK_ALLOW_STATIC_GLOBAL_INITIALIZERS");
+    SkUNREACHABLE;
 #endif
 }
 #endif
diff --git a/gfx/skia/skia/src/gpu/GrReducedClip.cpp b/gfx/skia/skia/src/gpu/GrReducedClip.cpp
index 9224e005c6..5c1d44b613 100644
--- a/gfx/skia/skia/src/gpu/GrReducedClip.cpp
+++ b/gfx/skia/skia/src/gpu/GrReducedClip.cpp
@@ -525,6 +525,7 @@ GrReducedClip::ClipResult GrReducedClip::clipInsideElement(const Element* elemen
     }
 
     SK_ABORT("Unexpected DeviceSpaceType");
+    SkUNREACHABLE;
 }
 
 GrReducedClip::ClipResult GrReducedClip::clipOutsideElement(const Element* element) {
@@ -591,6 +592,7 @@ GrReducedClip::ClipResult GrReducedClip::clipOutsideElement(const Element* eleme
     }
 
     SK_ABORT("Unexpected DeviceSpaceType");
+    SkUNREACHABLE;
 }
 
 inline void GrReducedClip::addWindowRectangle(const SkRect& elementInteriorRect, bool elementIsAA) {
diff --git a/gfx/skia/skia/src/gpu/GrResourceCache.cpp b/gfx/skia/skia/src/gpu/GrResourceCache.cpp
index 6d9a961886..5f2e68dd7b 100644
--- a/gfx/skia/skia/src/gpu/GrResourceCache.cpp
+++ b/gfx/skia/skia/src/gpu/GrResourceCache.cpp
@@ -40,6 +40,7 @@ GrScratchKey::ResourceType GrScratchKey::GenerateResourceType() {
     int32_t type = nextType++;
     if (type > SkTo<int32_t>(UINT16_MAX)) {
         SK_ABORT("Too many Resource Types");
+	SkUNREACHABLE;
     }
 
     return static_cast<ResourceType>(type);
@@ -51,6 +52,7 @@ GrUniqueKey::Domain GrUniqueKey::GenerateDomain() {
     int32_t domain = nextDomain++;
     if (domain > SkTo<int32_t>(UINT16_MAX)) {
         SK_ABORT("Too many GrUniqueKey Domains");
+	SkUNREACHABLE;
     }
 
     return static_cast<Domain>(domain);
diff --git a/gfx/skia/skia/src/gpu/GrShaderVar.cpp b/gfx/skia/skia/src/gpu/GrShaderVar.cpp
index 6f7ccccd60..67156a74bc 100644
--- a/gfx/skia/skia/src/gpu/GrShaderVar.cpp
+++ b/gfx/skia/skia/src/gpu/GrShaderVar.cpp
@@ -18,6 +18,7 @@ static const char* type_modifier_string(GrShaderVar::TypeModifier t) {
         case GrShaderVar::kUniform_TypeModifier: return "uniform";
     }
     SK_ABORT("Unknown shader variable type modifier.");
+    SkUNREACHABLE;
 }
 
 void GrShaderVar::setIOType(GrIOType ioType) {
@@ -32,6 +33,7 @@ void GrShaderVar::setIOType(GrIOType ioType) {
             return;
     }
     SK_ABORT("Unknown io type.");
+    SkUNREACHABLE;
 }
 
 void GrShaderVar::appendDecl(const GrShaderCaps* shaderCaps, SkString* out) const {
diff --git a/gfx/skia/skia/src/gpu/SkGpuDevice.cpp b/gfx/skia/skia/src/gpu/SkGpuDevice.cpp
index 77b9963ba5..f6d7ca05dd 100644
--- a/gfx/skia/skia/src/gpu/SkGpuDevice.cpp
+++ b/gfx/skia/skia/src/gpu/SkGpuDevice.cpp
@@ -283,6 +283,7 @@ static inline GrPrimitiveType point_mode_to_primitive_type(SkCanvas::PointMode m
             return GrPrimitiveType::kLineStrip;
     }
     SK_ABORT("Unexpected mode");
+    SkUNREACHABLE;
 }
 
 void SkGpuDevice::drawPoints(SkCanvas::PointMode mode,
diff --git a/gfx/skia/skia/src/gpu/SkGr.h b/gfx/skia/skia/src/gpu/SkGr.h
index 79a68822b9..716f59d7e6 100644
--- a/gfx/skia/skia/src/gpu/SkGr.h
+++ b/gfx/skia/skia/src/gpu/SkGr.h
@@ -159,6 +159,7 @@ static inline GrPrimitiveType SkVertexModeToGrPrimitiveType(SkVertices::VertexMo
             break;
     }
     SK_ABORT("Invalid mode");
+    SkUNREACHABLE;
 }
 
 //////////////////////////////////////////////////////////////////////////////
diff --git a/gfx/skia/skia/src/gpu/ccpr/GrCCCoverageProcessor.h b/gfx/skia/skia/src/gpu/ccpr/GrCCCoverageProcessor.h
index 5fdb488ea5..eb81f47ba6 100644
--- a/gfx/skia/skia/src/gpu/ccpr/GrCCCoverageProcessor.h
+++ b/gfx/skia/skia/src/gpu/ccpr/GrCCCoverageProcessor.h
@@ -240,6 +240,7 @@ inline const char* GrCCCoverageProcessor::PrimitiveTypeName(PrimitiveType type)
         case PrimitiveType::kConics: return "kConics";
     }
     SK_ABORT("Invalid PrimitiveType");
+    SkUNREACHABLE;
 }
 
 inline void GrCCCoverageProcessor::TriPointInstance::set(
diff --git a/gfx/skia/skia/src/gpu/ccpr/GrCCStrokeGeometry.cpp b/gfx/skia/skia/src/gpu/ccpr/GrCCStrokeGeometry.cpp
index 40884d7d8f..c920365f50 100644
--- a/gfx/skia/skia/src/gpu/ccpr/GrCCStrokeGeometry.cpp
+++ b/gfx/skia/skia/src/gpu/ccpr/GrCCStrokeGeometry.cpp
@@ -60,6 +60,7 @@ static GrCCStrokeGeometry::Verb join_verb_from_join(SkPaint::Join join) {
             return Verb::kRoundJoin;
     }
     SK_ABORT("Invalid SkPaint::Join.");
+    SkUNREACHABLE;
 }
 
 void GrCCStrokeGeometry::beginPath(const SkStrokeRec& stroke, float strokeDevWidth,
diff --git a/gfx/skia/skia/src/gpu/ccpr/GrCCStrokeGeometry.h b/gfx/skia/skia/src/gpu/ccpr/GrCCStrokeGeometry.h
index 24569accc4..d105836141 100644
--- a/gfx/skia/skia/src/gpu/ccpr/GrCCStrokeGeometry.h
+++ b/gfx/skia/skia/src/gpu/ccpr/GrCCStrokeGeometry.h
@@ -175,5 +175,6 @@ inline bool GrCCStrokeGeometry::IsInternalJoinVerb(Verb verb) {
             return false;
     }
     SK_ABORT("Invalid GrCCStrokeGeometry::Verb.");
+    SkUNREACHABLE;
 }
 #endif
diff --git a/gfx/skia/skia/src/gpu/ccpr/GrCoverageCountingPathRenderer.cpp b/gfx/skia/skia/src/gpu/ccpr/GrCoverageCountingPathRenderer.cpp
index 4e86d7e071..0376cf40c3 100644
--- a/gfx/skia/skia/src/gpu/ccpr/GrCoverageCountingPathRenderer.cpp
+++ b/gfx/skia/skia/src/gpu/ccpr/GrCoverageCountingPathRenderer.cpp
@@ -164,6 +164,7 @@ GrPathRenderer::CanDrawPath GrCoverageCountingPathRenderer::onCanDrawPath(
     }
 
     SK_ABORT("Invalid stroke style.");
+    SkUNREACHABLE;
 }
 
 bool GrCoverageCountingPathRenderer::onDrawPath(const DrawPathArgs& args) {
diff --git a/gfx/skia/skia/src/gpu/ccpr/GrVSCoverageProcessor.cpp b/gfx/skia/skia/src/gpu/ccpr/GrVSCoverageProcessor.cpp
index ae5cfca504..89beff076a 100644
--- a/gfx/skia/skia/src/gpu/ccpr/GrVSCoverageProcessor.cpp
+++ b/gfx/skia/skia/src/gpu/ccpr/GrVSCoverageProcessor.cpp
@@ -550,4 +550,5 @@ GrGLSLPrimitiveProcessor* GrVSCoverageProcessor::onCreateGLSLInstance(
             return new Impl(std::move(shader), 4);
     }
     SK_ABORT("Invalid PrimitiveType");
+    SkUNREACHABLE;
 }
diff --git a/gfx/skia/skia/src/gpu/dawn/GrDawnOpsRenderPass.cpp b/gfx/skia/skia/src/gpu/dawn/GrDawnOpsRenderPass.cpp
index 48fc8a7f48..9321f43b7e 100644
--- a/gfx/skia/skia/src/gpu/dawn/GrDawnOpsRenderPass.cpp
+++ b/gfx/skia/skia/src/gpu/dawn/GrDawnOpsRenderPass.cpp
@@ -39,7 +39,9 @@ static dawn::LoadOp to_dawn_load_op(GrLoadOp loadOp) {
             return dawn::LoadOp::Clear;
         default:
             SK_ABORT("Invalid LoadOp");
+	    SkUNREACHABLE;
     }
+    SkUNREACHABLE;
 }
 
 GrDawnOpsRenderPass::GrDawnOpsRenderPass(GrDawnGpu* gpu, GrRenderTarget* rt, GrSurfaceOrigin origin,
diff --git a/gfx/skia/skia/src/gpu/dawn/GrDawnUniformHandler.cpp b/gfx/skia/skia/src/gpu/dawn/GrDawnUniformHandler.cpp
index 74fd1e31a4..2546126406 100644
--- a/gfx/skia/skia/src/gpu/dawn/GrDawnUniformHandler.cpp
+++ b/gfx/skia/skia/src/gpu/dawn/GrDawnUniformHandler.cpp
@@ -95,6 +95,7 @@ uint32_t grsltype_to_alignment_mask(GrSLType type) {
             break;
     }
     SK_ABORT("Unexpected type");
+    SkUNREACHABLE;
 }
 
 static inline uint32_t grsltype_to_size(GrSLType type) {
@@ -173,6 +174,7 @@ static inline uint32_t grsltype_to_size(GrSLType type) {
             break;
     }
     SK_ABORT("Unexpected type");
+    SkUNREACHABLE;
 }
 
 uint32_t get_ubo_offset(uint32_t* currentOffset,
diff --git a/gfx/skia/skia/src/gpu/dawn/GrDawnVaryingHandler.cpp b/gfx/skia/skia/src/gpu/dawn/GrDawnVaryingHandler.cpp
index b3885d20c9..0d2bac39de 100644
--- a/gfx/skia/skia/src/gpu/dawn/GrDawnVaryingHandler.cpp
+++ b/gfx/skia/skia/src/gpu/dawn/GrDawnVaryingHandler.cpp
@@ -76,6 +76,7 @@ static inline int grsltype_to_location_size(GrSLType type) {
              return 0;
     }
     SK_ABORT("Unexpected type");
+    SkUNREACHABLE;
 }
 
 static void finalize_helper(GrDawnVaryingHandler::VarArray& vars) {
diff --git a/gfx/skia/skia/src/gpu/effects/GrConstColorProcessor.fp b/gfx/skia/skia/src/gpu/effects/GrConstColorProcessor.fp
index 18cc91a4b1..fd6694bb76 100644
--- a/gfx/skia/skia/src/gpu/effects/GrConstColorProcessor.fp
+++ b/gfx/skia/skia/src/gpu/effects/GrConstColorProcessor.fp
@@ -58,6 +58,7 @@ void main() {
                 return color * input;
         }
         SK_ABORT("Unexpected mode");
+	SkUNREACHABLE;
     }
 }
 
diff --git a/gfx/skia/skia/src/gpu/effects/GrCoverageSetOpXP.cpp b/gfx/skia/skia/src/gpu/effects/GrCoverageSetOpXP.cpp
index b75842c94a..714fc350d5 100644
--- a/gfx/skia/skia/src/gpu/effects/GrCoverageSetOpXP.cpp
+++ b/gfx/skia/skia/src/gpu/effects/GrCoverageSetOpXP.cpp
@@ -204,6 +204,7 @@ const GrXPFactory* GrCoverageSetOpXPFactory::Get(SkRegion::Op regionOp, bool inv
     }
 #undef _CONSTEXPR_
     SK_ABORT("Unknown region op.");
+    SkUNREACHABLE;
 }
 
 sk_sp<const GrXferProcessor> GrCoverageSetOpXPFactory::makeXferProcessor(
diff --git a/gfx/skia/skia/src/gpu/effects/GrPorterDuffXferProcessor.cpp b/gfx/skia/skia/src/gpu/effects/GrPorterDuffXferProcessor.cpp
index 47d92dbde4..1d44d9ad82 100644
--- a/gfx/skia/skia/src/gpu/effects/GrPorterDuffXferProcessor.cpp
+++ b/gfx/skia/skia/src/gpu/effects/GrPorterDuffXferProcessor.cpp
@@ -753,6 +753,7 @@ const GrXPFactory* GrPorterDuffXPFactory::Get(SkBlendMode blendMode) {
             return &gScreenPDXPF;
         default:
             SK_ABORT("Unexpected blend mode.");
+	    SkUNREACHABLE;
     }
 }
 
diff --git a/gfx/skia/skia/src/gpu/effects/GrSkSLFP.cpp b/gfx/skia/skia/src/gpu/effects/GrSkSLFP.cpp
index 9269ebf668..3169ab6e3f 100644
--- a/gfx/skia/skia/src/gpu/effects/GrSkSLFP.cpp
+++ b/gfx/skia/skia/src/gpu/effects/GrSkSLFP.cpp
@@ -154,6 +154,7 @@ public:
         }
         printf("%s\n", SkSL::String(type.fName).c_str());
         SK_ABORT("unsupported uniform type");
+	SkUNREACHABLE;
     }
 
     void emitCode(EmitArgs& args) override {
@@ -568,6 +569,7 @@ std::unique_ptr<GrFragmentProcessor> GrSkSLFP::TestCreate(GrProcessorTestData* d
         }
     }
     SK_ABORT("unreachable");
+    SkUNREACHABLE;
 }
 
 #endif
diff --git a/gfx/skia/skia/src/gpu/effects/generated/GrConstColorProcessor.h b/gfx/skia/skia/src/gpu/effects/generated/GrConstColorProcessor.h
index df64bce9b7..bc9024cb07 100644
--- a/gfx/skia/skia/src/gpu/effects/generated/GrConstColorProcessor.h
+++ b/gfx/skia/skia/src/gpu/effects/generated/GrConstColorProcessor.h
@@ -41,6 +41,7 @@ public:
                 return color * input;
         }
         SK_ABORT("Unexpected mode");
+	SkUNREACHABLE;
     }
     static std::unique_ptr<GrFragmentProcessor> Make(SkPMColor4f color, InputMode mode) {
         return std::unique_ptr<GrFragmentProcessor>(new GrConstColorProcessor(color, mode));
diff --git a/gfx/skia/skia/src/gpu/geometry/GrShape.cpp b/gfx/skia/skia/src/gpu/geometry/GrShape.cpp
index 4fc3472ffb..f16a2c536e 100644
--- a/gfx/skia/skia/src/gpu/geometry/GrShape.cpp
+++ b/gfx/skia/skia/src/gpu/geometry/GrShape.cpp
@@ -164,6 +164,7 @@ SkRect GrShape::bounds() const {
             return this->path().getBounds();
     }
     SK_ABORT("Unknown shape type");
+    SkUNREACHABLE;
 }
 
 SkRect GrShape::styledBounds() const {
@@ -254,6 +255,7 @@ int GrShape::unstyledKeySize() const {
         }
     }
     SK_ABORT("Should never get here.");
+    SkUNREACHABLE;
 }
 
 void GrShape::writeUnstyledKey(uint32_t* key) const {
diff --git a/gfx/skia/skia/src/gpu/gl/GrGLCaps.cpp b/gfx/skia/skia/src/gpu/gl/GrGLCaps.cpp
index 3142399c58..2dab83639a 100644
--- a/gfx/skia/skia/src/gpu/gl/GrGLCaps.cpp
+++ b/gfx/skia/skia/src/gpu/gl/GrGLCaps.cpp
@@ -4159,6 +4159,7 @@ GrBackendFormat GrGLCaps::getBackendFormatFromCompressionType(
             return GrBackendFormat::MakeGL(GR_GL_COMPRESSED_ETC1_RGB8, GR_GL_TEXTURE_2D);
     }
     SK_ABORT("Invalid compression type");
+    SkUNREACHABLE;
 }
 
 GrSwizzle GrGLCaps::getTextureSwizzle(const GrBackendFormat& format, GrColorType colorType) const {
diff --git a/gfx/skia/skia/src/gpu/gl/GrGLGLSL.cpp b/gfx/skia/skia/src/gpu/gl/GrGLGLSL.cpp
index 2ad38bc35e..8dc730f1b7 100644
--- a/gfx/skia/skia/src/gpu/gl/GrGLGLSL.cpp
+++ b/gfx/skia/skia/src/gpu/gl/GrGLGLSL.cpp
@@ -68,4 +68,5 @@ bool GrGLGetGLSLGeneration(const GrGLInterface* gl, GrGLSLGeneration* generation
         return true;
     }
     SK_ABORT("Unknown GL Standard");
+    SkUNREACHABLE;
 }
diff --git a/gfx/skia/skia/src/gpu/gl/GrGLGpu.cpp b/gfx/skia/skia/src/gpu/gl/GrGLGpu.cpp
index 937e168db5..da66902895 100644
--- a/gfx/skia/skia/src/gpu/gl/GrGLGpu.cpp
+++ b/gfx/skia/skia/src/gpu/gl/GrGLGpu.cpp
@@ -196,6 +196,7 @@ static int gl_target_to_binding_index(GrGLenum target) {
             return 2;
     }
     SK_ABORT("Unexpected GL texture target.");
+    SkUNREACHABLE;
 }
 
 GrGpuResource::UniqueID GrGLGpu::TextureUnitBindings::boundID(GrGLenum target) const {
@@ -234,6 +235,7 @@ static GrGLenum filter_to_gl_mag_filter(GrSamplerState::Filter filter) {
         case GrSamplerState::Filter::kMipMap:  return GR_GL_LINEAR;
     }
     SK_ABORT("Unknown filter");
+    SkUNREACHABLE;
 }
 
 static GrGLenum filter_to_gl_min_filter(GrSamplerState::Filter filter) {
@@ -243,6 +245,7 @@ static GrGLenum filter_to_gl_min_filter(GrSamplerState::Filter filter) {
         case GrSamplerState::Filter::kMipMap:  return GR_GL_LINEAR_MIPMAP_LINEAR;
     }
     SK_ABORT("Unknown filter");
+    SkUNREACHABLE;
 }
 
 static inline GrGLenum wrap_mode_to_gl_wrap(GrSamplerState::WrapMode wrapMode,
@@ -257,6 +260,7 @@ static inline GrGLenum wrap_mode_to_gl_wrap(GrSamplerState::WrapMode wrapMode,
             return GR_GL_CLAMP_TO_BORDER;
     }
     SK_ABORT("Unknown wrap mode");
+    SkUNREACHABLE;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -1107,7 +1111,7 @@ static bool renderbuffer_storage_msaa(const GrGLContext& ctx,
             break;
         case GrGLCaps::kNone_MSFBOType:
             SK_ABORT("Shouldn't be here if we don't support multisampled renderbuffers.");
-            break;
+	    SkUNREACHABLE;
     }
     return (GR_GL_NO_ERROR == CHECK_ALLOC_ERROR(ctx.interface()));
 }
@@ -2275,9 +2279,10 @@ static GrGLenum gr_primitive_type_to_gl_mode(GrPrimitiveType primitiveType) {
             return GR_GL_LINE_STRIP;
         case GrPrimitiveType::kPath:
             SK_ABORT("non-mesh-based GrPrimitiveType");
-            return 0;
+            SkUNREACHABLE;
     }
     SK_ABORT("invalid GrPrimitiveType");
+    SkUNREACHABLE;
 }
 
 void GrGLGpu::sendMeshToGpu(GrPrimitiveType primitiveType, const GrBuffer* vertexBuffer,
@@ -4006,7 +4011,8 @@ int GrGLGpu::TextureToCopyProgramIdx(GrTexture* texture) {
         case kTextureExternalSampler_GrSLType:
             return 2;
         default:
-            SK_ABORT("Unexpected samper type");
+            SK_ABORT("Unexpected sampler type");
+	    SkUNREACHABLE;
     }
 }
 
diff --git a/gfx/skia/skia/src/gpu/gl/GrGLPath.cpp b/gfx/skia/skia/src/gpu/gl/GrGLPath.cpp
index e001bf93a1..8d51f00e4b 100644
--- a/gfx/skia/skia/src/gpu/gl/GrGLPath.cpp
+++ b/gfx/skia/skia/src/gpu/gl/GrGLPath.cpp
@@ -197,6 +197,7 @@ static GrPathRendering::FillType convert_skpath_filltype(SkPath::FillType fill)
     switch (fill) {
         default:
             SK_ABORT("Incomplete Switch\n");
+	    SkUNREACHABLE;
         case SkPath::kWinding_FillType:
         case SkPath::kInverseWinding_FillType:
             return GrPathRendering::kWinding_FillType;
diff --git a/gfx/skia/skia/src/gpu/gl/GrGLTexture.cpp b/gfx/skia/skia/src/gpu/gl/GrGLTexture.cpp
index a5a1a3708b..1a223cf1e2 100644
--- a/gfx/skia/skia/src/gpu/gl/GrGLTexture.cpp
+++ b/gfx/skia/skia/src/gpu/gl/GrGLTexture.cpp
@@ -25,6 +25,7 @@ GrTextureType GrGLTexture::TextureTypeFromTarget(GrGLenum target) {
             return GrTextureType::kExternal;
     }
     SK_ABORT("Unexpected texture target");
+    SkUNREACHABLE;
 }
 
 static inline GrGLenum target_from_texture_type(GrTextureType type) {
@@ -37,8 +38,10 @@ static inline GrGLenum target_from_texture_type(GrTextureType type) {
             return GR_GL_TEXTURE_EXTERNAL;
         default:
             SK_ABORT("Unexpected texture target");
+	    SkUNREACHABLE;
     }
     SK_ABORT("Unexpected texture type");
+    SkUNREACHABLE;
 }
 
 // Because this class is virtually derived from GrSurface we must explicitly call its constructor.
diff --git a/gfx/skia/skia/src/gpu/gl/GrGLVertexArray.cpp b/gfx/skia/skia/src/gpu/gl/GrGLVertexArray.cpp
index cfac573241..4d878af131 100644
--- a/gfx/skia/skia/src/gpu/gl/GrGLVertexArray.cpp
+++ b/gfx/skia/skia/src/gpu/gl/GrGLVertexArray.cpp
@@ -80,6 +80,7 @@ static AttribLayout attrib_layout(GrVertexAttribType type) {
             return {true, 4, GR_GL_UNSIGNED_SHORT};
     }
     SK_ABORT("Unknown vertex attrib type");
+    SkUNREACHABLE;
 };
 
 void GrGLAttribArrayState::set(GrGLGpu* gpu,
diff --git a/gfx/skia/skia/src/gpu/glsl/GrGLSL.cpp b/gfx/skia/skia/src/gpu/glsl/GrGLSL.cpp
index afa9159bb0..d073fa6f8b 100644
--- a/gfx/skia/skia/src/gpu/glsl/GrGLSL.cpp
+++ b/gfx/skia/skia/src/gpu/glsl/GrGLSL.cpp
@@ -98,4 +98,5 @@ const char* GrGLSLTypeString(GrSLType t) {
             return "sampler";
     }
     SK_ABORT("Unknown shader var type.");
+    SkUNREACHABLE;
 }
diff --git a/gfx/skia/skia/src/gpu/glsl/GrGLSLVarying.cpp b/gfx/skia/skia/src/gpu/glsl/GrGLSLVarying.cpp
index ce086a9082..16a0171e7d 100644
--- a/gfx/skia/skia/src/gpu/glsl/GrGLSLVarying.cpp
+++ b/gfx/skia/skia/src/gpu/glsl/GrGLSLVarying.cpp
@@ -35,6 +35,7 @@ static bool use_flat_interpolation(GrGLSLVaryingHandler::Interpolation interpola
             return true;
     }
     SK_ABORT("Invalid interpolation");
+    SkUNREACHABLE;
 }
 
 void GrGLSLVaryingHandler::addVarying(const char* name, GrGLSLVarying* varying,
diff --git a/gfx/skia/skia/src/gpu/glsl/GrGLSLVertexGeoBuilder.cpp b/gfx/skia/skia/src/gpu/glsl/GrGLSLVertexGeoBuilder.cpp
index ccec08db8b..751b40e9fe 100644
--- a/gfx/skia/skia/src/gpu/glsl/GrGLSLVertexGeoBuilder.cpp
+++ b/gfx/skia/skia/src/gpu/glsl/GrGLSLVertexGeoBuilder.cpp
@@ -51,6 +51,7 @@ static const char* input_type_name(GrGLSLGeometryBuilder::InputType in) {
         case InputType::kTriangles: return "triangles";
     }
     SK_ABORT("invalid input type");
+    SkUNREACHABLE;
 }
 
 static const char* output_type_name(GrGLSLGeometryBuilder::OutputType out) {
@@ -61,6 +62,7 @@ static const char* output_type_name(GrGLSLGeometryBuilder::OutputType out) {
         case OutputType::kTriangleStrip: return "triangle_strip";
     }
     SK_ABORT("invalid output type");
+    SkUNREACHABLE;
 }
 
 void GrGLSLGeometryBuilder::configure(InputType inputType, OutputType outputType, int maxVertices,
diff --git a/gfx/skia/skia/src/gpu/mtl/GrMtlCaps.mm b/gfx/skia/skia/src/gpu/mtl/GrMtlCaps.mm
index 7511f26366..82ff3db772 100644
--- a/gfx/skia/skia/src/gpu/mtl/GrMtlCaps.mm
+++ b/gfx/skia/skia/src/gpu/mtl/GrMtlCaps.mm
@@ -506,6 +506,7 @@ size_t GrMtlCaps::GetFormatIndex(MTLPixelFormat pixelFormat) {
         }
     }
     SK_ABORT("Invalid MTLPixelFormat");
+    SkUNREACHABLE;
 }
 
 void GrMtlCaps::initFormatTable() {
@@ -1011,6 +1012,7 @@ GrBackendFormat GrMtlCaps::getBackendFormatFromCompressionType(
 #endif
     }
     SK_ABORT("Invalid compression type");
+    SkUNREACHABLE;
 }
 
 GrSwizzle GrMtlCaps::getTextureSwizzle(const GrBackendFormat& format, GrColorType colorType) const {
diff --git a/gfx/skia/skia/src/gpu/mtl/GrMtlPipelineStateBuilder.mm b/gfx/skia/skia/src/gpu/mtl/GrMtlPipelineStateBuilder.mm
index 090c41b9de..4be37d4c53 100644
--- a/gfx/skia/skia/src/gpu/mtl/GrMtlPipelineStateBuilder.mm
+++ b/gfx/skia/skia/src/gpu/mtl/GrMtlPipelineStateBuilder.mm
@@ -155,6 +155,7 @@ static inline MTLVertexFormat attribute_type_to_mtlformat(GrVertexAttribType typ
             return MTLVertexFormatUShort4Normalized;
     }
     SK_ABORT("Unknown vertex attribute type");
+    SkUNREACHABLE;
 }
 
 static MTLVertexDescriptor* create_vertex_descriptor(const GrPrimitiveProcessor& primProc) {
@@ -276,6 +277,7 @@ static MTLBlendFactor blend_coeff_to_mtl_blend(GrBlendCoeff coeff) {
     }
 
     SK_ABORT("Unknown blend coefficient");
+    SkUNREACHABLE;
 }
 
 static MTLBlendOperation blend_equation_to_mtl_blend_op(GrBlendEquation equation) {
diff --git a/gfx/skia/skia/src/gpu/mtl/GrMtlSampler.mm b/gfx/skia/skia/src/gpu/mtl/GrMtlSampler.mm
index 2d7344eff7..2d03c968bf 100644
--- a/gfx/skia/skia/src/gpu/mtl/GrMtlSampler.mm
+++ b/gfx/skia/skia/src/gpu/mtl/GrMtlSampler.mm
@@ -38,6 +38,7 @@ static inline MTLSamplerAddressMode wrap_mode_to_mtl_sampler_address(
             }
     }
     SK_ABORT("Unknown wrap mode.");
+    SkUNREACHABLE;
 }
 
 GrMtlSampler* GrMtlSampler::Create(const GrMtlGpu* gpu, const GrSamplerState& samplerState) {
diff --git a/gfx/skia/skia/src/gpu/mtl/GrMtlUniformHandler.mm b/gfx/skia/skia/src/gpu/mtl/GrMtlUniformHandler.mm
index 89e1263eaf..7a2d007918 100644
--- a/gfx/skia/skia/src/gpu/mtl/GrMtlUniformHandler.mm
+++ b/gfx/skia/skia/src/gpu/mtl/GrMtlUniformHandler.mm
@@ -90,6 +90,7 @@ static uint32_t grsltype_to_alignment_mask(GrSLType type) {
             break;
     }
     SK_ABORT("Unexpected type");
+    SkUNREACHABLE;
 }
 
 /** Returns the size in bytes taken up in Metal buffers for GrSLTypes. */
@@ -172,6 +173,7 @@ static inline uint32_t grsltype_to_mtl_size(GrSLType type) {
             break;
     }
     SK_ABORT("Unexpected type");
+    SkUNREACHABLE;
 }
 
 // Given the current offset into the ubo, calculate the offset for the uniform we're trying to add
diff --git a/gfx/skia/skia/src/gpu/mtl/GrMtlUtil.mm b/gfx/skia/skia/src/gpu/mtl/GrMtlUtil.mm
index eccf435074..b49a43b7ec 100644
--- a/gfx/skia/skia/src/gpu/mtl/GrMtlUtil.mm
+++ b/gfx/skia/skia/src/gpu/mtl/GrMtlUtil.mm
@@ -112,6 +112,7 @@ bool GrPixelConfigToMTLFormat(GrPixelConfig config, MTLPixelFormat* format) {
             return true;
     }
     SK_ABORT("Unexpected config");
+    SkUNREACHABLE;
 }
 
 MTLTextureDescriptor* GrGetMTLTextureDescriptor(id<MTLTexture> mtlTexture) {
diff --git a/gfx/skia/skia/src/gpu/ops/GrDrawVerticesOp.cpp b/gfx/skia/skia/src/gpu/ops/GrDrawVerticesOp.cpp
index 4b311b5207..8a010a1de1 100644
--- a/gfx/skia/skia/src/gpu/ops/GrDrawVerticesOp.cpp
+++ b/gfx/skia/skia/src/gpu/ops/GrDrawVerticesOp.cpp
@@ -610,6 +610,7 @@ static uint32_t seed_vertices(GrPrimitiveType type) {
             return 0;
     }
     SK_ABORT("Incomplete switch\n");
+    SkUNREACHABLE;
 }
 
 static uint32_t primitive_vertices(GrPrimitiveType type) {
@@ -627,6 +628,7 @@ static uint32_t primitive_vertices(GrPrimitiveType type) {
             return 0;
     }
     SK_ABORT("Incomplete switch\n");
+    SkUNREACHABLE;
 }
 
 static SkPoint random_point(SkRandom* random, SkScalar min, SkScalar max) {
diff --git a/gfx/skia/skia/src/gpu/ops/GrFillRRectOp.cpp b/gfx/skia/skia/src/gpu/ops/GrFillRRectOp.cpp
index 6b3c023ff6..6b28723bd5 100644
--- a/gfx/skia/skia/src/gpu/ops/GrFillRRectOp.cpp
+++ b/gfx/skia/skia/src/gpu/ops/GrFillRRectOp.cpp
@@ -823,4 +823,5 @@ static bool can_use_hw_derivatives_with_coverage(
         }
     }
     SK_ABORT("Invalid round rect type.");
+    SkUNREACHABLE;
 }
diff --git a/gfx/skia/skia/src/gpu/ops/GrOvalOpFactory.cpp b/gfx/skia/skia/src/gpu/ops/GrOvalOpFactory.cpp
index b32758150f..10f0d96889 100644
--- a/gfx/skia/skia/src/gpu/ops/GrOvalOpFactory.cpp
+++ b/gfx/skia/skia/src/gpu/ops/GrOvalOpFactory.cpp
@@ -2283,6 +2283,7 @@ static int rrect_type_to_vert_count(RRectType type) {
             return kVertsPerOverstrokeRRect;
     }
     SK_ABORT("Invalid type");
+    SkUNREACHABLE;
 }
 
 static int rrect_type_to_index_count(RRectType type) {
@@ -2295,6 +2296,7 @@ static int rrect_type_to_index_count(RRectType type) {
             return kIndicesPerOverstrokeRRect;
     }
     SK_ABORT("Invalid type");
+    SkUNREACHABLE;
 }
 
 static const uint16_t* rrect_type_to_indices(RRectType type) {
@@ -2306,6 +2308,7 @@ static const uint16_t* rrect_type_to_indices(RRectType type) {
             return gOverstrokeRRectIndices;
     }
     SK_ABORT("Invalid type");
+    SkUNREACHABLE;
 }
 
 ///////////////////////////////////////////////////////////////////////////////////////////////////
diff --git a/gfx/skia/skia/src/gpu/ops/GrShadowRRectOp.cpp b/gfx/skia/skia/src/gpu/ops/GrShadowRRectOp.cpp
index 546933bb8a..fadf6096c3 100644
--- a/gfx/skia/skia/src/gpu/ops/GrShadowRRectOp.cpp
+++ b/gfx/skia/skia/src/gpu/ops/GrShadowRRectOp.cpp
@@ -155,6 +155,7 @@ static int rrect_type_to_vert_count(RRectType type) {
             return kVertsPerOverstrokeRRect;
     }
     SK_ABORT("Invalid type");
+    SkUNREACHABLE;
 }
 
 static int rrect_type_to_index_count(RRectType type) {
@@ -167,6 +168,7 @@ static int rrect_type_to_index_count(RRectType type) {
             return kIndicesPerOverstrokeRRect;
     }
     SK_ABORT("Invalid type");
+    SkUNREACHABLE;
 }
 
 static const uint16_t* rrect_type_to_indices(RRectType type) {
@@ -178,6 +180,7 @@ static const uint16_t* rrect_type_to_indices(RRectType type) {
             return gRRectIndices;
     }
     SK_ABORT("Invalid type");
+    SkUNREACHABLE;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/gfx/skia/skia/src/gpu/text/GrTextBlob.h b/gfx/skia/skia/src/gpu/text/GrTextBlob.h
index ddea88d15f..d82e84704f 100644
--- a/gfx/skia/skia/src/gpu/text/GrTextBlob.h
+++ b/gfx/skia/skia/src/gpu/text/GrTextBlob.h
@@ -125,6 +125,7 @@ public:
 
     void* operator new(size_t) {
         SK_ABORT("All blobs are created by placement new.");
+	SkUNREACHABLE;
     }
 
     void* operator new(size_t, void* p) { return p; }
diff --git a/gfx/skia/skia/src/gpu/text/GrTextBlobVertexRegenerator.cpp b/gfx/skia/skia/src/gpu/text/GrTextBlobVertexRegenerator.cpp
index 976beaf3d4..f9c01dd217 100644
--- a/gfx/skia/skia/src/gpu/text/GrTextBlobVertexRegenerator.cpp
+++ b/gfx/skia/skia/src/gpu/text/GrTextBlobVertexRegenerator.cpp
@@ -284,4 +284,5 @@ bool GrTextBlob::VertexRegenerator::regenerate(GrTextBlob::VertexRegenerator::Re
         return true;
     }
     SK_ABORT("Should not get here");
+    SkUNREACHABLE;
 }
diff --git a/gfx/skia/skia/src/gpu/vk/GrVkCaps.cpp b/gfx/skia/skia/src/gpu/vk/GrVkCaps.cpp
index 36e2436a85..a914f5a4d5 100644
--- a/gfx/skia/skia/src/gpu/vk/GrVkCaps.cpp
+++ b/gfx/skia/skia/src/gpu/vk/GrVkCaps.cpp
@@ -108,6 +108,7 @@ static FormatCompatibilityClass format_compatibility_class(VkFormat format) {
 
         default:
             SK_ABORT("Unsupported VkFormat");
+	    SkUNREACHABLE;
     }
 }
 
@@ -1656,6 +1657,7 @@ GrBackendFormat GrVkCaps::getBackendFormatFromCompressionType(
             return GrBackendFormat::MakeVk(VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK);
     }
     SK_ABORT("Invalid compression type");
+    SkUNREACHABLE;
 }
 
 GrSwizzle GrVkCaps::getTextureSwizzle(const GrBackendFormat& format, GrColorType colorType) const {
diff --git a/gfx/skia/skia/src/gpu/vk/GrVkMemory.cpp b/gfx/skia/skia/src/gpu/vk/GrVkMemory.cpp
index ed14a643ec..3675c953d4 100644
--- a/gfx/skia/skia/src/gpu/vk/GrVkMemory.cpp
+++ b/gfx/skia/skia/src/gpu/vk/GrVkMemory.cpp
@@ -28,6 +28,7 @@ static BufferUsage get_buffer_usage(GrVkBuffer::Type type, bool dynamic) {
             return BufferUsage::kCpuOnly;
     }
     SK_ABORT("Invalid GrVkBuffer::Type");
+    SkUNREACHABLE;
 }
 
 bool GrVkMemory::AllocAndBindBufferMemory(const GrVkGpu* gpu,
diff --git a/gfx/skia/skia/src/gpu/vk/GrVkPipeline.cpp b/gfx/skia/skia/src/gpu/vk/GrVkPipeline.cpp
index 6868ff5bab..2c7a20a7db 100644
--- a/gfx/skia/skia/src/gpu/vk/GrVkPipeline.cpp
+++ b/gfx/skia/skia/src/gpu/vk/GrVkPipeline.cpp
@@ -80,6 +80,7 @@ static inline VkFormat attrib_type_to_vkformat(GrVertexAttribType type) {
             return VK_FORMAT_R16G16B16A16_UNORM;
     }
     SK_ABORT("Unknown vertex attrib type");
+    SkUNREACHABLE;
 }
 
 static void setup_vertex_input_state(const GrPrimitiveProcessor& primProc,
@@ -162,8 +163,10 @@ static VkPrimitiveTopology gr_primitive_type_to_vk_topology(GrPrimitiveType prim
             return VK_PRIMITIVE_TOPOLOGY_LINE_STRIP;
         case GrPrimitiveType::kPath:
             SK_ABORT("Unsupported primitive type");
+	    SkUNREACHABLE;
     }
     SK_ABORT("invalid GrPrimitiveType");
+    SkUNREACHABLE;
 }
 
 static void setup_input_assembly_state(GrPrimitiveType primitiveType,
diff --git a/gfx/skia/skia/src/gpu/vk/GrVkSampler.cpp b/gfx/skia/skia/src/gpu/vk/GrVkSampler.cpp
index 5dc3544f00..306bd96816 100644
--- a/gfx/skia/skia/src/gpu/vk/GrVkSampler.cpp
+++ b/gfx/skia/skia/src/gpu/vk/GrVkSampler.cpp
@@ -23,6 +23,7 @@ static inline VkSamplerAddressMode wrap_mode_to_vk_sampler_address(
             return VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
     }
     SK_ABORT("Unknown wrap mode.");
+    SkUNREACHABLE;
 }
 
 GrVkSampler* GrVkSampler::Create(GrVkGpu* gpu, const GrSamplerState& samplerState,
diff --git a/gfx/skia/skia/src/gpu/vk/GrVkTransferBuffer.h b/gfx/skia/skia/src/gpu/vk/GrVkTransferBuffer.h
index 210cf228d9..6a6fd90d96 100644
--- a/gfx/skia/skia/src/gpu/vk/GrVkTransferBuffer.h
+++ b/gfx/skia/skia/src/gpu/vk/GrVkTransferBuffer.h
@@ -34,6 +34,7 @@ private:
 
     bool onUpdateData(const void* src, size_t srcSizeInBytes) override {
         SK_ABORT("Not implemented for transfer buffers.");
+	SkUNREACHABLE;
     }
 
     GrVkGpu* getVkGpu() const {
diff --git a/gfx/skia/skia/src/gpu/vk/GrVkUniformHandler.cpp b/gfx/skia/skia/src/gpu/vk/GrVkUniformHandler.cpp
index 6df62ce6a9..4ac6873563 100644
--- a/gfx/skia/skia/src/gpu/vk/GrVkUniformHandler.cpp
+++ b/gfx/skia/skia/src/gpu/vk/GrVkUniformHandler.cpp
@@ -89,6 +89,7 @@ static uint32_t grsltype_to_alignment_mask(GrSLType type) {
             break;
     }
     SK_ABORT("Unexpected type");
+    SkUNREACHABLE;
 }
 
 /** Returns the size in bytes taken up in vulkanbuffers for GrSLTypes. */
@@ -172,6 +173,7 @@ static inline uint32_t grsltype_to_vk_size(GrSLType type) {
             break;
     }
     SK_ABORT("Unexpected type");
+    SkUNREACHABLE;
 }
 
 
diff --git a/gfx/skia/skia/src/gpu/vk/GrVkVaryingHandler.cpp b/gfx/skia/skia/src/gpu/vk/GrVkVaryingHandler.cpp
index 5fe2f45373..4b6d61813d 100644
--- a/gfx/skia/skia/src/gpu/vk/GrVkVaryingHandler.cpp
+++ b/gfx/skia/skia/src/gpu/vk/GrVkVaryingHandler.cpp
@@ -74,6 +74,7 @@ static inline int grsltype_to_location_size(GrSLType type) {
              return 1;
     }
     SK_ABORT("Unexpected type");
+    SkUNREACHABLE;
 }
 
 static void finalize_helper(GrVkVaryingHandler::VarArray& vars) {
diff --git a/gfx/skia/skia/src/pdf/SkPDFTag.cpp b/gfx/skia/skia/src/pdf/SkPDFTag.cpp
index a2248070e8..15122d5047 100644
--- a/gfx/skia/skia/src/pdf/SkPDFTag.cpp
+++ b/gfx/skia/skia/src/pdf/SkPDFTag.cpp
@@ -64,6 +64,7 @@ static const char* tag_name_from_type(SkPDF::DocumentStructureType type) {
         #undef M
     }
     SK_ABORT("bad tag");
+    SkUNREACHABLE;
 }
 
 struct SkPDFTagNode {
diff --git a/gfx/skia/skia/src/ports/SkFontMgr_FontConfigInterface.cpp b/gfx/skia/skia/src/ports/SkFontMgr_FontConfigInterface.cpp
index 23986cbaaa..e78c47b11a 100644
--- a/gfx/skia/skia/src/ports/SkFontMgr_FontConfigInterface.cpp
+++ b/gfx/skia/skia/src/ports/SkFontMgr_FontConfigInterface.cpp
@@ -173,18 +173,22 @@ public:
 protected:
     int onCountFamilies() const override {
         SK_ABORT("Not implemented.");
+	SkUNREACHABLE;
     }
 
     void onGetFamilyName(int index, SkString* familyName) const override {
         SK_ABORT("Not implemented.");
+	SkUNREACHABLE;
     }
 
     SkFontStyleSet* onCreateStyleSet(int index) const override {
         SK_ABORT("Not implemented.");
+	SkUNREACHABLE;
     }
 
     SkFontStyleSet* onMatchFamily(const char familyName[]) const override {
         SK_ABORT("Not implemented.");
+	SkUNREACHABLE;
     }
 
     SkTypeface* onMatchFamilyStyle(const char requestedFamilyName[],
@@ -215,10 +219,12 @@ protected:
                                             const char* bcp47[], int bcp47Count,
                                             SkUnichar character) const override {
         SK_ABORT("Not implemented.");
+	SkUNREACHABLE;
     }
 
     SkTypeface* onMatchFaceStyle(const SkTypeface*, const SkFontStyle&) const override {
         SK_ABORT("Not implemented.");
+	SkUNREACHABLE;
     }
 
     sk_sp<SkTypeface> onMakeFromData(sk_sp<SkData> data, int ttcIndex) const override {
diff --git a/gfx/skia/skia/src/shaders/SkImageShader.cpp b/gfx/skia/skia/src/shaders/SkImageShader.cpp
index 5bc13e587c..968e3cffae 100644
--- a/gfx/skia/skia/src/shaders/SkImageShader.cpp
+++ b/gfx/skia/skia/src/shaders/SkImageShader.cpp
@@ -183,6 +183,7 @@ static GrSamplerState::WrapMode tile_mode_to_wrap_mode(const SkTileMode tileMode
             return GrSamplerState::WrapMode::kClampToBorder;
     }
     SK_ABORT("Unknown tile mode.");
+    SkUNREACHABLE;
 }
 
 std::unique_ptr<GrFragmentProcessor> SkImageShader::asFragmentProcessor(
diff --git a/gfx/skia/skia/src/utils/SkShadowUtils.cpp b/gfx/skia/skia/src/utils/SkShadowUtils.cpp
index 1b47af5523..f0ae0411d0 100644
--- a/gfx/skia/skia/src/utils/SkShadowUtils.cpp
+++ b/gfx/skia/skia/src/utils/SkShadowUtils.cpp
@@ -149,6 +149,7 @@ struct SpotVerticesFactory {
                 return false;
         }
         SK_ABORT("Uninitialized occluder type?");
+	SkUNREACHABLE;
     }
 
     sk_sp<SkVertices> makeVertices(const SkPath& path, const SkMatrix& ctm,
diff --git a/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/ast_to_hir.cpp b/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/ast_to_hir.cpp
index c00298a160..74b9d1aef3 100644
--- a/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/ast_to_hir.cpp
+++ b/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/ast_to_hir.cpp
@@ -2651,6 +2651,7 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
    default:
       unreachable("Unsupported type");
    } /* base type */
+   return "";
 }
 
 static unsigned
diff --git a/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/ir.cpp b/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/ir.cpp
index 9ea8e00d31..2dee2ccdcd 100644
--- a/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/ir.cpp
+++ b/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/ir.cpp
@@ -624,6 +624,7 @@ ir_expression::get_num_operands(ir_expression_operation op)
       return 4;
 
    unreachable("Could not calculate number of operands");
+   return -1;
 }
 
 #include "ir_expression_operation_strings.h"
diff --git a/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/loop_analysis.cpp b/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/loop_analysis.cpp
index 9429e69c2a..8d9da42434 100644
--- a/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/loop_analysis.cpp
+++ b/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/loop_analysis.cpp
@@ -239,6 +239,7 @@ incremented_before_terminator(ir_loop *loop, ir_variable *var,
    }
 
    unreachable("Unable to find induction variable");
+   return false;
 }
 
 /**
diff --git a/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/opt_vectorize.cpp b/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/opt_vectorize.cpp
index 88318cd8a6..63a535c802 100644
--- a/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/opt_vectorize.cpp
+++ b/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl/opt_vectorize.cpp
@@ -229,6 +229,7 @@ write_mask_to_swizzle(unsigned write_mask)
    case WRITEMASK_W: return SWIZZLE_W;
    }
    unreachable("not reached");
+   return 0;
 }
 
 /**
diff --git a/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl_types.cpp b/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl_types.cpp
index 445659599c..615ab6215a 100644
--- a/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl_types.cpp
+++ b/third_party/rust/glslopt/glsl-optimizer/src/compiler/glsl_types.cpp
@@ -460,6 +460,7 @@ const glsl_type *glsl_type::get_bare_type() const
    }
 
    unreachable("Invalid base type");
+   return nullptr;
 }
 
 const glsl_type *glsl_type::get_float16_type() const
@@ -2016,6 +2017,7 @@ glsl_type::get_explicit_std140_type(bool row_major) const
       return type;
    } else {
       unreachable("Invalid type for UBO or SSBO");
+      return nullptr;
    }
 }
 
@@ -2374,6 +2376,7 @@ glsl_type::get_explicit_std430_type(bool row_major) const
       return type;
    } else {
       unreachable("Invalid type for SSBO");
+      return nullptr;
    }
 }
 
@@ -2448,6 +2451,7 @@ glsl_type::get_explicit_type_for_size_align(glsl_type_size_align_func type_info,
                                      this->matrix_columns, stride, false);
    } else {
       unreachable("Unhandled type.");
+      return nullptr;
    }
 }
 
@@ -2948,6 +2952,7 @@ glsl_get_sampler_dim_coordinate_components(enum glsl_sampler_dim dim)
       return 3;
    default:
       unreachable("Unknown sampler dim");
+      return -1;
    }
 }
 
diff --git a/third_party/rust/glslopt/glsl-optimizer/src/mesa/main/shaderobj.h b/third_party/rust/glslopt/glsl-optimizer/src/mesa/main/shaderobj.h
index 0d512550de..ef940cabdd 100644
--- a/third_party/rust/glslopt/glsl-optimizer/src/mesa/main/shaderobj.h
+++ b/third_party/rust/glslopt/glsl-optimizer/src/mesa/main/shaderobj.h
@@ -185,6 +185,7 @@ _mesa_shader_stage_from_subroutine_uniform(GLenum subuniform)
       return MESA_SHADER_TESS_EVAL;
    }
    unreachable("not reached");
+   return MESA_SHADER_NONE;
 }
 
 static inline gl_shader_stage
@@ -205,6 +206,7 @@ _mesa_shader_stage_from_subroutine(GLenum subroutine)
       return MESA_SHADER_TESS_EVAL;
    }
    unreachable("not reached");
+   return MESA_SHADER_NONE;
 }
 
 static inline GLenum
@@ -230,6 +232,7 @@ _mesa_shader_stage_to_subroutine(gl_shader_stage stage)
       break;
    }
    unreachable("not reached");
+   return GL_VERTEX_PROGRAM_ARB;
 }
 
 static inline GLenum
@@ -253,6 +256,7 @@ _mesa_shader_stage_to_subroutine_uniform(gl_shader_stage stage)
       break;
    }
    unreachable("not reached");
+   return GL_VERTEX_PROGRAM_ARB;
 }
 
 extern bool
