diff --git a/tools/profiler/core/platform.cpp b/tools/profiler/core/platform.cpp
--- a/tools/profiler/core/platform.cpp
+++ b/tools/profiler/core/platform.cpp
@@ -1176,11 +1176,11 @@
       if (!profiledThreadData) {
         // This thread was not profiled, continue with the next one.
         continue;
       }
       ThreadRegistry::OffThreadRef::RWFromAnyThreadWithLock lockedThreadData =
-          offThreadRef.LockedRWFromAnyThread();
+          offThreadRef.GetLockedRWFromAnyThread();
       MOZ_RELEASE_ASSERT(array.append(ProfiledThreadListElement{
           profiledThreadData->Info().RegisterTime(),
           lockedThreadData->GetJSContext(), profiledThreadData}));
     }
 
@@ -4208,11 +4208,11 @@
                   ProfileBufferEntry::Kind::RunningTimes, runningTimesDiff);
             }
 
             if (threadStackSampling) {
               ThreadRegistry::OffThreadRef::RWFromAnyThreadWithLock
-                  lockedThreadData = offThreadRef.LockedRWFromAnyThread();
+                  lockedThreadData = offThreadRef.GetLockedRWFromAnyThread();
               // Suspend the thread and collect its stack data in the local
               // buffer.
               mSampler.SuspendAndSampleAndResumeThread(
                   lock, lockedThreadData.DataCRef(), now,
                   [&](const Registers& aRegs, const TimeStamp& aNow) {
@@ -4922,11 +4922,11 @@
     ThreadProfilingFeatures threadProfilingFeatures =
         ActivePS::ProfilingFeaturesForThread(
             aLock, aOffThreadRef.UnlockedConstReaderCRef().Info());
     if (threadProfilingFeatures != ThreadProfilingFeatures::NotProfiled) {
       ThreadRegistry::OffThreadRef::RWFromAnyThreadWithLock
-          lockedRWFromAnyThread = aOffThreadRef.LockedRWFromAnyThread();
+          lockedRWFromAnyThread = aOffThreadRef.GetLockedRWFromAnyThread();
 
       ProfiledThreadData* profiledThreadData = ActivePS::AddLiveProfiledThread(
           aLock, MakeUnique<ProfiledThreadData>(
                      aOffThreadRef.UnlockedConstReaderCRef().Info()));
       lockedRWFromAnyThread->SetProfilingFeaturesAndData(
@@ -5788,11 +5788,11 @@
 
     ThreadProfilingFeatures threadProfilingFeatures =
         ActivePS::ProfilingFeaturesForThread(aLock, info);
     if (threadProfilingFeatures != ThreadProfilingFeatures::NotProfiled) {
       ThreadRegistry::OffThreadRef::RWFromAnyThreadWithLock lockedThreadData =
-          offThreadRef.LockedRWFromAnyThread();
+          offThreadRef.GetLockedRWFromAnyThread();
       ProfiledThreadData* profiledThreadData = ActivePS::AddLiveProfiledThread(
           aLock, MakeUnique<ProfiledThreadData>(info));
       lockedThreadData->SetProfilingFeaturesAndData(threadProfilingFeatures,
                                                     profiledThreadData, aLock);
       lockedThreadData->GetNewCpuTimeInNs();
@@ -6012,11 +6012,11 @@
         ThreadProfilingFeatures::NotProfiled) {
       continue;
     }
 
     ThreadRegistry::OffThreadRef::RWFromAnyThreadWithLock lockedThreadData =
-        offThreadRef.LockedRWFromAnyThread();
+        offThreadRef.GetLockedRWFromAnyThread();
 
     lockedThreadData->ClearProfilingFeaturesAndData(aLock);
 
     if (ActivePS::FeatureJS(aLock)) {
       lockedThreadData->StopJSSampling();
@@ -6355,11 +6355,11 @@
 
   // We don't call StopJSSampling() here; there's no point doing that for a JS
   // thread that is in the process of disappearing.
 
   ThreadRegistration::OnThreadRef::RWOnThreadWithLock lockedThreadData =
-      aOnThreadRef.LockedRWOnThread();
+      aOnThreadRef.GetLockedRWOnThread();
 
   ProfiledThreadData* profiledThreadData =
       lockedThreadData->GetProfiledThreadData(lock);
   lockedThreadData->ClearProfilingFeaturesAndData(lock);
 
@@ -6876,11 +6876,11 @@
         }
 
         // The profiler mutex must be locked before the ThreadRegistration's.
         PSAutoLock lock;
         ThreadRegistration::OnThreadRef::RWOnThreadWithLock lockedThreadData =
-            aOnThreadRef.LockedRWOnThread();
+            aOnThreadRef.GetLockedRWOnThread();
 
         if (ProfiledThreadData* profiledThreadData =
                 lockedThreadData->GetProfiledThreadData(lock);
             profiledThreadData && ActivePS::Exists(lock) &&
             ActivePS::FeatureJS(lock)) {
diff --git a/tools/profiler/public/ProfilerThreadRegistration.h b/tools/profiler/public/ProfilerThreadRegistration.h
--- a/tools/profiler/public/ProfilerThreadRegistration.h
+++ b/tools/profiler/public/ProfilerThreadRegistration.h
@@ -212,18 +212,18 @@
 
       LockedRWOnThread& mLockedRWOnThread;
       DataLock mDataLock;
     };
 
-    [[nodiscard]] RWOnThreadWithLock LockedRWOnThread() {
+    [[nodiscard]] RWOnThreadWithLock GetLockedRWOnThread() {
       return RWOnThreadWithLock{mThreadRegistration->mData,
                                 mThreadRegistration->mDataMutex};
     }
 
     template <typename F>
     auto WithLockedRWOnThread(F&& aF) {
-      RWOnThreadWithLock lockedData = LockedRWOnThread();
+      RWOnThreadWithLock lockedData = GetLockedRWOnThread();
       return std::forward<F>(aF)(lockedData.DataRef());
     }
 
     // This is needed to allow OnThreadPtr::operator-> to return a temporary
     // OnThreadRef object, for which `->` must work; Here it provides a pointer
diff --git a/tools/profiler/public/ProfilerThreadRegistry.h b/tools/profiler/public/ProfilerThreadRegistry.h
--- a/tools/profiler/public/ProfilerThreadRegistry.h
+++ b/tools/profiler/public/ProfilerThreadRegistry.h
@@ -175,18 +175,18 @@
 
       LockedRWFromAnyThread& mLockedRWFromAnyThread;
       ThreadRegistration::DataLock mDataLock;
     };
 
-    [[nodiscard]] RWFromAnyThreadWithLock LockedRWFromAnyThread() {
+    [[nodiscard]] RWFromAnyThreadWithLock GetLockedRWFromAnyThread() {
       return RWFromAnyThreadWithLock{mThreadRegistration->mData,
                                      mThreadRegistration->mDataMutex};
     }
 
     template <typename F>
     auto WithLockedRWFromAnyThread(F&& aF) {
-      RWFromAnyThreadWithLock lockedData = LockedRWFromAnyThread();
+      RWFromAnyThreadWithLock lockedData = GetLockedRWFromAnyThread();
       return std::forward<F>(aF)(lockedData.DataRef());
     }
 
    private:
     // Only ThreadRegistry should construct an OnThreadRef.
diff --git a/tools/profiler/tests/gtest/GeckoProfiler.cpp b/tools/profiler/tests/gtest/GeckoProfiler.cpp
--- a/tools/profiler/tests/gtest/GeckoProfiler.cpp
+++ b/tools/profiler/tests/gtest/GeckoProfiler.cpp
@@ -620,11 +620,11 @@
       // non-const LockedRWOnThread
 
       EXPECT_FALSE(TR::IsDataMutexLockedOnCurrentThread());
       {
         TR::OnThreadRef::RWOnThreadWithLock rwOnThreadWithLock =
-            aOnThreadRef.LockedRWOnThread();
+            aOnThreadRef.GetLockedRWOnThread();
         EXPECT_TRUE(TR::IsDataMutexLockedOnCurrentThread());
         TestConstLockedRWOnThread(rwOnThreadWithLock.DataCRef(),
                                   beforeRegistration, afterRegistration,
                                   &onStackChar);
         TestLockedRWOnThread(rwOnThreadWithLock.DataRef(), beforeRegistration,
@@ -1019,11 +1019,11 @@
         // non-const LockedRWFromAnyThread
 
         EXPECT_FALSE(TR::IsDataMutexLockedOnCurrentThread());
         {
           TRy::OffThreadRef::RWFromAnyThreadWithLock rwFromAnyThreadWithLock =
-              aOffThreadRef.LockedRWFromAnyThread();
+              aOffThreadRef.GetLockedRWFromAnyThread();
           if (profiler_current_thread_id() == testThreadId) {
             EXPECT_TRUE(TR::IsDataMutexLockedOnCurrentThread());
           }
           TestLockedRWFromAnyThread(rwFromAnyThreadWithLock.DataRef(),
                                     beforeRegistration, afterRegistration,
@@ -1156,11 +1156,11 @@
                                                     aOffThreadRef) {
           if (otherThreadLoops % 1000 == 0) {
             PR_Sleep(PR_MillisecondsToInterval(1));
           }
           TRy::OffThreadRef::RWFromAnyThreadWithLock rwFromAnyThreadWithLock =
-              aOffThreadRef.LockedRWFromAnyThread();
+              aOffThreadRef.GetLockedRWFromAnyThread();
           ++otherThreadReads;
           if (otherThreadReads % 1000 == 0) {
             PR_Sleep(PR_MillisecondsToInterval(1));
           }
         });

diff --git a/gfx/2d/Rect.h b/gfx/2d/Rect.h
--- a/gfx/2d/Rect.h
+++ b/gfx/2d/Rect.h
@@ -10,16 +10,17 @@
 #include "BaseRect.h"
 #include "BaseMargin.h"
 #include "NumericTools.h"
 #include "Point.h"
 #include "Tools.h"
 #include "mozilla/Maybe.h"
 
 #include <cmath>
+#include <cstdint>
 
 namespace mozilla {
 
 template <typename>
 struct IsPixel;
 
 namespace gfx {
 
diff --git a/toolkit/components/telemetry/pingsender/pingsender.cpp b/toolkit/components/telemetry/pingsender/pingsender.cpp
--- a/toolkit/components/telemetry/pingsender/pingsender.cpp
+++ b/toolkit/components/telemetry/pingsender/pingsender.cpp
@@ -1,14 +1,15 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include <cstdlib>
+#include <cstdint>
 #include <cstring>
 #include <ctime>
 #include <fstream>
 #include <iomanip>
 #include <string>
 #include <vector>
 
 #include <zlib.h>
