From 38f0cfb1f79c7f5df6a9ea58e51b2b38e1b56a40 Mon Sep 17 00:00:00 2001
From: Werner Fink <werner@suse.de>
Date: Thu, 19 Feb 2026 14:11:04 +0100
Subject: [PATCH] Patch for libzio usage

Signed-off-by: Werner Fink <werner@suse.de>
---
 config.h.in      |    3 +
 configure.ac     |   52 ++++++++++++++++++++++++
 src/decompress.c |  119 ++++++++++++++++++++++++++++++++++++++++++++++++++++---
 3 files changed, 169 insertions(+), 5 deletions(-)

--- config.h.in
+++ config.h.in
@@ -1148,6 +1148,9 @@
 /* Define to 1 if you have the `z' library (-lz). */
 #undef HAVE_LIBZ
 
+/* Define to 1 if you have libzio for opening compressed manuals */
+#undef HAVE_ZIO
+
 /* Define to 1 if the bcrypt library is guaranteed to be present. */
 #undef HAVE_LIB_BCRYPT
 
--- configure.ac
+++ configure.ac
@@ -35,6 +35,18 @@ MAN_ARG_DEVICE
 MAN_ARG_DB
 MAN_ARG_CONFIG_FILE
 MAN_ARG_SECTIONS
+AC_ARG_WITH([zio],
+[AS_HELP_STRING([--with-zio=LIBRARY], [use zlib/libbz2 wrapper library LIBRARY (libzio)])],
+	[if test -z "$withval" -o "$withval" = "yes"
+	 then
+		zio=libzio
+	 elif test "$withval" = "no"
+	 then
+		AC_MSG_ERROR(--with-zio requires an argument)
+	 else
+		zio=$withval
+	 fi],
+	[: ${zio=no}])
 MAN_ARG_AUTOMATIC_CREATE
 MAN_ARG_AUTOMATIC_UPDATE
 MAN_ARG_CATS
@@ -374,6 +386,46 @@ AC_DEFINE_UNQUOTED([PROG_UNXZ], ["$unxz"], [Program to use as unxz.])
 AC_DEFINE_UNQUOTED([PROG_UNLZIP], ["$unlzip"], [Program to use as unlzip.])
 AC_DEFINE_UNQUOTED([PROG_UNZSTD], ["$unzstd"], [Program to use as unzstd.])
 MAN_COMPRESS_LIB([z], [gzopen])
+dnl Check for zlib and libbz2 libraries to use this together
+dnl with SUSE's libzio to open compressed info files.
+dnl
+if test "$zio" = "no" || test -n "$zio"
+then
+    AC_CHECK_HEADER(zio.h,[
+      for lib in ${zio#lib} zio
+      do
+	AC_CHECK_LIB($lib, fzopen,              [LIBS="-l$lib $LIBS"; am_cv_libzio=yes])
+      done
+    ])
+    if test "$am_cv_libzio" = yes; then
+      AC_DEFINE([COMP_SRC],[],[Define if you have compressors and want to support compressed cat files.])
+      AC_DEFINE([HAVE_ZIO],[],[Define to 1 if you have libzio for opening compressed manuals])
+      AC_CHECK_HEADER(zlib.h,[
+	for lib in z gz
+	do
+	  AC_CHECK_LIB($lib, gzopen,             [LIBS="$LIBS -Wl,--no-as-needed -l$lib"; break])
+	done
+      ])
+      AC_CHECK_HEADER(bzlib.h,[
+	for lib in bz2 bzip2
+	do
+	  AC_CHECK_LIB($lib, BZ2_bzopen,         [LIBS="$LIBS -Wl,--no-as-needed -l$lib"; break])
+	done
+      ])
+      AC_CHECK_HEADER(lzma.h, [
+	for lib in lzma
+	do
+	  AC_CHECK_LIB($lib, lzma_easy_encoder,       [LIBS="$LIBS -Wl,--no-as-needed -l$lib"; break])
+	done
+      ])
+      AC_CHECK_HEADER(zstd.h, [
+	for lib in zstd
+	do
+	  AC_CHECK_LIB($lib, ZSTD_createCCtx,  [LIBS="$LIBS -Wl,--no-as-needed -l$lib"; break])
+	done
+      ])
+    fi
+fi
 dnl To add more decompressors just follow the scheme above.
 
 # Check for various header files and associated libraries.
--- src/decompress.c
+++ src/decompress.c
@@ -39,12 +39,17 @@
 
 #include "pipeline.h"
 
+#include "appendstr.h"
 #include "attribute.h"
 #include "minmax.h"
 #include "xalloc.h"
 #include "xstrndup.h"
 #include "xvasprintf.h"
 
+#ifdef HAVE_ZIO
+#  include "zio.h"
+#endif /* HAVE_ZIO */
+
 #include "manconfig.h"
 
 #include "compression.h"
@@ -99,6 +104,7 @@ static decompress *decompress_new_inprocess (char *buf, size_t len)
 	return d;
 }
 
+#  ifndef HAVE_ZIO
 static void decompress_zlib (void *data MAYBE_UNUSED)
 {
 	gzFile zlibfile;
@@ -126,6 +132,7 @@ static void decompress_zlib (void *data MAYBE_UNUSED)
 	gzclose (zlibfile);
 	return;
 }
+#  endif
 
 /* The largest number of uncompressed bytes we're prepared to read into
  * memory.  (We actually allow at most one fewer byte than this, for easy
@@ -145,7 +152,11 @@ static void decompress_zlib (void *data MAYBE_UNUSED)
 
 static decompress *decompress_try_zlib (const char *filename)
 {
+#  ifdef HAVE_ZIO
+	FILE *file;
+#  else
 	gzFile zlibfile;
+#  endif
 	/* We only ever call this from the parent process (and don't
 	 * currently use threads), and this lets us skip per-file memory
 	 * allocation.
@@ -153,18 +164,33 @@ static decompress *decompress_try_zlib (const char *filename)
 	static char buffer[MAX_INPROCESS];
 	int len = 0;
 
+#  ifdef HAVE_ZIO
+	file = fzopen (filename, "r");
+	if (!file)
+		return NULL;
+#  else
 	zlibfile = gzopen (filename, "r");
 	if (!zlibfile)
 		return NULL;
+#  endif
 
 	while (len < MAX_INPROCESS) {
 		/* Read one more byte than we're prepared to return, in
 		 * order to detect EOF at the right position.  The "len >=
 		 * MAX_INPROCESS" check below catches the boundary case.
 		 */
+#  ifdef HAVE_ZIO
+		int r = fread (buffer + len, sizeof (char),
+		               MAX_INPROCESS - len, file);
+#  else
 		int r = gzread (zlibfile, buffer + len, MAX_INPROCESS - len);
+#  endif
 		if (r < 0) {
+#  ifdef HAVE_ZIO
+			fclose (file);
+#  else
 			gzclose (zlibfile);
+#  endif
 			return NULL;
 		} else if (r == 0)
 			break;
@@ -172,7 +198,11 @@ static decompress *decompress_try_zlib (const char *filename)
 			len += r;
 	}
 
+#  ifdef HAVE_ZIO
+	fclose (file);
+#  else
 	gzclose (zlibfile);
+#  endif
 	if (len >= MAX_INPROCESS)
 		return NULL;
 	/* Copy input data so that we don't have potential data corruption
@@ -188,33 +218,108 @@ static decompress *decompress_try_zlib (const char *filename)
 #  define OPEN_FLAGS_UNUSED MAYBE_UNUSED
 #endif /* HAVE_LIBZ */
 
+#ifdef HAVE_ZIO
+static void decompress_zio (void *data)
+{
+	char *what = data;
+	FILE *file;
+
+	if (!what)
+		what = (char *) "n";
+
+	file = fdzopen (dup (fileno (stdin)), "r", what);
+	if (!file)
+		return;
+
+	for (;;) {
+		char buffer[PIPE_BUF];
+		int r = fread (buffer, sizeof (char), sizeof (buffer), file);
+		if (r <= 0)
+			break;
+		if (fwrite (buffer, 1, (size_t) r, stdout) < (size_t) r)
+			break;
+	}
+
+	fclose (file);
+	return;
+}
+
+static int ATTRIBUTE_PURE which_decompressor (const char *filename)
+{
+	const size_t len = strlen (filename);
+	struct l_s {
+		const char *ext;
+		size_t len;
+		int d;
+	} list[] = {
+	        {"gz",   2, 'z' },
+                {"z",    1, 'z' },
+                {"Z",    1, 'Z' },
+	        {"bz2",  3, 'b' },
+                {"xz",   2, 'x' },
+                {"lzma", 4, 'l' },
+	        {"zst",  3, 's' },
+                {"zstd", 4, 's' },
+                {NULL,   0, '\0'},
+	};
+	struct l_s *l;
+
+	for (l = list; l->ext; ++l) {
+		if (len > l->len &&
+		    STREQ (filename + (len - l->len), l->ext)) {
+			return (int) l->d;
+		}
+	}
+	return 'n';
+}
+#endif /* HAVE_ZIO */
+
 decompress *decompress_open (const char *filename, int flags OPEN_FLAGS_UNUSED)
 {
 	pipecmd *cmd;
 	pipeline *p;
 	struct stat st;
+	const char *ext;
 #ifdef HAVE_LIBZ
+#  ifdef HAVE_ZIO
+	char opt[2] = {'\0', '\0'};
+#  else
 	size_t filename_len;
+#  endif
 #endif /* HAVE_LIBZ */
-	char *ext;
 	struct compression *comp;
 
 	if (stat (filename, &st) < 0 || S_ISDIR (st.st_mode))
 		return NULL;
 
 #ifdef HAVE_LIBZ
+#  ifdef HAVE_ZIO
+	if ((opt[0] = which_decompressor (filename)) != 'n') {
+#  else
 	filename_len = strlen (filename);
 	if (filename_len > 3 && STREQ (filename + filename_len - 3, ".gz")) {
+#  endif
 		if (flags & DECOMPRESS_ALLOW_INPROCESS) {
 			decompress *d = decompress_try_zlib (filename);
 			if (d)
 				return d;
 		}
-
+#  ifdef HAVE_ZIO
+		char *name = NULL;
+
+		/* informational only; no shell quoting concerns */
+		name = appendstr (NULL, "zio<", filename, (void *) 0);
+		cmd = pipecmd_new_function (name, &decompress_zio, NULL,
+		                            (void *) opt);
+#  else
 		cmd = pipecmd_new_function ("zcat", &decompress_zlib, NULL,
 		                            NULL);
+#  endif
 		pipecmd_pre_exec (cmd, sandbox_load, sandbox_free, sandbox);
 		p = pipeline_new_commands (cmd, nullptr);
+#  ifdef HAVE_ZIO
+		free (name);
+#  endif
 		goto got_pipeline;
 	}
 #endif /* HAVE_LIBZ */
@@ -235,9 +340,9 @@ decompress *decompress_open (const char *filename, int flags OPEN_FLAGS_UNUSED)
 		}
 	}
 
-#ifdef HAVE_GZIP
+#if defined(HAVE_GZIP) && !defined(HAVE_ZIO)
 	/* HP-UX */
-	ext = strstr (filename, ".Z/");
+	ext = strstr (filename, ".Z");
 	if (ext) {
 		cmd = pipecmd_new_argstr (PROG_GUNZIP);
 		pipecmd_pre_exec (cmd, sandbox_load, sandbox_free, sandbox);
@@ -262,7 +367,11 @@ decompress *decompress_fdopen (int fd)
 #endif /* HAVE_LIBZ */
 
 #ifdef HAVE_LIBZ
+#  ifdef HAVE_ZIO
+	cmd = pipecmd_new_function ("zio<", &decompress_zio, NULL, NULL);
+#  else
 	cmd = pipecmd_new_function ("zcat", &decompress_zlib, NULL, NULL);
+#  endif
 	pipecmd_pre_exec (cmd, sandbox_load, sandbox_free, sandbox);
 	p = pipeline_new_commands (cmd, nullptr);
 #else  /* HAVE_LIBZ */
@@ -312,7 +421,7 @@ void decompress_inprocess_replace (decompress *d, char *buf, size_t len)
 
 void decompress_start (decompress *d)
 {
-	if (d->tag == DECOMPRESS_PIPELINE)
+	if (d && d->tag == DECOMPRESS_PIPELINE)
 		pipeline_start (d->u.p);
 }
 
