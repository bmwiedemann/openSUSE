diff --git a/configure.ac b/configure.ac
index f4fe224..89fb860 100644
--- a/configure.ac
+++ b/configure.ac
@@ -252,6 +252,14 @@ then
 fi
 
 MAN_CHECK_PROGS([eqn], [EQN], [use EQN to preprocess equations], [eqn geqn])
+MAN_CHECK_PROGS([geqn], [GEQN], [use GEQN to preprocess equations], [geqn])
+dnl
+dnl if geqn is found and geqn is identical with eqn we use a GNU eqn
+dnl which its self can use -Tlatin1
+dnl
+if test -n "$geqn" -a -n "$eqn" ; then
+	test $geqn -ef $eqn && neqn="$eqn -T$nroff_device"
+fi
 MAN_CHECK_PROGS([neqn], [NEQN], [use NEQN to preprocess equations for character devices], [neqn gneqn])
 # If we fail to find an neqn, use eqn and try to force it to output for an
 # ascii device. As this is only relevant for equations (?), not using latin1
@@ -295,9 +303,15 @@ then
 	compress_ext="gz"
 fi
 MAN_CHECK_PROGS([compress], [COMPRESS], [use COMPRESS as UNIX compression utility], [compress])
-if test -n "$compress"
+if test -n "$compress" || test -n "$gzip"
 then
-	uncompress="$compress -dc"
+	if test -n "$gzip"
+	then
+		uncompress="$gzip -dc"
+	elif test -n "$compress"
+	then
+		uncompress="$compress -dc"
+	fi
 	if test -z "$gzip"
 	then
 		compressor="$compress -c"
diff --git a/include/comp_src.h.in b/include/comp_src.h.in
index bc5d601..39f5f0d 100644
--- a/include/comp_src.h.in
+++ b/include/comp_src.h.in
@@ -51,7 +51,7 @@ struct compression comp_list[] = {
 #endif /* HAVE_GZIP */
 
 /* If we have compress, incorporate the following */
-#ifdef HAVE_COMPRESS
+#if defined(HAVE_COMPRESS) || defined(HAVE_GZIP)
 	{UNCOMPRESS, "Z", NULL},
 /* Else if we have gzip, incorporate the following */
 #elif defined (HAVE_GZIP)
diff --git a/lib/security.c b/lib/security.c
index 55f2d85..8524d1c 100644
--- a/lib/security.c
+++ b/lib/security.c
@@ -79,6 +79,11 @@ static void gripe_set_euid (void)
 	error (FATAL, errno, _("can't set effective uid"));
 }
 
+static inline void gripe_set_egid (void)
+{
+	error (FATAL, errno, _("can't set effective gid"));
+}
+
 #endif /* MAN_OWNER */
 
 void init_security (void)
@@ -165,6 +170,31 @@ void regain_effective_privs (void)
 		uid = euid;
 		gid = egid;
 	}
+	if (gid != rgid) {
+#  if defined(HAVE_SETRESGID)
+		if (setresgid (rgid, egid, -1) < 0)
+#  elif defined(HAVE_SETREGID)
+		if (setregid (rgid, egid) < 0)
+#  elif defined(HAVE_SETEGID)
+		if (setegid (rgid) < 0)
+#  endif
+			gripe_set_egid();
+ 
+		gid = rgid;
+	}
+ 
+	if (gid != egid) {
+#  if defined(HAVE_SETRESGID)
+		if (setresgid (egid, rgid, -1))
+#  elif defined(HAVE_SETREGID)
+		if (setregid (egid, rgid) < 0)
+#  elif defined(HAVE_SETEGID)
+		if (setegid (egid))
+#  endif
+			gripe_set_egid();
+ 
+		gid = egid;
+	}
 #endif /* MAN_OWNER */
 }
 
diff --git a/mk_catdirs b/mk_catdirs
new file mode 100644
index 0000000..47eaa25
--- /dev/null
+++ b/mk_catdirs
@@ -0,0 +1,30 @@
+#!/bin/sh
+
+OLDPWD="`pwd`"
+CACHE="$1/var/cache/man"
+
+  cats="cat{0,1,2,3,4,5,6,7,8,9,n}"
+locale="{ca,cs,da,de,en,es,et,fi,fr,ga,hu,is,it,ja,ko,nl,no,pl,pt,ru,sk,sr,sv,uk}"
+  dirs="{local,opt}"
+
+umask 022
+test -d ${CACHE} && rm -rf ${CACHE}
+mkdir -p ${CACHE}
+
+catman=false
+grep -qE '#[[:blank:]]*define[[:blank:]]+MAN_CATS' include/manconfig.h && catman=true
+cd ${CACHE}
+if $catman ; then
+    eval echo ${cats} \
+	${locale}/${cats} \
+	${dirs}/${cats} \
+	${dirs}/${locale}/${cats}
+else
+    eval echo ${locale} \
+	${dirs} \
+	${dirs}/${locale}
+fi | xargs mkdir -p
+sync
+cd ${OLDPWD}
+
+test "$(id -u)" -ne 0 || chown man:man -R ${CACHE}
diff --git a/src/check_mandirs.c b/src/check_mandirs.c
index d28a6be..90c5d58 100644
--- a/src/check_mandirs.c
+++ b/src/check_mandirs.c
@@ -397,7 +397,7 @@ void chown_if_possible (const char *path _GL_UNUSED)
 #endif /* MAN_OWNER */
 
 /* create the catman hierarchy if it doesn't exist */
-static void mkcatdirs (const char *mandir, const char *catdir)
+void mkcatdirs (const char *mandir, const char *catdir)
 {
 	char *manname, *catname;
 
@@ -425,9 +425,14 @@ static void mkcatdirs (const char *mandir, const char *catdir)
 			int j;
 			regain_effective_privs ();
 			debug ("creating catdir hierarchy %s	", catdir);
-			for (j = 1; j <= 9; j++) {
-				catname[strlen (catname) - 1] = '0' + j;
-				manname[strlen (manname) - 1] = '0' + j;
+			for (j = 1; j <= 10; j++) {
+				unsigned int c;
+				if (j < 10)
+					c = '0' + j;
+				else
+					c = 'n';
+				catname[strlen (catname) - 1] = c;
+				manname[strlen (manname) - 1] = c;
 				if ((is_directory (manname) == 1)
 				 && (is_directory (catname) != 1)) {
 					if (mkdir (catname, 0755) < 0) {
@@ -435,7 +440,7 @@ static void mkcatdirs (const char *mandir, const char *catdir)
 							error (0, 0, _("warning: cannot create catdir %s"), catname);
 						debug ("warning: cannot create catdir %s\n", catname);
 					} else
-						debug (" cat%d", j);
+						debug (" cat%c", c);
 					chown_if_possible (catname);
 				}
 			}
@@ -583,15 +588,10 @@ static int testmandirs (const char *database,
 		}
 
 		if (!quiet) {
-			int tty = isatty (STDERR_FILENO);
-
-			if (tty)
-				fprintf (stderr, "\r");
 			fprintf (stderr,
 				 _("Updating index cache for path "
 				   "`%s/%s'. Wait..."), path, mandir->d_name);
-			if (!tty)
-				fprintf (stderr, "\n");
+			fprintf (stderr, "\n");
 		}
 		add_dir_entries (dbf, path, mandir->d_name);
 		MYDBM_CLOSE (dbf);
@@ -698,7 +698,7 @@ int update_db (const char *database, const char *manpath, const char *catpath)
 		dbf = NULL;
 	}
 	if (!dbf) {
-		debug ("failed to open %s O_RDONLY\n", database);
+		debug ("failed to open database %s O_RDONLY\n", database);
 		return EOF;
 	}
 	mtime = MYDBM_GET_TIME (dbf);
@@ -904,6 +904,7 @@ static int purge_whatis (MYDBM_FILE dbf, const char *path, int cat,
 			       "would delete\n", name, info->ext);
 		return 1;
 	}
+	return 1;
 }
 
 /* Check that multi keys are correctly constructed. */
@@ -1005,6 +1006,14 @@ int purge_missing (const char *database,
 			continue;
 		}
 
+		/* Ignore db identifier keys. */
+		if (*MYDBM_DPTR (key) == '.' && *(key.dptr+1) == 0) {
+			nextkey = MYDBM_NEXTKEY (dbf, key);
+			MYDBM_FREE_DPTR (key);
+			key = nextkey;
+			continue;
+		}
+
 		content = MYDBM_FETCH (dbf, key);
 		if (!MYDBM_DPTR (content)) {
 			nextkey = MYDBM_NEXTKEY (dbf, key);
diff --git a/src/lexgrog.l b/src/lexgrog.l
index cc31a70..1e3a0d5 100644
--- a/src/lexgrog.l
+++ b/src/lexgrog.l
@@ -64,7 +64,7 @@
 
 #include "manconv_client.h"
 
-#define YY_READ_BUF_SIZE	1024
+#define YY_READ_BUF_SIZE	YY_BUF_SIZE
 #define MAX_NAME		8192
 
 #define ARRAY_SIZE(array) (sizeof (array) / sizeof ((array)[0]))
@@ -212,15 +212,15 @@ static const struct macro perldocs[] = {
 	{ "R\"", "\"" }
 };
 
-static void add_str_to_whatis (const char *string, size_t length);
-static void add_char_to_whatis (unsigned char c);
-static void add_separator_to_whatis (void);
-static void add_wordn_to_whatis (const char *string, size_t length);
-static void add_word_to_whatis (const char *string);
-static void add_glyph_to_whatis (const char *string, size_t length);
-static void add_perldoc_to_whatis (const char *string, size_t length);
-static void mdoc_text (const char *string);
-static void newline_found (void);
+static __inline__ void add_str_to_whatis (const char *string, size_t length);
+static __inline__ void add_char_to_whatis (unsigned char c);
+static __inline__ void add_separator_to_whatis (const char *, size_t);
+static __inline__ void add_wordn_to_whatis (const char *string, size_t length);
+static __inline__ void add_word_to_whatis (const char *string);
+static __inline__ void add_glyph_to_whatis (const char *string, size_t length);
+static __inline__ void add_perldoc_to_whatis (const char *string, size_t length);
+static __inline__ void mdoc_text (const char *string);
+static __inline__ void newline_found (void);
 
 static char newname[MAX_NAME];
 static char *p_name;
@@ -229,6 +229,7 @@ static char filters[MAX_FILTERS];
 
 static int fill_mode;
 static int waiting_for_quote;
+static int have_separator;
 
 static pipeline *decomp;
 
@@ -246,7 +247,7 @@ static pipeline *decomp;
 %}
 
 %option ecs meta-ecs
-%option 8bit batch caseful never-interactive 
+%option 8bit batch caseful never-interactive align
 %option nostdinit
 %option warn
 %option noyywrap nounput
@@ -285,8 +286,9 @@ font_change	\\f([[:upper:]1-4]|\({upper}{2})
 size_change	\\s[+-]?{digit}
 style_change	({font_change}{size_change}?|{size_change}{font_change}?)
 typeface	\.(B[IR]?|I[BR]?|R[BI]|S[BM])
+paragr		\.[PITLH][Pp]
 sec_request	\.[Ss][HhYySs]
-comment		['.]\\{dbl_quote}
+comment		(['.]\\{dbl_quote}|\'\-+|\\&)
 
  /* Please add to this list if you know how. */
  /* Note that, since flex only supports UTF-8 by accident, character classes
@@ -325,7 +327,26 @@ vi_name		TÊN
 zh_CN_name	名{blank}?(称|字){blank}?.*
 zh_TW_name	(名{blank}?(稱|字)|命令名){blank}?.*
 name		({bg_name}|{cs_name}|{da_name}|{de_name}|{en_name}|{eo_name}|{es_name}|{fi_name}|{fr_name}|{hu_name}|{id_name}|{it_name}|{ja_name}|{ko_name}|{latin_name}|{lt_name}|{nl_name}|{pl_name}|{ro_name}|{ru_name}|{sk_name}|{sr_name}|{srlatin_name}|{sv_name}|{ta_name}|{tr_name}|{uk_name}|{vi_name}|{zh_CN_name}|{zh_TW_name})
-name_sec	{dbl_quote}?{style_change}?{name}{style_change}?({blank}*{dbl_quote})?
+name_sec	{dbl_quote}?{style_change}?{name}{style_change}?({blank}*{dbl_quote})?\r?
+start		{sec_request}{blank_eol}+{name_sec}
+
+N		N(\bN)?
+n		(N(\bN)?|n(\bn)?)
+a		(A(\bA)?|a(\ba)?)
+o		(O(\bO)?|o(\bo)?)
+m		(M(\bM)?|M(\bM)?)
+e		(E(\bE)?|e(\be)?)
+B		B(\bB)
+b		(B(\bB)?|b(\bb)?)
+r		(R(\bR)?|r(\br)?)
+z		(Z(\bZ)?|z(\bz)?)
+i		(I(\bI)?|i(\bi)?)
+c		(C(\bC)?|c(\bc)?)
+h		(H(\bH)?|h(\bh)?)
+u		(U(\bU)?|u(\bu)?)
+g		(G(\bG)?|g(\bg)?)
+
+cname		(({N}({a}|{o}){m}({n}|{e})|{N}{o}{m}|{N}{o}{m}{b}{r}{e}|{B}{e}{z}{e}{i}{c}{h}{n}{u}{n}{g})|{bg_name}|{cs_name}|{hu_name}|{ko_name}|{ru_name}|{sr_name}|{tr_name}|{vi_name}|{ja_name}|{zh_CN_name}|{zh_TW_name})
 
  /* eptgrv : eqn, pic, tbl, grap, refer, vgrind */
 tbl_request	\.TS
@@ -339,8 +360,13 @@ vgrind_request	\.vS
 %%
 
  /* begin NAME section processing */
-<MAN_FILE>{sec_request}{blank_eol}+{name_sec}{blank}*	BEGIN (MAN_PRENAME);
-<CAT_FILE>{empty}{2,}{name}{blank}*{indent}		BEGIN (CAT_NAME);
+<MAN_FILE>{
+	{start}{blank}*{bol}{blank}*{paragr}		|	/* strange format */
+	{start}{blank}*			{			/* default */
+							BEGIN (MAN_PRENAME);
+					}
+}
+<CAT_FILE>{empty}{2,}{cname}{blank}*{indent}		BEGIN (CAT_NAME);
 
  /* general text matching */
 <MAN_FILE>{
@@ -415,6 +441,7 @@ vgrind_request	\.vS
 	{bol}\.sp{blank}*		|	/* vertical spacing */
 	{bol}\.ig{blank}*		|	/* block comment */
 	{bol}\.de[1i]?{blank}*		|	/* macro definition */
+	{bol}\.V[be]{blank}*		|	/* special in perl pages */
 	{bol}\.i[ef]{blank}*		|	/* conditional */
 	{empty}{bol}.+			|
 	<<EOF>>				{	/* terminate the string */
@@ -462,8 +489,8 @@ vgrind_request	\.vS
 
  /* Toggle fill mode */
 <MAN_NAME,MAN_DESC>{
-	{bol}\.nf.*			fill_mode = 0;
-	{bol}\.fi.*			fill_mode = 1;
+	{bol}\.(nf|de).*		fill_mode = 0;
+	{bol}\.(fi|\.).*		fill_mode = 1;
 }
 
 <CAT_NAME>-{eol}{blank_eol}*		/* strip continuations */
@@ -472,6 +499,9 @@ vgrind_request	\.vS
 <MAN_NAME>{
 	{next}{blank}*\\\((mi|hy|em|en){blank}*		|
 	{next}{blank}*\\\[(mi|hy|em|en)\]{blank}*	|
+	{bol}\.sp{bol}{blank}+\\-{blank}*	|	/* strange spacing in NAME section */
+	{blank}+[-\\]?-{bol}			|	/* dash at end of line */
+	{next}{blank_eol}+(\\?-){2}{blank}+	|	/* some man pages use -- as dash */
 	{next}{blank_eol}+[-\\]-{blank}*		|
 	{next}{blank_eol}*[-\\]-{blank}+		|
 	{bol}\.Nd{blank}*			{
diff --git a/src/man.c b/src/man.c
index 6d1cba7..f72867c 100644
--- a/src/man.c
+++ b/src/man.c
@@ -56,6 +56,7 @@
 #include <time.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/time.h>
 
 #include "argp.h"
 #include "dirname.h"
@@ -106,6 +107,8 @@
 #ifdef MAN_OWNER
 extern uid_t ruid;
 extern uid_t euid;
+extern gid_t rgid;
+extern gid_t egid;
 #endif /* MAN_OWNER */
 
 /* the default preprocessor sequence */
@@ -136,6 +139,11 @@ char *lang;
 
 static bool global_manpath;	/* global or user manual page hierarchy? */
 static int skip;		/* page exists but has been skipped */
+static struct termios tms;	/* To save terminal settings in */
+static int tms_set = 0;		/* Do we have saved terminal settings? */
+static pid_t tms_pid = 0;
+
+static void set_term(void) { if (tms_set && getpid () == tms_pid) tcsetattr(fileno(stdin), TCSANOW, &tms); }
 
 #if defined _AIX || defined __sgi
 char **global_argv;
@@ -232,10 +240,10 @@ static int found_a_stray;		/* found a straycat */
 #ifdef MAN_CATS
 static char *tmp_cat_file;	/* for open_cat_stream(), close_cat_stream() */
 static int created_tmp_cat;			/* dto. */
-#endif
 static int tmp_cat_fd;
 static struct timespec man_modtime;	/* modtime of man page, for
 					 * commit_tmp_cat() */
+#endif
 
 # ifdef TROFF_IS_GROFF
 static bool ditroff;
@@ -608,36 +616,6 @@ static void gripe_no_name (const char *sect)
 	exit (FAIL);
 }
 
-static struct termios tms;
-static int tms_set = 0;
-static pid_t tms_pid = 0;
-
-static void set_term (void)
-{
-	if (tms_set && getpid () == tms_pid)
-		tcsetattr (STDIN_FILENO, TCSANOW, &tms);
-}
-
-static void get_term (void)
-{
-	if (isatty (STDOUT_FILENO)) {
-		debug ("is a tty\n");
-		tcgetattr (STDIN_FILENO, &tms);
-		if (!tms_set++) {
-			/* Work around pipecmd_exec calling exit(3) rather
-			 * than _exit(2), which means our atexit-registered
-			 * functions are called at the end of each child
-			 * process created using pipecmd_new_function and
-			 * friends.  It would probably be good to fix this
-			 * in libpipeline at some point, but it would
-			 * require care to avoid breaking compatibility.
-			 */
-			tms_pid = getpid ();
-			atexit (set_term);
-		}
-	}
-}
-
 #if defined(TROFF_IS_GROFF) || defined(HEIRLOOM_NROFF)
 static int get_roff_line_length (void)
 {
@@ -1526,6 +1504,18 @@ static void setenv_less (pipecmd *cmd, const char *title)
 	free (less_opts);
 }
 
+static void disable_x(void)
+{
+	char *bname = basename((char*)pager);
+	if (bname) {
+		if (!strcmp(bname, "less"))
+			unsetenv("DISPLAY");
+#if 0
+		free(bname);
+#endif
+	}
+}
+
 static void add_output_iconv (pipeline *p,
 			      const char *source, const char *target)
 {
@@ -1656,6 +1646,8 @@ static pipeline *make_display_command (const char *encoding, const char *title)
 
 	if (pager_cmd) {
 		setenv_less (pager_cmd, title);
+		if (!htmlout)
+			disable_x();
 		pipeline_command (p, pager_cmd);
 	}
 	pipeline_ignore_signals (p, 1);
@@ -1666,7 +1658,7 @@ static pipeline *make_display_command (const char *encoding, const char *title)
 	return p;
 }
 
-
+#ifdef MAN_CATS
 /* return a (malloced) temporary name in cat_file's directory */
 static char *tmp_cat_filename (const char *cat_file)
 {
@@ -1694,7 +1686,6 @@ static char *tmp_cat_filename (const char *cat_file)
 		return name;
 }
 
-
 /* If delete unlink tmp_cat, else commit tmp_cat to cat_file.
    Return non-zero on error.
  */
@@ -1767,6 +1758,7 @@ static int commit_tmp_cat (const char *cat_file, const char *tmp_cat,
 
 	return status;
 }
+#endif /* MAN_CATS */
 
 /* TODO: This should all be refactored after work on the decompression
  * library is complete.
@@ -1803,7 +1795,6 @@ static void cleanup_unlink (void *arg)
 }
 
 #ifdef MAN_CATS
-
 /* Return pipeline to write formatted manual page to for saving as cat file. */
 static pipeline *open_cat_stream (const char *cat_file, const char *encoding)
 {
@@ -2025,6 +2016,7 @@ static void format_display (pipeline *decomp,
 	regain_effective_privs ();
 }
 
+#ifdef MAN_CATS
 /* "Display" a page in catman mode, which amounts to saving it. */
 /* TODO: merge with format_display_and_save? */
 static void display_catman (const char *cat_file, pipeline *decomp,
@@ -2068,6 +2060,7 @@ static void display_catman (const char *cat_file, pipeline *decomp,
 	pop_cleanup (cleanup_unlink, tmpcat);
 	free (tmpcat);
 }
+#endif /* MAN_CATS */
 
 static void disable_hyphenation (void *data _GL_UNUSED)
 {
@@ -2268,7 +2261,7 @@ static int display (const char *dir, const char *man_file,
 		format_cmd = NULL;
 		decomp_errno = errno;
 	}
-
+#ifdef MAN_CATS
 	/* Get modification time, for commit_tmp_cat(). */
 	if (man_file && *man_file) {
 		struct stat stb;
@@ -2278,7 +2271,7 @@ static int display (const char *dir, const char *man_file,
 		} else
 			man_modtime = get_stat_mtime (&stb);
 	}
-
+#endif /* MAN_CATS */
 	display_to_stdout = troff;
 #ifdef TROFF_IS_GROFF
 	if (htmlout || gxditview)
@@ -2418,6 +2411,7 @@ static int display (const char *dir, const char *man_file,
 			}
 			if (printed)
 				putchar ('\n');
+#ifdef MAN_CATS
 		} else if (catman) {
 			if (format) {
 				if (!save_cat)
@@ -2430,6 +2424,7 @@ static int display (const char *dir, const char *man_file,
 							format_cmd,
 							formatted_encoding);
 			}
+#endif /* MAN_CATS */
 		} else if (format) {
 			/* no cat or out of date */
 			pipeline *disp_cmd;
@@ -2491,8 +2486,10 @@ static int display (const char *dir, const char *man_file,
 
 	free (formatted_encoding);
 
-	pipeline_free (format_cmd);
-	pipeline_free (decomp);
+	if (format_cmd)
+		pipeline_free (format_cmd);
+	if (decomp)
+		pipeline_free (decomp);
 
 	if (!prompt)
 		prompt = found;
@@ -3324,7 +3321,7 @@ static int display_database_check (struct candidate *candp)
 #ifdef MAN_DB_UPDATES
 	if (!exists && !skip) {
 		debug ("dbdelete_wrapper (%s, %p)\n",
-		       candp->req_name, candp->source);
+		       candp->req_name, candp->source->addr);
 		dbdelete_wrapper (candp->req_name, candp->source);
 	}
 #endif /* MAN_DB_UPDATES */
@@ -3753,17 +3750,20 @@ static int local_man_loop (const char *argv)
 		/* Check that the file exists and isn't e.g. a directory */
 		if (stat (argv, &st)) {
 			error (0, errno, "%s", argv);
+			regain_effective_privs ();
 			return NOT_FOUND;
 		}
 
 		if (S_ISDIR (st.st_mode)) {
 			error (0, EISDIR, "%s", argv);
+			regain_effective_privs ();
 			return NOT_FOUND;
 		}
 
 		if (S_ISCHR (st.st_mode) || S_ISBLK (st.st_mode)) {
 			/* EINVAL is about the best I can do. */
 			error (0, EINVAL, "%s", argv);
+			regain_effective_privs ();
 			return NOT_FOUND;
 		}
 
@@ -3826,6 +3826,11 @@ executable_out:
 					argv_abs = xstrdup (argv);
 			}
 			lang = lang_dir (argv_abs);
+			if (!lang || !*lang) {
+				if (lang)
+					free(lang);
+				lang = xstrdup(internal_locale);
+			}
 			free (argv_abs);
 			if (!display (NULL, argv, NULL, argv_base, NULL)) {
 				if (local_mf)
@@ -4075,7 +4080,16 @@ int main (int argc, char *argv[])
 	umask (022);
 	init_locale ();
 
-	internal_locale = setlocale (LC_MESSAGES, NULL);
+	internal_locale = setlocale (LC_MESSAGES, "");
+#if defined(__GLIBC__)
+# if (__GLIBC__ < 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 2)
+	if (!internal_locale) {
+		if (    !(internal_locale = getenv ("LC_ALL"))
+		     && !(internal_locale = getenv ("LC_MESSAGES")))
+			internal_locale = getenv ("LANG");
+	}
+# endif
+#endif
 	/* Use LANGUAGE only when LC_MESSAGES locale category is
 	 * neither "C" nor "POSIX". */
 	if (internal_locale && strcmp (internal_locale, "C") &&
@@ -4120,7 +4134,16 @@ int main (int argc, char *argv[])
 	if (external)
 		do_extern (argc, argv);
 
+#ifdef MAN_OWNER
+	if (isatty(fileno(stdin)) && isatty(fileno(stdout))) {
+		tcgetattr(fileno(stdin), &tms);
+		tms_pid = getpid ();
+		if (!tms_set++)
+			atexit(set_term);
+	}
+#else
 	get_term (); /* stores terminal settings */
+#endif
 
 	/* close this locale and reinitialise if a new locale was 
 	   issued as an argument or in $MANOPT */
diff --git a/src/man_db.conf.in b/src/man_db.conf.in
index 2942000..b2751f5 100644
--- a/src/man_db.conf.in
+++ b/src/man_db.conf.in
@@ -20,6 +20,14 @@
 MANDATORY_MANPATH			/usr/man
 MANDATORY_MANPATH			/usr/share/man
 MANDATORY_MANPATH			/usr/local/share/man
+MANDATORY_MANPATH			/opt/man
+MANDATORY_MANPATH			/opt/dx/man
+MANDATORY_MANPATH			/opt/lsb/man
+MANDATORY_MANPATH			/opt/cross/share/man
+MANDATORY_MANPATH			/opt/mpich/man
+MANDATORY_MANPATH			/opt/lsb-tet3-lite/share/man
+MANDATORY_MANPATH			/opt/snavigator/man
+MANDATORY_MANPATH			/opt/novell/man
 #---------------------------------------------------------
 # set up PATH to MANPATH mapping
 # ie. what man tree holds man pages for what binary directory.
@@ -34,8 +42,10 @@ MANPATH_MAP	/usr/local/bin		/usr/local/man
 MANPATH_MAP	/usr/local/bin		/usr/local/share/man
 MANPATH_MAP	/usr/local/sbin		/usr/local/man
 MANPATH_MAP	/usr/local/sbin		/usr/local/share/man
-MANPATH_MAP	/usr/X11R6/bin		/usr/X11R6/man
-MANPATH_MAP	/usr/bin/X11		/usr/X11R6/man
+MANPATH_MAP	/usr/X11R6/bin		/usr/share/man
+MANPATH_MAP	/usr/X11/bin		/usr/share/man
+MANPATH_MAP	/usr/bin/X11		/usr/share/man
+MANPATH_MAP	/usr/bin/mh		/usr/share/man
 MANPATH_MAP	/usr/games		/usr/share/man
 MANPATH_MAP	/opt/bin		/opt/man
 MANPATH_MAP	/opt/sbin		/opt/man
@@ -68,7 +78,8 @@ MANDB_MAP	/usr/share/man		/var/cache/man
 MANDB_MAP	/usr/local/man		/var/cache/man/oldlocal
 MANDB_MAP	/usr/local/share/man	/var/cache/man/local
 MANDB_MAP	/usr/X11R6/man		/var/cache/man/X11R6
-MANDB_MAP	/opt/man		/var/cache/man/opt
+MANDB_MAP	/opt/man		/var/cache/man/oldopt
+MANDB_MAP	/opt/share/man		/var/cache/man/opt
 MANDB_MAP	/snap/man		/var/cache/man/snap
 #
 #---------------------------------------------------------
diff --git a/src/mandb.c b/src/mandb.c
index 7a63d8d..786e77b 100644
--- a/src/mandb.c
+++ b/src/mandb.c
@@ -203,6 +203,8 @@ struct dbpaths {
 #ifdef MAN_OWNER
 extern uid_t ruid;
 extern uid_t euid;
+extern gid_t rgid;
+extern gid_t egid;
 #endif /* MAN_OWNER */
 
 static gl_list_t manpathlist;
@@ -554,6 +556,8 @@ out:
 	return amount;
 }
 
+extern void mkcatdirs (const char *, const char *);
+
 static int process_manpath (const char *manpath, bool global_manpath,
 			    gl_map_t tried_catdirs)
 {
@@ -601,6 +605,8 @@ static int process_manpath (const char *manpath, bool global_manpath,
 		free (database);
 	}
 
+	mkcatdirs (manpath, catpath);
+
 	dbpaths = XZALLOC (struct dbpaths);
 	push_cleanup (cleanup, dbpaths, 0);
 	push_cleanup (cleanup_sigsafe, dbpaths, 1);
@@ -616,7 +622,7 @@ static int process_manpath (const char *manpath, bool global_manpath,
 	if (!opt_test && amount)
 		finish_up (dbpaths);
 #ifdef MAN_OWNER
-	if (global_manpath)
+	if (global_manpath  && (euid == 0 || ruid == 0))
 		do_chown (dbpaths);
 #endif /* MAN_OWNER */
 
@@ -819,8 +825,14 @@ int main (int argc, char *argv[])
 
 #ifdef MAN_OWNER
 	man_owner = get_man_owner ();
-	if (!user && euid != 0 && euid != man_owner->pw_uid)
-		user = true;
+	if (!user) {
+		if (!ruid && euid != man_owner->pw_uid) {
+			seteuid(man_owner->pw_uid);
+			euid = geteuid();
+		}
+		if (euid != man_owner->pw_uid)
+			user = true;
+	}
 #endif /* MAN_OWNER */
 
 	read_config_file (user);
diff --git a/src/manp.c b/src/manp.c
index 5441339..ac46d3f 100644
--- a/src/manp.c
+++ b/src/manp.c
@@ -898,7 +898,7 @@ static char *def_path (enum config_flag flag)
 
 	/* If we have complete config file failure... */
 	if (!manpath)
-		return xstrdup ("/usr/man");
+		return xstrdup ("/usr/share/man");
 
 	return manpath;
 }
diff --git a/src/straycats.c b/src/straycats.c
index b07083c..fbc0c1b 100644
--- a/src/straycats.c
+++ b/src/straycats.c
@@ -37,6 +37,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
+#include <fcntl.h>
 #include <dirent.h>
 
 #include "canonicalize.h"
diff --git a/src/ult_src.c b/src/ult_src.c
index 43e7a9b..93bd30c 100644
--- a/src/ult_src.c
+++ b/src/ult_src.c
@@ -336,10 +336,15 @@ const char *ult_src (const char *name, const char *path,
 		}
 		pipeline_start (decomp);
 
-		/* make sure that we skip over any comments */
+		/*
+		 * make sure that we skip over any comments
+		 * ... even if we handle TCL/TK manual pages
+		 */
 		do {
 			buffer = pipeline_readline (decomp);
-		} while (buffer && STRNEQ (buffer, ".\\\"", 3));
+		} while (buffer && *buffer &&
+			 (STRNEQ (buffer, ".\\\"", 3) ||
+			  STRNEQ (buffer, "'\\\"", 3)));
 
 		include = test_for_include (buffer);
 		if (include) {
