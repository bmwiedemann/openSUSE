diff -Nur mruby-3.0.0/include/mruby/proc.h new/include/mruby/proc.h
--- mruby-3.0.0/include/mruby/proc.h	2021-03-05 09:07:35.000000000 +0100
+++ new/include/mruby/proc.h	2021-12-16 13:05:19.456367294 +0100
@@ -90,7 +90,7 @@
 struct RProc *mrb_closure_new(mrb_state*, const mrb_irep*);
 MRB_API struct RProc *mrb_proc_new_cfunc(mrb_state*, mrb_func_t);
 MRB_API struct RProc *mrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals);
-void mrb_proc_copy(struct RProc *a, struct RProc *b);
+void mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b);
 mrb_int mrb_proc_arity(const struct RProc *p);
 
 /* following functions are defined in mruby-proc-ext so please include it when using */
diff -Nur mruby-3.0.0/src/class.c new/src/class.c
--- mruby-3.0.0/src/class.c	2021-03-05 09:07:35.000000000 +0100
+++ new/src/class.c	2021-12-16 13:07:55.280492289 +0100
@@ -2511,7 +2511,7 @@
     mrb_raise(mrb, E_ARGUMENT_ERROR, "no block given");
   }
   p = (struct RProc*)mrb_obj_alloc(mrb, MRB_TT_PROC, mrb->proc_class);
-  mrb_proc_copy(p, mrb_proc_ptr(blk));
+  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
   p->flags |= MRB_PROC_STRICT;
   MRB_METHOD_FROM_PROC(m, p);
   mrb_define_method_raw(mrb, c, mid, m);
diff -Nur mruby-3.0.0/src/proc.c new/src/proc.c
--- mruby-3.0.0/src/proc.c	2021-03-05 09:07:35.000000000 +0100
+++ new/src/proc.c	2021-12-16 13:07:17.312462000 +0100
@@ -184,7 +184,7 @@
 }
 
 void
-mrb_proc_copy(struct RProc *a, struct RProc *b)
+mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)
 {
   if (a->body.irep) {
     /* already initialized proc */
@@ -192,10 +192,10 @@
   }
   a->flags = b->flags;
   a->body = b->body;
+  a->upper = b->upper;
   if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {
-    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);
+    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);
   }
-  a->upper = b->upper;
   a->e.env = b->e.env;
   /* a->e.target_class = a->e.target_class; */
 }
@@ -210,7 +210,7 @@
   /* Calling Proc.new without a block is not implemented yet */
   mrb_get_args(mrb, "&!", &blk);
   p = (struct RProc *)mrb_obj_alloc(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
-  mrb_proc_copy(p, mrb_proc_ptr(blk));
+  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
   proc = mrb_obj_value(p);
   mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
   if (!MRB_PROC_STRICT_P(p) &&
@@ -228,7 +228,7 @@
   if (!mrb_proc_p(proc)) {
     mrb_raise(mrb, E_ARGUMENT_ERROR, "not a proc");
   }
-  mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));
+  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));
   return self;
 }
 
@@ -264,7 +264,7 @@
   p = mrb_proc_ptr(blk);
   if (!MRB_PROC_STRICT_P(p)) {
     struct RProc *p2 = (struct RProc*)mrb_obj_alloc(mrb, MRB_TT_PROC, p->c);
-    mrb_proc_copy(p2, p);
+    mrb_proc_copy(mrb, p2, p);
     p2->flags |= MRB_PROC_STRICT;
     return mrb_obj_value(p2);
   }
