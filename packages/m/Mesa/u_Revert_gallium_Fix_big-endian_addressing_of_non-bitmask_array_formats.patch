This reverts the functional part of commit
d17ff2f7, leaving the unit test for
mesa/pipe agreement on what's an array.

The issue is that the util_channel_desc.shift values on array formats are
not used for bit addressing in memory, they're bit addressing within a
word treating a pixel of the format as a native type, as seen by
llvmpipe's use of the values to do shifts (see
lp_build_unpack_arith_rgba_aos() for example).  This means the values are
nonsensical for 3-byte RGB, but then llvmpipe doesn't expose those formats
so it works out.

I still want to clean up our big-endian format handling at some point, but
let's fix the s390x regression first, sort out our format unit tests in
CI, then be able to refactor with confidence.

Fixes: d17ff2f7 ("gallium: Fix big-endian addressing of non-bitmask array formats.")
Closes: #2440
Closes: #2472

diff --git a/src/gallium/auxiliary/util/u_format_parse.py b/src/util/gallium/auxiliary/u_format_parse.py
index 541ae69d4dc662e16c08ed7c27a9e65534a4b08f..b9627055cda3f5277bddc1936614a983f1359d00 100644
--- a/src/gallium/auxiliary/util/u_format_parse.py
+++ b/src/gallium/auxiliary/util/u_format_parse.py
@@ -379,27 +379,16 @@ def parse(filename):
             channel.shift = le_shift
             le_shift += channel.size
 
+        be_shift = 0
+        for channel in be_channels[3::-1]:
+            channel.shift = be_shift
+            be_shift += channel.size
+
+        assert le_shift == be_shift
         for i in range(4):
             assert (le_swizzles[i] != SWIZZLE_NONE) == (be_swizzles[i] != SWIZZLE_NONE)
 
         format = Format(name, layout, block_width, block_height, block_depth, le_channels, le_swizzles, be_channels, be_swizzles, colorspace)
-
-        if format.is_array() and not format.is_bitmask():
-            # Formats accessed as arrays by the pack functions (R32G32_FLOAT or
-            # R8G8B8_UNORM, for example) should not be channel-ordering-reversed
-            # for BE.
-            # Note that __eq__ on channels ignores .shift!
-            assert(format.be_channels == format.le_channels)
-            assert(format.be_swizzles == format.le_swizzles)
-            format.be_channels = format.le_channels
-        else:
-            be_shift = 0
-            for channel in format.be_channels[3::-1]:
-                channel.shift = be_shift
-                be_shift += channel.size
-
-            assert le_shift == be_shift
-
         formats.append(format)
     return formats
 
