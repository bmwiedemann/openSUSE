Index: mesa-22.1.7/src/gallium/auxiliary/gallivm/lp_bld.h
===================================================================
--- mesa-22.1.7.orig/src/gallium/auxiliary/gallivm/lp_bld.h
+++ mesa-22.1.7/src/gallium/auxiliary/gallivm/lp_bld.h
@@ -81,10 +81,17 @@
 #define LLVMInsertBasicBlock ILLEGAL_LLVM_FUNCTION
 #define LLVMCreateBuilder ILLEGAL_LLVM_FUNCTION
 
-#if LLVM_VERSION_MAJOR >= 8
+#if LLVM_VERSION_MAJOR >= 15
+#define GALLIVM_HAVE_CORO 0
+#define GALLIVM_USE_NEW_PASS 1
+#elif LLVM_VERSION_MAJOR >= 8
 #define GALLIVM_HAVE_CORO 1
+#define GALLIVM_USE_NEW_PASS 0
 #else
 #define GALLIVM_HAVE_CORO 0
+#define GALLIVM_USE_NEW_PASS 0
 #endif
 
+#define GALLIVM_COROUTINES (GALLIVM_HAVE_CORO || GALLIVM_USE_NEW_PASS)
+
 #endif /* LP_BLD_H */
Index: mesa-22.1.7/src/gallium/auxiliary/gallivm/lp_bld_arit.c
===================================================================
--- mesa-22.1.7.orig/src/gallium/auxiliary/gallivm/lp_bld_arit.c
+++ mesa-22.1.7/src/gallium/auxiliary/gallivm/lp_bld_arit.c
@@ -391,16 +391,10 @@ lp_build_comp(struct lp_build_context *b
          return LLVMBuildNot(builder, a, "");
    }
 
-   if(LLVMIsConstant(a))
-      if (type.floating)
-          return LLVMConstFSub(bld->one, a);
-      else
-          return LLVMConstSub(bld->one, a);
+   if (type.floating)
+      return LLVMBuildFSub(builder, bld->one, a, "");
    else
-      if (type.floating)
-         return LLVMBuildFSub(builder, bld->one, a, "");
-      else
-         return LLVMBuildSub(builder, bld->one, a, "");
+      return LLVMBuildSub(builder, bld->one, a, "");
 }
 
 
@@ -479,16 +473,10 @@ lp_build_add(struct lp_build_context *bl
       }
    }
 
-   if(LLVMIsConstant(a) && LLVMIsConstant(b))
-      if (type.floating)
-         res = LLVMConstFAdd(a, b);
-      else
-         res = LLVMConstAdd(a, b);
+   if (type.floating)
+      res = LLVMBuildFAdd(builder, a, b, "");
    else
-      if (type.floating)
-         res = LLVMBuildFAdd(builder, a, b, "");
-      else
-         res = LLVMBuildAdd(builder, a, b, "");
+      res = LLVMBuildAdd(builder, a, b, "");
 
    /* clamp to ceiling of 1.0 */
    if(bld->type.norm && (bld->type.floating || bld->type.fixed))
@@ -815,16 +803,10 @@ lp_build_sub(struct lp_build_context *bl
       }
    }
 
-   if(LLVMIsConstant(a) && LLVMIsConstant(b))
-      if (type.floating)
-         res = LLVMConstFSub(a, b);
-      else
-         res = LLVMConstSub(a, b);
+   if (type.floating)
+      res = LLVMBuildFSub(builder, a, b, "");
    else
-      if (type.floating)
-         res = LLVMBuildFSub(builder, a, b, "");
-      else
-         res = LLVMBuildSub(builder, a, b, "");
+      res = LLVMBuildSub(builder, a, b, "");
 
    if(bld->type.norm && (bld->type.floating || bld->type.fixed))
       res = lp_build_max_simple(bld, res, bld->zero, GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN);
@@ -980,29 +962,15 @@ lp_build_mul(struct lp_build_context *bl
    else
       shift = NULL;
 
-   if(LLVMIsConstant(a) && LLVMIsConstant(b)) {
-      if (type.floating)
-         res = LLVMConstFMul(a, b);
-      else
-         res = LLVMConstMul(a, b);
-      if(shift) {
-         if(type.sign)
-            res = LLVMConstAShr(res, shift);
-         else
-            res = LLVMConstLShr(res, shift);
-      }
-   }
-   else {
-      if (type.floating)
-         res = LLVMBuildFMul(builder, a, b, "");
+   if (type.floating)
+      res = LLVMBuildFMul(builder, a, b, "");
+   else
+      res = LLVMBuildMul(builder, a, b, "");
+   if(shift) {
+      if(type.sign)
+	 res = LLVMBuildAShr(builder, res, shift, "");
       else
-         res = LLVMBuildMul(builder, a, b, "");
-      if(shift) {
-         if(type.sign)
-            res = LLVMBuildAShr(builder, res, shift, "");
-         else
-            res = LLVMBuildLShr(builder, res, shift, "");
-      }
+	 res = LLVMBuildLShr(builder, res, shift, "");
    }
 
    return res;
@@ -1288,15 +1256,6 @@ lp_build_div(struct lp_build_context *bl
    if(a == bld->undef || b == bld->undef)
       return bld->undef;
 
-   if(LLVMIsConstant(a) && LLVMIsConstant(b)) {
-      if (type.floating)
-         return LLVMConstFDiv(a, b);
-      else if (type.sign)
-         return LLVMConstSDiv(a, b);
-      else
-         return LLVMConstUDiv(a, b);
-   }
-
    /* fast rcp is disabled (just uses div), so makes no sense to try that */
    if(FALSE &&
       ((util_get_cpu_caps()->has_sse && type.width == 32 && type.length == 4) ||
@@ -2646,7 +2605,7 @@ lp_build_rcp(struct lp_build_context *bl
    assert(type.floating);
 
    if(LLVMIsConstant(a))
-      return LLVMConstFDiv(bld->one, a);
+      return LLVMBuildFDiv(builder, bld->one, a, "");
 
    /*
     * We don't use RCPPS because:
Index: mesa-22.1.7/src/gallium/auxiliary/gallivm/lp_bld_init.c
===================================================================
--- mesa-22.1.7.orig/src/gallium/auxiliary/gallivm/lp_bld_init.c
+++ mesa-22.1.7/src/gallium/auxiliary/gallivm/lp_bld_init.c
@@ -45,7 +45,9 @@
 #include <llvm-c/Transforms/Utils.h>
 #endif
 #include <llvm-c/BitWriter.h>
-#if GALLIVM_HAVE_CORO
+#if GALLIVM_USE_NEW_PASS == 1
+#include <llvm-c/Transforms/PassBuilder.h>
+#elif GALLIVM_HAVE_CORO == 1
 #if LLVM_VERSION_MAJOR <= 8 && (defined(PIPE_ARCH_AARCH64) || defined (PIPE_ARCH_ARM) || defined(PIPE_ARCH_S390) || defined(PIPE_ARCH_MIPS64))
 #include <llvm-c/Transforms/IPO.h>
 #endif
@@ -110,6 +112,7 @@ enum LLVM_CodeGenOpt_Level {
 static boolean
 create_pass_manager(struct gallivm_state *gallivm)
 {
+#if GALLIVM_USE_NEW_PASS == 0
    assert(!gallivm->passmgr);
    assert(gallivm->target);
 
@@ -117,7 +120,7 @@ create_pass_manager(struct gallivm_state
    if (!gallivm->passmgr)
       return FALSE;
 
-#if GALLIVM_HAVE_CORO
+#if GALLIVM_HAVE_CORO == 1
    gallivm->cgpassmgr = LLVMCreatePassManager();
 #endif
    /*
@@ -134,7 +137,7 @@ create_pass_manager(struct gallivm_state
       free(td_str);
    }
 
-#if GALLIVM_HAVE_CORO
+#if GALLIVM_HAVE_CORO == 1
 #if LLVM_VERSION_MAJOR <= 8 && (defined(PIPE_ARCH_AARCH64) || defined (PIPE_ARCH_ARM) || defined(PIPE_ARCH_S390) || defined(PIPE_ARCH_MIPS64))
    LLVMAddArgumentPromotionPass(gallivm->cgpassmgr);
    LLVMAddFunctionAttrsPass(gallivm->cgpassmgr);
@@ -181,14 +184,13 @@ create_pass_manager(struct gallivm_state
        */
       LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
    }
-#if GALLIVM_HAVE_CORO
+#if GALLIVM_HAVE_CORO == 1
    LLVMAddCoroCleanupPass(gallivm->passmgr);
 #endif
-
+#endif
    return TRUE;
 }
 
-
 /**
  * Free gallivm object's LLVM allocations, but not any generated code
  * nor the gallivm object itself.
@@ -196,15 +198,17 @@ create_pass_manager(struct gallivm_state
 void
 gallivm_free_ir(struct gallivm_state *gallivm)
 {
+#if GALLIVM_USE_NEW_PASS == 0
    if (gallivm->passmgr) {
       LLVMDisposePassManager(gallivm->passmgr);
    }
 
-#if GALLIVM_HAVE_CORO
+#if GALLIVM_HAVE_CORO == 1
    if (gallivm->cgpassmgr) {
       LLVMDisposePassManager(gallivm->cgpassmgr);
    }
 #endif
+#endif
 
    if (gallivm->engine) {
       /* This will already destroy any associated module */
@@ -232,8 +236,12 @@ gallivm_free_ir(struct gallivm_state *ga
    gallivm->target = NULL;
    gallivm->module = NULL;
    gallivm->module_name = NULL;
+#if GALLIVM_USE_NEW_PASS == 0
+#if GALLIVM_HAVE_CORO == 1
    gallivm->cgpassmgr = NULL;
+#endif
    gallivm->passmgr = NULL;
+#endif
    gallivm->context = NULL;
    gallivm->builder = NULL;
    gallivm->cache = NULL;
@@ -571,7 +579,6 @@ gallivm_verify_function(struct gallivm_s
 void
 gallivm_compile_module(struct gallivm_state *gallivm)
 {
-   LLVMValueRef func;
    int64_t time_begin = 0;
 
    assert(!gallivm->compiled);
@@ -581,6 +588,13 @@ gallivm_compile_module(struct gallivm_st
       gallivm->builder = NULL;
    }
 
+   LLVMSetDataLayout(gallivm->module, "");
+   assert(!gallivm->engine);
+   if (!init_gallivm_engine(gallivm)) {
+      assert(0);
+   }
+   assert(gallivm->engine);
+
    if (gallivm->cache && gallivm->cache->data_size) {
       goto skip_cached;
    }
@@ -604,11 +618,33 @@ gallivm_compile_module(struct gallivm_st
    if (gallivm_debug & GALLIVM_DEBUG_PERF)
       time_begin = os_time_get();
 
-#if GALLIVM_HAVE_CORO
+#if GALLIVM_USE_NEW_PASS == 1
+   char passes[1024];
+   passes[0] = 0;
+
+   /*
+    * there should be some way to combine these two pass runs but I'm not seeing it,
+    * at the time of writing.
+    */
+   strcpy(passes, "default<O0>");
+
+   LLVMPassBuilderOptionsRef opts = LLVMCreatePassBuilderOptions();
+   LLVMRunPasses(gallivm->module, passes, LLVMGetExecutionEngineTargetMachine(gallivm->engine), opts);
+
+   if (!(gallivm_perf & GALLIVM_PERF_NO_OPT))
+      strcpy(passes, "sroa,early-cse,simplifycfg,reassociate,mem2reg,constprop,instcombine,");
+   else
+      strcpy(passes, "mem2reg");
+
+   LLVMRunPasses(gallivm->module, passes, LLVMGetExecutionEngineTargetMachine(gallivm->engine), opts);
+   LLVMDisposePassBuilderOptions(opts);
+#else
+#if GALLIVM_HAVE_CORO == 1
    LLVMRunPassManager(gallivm->cgpassmgr, gallivm->module);
 #endif
    /* Run optimization passes */
    LLVMInitializeFunctionPassManager(gallivm->passmgr);
+   LLVMValueRef func;
    func = LLVMGetFirstFunction(gallivm->module);
    while (func) {
       if (0) {
@@ -626,7 +662,7 @@ gallivm_compile_module(struct gallivm_st
       func = LLVMGetNextFunction(func);
    }
    LLVMFinalizeFunctionPassManager(gallivm->passmgr);
-
+#endif
    if (gallivm_debug & GALLIVM_DEBUG_PERF) {
       int64_t time_end = os_time_get();
       int time_msec = (int)((time_end - time_begin) / 1000);
@@ -653,12 +689,6 @@ gallivm_compile_module(struct gallivm_st
     * lp_build_create_jit_compiler_for_module()
     */
  skip_cached:
-   LLVMSetDataLayout(gallivm->module, "");
-   assert(!gallivm->engine);
-   if (!init_gallivm_engine(gallivm)) {
-      assert(0);
-   }
-   assert(gallivm->engine);
 
    ++gallivm->compiled;
 
Index: mesa-22.1.7/src/gallium/auxiliary/gallivm/lp_bld_init.h
===================================================================
--- mesa-22.1.7.orig/src/gallium/auxiliary/gallivm/lp_bld_init.h
+++ mesa-22.1.7/src/gallium/auxiliary/gallivm/lp_bld_init.h
@@ -46,8 +46,12 @@ struct gallivm_state
    LLVMModuleRef module;
    LLVMExecutionEngineRef engine;
    LLVMTargetDataRef target;
+#if GALLIVM_USE_NEW_PASS == 0
    LLVMPassManagerRef passmgr;
+#if GALLIVM_HAVE_CORO == 1
    LLVMPassManagerRef cgpassmgr;
+#endif
+#endif
    LLVMContextRef context;
    LLVMBuilderRef builder;
    LLVMMCJITMemoryManagerRef memorymgr;
Index: mesa-22.1.7/src/gallium/drivers/llvmpipe/lp_screen.c
===================================================================
--- mesa-22.1.7.orig/src/gallium/drivers/llvmpipe/lp_screen.c
+++ mesa-22.1.7/src/gallium/drivers/llvmpipe/lp_screen.c
@@ -215,7 +215,7 @@ llvmpipe_get_param(struct pipe_screen *s
       return lscreen->use_tgsi ? 330 : 450;
    }
    case PIPE_CAP_COMPUTE:
-      return GALLIVM_HAVE_CORO;
+      return GALLIVM_COROUTINES;
    case PIPE_CAP_USER_VERTEX_BUFFERS:
       return 1;
    case PIPE_CAP_TGSI_TEXCOORD:
@@ -394,7 +394,7 @@ llvmpipe_get_shader_param(struct pipe_sc
    case PIPE_SHADER_TESS_CTRL:
    case PIPE_SHADER_TESS_EVAL:
       /* Tessellation shader needs llvm coroutines support */
-      if (!GALLIVM_HAVE_CORO || lscreen->use_tgsi)
+      if (!GALLIVM_COROUTINES || lscreen->use_tgsi)
          return 0;
       FALLTHROUGH;
    case PIPE_SHADER_VERTEX:
Index: mesa-22.1.7/src/gallium/frontends/clover/llvm/compat.hpp
===================================================================
--- mesa-22.1.7.orig/src/gallium/frontends/clover/llvm/compat.hpp
+++ mesa-22.1.7/src/gallium/frontends/clover/llvm/compat.hpp
@@ -102,7 +102,11 @@ namespace clover {
                                     clang::InputKind ik, const ::llvm::Triple& triple,
                                     clang::LangStandard::Kind d)
          {
+#if LLVM_VERSION_MAJOR >= 15
+            c->getLangOpts().setLangDefaults(c->getLangOpts(), ik.getLanguage(), triple,
+#else
             c->getInvocation().setLangDefaults(c->getLangOpts(), ik, triple,
+#endif
 #if LLVM_VERSION_MAJOR >= 12
                                                c->getPreprocessorOpts().Includes,
 #else
