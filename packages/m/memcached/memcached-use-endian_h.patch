Index: util.c
===================================================================
--- util.c.orig
+++ util.c
@@ -167,30 +167,3 @@ void vperror(const char *fmt, ...) {
     perror(buf);
 }
 
-#ifndef HAVE_HTONLL
-static uint64_t mc_swap64(uint64_t in) {
-#ifdef ENDIAN_LITTLE
-    /* Little endian, flip the bytes around until someone makes a faster/better
-    * way to do this. */
-    int64_t rv = 0;
-    int i = 0;
-     for(i = 0; i<8; i++) {
-        rv = (rv << 8) | (in & 0xff);
-        in >>= 8;
-     }
-    return rv;
-#else
-    /* big-endian machines don't need byte swapping */
-    return in;
-#endif
-}
-
-uint64_t ntohll(uint64_t val) {
-   return mc_swap64(val);
-}
-
-uint64_t htonll(uint64_t val) {
-   return mc_swap64(val);
-}
-#endif
-
Index: util.h
===================================================================
--- util.h.orig
+++ util.h
@@ -11,16 +11,17 @@ bool uriencode(const char *src, char *ds
  *
  * returns true if conversion succeeded.
  */
+
+#include <endian.h>
+
 bool safe_strtoull(const char *str, uint64_t *out);
 bool safe_strtoll(const char *str, int64_t *out);
 bool safe_strtoul(const char *str, uint32_t *out);
 bool safe_strtol(const char *str, int32_t *out);
 bool safe_strtod(const char *str, double *out);
 
-#ifndef HAVE_HTONLL
-extern uint64_t htonll(uint64_t);
-extern uint64_t ntohll(uint64_t);
-#endif
+#define htonll(x) htobe64(x)
+#define ntohll(x) be64toh(x)
 
 #ifdef __GCC
 # define __gcc_attribute__ __attribute__
