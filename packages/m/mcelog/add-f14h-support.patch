Add F14h decoding support

Signed-off-by: Borislav Petkov <bp@suse.de>
---
 amd.c    |   88 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 amd.h    |    3 +-
 mcelog.c |    2 +
 mcelog.h |    1 
 4 files changed, 93 insertions(+), 1 deletion(-)

--- a/amd.c
+++ b/amd.c
@@ -159,6 +159,8 @@
 		return CPU_F11H;
 	case 0x12:
 		return CPU_F12H;
+	case 0x14:
+		return CPU_F14H;
 	default:
 		break;
 	}
@@ -381,6 +383,58 @@
 	return f10h_mc0_mce(ec, xec);
 }
 
+static bool cat_mc0_mce(u16 ec, u8 xec)
+{
+	u8 r4	 = R4(ec);
+	bool ret = true;
+
+	if (MEM_ERROR(ec)) {
+
+		if (TT(ec) != TT_DATA || LL(ec) != LL_L1)
+			return false;
+
+		switch (r4) {
+		case R4_DRD:
+		case R4_DWR:
+			Wprintf("Data/Tag parity error due to %s.\n",
+				(r4 == R4_DRD ? "load/hw prf" : "store"));
+			break;
+		case R4_EVICT:
+			Wprintf("Copyback parity error on a tag miss.\n");
+			break;
+		case R4_SNOOP:
+			Wprintf("Tag parity error during snoop.\n");
+			break;
+		default:
+			ret = false;
+		}
+	} else if (BUS_ERROR(ec)) {
+
+		if ((II(ec) != II_MEM && II(ec) != II_IO) || LL(ec) != LL_LG)
+			return false;
+
+		Wprintf("System read data error on a ");
+
+		switch (r4) {
+		case R4_RD:
+			Wprintf("TLB reload.\n");
+			break;
+		case R4_DWR:
+			Wprintf("store.\n");
+			break;
+		case R4_DRD:
+			Wprintf("load.\n");
+			break;
+		default:
+			ret = false;
+		}
+	} else {
+		ret = false;
+	}
+
+	return ret;
+}
+
 static void decode_mc0_mce(struct amd_decoder_ops *ops, struct mce *m)
 {
 	u16 ec = EC(m->status);
@@ -402,6 +456,31 @@
 		Eprintf("Corrupted MC0 MCE info?\n");
 }
 
+static bool cat_mc1_mce(u16 ec, u8 xec)
+{
+	u8 r4    = R4(ec);
+	bool ret = true;
+
+	if (!MEM_ERROR(ec))
+		return false;
+
+	if (TT(ec) != TT_INSTR)
+		return false;
+
+	if (r4 == R4_IRD)
+		Wprintf("Data/tag array parity error for a tag hit.\n");
+	else if (r4 == R4_SNOOP)
+		Wprintf("Tag error during snoop/victimization.\n");
+	else if (xec == 0x0)
+		Wprintf("Tag parity error from victim castout.\n");
+	else if (xec == 0x2)
+		Wprintf("Microcode patch RAM parity error.\n");
+	else
+		ret = false;
+
+	return ret;
+}
+
 static void decode_mc1_mce(struct amd_decoder_ops *ops, struct mce *m)
 {
 	u16 ec = EC(m->status);
@@ -656,6 +735,12 @@
 		.mc1_mce = k8_mc1_mce,
 		.mc2_mce = k8_mc2_mce,
 	},
+	[AMD_F14H] = {
+		.cpu	 = AMD_F14H,
+		.mc0_mce = cat_mc0_mce,
+		.mc1_mce = cat_mc1_mce,
+		.mc2_mce = k8_mc2_mce,
+	},
 };
 
 static void __decode_amd_mc(enum cputype cpu, struct mce *mce)
@@ -672,6 +757,9 @@
 	case CPU_F12H:
 		ops = &fam_ops[AMD_F12H];
 		break;
+	case CPU_F14H:
+		ops = &fam_ops[AMD_F14H];
+		break;
 	default:
 		Eprintf("Huh? What family is it: 0x%x?!\n", cpu);
 		return;
--- a/amd.h
+++ b/amd.h
@@ -96,4 +96,5 @@
 	case CPU_K8:  \
 	case CPU_F10H: \
 	case CPU_F11H: \
-	case CPU_F12H
+	case CPU_F12H: \
+	case CPU_F14H
--- a/mcelog.c
+++ b/mcelog.c
@@ -232,6 +232,7 @@
 	[CPU_F10H] = "AMD Greyhound",
 	[CPU_F11H] = "AMD Griffin",
 	[CPU_F12H] = "AMD Llano",
+	[CPU_F14H] = "AMD Bobcat",
 	[CPU_P4] = "Intel P4",
 	[CPU_NEHALEM] = "Intel Xeon 5500 series / Core i3/5/7 (\"Nehalem/Westmere\")",
 	[CPU_DUNNINGTON] = "Intel Xeon 7400 series",
@@ -274,6 +275,7 @@
 	{ "f10h", CPU_F10H },
 	{ "f11h", CPU_F11H },
 	{ "f12h", CPU_F12H },
+	{ "f14h", CPU_F14H },
 	{ "p4", CPU_P4 },
 	{ "dunnington", CPU_DUNNINGTON },
 	{ "xeon74xx", CPU_DUNNINGTON },
--- a/mcelog.h
+++ b/mcelog.h
@@ -122,6 +122,7 @@
 	CPU_F10H,
 	CPU_F11H,
 	CPU_F12H,
+	CPU_F14H,
 	CPU_P4,
 	CPU_NEHALEM,
 	CPU_DUNNINGTON,
