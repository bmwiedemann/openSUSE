Add F11h decoding support

Signed-off-by: Borislav Petkov <bp@suse.de>
---
 amd.c    |   21 +++++++++++++++++++++
 amd.h    |    3 ++-
 mcelog.c |    2 ++
 mcelog.h |    1 +
 4 files changed, 26 insertions(+), 1 deletion(-)

--- a/amd.c
+++ b/amd.c
@@ -155,6 +155,8 @@
 		return CPU_K8;
 	case 0x10:
 		return CPU_F10H;
+	case 0x11:
+		return CPU_F11H;
 	default:
 		break;
 	}
@@ -367,6 +369,16 @@
 	return f12h_mc0_mce(ec, xec);
 }
 
+static bool k8_mc0_mce(u16 ec, u8 xec)
+{
+	if (BUS_ERROR(ec)) {
+		Wprintf("during system linefill.\n");
+		return true;
+	}
+
+	return f10h_mc0_mce(ec, xec);
+}
+
 static void decode_mc0_mce(struct amd_decoder_ops *ops, struct mce *m)
 {
 	u16 ec = EC(m->status);
@@ -630,6 +642,12 @@
 		.mc1_mce = k8_mc1_mce,
 		.mc2_mce = k8_mc2_mce,
 	},
+	[AMD_F11H] = {
+		.cpu	 = AMD_F11H,
+		.mc0_mce = k8_mc0_mce,
+		.mc1_mce = k8_mc1_mce,
+		.mc2_mce = k8_mc2_mce,
+	},
 };
 
 static void __decode_amd_mc(enum cputype cpu, struct mce *mce)
@@ -640,6 +658,9 @@
 	case CPU_F10H:
 		ops = &fam_ops[AMD_F10H];
 		break;
+	case CPU_F11H:
+		ops = &fam_ops[AMD_F11H];
+		break;
 	default:
 		Eprintf("Huh? What family is it: 0x%x?!\n", cpu);
 		return;
--- a/amd.h
+++ b/amd.h
@@ -93,4 +93,5 @@
 
 #define CASE_AMD_CPUS \
 	case CPU_K8:  \
-	case CPU_F10H
+	case CPU_F10H: \
+	case CPU_F11H
--- a/mcelog.c
+++ b/mcelog.c
@@ -230,6 +230,7 @@
 	[CPU_CORE2] = "Intel Core", /* 65nm and 45nm */
 	[CPU_K8] = "AMD K8 and derivates",
 	[CPU_F10H] = "AMD Greyhound",
+	[CPU_F11H] = "AMD Griffin",
 	[CPU_P4] = "Intel P4",
 	[CPU_NEHALEM] = "Intel Xeon 5500 series / Core i3/5/7 (\"Nehalem/Westmere\")",
 	[CPU_DUNNINGTON] = "Intel Xeon 7400 series",
@@ -270,6 +271,7 @@
 	{ "core2", CPU_CORE2 },
 	{ "k8", CPU_K8 },
 	{ "f10h", CPU_F10H },
+	{ "f11h", CPU_F11H },
 	{ "p4", CPU_P4 },
 	{ "dunnington", CPU_DUNNINGTON },
 	{ "xeon74xx", CPU_DUNNINGTON },
--- a/mcelog.h
+++ b/mcelog.h
@@ -120,6 +120,7 @@
 	CPU_CORE2, /* 65nm and 45nm */
 	CPU_K8,
 	CPU_F10H,
+	CPU_F11H,
 	CPU_P4,
 	CPU_NEHALEM,
 	CPU_DUNNINGTON,
