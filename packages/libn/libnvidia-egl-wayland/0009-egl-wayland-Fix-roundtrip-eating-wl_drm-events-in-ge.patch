From c10c5300483a8ec975e64e5d76c0fb00ac94e026 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@badland.io>
Date: Thu, 19 Sep 2024 09:35:47 -0400
Subject: [PATCH 9/9] egl-wayland: Fix roundtrip eating wl_drm events in
 getServerProtocolsInfo

This resolves another issue where the wl_drm events sent by the
compositor are silently dropped by a roundtrip that happens before
the wl_drm listener is registered. This change immediately registers
wl_drm and triggers its roundtrip first. The dmabuf feedback can
then proceed, potentially replacing the wl_drm name if a valid device
was provided.
---
 src/wayland-egldisplay.c | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/src/wayland-egldisplay.c b/src/wayland-egldisplay.c
index 3921ede..7089271 100644
--- a/src/wayland-egldisplay.c
+++ b/src/wayland-egldisplay.c
@@ -634,6 +634,7 @@ registry_handle_global_check_protocols(
 
     if ((strcmp(interface, "wl_drm") == 0) && (version >= 2)) {
         protocols->wlDrm = wl_registry_bind(registry, name, &wl_drm_interface, 2);
+        wl_drm_add_listener(protocols->wlDrm, &drmListener, protocols);
     }
 }
 
@@ -817,11 +818,19 @@ static bool getServerProtocolsInfo(struct wl_display *nativeDpy,
                                    protocols);
     if (ret == 0) {
         wl_display_roundtrip_queue(nativeDpy, queue);
+        /* use a second roundtrip to handle any wl_drm events triggered by binding the protocol */
+        wl_display_roundtrip_queue(nativeDpy, queue);
+
         if (!getDeviceFromDevIdInitialised) {
             getDeviceFromDevId = dlsym(RTLD_DEFAULT, "drmGetDeviceFromDevId");
             getDeviceFromDevIdInitialised = true;
         }
 
+        /*
+         * if dmabuf feedback is available then use that. This will potentially
+         * replace the drm_name provided by wl_drm, assuming the feedback provides
+         * a valid dev_t.
+         */
         if (protocols->wlDmaBuf && getDeviceFromDevId) {
             struct zwp_linux_dmabuf_feedback_v1 *default_feedback
                     = zwp_linux_dmabuf_v1_get_default_feedback(protocols->wlDmaBuf);
@@ -832,12 +841,6 @@ static bool getServerProtocolsInfo(struct wl_display *nativeDpy,
             }
         }
 
-        /* If we didn't get a name through linux_dmabuf then fall back to wl_drm */
-        if (!protocols->drm_name && protocols->wlDrm) {
-            wl_drm_add_listener(protocols->wlDrm, &drmListener, protocols);
-            wl_display_roundtrip_queue(nativeDpy, queue);
-        }
-
         /* Check that one of our two protocols provided the device name */
         result = protocols->drm_name != NULL;
 
-- 
2.43.0

