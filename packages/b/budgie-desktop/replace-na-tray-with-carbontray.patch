From 92c655f53112c3a7766c72c8817836ddee57c5ce Mon Sep 17 00:00:00 2001
From: Campbell Jones <git@serebit.com>
Date: Thu, 2 Jul 2020 18:11:24 -0400
Subject: [PATCH] Replace na-tray with carbontray

---
 src/applets/tray/TrayApplet.vala              | 208 ++--
 .../tray/carbontray/carbontray-1.0.vapi       |  18 +
 src/applets/tray/carbontray/child.c           | 163 +++
 src/applets/tray/carbontray/child.h           |  39 +
 src/applets/tray/carbontray/marshal.list      |   1 +
 src/applets/tray/carbontray/meson.build       |  27 +
 src/applets/tray/carbontray/tray.c            | 421 ++++++++
 src/applets/tray/carbontray/tray.h            |  72 ++
 .../tray/com.solus-project.tray.gschema.xml   |  10 +
 src/applets/tray/meson.build                  |  28 +-
 src/applets/tray/plugin.gresource.xml         |   6 +
 src/applets/tray/settings.ui                  |  42 +
 src/imports/meson.build                       |   1 -
 src/imports/natray/fixedtip.c                 | 289 ------
 src/imports/natray/fixedtip.h                 |  66 --
 src/imports/natray/meson.build                |  32 -
 src/imports/natray/na-tray-child.c            | 528 ----------
 src/imports/natray/na-tray-child.h            |  69 --
 src/imports/natray/na-tray-manager.c          | 981 ------------------
 src/imports/natray/na-tray-manager.h          | 112 --
 src/imports/natray/na-tray.c                  | 676 ------------
 src/imports/natray/na-tray.h                  |  49 -
 src/imports/natray/natray-1.0.vapi            |  17 -
 src/meson.build                               |   1 -
 25 files changed, 890 insertions(+), 2968 deletions(-)
 create mode 100644 src/applets/tray/carbontray/carbontray-1.0.vapi
 create mode 100644 src/applets/tray/carbontray/child.c
 create mode 100644 src/applets/tray/carbontray/child.h
 create mode 100644 src/applets/tray/carbontray/marshal.list
 create mode 100644 src/applets/tray/carbontray/meson.build
 create mode 100644 src/applets/tray/carbontray/tray.c
 create mode 100644 src/applets/tray/carbontray/tray.h
 create mode 100644 src/applets/tray/com.solus-project.tray.gschema.xml
 create mode 100644 src/applets/tray/plugin.gresource.xml
 create mode 100644 src/applets/tray/settings.ui
 delete mode 100644 src/imports/meson.build
 delete mode 100644 src/imports/natray/fixedtip.c
 delete mode 100644 src/imports/natray/fixedtip.h
 delete mode 100644 src/imports/natray/meson.build
 delete mode 100644 src/imports/natray/na-tray-child.c
 delete mode 100644 src/imports/natray/na-tray-child.h
 delete mode 100644 src/imports/natray/na-tray-manager.c
 delete mode 100644 src/imports/natray/na-tray-manager.h
 delete mode 100644 src/imports/natray/na-tray.c
 delete mode 100644 src/imports/natray/na-tray.h
 delete mode 100644 src/imports/natray/natray-1.0.vapi

diff --git a/src/applets/tray/TrayApplet.vala b/src/applets/tray/TrayApplet.vala
index 8edd75ff..62a92fd7 100644
--- a/src/applets/tray/TrayApplet.vala
+++ b/src/applets/tray/TrayApplet.vala
@@ -9,195 +9,123 @@
  * (at your option) any later version.
  */
 
-public class TrayPlugin : Budgie.Plugin, Peas.ExtensionBase
-{
-    public Budgie.Applet get_panel_widget(string uuid)
-    {
-        return new TrayApplet();
+public class TrayPlugin : Budgie.Plugin, Peas.ExtensionBase {
+    public Budgie.Applet get_panel_widget(string uuid) {
+        return new TrayApplet(uuid);
     }
 }
 
-public class TrayApplet : Budgie.Applet
-{
-    protected Na.Tray? tray = null;
-    /* Fix this. Please. */
-    protected int icon_size = 22;
-    Gtk.EventBox box;
+[GtkTemplate (ui = "/com/solus-project/tray/settings.ui")]
+public class TraySettings : Gtk.Grid {
+    Settings? settings = null;
+
+    [GtkChild]
+    private Gtk.SpinButton? spinbutton_spacing;
+
+    public TraySettings(Settings? settings) {
+        this.settings = settings;
+        settings.bind("spacing", spinbutton_spacing, "value", SettingsBindFlags.DEFAULT);
+    }
+}
 
-    int width;
-    int height;
+public class TrayApplet : Budgie.Applet {
+    public string uuid { public set; public get; }
+    private Carbon.Tray tray;
+    private Gtk.EventBox box;
+    private Settings? settings;
+    private Gtk.Orientation orient;
 
-    Gtk.Orientation orient = Gtk.Orientation.HORIZONTAL;
+    public TrayApplet(string uuid) {
+        Object(uuid: uuid);
 
-    public TrayApplet()
-    {
         box = new Gtk.EventBox();
         add(box);
 
-        valign = Gtk.Align.CENTER;
-        box.valign = Gtk.Align.CENTER;
-        box.vexpand = false;
+        hexpand = false;
         vexpand = false;
+        box.vexpand = false;
+        box.hexpand = false;
 
-        show_all();
-        Timeout.add_seconds(1,()=> {
-            maybe_integrate_tray();
-            return false;
-        });
-
-        panel_size_changed.connect((p,i,s)=> {
-            this.icon_size = s;
-            if (tray != null) {
-                tray.set_icon_size(icon_size);
-                queue_resize();
-                tray.queue_resize();
-            }
-        });
-
-        size_allocate.connect(on_size_allocate);
-    }
-
-    public override void panel_position_changed(Budgie.PanelPosition position)
-    {
-        if (position == Budgie.PanelPosition.LEFT || position == Budgie.PanelPosition.RIGHT) {
-            this.orient = Gtk.Orientation.VERTICAL;
-        } else {
-            this.orient = Gtk.Orientation.HORIZONTAL;
-        }
+        settings_schema = "com.solus-project.tray";
+        settings_prefix = "/com/solus-project/budgie-panel/instance/tray";
 
-        if (tray == null) {
-            return;
-        }
+        settings = get_applet_settings(uuid);
+        settings.changed.connect(on_settings_change);
 
-        this.box.remove(this.tray);
-        this.tray = null;
-        this.maybe_integrate_tray();
-        this.show_all();
+        maybe_integrate_tray();
     }
 
-    void on_size_allocate(Gtk.Allocation alloc)
-    {
-        if (!get_realized() || get_parent() == null) {
-            return;
-        }
-        if (this.width != alloc.width || this.height != alloc.height) {
-            this.width = alloc.width;
-            this.height = alloc.height;
-            this.get_parent().queue_resize();
-            this.get_toplevel().queue_resize();
-            this.get_parent().queue_draw();
-            this.get_toplevel().queue_draw();
-        }
+    public override bool supports_settings() {
+        return true;
     }
 
+    public override Gtk.Widget? get_settings_ui() {
+        return new TraySettings(get_applet_settings(uuid));
+    }
 
-    public override void get_preferred_height(out int m, out int n)
-    {
-        if (this.orient == Gtk.Orientation.HORIZONTAL) {
-            m = icon_size;
-            n = icon_size;
+    void on_settings_change(string key) {
+        if (key != "spacing") {
             return;
         }
-        int om, on;
-        base.get_preferred_height(out om, out on);
-        m = om;
-        n = on;
+        tray.set_spacing(settings.get_int(key));
     }
 
-    public override void get_preferred_height_for_width(int w, out int m, out int n)
-    {
-        if (this.orient == Gtk.Orientation.HORIZONTAL) {
-            m = icon_size;
-            n = icon_size;
-            return;
+    public override void panel_position_changed(Budgie.PanelPosition position) {
+        if (position == Budgie.PanelPosition.LEFT || position == Budgie.PanelPosition.RIGHT) {
+            orient = Gtk.Orientation.VERTICAL;
+        } else {
+            orient = Gtk.Orientation.HORIZONTAL;
         }
-        int om, on;
-        base.get_preferred_height_for_width(w, out om, out on);
-        m = om;
-        n = on;
-    }
 
-    public override void get_preferred_width(out int m, out int n)
-    {
-        if (this.orient == Gtk.Orientation.VERTICAL) {
-            m = icon_size;
-            n = icon_size;
+        if (tray == null) {
             return;
         }
-        int om, on;
-        base.get_preferred_width(out om, out on);
-        m = om;
-        n = on;
+
+        tray.unregister();
+        tray.remove_from_container(box);
+        tray = null;
+        maybe_integrate_tray();
     }
 
-    public override void get_preferred_width_for_height(int h, out int m, out int n)
-    {
-        if (this.orient == Gtk.Orientation.VERTICAL) {
-            m = icon_size;
-            n = icon_size;
+    protected void maybe_integrate_tray() {
+        if (tray != null) {
             return;
         }
-        int om, on;
-        base.get_preferred_width_for_height(h, out om, out on);
-        m = om;
-        n = on;
-    }
 
-    protected void maybe_integrate_tray()
-    {
-        if (tray != null) {
+        tray = new Carbon.Tray(orient, 24, settings.get_int("spacing"));
+
+        if (tray == null) {
+            var label = new Gtk.Label("Tray unavailable");
+            box.add(label);
+            label.show_all();
             return;
         }
 
-        switch (this.orient) {
+        switch (orient) {
         case Gtk.Orientation.HORIZONTAL:
-            valign = Gtk.Align.CENTER;
-            box.valign = Gtk.Align.CENTER;
-            box.halign = Gtk.Align.START;
             halign = Gtk.Align.START;
-            box.vexpand = false;
-            vexpand = false;
+            valign = Gtk.Align.FILL;
+            box.halign = Gtk.Align.START;
+            box.valign = Gtk.Align.FILL;
             break;
         case Gtk.Orientation.VERTICAL:
+            halign = Gtk.Align.FILL;
             valign = Gtk.Align.START;
+            box.halign = Gtk.Align.FILL;
             box.valign = Gtk.Align.START;
-            box.halign = Gtk.Align.CENTER;
-            halign = Gtk.Align.CENTER;
-            box.vexpand = false;
-            vexpand = false;
             break;
         }
 
-        tray = new Na.Tray.for_screen(this.orient);
-        if (tray == null) {
-            var label = new Gtk.Label("Tray unavailable");
-            add(label);
-            label.show_all();
-            return;
-        }
-        tray.set_icon_size(icon_size);
-        tray.set_size_request(-1, -1);
-
-        Gdk.RGBA fg = {};
-        Gdk.RGBA warning = {};
-        Gdk.RGBA error = {};
-        Gdk.RGBA success = {};
-
-        fg.parse("white");
-        warning.parse("red");
-        error.parse("orange");
-        success.parse("white");
-
-        tray.set_colors(fg, error, warning, success);
-        box.add(tray);
+        tray.add_to_container(box);
         show_all();
+        tray.register((Gdk.X11.Screen) get_screen());
 
-        var win = this.get_toplevel();
+        var win = get_toplevel();
         if (win == null) {
             return;
         }
         win.queue_draw();
-        this.queue_resize();
+        queue_resize();
     }
 }
 
diff --git a/src/applets/tray/carbontray/carbontray-1.0.vapi b/src/applets/tray/carbontray/carbontray-1.0.vapi
new file mode 100644
index 00000000..cb1ce28b
--- /dev/null
+++ b/src/applets/tray/carbontray/carbontray-1.0.vapi
@@ -0,0 +1,18 @@
+namespace Carbon {
+    [Compact]
+    [CCode (cheader_filename = "tray.h")]
+	public class Tray : GLib.Object {
+        [CCode (has_construct_function = false, type = "GtkWidget*")]
+        public Tray(Gtk.Orientation orientation, int iconSize, int spacing);
+
+        public void add_to_container(Gtk.Container container);
+
+        public void remove_from_container(Gtk.Container container);
+        
+        public bool register(Gdk.X11.Screen screen);
+
+        public void unregister();
+
+        public void set_spacing(int spacing);
+    }
+}
diff --git a/src/applets/tray/carbontray/child.c b/src/applets/tray/carbontray/child.c
new file mode 100644
index 00000000..eb7fa832
--- /dev/null
+++ b/src/applets/tray/carbontray/child.c
@@ -0,0 +1,163 @@
+#include "child.h"
+#include "tray.h"
+
+// static method header
+
+static void carbon_child_init(CarbonChild*);
+static void carbon_child_realize(GtkWidget*);
+static void carbon_child_get_preferred_width(GtkWidget*, int*, int*);
+static void carbon_child_get_preferred_height(GtkWidget*, int*, int*);
+static void set_wmclass(CarbonChild*, Display*);
+
+
+
+// define our type with the macro
+
+G_DEFINE_TYPE(CarbonChild, carbon_child, GTK_TYPE_SOCKET)
+
+
+
+// public method implementations
+
+CarbonChild* carbon_child_new(int size, GdkScreen *screen, Window iconWindow) {
+    CarbonChild *self = g_object_new(carbon_child_get_type(), NULL);
+    self->preferredWidth = size;
+	self->preferredHeight = size;
+
+	if (GDK_IS_SCREEN(screen) == FALSE)
+		return NULL;
+
+	GdkDisplay *display = gdk_screen_get_display(screen);
+	gdk_x11_display_error_trap_push(display);
+	XWindowAttributes attributes;
+	int result = XGetWindowAttributes(GDK_DISPLAY_XDISPLAY(display), iconWindow, &attributes);
+
+	if (gdk_x11_display_error_trap_pop(display) != 0 || result == 0)
+		return NULL;
+
+	GdkVisual *visual = gdk_x11_screen_lookup_visual(screen, attributes.visual->visualid);
+	if (visual == NULL || GDK_IS_VISUAL(visual) == FALSE) {
+		return NULL;
+	}
+
+	self->iconWindow = iconWindow;
+	self->isComposited = FALSE;
+	gtk_widget_set_visual(GTK_WIDGET(self), visual);
+
+	/* check if there is an alpha channel in the visual */
+	int red_prec, green_prec, blue_prec;
+	gdk_visual_get_red_pixel_details(visual, NULL, NULL, &red_prec);
+	gdk_visual_get_green_pixel_details(visual, NULL, NULL, &green_prec);
+	gdk_visual_get_blue_pixel_details(visual, NULL, NULL, &blue_prec);
+	
+	bool supportsComposite = gdk_display_supports_composite(gdk_screen_get_display(screen));
+	if (red_prec + blue_prec + green_prec < gdk_visual_get_depth(visual) && supportsComposite)
+		self->isComposited = TRUE;
+
+	self->wmclass = NULL;
+	set_wmclass(self, GDK_DISPLAY_XDISPLAY(display));
+
+  	return self;
+}
+
+void carbon_child_draw_on_tray(CarbonChild *self, GtkWidget *parent, cairo_t *cr) {
+	g_return_if_fail(self != NULL);
+	g_return_if_fail(parent != NULL);
+	g_return_if_fail(cr != NULL);
+
+    GtkAllocation allocation = {0};
+	gtk_widget_get_allocation(GTK_WIDGET(self), &allocation);
+
+	if (!gtk_widget_get_has_window(GTK_WIDGET(parent))) {
+		GtkAllocation parentAllocation = {0};
+		gtk_widget_get_allocation(GTK_WIDGET(parent), &parentAllocation);
+
+		allocation.x = allocation.x - parentAllocation.x;
+		allocation.y = allocation.y - parentAllocation.y;
+	}
+	cairo_save(cr);
+	GdkWindow *window = gtk_widget_get_window(GTK_WIDGET(self));
+	gdk_cairo_set_source_window(cr, window, allocation.x, allocation.y);
+	cairo_rectangle(cr, allocation.x, allocation.y, allocation.width, allocation.height);
+	cairo_clip(cr);
+	cairo_paint(cr);
+	cairo_restore(cr);
+}
+
+
+
+// static method implementations
+
+static void carbon_child_init(CarbonChild *self) {
+    GtkWidget *widget = GTK_WIDGET(self);
+
+	gtk_widget_set_halign(widget, GTK_ALIGN_CENTER);
+	gtk_widget_set_valign(widget, GTK_ALIGN_CENTER);
+	gtk_widget_set_hexpand(widget, FALSE);
+	gtk_widget_set_vexpand(widget, FALSE);
+}
+
+static void carbon_child_realize(GtkWidget *widget) {
+	CarbonChild *self = CARBON_CHILD(widget);
+	GdkRGBA transparent = { 0.0, 0.0, 0.0, 0.0 };
+	GdkWindow *window;
+
+	gtk_widget_set_size_request(widget, self->preferredWidth, self->preferredHeight);
+
+	GTK_WIDGET_CLASS(carbon_child_parent_class)->realize(widget);
+
+	window = gtk_widget_get_window(widget);
+
+	if (self->isComposited) {
+		gdk_window_set_background_rgba(window, &transparent);
+		gdk_window_set_composited(window, TRUE);
+	} else if (gtk_widget_get_visual(widget) == gdk_window_get_visual(gdk_window_get_parent(window))) {
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+		gdk_window_set_background_pattern(window, NULL);
+		G_GNUC_END_IGNORE_DEPRECATIONS
+	} else {
+		self->parentRelativeBg = FALSE;
+	}
+
+	gdk_window_set_composited(window, self->isComposited);
+	gtk_widget_set_app_paintable(widget, self->parentRelativeBg || self->isComposited);
+	gtk_widget_set_double_buffered(widget, self->parentRelativeBg);
+}
+
+static void carbon_child_get_preferred_width(GtkWidget *base, int *minimum_width, int *natural_width) {
+	CarbonChild *self =(CarbonChild*) base;
+    int scale = gtk_widget_get_scale_factor(base);
+	
+    *minimum_width = self->preferredWidth / scale;
+    *natural_width = self->preferredWidth / scale;
+}
+
+static void carbon_child_get_preferred_height(GtkWidget *base, int *minimum_height, int *natural_height) {
+	CarbonChild *self =(CarbonChild*) base;
+    int scale = gtk_widget_get_scale_factor(base);
+	
+    *minimum_height = self->preferredHeight / scale;
+    *natural_height = self->preferredHeight / scale;
+}
+
+static void carbon_child_class_init(CarbonChildClass *klass) {
+    GtkWidgetClass *gtkwidget_class = GTK_WIDGET_CLASS(klass);
+
+	gtkwidget_class->get_preferred_width =(void(*)(GtkWidget*, int*, int*)) carbon_child_get_preferred_width;
+	gtkwidget_class->get_preferred_height =(void(*)(GtkWidget*, int*, int*)) carbon_child_get_preferred_height;
+    gtkwidget_class->realize =(void(*)(GtkWidget*)) carbon_child_realize;
+}
+
+static void set_wmclass(CarbonChild *self, Display *xdisplay) {
+	XClassHint ch;
+	ch.res_class = NULL;
+
+	GdkDisplay *display = gdk_display_get_default();
+	gdk_x11_display_error_trap_push(display);
+	XGetClassHint(xdisplay, self->iconWindow, &ch);
+	gdk_x11_display_error_trap_pop_ignored(display);
+
+	if (ch.res_class) {
+		self->wmclass = ch.res_class;
+	}
+}
diff --git a/src/applets/tray/carbontray/child.h b/src/applets/tray/carbontray/child.h
new file mode 100644
index 00000000..7f52a830
--- /dev/null
+++ b/src/applets/tray/carbontray/child.h
@@ -0,0 +1,39 @@
+#ifndef __CARBONTRAY_CHILD_H__
+#define __CARBONTRAY_CHILD_H__
+
+#include <gtk/gtk.h>
+#include <gtk/gtkx.h>
+#include <stdbool.h>
+
+typedef struct _CarbonChild {
+	GtkSocket parent;
+
+	int preferredWidth;
+	int preferredHeight;
+	Window iconWindow;
+
+	char *wmclass;
+
+	bool parentRelativeBg;
+	bool isComposited;
+} CarbonChild;
+
+typedef struct _CarbonChildClass {
+	GtkSocketClass parent_class;
+} CarbonChildClass;
+
+
+
+#define CARBON_TYPE_CHILD (carbon_child_get_type())
+#define CARBON_CHILD(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), CARBON_TYPE_CHILD, CarbonChild))
+#define CARBON_IS_CHILD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CARBON_TYPE_CHILD))
+
+
+
+GType carbon_child_get_type(void);
+
+CarbonChild* carbon_child_new(int, GdkScreen*, Window);
+
+void carbon_child_draw_on_tray(CarbonChild*, GtkWidget*, cairo_t*);
+
+#endif
diff --git a/src/applets/tray/carbontray/marshal.list b/src/applets/tray/carbontray/marshal.list
new file mode 100644
index 00000000..8355c4eb
--- /dev/null
+++ b/src/applets/tray/carbontray/marshal.list
@@ -0,0 +1 @@
+VOID:OBJECT,STRING,LONG,LONG
diff --git a/src/applets/tray/carbontray/meson.build b/src/applets/tray/carbontray/meson.build
new file mode 100644
index 00000000..885f473f
--- /dev/null
+++ b/src/applets/tray/carbontray/meson.build
@@ -0,0 +1,27 @@
+libcarbontray_deps = [
+    dep_gtk3,
+    dependency('gtk+-x11-3.0'),
+    dependency('x11'),
+]
+
+libcarbontray_sources = [
+    'tray.c',
+    'child.c'
+]
+
+libcarbontray_marshal_files = gnome.genmarshal('marshal', sources: 'marshal.list')
+
+libcarbontray = static_library(
+    'carbontray',
+    libcarbontray_sources + libcarbontray_marshal_files,
+    dependencies: libcarbontray_deps,
+    include_directories: [
+        include_directories('.'),
+        include_directories(join_paths('..', '..', '..')),
+    ],
+)
+
+link_libcarbontray = declare_dependency(
+    link_with: libcarbontray,
+    include_directories: include_directories('.'),
+)
diff --git a/src/applets/tray/carbontray/tray.c b/src/applets/tray/carbontray/tray.c
new file mode 100644
index 00000000..732f8c2f
--- /dev/null
+++ b/src/applets/tray/carbontray/tray.c
@@ -0,0 +1,421 @@
+#include "tray.h"
+#include "child.h"
+#include "marshal.h"
+
+/*
+  this file's contents largely use xfce4-panel as a reference, which is licensed under the terms of the GNU GPL v2
+  
+  additional notes were taken from na-tray, the previous system tray for Budgie, which is part of MATE Desktop 
+  and licensed under the terms of the GNU GPL v2
+*/
+
+
+
+// global declarations
+
+#define TRAY_REQUEST_DOCK   0
+#define TRAY_BEGIN_MESSAGE  1
+#define TRAY_CANCEL_MESSAGE 2
+
+static unsigned int message_sent_signal;
+
+
+
+// static method header
+
+static void carbon_tray_init(CarbonTray*);
+static void carbon_tray_class_init(CarbonTrayClass*);
+static void carbon_tray_finalize(GObject*);
+static int carbon_tray_draw(GtkWidget*, cairo_t*);
+
+static GdkFilterReturn window_filter(GdkXEvent*, GdkEvent*, void*);
+static void handle_message_data(CarbonTray*, XClientMessageEvent*);
+static void handle_message_begin(CarbonTray*, XClientMessageEvent*);
+static void handle_message_cancel(CarbonTray*, XClientMessageEvent*);
+static void handle_dock_request(CarbonTray*, XClientMessageEvent*);
+static bool handle_undock_request(GtkSocket*, void*);
+
+static void remove_message(CarbonTray*, XClientMessageEvent*);
+static void free_message(CarbonMessage*);
+static void set_xproperties(CarbonTray*);
+static void draw_child(GtkWidget*, void*);
+
+
+
+// define our type with the macro
+
+G_DEFINE_TYPE(CarbonTray, carbon_tray, G_TYPE_OBJECT)
+
+
+
+// public methods
+
+CarbonTray* carbon_tray_new(GtkOrientation orientation, int iconSize, int spacing) {
+	CarbonTray *self = g_object_new(CARBON_TYPE_TRAY, NULL);
+	self->box = GTK_BOX(gtk_box_new(orientation, spacing));
+	GtkWidget *boxWidget = GTK_WIDGET(self->box);
+
+	self->iconSize = iconSize;
+
+	if (orientation == GTK_ORIENTATION_HORIZONTAL) {
+		gtk_widget_set_halign(boxWidget, GTK_ALIGN_START);
+		gtk_widget_set_valign(boxWidget, GTK_ALIGN_FILL);
+	} else {
+		gtk_widget_set_halign(boxWidget, GTK_ALIGN_FILL);
+		gtk_widget_set_valign(boxWidget, GTK_ALIGN_START);
+	}
+
+	gtk_widget_set_hexpand(boxWidget, FALSE);
+	gtk_widget_set_vexpand(boxWidget, FALSE);
+	gtk_widget_set_size_request(boxWidget, -1, -1);
+
+	return self;
+}
+
+void carbon_tray_add_to_container(CarbonTray *tray, GtkContainer *container) {
+	gtk_container_add(container, GTK_WIDGET(tray->box));
+}
+
+void carbon_tray_remove_from_container(CarbonTray *tray, GtkContainer *container) {
+	gtk_container_remove(container, GTK_WIDGET(tray->box));
+}
+
+bool carbon_tray_register(CarbonTray *tray, GdkScreen *screen) {
+	g_signal_connect(tray->box, "draw", G_CALLBACK(carbon_tray_draw), NULL);
+
+	GtkWidget *invisible = gtk_invisible_new_for_screen(screen);
+	gtk_widget_realize(invisible);
+	gtk_widget_add_events(invisible, GDK_PROPERTY_CHANGE_MASK | GDK_STRUCTURE_MASK);
+
+	int screen_number = gdk_screen_get_number(screen);
+	char *selection_name = g_strdup_printf("_NET_SYSTEM_TRAY_S%d", screen_number);
+	tray->selectionAtom = gdk_atom_intern(selection_name, FALSE);
+	g_free(selection_name);
+
+	GdkDisplay *display = gdk_screen_get_display(screen);
+
+	tray->invisible = GTK_WIDGET(g_object_ref(G_OBJECT(invisible)));
+	set_xproperties(tray);
+
+	unsigned int timestamp = gdk_x11_get_server_time(gtk_widget_get_window(invisible));
+
+	bool succeed = gdk_selection_owner_set_for_display(display, gtk_widget_get_window(invisible), tray->selectionAtom, timestamp, TRUE);
+
+	if (succeed) {
+		Window root_window = RootWindowOfScreen(GDK_SCREEN_XSCREEN(screen));
+
+		XClientMessageEvent xevent;
+
+		/* send a message to x11 that we're going to handle this display */
+		xevent.type = ClientMessage;
+		xevent.window = root_window;
+		xevent.message_type = gdk_x11_get_xatom_by_name_for_display(display, "MANAGER");
+		xevent.format = 32;
+		xevent.data.l[0] = timestamp;
+		xevent.data.l[1] = (long) gdk_x11_atom_to_xatom_for_display(display, tray->selectionAtom);
+		xevent.data.l[2] = (long) GDK_WINDOW_XID(gtk_widget_get_window(GTK_WIDGET(invisible)));
+		xevent.data.l[3] = 0;
+		xevent.data.l[4] = 0;
+
+		XSendEvent(GDK_DISPLAY_XDISPLAY(display), root_window, False, StructureNotifyMask,(XEvent*) &xevent);
+
+		gdk_window_add_filter(gtk_widget_get_window(invisible), window_filter, tray);
+
+		GdkAtom opcode_atom = gdk_atom_intern("_NET_SYSTEM_TRAY_OPCODE", FALSE);
+		tray->opcodeAtom = gdk_x11_atom_to_xatom_for_display(display, opcode_atom);
+
+		GdkAtom data_atom = gdk_atom_intern("_NET_SYSTEM_TRAY_MESSAGE_DATA", FALSE);
+		tray->dataAtom = gdk_x11_atom_to_xatom_for_display(display, data_atom);
+	} else {
+	  	g_object_unref(G_OBJECT(tray->invisible));
+	  	tray->invisible = NULL;
+		gtk_widget_destroy(invisible);
+	}
+
+  	return succeed;
+}
+
+void carbon_tray_unregister(CarbonTray *tray) {
+	GtkWidget *invisible = tray->invisible;
+	GdkDisplay *display = gtk_widget_get_display(invisible);
+	GdkWindow *owner = gdk_selection_owner_get_for_display(display, tray->selectionAtom);
+
+	if (owner == gtk_widget_get_window(invisible)) {
+      	gdk_selection_owner_set_for_display(display, NULL, tray->selectionAtom, gdk_x11_get_server_time(gtk_widget_get_window(invisible)), TRUE);
+    }
+
+	gdk_window_remove_filter(gtk_widget_get_window(invisible), window_filter, tray);
+
+	tray->invisible = NULL;
+	gtk_widget_destroy(invisible);
+	g_object_unref(G_OBJECT(invisible));
+}
+
+void carbon_tray_set_spacing(CarbonTray *tray, int spacing) {
+	gtk_box_set_spacing(tray->box, spacing);
+}
+
+
+
+// static methods
+
+static void carbon_tray_init(CarbonTray* self) {
+	self->socketTable = g_hash_table_new(NULL, NULL);
+	self->invisible = NULL;
+
+	self->selectionAtom = NULL;
+	self->opcodeAtom = 0;
+	self->dataAtom = 0;
+	self->messages = NULL;
+}
+
+static void carbon_tray_class_init(CarbonTrayClass *klass) {
+	GObjectClass *gobjectClass = G_OBJECT_CLASS(klass);
+	gobjectClass->finalize = carbon_tray_finalize;
+
+	g_signal_new("message-sent", G_OBJECT_CLASS_TYPE (klass), G_SIGNAL_RUN_LAST,
+		  G_STRUCT_OFFSET (CarbonTrayClass, message_sent), NULL, NULL,
+		  g_cclosure_user_marshal_VOID__OBJECT_STRING_LONG_LONG,
+		  G_TYPE_NONE, 4,
+		  GTK_TYPE_SOCKET,
+		  G_TYPE_STRING,
+		  G_TYPE_LONG,
+		  G_TYPE_LONG);
+}
+
+static void carbon_tray_finalize(GObject *object) {
+	CarbonTray *tray = CARBON_TRAY(object);
+
+	g_hash_table_destroy(tray->socketTable);
+
+	if (tray->messages) {
+		g_slist_foreach(tray->messages,(GFunc)(void(*)(void)) free_message, NULL);
+		g_slist_free(tray->messages);
+	}
+
+	G_OBJECT_CLASS(carbon_tray_parent_class)->finalize(object);
+}
+
+static int carbon_tray_draw(GtkWidget *widget, cairo_t *cr) {
+	CarbonDrawData data;
+	data.box = widget;
+	data.cr = cr;
+	
+	gtk_container_foreach(GTK_CONTAINER(widget), draw_child, &data);
+
+	return TRUE;
+}
+
+static GdkFilterReturn window_filter(GdkXEvent *xev, GdkEvent *event, void *userData) {
+	// event goes unused
+	(void) event;
+
+	XEvent *xevent =(XEvent*) xev;
+	CarbonTray *tray =(CarbonTray*) userData;
+
+	if (xevent->type == ClientMessage) {
+		XClientMessageEvent *xclient =(XClientMessageEvent*) xevent;
+
+		if (xclient->message_type == tray->opcodeAtom) {
+			switch(xclient->data.l[1]) {
+				case TRAY_REQUEST_DOCK:
+					handle_dock_request(tray, xclient);
+					return GDK_FILTER_REMOVE;
+				case TRAY_BEGIN_MESSAGE:
+					handle_message_begin(tray, xclient);
+					return GDK_FILTER_REMOVE;
+				case TRAY_CANCEL_MESSAGE:
+					handle_message_cancel(tray, xclient);
+					return GDK_FILTER_REMOVE;
+			}
+		} else if (xclient->message_type == tray->dataAtom) {
+			handle_message_data(tray, xclient);
+			return GDK_FILTER_REMOVE;
+		}
+	} else if (xevent->type == SelectionClear) {
+		carbon_tray_unregister(tray);
+	}
+
+	return GDK_FILTER_CONTINUE;
+}
+
+static void handle_dock_request(CarbonTray *tray, XClientMessageEvent *xevent) {
+	Window window =(unsigned long) xevent->data.l[2];
+
+	/* check if we already have this window */
+	if (g_hash_table_lookup(tray->socketTable, GUINT_TO_POINTER(window)) != NULL) {
+		handle_undock_request(g_hash_table_lookup(tray->socketTable, GUINT_TO_POINTER(window)), tray);
+	}
+
+	/* create the socket */
+	GdkScreen *screen = gtk_widget_get_screen(tray->invisible);
+	CarbonChild *child = carbon_child_new(tray->iconSize, screen, window);
+	GtkWidget *socket = GTK_WIDGET(child);
+	if (socket == NULL)
+		return;
+
+	// networkmanager applet should be packed at the end
+	if (strcmp(child->wmclass, "Nm-applet") == 0) {
+		gtk_box_pack_end(GTK_BOX(tray->box), socket, FALSE, FALSE, 0);
+	} else {
+		gtk_box_pack_start(GTK_BOX(tray->box), socket, FALSE, FALSE, 0);
+		gtk_box_reorder_child(GTK_BOX(tray->box), socket, 0);
+	}
+	
+	if (GTK_IS_WINDOW(gtk_widget_get_toplevel(socket))) {
+		g_signal_connect(G_OBJECT(socket), "plug-removed", G_CALLBACK(handle_undock_request), tray);
+		gtk_socket_add_id(GTK_SOCKET(socket), window);
+		g_hash_table_insert(tray->socketTable, GUINT_TO_POINTER(window), socket);
+		gtk_widget_show_all(GTK_WIDGET(socket));
+	} else {
+		g_warning("No parent window set, destroying socket");
+		gtk_container_remove(GTK_CONTAINER(tray->box), GTK_WIDGET(socket));
+		gtk_widget_destroy(socket);
+	}
+
+	// if embedding failed, just destroy the socket
+	if (!gtk_socket_get_plug_window(GTK_SOCKET(socket))) {
+		handle_undock_request(GTK_SOCKET(socket), tray);
+	}
+}
+
+static bool handle_undock_request(GtkSocket *socket, void *userData) {
+	CarbonTray *tray = CARBON_TRAY(userData);
+	Window window = CARBON_CHILD(socket)->iconWindow;
+
+	gtk_container_remove(GTK_CONTAINER(tray->box), GTK_WIDGET(socket));
+	g_hash_table_remove(tray->socketTable, GUINT_TO_POINTER(window));
+
+	// destroys the socket
+	return FALSE;
+}
+
+static void handle_message_begin(CarbonTray *tray, XClientMessageEvent *xevent) {
+	GtkSocket *socket = g_hash_table_lookup(tray->socketTable, GUINT_TO_POINTER(xevent->window));
+	if (socket == NULL)
+		return;
+
+	remove_message(tray, xevent);
+
+	long timeout = xevent->data.l[2];
+	long length = xevent->data.l[3];
+	long id = xevent->data.l[4];
+
+	if (length == 0) {
+		g_signal_emit(tray, message_sent_signal, 0, socket, "", id, timeout);
+	} else {
+		CarbonMessage *message = &(CarbonMessage) {
+			.window = xevent->window,
+			.timeout = timeout,
+			.length = length,
+			.id = id,
+			.remainingLength = length,
+			.string = g_malloc((unsigned long) length + 1)
+		};
+		message->string[length] = '\0'; // always remember to null terminate
+
+		tray->messages = g_slist_prepend(tray->messages, message);
+	}
+}
+
+static void handle_message_data(CarbonTray *tray, XClientMessageEvent *xevent) {
+	CarbonMessage *message;
+	GSList *it;
+
+	for(it = tray->messages; it != NULL; it = it->next) {
+		message = it -> data;
+
+		if (xevent->window == message->window) {
+			long length = MIN(message->remainingLength, 20);
+			memcpy((message->string + message->length - message->remainingLength), &xevent->data,(unsigned long) length);
+			message->remainingLength -= length;
+
+			if (message->remainingLength == 0) {
+				GtkSocket *socket = g_hash_table_lookup(tray->socketTable, GUINT_TO_POINTER(message->window));
+
+				if (socket != NULL) {
+					g_signal_emit(tray, message_sent_signal, 0, socket, message->string, message->id, message->timeout);
+				}
+
+				tray->messages = g_slist_delete_link(tray->messages, it);
+				free_message(message);
+			}
+		}
+	}
+}
+
+static void handle_message_cancel(CarbonTray *tray, XClientMessageEvent *xevent) {
+	remove_message(tray, xevent);
+}
+
+static void remove_message(CarbonTray *tray, XClientMessageEvent *xevent) {
+	CarbonMessage *message;
+	GSList *it;
+	for(it = tray->messages; it != NULL; it = it->next) {
+		message = it->data;
+
+		if (xevent->window == message->window && xevent->data.l[4] == message->id) {
+			tray->messages = g_slist_delete_link(tray->messages, it);
+			free_message(message);
+			break;
+		}
+	}
+}
+
+static void free_message(CarbonMessage *message) {
+	g_free(message->string);
+	g_slice_free(CarbonMessage, message);
+}
+
+static void set_xproperties(CarbonTray *tray) {
+	GdkDisplay *display = gtk_widget_get_display(tray->invisible);
+	GdkScreen *screen = gtk_invisible_get_screen(GTK_INVISIBLE(tray->invisible));	
+
+	// set the visual
+
+	GdkVisual *visual = gdk_screen_get_rgba_visual(screen);
+
+	Visual *xvisual;
+	if (visual != NULL) {
+		xvisual = GDK_VISUAL_XVISUAL(visual);
+	} else {
+		xvisual = GDK_VISUAL_XVISUAL(gdk_screen_get_system_visual(screen));
+	}
+
+	unsigned long data[1] = { XVisualIDFromVisual(xvisual) };
+	Atom atom = gdk_x11_get_xatom_by_name_for_display(display, "_NET_SYSTEM_TRAY_VISUAL");
+	XChangeProperty(GDK_DISPLAY_XDISPLAY(display),
+					GDK_WINDOW_XID(gtk_widget_get_window(tray->invisible)),
+					atom,
+					XA_VISUALID, 32,
+					PropModeReplace,
+					(guchar*) &data, 1);
+
+	// set the icon size
+
+	data[0] = (unsigned int) tray->iconSize;
+	atom = gdk_x11_get_xatom_by_name_for_display(display, "_NET_SYSTEM_TRAY_ICON_SIZE");
+	XChangeProperty(GDK_DISPLAY_XDISPLAY(display),
+                   	GDK_WINDOW_XID(gtk_widget_get_window(tray->invisible)),
+                   	atom,
+                   	XA_CARDINAL, 32,
+                   	PropModeReplace,
+                   	(guchar*) &data, 1);
+
+	// set orientation
+
+	data[0] = (unsigned int) gtk_orientable_get_orientation(GTK_ORIENTABLE(tray->box)) == GTK_ORIENTATION_HORIZONTAL ? 0 : 1;
+	atom = gdk_x11_get_xatom_by_name_for_display(display, "_NET_SYSTEM_TRAY_ORIENTATION");
+	XChangeProperty(GDK_DISPLAY_XDISPLAY(display),
+					GDK_WINDOW_XID(gtk_widget_get_window(tray->invisible)),
+					atom,
+					XA_CARDINAL, 32,
+					PropModeReplace,
+					(guchar*) &data, 1);
+}
+
+static void draw_child(GtkWidget *widget, void *data) {
+	CarbonDrawData *dt = (CarbonDrawData*) data;
+	CarbonChild *child = CARBON_CHILD(widget);
+	carbon_child_draw_on_tray(child, GTK_WIDGET(dt->box), dt->cr);
+}
diff --git a/src/applets/tray/carbontray/tray.h b/src/applets/tray/carbontray/tray.h
new file mode 100644
index 00000000..81776ddf
--- /dev/null
+++ b/src/applets/tray/carbontray/tray.h
@@ -0,0 +1,72 @@
+#ifndef __CARBONTRAY_TRAY_H__
+#define __CARBONTRAY_TRAY_H__
+
+#include <gtk/gtk.h>
+#include <gtk/gtkx.h>
+#include <X11/Xatom.h>
+#include <stdbool.h>
+#include "child.h"
+
+typedef struct {
+	GObject parent_instance;
+
+	GtkBox *box;
+	int iconSize;
+
+	GHashTable *socketTable;
+	GtkWidget *invisible;
+
+	GdkAtom selectionAtom;
+	Atom opcodeAtom;
+	Atom dataAtom;
+	GSList *messages;
+} CarbonTray;
+
+typedef struct {
+	GObjectClass parent_class;
+
+	void (*message_sent)(CarbonTray *manager, CarbonChild *child, char *message, long id, long timeout);
+} CarbonTrayClass;
+
+typedef struct {
+    char *string;
+
+    long id;
+    long length;
+    long remainingLength;
+    long timeout;
+
+    Window window;
+} CarbonMessage;
+
+typedef struct {
+	GtkWidget *box;
+	cairo_t *cr;
+} CarbonDrawData;
+
+
+
+#define CARBON_TYPE_TRAY carbon_tray_get_type()
+#define CARBON_TRAY(obj) G_TYPE_CHECK_INSTANCE_CAST((obj), CARBON_TYPE_TRAY, CarbonTray)
+#define CARBON_IS_TRAY(obj) G_TYPE_CHECK_INSTANCE_TYPE((obj), CARBON_TYPE_TRAY)
+#define CARBON_TRAY_CLASS(klass) G_TYPE_CHECK_CLASS_CAST((klass), CARBON_TYPE_TRAY, CarbonTrayClass))
+
+
+
+GType carbon_tray_get_type(void);
+
+CarbonTray* carbon_tray_new(GtkOrientation, int, int);
+
+void carbon_tray_add_to_container(CarbonTray*, GtkContainer*);
+
+void carbon_tray_remove_from_container(CarbonTray*, GtkContainer*);
+
+bool carbon_tray_register(CarbonTray*, GdkScreen*);
+
+void carbon_tray_unregister(CarbonTray*);
+
+void carbon_tray_set_spacing(CarbonTray*, int spacing);
+
+void carbon_tray_unref(CarbonTray*);
+
+#endif
diff --git a/src/applets/tray/com.solus-project.tray.gschema.xml b/src/applets/tray/com.solus-project.tray.gschema.xml
new file mode 100644
index 00000000..62d6e6f2
--- /dev/null
+++ b/src/applets/tray/com.solus-project.tray.gschema.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<schemalist gettext-domain="budgie">
+  <schema id="com.solus-project.tray">
+    <key type="i" name="spacing">
+      <default>4</default>
+      <summary>Space between icons</summary>
+      <description>How large to make the space between icons, in pixels</description>
+    </key>
+  </schema>
+</schemalist>
diff --git a/src/applets/tray/meson.build b/src/applets/tray/meson.build
index da265a02..973e731b 100644
--- a/src/applets/tray/meson.build
+++ b/src/applets/tray/meson.build
@@ -1,5 +1,7 @@
 # Tray Applet build
 
+subdir('carbontray')
+
 applet_tray_dir = applets_dir + '.tray'
 
 custom_target('plugin-file-tray',
@@ -9,15 +11,24 @@ custom_target('plugin-file-tray',
     install : true,
     install_dir : applet_tray_dir)
 
-applet_tray_sources = [
-    'TrayApplet.vala',
-]
+gresource = join_paths(meson.current_source_dir(), 'plugin.gresource.xml')
+
+applet_tray_resources = gnome.compile_resources(
+    'tray-applet-resources',
+    gresource,
+    source_dir: meson.current_source_dir(),
+    c_name: 'budgie_tray',
+)
+
+applet_tray_sources = ['TrayApplet.vala', applet_tray_resources]
 
 applet_tray_deps = [
     libplugin_vapi,
     dep_gtk3,
+    dependency('x11'),
+    dependency('gdk-x11-3.0'),
     dep_peas,
-    link_libnatray,
+    link_libcarbontray,
     link_libplugin,
 ]
 
@@ -27,10 +38,13 @@ shared_library(
     dependencies: applet_tray_deps,
     vala_args: [
         '--pkg', 'libpeas-1.0',
-        '--pkg', 'gtk+-3.0',
-        '--pkg', 'natray-1.0',
-        '--vapidir', join_paths(meson.source_root(), 'src', 'imports', 'natray'),
+        join_paths(meson.source_root(), 'src', 'applets', 'tray', 'carbontray', 'carbontray-1.0.vapi'),
     ],
     install: true,
     install_dir: applet_tray_dir,
 )
+
+install_data(
+    'com.solus-project.tray.gschema.xml',
+    install_dir: join_paths(datadir, 'glib-2.0', 'schemas'),
+)
diff --git a/src/applets/tray/plugin.gresource.xml b/src/applets/tray/plugin.gresource.xml
new file mode 100644
index 00000000..66d07528
--- /dev/null
+++ b/src/applets/tray/plugin.gresource.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<gresources>
+        <gresource prefix="/com/solus-project/tray">
+                <file preprocess="xml-stripblanks">settings.ui</file>
+        </gresource>
+</gresources>
diff --git a/src/applets/tray/settings.ui b/src/applets/tray/settings.ui
new file mode 100644
index 00000000..209b379c
--- /dev/null
+++ b/src/applets/tray/settings.ui
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<interface>
+  <requires lib="gtk+" version="3.12"/>
+  <object class="GtkAdjustment" id="adjustment1">
+    <property name="upper">20</property>
+    <property name="step_increment">1</property>
+    <property name="page_increment">10</property>
+  </object>
+  <template class="TraySettings" parent="GtkGrid">
+    <property name="visible">True</property>
+    <property name="can_focus">False</property>
+    <property name="hexpand">True</property>
+    <child>
+      <object class="GtkLabel" id="label1">
+        <property name="visible">True</property>
+        <property name="can_focus">False</property>
+        <property name="halign">start</property>
+        <property name="valign">center</property>
+        <property name="hexpand">True</property>
+        <property name="label" translatable="yes">Icon Spacing</property>
+      </object>
+      <packing>
+        <property name="left_attach">0</property>
+        <property name="top_attach">0</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkSpinButton" id="spinbutton_spacing">
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="halign">end</property>
+        <property name="valign">center</property>
+        <property name="hexpand">True</property>
+        <property name="adjustment">adjustment1</property>
+      </object>
+      <packing>
+        <property name="left_attach">1</property>
+        <property name="top_attach">0</property>
+      </packing>
+    </child>
+  </template>
+</interface>
diff --git a/src/imports/meson.build b/src/imports/meson.build
deleted file mode 100644
index e1f63f62..00000000
--- a/src/imports/meson.build
+++ /dev/null
@@ -1 +0,0 @@
-subdir('natray')
diff --git a/src/imports/natray/fixedtip.c b/src/imports/natray/fixedtip.c
deleted file mode 100644
index 16347dd7..00000000
--- a/src/imports/natray/fixedtip.c
+++ /dev/null
@@ -1,289 +0,0 @@
-/* Metacity fixed tooltip routine */
-
-/*
- * Copyright (C) 2001 Havoc Pennington
- * Copyright (C) 2003-2006 Vincent Untz
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "fixedtip.h"
-
-/* Signals */
-enum
-{
-  CLICKED,
-  LAST_SIGNAL
-};
-
-static guint fixedtip_signals[LAST_SIGNAL] = { 0 };
-
-struct _NaFixedTipPrivate
-{
-  GtkWidget      *parent;
-  GtkWidget      *label;
-  GtkOrientation  orientation;
-};
-
-G_DEFINE_TYPE (NaFixedTip, na_fixed_tip, GTK_TYPE_WINDOW)
-
-static gboolean
-button_press_handler (GtkWidget      *fixedtip,
-                      GdkEventButton *event,
-                      gpointer        data)
-{
-  if (event->button == 1 && event->type == GDK_BUTTON_PRESS)
-    g_signal_emit (fixedtip, fixedtip_signals[CLICKED], 0);
-
-  return FALSE;
-}
-
-static gboolean
-na_fixed_tip_draw (GtkWidget *widget, cairo_t *cr)
-{
-  GtkStyleContext *context;
-  GtkStateFlags state;
-  int width, height;
-
-  width = gtk_widget_get_allocated_width (widget);
-  height = gtk_widget_get_allocated_height (widget);
-
-  state = gtk_widget_get_state_flags (widget);
-  context = gtk_widget_get_style_context (widget);
-  gtk_style_context_save (context);
-  gtk_style_context_add_class (context, GTK_STYLE_CLASS_TOOLTIP);
-  gtk_style_context_set_state (context, state);
-
-  cairo_save (cr);
-  gtk_render_background (context, cr,
-                         0., 0.,
-                         (gdouble)width,
-                         (gdouble)height);
-  cairo_restore (cr);
-
-  gtk_style_context_restore (context);
-
-  return FALSE;
-}
-
-static void
-na_fixed_tip_class_init (NaFixedTipClass *class)
-{
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (class);
-
-  widget_class->draw = na_fixed_tip_draw;
-
-  fixedtip_signals[CLICKED] =
-    g_signal_new ("clicked",
-		  G_OBJECT_CLASS_TYPE (class),
-		  G_SIGNAL_RUN_LAST,
-		  G_STRUCT_OFFSET (NaFixedTipClass, clicked),
-		  NULL, NULL, NULL,
-		  G_TYPE_NONE, 0);
-
-  g_type_class_add_private (class, sizeof (NaFixedTipPrivate));
-}
-
-/* Did you already see this code? Yes, it's gtk_tooltips_ force_window() ;-) */
-static void
-na_fixed_tip_init (NaFixedTip *fixedtip)
-{
-  GtkWidget *label;
-
-  fixedtip->priv = G_TYPE_INSTANCE_GET_PRIVATE (fixedtip, NA_TYPE_FIXED_TIP,
-                                                NaFixedTipPrivate);
-
-  gtk_window_set_type_hint (GTK_WINDOW (fixedtip),
-                            GDK_WINDOW_TYPE_HINT_TOOLTIP);
-
-  gtk_widget_set_app_paintable (GTK_WIDGET (fixedtip), TRUE);
-  gtk_window_set_resizable (GTK_WINDOW (fixedtip), FALSE);
-  gtk_widget_set_name (GTK_WIDGET (fixedtip), "gtk-tooltips");
-  gtk_container_set_border_width (GTK_CONTAINER (fixedtip), 4);
-
-  label = gtk_label_new (NULL);
-  gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);
-  gtk_widget_show (label);
-  gtk_container_add (GTK_CONTAINER (fixedtip), label);
-  fixedtip->priv->label = label;
-
-  gtk_widget_add_events (GTK_WIDGET (fixedtip), GDK_BUTTON_PRESS_MASK);
-
-  g_signal_connect (fixedtip, "button_press_event",
-                    G_CALLBACK (button_press_handler), NULL);
-
-  fixedtip->priv->orientation = GTK_ORIENTATION_HORIZONTAL;
-}
-
-static void
-get_monitor_geometry (GdkWindow    *window,
-                      GdkRectangle *geometry)
-{
-  GdkDisplay *display = NULL;
-#if GTK_MAJOR_VERSION == 3 && GTK_MINOR_VERSION < 22
-  GdkScreen *screen = NULL;
-  gint monitor;
-
-  screen = gdk_screen_get_default ();
-  monitor = gdk_screen_get_monitor_at_window (screen, window);
-
-  gdk_screen_get_monitor_geometry (screen, monitor, geometry);
-#else
-  GdkMonitor *monitor;
-
-  display = gdk_display_get_default ();
-  monitor = gdk_display_get_monitor_at_window (display, window);
-
-  gdk_monitor_get_geometry (monitor, geometry);
-#endif
-}
-
-static void
-na_fixed_tip_position (NaFixedTip *fixedtip)
-{
-  GdkWindow      *parent_window;
-  GdkRectangle    monitor;
-  GtkRequisition  req;
-  int             root_x;
-  int             root_y;
-  int             parent_width;
-  int             parent_height;
-
-  parent_window = gtk_widget_get_window (fixedtip->priv->parent);
-  get_monitor_geometry (parent_window, &monitor);
-
-  gtk_widget_get_preferred_size (GTK_WIDGET (fixedtip), &req, NULL);
-
-  gdk_window_get_origin (parent_window, &root_x, &root_y);
-  parent_width = gdk_window_get_width (parent_window);
-  parent_height = gdk_window_get_height (parent_window);
-
-  /* pad between panel and message window */
-#define PAD 5
-
-  if (fixedtip->priv->orientation == GTK_ORIENTATION_VERTICAL)
-    {
-      if (root_x <= monitor.width / 2)
-        root_x += parent_width + PAD;
-      else
-        root_x -= req.width + PAD;
-    }
-  else
-    {
-      if (root_y <= monitor.height / 2)
-        root_y += parent_height + PAD;
-      else
-        root_y -= req.height + PAD;
-    }
-
-  /* Push onscreen */
-  if ((root_x + req.width) > monitor.width)
-    root_x = monitor.width - req.width;
-
-  if ((root_y + req.height) > monitor.height)
-    root_y = monitor.height - req.height;
-
-  gtk_window_move (GTK_WINDOW (fixedtip), root_x, root_y);
-}
-
-static void
-na_fixed_tip_parent_size_allocated (GtkWidget     *parent,
-                                    GtkAllocation *allocation,
-                                    NaFixedTip    *fixedtip)
-{
-  na_fixed_tip_position (fixedtip);
-}
-
-static void
-na_fixed_tip_parent_screen_changed (GtkWidget  *parent,
-                                    GdkScreen  *new_screen,
-                                    NaFixedTip *fixedtip)
-{
-  na_fixed_tip_position (fixedtip);
-}
-
-GtkWidget *
-na_fixed_tip_new (GtkWidget      *parent,
-                  GtkOrientation  orientation)
-{
-  NaFixedTip *fixedtip;
-
-  g_return_val_if_fail (parent != NULL, NULL);
-
-  fixedtip = g_object_new (NA_TYPE_FIXED_TIP,
-                           "type", GTK_WINDOW_POPUP,
-                           NULL);
-
-  fixedtip->priv->parent = parent;
-
-#if 0
-  //FIXME: would be nice to be able to get the toplevel for the tip, but this
-  //doesn't work
-  GtkWidget  *toplevel;
-
-  toplevel = gtk_widget_get_toplevel (parent);
-  /*
-  if (toplevel && gtk_widget_is_toplevel (toplevel) && GTK_IS_WINDOW (toplevel))
-    gtk_window_set_transient_for (GTK_WINDOW (fixedtip), GTK_WINDOW (toplevel));
-    */
-#endif
-
-  fixedtip->priv->orientation = orientation;
-
-  //FIXME: would be nice to move the tip when the notification area moves
-  g_signal_connect_object (parent, "size-allocate",
-                           G_CALLBACK (na_fixed_tip_parent_size_allocated),
-                           fixedtip, 0);
-  g_signal_connect_object (parent, "screen-changed",
-                           G_CALLBACK (na_fixed_tip_parent_screen_changed),
-                           fixedtip, 0);
-
-  na_fixed_tip_position (fixedtip);
-
-  return GTK_WIDGET (fixedtip);
-}
-
-void
-na_fixed_tip_set_markup (GtkWidget  *widget,
-                         const char *markup_text)
-{
-  NaFixedTip *fixedtip;
-
-  g_return_if_fail (NA_IS_FIXED_TIP (widget));
-
-  fixedtip = NA_FIXED_TIP (widget);
-
-  gtk_label_set_markup (GTK_LABEL (fixedtip->priv->label),
-                        markup_text);
-
-  na_fixed_tip_position (fixedtip);
-}
-
-void
-na_fixed_tip_set_orientation (GtkWidget      *widget,
-                              GtkOrientation  orientation)
-{
-  NaFixedTip *fixedtip;
-
-  g_return_if_fail (NA_IS_FIXED_TIP (widget));
-
-  fixedtip = NA_FIXED_TIP (widget);
-
-  if (orientation == fixedtip->priv->orientation)
-    return;
-
-  fixedtip->priv->orientation = orientation;
-
-  na_fixed_tip_position (fixedtip);
-}
diff --git a/src/imports/natray/fixedtip.h b/src/imports/natray/fixedtip.h
deleted file mode 100644
index a1c62041..00000000
--- a/src/imports/natray/fixedtip.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* Fixed tooltip routine */
-
-/*
- * Copyright (C) 2001 Havoc Pennington, 2002 Red Hat Inc.
- * Copyright (C) 2003-2006 Vincent Untz
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef FIXED_TIP_H
-#define FIXED_TIP_H
-
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-#define NA_TYPE_FIXED_TIP			(na_fixed_tip_get_type ())
-#define NA_FIXED_TIP(obj)			(G_TYPE_CHECK_INSTANCE_CAST ((obj), NA_TYPE_FIXED_TIP, NaFixedTip))
-#define NA_FIXED_TIP_CLASS(klass)		(G_TYPE_CHECK_CLASS_CAST ((klass), NA_TYPE_FIXED_TIP, NaFixedTipClass))
-#define NA_IS_FIXED_TIP(obj)			(G_TYPE_CHECK_INSTANCE_TYPE ((obj), NA_TYPE_FIXED_TIP))
-#define NA_IS_FIXED_TIP_CLASS(klass)		(G_TYPE_CHECK_CLASS_TYPE ((klass), NA_TYPE_FIXED_TIP))
-#define NA_FIXED_TIP_GET_CLASS(obj)		(G_TYPE_INSTANCE_GET_CLASS ((obj), NA_TYPE_FIXED_TIP, NaFixedTipClass))
-
-typedef struct _NaFixedTip	  NaFixedTip;
-typedef struct _NaFixedTipPrivate NaFixedTipPrivate;
-typedef struct _NaFixedTipClass   NaFixedTipClass;
-
-struct _NaFixedTip
-{
-  GtkWindow parent_instance;
-
-  NaFixedTipPrivate *priv;
-};
-
-struct _NaFixedTipClass
-{
-  GtkWindowClass parent_class;
-
-  void (* clicked)    (NaFixedTip *fixedtip);
-};
-
-GType      na_fixed_tip_get_type (void);
-
-GtkWidget *na_fixed_tip_new (GtkWidget      *parent,
-                             GtkOrientation  orientation);
-
-void       na_fixed_tip_set_markup (GtkWidget  *widget,
-                                    const char *markup_text);
-
-void       na_fixed_tip_set_orientation (GtkWidget      *widget,
-                                         GtkOrientation  orientation);
-
-G_END_DECLS
-
-#endif /* FIXED_TIP_H */
diff --git a/src/imports/natray/meson.build b/src/imports/natray/meson.build
deleted file mode 100644
index 003c57f6..00000000
--- a/src/imports/natray/meson.build
+++ /dev/null
@@ -1,32 +0,0 @@
-# libnatray provides the old GNOME Panel natray code for use in Budgie
-
-libnatray_deps = [
-    dep_gtk3,
-    dependency('gtk+-x11-3.0', version: gnome_minimum_version),
-    dependency('x11'),
-]
-
-libnatray_sources = [
-    'na-tray.c',
-    'na-tray-child.c',
-    'na-tray-manager.c',
-    'fixedtip.c',
-]
-
-libnatray = static_library(
-    'natray',
-    libnatray_sources,
-    dependencies: libnatray_deps,
-    include_directories: [
-        include_directories('.'),
-        include_directories(join_paths('..', '..', '..')),
-    ],
-)
-
-link_libnatray = declare_dependency(
-    link_with: libnatray,
-    include_directories: include_directories('.'),
-)
-
-# Expose the current directory so that we can use vapidir
-dir_libnatray = meson.current_source_dir()
diff --git a/src/imports/natray/na-tray-child.c b/src/imports/natray/na-tray-child.c
deleted file mode 100644
index f90c4e71..00000000
--- a/src/imports/natray/na-tray-child.c
+++ /dev/null
@@ -1,528 +0,0 @@
-/* na-tray-child.c
- * Copyright (C) 2002 Anders Carlsson <andersca@gnu.org>
- * Copyright (C) 2003-2006 Vincent Untz
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <config.h>
-#include <string.h>
-
-#include "na-tray-child.h"
-
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-#include <X11/Xatom.h>
-
-G_DEFINE_TYPE (NaTrayChild, na_tray_child, GTK_TYPE_SOCKET)
-
-static void
-na_tray_child_finalize (GObject *object)
-{
-  G_OBJECT_CLASS (na_tray_child_parent_class)->finalize (object);
-}
-
-static void
-na_tray_child_realize (GtkWidget *widget)
-{
-  NaTrayChild *child = NA_TRAY_CHILD (widget);
-  GdkVisual *visual = gtk_widget_get_visual (widget);
-  GdkWindow *window;
-
-  GTK_WIDGET_CLASS (na_tray_child_parent_class)->realize (widget);
-
-  window = gtk_widget_get_window (widget);
-
-  if (child->has_alpha)
-    {
-      /* We have real transparency with an ARGB visual and the Composite
-       * extension. */
-
-      /* Set a transparent background */
-      cairo_pattern_t *transparent = cairo_pattern_create_rgba (0, 0, 0, 0);
-      gdk_window_set_background_pattern (window, transparent);
-      gdk_window_set_composited (window, TRUE);
-      cairo_pattern_destroy (transparent);
-
-      child->parent_relative_bg = FALSE;
-    }
-  else if (visual == gdk_window_get_visual (gdk_window_get_parent (window)))
-    {
-      /* Otherwise, if the visual matches the visual of the parent window, we
-       * can use a parent-relative background and fake transparency. */
-      gdk_window_set_background_pattern (window, NULL);
-
-      child->parent_relative_bg = TRUE;
-    }
-  else
-    {
-      /* Nothing to do; the icon will sit on top of an ugly gray box */
-      child->parent_relative_bg = FALSE;
-    }
-
-  gdk_window_set_composited (window, child->composited);
-
-  gtk_widget_set_app_paintable (GTK_WIDGET (child),
-                                child->parent_relative_bg || child->has_alpha);
-
-  /* Double-buffering will interfere with the parent-relative-background fake
-   * transparency, since the double-buffer code doesn't know how to fill in the
-   * background of the double-buffer correctly.
-   */
-  gtk_widget_set_double_buffered (GTK_WIDGET (child),
-                                  child->parent_relative_bg);
-}
-
-static void
-na_tray_child_style_set (GtkWidget *widget,
-                         GtkStyle  *previous_style)
-{
-  /* The default handler resets the background according to the new style.
-   * We either use a transparent background or a parent-relative background
-   * and ignore the style background. So, just don't chain up.
-   */
-}
-
-static void
-na_tray_child_get_preferred_width (GtkWidget *widget,
-                                   gint      *minimal_width,
-                                   gint      *natural_width)
-{
-  GTK_WIDGET_CLASS (na_tray_child_parent_class)->get_preferred_width (widget,
-                                                                      minimal_width,
-                                                                      natural_width);
-
-  if (*minimal_width < 22)
-    *minimal_width = 22;
-
-  if (*natural_width < 22)
-    *natural_width = 22;
-}
-
-static void
-na_tray_child_get_preferred_height (GtkWidget *widget,
-                                    gint      *minimal_height,
-                                    gint      *natural_height)
-{
-  GTK_WIDGET_CLASS (na_tray_child_parent_class)->get_preferred_height (widget,
-                                                                       minimal_height,
-                                                                       natural_height);
-
-  if (*minimal_height < 22)
-    *minimal_height = 22;
-
-  if (*natural_height < 22)
-    *natural_height = 22;
-}
-
-static void
-na_tray_child_size_allocate (GtkWidget      *widget,
-                             GtkAllocation  *allocation)
-{
-  NaTrayChild *child = NA_TRAY_CHILD (widget);
-  GtkAllocation widget_allocation;
-  gboolean moved, resized;
-
-  gtk_widget_get_allocation (widget, &widget_allocation);
-
-  moved = (allocation->x != widget_allocation.x ||
-	   allocation->y != widget_allocation.y);
-  resized = (allocation->width != widget_allocation.width ||
-	     allocation->height != widget_allocation.height);
-
-  /* When we are allocating the widget while mapped we need special handling
-   * for both real and fake transparency.
-   *
-   * Real transparency: we need to invalidate and trigger a redraw of the old
-   *   and new areas. (GDK really should handle this for us, but doesn't as of
-   *   GTK+-2.14)
-   *
-   * Fake transparency: if the widget moved, we need to force the contents to
-   *   be redrawn with the new offset for the parent-relative background.
-   */
-  if ((moved || resized) && gtk_widget_get_mapped (widget))
-    {
-      if (na_tray_child_has_alpha (child))
-        gdk_window_invalidate_rect (gdk_window_get_parent (gtk_widget_get_window (widget)),
-                                    &widget_allocation, FALSE);
-    }
-
-  GTK_WIDGET_CLASS (na_tray_child_parent_class)->size_allocate (widget,
-                                                                allocation);
-
-  if ((moved || resized) && gtk_widget_get_mapped (widget))
-    {
-      if (na_tray_child_has_alpha (NA_TRAY_CHILD (widget)))
-        gdk_window_invalidate_rect (gdk_window_get_parent (gtk_widget_get_window (widget)),
-                                    &widget_allocation, FALSE);
-      else if (moved && child->parent_relative_bg)
-        na_tray_child_force_redraw (child);
-    }
-}
-
-/* The plug window should completely occupy the area of the child, so we won't
- * get a draw event. But in case we do (the plug unmaps itself, say), this
- * draw handler draws with real or fake transparency.
- */
-static gboolean
-na_tray_child_draw (GtkWidget *widget,
-                    cairo_t   *cr)
-{
-  NaTrayChild *child = NA_TRAY_CHILD (widget);
-
-  if (na_tray_child_has_alpha (child))
-    {
-      /* Clear to transparent */
-      cairo_set_source_rgba (cr, 0, 0, 0, 0);
-      cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
-      cairo_paint (cr);
-    }
-  else if (child->parent_relative_bg)
-    {
-      GdkWindow *window;
-      cairo_surface_t *target;
-      GdkRectangle clip_rect;
-
-      window = gtk_widget_get_window (widget);
-      target = cairo_get_group_target (cr);
-
-      gdk_cairo_get_clip_rectangle (cr, &clip_rect);
-
-      /* Clear to parent-relative pixmap
-       * We need to use direct X access here because GDK doesn't know about
-       * the parent relative pixmap. */
-      cairo_surface_flush (target);
-
-      XClearArea (GDK_WINDOW_XDISPLAY (window),
-                  GDK_WINDOW_XID (window),
-                  clip_rect.x, clip_rect.y,
-                  clip_rect.width, clip_rect.height,
-                  False);
-      cairo_surface_mark_dirty_rectangle (target,
-                                          clip_rect.x, clip_rect.y,
-                                          clip_rect.width, clip_rect.height);
-    }
-
-  return FALSE;
-}
-
-static void
-na_tray_child_init (NaTrayChild *child)
-{
-}
-
-static void
-na_tray_child_class_init (NaTrayChildClass *klass)
-{
-  GObjectClass *gobject_class;
-  GtkWidgetClass *widget_class;
-
-  gobject_class = (GObjectClass *)klass;
-  widget_class = (GtkWidgetClass *)klass;
-
-  gobject_class->finalize = na_tray_child_finalize;
-  widget_class->style_set = na_tray_child_style_set;
-  widget_class->realize = na_tray_child_realize;
-  widget_class->get_preferred_width = na_tray_child_get_preferred_width;
-  widget_class->get_preferred_height = na_tray_child_get_preferred_height;
-  widget_class->size_allocate = na_tray_child_size_allocate;
-  widget_class->draw = na_tray_child_draw;
-}
-
-GtkWidget *
-na_tray_child_new (GdkScreen *screen,
-                   Window     icon_window)
-{
-  XWindowAttributes window_attributes;
-  Display *xdisplay;
-  NaTrayChild *child;
-  GdkVisual *visual;
-  gboolean visual_has_alpha;
-  int red_prec, green_prec, blue_prec, depth;
-  int result;
-
-  g_return_val_if_fail (GDK_IS_SCREEN (screen), NULL);
-  g_return_val_if_fail (icon_window != None, NULL);
-
-  xdisplay = GDK_SCREEN_XDISPLAY (screen);
-
-  /* We need to determine the visual of the window we are embedding and create
-   * the socket in the same visual.
-   */
-
-  gdk_error_trap_push ();
-  result = XGetWindowAttributes (xdisplay, icon_window,
-                                 &window_attributes);
-  gdk_error_trap_pop_ignored ();
-
-  if (!result) /* Window already gone */
-    return NULL;
-
-  visual = gdk_x11_screen_lookup_visual (screen,
-                                         window_attributes.visual->visualid);
-  if (!visual) /* Icon window is on another screen? */
-    return NULL;
-
-  child = g_object_new (NA_TYPE_TRAY_CHILD, NULL);
-  child->icon_window = icon_window;
-
-  gtk_widget_set_visual (GTK_WIDGET (child), visual);
-
-  /* We have alpha if the visual has something other than red, green,
-   * and blue */
-  gdk_visual_get_red_pixel_details (visual, NULL, NULL, &red_prec);
-  gdk_visual_get_green_pixel_details (visual, NULL, NULL, &green_prec);
-  gdk_visual_get_blue_pixel_details (visual, NULL, NULL, &blue_prec);
-  depth = gdk_visual_get_depth (visual);
-
-  visual_has_alpha = red_prec + blue_prec + green_prec < depth;
-  child->has_alpha = (visual_has_alpha && gdk_screen_is_composited (screen));
-
-  child->composited = child->has_alpha;
-
-  return GTK_WIDGET (child);
-}
-
-char *
-na_tray_child_get_title (NaTrayChild *child)
-{
-  char *retval = NULL;
-  GdkDisplay *display;
-  Atom utf8_string, atom, type;
-  int result;
-  int format;
-  gulong nitems;
-  gulong bytes_after;
-  gchar *val;
-
-  g_return_val_if_fail (NA_IS_TRAY_CHILD (child), NULL);
-
-  display = gtk_widget_get_display (GTK_WIDGET (child));
-
-  utf8_string = gdk_x11_get_xatom_by_name_for_display (display, "UTF8_STRING");
-  atom = gdk_x11_get_xatom_by_name_for_display (display, "_NET_WM_NAME");
-
-  gdk_error_trap_push ();
-
-  result = XGetWindowProperty (GDK_DISPLAY_XDISPLAY (display),
-                               child->icon_window,
-                               atom,
-                               0, G_MAXLONG,
-                               False, utf8_string,
-                               &type, &format, &nitems,
-                               &bytes_after, (guchar **)&val);
-
-  if (gdk_error_trap_pop () || result != Success)
-    return NULL;
-
-  if (type != utf8_string ||
-      format != 8 ||
-      nitems == 0)
-    {
-      if (val)
-        XFree (val);
-      return NULL;
-    }
-
-  if (!g_utf8_validate (val, nitems, NULL))
-    {
-      XFree (val);
-      return NULL;
-    }
-
-  retval = g_strndup (val, nitems);
-
-  XFree (val);
-
-  return retval;
-}
-
-/**
- * na_tray_child_has_alpha;
- * @child: a #NaTrayChild
- *
- * Checks if the child has an ARGB visual and real alpha transparence.
- * (as opposed to faked alpha transparency with an parent-relative
- * background)
- *
- * Return value: %TRUE if the child has an alpha transparency
- */
-gboolean
-na_tray_child_has_alpha (NaTrayChild *child)
-{
-  g_return_val_if_fail (NA_IS_TRAY_CHILD (child), FALSE);
-
-  return child->has_alpha;
-}
-
-/**
- * na_tray_child_set_composited;
- * @child: a #NaTrayChild
- * @composited: %TRUE if the child's window should be redirected
- *
- * Sets whether the #GdkWindow of the child should be set redirected
- * using gdk_window_set_composited(). By default this is based off of
- * na_tray_child_has_alpha(), but it may be useful to override it in
- * certain circumstances; for example, if the #NaTrayChild is added
- * to a parent window and that parent window is composited against the
- * background.
- */
-void
-na_tray_child_set_composited (NaTrayChild *child,
-                              gboolean     composited)
-{
-  g_return_if_fail (NA_IS_TRAY_CHILD (child));
-
-  if (child->composited == composited)
-    return;
-
-  child->composited = composited;
-  if (gtk_widget_get_realized (GTK_WIDGET (child)))
-    gdk_window_set_composited (gtk_widget_get_window (GTK_WIDGET (child)),
-                               composited);
-}
-
-/* If we are faking transparency with a window-relative background, force a
- * redraw of the icon. This should be called if the background changes or if
- * the child is shifted with respect to the background.
- */
-void
-na_tray_child_force_redraw (NaTrayChild *child)
-{
-  GtkWidget *widget = GTK_WIDGET (child);
-
-  if (gtk_widget_get_mapped (widget) && child->parent_relative_bg)
-    {
-#if 1
-      /* Sending an ExposeEvent might cause redraw problems if the
-       * icon is expecting the server to clear-to-background before
-       * the redraw. It should be ok for GtkStatusIcon or EggTrayIcon.
-       */
-      Display *xdisplay = GDK_DISPLAY_XDISPLAY (gtk_widget_get_display (widget));
-      XEvent xev;
-      GdkWindow *plug_window;
-      GtkAllocation allocation;
-
-      plug_window = gtk_socket_get_plug_window (GTK_SOCKET (child));
-      gtk_widget_get_allocation (widget, &allocation);
-
-      xev.xexpose.type = Expose;
-      xev.xexpose.window = GDK_WINDOW_XID (plug_window);
-      xev.xexpose.x = 0;
-      xev.xexpose.y = 0;
-      xev.xexpose.width = allocation.width;
-      xev.xexpose.height = allocation.height;
-      xev.xexpose.count = 0;
-
-      gdk_error_trap_push ();
-      XSendEvent (xdisplay,
-                  xev.xexpose.window,
-                  False, ExposureMask,
-                  &xev);
-      gdk_error_trap_pop_ignored ();
-#else
-      /* Hiding and showing is the safe way to do it, but can result in more
-       * flickering.
-       */
-      gdk_window_hide (widget->window);
-      gdk_window_show (widget->window);
-#endif
-    }
-}
-
-/* from libwnck/xutils.c, comes as LGPLv2+ */
-static char *
-latin1_to_utf8 (const char *latin1)
-{
-  GString *str;
-  const char *p;
-
-  str = g_string_new (NULL);
-
-  p = latin1;
-  while (*p)
-    {
-      g_string_append_unichar (str, (gunichar) *p);
-      ++p;
-    }
-
-  return g_string_free (str, FALSE);
-}
-
-/* derived from libwnck/xutils.c, comes as LGPLv2+ */
-static void
-_get_wmclass (Display *xdisplay,
-              Window   xwindow,
-              char   **res_class,
-              char   **res_name)
-{
-  XClassHint ch;
-
-  ch.res_name = NULL;
-  ch.res_class = NULL;
-
-  gdk_error_trap_push ();
-  XGetClassHint (xdisplay, xwindow, &ch);
-  gdk_error_trap_pop_ignored ();
-
-  if (res_class)
-    *res_class = NULL;
-
-  if (res_name)
-    *res_name = NULL;
-
-  if (ch.res_name)
-    {
-      if (res_name)
-        *res_name = latin1_to_utf8 (ch.res_name);
-
-      XFree (ch.res_name);
-    }
-
-  if (ch.res_class)
-    {
-      if (res_class)
-        *res_class = latin1_to_utf8 (ch.res_class);
-
-      XFree (ch.res_class);
-    }
-}
-
-/**
- * na_tray_child_get_wm_class;
- * @child: a #NaTrayChild
- * @res_name: return location for a string containing the application name of
- * @child, or %NULL
- * @res_class: return location for a string containing the application class of
- * @child, or %NULL
- *
- * Fetches the resource associated with @child.
- */
-void
-na_tray_child_get_wm_class (NaTrayChild  *child,
-                            char        **res_name,
-                            char        **res_class)
-{
-  GdkDisplay *display;
-
-  g_return_if_fail (NA_IS_TRAY_CHILD (child));
-
-  display = gtk_widget_get_display (GTK_WIDGET (child));
-
-  _get_wmclass (GDK_DISPLAY_XDISPLAY (display),
-                child->icon_window,
-                res_class,
-                res_name);
-}
diff --git a/src/imports/natray/na-tray-child.h b/src/imports/natray/na-tray-child.h
deleted file mode 100644
index eb4434f2..00000000
--- a/src/imports/natray/na-tray-child.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
-/* na-tray-child.h
- * Copyright (C) 2002 Anders Carlsson <andersca@gnu.org>
- * Copyright (C) 2003-2006 Vincent Untz
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __NA_TRAY_CHILD_H__
-#define __NA_TRAY_CHILD_H__
-
-#include <gtk/gtk.h>
-#include <gtk/gtkx.h>
-
-G_BEGIN_DECLS
-
-#define NA_TYPE_TRAY_CHILD		(na_tray_child_get_type ())
-#define NA_TRAY_CHILD(obj)		(G_TYPE_CHECK_INSTANCE_CAST ((obj), NA_TYPE_TRAY_CHILD, NaTrayChild))
-#define NA_TRAY_CHILD_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST ((klass), NA_TYPE_TRAY_CHILD, NaTrayChildClass))
-#define NA_IS_TRAY_CHILD(obj)		(G_TYPE_CHECK_INSTANCE_TYPE ((obj), NA_TYPE_TRAY_CHILD))
-#define NA_IS_TRAY_CHILD_CLASS(klass)	(G_TYPE_CHECK_CLASS_TYPE ((klass), NA_TYPE_TRAY_CHILD))
-#define NA_TRAY_CHILD_GET_CLASS(obj)	(G_TYPE_INSTANCE_GET_CLASS ((obj), NA_TYPE_TRAY_CHILD, NaTrayChildClass))
-
-typedef struct _NaTrayChild	  NaTrayChild;
-typedef struct _NaTrayChildClass  NaTrayChildClass;
-typedef struct _NaTrayChildChild  NaTrayChildChild;
-
-struct _NaTrayChild
-{
-  GtkSocket parent_instance;
-  Window icon_window;
-  guint has_alpha : 1;
-  guint composited : 1;
-  guint parent_relative_bg : 1;
-};
-
-struct _NaTrayChildClass
-{
-  GtkSocketClass parent_class;
-};
-
-GType           na_tray_child_get_type        (void);
-
-GtkWidget      *na_tray_child_new            (GdkScreen    *screen,
-                                              Window        icon_window);
-char           *na_tray_child_get_title      (NaTrayChild  *child);
-gboolean        na_tray_child_has_alpha      (NaTrayChild  *child);
-void            na_tray_child_set_composited (NaTrayChild  *child,
-                                              gboolean      composited);
-void            na_tray_child_force_redraw   (NaTrayChild  *child);
-void            na_tray_child_get_wm_class   (NaTrayChild  *child,
-					      char        **res_name,
-					      char        **res_class);
-
-G_END_DECLS
-
-#endif /* __NA_TRAY_CHILD_H__ */
diff --git a/src/imports/natray/na-tray-manager.c b/src/imports/natray/na-tray-manager.c
deleted file mode 100644
index 58b91b56..00000000
--- a/src/imports/natray/na-tray-manager.c
+++ /dev/null
@@ -1,981 +0,0 @@
-/* na-tray-manager.c
- * Copyright (C) 2002 Anders Carlsson <andersca@gnu.org>
- * Copyright (C) 2003-2006 Vincent Untz
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see <http://www.gnu.org/licenses/>.
- *
- * Used to be: eggtraymanager.c
- */
-
-#include <config.h>
-#include <string.h>
-#include <libintl.h>
-
-#include "na-tray-manager.h"
-
-#include <gdk/gdkx.h>
-#include <X11/Xatom.h>
-#include <gtk/gtk.h>
-
-/* Signals */
-enum
-{
-  TRAY_ICON_ADDED,
-  TRAY_ICON_REMOVED,
-  MESSAGE_SENT,
-  MESSAGE_CANCELLED,
-  LOST_SELECTION,
-  LAST_SIGNAL
-};
-
-enum {
-  PROP_0,
-  PROP_ORIENTATION
-};
-
-typedef struct
-{
-  long id, len;
-  long remaining_len;
-
-  long timeout;
-  char *str;
-#ifdef GDK_WINDOWING_X11
-  Window window;
-#endif
-} PendingMessage;
-
-static guint manager_signals[LAST_SIGNAL];
-
-#define SYSTEM_TRAY_REQUEST_DOCK    0
-#define SYSTEM_TRAY_BEGIN_MESSAGE   1
-#define SYSTEM_TRAY_CANCEL_MESSAGE  2
-
-#define SYSTEM_TRAY_ORIENTATION_HORZ 0
-#define SYSTEM_TRAY_ORIENTATION_VERT 1
-
-#ifdef GDK_WINDOWING_X11
-static gboolean na_tray_manager_check_running_screen_x11 (GdkScreen *screen);
-#endif
-
-static void na_tray_manager_finalize     (GObject      *object);
-static void na_tray_manager_set_property (GObject      *object,
-					  guint         prop_id,
-					  const GValue *value,
-					  GParamSpec   *pspec);
-static void na_tray_manager_get_property (GObject      *object,
-					  guint         prop_id,
-					  GValue       *value,
-					  GParamSpec   *pspec);
-
-static void na_tray_manager_unmanage (NaTrayManager *manager);
-
-G_DEFINE_TYPE (NaTrayManager, na_tray_manager, G_TYPE_OBJECT)
-
-static void
-na_tray_manager_init (NaTrayManager *manager)
-{
-  manager->invisible = NULL;
-  manager->socket_table = g_hash_table_new (NULL, NULL);
-
-  manager->padding = 0;
-  manager->icon_size = 0;
-
-  manager->fg.red = 0.0;
-  manager->fg.green = 0.0;
-  manager->fg.blue = 0.0;
-  manager->fg.alpha = 1.0;
-
-  manager->error.red = 1.0;
-  manager->error.green = 0.0;
-  manager->error.blue = 0.0;
-  manager->error.alpha = 1.0;
-
-  manager->warning.red = 1.0;
-  manager->warning.green = 1.0;
-  manager->warning.blue = 0.0;
-  manager->warning.alpha = 1.0;
-
-  manager->success.red = 0.0;
-  manager->success.green = 1.0;
-  manager->success.blue = 0.0;
-  manager->success.alpha = 1.0;
-}
-
-static void
-na_tray_manager_class_init (NaTrayManagerClass *klass)
-{
-  GObjectClass *gobject_class;
-
-  gobject_class = (GObjectClass *)klass;
-
-  gobject_class->finalize = na_tray_manager_finalize;
-  gobject_class->set_property = na_tray_manager_set_property;
-  gobject_class->get_property = na_tray_manager_get_property;
-
-  g_object_class_install_property (gobject_class,
-				   PROP_ORIENTATION,
-				   g_param_spec_enum ("orientation",
-						      "orientation",
-						      "orientation",
-						      GTK_TYPE_ORIENTATION,
-						      GTK_ORIENTATION_HORIZONTAL,
-						      G_PARAM_READWRITE |
-						      G_PARAM_CONSTRUCT |
-						      G_PARAM_STATIC_NAME |
-						      G_PARAM_STATIC_NICK |
-						      G_PARAM_STATIC_BLURB));
-
-  manager_signals[TRAY_ICON_ADDED] =
-    g_signal_new ("tray_icon_added",
-		  G_OBJECT_CLASS_TYPE (klass),
-		  G_SIGNAL_RUN_LAST,
-		  G_STRUCT_OFFSET (NaTrayManagerClass, tray_icon_added),
-		  NULL, NULL, NULL,
-		  G_TYPE_NONE, 1,
-		  GTK_TYPE_SOCKET);
-
-  manager_signals[TRAY_ICON_REMOVED] =
-    g_signal_new ("tray_icon_removed",
-		  G_OBJECT_CLASS_TYPE (klass),
-		  G_SIGNAL_RUN_LAST,
-		  G_STRUCT_OFFSET (NaTrayManagerClass, tray_icon_removed),
-		  NULL, NULL, NULL,
-		  G_TYPE_NONE, 1,
-		  GTK_TYPE_SOCKET);
-  manager_signals[MESSAGE_SENT] =
-    g_signal_new ("message_sent",
-		  G_OBJECT_CLASS_TYPE (klass),
-		  G_SIGNAL_RUN_LAST,
-		  G_STRUCT_OFFSET (NaTrayManagerClass, message_sent),
-		  NULL, NULL, NULL,
-		  G_TYPE_NONE, 4,
-		  GTK_TYPE_SOCKET,
-		  G_TYPE_STRING,
-		  G_TYPE_LONG,
-		  G_TYPE_LONG);
-  manager_signals[MESSAGE_CANCELLED] =
-    g_signal_new ("message_cancelled",
-		  G_OBJECT_CLASS_TYPE (klass),
-		  G_SIGNAL_RUN_LAST,
-		  G_STRUCT_OFFSET (NaTrayManagerClass, message_cancelled),
-		  NULL, NULL, NULL,
-		  G_TYPE_NONE, 2,
-		  GTK_TYPE_SOCKET,
-		  G_TYPE_LONG);
-  manager_signals[LOST_SELECTION] =
-    g_signal_new ("lost_selection",
-		  G_OBJECT_CLASS_TYPE (klass),
-		  G_SIGNAL_RUN_LAST,
-		  G_STRUCT_OFFSET (NaTrayManagerClass, lost_selection),
-		  NULL, NULL, NULL,
-		  G_TYPE_NONE, 0);
-
-#if defined (GDK_WINDOWING_X11)
-  /* Nothing */
-#elif defined (GDK_WINDOWING_WIN32)
-  g_warning ("Port NaTrayManager to Win32");
-#else
-  g_warning ("Port NaTrayManager to this GTK+ backend");
-#endif
-}
-
-static void
-na_tray_manager_finalize (GObject *object)
-{
-  NaTrayManager *manager;
-
-  manager = NA_TRAY_MANAGER (object);
-
-  na_tray_manager_unmanage (manager);
-
-  g_list_free (manager->messages);
-  g_hash_table_destroy (manager->socket_table);
-
-  G_OBJECT_CLASS (na_tray_manager_parent_class)->finalize (object);
-}
-
-static void
-na_tray_manager_set_property (GObject      *object,
-			      guint         prop_id,
-			      const GValue *value,
-			      GParamSpec   *pspec)
-{
-  NaTrayManager *manager = NA_TRAY_MANAGER (object);
-
-  switch (prop_id)
-    {
-    case PROP_ORIENTATION:
-      na_tray_manager_set_orientation (manager, g_value_get_enum (value));
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
-static void
-na_tray_manager_get_property (GObject    *object,
-			      guint       prop_id,
-			      GValue     *value,
-			      GParamSpec *pspec)
-{
-  NaTrayManager *manager = NA_TRAY_MANAGER (object);
-
-  switch (prop_id)
-    {
-    case PROP_ORIENTATION:
-      g_value_set_enum (value, manager->orientation);
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
-NaTrayManager *
-na_tray_manager_new (void)
-{
-  NaTrayManager *manager;
-
-  manager = g_object_new (NA_TYPE_TRAY_MANAGER, NULL);
-
-  return manager;
-}
-
-#ifdef GDK_WINDOWING_X11
-
-static gboolean
-na_tray_manager_plug_removed (GtkSocket       *socket,
-			      NaTrayManager   *manager)
-{
-  NaTrayChild *child = NA_TRAY_CHILD (socket);
-
-  g_hash_table_remove (manager->socket_table,
-                       GINT_TO_POINTER (child->icon_window));
-  g_signal_emit (manager, manager_signals[TRAY_ICON_REMOVED], 0, child);
-
-  /* This destroys the socket. */
-  return FALSE;
-}
-
-static void
-na_tray_manager_handle_dock_request (NaTrayManager       *manager,
-				     XClientMessageEvent *xevent)
-{
-  Window icon_window = xevent->data.l[2];
-  GtkWidget *child;
-
-  if (g_hash_table_lookup (manager->socket_table,
-                           GINT_TO_POINTER (icon_window)))
-    {
-      /* We already got this notification earlier, ignore this one */
-      return;
-    }
-
-  child = na_tray_child_new (manager->screen, icon_window);
-  if (child == NULL) /* already gone or other error */
-    return;
-
-  g_signal_emit (manager, manager_signals[TRAY_ICON_ADDED], 0,
-		 child);
-
-  /* If the child wasn't attached, then destroy it */
-
-  if (!GTK_IS_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (child))))
-    {
-      gtk_widget_destroy (child);
-      return;
-    }
-
-  g_signal_connect (child, "plug_removed",
-		    G_CALLBACK (na_tray_manager_plug_removed), manager);
-
-  gtk_socket_add_id (GTK_SOCKET (child), icon_window);
-
-  if (!gtk_socket_get_plug_window (GTK_SOCKET (child)))
-    {
-      /* Embedding failed, we won't get a plug-removed signal */
-      /* This signal destroys the socket */
-      g_signal_emit (manager, manager_signals[TRAY_ICON_REMOVED], 0, child);
-      return;
-    }
-
-  g_hash_table_insert (manager->socket_table,
-                       GINT_TO_POINTER (icon_window), child);
-  gtk_widget_show (child);
-}
-
-static void
-pending_message_free (PendingMessage *message)
-{
-  g_free (message->str);
-  g_free (message);
-}
-
-static void
-na_tray_manager_handle_message_data (NaTrayManager       *manager,
-				     XClientMessageEvent *xevent)
-{
-  GList *p;
-  int    len;
-
-  /* Try to see if we can find the pending message in the list */
-  for (p = manager->messages; p; p = p->next)
-    {
-      PendingMessage *msg = p->data;
-
-      if (xevent->window == msg->window)
-	{
-	  /* Append the message */
-	  len = MIN (msg->remaining_len, 20);
-
-	  memcpy ((msg->str + msg->len - msg->remaining_len),
-		  &xevent->data, len);
-	  msg->remaining_len -= len;
-
-	  if (msg->remaining_len == 0)
-	    {
-	      GtkSocket *socket;
-
-	      socket = g_hash_table_lookup (manager->socket_table,
-                                            GINT_TO_POINTER (msg->window));
-
-	      if (socket)
-		  g_signal_emit (manager, manager_signals[MESSAGE_SENT], 0,
-				 socket, msg->str, msg->id, msg->timeout);
-
-	      pending_message_free (msg);
-	      manager->messages = g_list_remove_link (manager->messages, p);
-              g_list_free_1 (p);
-	    }
-
-          break;
-	}
-    }
-}
-
-static void
-na_tray_manager_handle_begin_message (NaTrayManager       *manager,
-				      XClientMessageEvent *xevent)
-{
-  GtkSocket      *socket;
-  GList          *p;
-  PendingMessage *msg;
-  long            timeout;
-  long            len;
-  long            id;
-
-  socket = g_hash_table_lookup (manager->socket_table,
-                                GINT_TO_POINTER (xevent->window));
-  /* we don't know about this tray icon, so ignore the message */
-  if (!socket)
-    return;
-
-  timeout = xevent->data.l[2];
-  len     = xevent->data.l[3];
-  id      = xevent->data.l[4];
-
-  /* Check if the same message is already in the queue and remove it if so */
-  for (p = manager->messages; p; p = p->next)
-    {
-      PendingMessage *pmsg = p->data;
-
-      if (xevent->window == pmsg->window &&
-	  id == pmsg->id)
-	{
-	  /* Hmm, we found it, now remove it */
-	  pending_message_free (pmsg);
-	  manager->messages = g_list_remove_link (manager->messages, p);
-          g_list_free_1 (p);
-	  break;
-	}
-    }
-
-  if (len == 0)
-    {
-      g_signal_emit (manager, manager_signals[MESSAGE_SENT], 0,
-                     socket, "", id, timeout);
-    }
-  else
-    {
-      /* Now add the new message to the queue */
-      msg = g_new0 (PendingMessage, 1);
-      msg->window = xevent->window;
-      msg->timeout = timeout;
-      msg->len = len;
-      msg->id = id;
-      msg->remaining_len = msg->len;
-      msg->str = g_malloc (msg->len + 1);
-      msg->str[msg->len] = '\0';
-      manager->messages = g_list_prepend (manager->messages, msg);
-    }
-}
-
-static void
-na_tray_manager_handle_cancel_message (NaTrayManager       *manager,
-				       XClientMessageEvent *xevent)
-{
-  GList     *p;
-  GtkSocket *socket;
-  long       id;
-
-  id = xevent->data.l[2];
-
-  /* Check if the message is in the queue and remove it if so */
-  for (p = manager->messages; p; p = p->next)
-    {
-      PendingMessage *msg = p->data;
-
-      if (xevent->window == msg->window &&
-	  id == msg->id)
-	{
-	  pending_message_free (msg);
-	  manager->messages = g_list_remove_link (manager->messages, p);
-          g_list_free_1 (p);
-	  break;
-	}
-    }
-
-  socket = g_hash_table_lookup (manager->socket_table,
-                                GINT_TO_POINTER (xevent->window));
-
-  if (socket)
-    {
-      g_signal_emit (manager, manager_signals[MESSAGE_CANCELLED], 0,
-		     socket, xevent->data.l[2]);
-    }
-}
-
-static GdkFilterReturn
-na_tray_manager_window_filter (GdkXEvent *xev,
-                               GdkEvent  *event,
-                               gpointer   data)
-{
-  XEvent        *xevent = (GdkXEvent *)xev;
-  NaTrayManager *manager = data;
-
-  if (xevent->type == ClientMessage)
-    {
-      /* _NET_SYSTEM_TRAY_OPCODE: SYSTEM_TRAY_REQUEST_DOCK */
-      if (xevent->xclient.message_type == manager->opcode_atom &&
-          xevent->xclient.data.l[1]    == SYSTEM_TRAY_REQUEST_DOCK)
-	{
-          na_tray_manager_handle_dock_request (manager,
-                                               (XClientMessageEvent *) xevent);
-          return GDK_FILTER_REMOVE;
-	}
-      /* _NET_SYSTEM_TRAY_OPCODE: SYSTEM_TRAY_BEGIN_MESSAGE */
-      else if (xevent->xclient.message_type == manager->opcode_atom &&
-               xevent->xclient.data.l[1]    == SYSTEM_TRAY_BEGIN_MESSAGE)
-        {
-          na_tray_manager_handle_begin_message (manager,
-                                                (XClientMessageEvent *) event);
-          return GDK_FILTER_REMOVE;
-        }
-      /* _NET_SYSTEM_TRAY_OPCODE: SYSTEM_TRAY_CANCEL_MESSAGE */
-      else if (xevent->xclient.message_type == manager->opcode_atom &&
-               xevent->xclient.data.l[1]    == SYSTEM_TRAY_CANCEL_MESSAGE)
-        {
-          na_tray_manager_handle_cancel_message (manager,
-                                                 (XClientMessageEvent *) event);
-          return GDK_FILTER_REMOVE;
-        }
-      /* _NET_SYSTEM_TRAY_MESSAGE_DATA */
-      else if (xevent->xclient.message_type == manager->message_data_atom)
-        {
-          na_tray_manager_handle_message_data (manager,
-                                               (XClientMessageEvent *) event);
-          return GDK_FILTER_REMOVE;
-        }
-    }
-  else if (xevent->type == SelectionClear)
-    {
-      g_signal_emit (manager, manager_signals[LOST_SELECTION], 0);
-      na_tray_manager_unmanage (manager);
-    }
-
-  return GDK_FILTER_CONTINUE;
-}
-
-#if 0
-//FIXME investigate why this doesn't work
-static gboolean
-na_tray_manager_selection_clear_event (GtkWidget         *widget,
-                                       GdkEventSelection *event,
-                                       NaTrayManager     *manager)
-{
-  g_signal_emit (manager, manager_signals[LOST_SELECTION], 0);
-  na_tray_manager_unmanage (manager);
-
-  return FALSE;
-}
-#endif
-#endif
-
-static void
-na_tray_manager_unmanage (NaTrayManager *manager)
-{
-#ifdef GDK_WINDOWING_X11
-  GdkDisplay *display;
-  guint32     timestamp;
-  GtkWidget  *invisible;
-  GdkWindow  *window;
-
-  if (manager->invisible == NULL)
-    return;
-
-  invisible = manager->invisible;
-  window = gtk_widget_get_window (invisible);
-
-  g_assert (GTK_IS_INVISIBLE (invisible));
-  g_assert (gtk_widget_get_realized (invisible));
-  g_assert (GDK_IS_WINDOW (window));
-
-  display = gtk_widget_get_display (invisible);
-
-  if (gdk_selection_owner_get_for_display (display, manager->selection_atom) ==
-      window)
-    {
-      timestamp = gdk_x11_get_server_time (window);
-      gdk_selection_owner_set_for_display (display,
-                                           NULL,
-                                           manager->selection_atom,
-                                           timestamp,
-                                           TRUE);
-    }
-
-  gdk_window_remove_filter (window,
-                            na_tray_manager_window_filter, manager);
-
-  manager->invisible = NULL; /* prior to destroy for reentrancy paranoia */
-  gtk_widget_destroy (invisible);
-  g_object_unref (G_OBJECT (invisible));
-#endif
-}
-
-static void
-na_tray_manager_set_orientation_property (NaTrayManager *manager)
-{
-#ifdef GDK_WINDOWING_X11
-  GdkWindow  *window;
-  GdkDisplay *display;
-  Atom        orientation_atom;
-  gulong      data[1];
-
-  g_return_if_fail (manager->invisible != NULL);
-  window = gtk_widget_get_window (manager->invisible);
-  g_return_if_fail (window != NULL);
-
-  display = gtk_widget_get_display (manager->invisible);
-  orientation_atom = gdk_x11_get_xatom_by_name_for_display (display,
-                                                            "_NET_SYSTEM_TRAY_ORIENTATION");
-
-  data[0] = manager->orientation == GTK_ORIENTATION_HORIZONTAL ?
-		SYSTEM_TRAY_ORIENTATION_HORZ :
-		SYSTEM_TRAY_ORIENTATION_VERT;
-
-  XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-		   GDK_WINDOW_XID (window),
-                   orientation_atom,
-		   XA_CARDINAL, 32,
-		   PropModeReplace,
-		   (guchar *) &data, 1);
-#endif
-}
-
-static void
-na_tray_manager_set_visual_property (NaTrayManager *manager)
-{
-#ifdef GDK_WINDOWING_X11
-  GdkWindow  *window;
-  GdkDisplay *display;
-  Visual     *xvisual;
-  Atom        visual_atom;
-  gulong      data[1];
-
-  g_return_if_fail (manager->invisible != NULL);
-  window = gtk_widget_get_window (manager->invisible);
-  g_return_if_fail (window != NULL);
-
-  /* The visual property is a hint to the tray icons as to what visual they
-   * should use for their windows. If the X server has RGBA colormaps, then
-   * we tell the tray icons to use a RGBA colormap and we'll composite the
-   * icon onto its parents with real transparency. Otherwise, we just tell
-   * the icon to use our colormap, and we'll do some hacks with parent
-   * relative backgrounds to simulate transparency.
-   */
-
-  display = gtk_widget_get_display (manager->invisible);
-  visual_atom = gdk_x11_get_xatom_by_name_for_display (display,
-						       "_NET_SYSTEM_TRAY_VISUAL");
-
-  if (gdk_screen_get_rgba_visual (manager->screen) != NULL &&
-      gdk_screen_is_composited (manager->screen))
-    xvisual = GDK_VISUAL_XVISUAL (gdk_screen_get_rgba_visual (manager->screen));
-  else
-    {
-      /* We actually want the visual of the tray where the icons will
-       * be embedded. In almost all cases, this will be the same as the visual
-       * of the screen.
-       */
-      xvisual = GDK_VISUAL_XVISUAL (gdk_screen_get_system_visual (manager->screen));
-    }
-
-  data[0] = XVisualIDFromVisual (xvisual);
-
-  XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-                   GDK_WINDOW_XID (window),
-                   visual_atom,
-                   XA_VISUALID, 32,
-                   PropModeReplace,
-                   (guchar *) &data, 1);
-#endif
-}
-
-static void
-na_tray_manager_set_padding_property (NaTrayManager *manager)
-{
-#ifdef GDK_WINDOWING_X11
-  GdkWindow  *window;
-  GdkDisplay *display;
-  Atom        atom;
-  gulong      data[1];
-
-  g_return_if_fail (manager->invisible != NULL);
-  window = gtk_widget_get_window (manager->invisible);
-  g_return_if_fail (window != NULL);
-
-  display = gtk_widget_get_display (manager->invisible);
-  atom = gdk_x11_get_xatom_by_name_for_display (display,
-                                                "_NET_SYSTEM_TRAY_PADDING");
-
-  data[0] = manager->padding;
-
-  XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-                   GDK_WINDOW_XID (window),
-                   atom,
-                   XA_CARDINAL, 32,
-                   PropModeReplace,
-                   (guchar *) &data, 1);
-#endif
-}
-
-static void
-na_tray_manager_set_icon_size_property (NaTrayManager *manager)
-{
-#ifdef GDK_WINDOWING_X11
-  GdkWindow  *window;
-  GdkDisplay *display;
-  Atom        atom;
-  gulong      data[1];
-
-  g_return_if_fail (manager->invisible != NULL);
-  window = gtk_widget_get_window (manager->invisible);
-  g_return_if_fail (window != NULL);
-
-  display = gtk_widget_get_display (manager->invisible);
-  atom = gdk_x11_get_xatom_by_name_for_display (display,
-                                                "_NET_SYSTEM_TRAY_ICON_SIZE");
-
-  data[0] = manager->icon_size;
-
-  XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-                   GDK_WINDOW_XID (window),
-                   atom,
-                   XA_CARDINAL, 32,
-                   PropModeReplace,
-                   (guchar *) &data, 1);
-#endif
-}
-
-static void
-na_tray_manager_set_colors_property (NaTrayManager *manager)
-{
-#ifdef GDK_WINDOWING_X11
-  GdkWindow  *window;
-  GdkDisplay *display;
-  Atom        atom;
-  gulong      data[12];
-
-  g_return_if_fail (manager->invisible != NULL);
-  window = gtk_widget_get_window (manager->invisible);
-  g_return_if_fail (window != NULL);
-
-  display = gtk_widget_get_display (manager->invisible);
-  atom = gdk_x11_get_xatom_by_name_for_display (display,
-                                                "_NET_SYSTEM_TRAY_COLORS");
-
-  data[0] = manager->fg.red * 65535;
-  data[1] = manager->fg.green * 65535;
-  data[2] = manager->fg.blue * 65535;
-  data[3] = manager->error.red * 65535;
-  data[4] = manager->error.green * 65535;
-  data[5] = manager->error.blue * 65535;
-  data[6] = manager->warning.red * 65535;
-  data[7] = manager->warning.green * 65535;
-  data[8] = manager->warning.blue * 65535;
-  data[9] = manager->success.red * 65535;
-  data[10] = manager->success.green * 65535;
-  data[11] = manager->success.blue * 65535;
-
-  XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-                   GDK_WINDOW_XID (window),
-                   atom,
-                   XA_CARDINAL, 32,
-                   PropModeReplace,
-                   (guchar *) &data, 12);
-#endif
-}
-
-#ifdef GDK_WINDOWING_X11
-
-static gboolean
-na_tray_manager_manage_screen_x11 (NaTrayManager *manager,
-				   GdkScreen     *screen)
-{
-  GdkDisplay *display;
-  Screen     *xscreen;
-  GtkWidget  *invisible;
-  GdkWindow  *window;
-  char       *selection_atom_name;
-  guint32     timestamp;
-
-  g_return_val_if_fail (NA_IS_TRAY_MANAGER (manager), FALSE);
-  g_return_val_if_fail (manager->screen == NULL, FALSE);
-
-  /* If there's already a manager running on the screen
-   * we can't create another one.
-   */
-#if 0
-  if (na_tray_manager_check_running_screen_x11 (screen))
-    return FALSE;
-#endif
-
-  manager->screen = screen;
-
-  display = gdk_screen_get_display (screen);
-  xscreen = GDK_SCREEN_XSCREEN (screen);
-
-  invisible = gtk_invisible_new_for_screen (screen);
-  gtk_widget_realize (invisible);
-
-  gtk_widget_add_events (invisible,
-                         GDK_PROPERTY_CHANGE_MASK | GDK_STRUCTURE_MASK);
-
-  selection_atom_name = g_strdup_printf ("_NET_SYSTEM_TRAY_S%d",
-					 gdk_x11_screen_get_screen_number (screen));
-  manager->selection_atom = gdk_atom_intern (selection_atom_name, FALSE);
-  g_free (selection_atom_name);
-
-  manager->invisible = invisible;
-  g_object_ref (G_OBJECT (manager->invisible));
-
-  na_tray_manager_set_orientation_property (manager);
-  na_tray_manager_set_visual_property (manager);
-  na_tray_manager_set_padding_property (manager);
-  na_tray_manager_set_icon_size_property (manager);
-  na_tray_manager_set_colors_property (manager);
-
-  window = gtk_widget_get_window (invisible);
-
-  timestamp = gdk_x11_get_server_time (window);
-
-  /* Check if we could set the selection owner successfully */
-  if (gdk_selection_owner_set_for_display (display,
-                                           window,
-                                           manager->selection_atom,
-                                           timestamp,
-                                           TRUE))
-    {
-      XClientMessageEvent xev;
-      GdkAtom             opcode_atom;
-      GdkAtom             message_data_atom;
-
-      xev.type = ClientMessage;
-      xev.window = RootWindowOfScreen (xscreen);
-      xev.message_type = gdk_x11_get_xatom_by_name_for_display (display,
-                                                                "MANAGER");
-
-      xev.format = 32;
-      xev.data.l[0] = timestamp;
-      xev.data.l[1] = gdk_x11_atom_to_xatom_for_display (display,
-                                                         manager->selection_atom);
-      xev.data.l[2] = GDK_WINDOW_XID (window);
-      xev.data.l[3] = 0;	/* manager specific data */
-      xev.data.l[4] = 0;	/* manager specific data */
-
-      XSendEvent (GDK_DISPLAY_XDISPLAY (display),
-		  RootWindowOfScreen (xscreen),
-		  False, StructureNotifyMask, (XEvent *)&xev);
-
-      opcode_atom = gdk_atom_intern ("_NET_SYSTEM_TRAY_OPCODE", FALSE);
-      manager->opcode_atom = gdk_x11_atom_to_xatom_for_display (display,
-                                                                opcode_atom);
-
-      message_data_atom = gdk_atom_intern ("_NET_SYSTEM_TRAY_MESSAGE_DATA",
-                                           FALSE);
-      manager->message_data_atom = gdk_x11_atom_to_xatom_for_display (display,
-                                                                      message_data_atom);
-
-      /* Add a window filter */
-#if 0
-      /* This is for when we lose the selection of _NET_SYSTEM_TRAY_Sx */
-      g_signal_connect (invisible, "selection-clear-event",
-                        G_CALLBACK (na_tray_manager_selection_clear_event),
-                        manager);
-#endif
-      gdk_window_add_filter (window,
-                             na_tray_manager_window_filter, manager);
-      return TRUE;
-    }
-  else
-    {
-      gtk_widget_destroy (invisible);
-      g_object_unref (invisible);
-      manager->invisible = NULL;
-
-      manager->screen = NULL;
-
-      return FALSE;
-    }
-}
-
-#endif
-
-gboolean
-na_tray_manager_manage_screen (NaTrayManager *manager,
-			       GdkScreen     *screen)
-{
-  g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
-  g_return_val_if_fail (manager->screen == NULL, FALSE);
-
-#ifdef GDK_WINDOWING_X11
-  return na_tray_manager_manage_screen_x11 (manager, screen);
-#else
-  return FALSE;
-#endif
-}
-
-#ifdef GDK_WINDOWING_X11
-
-static gboolean
-na_tray_manager_check_running_screen_x11 (GdkScreen *screen)
-{
-  GdkDisplay *display;
-  Atom        selection_atom;
-  char       *selection_atom_name;
-
-  display = gdk_screen_get_display (screen);
-  selection_atom_name = g_strdup_printf ("_NET_SYSTEM_TRAY_S%d",
-                                         gdk_x11_screen_get_screen_number (screen));
-  selection_atom = gdk_x11_get_xatom_by_name_for_display (display,
-                                                          selection_atom_name);
-  g_free (selection_atom_name);
-
-  if (XGetSelectionOwner (GDK_DISPLAY_XDISPLAY (display),
-                          selection_atom) != None)
-    return TRUE;
-  else
-    return FALSE;
-}
-
-#endif
-
-gboolean
-na_tray_manager_check_running (GdkScreen *screen)
-{
-  g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
-
-#ifdef GDK_WINDOWING_X11
-  return na_tray_manager_check_running_screen_x11 (screen);
-#else
-  return FALSE;
-#endif
-}
-
-void
-na_tray_manager_set_orientation (NaTrayManager  *manager,
-				 GtkOrientation  orientation)
-{
-  g_return_if_fail (NA_IS_TRAY_MANAGER (manager));
-
-  if (manager->orientation != orientation)
-    {
-      manager->orientation = orientation;
-
-      na_tray_manager_set_orientation_property (manager);
-
-      g_object_notify (G_OBJECT (manager), "orientation");
-    }
-}
-
-void
-na_tray_manager_set_padding (NaTrayManager *manager,
-                             gint           padding)
-{
-  g_return_if_fail (NA_IS_TRAY_MANAGER (manager));
-
-  if (manager->padding != padding)
-    {
-      manager->padding = padding;
-
-      na_tray_manager_set_padding_property (manager);
-    }
-}
-
-void
-na_tray_manager_set_icon_size (NaTrayManager *manager,
-                               gint           icon_size)
-{
-  g_return_if_fail (NA_IS_TRAY_MANAGER (manager));
-
-  if (manager->icon_size != icon_size)
-    {
-      manager->icon_size = icon_size;
-
-      na_tray_manager_set_icon_size_property (manager);
-    }
-}
-
-void
-na_tray_manager_set_colors (NaTrayManager *manager,
-                            GdkRGBA       *fg,
-                            GdkRGBA       *error,
-                            GdkRGBA       *warning,
-                            GdkRGBA       *success)
-{
-  g_return_if_fail (NA_IS_TRAY_MANAGER (manager));
-
-  if (!gdk_rgba_equal (&manager->fg, fg) ||
-      !gdk_rgba_equal (&manager->error, error) ||
-      !gdk_rgba_equal (&manager->warning, warning) ||
-      !gdk_rgba_equal (&manager->success, success))
-    {
-      manager->fg = *fg;
-      manager->error = *error;
-      manager->warning = *warning;
-      manager->success = *success;
-
-      na_tray_manager_set_colors_property (manager);
-    }
-}
-
-GtkOrientation
-na_tray_manager_get_orientation (NaTrayManager *manager)
-{
-  g_return_val_if_fail (NA_IS_TRAY_MANAGER (manager), GTK_ORIENTATION_HORIZONTAL);
-
-  return manager->orientation;
-}
diff --git a/src/imports/natray/na-tray-manager.h b/src/imports/natray/na-tray-manager.h
deleted file mode 100644
index 1fede4ab..00000000
--- a/src/imports/natray/na-tray-manager.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
-/* na-tray-manager.h
- * Copyright (C) 2002 Anders Carlsson <andersca@gnu.org>
- * Copyright (C) 2003-2006 Vincent Untz
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see <http://www.gnu.org/licenses/>.
- *
- * Used to be: eggtraymanager.h
- */
-
-#ifndef __NA_TRAY_MANAGER_H__
-#define __NA_TRAY_MANAGER_H__
-
-#ifdef GDK_WINDOWING_X11
-#include <gdk/gdkx.h>
-#endif
-#include <gtk/gtk.h>
-
-#include "na-tray-child.h"
-
-G_BEGIN_DECLS
-
-#define NA_TYPE_TRAY_MANAGER			(na_tray_manager_get_type ())
-#define NA_TRAY_MANAGER(obj)			(G_TYPE_CHECK_INSTANCE_CAST ((obj), NA_TYPE_TRAY_MANAGER, NaTrayManager))
-#define NA_TRAY_MANAGER_CLASS(klass)		(G_TYPE_CHECK_CLASS_CAST ((klass), NA_TYPE_TRAY_MANAGER, NaTrayManagerClass))
-#define NA_IS_TRAY_MANAGER(obj)			(G_TYPE_CHECK_INSTANCE_TYPE ((obj), NA_TYPE_TRAY_MANAGER))
-#define NA_IS_TRAY_MANAGER_CLASS(klass)		(G_TYPE_CHECK_CLASS_TYPE ((klass), NA_TYPE_TRAY_MANAGER))
-#define NA_TRAY_MANAGER_GET_CLASS(obj)		(G_TYPE_INSTANCE_GET_CLASS ((obj), NA_TYPE_TRAY_MANAGER, NaTrayManagerClass))
-
-typedef struct _NaTrayManager	    NaTrayManager;
-typedef struct _NaTrayManagerClass  NaTrayManagerClass;
-
-struct _NaTrayManager
-{
-  GObject parent_instance;
-
-#ifdef GDK_WINDOWING_X11
-  GdkAtom selection_atom;
-  Atom    opcode_atom;
-  Atom    message_data_atom;
-#endif
-
-  GtkWidget *invisible;
-  GdkScreen *screen;
-  GtkOrientation orientation;
-  gint padding;
-  gint icon_size;
-  GdkRGBA fg;
-  GdkRGBA error;
-  GdkRGBA warning;
-  GdkRGBA success;
-
-  GList *messages;
-  GHashTable *socket_table;
-};
-
-struct _NaTrayManagerClass
-{
-  GObjectClass parent_class;
-
-  void (* tray_icon_added)   (NaTrayManager      *manager,
-			      NaTrayChild        *child);
-  void (* tray_icon_removed) (NaTrayManager      *manager,
-			      NaTrayChild        *child);
-
-  void (* message_sent)      (NaTrayManager      *manager,
-			      NaTrayChild        *child,
-			      const gchar        *message,
-			      glong               id,
-			      glong               timeout);
-
-  void (* message_cancelled) (NaTrayManager      *manager,
-			      NaTrayChild        *child,
-			      glong               id);
-
-  void (* lost_selection)    (NaTrayManager      *manager);
-};
-
-GType           na_tray_manager_get_type        (void);
-
-gboolean        na_tray_manager_check_running   (GdkScreen          *screen);
-NaTrayManager  *na_tray_manager_new             (void);
-gboolean        na_tray_manager_manage_screen   (NaTrayManager      *manager,
-						 GdkScreen          *screen);
-void            na_tray_manager_set_orientation (NaTrayManager      *manager,
-						 GtkOrientation      orientation);
-GtkOrientation  na_tray_manager_get_orientation (NaTrayManager      *manager);
-void            na_tray_manager_set_padding     (NaTrayManager      *manager,
-						 gint                padding);
-void            na_tray_manager_set_icon_size   (NaTrayManager      *manager,
-						 gint                padding);
-void            na_tray_manager_set_colors      (NaTrayManager      *manager,
-						 GdkRGBA            *fg,
-						 GdkRGBA            *error,
-						 GdkRGBA            *warning,
-						 GdkRGBA            *success);
-
-
-G_END_DECLS
-
-#endif /* __NA_TRAY_MANAGER_H__ */
diff --git a/src/imports/natray/na-tray.c b/src/imports/natray/na-tray.c
deleted file mode 100644
index ebe520da..00000000
--- a/src/imports/natray/na-tray.c
+++ /dev/null
@@ -1,676 +0,0 @@
-/*
- * Copyright (C) 2002 Red Hat, Inc.
- * Copyright (C) 2003-2006 Vincent Untz
- * Copyright (C) 2007 Christian Persch
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "config.h"
-
-#include <gtk/gtk.h>
-#include <string.h>
-
-#include "na-tray.h"
-#include "na-tray-manager.h"
-#include "fixedtip.h"
-
-#define ICON_SPACING 3
-#define MIN_BOX_SIZE 3
-
-struct _NaTray
-{
-  GtkBin          parent;
-
-  NaTrayManager  *tray_manager;
-  GHashTable     *icon_table;
-  GHashTable     *tip_table;
-
-  GtkWidget      *box;
-
-  GtkOrientation  orientation;
-};
-
-typedef struct
-{
-  char  *text;
-  glong  id;
-  glong  timeout;
-} IconTipBuffer;
-
-typedef struct
-{
-  NaTray     *tray;      /* tray containing the tray icon */
-  GtkWidget  *icon;      /* tray icon sending the message */
-  GtkWidget  *fixedtip;
-  guint       source_id;
-  glong       id;        /* id of the current message */
-  GSList     *buffer;    /* buffered messages */
-} IconTip;
-
-enum
-{
-  PROP_0,
-  PROP_ORIENTATION,
-};
-
-static void icon_tip_show_next (IconTip *icontip);
-
-G_DEFINE_TYPE (NaTray, na_tray, GTK_TYPE_BIN)
-
-const char *ordered_roles[] = {
-  "keyboard",
-  "volume",
-  "bluetooth",
-  "network",
-  "battery",
-  NULL
-};
-
-const char *wmclass_roles[] = {
-  "Bluetooth-applet", "bluetooth",
-  "Gnome-volume-control-applet", "volume",
-  "Nm-applet", "network",
-  "Gnome-power-manager", "battery",
-  "keyboard", "keyboard",
-  NULL,
-};
-
-static const char *
-find_role (const char *wmclass)
-{
-  int i;
-
-  for (i = 0; wmclass_roles[i]; i += 2)
-    {
-      if (strcmp (wmclass, wmclass_roles[i]) == 0)
-        return wmclass_roles[i + 1];
-    }
-
-  return NULL;
-}
-
-static int
-find_role_position (const char *role)
-{
-  int i;
-
-  for (i = 0; ordered_roles[i]; i++)
-    {
-      if (strcmp (role, ordered_roles[i]) == 0)
-        break;
-    }
-
-  return i + 1;
-}
-
-static int
-find_icon_position (NaTray    *tray,
-                    GtkWidget *icon)
-{
-  int            position;
-  char          *class_a;
-  const char    *role;
-  int            role_position;
-  GList         *l, *children;
-
-  /* We insert the icons with a known roles in a specific order (the one
-   * defined by ordered_roles), and all other icons at the beginning of the box
-   * (left in LTR). */
-
-  position = 0;
-
-  class_a = NULL;
-  na_tray_child_get_wm_class (NA_TRAY_CHILD (icon), NULL, &class_a);
-  if (!class_a)
-    return position;
-
-  role = find_role (class_a);
-  g_free (class_a);
-  if (!role)
-    return position;
-
-  role_position = find_role_position (role);
-  g_object_set_data (G_OBJECT (icon), "role-position", GINT_TO_POINTER (role_position));
-
-  children = gtk_container_get_children (GTK_CONTAINER (tray->box));
-  for (l = g_list_last (children); l; l = l->prev)
-    {
-      GtkWidget *child = l->data;
-      int        rp;
-
-      rp = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (child), "role-position"));
-      if (rp == 0 || rp < role_position)
-        {
-          position = g_list_index (children, child) + 1;
-          break;
-        }
-    }
-  g_list_free (children);
-
-  /* should never happen, but it doesn't hurt to be on the safe side */
-  if (position < 0)
-    position = 0;
-
-  return position;
-}
-
-static void
-tray_added (NaTrayManager *manager,
-            GtkWidget     *icon,
-            NaTray        *tray)
-{
-  int position;
-
-  g_hash_table_insert (tray->icon_table, icon, tray);
-
-  position = find_icon_position (tray, icon);
-  gtk_box_pack_start (GTK_BOX (tray->box), icon, FALSE, FALSE, 0);
-  gtk_box_reorder_child (GTK_BOX (tray->box), icon, position);
-
-  gtk_widget_show (icon);
-}
-
-static void
-tray_removed (NaTrayManager *manager,
-              GtkWidget     *icon,
-              NaTray        *tray)
-{
-  NaTray *icon_tray;
-
-  icon_tray = g_hash_table_lookup (tray->icon_table, icon);
-  if (icon_tray == NULL)
-    return;
-
-  g_assert (icon_tray == tray);
-
-  gtk_container_remove (GTK_CONTAINER (tray->box), icon);
-
-  g_hash_table_remove (tray->icon_table, icon);
-  g_hash_table_remove (tray->tip_table, icon);
-}
-
-static void
-icon_tip_buffer_free (gpointer data,
-                      gpointer userdata)
-{
-  IconTipBuffer *buffer;
-
-  buffer = data;
-
-  g_free (buffer->text);
-  buffer->text = NULL;
-
-  g_free (buffer);
-}
-
-static void
-icon_tip_free (gpointer data)
-{
-  IconTip *icontip;
-
-  if (data == NULL)
-    return;
-
-  icontip = data;
-
-  if (icontip->fixedtip != NULL)
-    gtk_widget_destroy (GTK_WIDGET (icontip->fixedtip));
-  icontip->fixedtip = NULL;
-
-  if (icontip->source_id != 0)
-    g_source_remove (icontip->source_id);
-  icontip->source_id = 0;
-
-  if (icontip->buffer != NULL)
-    {
-      g_slist_foreach (icontip->buffer, icon_tip_buffer_free, NULL);
-      g_slist_free (icontip->buffer);
-    }
-  icontip->buffer = NULL;
-
-  g_free (icontip);
-}
-
-static int
-icon_tip_buffer_compare (gconstpointer a,
-                         gconstpointer b)
-{
-  const IconTipBuffer *buffer_a = a;
-  const IconTipBuffer *buffer_b = b;
-
-  if (buffer_a == NULL || buffer_b == NULL)
-    return !(buffer_a == buffer_b);
-
-  return buffer_a->id - buffer_b->id;
-}
-
-static void
-icon_tip_show_next_clicked (GtkWidget *widget,
-                            gpointer   data)
-{
-  icon_tip_show_next ((IconTip *) data);
-}
-
-static gboolean
-icon_tip_show_next_timeout (gpointer data)
-{
-  IconTip *icontip = (IconTip *) data;
-
-  icon_tip_show_next (icontip);
-
-  return FALSE;
-}
-
-static void
-icon_tip_show_next (IconTip *icontip)
-{
-  IconTipBuffer *buffer;
-
-  if (icontip->buffer == NULL)
-    {
-      /* this will also destroy the tip window */
-      g_hash_table_remove (icontip->tray->tip_table,
-                           icontip->icon);
-      return;
-    }
-
-  if (icontip->source_id != 0)
-    g_source_remove (icontip->source_id);
-  icontip->source_id = 0;
-
-  buffer = icontip->buffer->data;
-  icontip->buffer = g_slist_remove (icontip->buffer, buffer);
-
-  if (icontip->fixedtip == NULL)
-    {
-      icontip->fixedtip = na_fixed_tip_new (icontip->icon,
-                                            na_tray_get_orientation (icontip->tray));
-
-      g_signal_connect (icontip->fixedtip, "clicked",
-                        G_CALLBACK (icon_tip_show_next_clicked), icontip);
-    }
-
-  na_fixed_tip_set_markup (icontip->fixedtip, buffer->text);
-
-  if (!gtk_widget_get_mapped (icontip->fixedtip))
-    gtk_widget_show (icontip->fixedtip);
-
-  icontip->id = buffer->id;
-
-  if (buffer->timeout > 0)
-    icontip->source_id = g_timeout_add_seconds (buffer->timeout,
-                                                icon_tip_show_next_timeout,
-                                                icontip);
-
-  icon_tip_buffer_free (buffer, NULL);
-}
-
-static void
-message_sent (NaTrayManager *manager,
-              GtkWidget     *icon,
-              const char    *text,
-              glong          id,
-              glong          timeout,
-              NaTray        *tray)
-{
-  IconTip       *icontip;
-  IconTipBuffer  find_buffer;
-  IconTipBuffer *buffer;
-  gboolean       show_now;
-
-  icontip = g_hash_table_lookup (tray->tip_table, icon);
-
-  find_buffer.id = id;
-  if (icontip &&
-      (icontip->id == id ||
-       g_slist_find_custom (icontip->buffer, &find_buffer,
-                            icon_tip_buffer_compare) != NULL))
-    /* we already have this message, so ignore it */
-    /* FIXME: in an ideal world, we'd remember all the past ids and ignore them
-     * too */
-    return;
-
-  show_now = FALSE;
-
-  if (icontip == NULL)
-    {
-      NaTray *icon_tray;
-
-      icon_tray = g_hash_table_lookup (tray->icon_table, icon);
-      if (icon_tray == NULL)
-        {
-          /* We don't know about the icon sending the message, so ignore it.
-           * But this should never happen since NaTrayManager shouldn't send
-           * us the message if there's no socket for it. */
-          g_critical ("Ignoring a message sent by a tray icon "
-                      "we don't know: \"%s\".\n", text);
-          return;
-        }
-
-      icontip = g_new0 (IconTip, 1);
-      icontip->tray = tray;
-      icontip->icon = icon;
-
-      g_hash_table_insert (tray->tip_table, icon, icontip);
-
-      show_now = TRUE;
-    }
-
-  buffer = g_new0 (IconTipBuffer, 1);
-
-  buffer->text    = g_strdup (text);
-  buffer->id      = id;
-  buffer->timeout = timeout;
-
-  icontip->buffer = g_slist_append (icontip->buffer, buffer);
-
-  if (show_now)
-    icon_tip_show_next (icontip);
-}
-
-static void
-message_cancelled (NaTrayManager *manager,
-                   GtkWidget     *icon,
-                   glong          id,
-                   NaTray        *tray)
-{
-  IconTip       *icontip;
-  IconTipBuffer  find_buffer;
-  GSList        *cancel_buffer_l;
-  IconTipBuffer *cancel_buffer;
-
-  icontip = g_hash_table_lookup (tray->tip_table, icon);
-  if (icontip == NULL)
-    return;
-
-  if (icontip->id == id)
-    {
-      icon_tip_show_next (icontip);
-      return;
-    }
-
-  find_buffer.id = id;
-  cancel_buffer_l = g_slist_find_custom (icontip->buffer, &find_buffer,
-                                         icon_tip_buffer_compare);
-  if (cancel_buffer_l == NULL)
-    return;
-
-  cancel_buffer = cancel_buffer_l->data;
-  icon_tip_buffer_free (cancel_buffer, NULL);
-
-  icontip->buffer = g_slist_remove_link (icontip->buffer, cancel_buffer_l);
-  g_slist_free_1 (cancel_buffer_l);
-}
-
-static void
-update_orientation_for_messages (gpointer key,
-                                 gpointer value,
-                                 gpointer data)
-{
-  NaTray *tray;
-  IconTip    *icontip;
-
-  if (value == NULL)
-    return;
-
-  icontip = value;
-  tray    = data;
-  if (icontip->tray != tray)
-    return;
-
-  if (icontip->fixedtip)
-    na_fixed_tip_set_orientation (icontip->fixedtip, tray->orientation);
-}
-
-static void
-update_size_and_orientation (NaTray *tray)
-{
-  gtk_orientable_set_orientation (GTK_ORIENTABLE (tray->box), tray->orientation);
-
-  g_hash_table_foreach (tray->tip_table, update_orientation_for_messages, tray);
-
-  na_tray_manager_set_orientation (tray->tray_manager, tray->orientation);
-
-  /* note, you want this larger if the frame has non-NONE relief by default. */
-  switch (tray->orientation)
-    {
-    case GTK_ORIENTATION_VERTICAL:
-      /* Give box a min size so the frame doesn't look dumb */
-      gtk_widget_set_size_request (tray->box, MIN_BOX_SIZE, -1);
-      break;
-    case GTK_ORIENTATION_HORIZONTAL:
-      gtk_widget_set_size_request (tray->box, -1, MIN_BOX_SIZE);
-      break;
-    default:
-      g_assert_not_reached ();
-      break;
-    }
-}
-
-/* Children with alpha channels have been set to be composited by calling
- * gdk_window_set_composited(). We need to paint these children ourselves.
- */
-static void
-na_tray_draw_icon (GtkWidget *widget,
-		   gpointer   data)
-{
-  cairo_t *cr = (cairo_t *) data;
-
-  if (na_tray_child_has_alpha (NA_TRAY_CHILD (widget)))
-    {
-      GtkAllocation allocation;
-
-      gtk_widget_get_allocation (widget, &allocation);
-
-      cairo_save (cr);
-      gdk_cairo_set_source_window (cr,
-                                   gtk_widget_get_window (widget),
-				   allocation.x,
-				   allocation.y);
-      cairo_rectangle (cr, allocation.x, allocation.y, allocation.width, allocation.height);
-      cairo_clip (cr);
-      cairo_paint (cr);
-      cairo_restore (cr);
-    }
-}
-
-static gboolean
-na_tray_draw_box (GtkWidget *box,
-		  cairo_t   *cr)
-{
-  gtk_container_foreach (GTK_CONTAINER (box), na_tray_draw_icon, cr);
-  return TRUE;
-}
-
-static void
-na_tray_init (NaTray *tray)
-{
-  tray->orientation = GTK_ORIENTATION_HORIZONTAL;
-
-  tray->box = gtk_box_new (tray->orientation, ICON_SPACING);
-  g_signal_connect (tray->box, "draw", G_CALLBACK (na_tray_draw_box), NULL);
-  gtk_container_add (GTK_CONTAINER (tray), tray->box);
-  gtk_widget_show (tray->box);
-}
-
-static void
-na_tray_constructed (GObject *object)
-{
-  NaTray *tray;
-  GdkScreen *screen;
-
-  G_OBJECT_CLASS (na_tray_parent_class)->constructed (object);
-
-  tray = NA_TRAY (object);
-  screen = gdk_screen_get_default ();
-
-  tray->tray_manager = na_tray_manager_new ();
-
-  if (na_tray_manager_manage_screen (tray->tray_manager, screen))
-    {
-      g_signal_connect (tray->tray_manager, "tray-icon-added",
-                        G_CALLBACK (tray_added), tray);
-      g_signal_connect (tray->tray_manager, "tray-icon-removed",
-                        G_CALLBACK (tray_removed), tray);
-      g_signal_connect (tray->tray_manager, "message-sent",
-                        G_CALLBACK (message_sent), tray);
-      g_signal_connect (tray->tray_manager, "message-cancelled",
-                        G_CALLBACK (message_cancelled), tray);
-
-      tray->icon_table = g_hash_table_new (NULL, NULL);
-      tray->tip_table = g_hash_table_new_full (NULL, NULL, NULL, icon_tip_free);
-    }
-  else
-    {
-      g_printerr ("System tray didn't get the system tray manager selection\n");
-      g_clear_object (&tray->tray_manager);
-    }
-
-  update_size_and_orientation (tray);
-}
-
-static void
-na_tray_dispose (GObject *object)
-{
-  NaTray *tray = NA_TRAY (object);
-
-  g_clear_object (&tray->tray_manager);
-  g_clear_pointer (&tray->icon_table, g_hash_table_destroy);
-  g_clear_pointer (&tray->tip_table, g_hash_table_destroy);
-
-  G_OBJECT_CLASS (na_tray_parent_class)->dispose (object);
-}
-
-static void
-na_tray_set_property (GObject      *object,
-		      guint         prop_id,
-		      const GValue *value,
-		      GParamSpec   *pspec)
-{
-  NaTray *tray = NA_TRAY (object);
-
-  switch (prop_id)
-    {
-    case PROP_ORIENTATION:
-      na_tray_set_orientation (tray, g_value_get_enum (value));
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
-static void
-na_tray_get_preferred_width (GtkWidget *widget,
-                             gint      *minimal_width,
-                             gint      *natural_width)
-{
-  gtk_widget_get_preferred_width (gtk_bin_get_child (GTK_BIN (widget)),
-                                  minimal_width,
-                                  natural_width);
-}
-
-static void
-na_tray_get_preferred_height (GtkWidget *widget,
-                              gint      *minimal_height,
-                              gint      *natural_height)
-{
-  gtk_widget_get_preferred_height (gtk_bin_get_child (GTK_BIN (widget)),
-                                   minimal_height,
-                                   natural_height);
-}
-
-static void
-na_tray_size_allocate (GtkWidget        *widget,
-                       GtkAllocation    *allocation)
-{
-  gtk_widget_size_allocate (gtk_bin_get_child (GTK_BIN (widget)), allocation);
-  gtk_widget_set_allocation (widget, allocation);
-}
-
-static void
-na_tray_class_init (NaTrayClass *klass)
-{
-  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-
-  gobject_class->constructed = na_tray_constructed;
-  gobject_class->set_property = na_tray_set_property;
-  gobject_class->dispose = na_tray_dispose;
-  widget_class->get_preferred_width = na_tray_get_preferred_width;
-  widget_class->get_preferred_height = na_tray_get_preferred_height;
-  widget_class->size_allocate = na_tray_size_allocate;
-
-  g_object_class_install_property
-    (gobject_class,
-     PROP_ORIENTATION,
-     g_param_spec_enum ("orientation", "orientation", "orientation",
-		        GTK_TYPE_ORIENTATION,
-			GTK_ORIENTATION_HORIZONTAL,
-			G_PARAM_WRITABLE |
-			G_PARAM_STATIC_NAME |
-			G_PARAM_STATIC_NICK |
-			G_PARAM_STATIC_BLURB));
-}
-
-NaTray *
-na_tray_new_for_screen (GtkOrientation orientation)
-{
-  return g_object_new (NA_TYPE_TRAY,
-		       "orientation", orientation,
-		       NULL);
-}
-
-void
-na_tray_set_orientation (NaTray         *tray,
-			 GtkOrientation  orientation)
-{
-  if (orientation == tray->orientation)
-    return;
-
-  tray->orientation = orientation;
-
-  update_size_and_orientation (tray);
-}
-
-GtkOrientation
-na_tray_get_orientation (NaTray *tray)
-{
-  return tray->orientation;
-}
-
-void
-na_tray_set_padding (NaTray *tray,
-                     gint    padding)
-{
-  na_tray_manager_set_padding (tray->tray_manager, padding);
-}
-
-void
-na_tray_set_icon_size (NaTray *tray,
-                       gint    size)
-{
-  na_tray_manager_set_icon_size (tray->tray_manager, size);
-}
-
-void
-na_tray_set_colors (NaTray   *tray,
-                    GdkRGBA  *fg,
-                    GdkRGBA  *error,
-                    GdkRGBA  *warning,
-                    GdkRGBA  *success)
-{
-  na_tray_manager_set_colors (tray->tray_manager, fg, error, warning, success);
-}
diff --git a/src/imports/natray/na-tray.h b/src/imports/natray/na-tray.h
deleted file mode 100644
index df8d41a4..00000000
--- a/src/imports/natray/na-tray.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
-/* na-tray-tray.h
- * Copyright (C) 2002 Anders Carlsson <andersca@gnu.org>
- * Copyright (C) 2003-2006 Vincent Untz
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, see <http://www.gnu.org/licenses/>.
- *
- * Used to be: eggtraytray.h
- */
-
-#ifndef __NA_TRAY_H__
-#define __NA_TRAY_H__
-
-#include <gdk/gdkx.h>
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-#define NA_TYPE_TRAY na_tray_get_type ()
-G_DECLARE_FINAL_TYPE (NaTray, na_tray, NA, TRAY, GtkBin)
-
-NaTray         *na_tray_new_for_screen  (GtkOrientation orientation);
-void            na_tray_set_orientation	(NaTray        *tray,
-					 GtkOrientation orientation);
-GtkOrientation  na_tray_get_orientation (NaTray        *tray);
-void            na_tray_set_padding     (NaTray        *tray,
-					 gint           padding);
-void            na_tray_set_icon_size   (NaTray        *tray,
-					 gint           icon_size);
-void            na_tray_set_colors      (NaTray        *tray,
-					 GdkRGBA       *fg,
-					 GdkRGBA       *error,
-					 GdkRGBA       *warning,
-					 GdkRGBA       *success);
-
-G_END_DECLS
-
-#endif /* __NA_TRAY_H__ */
diff --git a/src/imports/natray/natray-1.0.vapi b/src/imports/natray/natray-1.0.vapi
deleted file mode 100644
index 7c74424f..00000000
--- a/src/imports/natray/natray-1.0.vapi
+++ /dev/null
@@ -1,17 +0,0 @@
-namespace Na {
-	[CCode (cheader_filename = "na-tray.h")]
-	public class Tray : Gtk.Bin {
-		[CCode (has_construct_function = false, type = "GtkWidget*")]
-		public Tray();
-		[CCode (has_construct_function = false, type = "GtkWidget*")]
-        public Tray.for_screen(Gtk.Orientation orientation);
-
-        public void set_orientation(Gtk.Orientation orientation);
-        public Gtk.Orientation get_orientation(Gtk.Orientation orientation);
-
-        public void set_padding(int padding);
-        public void set_icon_size(int icon_size);
-
-        public void set_colors(Gdk.RGBA fg, Gdk.RGBA error, Gdk.RGBA warning, Gdk.RGBA success);
-	}
-}
diff --git a/src/meson.build b/src/meson.build
index 89bc6961..28bf9249 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -9,7 +9,6 @@ subdir('libsession')
 subdir('appsys')
 subdir('abomination')
 
-subdir('imports')
 subdir('theme')
 subdir('lib')
 subdir('raven')
