From b27ba0fef1456f15144c5da135a197a235f6415d Mon Sep 17 00:00:00 2001
From: Richard Antalik <richardantalik@gmail.com>
Date: Thu, 6 Nov 2025 19:48:22 +0100
Subject: [PATCH] Fix: VSE: Can not cancel waveform reading job

When there are lot of sound strips in VSE timeline, waveform rendering
could not be stopped. This causes problems mainly when .blend file was
opened by accident and different one can not be opened until all
waveforms are read, which can take a minute.

This was caused by code, where value of `stop` boolean pointer was
stored in local variable and cast into short. Pointer to this local
variable was passed to `AUD_readSound()`. Then value of `stop` bool
pointer was set to that local variable again. Because the code runs in
multiple threads now, it is quite likely, that `stop` value gets
overwritten by older thread. Especially, because `AUD_readSound()` does
interrupt its process only when `stop` was true before its execution,
so it is done very quickly.

Pass boolean pointer directly to `AUD_readSound()`, so the waveform
reading process can be interrupted immediately. The change in Audaspace
is already merged in
https://github.com/audaspace/audaspace/commit/9b1be5f7c9

Finally, while the waveform reading job now can be cancelled, new job
will be created immediately. This is technically correct behavior, even
though it can cause other problems described in #144082

Pull Request: https://projects.blender.org/blender/blender/pulls/149301
---
 extern/audaspace/bindings/C/AUD_Special.cpp | 2 +-
 extern/audaspace/bindings/C/AUD_Special.h   | 6 ++++--
 source/blender/blenkernel/intern/sound.cc   | 5 +----
 3 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/extern/audaspace/bindings/C/AUD_Special.cpp b/extern/audaspace/bindings/C/AUD_Special.cpp
index 0e94f80ccda..ec9433c4b7e 100644
--- a/extern/audaspace/bindings/C/AUD_Special.cpp
+++ b/extern/audaspace/bindings/C/AUD_Special.cpp
@@ -200,7 +200,7 @@ AUD_API AUD_Handle* AUD_pauseAfter(AUD_Handle* handle, double seconds)
 	return nullptr;
 }
 
-AUD_API int AUD_readSound(AUD_Sound* sound, float* buffer, int length, int samples_per_second, short* interrupt)
+AUD_API int AUD_readSound(AUD_Sound* sound, float* buffer, int length, int samples_per_second, bool* interrupt)
 {
 	DeviceSpecs specs;
 	float* buf;
diff --git a/extern/audaspace/bindings/C/AUD_Special.h b/extern/audaspace/bindings/C/AUD_Special.h
index 72139e956a1..3c8ac71512a 100644
--- a/extern/audaspace/bindings/C/AUD_Special.h
+++ b/extern/audaspace/bindings/C/AUD_Special.h
@@ -18,6 +18,8 @@
 
 #include "AUD_Types.h"
 
+#include <stdbool.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -53,10 +55,10 @@ extern AUD_API AUD_Handle* AUD_pauseAfter(AUD_Handle* handle, double seconds);
  * \param buffer The buffer to write to. Must have a size of 3*4*length.
  * \param length How many samples to read from the sound.
  * \param samples_per_second How many samples to read per second of the sound.
- * \param interrupt Must point to a short that equals 0. If it is set to a non-zero value, the method will be interrupted and return 0.
+ * \param interrupt Must point to a bool that equals false. If it is set to true, the method will be interrupted and return 0.
  * \return How many samples really have been read. Always <= length.
  */
-extern AUD_API int AUD_readSound(AUD_Sound* sound, float* buffer, int length, int samples_per_second, short* interrupt);
+extern AUD_API int AUD_readSound(AUD_Sound* sound, float* buffer, int length, int samples_per_second, bool* interrupt);
 
 /**
  * Mixes a sound down into a file.
diff --git a/source/blender/blenkernel/intern/sound.cc b/source/blender/blenkernel/intern/sound.cc
index 88716af54ca..2f492bbd122 100644
--- a/source/blender/blenkernel/intern/sound.cc
+++ b/source/blender/blenkernel/intern/sound.cc
@@ -1305,11 +1305,8 @@ void BKE_sound_read_waveform(Main *bmain, bSound *sound, bool *stop)
     int length = info.length * SOUND_WAVE_SAMPLES_PER_SECOND;
 
     waveform->data = MEM_malloc_arrayN<float>(3 * size_t(length), "SoundWaveform.samples");
-    /* Ideally this would take a boolean argument. */
-    short stop_i16 = *stop;
     waveform->length = AUD_readSound(
-        sound->playback_handle, waveform->data, length, SOUND_WAVE_SAMPLES_PER_SECOND, &stop_i16);
-    *stop = stop_i16 != 0;
+        sound->playback_handle, waveform->data, length, SOUND_WAVE_SAMPLES_PER_SECOND, stop);
   }
   else {
     /* Create an empty waveform here if the sound couldn't be
