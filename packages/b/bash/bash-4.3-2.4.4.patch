---
 array.c                  |    2 +-
 examples/loadables/tee.c |    3 ++-
 hashlib.c                |    4 ++--
 jobs.c                   |    8 ++++++++
 sig.c                    |    4 ++--
 sig.h                    |    4 ++--
 trap.c                   |    2 +-
 trap.h                   |    2 +-
 8 files changed, 19 insertions(+), 10 deletions(-)

--- array.c
+++ array.c	2025-01-31 13:09:34.626496209 +0000
@@ -1031,7 +1031,7 @@ array_from_string(char *s, char *sep)
  * To make a running version, compile -DTEST_ARRAY and link with:
  * 	xmalloc.o syntax.o lib/malloc/libmalloc.a lib/sh/libsh.a
  */
-int interrupt_immediately = 0;
+volatile sig_atomic_t interrupt_immediately = 0;
 
 int
 signal_is_trapped(int s)
--- examples/loadables/tee.c
+++ examples/loadables/tee.c	2025-01-31 13:10:07.849883770 +0000
@@ -35,6 +35,7 @@
 #include "bashansi.h"
 
 #include <stdio.h>
+#include <signal.h>
 #include <errno.h>
 
 #include "builtins.h"
@@ -56,7 +57,7 @@ static FLIST *tee_flist;
 
 #define TEE_BUFSIZE	8192
 
-extern int interrupt_immediately;
+extern volatile sig_atomic_t interrupt_immediately;
 
 extern char *strerror (int);
 
--- hashlib.c
+++ hashlib.c	2025-01-31 13:10:56.584985412 +0000
@@ -449,8 +449,8 @@ hash_pstats (HASH_TABLE *table, char *na
 
 HASH_TABLE *table, *ntable;
 
-int interrupt_immediately = 0;
-int running_trap = 0;
+volatile sig_atomic_t interrupt_immediately = 0;
+volatile sig_atomic_t running_trap = 0;
 
 int
 signal_is_trapped (int s)
--- jobs.c
+++ jobs.c	2025-01-31 13:12:14.623546948 +0000
@@ -2354,6 +2354,14 @@ make_child (char *command, int flags)
 	 the child process when this returns. */
       mypid = getpid ();
 
+      if (interrupt_state)
+	{
+	  struct timeval tv;
+	  struct rusage   rx;
+	  (void) gettimeofday(&tv, NULL);
+	  (void) getrusage(RUSAGE_SELF, &rx);
+	}
+
       /* Close default_buffered_input if it's > 0.  We don't close it if it's
 	 0 because that's the file descriptor used when redirecting input,
 	 and it's wrong to close the file in that case. */
--- sig.c
+++ sig.c	2025-01-31 12:58:40.154563470 +0000
@@ -86,10 +86,10 @@ sigset_t top_level_mask;
 #endif /* JOB_CONTROL */
 
 /* When non-zero, we throw_to_top_level (). */
-int interrupt_immediately = 0;
+volatile sig_atomic_t interrupt_immediately = 0;
 
 /* When non-zero, we call the terminating signal handler immediately. */
-int terminate_immediately = 0;
+volatile sig_atomic_t terminate_immediately = 0;
 
 #if defined (SIGWINCH)
 static SigHandler *old_winch = (SigHandler *)SIG_DFL;
--- sig.h
+++ sig.h	2025-01-31 13:12:50.922877875 +0000
@@ -105,8 +105,8 @@ do { \
 extern volatile sig_atomic_t sigwinch_received;
 extern volatile sig_atomic_t sigterm_received;
 
-extern int interrupt_immediately;	/* no longer used */
-extern int terminate_immediately;
+extern volatile sig_atomic_t interrupt_immediately;	/* no longer used */
+extern volatile sig_atomic_t terminate_immediately;
 
 extern volatile int builtin_catch_sigpipe;	/* not used yet */
 
--- trap.c
+++ trap.c	2025-01-31 13:13:24.578257547 +0000
@@ -112,7 +112,7 @@ int pending_traps[NSIG];
    Used in execute_cmd.c and builtins/common.c to clean up when
    parse_and_execute does not return normally after executing the
    trap command (e.g., when `return' is executed in the trap command). */
-int running_trap;
+volatile sig_atomic_t running_trap;
 
 /* The execution context (function/source execution level) when we began
    running this trap command. This is used to determine whether we have
--- trap.h
+++ trap.h	2025-01-31 13:13:58.405634062 +0000
@@ -62,7 +62,7 @@ extern char *trap_list[];
 
 extern int trapped_signal_received;
 extern int wait_signal_received;
-extern int running_trap;
+extern volatile sig_atomic_t running_trap;
 extern int trap_return_context;
 extern int trap_saved_exit_value;
 extern int suppress_debug_trap_verbose;
