When a writable input section (i.e. data) refers to a symbol defined in an
ET_DYN object, BFD ld for ARM targets generates a COPY dynamic reloc.  For
other targets like x86, this situation generates a plain data dynamic
reloc.  Gold for ARM also generates the plain data dynamic reloc.

https://bugzilla.suse.com/show_bug.cgi?id=1200962
https://sourceware.org/bugzilla/show_bug.cgi?id=16177

---
 bfd/elf32-arm.c | 25 +++++++++++++++++++------
 1 file changed, 19 insertions(+), 6 deletions(-)
Index: binutils-2.39/bfd/elf32-arm.c
===================================================================
--- binutils-2.39.orig/bfd/elf32-arm.c
+++ binutils-2.39/bfd/elf32-arm.c
@@ -16196,6 +16196,21 @@ elf32_arm_adjust_dynamic_symbol (struct
   if (bfd_link_pic (info) || globals->root.is_relocatable_executable)
     return true;
 
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return true;
+    }
+
+  /* If we don't find any dynamic relocs in read-only sections, then
+     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
+  if (!_bfd_elf_readonly_dynrelocs (h))
+    {
+      h->non_got_ref = 0;
+      return true;
+    }
+
   /* We must allocate the symbol in our .dynbss section, which will
      become part of the .bss section of the executable.  There will be
      an entry for this symbol in the .dynsym section.  The dynamic
@@ -16205,9 +16220,9 @@ elf32_arm_adjust_dynamic_symbol (struct
      determine the address it must put in the global offset table, so
      both the dynamic object and the regular object will refer to the
      same memory location for the variable.  */
-  /* If allowed, we must generate a R_ARM_COPY reloc to tell the dynamic
-     linker to copy the initial value out of the dynamic object and into
-     the runtime process image.  We need to remember the offset into the
+  /* We must generate a R_ARM_COPY reloc to tell the dynamic linker to
+     copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
      .rel(a).bss section we are going to use.  */
   if ((h->root.u.def.section->flags & SEC_READONLY) != 0)
     {
@@ -16219,9 +16234,7 @@ elf32_arm_adjust_dynamic_symbol (struct
       s = globals->root.sdynbss;
       srel = globals->root.srelbss;
     }
-  if (info->nocopyreloc == 0
-      && (h->root.u.def.section->flags & SEC_ALLOC) != 0
-      && h->size != 0)
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
     {
       elf32_arm_allocate_dynrelocs (info, srel, 1);
       h->needs_copy = 1;
