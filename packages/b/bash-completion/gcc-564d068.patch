From 564d068cb890dc7dbca9c566fd7fab227558efd6 Mon Sep 17 00:00:00 2001
From: marxin <mliska@suse.cz>
Date: Mon, 14 May 2018 15:35:57 +0200
Subject: [PATCH] Add support for GCC --completion= option.

---
 completions/gcc |   83 +++++++++++++++++++++++++++++++-------------------------
 1 file changed, 47 insertions(+), 36 deletions(-)

--- completions/gcc
+++ completions/gcc	2019-04-26 08:40:48.199351068 +0000
@@ -1,49 +1,60 @@
 # gcc(1) completion                                        -*- shell-script -*-
-#
-# The only unusual feature is that we don't parse "gcc --help -v" output
-# directly, because that would include the options of all the other backend
-# tools (linker, assembler, preprocessor, etc) without any indication that
-# you cannot feed such options to the gcc driver directly.  (For example, the
-# linker takes a -z option, but you must type -Wl,-z for gcc.)  Instead, we
-# ask the driver ("g++") for the name of the compiler ("cc1"), and parse the
-# --help output of the compiler.
 
 _gcc()
 {
-    local cur prev words cword
+    local cur prev prev2 words cword argument prefix prefix_length
     _init_completion || return
+    _expand || return
 
-    local cc backend
+    # Test that GCC is recent enough and if not fallback to
+    # parsing of --completion option.
+    $1 --completion=" " 2> /dev/null
+    if ! $1 --completion=" " 2>/dev/null; then
+        if [[ "$cur" == -* ]]; then
+            local cc=$( $1 -print-prog-name=cc1 2> /dev/null )
+            [[ $cc ]] || return
+            COMPREPLY=( $( compgen -W "$( $cc --help 2> /dev/null | tr '\t' ' ' |\
+                command sed -e '/^  *-/!d' -e 's/ *-\([^][ <>]*\).*/-\1/' )" -- "$cur" ) )
+            [[ $COMPREPLY == *= ]] && compopt -o nospace
+            return
+        else
+            _filedir
+            return
+        fi
+    fi
 
-    case $1 in
-        gcj)
-            backend=jc1
-            ;;
-        gpc)
-            backend=gpc1
-            ;;
-        *77)
-            backend=f771
-            ;;
-        *95)
-            backend=f951
-            ;;
-        *)
-            backend=cc1 # (near-)universal backend
-            ;;
-    esac
+    # extract also for situations like: -fsanitize=add
+    if [[ $cword > 2 ]]; then
+        prev2="${COMP_WORDS[$cword - 2]}"
+    fi
 
+    # sample: -fsan
     if [[ "$cur" == -* ]]; then
-        cc=$( $1 -print-prog-name=$backend 2>/dev/null )
-        [[ $cc ]] || return
-        # sink stderr:
-        # for C/C++/ObjectiveC it's useless
-        # for FORTRAN/Java it's an error
-        COMPREPLY=( $( compgen -W "$( $cc --help 2>/dev/null | tr '\t' ' ' |\
-            command sed -e '/^  *-/!d' -e 's/ *-\([^][ <>]*\).*/-\1/' )" -- "$cur" ) )
-        [[ $COMPREPLY == *= ]] && compopt -o nospace
-    else
+        argument=$cur
+        prefix=""
+    # sample: -fsanitize=
+    elif [[ "$cur" == "=" && $prev == -* ]]; then
+        argument=$prev$cur
+        prefix=$prev$cur
+    # sample: -fsanitize=add
+    elif [[ "$prev" == "=" && $prev2 == -* ]]; then
+        argument=$prev2$prev$cur
+        prefix=$prev2$prev
+    # sample: --param lto-
+    elif [[ "$prev" == "--param" ]]; then
+        argument="$prev $cur"
+        prefix="$prev "
+    fi
+
+    if [[ "$argument" == "" ]]; then
         _filedir
+    else
+        # In situation like '-fsanitize=add' $cur is equal to last token.
+        # Thus we need to strip the beginning of suggested option.
+        prefix_length=`expr length "$prefix" + 1`
+        local flags=$( gcc --completion="$argument" 2> /dev/null | cut -c $prefix_length-)
+        [[ "${flags: -1}" == '=' ]] && compopt -o nospace 2> /dev/null
+        COMPREPLY=( $( compgen -W "$flags" -- "") )
     fi
 } &&
 complete -F _gcc gcc g++ gfortran g77 g95 gcj gpc &&
