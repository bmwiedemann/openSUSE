From 7c73fff34d987c3071a884ac0f74709c8f6dc01f Mon Sep 17 00:00:00 2001
From: Jorn Vernee <jvernee@openjdk.org>
Date: Wed, 25 Nov 2020 18:09:22 +0000
Subject: [PATCH] 8256486: Linux/Windows-x86 builds broken after JDK-8254231

Reviewed-by: shade
---
 src/hotspot/cpu/x86/assembler_x86.cpp         | 38 +++++++++----------
 src/hotspot/cpu/x86/macroAssembler_x86.cpp    | 16 ++++----
 src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp  |  8 ++++
 .../cpu/x86/universalNativeInvoker_x86_32.cpp | 34 +++++++++++++++++
 ....cpp => universalNativeInvoker_x86_64.cpp} |  0
 .../cpu/x86/universalUpcallHandler_x86_32.cpp | 30 +++++++++++++++
 ....cpp => universalUpcallHandler_x86_64.cpp} |  0
 src/hotspot/cpu/x86/x86_32.ad                 |  5 +++
 .../share/prims/universalUpcallHandler.cpp    | 16 ++++----
 .../share/prims/universalUpcallHandler.hpp    |  4 +-
 .../windows/native/libjava/jni_util_md.c      |  2 +-
 .../jdk/incubator/foreign/libUpcallsJNI.c     |  7 ++--
 12 files changed, 120 insertions(+), 40 deletions(-)
 create mode 100644 src/hotspot/cpu/x86/universalNativeInvoker_x86_32.cpp
 rename src/hotspot/cpu/x86/{universalNativeInvoker_x86.cpp => universalNativeInvoker_x86_64.cpp} (100%)
 create mode 100644 src/hotspot/cpu/x86/universalUpcallHandler_x86_32.cpp
 rename src/hotspot/cpu/x86/{universalUpcallHandler_x86.cpp => universalUpcallHandler_x86_64.cpp} (100%)

diff --git a/src/hotspot/cpu/x86/assembler_x86.cpp b/src/hotspot/cpu/x86/assembler_x86.cpp
index d538a2dbfe6..1d30c95b8ee 100644
--- a/src/hotspot/cpu/x86/assembler_x86.cpp
+++ b/src/hotspot/cpu/x86/assembler_x86.cpp
@@ -8040,6 +8040,25 @@ void Assembler::vzeroupper_uncached() {
   }
 }
 
+void Assembler::fld_x(Address adr) {
+  InstructionMark im(this);
+  emit_int8((unsigned char)0xDB);
+  emit_operand32(rbp, adr);
+}
+
+void Assembler::fstp_x(Address adr) {
+  InstructionMark im(this);
+  emit_int8((unsigned char)0xDB);
+  emit_operand32(rdi, adr);
+}
+
+void Assembler::emit_operand32(Register reg, Address adr) {
+  assert(reg->encoding() < 8, "no extended registers");
+  assert(!adr.base_needs_rex() && !adr.index_needs_rex(), "no extended registers");
+  emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
+               adr._rspec);
+}
+
 #ifndef _LP64
 // 32bit only pieces of the assembler
 
@@ -9860,25 +9879,6 @@ void Assembler::decq(Address dst) {
   emit_operand(rcx, dst);
 }
 
-void Assembler::fld_x(Address adr) {
-  InstructionMark im(this);
-  emit_int8((unsigned char)0xDB);
-  emit_operand32(rbp, adr);
-}
-
-void Assembler::fstp_x(Address adr) {
-  InstructionMark im(this);
-  emit_int8((unsigned char)0xDB);
-  emit_operand32(rdi, adr);
-}
-
-void Assembler::emit_operand32(Register reg, Address adr) {
-  assert(reg->encoding() < 8, "no extended registers");
-  assert(!adr.base_needs_rex() && !adr.index_needs_rex(), "no extended registers");
-  emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
-               adr._rspec);
-}
-
 void Assembler::fxrstor(Address src) {
   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);
   emit_operand(as_Register(1), src);
diff --git a/src/hotspot/cpu/x86/macroAssembler_x86.cpp b/src/hotspot/cpu/x86/macroAssembler_x86.cpp
index 29605af4488..e26d9cd50f6 100644
--- a/src/hotspot/cpu/x86/macroAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/macroAssembler_x86.cpp
@@ -745,6 +745,10 @@ void MacroAssembler::pushptr(AddressLiteral src) {
   }
 }
 
+void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
+  reset_last_Java_frame(r15_thread, clear_fp);
+}
+
 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
                                          Register last_java_fp,
                                          address  last_java_pc) {
@@ -2713,25 +2717,21 @@ void MacroAssembler::push_IU_state() {
   pusha();
 }
 
-void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
-  reset_last_Java_frame(r15_thread, clear_fp);
-}
-
 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
   if (!java_thread->is_valid()) {
     java_thread = rdi;
     get_thread(java_thread);
   }
   // we must set sp to zero to clear frame
-  movslq(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
+  movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
   // must clear fp, so that compiled frames are not confused; it is
   // possible that we need it only for debugging
   if (clear_fp) {
-    movslq(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
+    movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
   }
   // Always clear the pc because it could have been set by make_walkable()
-  movslq(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
-  movslq(Address(java_thread, JavaThread::saved_rbp_address_offset()), NULL_WORD);
+  movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
+  movptr(Address(java_thread, JavaThread::saved_rbp_address_offset()), NULL_WORD);
   vzeroupper();
 }
 
diff --git a/src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp b/src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp
index fd6c7ab5f70..4aaad790bba 100644
--- a/src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp
+++ b/src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp
@@ -2985,3 +2985,11 @@ RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const cha
   // frame_size_words or bytes??
   return RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_words, oop_maps, true);
 }
+
+BufferBlob* SharedRuntime::make_native_invoker(address call_target,
+                                                int shadow_space_bytes,
+                                                const GrowableArray<VMReg>& input_registers,
+                                                const GrowableArray<VMReg>& output_registers) {
+  ShouldNotCallThis();
+  return nullptr;
+}
diff --git a/src/hotspot/cpu/x86/universalNativeInvoker_x86_32.cpp b/src/hotspot/cpu/x86/universalNativeInvoker_x86_32.cpp
new file mode 100644
index 00000000000..d3443107b72
--- /dev/null
+++ b/src/hotspot/cpu/x86/universalNativeInvoker_x86_32.cpp
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "precompiled.hpp"
+#include "prims/universalNativeInvoker.hpp"
+
+void ProgrammableInvoker::Generator::generate() {
+  Unimplemented();
+}
+
+address ProgrammableInvoker::generate_adapter(jobject jabi, jobject jlayout) {
+  Unimplemented();
+  return nullptr;
+}
diff --git a/src/hotspot/cpu/x86/universalNativeInvoker_x86.cpp b/src/hotspot/cpu/x86/universalNativeInvoker_x86_64.cpp
similarity index 100%
rename from src/hotspot/cpu/x86/universalNativeInvoker_x86.cpp
rename to src/hotspot/cpu/x86/universalNativeInvoker_x86_64.cpp
diff --git a/src/hotspot/cpu/x86/universalUpcallHandler_x86_32.cpp b/src/hotspot/cpu/x86/universalUpcallHandler_x86_32.cpp
new file mode 100644
index 00000000000..966ab750db0
--- /dev/null
+++ b/src/hotspot/cpu/x86/universalUpcallHandler_x86_32.cpp
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "precompiled.hpp"
+#include "prims/universalUpcallHandler.hpp"
+
+address ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {
+  Unimplemented();
+  return nullptr;
+}
diff --git a/src/hotspot/cpu/x86/universalUpcallHandler_x86.cpp b/src/hotspot/cpu/x86/universalUpcallHandler_x86_64.cpp
similarity index 100%
rename from src/hotspot/cpu/x86/universalUpcallHandler_x86.cpp
rename to src/hotspot/cpu/x86/universalUpcallHandler_x86_64.cpp
diff --git a/src/hotspot/cpu/x86/x86_32.ad b/src/hotspot/cpu/x86/x86_32.ad
index e6b947e1c8f..f7a4e149251 100644
--- a/src/hotspot/cpu/x86/x86_32.ad
+++ b/src/hotspot/cpu/x86/x86_32.ad
@@ -311,6 +311,11 @@ int MachCallRuntimeNode::ret_addr_offset() {
   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
 }
 
+int MachCallNativeNode::ret_addr_offset() {
+  ShouldNotCallThis();
+  return -1;
+}
+
 //
 // Compute padding required for nodes which need alignment
 //
diff --git a/src/hotspot/share/prims/universalUpcallHandler.cpp b/src/hotspot/share/prims/universalUpcallHandler.cpp
index 33ba631e616..9eff9f53c3f 100644
--- a/src/hotspot/share/prims/universalUpcallHandler.cpp
+++ b/src/hotspot/share/prims/universalUpcallHandler.cpp
@@ -33,34 +33,34 @@
 
 extern struct JavaVM_ main_vm;
 
-JNI_ENTRY(void, ProgrammableUpcallHandler::upcall_helper(JNIEnv* env, jobject rec, address buff))
+void ProgrammableUpcallHandler::upcall_helper(JavaThread* thread, jobject rec, address buff) {
+  JavaThread* THREAD = thread;
+  ThreadInVMfromNative tiv(THREAD);
   const UpcallMethod& upcall_method = instance().upcall_method;
 
-  ResourceMark rm(thread);
+  ResourceMark rm(THREAD);
   JavaValue result(T_VOID);
   JavaCallArguments args(2); // long = 2 slots
 
   args.push_jobject(rec);
   args.push_long((jlong) buff);
 
-  JavaCalls::call_static(&result, upcall_method.klass, upcall_method.name, upcall_method.sig, &args, thread);
-JNI_END
+  JavaCalls::call_static(&result, upcall_method.klass, upcall_method.name, upcall_method.sig, &args, CATCH);
+}
 
 void ProgrammableUpcallHandler::attach_thread_and_do_upcall(jobject rec, address buff) {
   Thread* thread = Thread::current_or_null();
   bool should_detach = false;
-  JNIEnv* p_env = nullptr;
   if (thread == nullptr) {
     JavaVM_ *vm = (JavaVM *)(&main_vm);
+    JNIEnv* p_env = nullptr; // unused
     jint result = vm->functions->AttachCurrentThread(vm, (void**) &p_env, nullptr);
     guarantee(result == JNI_OK, "Could not attach thread for upcall. JNI error code: %d", result);
     should_detach = true;
     thread = Thread::current();
-  } else {
-    p_env = thread->as_Java_thread()->jni_environment();
   }
 
-  upcall_helper(p_env, rec, buff);
+  upcall_helper(thread->as_Java_thread(), rec, buff);
 
   if (should_detach) {
     JavaVM_ *vm = (JavaVM *)(&main_vm);
diff --git a/src/hotspot/share/prims/universalUpcallHandler.hpp b/src/hotspot/share/prims/universalUpcallHandler.hpp
index cbef1d8eb3b..6af2e405d63 100644
--- a/src/hotspot/share/prims/universalUpcallHandler.hpp
+++ b/src/hotspot/share/prims/universalUpcallHandler.hpp
@@ -27,6 +27,8 @@
 #include "asm/codeBuffer.hpp"
 #include "prims/foreign_globals.hpp"
 
+class JavaThread;
+
 class ProgrammableUpcallHandler {
 private:
   static constexpr CodeBuffer::csize_t upcall_stub_size = 1024;
@@ -41,7 +43,7 @@ private:
 
   static const ProgrammableUpcallHandler& instance();
 
-  static void upcall_helper(JNIEnv* env, jobject rec, address buff);
+  static void upcall_helper(JavaThread* thread, jobject rec, address buff);
   static void attach_thread_and_do_upcall(jobject rec, address buff);
 public:
   static address generate_upcall_stub(jobject rec, jobject abi, jobject buffer_layout);
diff --git a/src/java.base/windows/native/libjava/jni_util_md.c b/src/java.base/windows/native/libjava/jni_util_md.c
index 47c5e5ebc01..a4186286e7a 100644
--- a/src/java.base/windows/native/libjava/jni_util_md.c
+++ b/src/java.base/windows/native/libjava/jni_util_md.c
@@ -49,7 +49,7 @@ void* findEntryInProcess(const char* name) {
 
     // first come, first served
     if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded)) {
-        for (int i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {
+        for (size_t i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {
             HMODULE mod = hMods[i];
             FARPROC proc = GetProcAddress(mod, name);
             if(proc != NULL) {
diff --git a/test/micro/org/openjdk/bench/jdk/incubator/foreign/libUpcallsJNI.c b/test/micro/org/openjdk/bench/jdk/incubator/foreign/libUpcallsJNI.c
index 8a4e16268a5..bf946891578 100644
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/libUpcallsJNI.c
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/libUpcallsJNI.c
@@ -22,6 +22,7 @@
  */
 #include <jni.h>
 #include <stdlib.h>
+#include "jlong.h"
 
 void blank(void (*cb)(void)) {
     cb();
@@ -67,17 +68,17 @@ JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_mak
   (*env)->ReleaseStringUTFChars(env, methodName, methodNameC);
   (*env)->ReleaseStringUTFChars(env, descriptor, descriptorC);
 
-  return (jlong) cb;
+  return ptr_to_jlong(cb);
 }
 
 JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_blank
   (JNIEnv *env, jclass cls, jlong cb) {
-    JNICB jniCb = (JNICB) cb;
+    JNICB jniCb = jlong_to_ptr(cb);
     (*env)->CallStaticVoidMethod(env, jniCb->holder, jniCb->mid);
 }
 
 JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_identity
   (JNIEnv *env, jclass cls, jint x, jlong cb) {
-    JNICB jniCb = (JNICB) cb;
+    JNICB jniCb = jlong_to_ptr(cb);
     return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, x);
 }
-- 
2.29.2

