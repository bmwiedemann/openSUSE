From 2218b45d14def6310661ddabed64723ffa9ace74 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Wed, 22 Feb 2023 10:45:05 +0100
Subject: [PATCH] Fix -Wsign-conversion on 32-bit

Closes: https://gitlab.freedesktop.org/emersion/libliftoff/-/issues/75
(cherry picked from commit 25dd6d662e6ee2ef756d3e6d6cf836dad9bdad85)
---
 example/compositor.c   | 4 ++--
 example/dynamic.c      | 4 ++--
 example/multi-output.c | 2 +-
 example/simple.c       | 2 +-
 plane.c                | 6 +++---
 test/bench.c           | 4 ++--
 6 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/example/compositor.c b/example/compositor.c
index a2d0d1c..3dde899 100644
--- a/example/compositor.c
+++ b/example/compositor.c
@@ -182,7 +182,7 @@ main(int argc, char *argv[])
 	layers[0] = add_layer(drm_fd, output, 0, 0, crtc->mode.hdisplay,
 			      crtc->mode.vdisplay, false, true, &fbs[0]);
 	for (i = 1; i < layers_len; i++) {
-		layers[i] = add_layer(drm_fd, output, 100 * i, 100 * i,
+		layers[i] = add_layer(drm_fd, output, 100 * (int)i, 100 * (int)i,
 				      256, 256, i % 2, false, &fbs[i]);
 	}
 
@@ -205,7 +205,7 @@ main(int argc, char *argv[])
 	for (i = 1; i < layers_len; i++) {
 		if (liftoff_layer_needs_composition(layers[i])) {
 			composite(drm_fd, &composition_fb, &fbs[i],
-				  i * 100, i * 100);
+				  (int)i * 100, (int)i * 100);
 		}
 	}
 
diff --git a/example/dynamic.c b/example/dynamic.c
index 7cf7543..5247c5f 100644
--- a/example/dynamic.c
+++ b/example/dynamic.c
@@ -199,8 +199,8 @@ main(int argc, char *argv[])
 		   crtc->mode.vdisplay, false);
 	for (i = 1; i < LAYERS_LEN; i++) {
 		init_layer(drm_fd, &layers[i], output, 100, 100, i % 2);
-		layers[i].x = 100 * i;
-		layers[i].y = 100 * i;
+		layers[i].x = 100 * (int)i;
+		layers[i].y = 100 * (int)i;
 	}
 
 	for (i = 0; i < LAYERS_LEN; i++) {
diff --git a/example/multi-output.c b/example/multi-output.c
index 4bf7ea0..b6b0656 100644
--- a/example/multi-output.c
+++ b/example/multi-output.c
@@ -145,7 +145,7 @@ main(int argc, char *argv[])
 						 crtc->mode.vdisplay, false);
 		for (j = 1; j < LAYERS_PER_OUTPUT; j++) {
 			layers[layers_len++] = add_layer(drm_fd, output,
-							 100 * j, 100 * j,
+							 100 * (int)j, 100 * (int)j,
 							 256, 256, j % 2);
 		}
 	}
diff --git a/example/simple.c b/example/simple.c
index e18a6b8..5ea5f74 100644
--- a/example/simple.c
+++ b/example/simple.c
@@ -120,7 +120,7 @@ main(int argc, char *argv[])
 	layers[0] = add_layer(drm_fd, output, 0, 0, crtc->mode.hdisplay,
 			      crtc->mode.vdisplay, false);
 	for (i = 1; i < LAYERS_LEN; i++) {
-		layers[i] = add_layer(drm_fd, output, 100 * i, 100 * i,
+		layers[i] = add_layer(drm_fd, output, 100 * (int)i, 100 * (int)i,
 				      256, 256, i % 2);
 	}
 
diff --git a/plane.c b/plane.c
index 07e4bae..7e2d408 100644
--- a/plane.c
+++ b/plane.c
@@ -335,11 +335,11 @@ plane_check_layer_fb(struct liftoff_plane *plane, struct liftoff_layer *layer)
 		return false;
 	}
 
-	if (format_index < modifiers[modifier_index].offset ||
-	    format_index >= modifiers[modifier_index].offset + 64) {
+	if ((size_t)format_index < modifiers[modifier_index].offset ||
+	    (size_t)format_index >= modifiers[modifier_index].offset + 64) {
 		return false;
 	}
-	format_shift = (int)(format_index - modifiers[modifier_index].offset);
+	format_shift = format_index - (int)modifiers[modifier_index].offset;
 	return (modifiers[modifier_index].formats & ((uint64_t)1 << format_shift)) != 0;
 }
 
diff --git a/test/bench.c b/test/bench.c
index 95a5142..851caa4 100644
--- a/test/bench.c
+++ b/test/bench.c
@@ -12,7 +12,7 @@
 #define MAX_LAYERS 128
 
 static struct liftoff_layer *
-add_layer(struct liftoff_output *output, int x, int y, int width, int height)
+add_layer(struct liftoff_output *output, int x, int y, uint32_t width, uint32_t height)
 {
 	uint32_t fb_id;
 	struct liftoff_layer *layer;
@@ -85,7 +85,7 @@ main(int argc, char *argv[])
 	for (i = 0; i < layers_len; i++) {
 		/* Planes don't intersect, so the library can arrange them in
 		 * any order. Testing all combinations takes more time. */
-		layers[i] = add_layer(output, i * 100, i * 100, 100, 100);
+		layers[i] = add_layer(output, (int)i * 100, (int)i * 100, 100, 100);
 		for (j = 0; j < planes_len; j++) {
 			if (j == 1) {
 				/* Make the lowest plane above the primary plane
-- 
GitLab

