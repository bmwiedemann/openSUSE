Index: xen-4.12.0-testing/xen/arch/x86/platform_hypercall.c
===================================================================
--- xen-4.12.0-testing.orig/xen/arch/x86/platform_hypercall.c
+++ xen-4.12.0-testing/xen/arch/x86/platform_hypercall.c
@@ -25,7 +25,7 @@
 #include <xen/symbols.h>
 #include <asm/current.h>
 #include <public/platform.h>
-#include <acpi/cpufreq/processor_perf.h>
+#include <acpi/cpufreq/cpufreq.h>
 #include <asm/edd.h>
 #include <asm/mtrr.h>
 #include <asm/io_apic.h>
@@ -807,6 +807,41 @@ ret_t do_platform_op(XEN_GUEST_HANDLE_PA
             ret = -EFAULT;
     }
     break;
+
+    case XENPF_get_cpu_freq:
+    case XENPF_get_cpu_freq_min:
+    case XENPF_get_cpu_freq_max:
+    {
+        struct vcpu *v;
+        const struct cpufreq_policy *policy;
+
+        if ( op->u.get_cpu_freq.vcpu >= current->domain->max_vcpus ||
+             !(v = current->domain->vcpu[op->u.get_cpu_freq.vcpu]) )
+        {
+            ret = -EINVAL;
+            break;
+        }
+
+        policy = per_cpu(cpufreq_cpu_policy, v->processor);
+        switch ( op->cmd & -!!policy )
+        {
+        case XENPF_get_cpu_freq:
+            op->u.get_cpu_freq.freq = policy->cur;
+            break;
+        case XENPF_get_cpu_freq_min:
+            op->u.get_cpu_freq.freq = policy->min;
+            break;
+        case XENPF_get_cpu_freq_max:
+            op->u.get_cpu_freq.freq = policy->max;
+            break;
+        default:
+            op->u.get_cpu_freq.freq = 0;
+            break;
+        }
+        if ( __copy_field_to_guest(u_xenpf_op, op, u.get_cpu_freq.freq) )
+            ret = -EFAULT;
+    }
+    break;
 
     default:
         ret = -ENOSYS;
Index: xen-4.12.0-testing/xen/include/public/platform.h
===================================================================
--- xen-4.12.0-testing.orig/xen/include/public/platform.h
+++ xen-4.12.0-testing/xen/include/public/platform.h
@@ -553,6 +553,16 @@ struct xenpf_core_parking {
 typedef struct xenpf_core_parking xenpf_core_parking_t;
 DEFINE_XEN_GUEST_HANDLE(xenpf_core_parking_t);
 
+#define XENPF_get_cpu_freq        ('N' << 24)
+#define XENPF_get_cpu_freq_min    (XENPF_get_cpu_freq + 1)
+#define XENPF_get_cpu_freq_max    (XENPF_get_cpu_freq_min + 1)
+struct xenpf_get_cpu_freq {
+    /* IN variables */
+    uint32_t vcpu;
+    /* OUT variables */
+    uint32_t freq; /* in kHz */
+};
+
 /*
  * Access generic platform resources(e.g., accessing MSR, port I/O, etc)
  * in unified way. Batch resource operations in one call are supported and
@@ -644,6 +654,7 @@ struct xen_platform_op {
         struct xenpf_core_parking      core_parking;
         struct xenpf_resource_op       resource_op;
         struct xenpf_symdata           symdata;
+        struct xenpf_get_cpu_freq      get_cpu_freq;
         uint8_t                        pad[128];
     } u;
 };
