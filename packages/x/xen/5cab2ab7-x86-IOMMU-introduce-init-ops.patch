
References: bsc#1135799

# Commit 1b3cc8000c82edc9761c1e595928d6584e11f9f5
# Date 2019-04-08 13:04:23 +0200
# Author Jan Beulich <jbeulich@suse.com>
# Committer Jan Beulich <jbeulich@suse.com>
x86/IOMMU: introduce init-ops structure

Do away with the CPU vendor dependency, and set the init ops pointer
based on which ACPI tables have been found.

Also take the opportunity and add __read_mostly to iommu_ops.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Kevin Tian <kevin.tian@intel.com>
Acked-by: Brian Woods <brian.woods@amd.com>

--- a/xen/drivers/passthrough/amd/pci_amd_iommu.c
+++ b/xen/drivers/passthrough/amd/pci_amd_iommu.c
@@ -30,6 +30,7 @@
 
 static bool_t __read_mostly init_done;
 
+static const struct iommu_init_ops _iommu_init_ops;
 static const struct iommu_ops amd_iommu_ops;
 
 struct amd_iommu *find_iommu_for_device(int seg, int bdf)
@@ -185,10 +186,12 @@ int __init acpi_ivrs_init(void)
         return -ENODEV;
     }
 
+    iommu_init_ops = &_iommu_init_ops;
+
     return 0;
 }
 
-int __init amd_iov_detect(void)
+static int __init iov_detect(void)
 {
     if ( !iommu_enable && !iommu_intremap )
         return 0;
@@ -604,3 +607,7 @@ static const struct iommu_ops __initcons
     .crash_shutdown = amd_iommu_crash_shutdown,
     .dump_p2m_table = amd_dump_p2m_table,
 };
+
+static const struct iommu_init_ops __initconstrel _iommu_init_ops = {
+    .setup = iov_detect,
+};
--- a/xen/drivers/passthrough/vtd/dmar.c
+++ b/xen/drivers/passthrough/vtd/dmar.c
@@ -993,7 +993,11 @@ int __init acpi_dmar_init(void)
     ret = parse_dmar_table(acpi_parse_dmar);
 
     if ( !ret )
+    {
+        iommu_init_ops = &intel_iommu_init_ops;
+
         return add_user_rmrr();
+    }
 
     return ret;
 }
--- a/xen/drivers/passthrough/vtd/extern.h
+++ b/xen/drivers/passthrough/vtd/extern.h
@@ -27,6 +27,7 @@
 
 struct pci_ats_dev;
 extern bool_t rwbf_quirk;
+extern const struct iommu_init_ops intel_iommu_init_ops;
 extern const struct iommu_ops intel_iommu_ops;
 
 void print_iommu_regs(struct acpi_drhd_unit *drhd);
--- a/xen/drivers/passthrough/vtd/iommu.c
+++ b/xen/drivers/passthrough/vtd/iommu.c
@@ -2280,7 +2280,7 @@ static void __hwdom_init setup_hwdom_rmr
     pcidevs_unlock();
 }
 
-int __init intel_vtd_setup(void)
+static int __init vtd_setup(void)
 {
     struct acpi_drhd_unit *drhd;
     struct iommu *iommu;
@@ -2735,6 +2735,10 @@ const struct iommu_ops __initconstrel in
     .dump_p2m_table = vtd_dump_p2m_table,
 };
 
+const struct iommu_init_ops __initconstrel intel_iommu_init_ops = {
+    .setup = vtd_setup,
+};
+
 /*
  * Local variables:
  * mode: C
--- a/xen/drivers/passthrough/x86/iommu.c
+++ b/xen/drivers/passthrough/x86/iommu.c
@@ -23,7 +23,8 @@
 #include <asm/hvm/io.h>
 #include <asm/setup.h>
 
-struct iommu_ops iommu_ops;
+const struct iommu_init_ops *__initdata iommu_init_ops;
+struct iommu_ops __read_mostly iommu_ops;
 
 void iommu_update_ire_from_apic(
     unsigned int apic, unsigned int reg, unsigned int value)
--- a/xen/include/asm-x86/iommu.h
+++ b/xen/include/asm-x86/iommu.h
@@ -56,9 +56,6 @@ struct arch_iommu
     struct guest_iommu *g_iommu;
 };
 
-int intel_vtd_setup(void);
-int amd_iov_detect(void);
-
 extern struct iommu_ops iommu_ops;
 
 static inline const struct iommu_ops *iommu_get_ops(void)
@@ -67,17 +64,15 @@ static inline const struct iommu_ops *io
     return &iommu_ops;
 }
 
+struct iommu_init_ops {
+    int (*setup)(void);
+};
+
+extern const struct iommu_init_ops *iommu_init_ops;
+
 static inline int iommu_hardware_setup(void)
 {
-    switch ( boot_cpu_data.x86_vendor )
-    {
-    case X86_VENDOR_INTEL:
-        return intel_vtd_setup();
-    case X86_VENDOR_AMD:
-        return amd_iov_detect();
-    }
-
-    return -ENODEV;
+    return iommu_init_ops ? iommu_init_ops->setup() : -ENODEV;
 }
 
 /* Are we using the domain P2M table as its IOMMU pagetable? */
