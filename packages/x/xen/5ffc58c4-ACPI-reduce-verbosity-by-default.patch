References: bsc#1177204

# Commit b4b0a8609c42d9e01dd51fd59ab2859f7df2a961
# Date 2021-01-11 14:55:16 +0100
# Author Jan Beulich <jbeulich@suse.com>
# Committer Jan Beulich <jbeulich@suse.com>
ACPI: reduce verbosity by default

While they're KERN_INFO messages and hence not visible by default, we
still have had reports that the amount of output is too large, not the
least because
- the command line controlled resizing of the console ring buffer
  happens only after SRAT parsing (which may alone produce more than 16k
  of output),
- the default resizing of the console ring buffer happens only after
  ACPI table parsing, since the default size gets calculated depending
  on the number or processors found.

Gate all per-processor logging behind a new "acpi=verbose", making sure
we wouldn't unintentionally pass this on to Dom0.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>

--- a/docs/misc/xen-command-line.pandoc
+++ b/docs/misc/xen-command-line.pandoc
@@ -75,13 +75,10 @@ of Boolean and String.  These are noted
 ## Parameter details
 
 ### acpi
-> `= force | ht | noirq | <boolean>`
+> `= force | ht | noirq | <boolean> | verbose`
 
 **String**, or **Boolean** to disable.
 
-The **acpi** option is used to control a set of four related boolean
-flags; `acpi_force`, `acpi_ht`, `acpi_noirq` and `acpi_disabled`.
-
 By default, Xen will scan the DMI data and blacklist certain systems
 which are known to have broken ACPI setups.  Providing `acpi=force`
 will cause Xen to ignore the blacklist and attempt to use all ACPI
@@ -97,12 +94,15 @@ which requires this option to function s
 Additionally, this will not prevent Xen from finding IO-APIC entries
 from the MP tables.
 
-Finally, any of the boolean false options can be used to disable ACPI
+Further, any of the boolean false options can be used to disable ACPI
 usage entirely.
 
 Because responsibility for ACPI processing is shared between Xen and
 the domain 0 kernel this option is automatically propagated to the
-domain 0 command line
+domain 0 command line.
+
+Finally, `acpi=verbose` will enable per-processor information logging
+which may otherwise be too noisy in particular on large systems.
 
 ### acpi_apic_instance
 > `= <integer>`
--- a/xen/arch/x86/setup.c
+++ b/xen/arch/x86/setup.c
@@ -78,6 +78,7 @@ unsigned long __read_mostly cr4_pv32_mas
 /* "acpi=force":  Override the disable blacklist.                   */
 /* "acpi=ht":     Limit ACPI just to boot-time to enable HT.        */
 /* "acpi=noirq":  Disables ACPI interrupt routing.                  */
+/* "acpi=verbose": Enables more verbose ACPI boot time logging.     */
 static int parse_acpi_param(const char *s);
 custom_param("acpi", parse_acpi_param);
 
@@ -216,9 +217,6 @@ static char __initdata acpi_param[10] =
 
 static int __init parse_acpi_param(const char *s)
 {
-    /* Save the parameter so it can be propagated to domain0. */
-    safe_strcpy(acpi_param, s);
-
     /* Interpret the parameter for use within Xen. */
     if ( !parse_bool(s, NULL) )
     {
@@ -240,9 +238,17 @@ static int __init parse_acpi_param(const
     {
         acpi_noirq_set();
     }
+    else if ( !strcmp(s, "verbose") )
+    {
+        opt_acpi_verbose = true;
+        return 0;
+    }
     else
         return -EINVAL;
 
+    /* Save the parameter so it can be propagated to domain0. */
+    safe_strcpy(acpi_param, s);
+
     return 0;
 }
 
--- a/xen/arch/x86/srat.c
+++ b/xen/arch/x86/srat.c
@@ -230,8 +230,10 @@ acpi_numa_x2apic_affinity_init(const str
 	apicid_to_node[pa->apic_id] = node;
 	node_set(node, processor_nodes_parsed);
 	acpi_numa = 1;
-	printk(KERN_INFO "SRAT: PXM %u -> APIC %08x -> Node %u\n",
-	       pxm, pa->apic_id, node);
+
+	if (opt_acpi_verbose)
+		printk(KERN_INFO "SRAT: PXM %u -> APIC %08x -> Node %u\n",
+		       pxm, pa->apic_id, node);
 }
 
 /* Callback for Proximity Domain -> LAPIC mapping */
@@ -263,8 +265,10 @@ acpi_numa_processor_affinity_init(const
 	apicid_to_node[pa->apic_id] = node;
 	node_set(node, processor_nodes_parsed);
 	acpi_numa = 1;
-	printk(KERN_INFO "SRAT: PXM %u -> APIC %02x -> Node %u\n",
-	       pxm, pa->apic_id, node);
+
+	if (opt_acpi_verbose)
+		printk(KERN_INFO "SRAT: PXM %u -> APIC %02x -> Node %u\n",
+		       pxm, pa->apic_id, node);
 }
 
 /* Callback for parsing of the Proximity Domain <-> Memory Area mappings */
--- a/xen/drivers/acpi/tables.c
+++ b/xen/drivers/acpi/tables.c
@@ -36,6 +36,8 @@
 
 #define ACPI_MAX_TABLES		128
 
+bool __initdata opt_acpi_verbose;
+
 static const char *__initdata
 mps_inti_flags_polarity[] = { "dfl", "high", "res", "low" };
 static const char *__initdata
@@ -51,6 +53,7 @@ void __init acpi_table_print_madt_entry(
 	switch (header->type) {
 
 	case ACPI_MADT_TYPE_LOCAL_APIC:
+		if (opt_acpi_verbose)
 		{
 			struct acpi_madt_local_apic *p =
 			    (struct acpi_madt_local_apic *)header;
@@ -62,6 +65,7 @@ void __init acpi_table_print_madt_entry(
 		break;
 
 	case ACPI_MADT_TYPE_LOCAL_X2APIC:
+		if (opt_acpi_verbose)
 		{
 			struct acpi_madt_local_x2apic *p =
 			    (struct acpi_madt_local_x2apic *)header;
@@ -115,6 +119,7 @@ void __init acpi_table_print_madt_entry(
 		break;
 
 	case ACPI_MADT_TYPE_LOCAL_APIC_NMI:
+		if (opt_acpi_verbose)
 		{
 			struct acpi_madt_local_apic_nmi *p =
 			    (struct acpi_madt_local_apic_nmi *)header;
@@ -128,6 +133,7 @@ void __init acpi_table_print_madt_entry(
 		break;
 
 	case ACPI_MADT_TYPE_LOCAL_X2APIC_NMI:
+		if (opt_acpi_verbose)
 		{
 			u16 polarity, trigger;
 			struct acpi_madt_local_x2apic_nmi *p =
@@ -167,6 +173,7 @@ void __init acpi_table_print_madt_entry(
 		break;
 
 	case ACPI_MADT_TYPE_LOCAL_SAPIC:
+		if (opt_acpi_verbose)
 		{
 			struct acpi_madt_local_sapic *p =
 			    (struct acpi_madt_local_sapic *)header;
--- a/xen/include/xen/acpi.h
+++ b/xen/include/xen/acpi.h
@@ -53,6 +53,8 @@
 
 extern acpi_physical_address rsdp_hint;
 
+extern bool opt_acpi_verbose;
+
 enum acpi_interrupt_id {
 	ACPI_INTERRUPT_PMI	= 1,
 	ACPI_INTERRUPT_INIT,
