Index: xen-4.17.0-testing/Config.mk
===================================================================
--- xen-4.17.0-testing.orig/Config.mk
+++ xen-4.17.0-testing/Config.mk
@@ -73,7 +73,7 @@ EXTRA_INCLUDES += $(EXTRA_PREFIX)/includ
 EXTRA_LIB += $(EXTRA_PREFIX)/lib
 endif
 
-PYTHON      ?= python
+PYTHON      ?= python3
 PYTHON_PREFIX_ARG ?= --prefix="$(prefix)"
 # The above requires that prefix contains *no spaces*. This variable is here
 # to permit the user to set PYTHON_PREFIX_ARG to '' to workaround this bug:
Index: xen-4.17.0-testing/tools/configure
===================================================================
--- xen-4.17.0-testing.orig/tools/configure
+++ xen-4.17.0-testing/tools/configure
@@ -7343,15 +7343,15 @@ if test x"${PYTHONPATH}" = x"no"
 then
     as_fn_error $? "Unable to find $PYTHON, please install $PYTHON" "$LINENO" 5
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for python version >= 2.6 " >&5
-$as_echo_n "checking for python version >= 2.6 ... " >&6; }
-`$PYTHON -c 'import sys; sys.exit(eval("sys.version_info < (2, 6)"))'`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for python3 version >= 3.0 " >&5
+$as_echo_n "checking for python3 version >= 3.0 ... " >&6; }
+`$PYTHON -c 'import sys; sys.exit(eval("sys.version_info < (3, 0)"))'`
 if test "$?" != "0"
 then
     python_version=`$PYTHON -V 2>&1`
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-    as_fn_error $? "$python_version is too old, minimum required version is 2.6" "$LINENO" 5
+    as_fn_error $? "$python_version is too old, minimum required version is 3.0" "$LINENO" 5
 else
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
Index: xen-4.17.0-testing/tools/configure.ac
===================================================================
--- xen-4.17.0-testing.orig/tools/configure.ac
+++ xen-4.17.0-testing/tools/configure.ac
@@ -361,7 +361,7 @@ PYTHONPATH=$PYTHON
 PYTHON=`basename $PYTHONPATH`
 
 AX_PATH_PROG_OR_FAIL([PYTHONPATH], [$PYTHON])
-AX_CHECK_PYTHON_VERSION([2], [6])
+AX_CHECK_PYTHON_VERSION([3], [0])
 
 AS_IF([test "$cross_compiling" != yes], [
     AX_CHECK_PYTHON_DEVEL()
Index: xen-4.17.0-testing/tools/libs/light/idl.py
===================================================================
--- xen-4.17.0-testing.orig/tools/libs/light/idl.py
+++ xen-4.17.0-testing/tools/libs/light/idl.py
@@ -271,7 +271,7 @@ class KeyedUnion(Aggregate):
         if not isinstance(keyvar_type, Enumeration):
             raise ValueError
 
-        kv_kwargs = dict([(x.lstrip('keyvar_'),y) for (x,y) in kwargs.items() if x.startswith('keyvar_')])
+        kv_kwargs = dict([(x.lstrip('keyvar_'),y) for (x,y) in list(kwargs.items()) if x.startswith('keyvar_')])
         
         self.keyvar = Field(keyvar_type, keyvar_name, **kv_kwargs)
 
@@ -317,7 +317,7 @@ class Array(Type):
         kwargs.setdefault('json_parse_type', 'JSON_ARRAY')
         Type.__init__(self, namespace=elem_type.namespace, typename=elem_type.rawname + " *", **kwargs)
 
-        lv_kwargs = dict([(x.lstrip('lenvar_'),y) for (x,y) in kwargs.items() if x.startswith('lenvar_')])
+        lv_kwargs = dict([(x.lstrip('lenvar_'),y) for (x,y) in list(kwargs.items()) if x.startswith('lenvar_')])
 
         self.lenvar = Field(integer, lenvar_name, **lv_kwargs)
         self.elem_type = elem_type
@@ -353,7 +353,7 @@ def parse(f):
     globs = {}
     locs = OrderedDict()
 
-    for n,t in globals().items():
+    for n,t in list(globals().items()):
         if isinstance(t, Type):
             globs[n] = t
         elif isinstance(t,type(object)) and issubclass(t, Type):
Index: xen-4.17.0-testing/tools/libs/light/gentest.py
===================================================================
--- xen-4.17.0-testing.orig/tools/libs/light/gentest.py
+++ xen-4.17.0-testing/tools/libs/light/gentest.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 
 from __future__ import print_function
 
Index: xen-4.17.0-testing/tools/libs/light/gentypes.py
===================================================================
--- xen-4.17.0-testing.orig/tools/libs/light/gentypes.py
+++ xen-4.17.0-testing/tools/libs/light/gentypes.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 
 from __future__ import print_function
 
Index: xen-4.17.0-testing/tools/ocaml/libs/xentoollog/genlevels.py
===================================================================
--- xen-4.17.0-testing.orig/tools/ocaml/libs/xentoollog/genlevels.py
+++ xen-4.17.0-testing/tools/ocaml/libs/xentoollog/genlevels.py
@@ -89,7 +89,7 @@ def gen_c(level):
 def autogen_header(open_comment, close_comment):
     s = open_comment + " AUTO-GENERATED FILE DO NOT EDIT " + close_comment + "\n"
     s += open_comment + " autogenerated by \n"
-    s += reduce(lambda x,y: x + " ", range(len(open_comment + " ")), "")
+    s += reduce(lambda x,y: x + " ", list(range(len(open_comment + " "))), "")
     s += "%s" % " ".join(sys.argv)
     s += "\n " + close_comment + "\n\n"
     return s
Index: xen-4.17.0-testing/tools/include/xen-foreign/mkheader.py
===================================================================
--- xen-4.17.0-testing.orig/tools/include/xen-foreign/mkheader.py
+++ xen-4.17.0-testing/tools/include/xen-foreign/mkheader.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 
 from __future__ import print_function
 
Index: xen-4.17.0-testing/tools/include/xen-foreign/mkchecker.py
===================================================================
--- xen-4.17.0-testing.orig/tools/include/xen-foreign/mkchecker.py
+++ xen-4.17.0-testing/tools/include/xen-foreign/mkchecker.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 
 import sys;
 from structs import structs, compat_arches;
Index: xen-4.17.0-testing/xen/tools/gen-cpuid.py
===================================================================
--- xen-4.17.0-testing.orig/xen/tools/gen-cpuid.py
+++ xen-4.17.0-testing/xen/tools/gen-cpuid.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python3
 # -*- coding: utf-8 -*-
 
 import sys, os, re
Index: xen-4.17.0-testing/xen/tools/compat-build-source.py
===================================================================
--- xen-4.17.0-testing.orig/xen/tools/compat-build-source.py
+++ xen-4.17.0-testing/xen/tools/compat-build-source.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python3
 
 import re,sys
 
Index: xen-4.17.0-testing/xen/tools/compat-build-header.py
===================================================================
--- xen-4.17.0-testing.orig/xen/tools/compat-build-header.py
+++ xen-4.17.0-testing/xen/tools/compat-build-header.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python3
 
 import re,sys
 
Index: xen-4.17.0-testing/tools/misc/xensymoops
===================================================================
--- xen-4.17.0-testing.orig/tools/misc/xensymoops
+++ xen-4.17.0-testing/tools/misc/xensymoops
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python3
 
 # An oops analyser for Xen
 # Usage: xensymoops path-to-xen.s < oops-message
@@ -43,12 +43,12 @@ def read_oops():
     return (eip_addr, stack_addresses)
 
 def usage():
-    print >> sys.stderr, """Usage: %s path-to-asm < oops-msg
+    print("""Usage: %s path-to-asm < oops-msg
     The oops message should be fed to the standard input.  The
     command-line argument specifies the path to the Xen assembly dump
     produced by \"make debug\".  The location of EIP and the backtrace
     will be output to standard output.
-    """ % sys.argv[0]
+    """ % sys.argv[0], file=sys.stderr)
     sys.exit()
 
 ##### main
@@ -99,7 +99,7 @@ while True:
 
     # if this address was seen as a potential code address in the backtrace then
     # record it in the backtrace list
-    if stk_addrs.has_key(address):
+    if address in stk_addrs:
         backtrace.append((stk_addrs[address], address, func))
 
     # if this was the address that EIP...
@@ -107,12 +107,12 @@ while True:
         eip_func = func
 
 
-print "EIP %s in function %s" % (eip_addr, eip_func)
-print "Backtrace:"
+print("EIP %s in function %s" % (eip_addr, eip_func))
+print("Backtrace:")
 
 # sorting will order primarily by the first element of each tuple,
 # i.e. the order in the original oops
 backtrace.sort()
 
 for (i, a, f) in backtrace:
-    print "%s in function %s" % ( a, f )
+    print("%s in function %s" % ( a, f ))
