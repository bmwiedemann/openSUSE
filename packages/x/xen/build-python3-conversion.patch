Index: xen-4.13.0-testing/Config.mk
===================================================================
--- xen-4.13.0-testing.orig/Config.mk
+++ xen-4.13.0-testing/Config.mk
@@ -82,7 +82,7 @@ EXTRA_INCLUDES += $(EXTRA_PREFIX)/includ
 EXTRA_LIB += $(EXTRA_PREFIX)/lib
 endif
 
-PYTHON      ?= python
+PYTHON      ?= python3
 PYTHON_PREFIX_ARG ?= --prefix="$(prefix)"
 # The above requires that prefix contains *no spaces*. This variable is here
 # to permit the user to set PYTHON_PREFIX_ARG to '' to workaround this bug:
Index: xen-4.13.0-testing/tools/configure
===================================================================
--- xen-4.13.0-testing.orig/tools/configure
+++ xen-4.13.0-testing/tools/configure
@@ -6926,7 +6926,7 @@ then
 fi;;
 esac
 if test -z "$PYTHON"; then :
-  for ac_prog in python python3 python2
+  for ac_prog in python3 python python2
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
@@ -7065,15 +7065,15 @@ if test x"${PYTHONPATH}" = x"no"
 then
     as_fn_error $? "Unable to find $PYTHON, please install $PYTHON" "$LINENO" 5
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for python version >= 2.6 " >&5
-$as_echo_n "checking for python version >= 2.6 ... " >&6; }
-`$PYTHON -c 'import sys; sys.exit(eval("sys.version_info < (2, 6)"))'`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for python3 version >= 3.0 " >&5
+$as_echo_n "checking for python3 version >= 3.0 ... " >&6; }
+`$PYTHON -c 'import sys; sys.exit(eval("sys.version_info < (3, 0)"))'`
 if test "$?" != "0"
 then
     python_version=`$PYTHON -V 2>&1`
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-    as_fn_error $? "$python_version is too old, minimum required version is 2.6" "$LINENO" 5
+    as_fn_error $? "$python_version is too old, minimum required version is 3.0" "$LINENO" 5
 else
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
Index: xen-4.13.0-testing/tools/python/test.py
===================================================================
--- xen-4.13.0-testing.orig/tools/python/test.py
+++ xen-4.13.0-testing/tools/python/test.py
@@ -1,4 +1,4 @@
-#! /usr/bin/env python2.3
+#!/usr/bin/python3
 ##############################################################################
 #
 # Copyright (c) 2001, 2002 Zope Corporation and Contributors.
@@ -289,9 +289,9 @@ class ImmediateTestResult(unittest._Text
     def stopTest(self, test):
         self._testtimes[test] = time.time() - self._testtimes[test]
         if gc.garbage:
-            print "The following test left garbage:"
-            print test
-            print gc.garbage
+            print("The following test left garbage:")
+            print(test)
+            print(gc.garbage)
             # XXX Perhaps eat the garbage here, so that the garbage isn't
             #     printed for every subsequent test.
 
@@ -301,23 +301,23 @@ class ImmediateTestResult(unittest._Text
                              and
                              t not in self._threads)]
         if new_threads:
-            print "The following test left new threads behind:"
-            print test
-            print "New thread(s):", new_threads
+            print("The following test left new threads behind:")
+            print(test)
+            print("New thread(s):", new_threads)
 
     def print_times(self, stream, count=None):
-        results = self._testtimes.items()
+        results = list(self._testtimes.items())
         results.sort(lambda x, y: cmp(y[1], x[1]))
         if count:
             n = min(count, len(results))
             if n:
-                print >>stream, "Top %d longest tests:" % n
+                print("Top %d longest tests:" % n, file=stream)
         else:
             n = len(results)
         if not n:
             return
         for i in range(n):
-            print >>stream, "%6dms" % int(results[i][1] * 1000), results[i][0]
+            print("%6dms" % int(results[i][1] * 1000), results[i][0], file=stream)
 
     def _print_traceback(self, msg, err, test, errlist):
         if self.showAll or self.dots or self._progress:
@@ -369,7 +369,7 @@ class ImmediateTestResult(unittest._Text
         if self._progress:
             self.stream.write("\r")
         if self._debug:
-            raise err[0], err[1], err[2]
+            raise err[0](err[1]).with_traceback(err[2])
         self._print_traceback("Error in test %s" % test, err,
                               test, self.errors)
 
@@ -377,7 +377,7 @@ class ImmediateTestResult(unittest._Text
         if self._progress:
             self.stream.write("\r")
         if self._debug:
-            raise err[0], err[1], err[2]
+            raise err[0](err[1]).with_traceback(err[2])
         self._print_traceback("Failure in test %s" % test, err,
                               test, self.failures)
 
@@ -480,11 +480,11 @@ class PathInit:
         kind = functional and "FUNCTIONAL" or "UNIT"
         if libdir:
             extra = os.path.join(self.org_cwd, libdir)
-            print "Running %s tests from %s" % (kind, extra)
+            print("Running %s tests from %s" % (kind, extra))
             self.libdir = extra
             sys.path.insert(0, extra)
         else:
-            print "Running %s tests from %s" % (kind, self.cwd)
+            print("Running %s tests from %s" % (kind, self.cwd))
         # Make sure functional tests find ftesting.zcml
         if functional:
             config_file = 'ftesting.zcml'
@@ -492,7 +492,7 @@ class PathInit:
                 # We chdired into build, so ftesting.zcml is in the
                 # parent directory
                 config_file = os.path.join('..', 'ftesting.zcml')
-            print "Parsing %s" % config_file
+            print("Parsing %s" % config_file)
             from zope.app.tests.functional import FunctionalTestSetup
             FunctionalTestSetup(config_file)
 
@@ -530,7 +530,7 @@ class TestFileFinder:
         if not "__init__.py" in files:
             if not files or files == ["CVS"]:
                 return
-            print "not a package", dir
+            print("not a package", dir)
             return
 
         # Put matching files in matches.  If matches is non-empty,
@@ -549,9 +549,9 @@ class TestFileFinder:
             __import__(pkg)
         # We specifically do not want to catch ImportError since that's useful
         # information to know when running the tests.
-        except RuntimeError, e:
+        except RuntimeError as e:
             if VERBOSE:
-                print "skipping %s because: %s" % (pkg, e)
+                print("skipping %s because: %s" % (pkg, e))
             return
         else:
             self.files.extend(matches)
@@ -698,16 +698,16 @@ class TrackRefs:
         ct = [(type2count[t] - self.type2count.get(t, 0),
                type2all[t] - self.type2all.get(t, 0),
                t)
-              for t in type2count.iterkeys()]
+              for t in type2count.keys()]
         ct.sort()
         ct.reverse()
         printed = False
         for delta1, delta2, t in ct:
             if delta1 or delta2:
                 if not printed:
-                    print "%-55s %8s %8s" % ('', 'insts', 'refs')
+                    print("%-55s %8s %8s" % ('', 'insts', 'refs'))
                     printed = True
-                print "%-55s %8d %8d" % (t, delta1, delta2)
+                print("%-55s %8d %8d" % (t, delta1, delta2))
 
         self.type2count = type2count
         self.type2all = type2all
@@ -729,25 +729,25 @@ def runner(files, test_filter, debug):
         if TIMESFN:
             r.print_times(open(TIMESFN, "w"))
             if VERBOSE:
-                print "Wrote timing data to", TIMESFN
+                print("Wrote timing data to", TIMESFN)
         if TIMETESTS:
             r.print_times(sys.stdout, TIMETESTS)
     except:
         if DEBUGGER:
-            print "%s:" % (sys.exc_info()[0], )
-            print sys.exc_info()[1]
+            print("%s:" % (sys.exc_info()[0], ))
+            print(sys.exc_info()[1])
             pdb.post_mortem(sys.exc_info()[2])
         else:
             raise
 
 def remove_stale_bytecode(arg, dirname, names):
-    names = map(os.path.normcase, names)
+    names = list(map(os.path.normcase, names))
     for name in names:
         if name.endswith(".pyc") or name.endswith(".pyo"):
             srcname = name[:-1]
             if srcname not in names:
                 fullname = os.path.join(dirname, name)
-                print "Removing stale bytecode file", fullname
+                print("Removing stale bytecode file", fullname)
                 os.unlink(fullname)
 
 def main(module_filter, test_filter, libdir):
@@ -773,12 +773,12 @@ def main(module_filter, test_filter, lib
             runner(files, test_filter, DEBUG)
             gc.collect()
             if gc.garbage:
-                print "GARBAGE:", len(gc.garbage), gc.garbage
+                print("GARBAGE:", len(gc.garbage), gc.garbage)
                 return
             if REFCOUNT:
                 prev = rc
                 rc = sys.gettotalrefcount()
-                print "totalrefcount=%-8d change=%-6d" % (rc, rc - prev)
+                print("totalrefcount=%-8d change=%-6d" % (rc, rc - prev))
                 track.update()
     else:
         runner(files, test_filter, DEBUG)
@@ -801,7 +801,7 @@ def configure_logging():
     else:
         logging.basicConfig()
 
-    if os.environ.has_key("LOGGING"):
+    if "LOGGING" in os.environ:
         level = int(os.environ["LOGGING"])
         logging.getLogger().setLevel(level)
 
@@ -865,8 +865,8 @@ def process_args(argv=None):
 
     # import the config file
     if os.path.isfile(config_filename):
-        print 'Configuration file found.'
-        execfile(config_filename, globals())
+        print('Configuration file found.')
+        exec(compile(open(config_filename).read(), config_filename, 'exec'), globals())
 
 
     try:
@@ -884,9 +884,9 @@ def process_args(argv=None):
     # fixme: add the long names
     # fixme: add the extra documentation
     # fixme: test for functional first!
-    except getopt.error, msg:
-        print msg
-        print "Try `python %s -h' for more information." % argv[0]
+    except getopt.error as msg:
+        print(msg)
+        print("Try `python %s -h' for more information." % argv[0])
         sys.exit(2)
 
     for k, v in opts:
@@ -916,13 +916,13 @@ def process_args(argv=None):
             RUN_UNIT = True
             RUN_FUNCTIONAL = True
         elif k in ("-h", "--help"):
-            print __doc__
+            print(__doc__)
             sys.exit(0)
         elif k in ("-g", "--gc-threshold"):
             GC_THRESHOLD = int(v)
         elif k in ("-G", "--gc-option"):
             if not v.startswith("DEBUG_"):
-                print "-G argument must be DEBUG_ flag, not", repr(v)
+                print("-G argument must be DEBUG_ flag, not", repr(v))
                 sys.exit(1)
             GC_FLAGS.append(v)
         elif k in ('-k', '--keepbytecode'):
@@ -968,30 +968,30 @@ def process_args(argv=None):
         import pychecker.checker
 
     if REFCOUNT and not hasattr(sys, "gettotalrefcount"):
-        print "-r ignored, because it needs a debug build of Python"
+        print("-r ignored, because it needs a debug build of Python")
         REFCOUNT = False
 
     if sys.version_info < ( 2,3,2 ):
-        print """\
+        print("""\
         ERROR: Your python version is not supported by Zope3.
-        Zope3 needs Python 2.3.2 or greater. You are running:""" + sys.version
+        Zope3 needs Python 2.3.2 or greater. You are running:""" + sys.version)
         sys.exit(1)
 
     if GC_THRESHOLD is not None:
         if GC_THRESHOLD == 0:
             gc.disable()
-            print "gc disabled"
+            print("gc disabled")
         else:
             gc.set_threshold(GC_THRESHOLD)
-            print "gc threshold:", gc.get_threshold()
+            print("gc threshold:", gc.get_threshold())
 
     if GC_FLAGS:
         val = 0
         for flag in GC_FLAGS:
             v = getattr(gc, flag, None)
             if v is None:
-                print "Unknown gc flag", repr(flag)
-                print gc.set_debug.__doc__
+                print("Unknown gc flag", repr(flag))
+                print(gc.set_debug.__doc__)
                 sys.exit(1)
             val |= v
         gcdebug |= v
@@ -1009,10 +1009,10 @@ def process_args(argv=None):
         if BUILD_INPLACE:
             cmd += "_ext -i"
         if VERBOSE:
-            print cmd
+            print(cmd)
         sts = os.system(cmd)
         if sts:
-            print "Build failed", hex(sts)
+            print("Build failed", hex(sts))
             sys.exit(1)
 
     k = []
@@ -1027,9 +1027,9 @@ def process_args(argv=None):
         if VERBOSE:
             kind = functional and "FUNCTIONAL" or "UNIT"
             if LEVEL == 0:
-                print "Running %s tests at all levels" % kind
+                print("Running %s tests at all levels" % kind)
             else:
-                print "Running %s tests at level %d" % (kind, LEVEL)
+                print("Running %s tests at level %d" % (kind, LEVEL))
 
 # This was to avoid functional tests outside of z3, but this doesn't really
 # work right.
@@ -1073,20 +1073,20 @@ def process_args(argv=None):
                               globals=globals(), locals=vars())
                 r = tracer.results()
                 path = "/tmp/trace.%s" % os.getpid()
-                import cPickle
+                import pickle
                 f = open(path, "wb")
-                cPickle.dump(r, f)
+                pickle.dump(r, f)
                 f.close()
-                print path
+                print(path)
                 r.write_results(show_missing=True,
                                 summary=True, coverdir=coverdir)
             else:
                 bad = main(MODULE_FILTER, TEST_FILTER, LIBDIR)
                 if bad:
                     sys.exit(1)
-        except ImportError, err:
-            print err
-            print sys.path
+        except ImportError as err:
+            print(err)
+            print(sys.path)
             raise
 
 
Index: xen-4.13.0-testing/tools/configure.ac
===================================================================
--- xen-4.13.0-testing.orig/tools/configure.ac
+++ xen-4.13.0-testing/tools/configure.ac
@@ -337,14 +337,14 @@ case "$host_os" in
   freebsd*) ;;
   *) AX_PATH_PROG_OR_FAIL([BASH], [bash]);;
 esac
-AS_IF([test -z "$PYTHON"], [AC_CHECK_PROGS([PYTHON], [python python3 python2], err)])
+AS_IF([test -z "$PYTHON"], [AC_CHECK_PROGS([PYTHON], [python3 python python2], err)])
 AS_IF([test "$PYTHON" = "err"], [AC_MSG_ERROR([No python interpreter found])])
 AS_IF([echo "$PYTHON" | grep -q "^/"], [], [AC_PATH_PROG([PYTHON], [$PYTHON])])
 PYTHONPATH=$PYTHON
 PYTHON=`basename $PYTHONPATH`
 
 AX_PATH_PROG_OR_FAIL([PYTHONPATH], [$PYTHON])
-AX_CHECK_PYTHON_VERSION([2], [6])
+AX_CHECK_PYTHON_VERSION([3], [0])
 
 AS_IF([test "$cross_compiling" != yes], [
     AX_CHECK_PYTHON_DEVEL()
Index: xen-4.13.0-testing/tools/libxl/idl.py
===================================================================
--- xen-4.13.0-testing.orig/tools/libxl/idl.py
+++ xen-4.13.0-testing/tools/libxl/idl.py
@@ -271,7 +271,7 @@ class KeyedUnion(Aggregate):
         if not isinstance(keyvar_type, Enumeration):
             raise ValueError
 
-        kv_kwargs = dict([(x.lstrip('keyvar_'),y) for (x,y) in kwargs.items() if x.startswith('keyvar_')])
+        kv_kwargs = dict([(x.lstrip('keyvar_'),y) for (x,y) in list(kwargs.items()) if x.startswith('keyvar_')])
         
         self.keyvar = Field(keyvar_type, keyvar_name, **kv_kwargs)
 
@@ -317,7 +317,7 @@ class Array(Type):
         kwargs.setdefault('json_parse_type', 'JSON_ARRAY')
         Type.__init__(self, namespace=elem_type.namespace, typename=elem_type.rawname + " *", **kwargs)
 
-        lv_kwargs = dict([(x.lstrip('lenvar_'),y) for (x,y) in kwargs.items() if x.startswith('lenvar_')])
+        lv_kwargs = dict([(x.lstrip('lenvar_'),y) for (x,y) in list(kwargs.items()) if x.startswith('lenvar_')])
 
         self.lenvar = Field(integer, lenvar_name, **lv_kwargs)
         self.elem_type = elem_type
@@ -353,7 +353,7 @@ def parse(f):
     globs = {}
     locs = OrderedDict()
 
-    for n,t in globals().items():
+    for n,t in list(globals().items()):
         if isinstance(t, Type):
             globs[n] = t
         elif isinstance(t,type(object)) and issubclass(t, Type):
Index: xen-4.13.0-testing/tools/libxl/gentest.py
===================================================================
--- xen-4.13.0-testing.orig/tools/libxl/gentest.py
+++ xen-4.13.0-testing/tools/libxl/gentest.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 
 from __future__ import print_function
 
Index: xen-4.13.0-testing/tools/libxl/gentypes.py
===================================================================
--- xen-4.13.0-testing.orig/tools/libxl/gentypes.py
+++ xen-4.13.0-testing/tools/libxl/gentypes.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 
 from __future__ import print_function
 
Index: xen-4.13.0-testing/tools/ocaml/libs/xentoollog/genlevels.py
===================================================================
--- xen-4.13.0-testing.orig/tools/ocaml/libs/xentoollog/genlevels.py
+++ xen-4.13.0-testing/tools/ocaml/libs/xentoollog/genlevels.py
@@ -89,7 +89,7 @@ def gen_c(level):
 def autogen_header(open_comment, close_comment):
     s = open_comment + " AUTO-GENERATED FILE DO NOT EDIT " + close_comment + "\n"
     s += open_comment + " autogenerated by \n"
-    s += reduce(lambda x,y: x + " ", range(len(open_comment + " ")), "")
+    s += reduce(lambda x,y: x + " ", list(range(len(open_comment + " "))), "")
     s += "%s" % " ".join(sys.argv)
     s += "\n " + close_comment + "\n\n"
     return s
Index: xen-4.13.0-testing/tools/include/xen-foreign/mkheader.py
===================================================================
--- xen-4.13.0-testing.orig/tools/include/xen-foreign/mkheader.py
+++ xen-4.13.0-testing/tools/include/xen-foreign/mkheader.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 
 import sys, re;
 from structs import unions, structs, defines;
Index: xen-4.13.0-testing/tools/include/xen-foreign/mkchecker.py
===================================================================
--- xen-4.13.0-testing.orig/tools/include/xen-foreign/mkchecker.py
+++ xen-4.13.0-testing/tools/include/xen-foreign/mkchecker.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 
 import sys;
 from structs import structs, compat_arches;
Index: xen-4.13.0-testing/xen/tools/gen-cpuid.py
===================================================================
--- xen-4.13.0-testing.orig/xen/tools/gen-cpuid.py
+++ xen-4.13.0-testing/xen/tools/gen-cpuid.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python3
 # -*- coding: utf-8 -*-
 
 import sys, os, re
@@ -135,7 +135,7 @@ def crunch_numbers(state):
     common_1d = (FPU, VME, DE, PSE, TSC, MSR, PAE, MCE, CX8, APIC,
                  MTRR, PGE, MCA, CMOV, PAT, PSE36, MMX, FXSR)
 
-    state.known = featureset_to_uint32s(state.names.keys(), nr_entries)
+    state.known = featureset_to_uint32s(list(state.names.keys()), nr_entries)
     state.common_1d = featureset_to_uint32s(common_1d, 1)[0]
     state.special = featureset_to_uint32s(state.raw_special, nr_entries)
     state.pv = featureset_to_uint32s(state.raw_pv, nr_entries)
@@ -317,11 +317,11 @@ def crunch_numbers(state):
 
         state.deep_deps[feat] = seen[1:]
 
-    state.deep_features = featureset_to_uint32s(deps.keys(), nr_entries)
-    state.nr_deep_deps = len(state.deep_deps.keys())
+    state.deep_features = featureset_to_uint32s(list(deps.keys()), nr_entries)
+    state.nr_deep_deps = len(list(state.deep_deps.keys()))
 
     try:
-        _tmp = state.deep_deps.iteritems()
+        _tmp = state.deep_deps.items()
     except AttributeError:
         _tmp = state.deep_deps.items()
 
@@ -329,10 +329,10 @@ def crunch_numbers(state):
         state.deep_deps[k] = featureset_to_uint32s(v, nr_entries)
 
     # Calculate the bitfield name declarations
-    for word in xrange(nr_entries):
+    for word in range(nr_entries):
 
         names = []
-        for bit in xrange(32):
+        for bit in range(32):
 
             name = state.names.get(word * 32 + bit, "")
 
Index: xen-4.13.0-testing/xen/tools/compat-build-source.py
===================================================================
--- xen-4.13.0-testing.orig/xen/tools/compat-build-source.py
+++ xen-4.13.0-testing/xen/tools/compat-build-source.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python3
 
 import re,sys
 
Index: xen-4.13.0-testing/xen/tools/compat-build-header.py
===================================================================
--- xen-4.13.0-testing.orig/xen/tools/compat-build-header.py
+++ xen-4.13.0-testing/xen/tools/compat-build-header.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python3
 
 import re,sys
 
Index: xen-4.13.0-testing/xen/tools/fig-to-oct.py
===================================================================
--- xen-4.13.0-testing.orig/xen/tools/fig-to-oct.py
+++ xen-4.13.0-testing/xen/tools/fig-to-oct.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python3
 import sys
 
 chars_per_line = 18
Index: xen-4.13.0-testing/tools/misc/xensymoops
===================================================================
--- xen-4.13.0-testing.orig/tools/misc/xensymoops
+++ xen-4.13.0-testing/tools/misc/xensymoops
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python3
 
 # An oops analyser for Xen
 # Usage: xensymoops path-to-xen.s < oops-message
@@ -43,12 +43,12 @@ def read_oops():
     return (eip_addr, stack_addresses)
 
 def usage():
-    print >> sys.stderr, """Usage: %s path-to-asm < oops-msg
+    print("""Usage: %s path-to-asm < oops-msg
     The oops message should be fed to the standard input.  The
     command-line argument specifies the path to the Xen assembly dump
     produced by \"make debug\".  The location of EIP and the backtrace
     will be output to standard output.
-    """ % sys.argv[0]
+    """ % sys.argv[0], file=sys.stderr)
     sys.exit()
 
 ##### main
@@ -99,7 +99,7 @@ while True:
 
     # if this address was seen as a potential code address in the backtrace then
     # record it in the backtrace list
-    if stk_addrs.has_key(address):
+    if address in stk_addrs:
         backtrace.append((stk_addrs[address], address, func))
 
     # if this was the address that EIP...
@@ -107,12 +107,12 @@ while True:
         eip_func = func
 
 
-print "EIP %s in function %s" % (eip_addr, eip_func)
-print "Backtrace:"
+print("EIP %s in function %s" % (eip_addr, eip_func))
+print("Backtrace:")
 
 # sorting will order primarily by the first element of each tuple,
 # i.e. the order in the original oops
 backtrace.sort()
 
 for (i, a, f) in backtrace:
-    print "%s in function %s" % ( a, f )
+    print("%s in function %s" % ( a, f ))
