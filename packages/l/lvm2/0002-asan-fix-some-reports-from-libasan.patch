From f83b3962c10bf4e196fec0e3e735820ba908661f Mon Sep 17 00:00:00 2001
From: Zdenek Kabelac <zkabelac@redhat.com>
Date: Mon, 7 Feb 2022 19:58:04 +0100
Subject: asan: fix some reports from libasan

When compiled and used with:

CFLAGS="-fsanitize=address -g -O0"
ASAN_OPTIONS=strict_string_checks=1:detect_stack_use_after_return=1:check_initialization_order=1:strict_init_order=1

we have few reported issue - they where not normally spotted, since
we were still accessing our own memory - but ouf of buffer-range.

TODO: there is still something to enhance with handling of #orphan vgids
---
 lib/config/config.c              | 4 +++-
 lib/format_text/format-text.c    | 2 +-
 lib/format_text/text_label.c     | 6 ++++--
 lib/metadata/metadata-exported.h | 2 +-
 lib/uuid/uuid.c                  | 5 +++++
 tools/Makefile.in                | 4 ++--
 tools/command.c                  | 2 +-
 7 files changed, 17 insertions(+), 8 deletions(-)

diff --git a/lib/config/config.c b/lib/config/config.c
index c8dab5683a20..f9614779a743 100644
--- a/lib/config/config.c
+++ b/lib/config/config.c
@@ -522,7 +522,9 @@ int config_file_read_fd(struct dm_config_tree *cft, struct device *dev, dev_io_r
 	if (!(dev->flags & DEV_REGULAR) || size2)
 		use_plain_read = 0;
 
-	if (!(buf = zalloc(size + size2))) {
+	/* Ensure there is extra '\0' after end of buffer since we pass
+	 * buffer to funtions like strtoll() */
+	if (!(buf = zalloc(size + size2 + 1))) {
 		log_error("Failed to allocate circular buffer.");
 		return 0;
 	}
diff --git a/lib/format_text/format-text.c b/lib/format_text/format-text.c
index 00443faa12f7..07aaa0b28880 100644
--- a/lib/format_text/format-text.c
+++ b/lib/format_text/format-text.c
@@ -2601,7 +2601,7 @@ struct format_type *create_text_format(struct cmd_context *cmd)
 	fmt->ops = &_text_handler;
 	fmt->name = FMT_TEXT_NAME;
 	fmt->alias = FMT_TEXT_ALIAS;
-	fmt->orphan_vg_name = ORPHAN_VG_NAME(FMT_TEXT_NAME);
+	strncpy(fmt->orphan_vg_name, ORPHAN_VG_NAME(FMT_TEXT_NAME), sizeof(fmt->orphan_vg_name));
 	fmt->features = FMT_SEGMENTS | FMT_TAGS | FMT_PRECOMMIT |
 			FMT_UNLIMITED_VOLS | FMT_RESIZE_PV |
 			FMT_UNLIMITED_STRIPESIZE | FMT_CONFIG_PROFILE |
diff --git a/lib/format_text/text_label.c b/lib/format_text/text_label.c
index 29b470271170..324c86e44978 100644
--- a/lib/format_text/text_label.c
+++ b/lib/format_text/text_label.c
@@ -410,6 +410,7 @@ static int _text_read(struct cmd_context *cmd, struct labeller *labeller, struct
 {
 	struct lvmcache_vgsummary vgsummary;
 	char pvid[ID_LEN + 1] __attribute__((aligned(8))) = { 0 };
+	char vgid[ID_LEN + 1] __attribute__((aligned(8))) = { 0 };
 	struct lvmcache_info *info;
 	const struct format_type *fmt = labeller->fmt;
 	struct label_header *lh = (struct label_header *) label_buf;
@@ -433,6 +434,7 @@ static int _text_read(struct cmd_context *cmd, struct labeller *labeller, struct
 	pvhdr = (struct pv_header *) ((char *) label_buf + xlate32(lh->offset_xl));
 
 	memcpy(pvid, &pvhdr->pv_uuid, ID_LEN);
+	strncpy(vgid, FMT_TEXT_ORPHAN_VG_NAME, ID_LEN);
 
 	/*
 	 * FIXME: stop adding the device to lvmcache initially as an orphan
@@ -449,8 +451,8 @@ static int _text_read(struct cmd_context *cmd, struct labeller *labeller, struct
 	 * Other reasons for lvmcache_add to return NULL are internal errors.
 	 */
 	if (!(info = lvmcache_add(cmd, labeller, pvid, dev, label_sector,
-				  FMT_TEXT_ORPHAN_VG_NAME,
-				  FMT_TEXT_ORPHAN_VG_NAME, 0, is_duplicate)))
+				  vgid,
+				  vgid, 0, is_duplicate)))
 		return_0;
 
 	lvmcache_set_device_size(info, xlate64(pvhdr->device_size_xl));
diff --git a/lib/metadata/metadata-exported.h b/lib/metadata/metadata-exported.h
index 7bac5b900343..fd370d4b261a 100644
--- a/lib/metadata/metadata-exported.h
+++ b/lib/metadata/metadata-exported.h
@@ -371,7 +371,7 @@ struct format_type {
 	struct labeller *labeller;
 	const char *name;
 	const char *alias;
-	const char *orphan_vg_name;
+	char orphan_vg_name[ID_LEN];
 	struct volume_group *orphan_vg; /* Only one ever exists. */
 	uint32_t features;
 	void *library;
diff --git a/lib/uuid/uuid.c b/lib/uuid/uuid.c
index be4cbc3ec194..d8b72422bc0f 100644
--- a/lib/uuid/uuid.c
+++ b/lib/uuid/uuid.c
@@ -168,6 +168,11 @@ int id_write_format(const struct id *id, char *buffer, size_t size)
 
 	assert(ID_LEN == 32);
 
+	if (id->uuid[0] == '#') {
+		(void) dm_strncpy(buffer, (char*)id->uuid, size);
+		return 1;
+	}
+
 	/* split into groups separated by dashes */
 	if (size < (32 + 6 + 1)) {
 		if (size > 0)
diff --git a/tools/Makefile.in b/tools/Makefile.in
index e0e180474789..25fe3b6b36d8 100644
--- a/tools/Makefile.in
+++ b/tools/Makefile.in
@@ -190,9 +190,9 @@ command-lines-input.h: $(srcdir)/command-lines.in Makefile
 	$(Q) set -o pipefail && \
 	( cat $(srcdir)/license.inc && \
 	  echo "/* Do not edit. This file is generated by the Makefile. */" && \
-	  echo -en "const char _command_input[] =\n\n\"" && \
+	  echo -en "static const char _command_input[] =\n\n\"" && \
 	  $(EGREP) -v '^#|\-\-\-|^$$' $(srcdir)/command-lines.in | $(AWK) 'BEGIN {ORS = "\\n\"\n\""} //' && \
-	  echo "\\n\";" \
+	  echo "\\n\\n\";" \
 	) > $@
 
 $(SOURCES:%.c=%.d) $(SOURCES2:%.c=%.d): command-lines-input.h command-count.h cmds.h
diff --git a/tools/command.c b/tools/command.c
index 18ffd64ed986..8de8825e4cbd 100644
--- a/tools/command.c
+++ b/tools/command.c
@@ -2549,7 +2549,7 @@ static const char *_man_long_opt_name(const char *cmdname, int opt_enum)
 	}
 
 	if (strchr(long_opt, '[')) {
-		for (i = 0; i < sizeof(long_opt_name) - 1; ++long_opt, ++i) {
+		for (i = 0; *long_opt && i < sizeof(long_opt_name) - 1; ++long_opt, ++i) {
 			if (i < (sizeof(long_opt_name) - 8))
 				switch(*long_opt) {
 				case '[':
-- 
2.34.1

