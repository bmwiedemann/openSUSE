--- a/include/instrumentation/events/ext4.h
+++ b/include/instrumentation/events/ext4.h
@@ -122,6 +122,35 @@ LTTNG_TRACEPOINT_EVENT(ext4_begin_ordere
 	)
 )
 
+#if (LTTNG_LINUX_VERSION_CODE >= LTTNG_KERNEL_VERSION(5,19,0))
+LTTNG_TRACEPOINT_EVENT_CLASS(ext4__write_begin,
+
+	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len),
+
+	TP_ARGS(inode, pos, len),
+
+	TP_FIELDS(
+		ctf_integer(dev_t, dev, inode->i_sb->s_dev)
+		ctf_integer(ino_t, ino, inode->i_ino)
+		ctf_integer(loff_t, pos, pos)
+		ctf_integer(unsigned int, len, len)
+	)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(ext4__write_begin, ext4_write_begin,
+
+	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len),
+
+	TP_ARGS(inode, pos, len)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(ext4__write_begin, ext4_da_write_begin,
+
+	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len),
+
+	TP_ARGS(inode, pos, len)
+)
+#else
 LTTNG_TRACEPOINT_EVENT_CLASS(ext4__write_begin,
 
 	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
@@ -153,6 +182,7 @@ LTTNG_TRACEPOINT_EVENT_INSTANCE(ext4__wr
 
 	TP_ARGS(inode, pos, len, flags)
 )
+#endif
 
 LTTNG_TRACEPOINT_EVENT_CLASS(ext4__write_end,
 	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
--- a/include/instrumentation/events/kmem.h
+++ b/include/instrumentation/events/kmem.h
@@ -218,6 +218,50 @@ LTTNG_TRACEPOINT_EVENT_MAP(mm_page_alloc
 	)
 )
 
+#if (LTTNG_LINUX_VERSION_CODE >= LTTNG_KERNEL_VERSION(5,19,0))
+LTTNG_TRACEPOINT_EVENT_CLASS(kmem_mm_page,
+
+	TP_PROTO(struct page *page, unsigned int order, int migratetype,
+			int percpu_refill),
+
+	TP_ARGS(page, order, migratetype, percpu_refill),
+
+	TP_FIELDS(
+		ctf_integer_hex(struct page *, page, page)
+		ctf_integer(unsigned long, pfn,
+			page ? page_to_pfn(page) : -1UL)
+		ctf_integer(unsigned int, order, order)
+		ctf_integer(int, migratetype, migratetype)
+		ctf_integer(int, percpu_refill, percpu_refill)
+	)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE_MAP(kmem_mm_page, mm_page_alloc_zone_locked,
+
+	kmem_mm_page_alloc_zone_locked,
+
+	TP_PROTO(struct page *page, unsigned int order, int migratetype,
+			int percpu_refill),
+
+	TP_ARGS(page, order, migratetype, percpu_refill)
+)
+
+LTTNG_TRACEPOINT_EVENT_MAP(mm_page_pcpu_drain,
+
+	kmem_mm_page_pcpu_drain,
+
+	TP_PROTO(struct page *page, unsigned int order, int migratetype),
+
+	TP_ARGS(page, order, migratetype),
+
+	TP_FIELDS(
+		ctf_integer(unsigned long, pfn,
+			page ? page_to_pfn(page) : -1UL)
+		ctf_integer(unsigned int, order, order)
+		ctf_integer(int, migratetype, migratetype)
+	)
+)
+#else
 LTTNG_TRACEPOINT_EVENT_CLASS(kmem_mm_page,
 
 	TP_PROTO(struct page *page, unsigned int order, int migratetype),
@@ -250,6 +294,7 @@ LTTNG_TRACEPOINT_EVENT_INSTANCE_MAP(kmem
 
 	TP_ARGS(page, order, migratetype)
 )
+#endif
 
 #if (LTTNG_LINUX_VERSION_CODE >= LTTNG_KERNEL_VERSION(3,19,2)	\
 	|| LTTNG_KERNEL_RANGE(3,14,36, 3,15,0)		\
--- a/include/instrumentation/events/workqueue.h
+++ b/include/instrumentation/events/workqueue.h
@@ -28,10 +28,35 @@ LTTNG_TRACEPOINT_EVENT_CLASS(workqueue_w
 	)
 )
 
+#if (LTTNG_LINUX_VERSION_CODE >= LTTNG_KERNEL_VERSION(5,19,0))
 /**
  * workqueue_queue_work - called when a work gets queued
  * @req_cpu:	the requested cpu
- * @cwq:	pointer to struct cpu_workqueue_struct
+ * @pwq:	pointer to struct pool_workqueue
+ * @work:	pointer to struct work_struct
+ *
+ * This event occurs when a work is queued immediately or once a
+ * delayed work is actually queued on a workqueue (ie: once the delay
+ * has been reached).
+ */
+LTTNG_TRACEPOINT_EVENT(workqueue_queue_work,
+
+	TP_PROTO(int req_cpu, struct pool_workqueue *pwq,
+		 struct work_struct *work),
+
+	TP_ARGS(req_cpu, pwq, work),
+
+	TP_FIELDS(
+		ctf_integer_hex(void *, work, work)
+		ctf_integer_hex(void *, function, work->func)
+		ctf_integer(int, req_cpu, req_cpu)
+	)
+)
+#elif (LTTNG_LINUX_VERSION_CODE >= LTTNG_KERNEL_VERSION(3,9,0))
+/**
+ * workqueue_queue_work - called when a work gets queued
+ * @req_cpu:	the requested cpu
+ * @pwq:	pointer to struct pool_workqueue
  * @work:	pointer to struct work_struct
  *
  * This event occurs when a work is queued immediately or once a
@@ -40,17 +65,34 @@ LTTNG_TRACEPOINT_EVENT_CLASS(workqueue_w
  */
 LTTNG_TRACEPOINT_EVENT(workqueue_queue_work,
 
-#if (LTTNG_LINUX_VERSION_CODE >= LTTNG_KERNEL_VERSION(3,9,0))
 	TP_PROTO(unsigned int req_cpu, struct pool_workqueue *pwq,
 		 struct work_struct *work),
 
 	TP_ARGS(req_cpu, pwq, work),
+
+	TP_FIELDS(
+		ctf_integer_hex(void *, work, work)
+		ctf_integer_hex(void *, function, work->func)
+		ctf_integer(unsigned int, req_cpu, req_cpu)
+	)
+)
 #else
+/**
+ * workqueue_queue_work - called when a work gets queued
+ * @req_cpu:	the requested cpu
+ * @cwq:	pointer to struct cpu_workqueue_struct
+ * @work:	pointer to struct work_struct
+ *
+ * This event occurs when a work is queued immediately or once a
+ * delayed work is actually queued on a workqueue (ie: once the delay
+ * has been reached).
+ */
+LTTNG_TRACEPOINT_EVENT(workqueue_queue_work,
+
 	TP_PROTO(unsigned int req_cpu, struct cpu_workqueue_struct *cwq,
 		 struct work_struct *work),
 
 	TP_ARGS(req_cpu, cwq, work),
-#endif
 
 	TP_FIELDS(
 		ctf_integer_hex(void *, work, work)
@@ -58,6 +100,7 @@ LTTNG_TRACEPOINT_EVENT(workqueue_queue_w
 		ctf_integer(unsigned int, req_cpu, req_cpu)
 	)
 )
+#endif
 
 /**
  * workqueue_activate_work - called when a work gets activated
