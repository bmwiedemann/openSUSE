From 9c155985f17fd369bbba311b714fb6c01c17d66e Mon Sep 17 00:00:00 2001
From: Sjoerd Meijer <sjoerd.meijer@arm.com>
Date: Fri, 18 Oct 2019 11:01:45 +0000
Subject: [PATCH] [Arm][libsanitizer] Fix arm libsanitizer failure with
 bleeding edge glibc

Glibc has recently introduced changed to the mode field in ipc_perm in commit
2f959dfe849e0646e27403f2e4091536496ac0f0. For Arm this means that the mode
field no longer has the same size.

This causes an assert failure against libsanitizer's internal copy of ipc_perm.
Since this change can't be easily detected I am adding arm to the list of
targets that are excluded from this check.

Patch by: Tamar Christina

Differential Revision: https://reviews.llvm.org/D69104

llvm-svn: 375220

From 947f9692440836dcb8d88b74b69dd379d85974ce Mon Sep 17 00:00:00 2001
From: Evgenii Stepanov <eugenis@google.com>
Date: Mon, 25 Nov 2019 13:52:17 -0800
Subject: [PATCH] Fix sanitizer-common build with glibc 2.31

Summary:
As mentioned in D69104, glibc changed ABI recently with the [[ https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=2f959dfe849e0646e27403f2e4091536496ac0f0| 2f959dfe ]] change.
D69104 dealt with just 32-bit ARM, but that is just one of the many affected architectures.
E.g. x86_64, i?86, riscv64, sparc 32-bit, s390 31-bit are affected too (and various others).

This patch instead of adding a long list of further architectures that wouldn't be checked ever next to arm 32-bit changes the structures to match the 2.31 layout and performs the checking on Linux for ipc_perm mode position/size only on non-Linux or on Linux with glibc 2.31 or later.  I think this matches what is done for aarch64 already.
If needed, we could list architectures that haven't changed ABI (e.g. powerpc), so that they would be checked even with older glibcs.  AFAIK sanitizers don't actually use ipc_perm.mode and
so all they care about is the size and alignment of the whole structure.

Note, s390 31-bit and arm 32-bit big-endian changed ABI even further, there will now be shmctl with old symbol version and shmctl@@GLIBC_2.31 which will be incompatible.  I'm afraid this isn't really solvable unless the sanitizer libraries are symbol versioned and use matching symbol versions to glibc symbols for stuff they intercept, plus use dlvsym.
This patch doesn't try to address that.

Patch by Jakub Jelinek.

Reviewers: kcc, eugenis, dvyukov

Reviewed By: eugenis

Subscribers: jyknight, kristof.beyls, fedor.sergeev, simoncook, PkmX, s.egerton, steven.zhang, #sanitizers, llvm-commits

Tags: #sanitizers, #llvm

Differential Revision: https://reviews.llvm.org/D70662

Index: compiler-rt-9.0.1.src/lib/sanitizer_common/sanitizer_platform_limits_posix.cc
===================================================================
--- compiler-rt-9.0.1.src.orig/lib/sanitizer_common/sanitizer_platform_limits_posix.cc
+++ compiler-rt-9.0.1.src/lib/sanitizer_common/sanitizer_platform_limits_posix.cc
@@ -1126,8 +1126,9 @@ CHECK_SIZE_AND_OFFSET(ipc_perm, uid);
 CHECK_SIZE_AND_OFFSET(ipc_perm, gid);
 CHECK_SIZE_AND_OFFSET(ipc_perm, cuid);
 CHECK_SIZE_AND_OFFSET(ipc_perm, cgid);
-#if !defined(__aarch64__) || !SANITIZER_LINUX || __GLIBC_PREREQ (2, 21)
-/* On aarch64 glibc 2.20 and earlier provided incorrect mode field.  */
+#if !SANITIZER_LINUX || __GLIBC_PREREQ (2, 31)
+/* glibc 2.30 and earlier provided 16-bit mode field instead of 32-bit
+   on many architectures.  */
 CHECK_SIZE_AND_OFFSET(ipc_perm, mode);
 #endif
 
Index: compiler-rt-9.0.1.src/lib/sanitizer_common/sanitizer_platform_limits_posix.h
===================================================================
--- compiler-rt-9.0.1.src.orig/lib/sanitizer_common/sanitizer_platform_limits_posix.h
+++ compiler-rt-9.0.1.src/lib/sanitizer_common/sanitizer_platform_limits_posix.h
@@ -203,26 +203,13 @@ namespace __sanitizer {
     u64 __unused1;
     u64 __unused2;
 #elif defined(__sparc__)
-#if defined(__arch64__)
     unsigned mode;
-    unsigned short __pad1;
-#else
-    unsigned short __pad1;
-    unsigned short mode;
     unsigned short __pad2;
-#endif
     unsigned short __seq;
     unsigned long long __unused1;
     unsigned long long __unused2;
-#elif defined(__mips__) || defined(__aarch64__) || defined(__s390x__)
-    unsigned int mode;
-    unsigned short __seq;
-    unsigned short __pad1;
-    unsigned long __unused1;
-    unsigned long __unused2;
 #else
-    unsigned short mode;
-    unsigned short __pad1;
+    unsigned int mode;
     unsigned short __seq;
     unsigned short __pad2;
 #if defined(__x86_64__) && !defined(_LP64)
