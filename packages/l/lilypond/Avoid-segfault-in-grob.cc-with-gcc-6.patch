From 682f75315e6820220ecf45717664f6d32f480c98 Mon Sep 17 00:00:00 2001
From: Guido Aulisi <guido.aulisi@gmail.com>
Date: Fri, 22 Jul 2016 15:26:29 +0200
Subject: [PATCH 1/2] Avoid segfault in grob.cc with gcc 6 (see issue #4814)

When optimizing, GCC 6 now assumes the "this" pointer can never be null,
which is guaranteed by the language rules.
Programs which assume it is OK to invoke a member function through a null pointer
(possibly relying on checks like this != NULL) may crash or otherwise fail at run time
if null pointer checks are optimized away.
---
 lily/grob.cc | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

Index: lily/grob.cc
===================================================================
--- lily/grob.cc.orig	2014-03-17 17:29:16.000000000 +0200
+++ lily/grob.cc	2018-05-15 10:08:44.673032220 +0200
@@ -330,7 +330,7 @@ Real
 Grob::relative_coordinate (Grob const *refp, Axis a) const
 {
   /* eaa - hmmm, should we do a programming_error() here? */
-  if ((this == NULL) || (refp == this))
+  if (refp == this)
     return 0.0;
 
   /* We catch PARENT_L_ == nil case with this, but we crash if we did
@@ -339,7 +339,8 @@ Grob::relative_coordinate (Grob const *r
   if (refp == dim_cache_[a].parent_)
     return off;
 
-  off += dim_cache_[a].parent_->relative_coordinate (refp, a);
+  if (dim_cache_[a].parent_ != NULL)
+    off += dim_cache_[a].parent_->relative_coordinate (refp, a);
 
   return off;
 }
