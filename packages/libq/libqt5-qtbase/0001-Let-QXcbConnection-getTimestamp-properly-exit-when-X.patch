From 5519447b9db4023deca98e5b882845416a9c33f1 Mon Sep 17 00:00:00 2001
From: Sheng Mao <shngmao@gmail.com>
Date: Fri, 13 Nov 2020 22:34:46 -0700
Subject: [PATCH] Let QXcbConnection::getTimestamp properly exit when X server
 quits
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

QXcbConnection::getTimestamp uses dummy events to get timestamp from
X server. However, in some cases, X server shuts down while client tries
to get timestamp. In this case, QXcbConnection::getTimestamp keeps
getting null event and thus falls into indefinite loop.

This fix checks if xcb connection is still valid and use a special
xcb_timestamp_t value, CurrentTime (0L), as returned value.
CurrentTime should not be generated by X server and if getTimestamp
returns this value, it means an "exception" case is triggered.

This fix is introduced because in kwin_x11 (KDE project), X server can
exit on logout. kwin_x11 should handle disconnection from X server.
But the indefinite loop prevents kwin_x11 to process disconnection
event and therefore kwin_x11 cannot quit properly.

Fixes: QTBUG-88435
Change-Id: Iaf7ef3f8a35fa8389d22a608e3c49041bf90e1b9
Reviewed-by: Qt CI Bot <qt_ci_bot@qt-project.org>
Reviewed-by: Liang Qi <liang.qi@qt.io>
Reviewed-by: Tor Arne Vestb√∏ <tor.arne.vestbo@qt.io>
(cherry picked from commit dbd1c8b047700bb6d0adae848d6cbb89fa2fcfff)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/plugins/platforms/xcb/qxcbconnection.cpp | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/src/plugins/platforms/xcb/qxcbconnection.cpp b/src/plugins/platforms/xcb/qxcbconnection.cpp
index c557109bd1..9abdae6a7c 100644
--- a/src/plugins/platforms/xcb/qxcbconnection.cpp
+++ b/src/plugins/platforms/xcb/qxcbconnection.cpp
@@ -763,7 +763,10 @@ xcb_timestamp_t QXcbConnection::getTimestamp()
 
     xcb_generic_event_t *event = nullptr;
 
-    while (!event) {
+    // When disconnection is caused by X server, event will never be able to hold
+    // a valid pointer. isConnected(), which calls xcb_connection_has_error(),
+    // can handle this type of disconnection and properly quits the loop.
+    while (isConnected() && !event) {
         connection()->sync();
         event = eventQueue()->peek([window, dummyAtom](xcb_generic_event_t *event, int type) {
             if (type != XCB_PROPERTY_NOTIFY)
@@ -773,6 +776,14 @@ xcb_timestamp_t QXcbConnection::getTimestamp()
         });
     }
 
+    if (!event) {
+        // https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html#glossary
+        // > One timestamp value (named CurrentTime) is never generated by the
+        // > server. This value is reserved for use in requests to represent the
+        // > current server time.
+        return XCB_CURRENT_TIME;
+    }
+
     xcb_property_notify_event_t *pn = reinterpret_cast<xcb_property_notify_event_t *>(event);
     xcb_timestamp_t timestamp = pn->time;
     free(event);
-- 
2.30.0

