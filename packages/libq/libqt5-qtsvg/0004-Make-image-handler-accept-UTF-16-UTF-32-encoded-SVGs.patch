From cfc616978b52a396b2ef6900546f7fc086d7cab3 Mon Sep 17 00:00:00 2001
From: Eirik Aavitsland <eirik.aavitsland@qt.io>
Date: Thu, 8 Apr 2021 13:19:52 +0200
Subject: [PATCH 4/4] Make image handler accept UTF-16/UTF-32 encoded SVGs

The canRead() header checks assumed 8 bit encoding.

Pick-to: 6.1 6.0 5.15
Fixes: QTBUG-90744
Change-Id: Ibe934fe9ed31b89ee0fbfc4562aa66ab1b359225
Reviewed-by: Allan Sandfeld Jensen <allan.jensen@qt.io>
(cherry picked from commit 45fb1f07eaa984af40fca9f12b8f3d27f7b0e9ac)
---
 .../imageformats/svg/qsvgiohandler.cpp        |  37 +++++++++++-------
 tests/auto/qsvgplugin/simple_Utf16BE.svg      | Bin 0 -> 228 bytes
 tests/auto/qsvgplugin/simple_Utf16LE.svg      | Bin 0 -> 228 bytes
 tests/auto/qsvgplugin/simple_Utf32BE.svg      | Bin 0 -> 456 bytes
 tests/auto/qsvgplugin/simple_Utf32LE.svg      | Bin 0 -> 456 bytes
 tests/auto/qsvgplugin/simple_Utf8.svg         |   3 ++
 tests/auto/qsvgplugin/tst_qsvgplugin.cpp      |  32 +++++++++++++++
 7 files changed, 57 insertions(+), 15 deletions(-)
 create mode 100644 tests/auto/qsvgplugin/simple_Utf16BE.svg
 create mode 100644 tests/auto/qsvgplugin/simple_Utf16LE.svg
 create mode 100644 tests/auto/qsvgplugin/simple_Utf32BE.svg
 create mode 100644 tests/auto/qsvgplugin/simple_Utf32LE.svg
 create mode 100644 tests/auto/qsvgplugin/simple_Utf8.svg

diff --git a/src/plugins/imageformats/svg/qsvgiohandler.cpp b/src/plugins/imageformats/svg/qsvgiohandler.cpp
index bd39b2a..4136aaf 100644
--- a/src/plugins/imageformats/svg/qsvgiohandler.cpp
+++ b/src/plugins/imageformats/svg/qsvgiohandler.cpp
@@ -118,6 +118,24 @@ QSvgIOHandler::~QSvgIOHandler()
     delete d;
 }
 
+static bool isPossiblySvg(QIODevice *device, bool *isCompressed = nullptr)
+{
+    constexpr int bufSize = 64;
+    char buf[bufSize];
+    const qint64 readLen = device->peek(buf, bufSize);
+    if (readLen < 8)
+        return false;
+#    ifndef QT_NO_COMPRESS
+    if (quint8(buf[0]) == 0x1f && quint8(buf[1]) == 0x8b) {
+        if (isCompressed)
+            *isCompressed = true;
+        return true;
+    }
+#    endif
+    QTextStream str(QByteArray::fromRawData(buf, readLen));
+    QByteArray ba = str.read(16).trimmed().toLatin1();
+    return ba.startsWith("<?xml") || ba.startsWith("<svg") || ba.startsWith("<!--") || ba.startsWith("<!DOCTYPE svg");
+}
 
 bool QSvgIOHandler::canRead() const
 {
@@ -126,15 +144,9 @@ bool QSvgIOHandler::canRead() const
     if (d->loaded && !d->readDone)
         return true;        // Will happen if we have been asked for the size
 
-    QByteArray buf = device()->peek(16);
-#ifndef QT_NO_COMPRESS
-    if (buf.startsWith("\x1f\x8b")) {
-        setFormat("svgz");
-        return true;
-    } else
-#endif
-    if (buf.contains("<?xml") || buf.contains("<svg") || buf.contains("<!--") || buf.contains("<!DOCTYPE svg")) {
-        setFormat("svg");
+    bool isCompressed = false;
+    if (isPossiblySvg(device(), &isCompressed)) {
+        setFormat(isCompressed ? "svgz" : "svg");
         return true;
     }
     return false;
@@ -260,12 +272,7 @@ bool QSvgIOHandler::supportsOption(ImageOption option) const
 
 bool QSvgIOHandler::canRead(QIODevice *device)
 {
-    QByteArray buf = device->peek(16);
-    return
-#ifndef QT_NO_COMPRESS
-            buf.startsWith("\x1f\x8b") ||
-#endif
-            buf.contains("<?xml") || buf.contains("<svg") || buf.contains("<!--") || buf.contains("<!DOCTYPE svg");
+    return isPossiblySvg(device);
 }
 
 QT_END_NAMESPACE
diff --git a/tests/auto/qsvgplugin/simple_Utf16BE.svg b/tests/auto/qsvgplugin/simple_Utf16BE.svg
new file mode 100644
index 0000000000000000000000000000000000000000..c3312cb2a98dc3a2a7f42100720a94ee913ab641
GIT binary patch
literal 228
zcmY+8!3x4a3`F1AuUP86TPwXt^=FD(h1JSdZ2kG_Y$$>ZBuq%=W%<xD@}kG7o=I|7
z2JRdw*illcJ7#V~O-GwwcuEfrcxf_~s(bAZ%IGz%b(!VY{DKo3B{>m0F_LN&(W%dt
i+N`XO_n%MZY8v|_=r&6EzpW7h!FvAF8>RhG#ry&V93m0`

literal 0
HcmV?d00001

diff --git a/tests/auto/qsvgplugin/simple_Utf16LE.svg b/tests/auto/qsvgplugin/simple_Utf16LE.svg
new file mode 100644
index 0000000000000000000000000000000000000000..cdbeda92a5145faf70fcc8dcdf034141a66f59cf
GIT binary patch
literal 228
zcmY+8!3x4a3`F1AuUP86tCe14^=FD(h1JSdZ2ft4HWWby5+)?`@_7eFp7c1?6It%U
zz>NbHTWU7yj+rY-)6wQ<9@3pXUYbm`>Q4KEGI~uLT^9Kzzv9SBNsd4#MpjKCI`!F7
h+lAHf`t#XbLu;Qz-6pC0w>Cl~S}%Wkql6!|Fux@+A`$=q

literal 0
HcmV?d00001

diff --git a/tests/auto/qsvgplugin/simple_Utf32BE.svg b/tests/auto/qsvgplugin/simple_Utf32BE.svg
new file mode 100644
index 0000000000000000000000000000000000000000..0d5d02c1ba98a60908ca852692bf5f1124d4b64b
GIT binary patch
literal 456
zcmaKnNeV(i3<Z1bDT3}DaU<$w#0i{Gak#u%B^~&<a8V@Pncgeq^)97M;Q}{UL)3gp
zJcG3@9N_>nXu|-y(68?xK41?!u-Dn_-;iG`C*lNpl{+zUr}+rXy{itj**^qtCjK?`
zt8ES~h>9K;pbvMMt5J^uzSW*u$K*|4)}Mds?#x;BIj@d@6?oTsl6@WW^k9$VJ7@Kl
LUi9$m^;`P@=Ncjs

literal 0
HcmV?d00001

diff --git a/tests/auto/qsvgplugin/simple_Utf32LE.svg b/tests/auto/qsvgplugin/simple_Utf32LE.svg
new file mode 100644
index 0000000000000000000000000000000000000000..58a71596656a79d9540b6bbef92e6b40aec46871
GIT binary patch
literal 456
zcmaKnNeV(i3<b0H6pij3aU=RKBTnFiio@mAD(Jw+g^MET&h*~r9WjrHE8JlNrRFQ*
z1+4Ah1V>mv7e>&BVSN|k6ArKkd!5bxE%~i-CeC0`c@PtKnoq#oyXsJz{bTTE;$K_8
z+8XFUspxSD`f!)I8ueJfx7t(dl)UZB`s+{KojI#M=habQ4c_&hWM7XwJ=i1p&RM;s
K7d`xX&Ds}BU?LI#

literal 0
HcmV?d00001

diff --git a/tests/auto/qsvgplugin/simple_Utf8.svg b/tests/auto/qsvgplugin/simple_Utf8.svg
new file mode 100644
index 0000000..2052c48
--- /dev/null
+++ b/tests/auto/qsvgplugin/simple_Utf8.svg
@@ -0,0 +1,3 @@
+ï»¿<svg version="1.0" xmlns="http://www.w3.org/2000/svg">
+  <circle cx="50" cy="50" r="25" fill="#00ff00" />
+</svg>
diff --git a/tests/auto/qsvgplugin/tst_qsvgplugin.cpp b/tests/auto/qsvgplugin/tst_qsvgplugin.cpp
index e1f84f3..73bbe8b 100644
--- a/tests/auto/qsvgplugin/tst_qsvgplugin.cpp
+++ b/tests/auto/qsvgplugin/tst_qsvgplugin.cpp
@@ -61,6 +61,8 @@ private slots:
     void checkSize_data();
     void checkSize();
     void checkImageInclude();
+    void encodings_data();
+    void encodings();
 };
 
 
@@ -145,6 +147,36 @@ void tst_QSvgPlugin::checkImageInclude()
     logMessages.clear();
 }
 
+void tst_QSvgPlugin::encodings_data()
+{
+    QTest::addColumn<QString>("filename");
+
+    QTest::newRow("utf-8") << QFINDTESTDATA("simple_Utf8.svg");
+    QTest::newRow("utf-16LE") << QFINDTESTDATA("simple_Utf16LE.svg");
+    QTest::newRow("utf-16BE") << QFINDTESTDATA("simple_Utf16BE.svg");
+    QTest::newRow("utf-32LE") << QFINDTESTDATA("simple_Utf32LE.svg");
+    QTest::newRow("utf-32BE") << QFINDTESTDATA("simple_Utf32BE.svg");
+}
+
+void tst_QSvgPlugin::encodings()
+{
+    QFETCH(QString, filename);
+
+    {
+        QFile file(filename);
+        file.open(QIODevice::ReadOnly);
+        QVERIFY(QSvgIOHandler::canRead(&file));
+    }
+
+    QFile file(filename);
+    file.open(QIODevice::ReadOnly);
+    QSvgIOHandler plugin;
+    plugin.setDevice(&file);
+    QVERIFY(plugin.canRead());
+    QImage img;
+    QVERIFY(plugin.read(&img));
+    QCOMPARE(img.size(), QSize(50, 50));
+}
 
 QTEST_MAIN(tst_QSvgPlugin)
 #include "tst_qsvgplugin.moc"
-- 
2.25.1

