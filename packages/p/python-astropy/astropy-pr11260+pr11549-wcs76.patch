From 6c485869cbee373282c8081d110bbf1ea25b3982 Mon Sep 17 00:00:00 2001
From: Derek Homeier <dhomeie@gwdg.de>
Date: Mon, 1 Feb 2021 00:00:32 +0100
Subject: [PATCH 1/3] Updated bundled WCSLIB to 7.4 with wcshdo() fix

WCSLIB version 7.4 was released on 2021/01/31 by Mark Calabretta.

It contains a number of important bug fixes, particularly for wcshdo(),
and enhancements, as per the change log appended below.

-------------------------------

* C library

 - In wcshdo(), fixed a bug introduced in release 5.9 that potentially
   caused loss of numerical precision in the sprintf() formatting of
   floating point keyvalues.  This was triggered when a large range of
   CRPIXja, PCi_ja, or CDELTia values (as three separate groups) were
   formatted using an 'f' format descriptor, the range not being so
   large that it would have forced wcshdo() to revert to 'E' format.
   Reported by Mohammad Akhlaghi.

   Also in wcshdo(), fixed a bug introduced in release 7.1 that caused
   the coefficients of the TPD distortion function not to be written to
   the header.  TPD and Polynomial distortion function headers will now
   always include the DPja.DOCORR keyword.  Reported by Derek Homeier
   with patch.

 - In wcsset(), fixed a segv generated in attempting to report a non-
   standard units string with wcserr message reporting disabled.
   Reported by Mohammad Akhlaghi.

   In wcsutrne(), allow 'Angstroms' and 'angstroms' as additional
   synonyms for 'Angstrom'.

 - In datfix(), ensure that 0 is returned if an informational message
   is set in wcsprm::err.  Consequent on feedback independently from
   Mihai Cara and Bruce Merry.

   Clarified that informational messages may be set in wcsprm::err
   for returns of 0 from datfix(), obsfix(), unitfix(), and spcfix().

* User manual

 - Added cautions about translating CDi_ja to PCi_ja plus CDELTia for
   those historical distortion functions (TPV, TNX, ZPX) that expect to
   operate on intermediate world coordinates, rather than intermediate
   pixel coordinates.  Consequent on feedback from Mohammad Akhlaghi.

 - Documentation generation moved to doxygen 1.9.1 (was 1.8.19).
---
 astropy/wcs/setup_package.py        |    2 +-
 cextern/wcslib/C/GNUmakefile        |    4 +-
 cextern/wcslib/C/cel.c              |   93 +-
 cextern/wcslib/C/cel.h              |   89 +-
 cextern/wcslib/C/dis.c              |  778 ++++++++---------
 cextern/wcslib/C/dis.h              |  138 +--
 cextern/wcslib/C/fitshdr.h          |   67 +-
 cextern/wcslib/C/fitshdr.l          |  103 ++-
 cextern/wcslib/C/flexed/README      |    2 +-
 cextern/wcslib/C/flexed/fitshdr.c   |  183 ++--
 cextern/wcslib/C/flexed/wcsbth.c    | 1223 +++++++++++++--------------
 cextern/wcslib/C/flexed/wcspih.c    |  929 ++++++++++----------
 cextern/wcslib/C/flexed/wcsulex.c   |  433 +++++-----
 cextern/wcslib/C/flexed/wcsutrn.c   | 1012 ++++++++++++----------
 cextern/wcslib/C/getwcstab.c        |   37 +-
 cextern/wcslib/C/getwcstab.h        |  107 ++-
 cextern/wcslib/C/lin.c              |  227 +++--
 cextern/wcslib/C/lin.h              |   83 +-
 cextern/wcslib/C/log.c              |   15 +-
 cextern/wcslib/C/log.h              |   27 +-
 cextern/wcslib/C/prj.c              |  751 ++++++++--------
 cextern/wcslib/C/prj.h              |  105 ++-
 cextern/wcslib/C/spc.c              |  271 +++---
 cextern/wcslib/C/spc.h              |  121 ++-
 cextern/wcslib/C/sph.c              |   85 +-
 cextern/wcslib/C/sph.h              |   93 +-
 cextern/wcslib/C/spx.c              |   83 +-
 cextern/wcslib/C/spx.h              |  109 ++-
 cextern/wcslib/C/tab.c              |  325 ++++---
 cextern/wcslib/C/tab.h              |  111 ++-
 cextern/wcslib/C/wcs.c              |  714 ++++++++--------
 cextern/wcslib/C/wcs.h              |  362 ++++----
 cextern/wcslib/C/wcsbth.l           |  349 ++++----
 cextern/wcslib/C/wcserr.c           |   25 +-
 cextern/wcslib/C/wcserr.h           |   29 +-
 cextern/wcslib/C/wcsfix.c           |  281 +++---
 cextern/wcslib/C/wcsfix.h           |  118 +--
 cextern/wcslib/C/wcshdr.c           |  482 +++++------
 cextern/wcslib/C/wcshdr.h           |  154 ++--
 cextern/wcslib/C/wcslib.h           |   13 +-
 cextern/wcslib/C/wcsmath.h          |   13 +-
 cextern/wcslib/C/wcspih.l           |  337 ++++----
 cextern/wcslib/C/wcsprintf.c        |   43 +-
 cextern/wcslib/C/wcsprintf.h        |   13 +-
 cextern/wcslib/C/wcstrig.c          |   23 +-
 cextern/wcslib/C/wcstrig.h          |   21 +-
 cextern/wcslib/C/wcsulex.l          |  175 ++--
 cextern/wcslib/C/wcsunits.c         |   41 +-
 cextern/wcslib/C/wcsunits.h         |  117 ++-
 cextern/wcslib/C/wcsutil.c          |   87 +-
 cextern/wcslib/C/wcsutil.h          |   13 +-
 cextern/wcslib/C/wcsutrn.l          |   41 +-
 cextern/wcslib/C/wtbarr.h           |   45 +-
 cextern/wcslib/CHANGES              |   65 +-
 cextern/wcslib/GNUmakefile          |    4 +-
 cextern/wcslib/INSTALL              |   12 +-
 cextern/wcslib/README               |   10 +-
 cextern/wcslib/THANKS               |   12 +-
 cextern/wcslib/VALIDATION           |   22 +-
 cextern/wcslib/configure            |   24 +-
 cextern/wcslib/configure.ac         |    6 +-
 cextern/wcslib/flavours             |    2 +-
 cextern/wcslib/makedefs.in          |    8 +-
 cextern/wcslib/wcsconfig.h.in       |    4 +-
 cextern/wcslib/wcsconfig_f77.h.in   |    4 +-
 cextern/wcslib/wcsconfig_tests.h.in |    4 +-
 cextern/wcslib/wcsconfig_utils.h.in |    4 +-
 67 files changed, 5703 insertions(+), 5580 deletions(-)

Index: astropy-4.2.1/astropy/wcs/setup_package.py
===================================================================
--- astropy-4.2.1.orig/astropy/wcs/setup_package.py
+++ astropy-4.2.1/astropy/wcs/setup_package.py
@@ -16,7 +16,7 @@ import numpy
 from extension_helpers import import_file, write_if_different, get_compiler, pkg_config
 
 WCSROOT = os.path.relpath(os.path.dirname(__file__))
-WCSVERSION = "7.3.0"
+WCSVERSION = "7.4"
 
 
 def b(s):
@@ -227,6 +227,10 @@ def get_wcslib_cfg(cfg, wcslib_files, in
     if sys.platform.startswith('linux'):
         cfg['define_macros'].append(('HAVE_SINCOS', None))
 
+    # For 4.7+ enable C99 syntax in older compilers (need 'gnu99' std for gcc)
+    if get_compiler() == 'unix':
+        cfg['extra_compile_args'].extend(['-std=gnu99'])
+
     # Squelch a few compilation warnings in WCSLIB
     if get_compiler() in ('unix', 'mingw32'):
         if not debug:
Index: astropy-4.2.1/cextern/wcslib/C/GNUmakefile
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/GNUmakefile
+++ astropy-4.2.1/cextern/wcslib/C/GNUmakefile
@@ -1,5 +1,5 @@
 #-----------------------------------------------------------------------------
-# GNU makefile for building WCSLIB 7.3 and its test suite.
+# GNU makefile for building WCSLIB 7.6 and its test suite.
 #
 # Summary of the main targets
 # ---------------------------
@@ -31,7 +31,7 @@
 #
 # Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 # http://www.atnf.csiro.au/people/Mark.Calabretta
-# $Id: GNUmakefile,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+# $Id: GNUmakefile,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 #-----------------------------------------------------------------------------
 # Get configure settings.
 SUBDIR := C
@@ -78,9 +78,12 @@ TEST_C := twcstab twcshdr tdis3 twcslint
 # Test programs that require PGPLOT but not PGSBOX.
 TEST_P := tspc tprj2 tcel1 tcel2 ttab2 ttab3 twcsmix
 
-# Test programs that require PGPLOT and PGSBOX.
+# Test programs that require PGSBOX (and therefore PGPLOT).
 TEST_B := tpih2
 
+# Test program for POSIX threads (code development only).
+TEST_T := tpthreads
+
 # Test programs that are compiled but not automatically exercised.
 TEST_X := tsphdpa twcshdr
 
@@ -88,24 +91,39 @@ TEST_X := tsphdpa twcshdr
 TESTS  := $(TEST_N)
 
 # Do we have CFITSIO?
-ifeq "$(CFITSIOINC)$(CFITSIOLIB)" ""
-  # No, amend TEST_X.
-  TEST_X := $(filter-out $(TEST_C),$(TEST_X))
-else
+DO_CFITSIO := 1
+ifeq "$(CFITSIOINC)" ""
+  DO_CFITSIO := 0
+else ifeq "$(CFITSIOLIB)" ""
+  DO_CFITSIO := 0
+endif
+
+ifeq "$(DO_CFITSIO)" "1"
   # Yes, add test programs that use it.
   TESTS += $(TEST_C)
   CFITSIO_CFLAGS := $(filter-out -Wpadded,$(CFLAGS))
+else
+  # No, amend TEST_X.
+  TEST_X := $(filter-out $(TEST_C),$(TEST_X))
 endif
 
 # Do we have PGPLOT?
+DO_PGPLOT := 0
 ifneq "$(CHECK)" "nopgplot"
-ifeq "$(PGPLOTINC)$(PGPLOTLIB)" ""
-  # No, amend TEST_X.
-  TEST_X := $(filter-out $(TEST_P) $(TEST_B),$(TEST_X))
-else
-  # Yes, add test programs that use it.
-  TESTS += $(TEST_P) $(TEST_B)
-endif
+  DO_PGPLOT := 1
+  ifeq "$(PGPLOTINC)" ""
+    DO_PGPLOT := 0
+  else ifeq "$(PGPLOTLIB)" ""
+    DO_PGPLOT := 0
+  endif
+
+  ifeq "$(DO_PGPLOT)" "1"
+    # Yes, add test programs that use it.
+    TESTS += $(TEST_P) $(TEST_B)
+  else
+    # No, amend TEST_X.
+    TEST_X := $(filter-out $(TEST_P) $(TEST_B),$(TEST_X))
+  endif
 endif
 
 # Remove tests that aren't automatically exercised.
@@ -248,7 +266,7 @@ run_% : %
 #--------------------------------
 
 .PHONY : build check clean cleaner cleanest distclean install lib realclean \
-         run_% test tests
+         run_% test tests uninstall
 
 build : lib
 
@@ -338,13 +356,18 @@ install : build
 	-  $(RM) $(INCLINK)
 	   $(LN_S) $(notdir $(INCDIR)) $(INCLINK)
 
+uninstall :
+	-  cd $(LIBDIR) && $(RM) $(WCSLIB) $(SHRLN) $(SONAME) $(SHRLIB)
+	-  $(RM) $(INCDIR)
+	-  $(RM) $(INCLINK)
+
 clean :
 	- $(RM) *.o $(LIBLOCK) *.i a.out t*.out core *.dSYM
 	- $(RM) -r $(EXTRA_CLEAN)
 
 cleaner : clean
 	-  $(RM) .gdb_history
-	-  $(RM) $(TEST_N) $(TEST_n) $(TEST_X)
+	-  $(RM) $(TEST_N) $(TEST_n) $(TEST_T) $(TEST_X)
 	-  $(RM) $(TEST_P) tdis3 tpih2 twcshdr twcslint twcstab
 	-  $(RM) tofits
 	-  $(RM) bth.fits fitshdr.fits pih.fits wcslint.fits wcstab.fits
@@ -361,38 +384,20 @@ check test : tests $(TESTS:%=run_%)
 
 tests : $(TESTS) $(TEST_X)
 
+# TEST_N and TEST_n programs (no special libraries required).
 $(TEST_N) $(TEST_n) : % : test/%.c $(WCSLIB)
 	-@ echo ''
 	   $(CC) $(CPPFLAGS) $(CFLAGS) -o $@ $< $(LDFLAGS) $(WCSLIB) $(LIBS)
 	-@ $(RM) $@.o
 
-$(TEST_P) : % : test/%.c $(WCSLIB)
-	-@ echo ''
-	   $(CC) $(CPPFLAGS) $(PGPLOTINC) $(CFLAGS) -c -o $@.o $<
-	   $(LD) -o $@ $@.o $(LDFLAGS) $(PGPLOTLIB) $(WCSLIB) $(FLIBS) $(LIBS)
-	-@ $(RM) $@.o
-
-tpih2 : test/tpih2.c $(PGSBOXLIB) $(WCSLIB)
-	-@ echo ''
-	   $(CC) $(CPPFLAGS) -I../pgsbox $(PGPLOTINC) $(CFLAGS) -c -o $@.o $<
-	   $(LD) -o $@ $@.o $(LDFLAGS) $(PGSBOXLIB) $(PGPLOTLIB) $(WCSLIB) \
-	     $(FLIBS) $(LIBS)
-	-@ $(RM) $@.o
-
-tfitshdr_cfitsio tpih1_cfitsio tbth1_cfitsio : %_cfitsio : test/%.c $(WCSLIB)
+# TEST_N programs (optionally using CFITSIO).
+tpih1_cfitsio tbth1_cfitsio tfitshdr_cfitsio : %_cfitsio : test/%.c $(WCSLIB)
 	-@ echo ''
 	   $(CC) -DDO_CFITSIO $(CPPFLAGS) $(CFITSIOINC) $(CFITSIO_CFLAGS) \
 	     -o $@ $< $(LDFLAGS) $(CFITSIOLIB) $(WCSLIB) $(LIBS)
 	-@ $(RM) $@.o
 
-tpih2_cfitsio : test/tpih2.c $(PGSBOXLIB) $(WCSLIB)
-	-@ echo ''
-	   $(CC) -DDO_CFITSIO $(CPPFLAGS) -I../pgsbox $(PGPLOTINC) \
-	     $(CFITSIOINC) $(CFITSIO_CFLAGS) -c -o $@.o $<
-	   $(LD) -o $@ $@.o $(LDFLAGS) $(PGSBOXLIB) $(PGPLOTLIB) \
-	     $(CFITSIOLIB) $(WCSLIB) $(FLIBS) $(LIBS)
-	-@ $(RM) $@.o
-
+# TEST_C programs (using CFITSIO).
 twcstab : test/twcstab.c $(WCSLIB) $(GETWCSTAB)
 	-@ echo ''
 	   $(CC) $(CPPFLAGS) $(CFITSIOINC) $(CFITSIO_CFLAGS) -o $@ $< \
@@ -415,6 +420,36 @@ twcslint : test/twcslint
 	   cp $< .
 	-@ chmod a+x $@
 
+# TEST_P programs (using PGPLOT).
+$(TEST_P) : % : test/%.c $(WCSLIB)
+	-@ echo ''
+	   $(CC) $(CPPFLAGS) $(PGPLOTINC) $(CFLAGS) -c -o $@.o $<
+	   $(LD) -o $@ $@.o $(LDFLAGS) $(PGPLOTLIB) $(WCSLIB) $(FLIBS) $(LIBS)
+	-@ $(RM) $@.o
+
+# TEST_B programs (PGSBOX and PGPLOT).
+tpih2 : test/tpih2.c $(PGSBOXLIB) $(WCSLIB)
+	-@ echo ''
+	   $(CC) $(CPPFLAGS) -I../pgsbox $(PGPLOTINC) $(CFLAGS) -c -o $@.o $<
+	   $(LD) -o $@ $@.o $(LDFLAGS) $(PGSBOXLIB) $(PGPLOTLIB) $(WCSLIB) \
+	     $(FLIBS) $(LIBS)
+	-@ $(RM) $@.o
+
+tpih2_cfitsio : test/tpih2.c $(PGSBOXLIB) $(WCSLIB)
+	-@ echo ''
+	   $(CC) -DDO_CFITSIO $(CPPFLAGS) -I../pgsbox $(PGPLOTINC) \
+	     $(CFITSIOINC) $(CFITSIO_CFLAGS) -c -o $@.o $<
+	   $(LD) -o $@ $@.o $(LDFLAGS) $(PGSBOXLIB) $(PGPLOTLIB) \
+	     $(CFITSIOLIB) $(WCSLIB) $(FLIBS) $(LIBS)
+	-@ $(RM) $@.o
+
+# TEST_T programs (using POSIX threads).
+tpthreads : test/tpthreads.c $(WCSLIB)
+	-@ echo ''
+	   $(CC) $(CPPFLAGS) $(CFLAGS) -pthread -c -o $@.o $<
+	   $(LD) -o $@ $@.o $(LDFLAGS) -pthread $(WCSLIB) -lpthread $(LIBS)
+	-@ $(RM) $@.o
+
 getwcstab.o : getwcstab.c getwcstab.h
 	-@ echo ''
 	   $(CC) $(CPPFLAGS) $(CFITSIO_CFLAGS) $(CFITSIOINC) -c $<
@@ -436,6 +471,8 @@ GNUmakefile : ../makedefs ;
 show ::
 	-@ echo '  FLEXMODS    := $(FLEXMODS)'
 	-@ echo '  MODULES     := $(MODULES)'
+	-@ echo '  DO_CFITSIO  := $(DO_CFITSIO)'
+	-@ echo '  DO_PGPLOT   := $(DO_PGPLOT)'
 	-@ echo '  TESTS       := $(TESTS)'
 	-@ echo '  TEST_X      := $(TEST_X)'
 
Index: astropy-4.2.1/cextern/wcslib/C/cel.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/cel.c
+++ astropy-4.2.1/cextern/wcslib/C/cel.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: cel.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: cel.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -38,7 +35,7 @@
 
 const int CELSET = 137;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *cel_errmsg[] = {
   "Success",
   "Null celprm pointer passed",
@@ -48,19 +45,19 @@ const char *cel_errmsg[] = {
   "One or more of the (x,y) coordinates were invalid",
   "One or more of the (lng,lat) coordinates were invalid"};
 
-/* Map error returns for lower-level routines. */
+// Map error returns for lower-level routines.
 const int cel_prjerr[] = {
-  CELERR_SUCCESS,		/*  0: PRJERR_SUCCESS         */
-  CELERR_NULL_POINTER,		/*  1: PRJERR_NULL_POINTER    */
-  CELERR_BAD_PARAM,		/*  2: PRJERR_BAD_PARAM       */
-  CELERR_BAD_PIX,		/*  3: PRJERR_BAD_PIX         */
-  CELERR_BAD_WORLD		/*  4: PRJERR_BAD_WORLD       */
+  CELERR_SUCCESS,		//  0: PRJERR_SUCCESS
+  CELERR_NULL_POINTER,		//  1: PRJERR_NULL_POINTER
+  CELERR_BAD_PARAM,		//  2: PRJERR_BAD_PARAM
+  CELERR_BAD_PIX,		//  3: PRJERR_BAD_PIX
+  CELERR_BAD_WORLD		//  4: PRJERR_BAD_WORLD
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define CEL_ERRMSG(status) WCSERR_SET(status), cel_errmsg[status]
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celini(struct celprm *cel)
 
@@ -87,7 +84,7 @@ int celini(struct celprm *cel)
   return cel_prjerr[prjini(&(cel->prj))];
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celfree(struct celprm *cel)
 
@@ -99,7 +96,36 @@ int celfree(struct celprm *cel)
   return cel_prjerr[prjfree(&(cel->prj))];
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
+
+int celsize(const struct celprm *cel, int sizes[2])
+
+{
+  if (cel == 0x0) {
+    sizes[0] = sizes[1] = 0;
+    return CELERR_SUCCESS;
+  }
+
+  // Base size, in bytes.
+  sizes[0] = sizeof(struct celprm);
+
+  // Total size of allocated memory, in bytes.
+  sizes[1] = 0;
+
+  int exsizes[2];
+
+  // celprm::prj.
+  prjsize(&(cel->prj), exsizes);
+  sizes[1] += exsizes[1];
+
+  // celprm::err.
+  wcserr_size(cel->err, exsizes);
+  sizes[1] += exsizes[0] + exsizes[1];
+
+  return CELERR_SUCCESS;
+}
+
+//----------------------------------------------------------------------------
 
 int celprt(const struct celprm *cel)
 
@@ -156,7 +182,7 @@ int celprt(const struct celprm *cel)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celperr(const struct celprm *cel, const char *prefix)
 
@@ -171,7 +197,7 @@ int celperr(const struct celprm *cel, co
 }
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celset(struct celprm *cel)
 
@@ -189,13 +215,13 @@ int celset(struct celprm *cel)
   if (cel == 0x0) return CELERR_NULL_POINTER;
   err = &(cel->err);
 
-  /* Initialize the projection driver routines. */
+  // Initialize the projection driver routines.
   celprj = &(cel->prj);
   if (cel->offset) {
     celprj->phi0   = cel->phi0;
     celprj->theta0 = cel->theta0;
   } else {
-    /* Ensure that these are undefined - no fiducial offset. */
+    // Ensure that these are undefined - no fiducial offset.
     celprj->phi0   = UNDEFINED;
     celprj->theta0 = UNDEFINED;
   }
@@ -204,7 +230,7 @@ int celset(struct celprm *cel)
     return wcserr_set(CEL_ERRMSG(cel_prjerr[status]));
   }
 
-  /* Defaults set by the projection routines. */
+  // Defaults set by the projection routines.
   if (undefined(cel->phi0)) {
     cel->phi0 = celprj->phi0;
   }
@@ -231,7 +257,7 @@ int celset(struct celprm *cel)
   phip = cel->ref[2];
   latp = cel->ref[3];
 
-  /* Set default for native longitude of the celestial pole? */
+  // Set default for native longitude of the celestial pole?
   if (undefined(phip) || phip == 999.0) {
     phip = (lat0 < cel->theta0) ? 180.0 : 0.0;
     phip += cel->phi0;
@@ -246,15 +272,15 @@ int celset(struct celprm *cel)
   }
 
 
-  /* Compute celestial coordinates of the native pole. */
+  // Compute celestial coordinates of the native pole.
   cel->latpreq = 0;
   if (cel->theta0 == 90.0) {
-    /* Fiducial point at the native pole. */
+    // Fiducial point at the native pole.
     lngp = lng0;
     latp = lat0;
 
   } else {
-    /* Fiducial point away from the native pole. */
+    // Fiducial point away from the native pole.
     sincosd(lat0, &slat0, &clat0);
     sincosd(cel->theta0, &sthe0, &cthe0);
 
@@ -278,7 +304,7 @@ int celset(struct celprm *cel)
             "lat0 == 0 is required for |phip - phi0| = 90 and theta0 == 0");
         }
 
-        /* latp determined solely by LATPOLEa in this case. */
+        // latp determined solely by LATPOLEa in this case.
         cel->latpreq = 2;
         if (latp > 90.0) {
           latp = 90.0;
@@ -286,7 +312,7 @@ int celset(struct celprm *cel)
           latp = -90.0;
         }
 
-        /* Avert a spurious compiler warning. */
+        // Avert a spurious compiler warning.
 	u = v = 0.0;
 
       } else {
@@ -327,7 +353,7 @@ int celset(struct celprm *cel)
 
       if (fabs(latp1) < 90.0+tol &&
           fabs(latp2) < 90.0+tol) {
-        /* There are two valid solutions for latp. */
+        // There are two valid solutions for latp.
         cel->latpreq = 1;
       }
 
@@ -345,7 +371,7 @@ int celset(struct celprm *cel)
         }
       }
 
-      /* Account for rounding error. */
+      // Account for rounding error.
       if (fabs(latp) < 90.0+tol) {
         if (latp > 90.0) {
           latp =  90.0;
@@ -358,15 +384,15 @@ int celset(struct celprm *cel)
     z = cosd(latp)*clat0;
     if (fabs(z) < tol) {
       if (fabs(clat0) < tol) {
-        /* Celestial pole at the fiducial point. */
+        // Celestial pole at the fiducial point.
         lngp = lng0;
 
       } else if (latp > 0.0) {
-        /* Celestial north pole at the native pole.*/
+        // Celestial north pole at the native pole.
         lngp = lng0 + phip - cel->phi0 - 180.0;
 
       } else {
-        /* Celestial south pole at the native pole. */
+        // Celestial south pole at the native pole.
         lngp = lng0 - phip + cel->phi0;
       }
 
@@ -374,15 +400,15 @@ int celset(struct celprm *cel)
       x = (sthe0 - sind(latp)*slat0)/z;
       y =  sphip*cthe0/clat0;
       if (x == 0.0 && y == 0.0) {
-        /* Sanity check (shouldn't be possible). */
+        // Sanity check (shouldn't be possible).
         return wcserr_set(WCSERR_SET(CELERR_BAD_COORD_TRANS),
           "Invalid coordinate transformation parameters, internal error");
       }
       lngp = lng0 - atan2d(y,x);
     }
 
-    /* Make celestial longitude of the native pole the same sign as at the
-       fiducial point. */
+    // Make celestial longitude of the native pole the same sign as at the
+    // fiducial point.
     if (lng0 >= 0.0) {
       if (lngp < 0.0) {
         lngp += 360.0;
@@ -398,10 +424,10 @@ int celset(struct celprm *cel)
     }
   }
 
-  /* Reset LATPOLEa. */
+  // Reset LATPOLEa.
   cel->ref[3] = latp;
 
-  /* Set the Euler angles. */
+  // Set the Euler angles.
   cel->euler[0] = lngp;
   cel->euler[1] = 90.0 - latp;
   cel->euler[2] = phip;
@@ -409,7 +435,7 @@ int celset(struct celprm *cel)
   cel->isolat = (cel->euler[4] == 0.0);
   cel->flag = CELSET;
 
-  /* Check for ill-conditioned parameters. */
+  // Check for ill-conditioned parameters.
   if (fabs(latp) > 90.0+tol) {
     return wcserr_set(WCSERR_SET(CELERR_ILL_COORD_TRANS),
       "Ill-conditioned coordinate transformation parameters\nNo valid "
@@ -419,7 +445,7 @@ int celset(struct celprm *cel)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celx2s(
   struct celprm *cel,
@@ -442,7 +468,7 @@ int celx2s(
   struct prjprm *celprj;
   struct wcserr **err;
 
-  /* Initialize. */
+  // Initialize.
   if (cel == 0x0) return CELERR_NULL_POINTER;
   err = &(cel->err);
 
@@ -450,7 +476,7 @@ int celx2s(
     if ((status = celset(cel))) return status;
   }
 
-  /* Apply spherical deprojection. */
+  // Apply spherical deprojection.
   celprj = &(cel->prj);
   if ((istat = celprj->prjx2s(celprj, nx, ny, sxy, 1, x, y, phi, theta,
                                stat))) {
@@ -464,13 +490,13 @@ int celx2s(
 
   nphi = (ny > 0) ? (nx*ny) : nx;
 
-  /* Compute celestial coordinates. */
+  // Compute celestial coordinates.
   sphx2s(cel->euler, nphi, 0, 1, sll, phi, theta, lng, lat);
 
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cels2x(
   struct celprm *cel,
@@ -493,7 +519,7 @@ int cels2x(
   struct prjprm *celprj;
   struct wcserr **err;
 
-  /* Initialize. */
+  // Initialize.
   if (cel == 0x0) return CELERR_NULL_POINTER;
   err = &(cel->err);
 
@@ -501,11 +527,11 @@ int cels2x(
     if ((status = celset(cel))) return status;
   }
 
-  /* Compute native coordinates. */
+  // Compute native coordinates.
   sphs2x(cel->euler, nlng, nlat, sll, 1, lng, lat, phi, theta);
 
   if (cel->isolat) {
-    /* Constant celestial latitude -> constant native latitude. */
+    // Constant celestial latitude -> constant native latitude.
     nphi   = nlng;
     ntheta = nlat;
   } else {
@@ -513,7 +539,7 @@ int cels2x(
     ntheta = 0;
   }
 
-  /* Apply the spherical projection. */
+  // Apply the spherical projection.
   celprj = &(cel->prj);
   if ((istat = celprj->prjs2x(celprj, nphi, ntheta, 1, sxy, phi, theta, x, y,
                                stat))) {
Index: astropy-4.2.1/cextern/wcslib/C/cel.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/cel.h
+++ astropy-4.2.1/cextern/wcslib/C/cel.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: cel.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: cel.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -51,7 +48,8 @@
 *
 * Routine celini() is provided to initialize the celprm struct with default
 * values, celfree() reclaims any memory that may have been allocated to store
-* an error message, and celprt() prints its contents.
+* an error message, celsize() computes its total size including allocated
+* memory, and celprt() prints its contents.
 *
 * celperr() prints the error message(s), if any, stored in a celprm struct and
 * the prjprm struct that it contains.
@@ -102,6 +100,33 @@
 *                         1: Null celprm pointer passed.
 *
 *
+* celsize() - Compute the size of a celprm struct
+* -----------------------------------------------
+* celsize() computes the full size of a celprm struct, including allocated
+* memory.
+*
+* Given:
+*   cel       const struct celprm*
+*                       Celestial transformation parameters.
+*
+*                       If NULL, the base size of the struct and the allocated
+*                       size are both set to zero.
+*
+* Returned:
+*   sizes     int[2]    The first element is the base size of the struct as
+*                       returned by sizeof(struct celprm).  The second element
+*                       is the total allocated size, in bytes.  This figure
+*                       includes memory allocated for the constituent struct,
+*                       celprm::err.
+*
+*                       It is not an error for the struct not to have been set
+*                       up via celset().
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*
+*
 * celprt() - Print routine for the celprm struct
 * ----------------------------------------------
 * celprt() prints the contents of a celprm struct using wcsprintf().  Mainly
@@ -382,50 +407,50 @@ extern "C" {
 extern const char *cel_errmsg[];
 
 enum cel_errmsg_enum {
-  CELERR_SUCCESS         = 0,	/* Success. */
-  CELERR_NULL_POINTER    = 1,	/* Null celprm pointer passed. */
-  CELERR_BAD_PARAM       = 2,	/* Invalid projection parameters. */
-  CELERR_BAD_COORD_TRANS = 3,	/* Invalid coordinate transformation
-				   parameters. */
-  CELERR_ILL_COORD_TRANS = 4,	/* Ill-conditioned coordinated transformation
-				   parameters. */
-  CELERR_BAD_PIX         = 5,	/* One or more of the (x,y) coordinates were
-				   invalid. */
-  CELERR_BAD_WORLD       = 6 	/* One or more of the (lng,lat) coordinates
-				   were invalid. */
+  CELERR_SUCCESS         = 0,	// Success.
+  CELERR_NULL_POINTER    = 1,	// Null celprm pointer passed.
+  CELERR_BAD_PARAM       = 2,	// Invalid projection parameters.
+  CELERR_BAD_COORD_TRANS = 3,	// Invalid coordinate transformation
+				// parameters.
+  CELERR_ILL_COORD_TRANS = 4,	// Ill-conditioned coordinated transformation
+				// parameters.
+  CELERR_BAD_PIX         = 5,	// One or more of the (x,y) coordinates were
+				// invalid.
+  CELERR_BAD_WORLD       = 6 	// One or more of the (lng,lat) coordinates
+				// were invalid.
 };
 
 struct celprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int    flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  int    offset;		/* Force (x,y) = (0,0) at (phi_0,theta_0).  */
-  double phi0, theta0;		/* Native coordinates of fiducial point.    */
-  double ref[4];		/* Celestial coordinates of fiducial        */
-                                /* point and native coordinates of          */
-                                /* celestial pole.                          */
-
-  struct prjprm prj;		/* Projection parameters (see prj.h).       */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  double euler[5];		/* Euler angles and functions thereof.      */
-  int    latpreq;		/* LATPOLEa requirement.                    */
-  int    isolat;		/* True if |latitude| is preserved.         */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    offset;		// Force (x,y) = (0,0) at (phi_0,theta_0).
+  double phi0, theta0;		// Native coordinates of fiducial point.
+  double ref[4];		// Celestial coordinates of fiducial
+                                // point and native coordinates of
+                                // celestial pole.
+
+  struct prjprm prj;		// Projection parameters (see prj.h).
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  double euler[5];		// Euler angles and functions thereof.
+  int    latpreq;		// LATPOLEa requirement.
+  int    isolat;		// True if |latitude| is preserved.
 
-  /* Error handling                                                         */
-  /*------------------------------------------------------------------------*/
+  // Error handling
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private                                                                */
-  /*------------------------------------------------------------------------*/
-  void   *padding;		/* (Dummy inserted for alignment purposes.) */
+  // Private
+  //--------------------------------------------------------------------------
+  void   *padding;		// (Dummy inserted for alignment purposes.)
 };
 
-/* Size of the celprm struct in int units, used by the Fortran wrappers. */
+// Size of the celprm struct in int units, used by the Fortran wrappers.
 #define CELLEN (sizeof(struct celprm)/sizeof(int))
 
 
@@ -433,6 +458,8 @@ int celini(struct celprm *cel);
 
 int celfree(struct celprm *cel);
 
+int celsize(const struct celprm *cel, int sizes[2]);
+
 int celprt(const struct celprm *cel);
 
 int celperr(const struct celprm *cel, const char *prefix);
@@ -450,7 +477,7 @@ int cels2x(struct celprm *cel, int nlng,
            int stat[]);
 
 
-/* Deprecated. */
+// Deprecated.
 #define celini_errmsg cel_errmsg
 #define celprt_errmsg cel_errmsg
 #define celset_errmsg cel_errmsg
@@ -461,4 +488,4 @@ int cels2x(struct celprm *cel, int nlng,
 }
 #endif
 
-#endif /* WCSLIB_CEL */
+#endif // WCSLIB_CEL
Index: astropy-4.2.1/cextern/wcslib/C/dis.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/dis.c
+++ astropy-4.2.1/cextern/wcslib/C/dis.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: dis.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: dis.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -41,10 +38,10 @@ const int DIS_TPD        =    1;
 const int DIS_POLYNOMIAL =    2;
 const int DIS_DOTPD      = 1024;
 
-/* Maximum number of DPja or DQia keywords. */
+// Maximum number of DPja or DQia keywords.
 int NDPMAX = 256;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *dis_errmsg[] = {
   "Success",
   "Null disprm pointer passed",
@@ -53,10 +50,10 @@ const char *dis_errmsg[] = {
   "Distort error",
   "De-distort error"};
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define DIS_ERRMSG(status) WCSERR_SET(status), dis_errmsg[status]
 
-/* Internal helper functions, not for general use. */
+// Internal helper functions, not for general use.
 static int polyset(int j, struct disprm *dis);
 static int tpdset(int j, struct disprm *dis);
 
@@ -78,17 +75,17 @@ static int tpd7(DISP2X_ARGS);
 static int tpd8(DISP2X_ARGS);
 static int tpd9(DISP2X_ARGS);
 
-/* The first three iparm indices have meanings common to all distortion     */
-/* functions.  They are used by disp2x(), disx2p(), disprt(), and dishdo(). */
-#define I_DTYPE   0	/* Distortion type code.                            */
-#define I_NIPARM  1	/* Full (allocated) length of iparm[].              */
-#define I_NDPARM  2	/* No. of parameters in dparm[], excl. work space.  */
+// The first three iparm indices have meanings common to all distortion
+// functions.  They are used by disp2x(), disx2p(), disprt(), and dishdo().
+#define I_DTYPE   0	// Distortion type code.
+#define I_NIPARM  1	// Full (allocated) length of iparm[].
+#define I_NDPARM  2	// No. of parameters in dparm[], excl. work space.
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disndp(int ndpmax) { if (ndpmax >= 0) NDPMAX = ndpmax; return NDPMAX; }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int dpfill(
   struct dpkey *dp,
@@ -105,11 +102,11 @@ int dpfill(
   if (keyword) {
     if (field) {
       if (j && 2 <= strlen(keyword)) {
-        /* Fill in the axis number from the value given. */
+        // Fill in the axis number from the value given.
         if (keyword[2] == '\0') {
           sprintf(dp->field, "%s%d.%s", keyword, j, field);
         } else {
-          /* Take care not to overwrite any alternate code. */
+          // Take care not to overwrite any alternate code.
           sprintf(dp->field, "%s.%s", keyword, field);
           sprintf(axno, "%d", j);
           dp->field[2] = axno[0];
@@ -128,7 +125,7 @@ int dpfill(
   if (j) {
     dp->j = j;
   } else {
-    /* The field name must either be given or preset. */
+    // The field name must either be given or preset.
     if ((cp = strpbrk(dp->field, "0123456789")) != 0x0) {
       sscanf(cp, "%d.", &(dp->j));
     }
@@ -143,7 +140,7 @@ int dpfill(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int dpkeyi(const struct dpkey *dp)
 
@@ -155,7 +152,7 @@ int dpkeyi(const struct dpkey *dp)
   return dp->value.i;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double dpkeyd(const struct dpkey *dp)
 
@@ -167,7 +164,7 @@ double dpkeyd(const struct dpkey *dp)
   return dp->value.f;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disini(int alloc, int naxis, struct disprm *dis)
 
@@ -175,7 +172,7 @@ int disini(int alloc, int naxis, struct
   return disinit(alloc, naxis, dis, -1);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disinit(int alloc, int naxis, struct disprm *dis, int ndpmax)
 
@@ -184,13 +181,13 @@ int disinit(int alloc, int naxis, struct
 
   struct wcserr **err;
 
-  /* Check inputs. */
+  // Check inputs.
   if (dis == 0x0) return DISERR_NULL_POINTER;
 
   if (ndpmax < 0) ndpmax = disndp(-1);
 
 
-  /* Initialize error message handling. */
+  // Initialize error message handling.
   if (dis->flag == -1) {
     dis->err = 0x0;
   }
@@ -198,7 +195,7 @@ int disinit(int alloc, int naxis, struct
   wcserr_clear(err);
 
 
-  /* Initialize pointers. */
+  // Initialize pointers.
   if (dis->flag == -1 || dis->m_flag != DISSET) {
     if (dis->flag == -1) {
       dis->docorr = 0x0;
@@ -217,7 +214,7 @@ int disinit(int alloc, int naxis, struct
       dis->i_naxis = 0;
     }
 
-    /* Initialize memory management. */
+    // Initialize memory management.
     dis->m_flag   = 0;
     dis->m_naxis  = 0;
     dis->m_dtype  = 0x0;
@@ -231,23 +228,23 @@ int disinit(int alloc, int naxis, struct
   }
 
 
-  /* Allocate memory for arrays if required. */
+  // Allocate memory for arrays if required.
   if (alloc ||
       dis->dtype  == 0x0 ||
       (ndpmax && dis->dp == 0x0) ||
       dis->maxdis == 0x0) {
 
-    /* Was sufficient allocated previously? */
+    // Was sufficient allocated previously?
     if (dis->m_flag == DISSET &&
        (dis->m_naxis < naxis  ||
         dis->ndpmax  < ndpmax)) {
-      /* No, free it. */
+      // No, free it.
       disfree(dis);
     }
 
     if (alloc || dis->dtype == 0x0) {
       if (dis->m_dtype) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         dis->dtype = dis->m_dtype;
 
       } else {
@@ -264,7 +261,7 @@ int disinit(int alloc, int naxis, struct
 
     if (alloc || dis->dp == 0x0) {
       if (dis->m_dp) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         dis->dp = dis->m_dp;
 
       } else {
@@ -287,7 +284,7 @@ int disinit(int alloc, int naxis, struct
 
     if (alloc || dis->maxdis == 0x0) {
       if (dis->m_maxdis) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         dis->maxdis = dis->m_maxdis;
 
       } else {
@@ -304,7 +301,7 @@ int disinit(int alloc, int naxis, struct
   }
 
 
-  /* Set defaults. */
+  // Set defaults.
   dis->flag  = 0;
   dis->naxis = naxis;
 
@@ -326,7 +323,7 @@ int disinit(int alloc, int naxis, struct
 }
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int discpy(int alloc, const struct disprm *dissrc, struct disprm *disdst)
 
@@ -361,7 +358,7 @@ int discpy(int alloc, const struct dispr
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disfree(struct disprm *dis)
 
@@ -371,7 +368,7 @@ int disfree(struct disprm *dis)
   if (dis == 0x0) return DISERR_NULL_POINTER;
 
   if (dis->flag != -1) {
-    /* Optionally allocated by disinit() for given parameters. */
+    // Optionally allocated by disinit() for given parameters.
     if (dis->m_flag == DISSET) {
       if (dis->dtype  == dis->m_dtype)  dis->dtype  = 0x0;
       if (dis->dp     == dis->m_dp)     dis->dp     = 0x0;
@@ -382,11 +379,11 @@ int disfree(struct disprm *dis)
       if (dis->m_maxdis) free(dis->m_maxdis);
     }
 
-    /* The remainder were allocated by disset(). */
+    // The remainder were allocated by disset().
     if (dis->docorr) free(dis->docorr);
     if (dis->Nhat)   free(dis->Nhat);
 
-    /* Recall that axmap, offset, and scale were allocated in bulk. */
+    // Recall that axmap, offset, and scale were allocated in bulk.
     if (dis->axmap  && dis->axmap[0])  free(dis->axmap[0]);
     if (dis->offset && dis->offset[0]) free(dis->offset[0]);
     if (dis->scale  && dis->scale[0])  free(dis->scale[0]);
@@ -430,7 +427,90 @@ int disfree(struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
+
+int dissize(const struct disprm *dis, int sizes[2])
+
+{
+  if (dis == 0x0) {
+    sizes[0] = sizes[1] = 0;
+    return DISERR_NULL_POINTER;
+  }
+
+  // Base size, in bytes.
+  sizes[0] = sizeof(struct disprm);
+
+  // Total size of allocated memory, in bytes.
+  sizes[1] = 0;
+
+  int exsizes[2];
+  int naxis = dis->naxis;
+
+  // disprm::dtype[].
+  sizes[1] += naxis * sizeof(char [72]);
+
+  // disprm::dp[].
+  sizes[1] += dis->ndpmax * sizeof(struct dpkey);
+
+  // disprm::maxdis[].
+  sizes[1] += naxis * sizeof(double);
+
+  // dis::err[].
+  wcserr_size(dis->err, exsizes);
+  sizes[1] += exsizes[0] + exsizes[1];
+
+  // The remaining arrays are allocated by disset().
+  if (dis->flag != DISSET) {
+    return DISERR_SUCCESS;
+  }
+
+  // dis::docorr[].
+  sizes[1] += naxis * sizeof(int *);
+
+  // dis::Nhat[].
+  sizes[1] += naxis * sizeof(int *);
+
+  // dis::axmap[][].
+  sizes[1] += naxis * sizeof(int *);
+  sizes[1] += naxis*naxis * sizeof(int);
+
+  // dis::offset[][].
+  sizes[1] += naxis * sizeof(double *);
+  sizes[1] += naxis*naxis * sizeof(double);
+
+  // dis::scale[][].
+  sizes[1] += naxis * sizeof(double *);
+  sizes[1] += naxis*naxis * sizeof(double);
+
+  // dis::iparm[][].
+  sizes[1] += naxis * sizeof(int *);
+  for (int j = 0; j < naxis; j++) {
+    if (dis->iparm[j]) {
+      sizes[1] += dis->iparm[j][I_NIPARM] * sizeof(int);
+    }
+  }
+
+  // dis::dparm[][].
+  sizes[1] += naxis * sizeof(double *);
+  for (int j = 0; j < naxis; j++) {
+    if (dis->dparm[j]) {
+      sizes[1] += dis->dparm[j][I_NDPARM] * sizeof(double);
+    }
+  }
+
+  // dis::disp2x[].
+  sizes[1] += naxis * sizeof(int (*)(DISP2X_ARGS));
+
+  // dis::disx2p[].
+  sizes[1] += naxis * sizeof(int (*)(DISX2P_ARGS));
+
+  // dis::tmpmem[].
+  sizes[1] += 5*naxis * sizeof(double);
+
+  return DISERR_SUCCESS;
+}
+
+//----------------------------------------------------------------------------
 
 int disprt(const struct disprm *dis)
 
@@ -450,7 +530,7 @@ int disprt(const struct disprm *dis)
 
   wcsprintf("       flag: %d\n", dis->flag);
 
-  /* Parameters supplied. */
+  // Parameters supplied.
   wcsprintf("      naxis: %d\n", naxis);
 
   WCSPRINTF_PTR("      dtype: ", dis->dtype, "\n");
@@ -480,7 +560,7 @@ int disprt(const struct disprm *dis)
 
   wcsprintf("     totdis:  %#- 11.5g\n", dis->totdis);
 
-  /* Derived values. */
+  // Derived values.
   WCSPRINTF_PTR("     docorr: ", dis->docorr, "\n");
   wcsprintf("            ");
   for (j = 0; j < naxis; j++) {
@@ -559,13 +639,13 @@ int disprt(const struct disprm *dis)
   wcsprintf("    i_naxis: %d\n", dis->i_naxis);
   wcsprintf("       ndis: %d\n", dis->ndis);
 
-  /* Error handling. */
+  // Error handling.
   WCSPRINTF_PTR("        err: ", dis->err, "\n");
   if (dis->err) {
     wcserr_prt(dis->err, "             ");
   }
 
-  /* Work arrays. */
+  // Work arrays.
   WCSPRINTF_PTR("     disp2x: ", dis->disp2x, "\n");
   for (j = 0; j < naxis; j++) {
     wcsprintf("  disp2x[%d]: %s", j,
@@ -601,7 +681,7 @@ int disprt(const struct disprm *dis)
   }
   WCSPRINTF_PTR("     tmpmem: ", dis->tmpmem, "\n");
 
-  /* Memory management. */
+  // Memory management.
   wcsprintf("     m_flag: %d\n", dis->m_flag);
   wcsprintf("    m_naxis: %d\n", dis->m_naxis);
   WCSPRINTF_PTR("    m_dtype: ", dis->m_dtype, "");
@@ -617,7 +697,7 @@ int disprt(const struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disperr(const struct disprm *dis, const char *prefix)
 
@@ -631,7 +711,7 @@ int disperr(const struct disprm *dis, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int dishdo(struct disprm *dis)
 
@@ -648,13 +728,13 @@ int dishdo(struct disprm *dis)
   for (j = 0; j < dis->naxis; j++) {
     if (dis->iparm[j][I_DTYPE]) {
       if (dis->iparm[j][I_DTYPE] == DIS_TPD) {
-        /* Implemented as TPD... */
+        // Implemented as TPD...
         if (strcmp(dis->dtype[j], "TPD") != 0) {
-          /* ... but isn't TPD. */
+          // ... but isn't TPD.
           dis->iparm[j][I_DTYPE] |= DIS_DOTPD;
         }
       } else {
-        /* Must be a Polynomial that can't be implemented as TPD. */
+        // Must be a Polynomial that can't be implemented as TPD.
         status = wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
           "Translation of %s to TPD is not possible", dis->dtype[j]);
       }
@@ -664,7 +744,7 @@ int dishdo(struct disprm *dis)
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disset(struct disprm *dis)
 
@@ -682,7 +762,7 @@ int disset(struct disprm *dis)
   naxis = dis->naxis;
 
 
-  /* Do basic checks. */
+  // Do basic checks.
   if (dis->ndp < 0) {
     return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
       "disprm::ndp is negative (%d)", dis->ndp);
@@ -697,7 +777,7 @@ int disset(struct disprm *dis)
   }
 
   if (dis->ndp) {
-    /* Is it prior or sequent? */
+    // Is it prior or sequent?
     if (dis->dp[0].field[1] == 'P') {
       dpq = "DPja";
     } else if (dis->dp[0].field[1] == 'Q') {
@@ -714,26 +794,26 @@ int disset(struct disprm *dis)
         "distortion");
     }
 
-    /* A Clayton's distortion.  Avert compiler warnings about possible use of
-       uninitialized variables. */
+    // A Clayton's distortion.  Avert compiler warnings about possible use of
+    // uninitialized variables.
     dpq = 0x0;
   }
 
 
-  /* Free memory allocated separately for each axis. */
+  // Free memory allocated separately for each axis.
   for (j = 0; j < dis->i_naxis; j++) {
     if (dis->iparm[j]) free(dis->iparm[j]);
     if (dis->dparm[j]) free(dis->dparm[j]);
   }
 
-  /* Allocate or reallocate memory, if necessary, for derived parameter and
-     work arrays sized according to the number of axes. */
+  // Allocate or reallocate memory, if necessary, for derived parameter and
+  // work arrays sized according to the number of axes.
   if (dis->i_naxis < naxis) {
     if (dis->i_naxis) {
       free(dis->docorr);
       free(dis->Nhat);
 
-      /* Noting that axmap, offset, and scale are allocated in bulk. */
+      // Noting that axmap, offset, and scale are allocated in bulk.
       free(dis->axmap[0]);
       free(dis->axmap);
       free(dis->offset[0]);
@@ -760,7 +840,7 @@ int disset(struct disprm *dis)
       return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
     }
 
-    /* Allocate axmap[][] in bulk and then carve it up. */
+    // Allocate axmap[][] in bulk and then carve it up.
     if ((dis->axmap = calloc(naxis, sizeof(int *))) == 0x0) {
       disfree(dis);
       return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -775,7 +855,7 @@ int disset(struct disprm *dis)
       dis->axmap[j] = dis->axmap[j-1] + naxis;
     }
 
-    /* Allocate offset[][] in bulk and then carve it up. */
+    // Allocate offset[][] in bulk and then carve it up.
     if ((dis->offset = calloc(naxis, sizeof(double *))) == 0x0) {
       disfree(dis);
       return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -790,7 +870,7 @@ int disset(struct disprm *dis)
       dis->offset[j] = dis->offset[j-1] + naxis;
     }
 
-    /* Allocate scale[][] in bulk and then carve it up. */
+    // Allocate scale[][] in bulk and then carve it up.
     if ((dis->scale = calloc(naxis, sizeof(double *))) == 0x0) {
       disfree(dis);
       return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -833,7 +913,7 @@ int disset(struct disprm *dis)
     dis->i_naxis = naxis;
   }
 
-  /* Start with a clean slate. */
+  // Start with a clean slate.
   for (j = 0; j < naxis; j++) {
     dis->docorr[j] = 1;
   }
@@ -850,7 +930,7 @@ int disset(struct disprm *dis)
     dis->scale[0][jhat] = 1.0;
   }
 
-  /* polyset() etc. must look after iparm[][] and dparm[][]. */
+  // polyset() etc. must look after iparm[][] and dparm[][].
 
   dis->i_naxis = naxis;
   dis->ndis    = 0;
@@ -860,10 +940,10 @@ int disset(struct disprm *dis)
   memset(dis->tmpmem, 0, naxis*sizeof(double));
 
 
-  /* Handle DPja or DQia keywords common to all distortions. */
+  // Handle DPja or DQia keywords common to all distortions.
   keyp = dis->dp;
   for (idp = 0; idp < dis->ndp; idp++, keyp++) {
-    /* Check that they're all one kind or the other. */
+    // Check that they're all one kind or the other.
     if (keyp->field[1] != dpq[1]) {
       return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
         "disprm::dp appears to contain a mix of DPja and DQia keys");
@@ -882,7 +962,7 @@ int disset(struct disprm *dis)
     }
     fp++;
 
-    /* Convert to 0-relative axis number. */
+    // Convert to 0-relative axis number.
     j--;
 
     if (strncmp(fp, "DOCORR", 7) == 0) {
@@ -908,7 +988,7 @@ int disset(struct disprm *dis)
           dis->dtype[j], keyp->field, jhat);
       }
 
-      /* N.B. axis numbers in the map are 0-relative. */
+      // N.B. axis numbers in the map are 0-relative.
       dis->axmap[j][jhat-1] = dpkeyi(keyp) - 1;
 
     } else if (strncmp(fp, "OFFSET.", 7) == 0) {
@@ -921,10 +1001,10 @@ int disset(struct disprm *dis)
     }
   }
 
-  /* Set defaults and do sanity checks on axmap[][].  */
+  // Set defaults and do sanity checks on axmap[][].
   for (j = 0; j < naxis; j++) {
     if (strlen(dis->dtype[j]) == 0) {
-      /* No distortion on this axis, check that there are no parameters. */
+      // No distortion on this axis, check that there are no parameters.
       keyp = dis->dp;
       for (idp = 0; idp < dis->ndp; idp++, keyp++) {
         if (keyp->j == j+1) {
@@ -937,14 +1017,14 @@ int disset(struct disprm *dis)
       continue;
     }
 
-    /* N.B. NAXES (Nhat) has no default value. */
+    // N.B. NAXES (Nhat) has no default value.
     if (dis->Nhat[j] <= 0) {
       return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
         "%s.NAXES was not set (or bad) for %s distortion on axis %d",
         dpq, dis->dtype[j], j+1);
     }
 
-    /* Set defaults for axmap[][]. */
+    // Set defaults for axmap[][].
     Nhat = dis->Nhat[j];
     for (jhat = 0; jhat < Nhat; jhat++) {
       if (dis->axmap[j][jhat] == -1) {
@@ -952,7 +1032,7 @@ int disset(struct disprm *dis)
       }
     }
 
-    /* Sanity check on the length of the axis map. */
+    // Sanity check on the length of the axis map.
     Nhat = 0;
     for (jhat = 0; jhat < naxis; jhat++) {
       if (dis->axmap[j][jhat] != -1) Nhat = jhat+1;
@@ -964,7 +1044,7 @@ int disset(struct disprm *dis)
         dis->dtype[j], j+1);
     }
 
-    /* Check uniqueness of entries in the axis map. */
+    // Check uniqueness of entries in the axis map.
     for (jhat = 0; jhat < Nhat; jhat++) {
       for (k = 0; k < jhat; k++) {
         if (dis->axmap[j][jhat] == dis->axmap[j][k]) {
@@ -977,11 +1057,11 @@ int disset(struct disprm *dis)
   }
 
 
-  /* Identify the distortion functions. */
+  // Identify the distortion functions.
   ndis = 0;
   for (j = 0; j < naxis; j++) {
     if (strlen(dis->dtype[j]) == 0) {
-      /* No distortion on this axis. */
+      // No distortion on this axis.
       continue;
     }
 
@@ -990,47 +1070,47 @@ int disset(struct disprm *dis)
         "Empty axis map for %s distortion on axis %d", dis->dtype[j], j+1);
     }
 
-    /* Invoke the specific setup functions for each distortion. */
+    // Invoke the specific setup functions for each distortion.
     if (strcmp(dis->dtype[j], "TPD") == 0) {
-      /* Template Polynomial Distortion. */
+      // Template Polynomial Distortion.
       if ((status = tpdset(j, dis))) {
-        /* (Preserve the error message set by tpdset().) */
+        // (Preserve the error message set by tpdset().)
         return status;
       }
 
     } else if (strcmp(dis->dtype[j], "TPV") == 0) {
-      /* TPV "projection". */
+      // TPV "projection".
       if ((status = tpvset(j, dis))) {
-        /* (Preserve the error message set by tpvset().) */
+        // (Preserve the error message set by tpvset().)
         return status;
       }
 
     } else if (strcmp(dis->dtype[j], "SIP") == 0) {
-      /* Simple Imaging Polynomial (SIP). */
+      // Simple Imaging Polynomial (SIP).
       if ((status = sipset(j, dis))) {
-        /* (Preserve the error message set by sipset().) */
+        // (Preserve the error message set by sipset().)
         return status;
       }
 
     } else if (strcmp(dis->dtype[j], "DSS") == 0) {
-      /* Digitized Sky Survey (DSS). */
+      // Digitized Sky Survey (DSS).
       if ((status = dssset(j, dis))) {
-        /* (Preserve the error message set by dssset().) */
+        // (Preserve the error message set by dssset().)
         return status;
       }
 
     } else if (strncmp(dis->dtype[j], "WAT", 3) == 0) {
-      /* WAT (TNX or ZPX "projections"). */
+      // WAT (TNX or ZPX "projections").
       if ((status = watset(j, dis))) {
-        /* (Preserve the error message set by watset().) */
+        // (Preserve the error message set by watset().)
         return status;
       }
 
     } else if (strcmp(dis->dtype[j], "Polynomial")  == 0 ||
                strcmp(dis->dtype[j], "Polynomial*") == 0) {
-      /* General polynomial distortion. */
+      // General polynomial distortion.
       if ((status = polyset(j, dis))) {
-        /* (Preserve the error message set by polyset().) */
+        // (Preserve the error message set by polyset().)
         return status;
       }
 
@@ -1048,7 +1128,7 @@ int disset(struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disp2x(
   struct disprm *dis,
@@ -1063,7 +1143,7 @@ int disp2x(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
@@ -1074,7 +1154,7 @@ int disp2x(
   naxis = dis->naxis;
 
 
-  /* Invoke the distortion functions for each axis. */
+  // Invoke the distortion functions for each axis.
   tmpcrd = dis->tmpmem;
   for (j = 0; j < naxis; j++) {
     if (dis->disp2x[j]) {
@@ -1093,10 +1173,10 @@ int disp2x(
       }
 
       if (dis->docorr[j]) {
-        /* Distortion function computes a correction to be applied. */
+        // Distortion function computes a correction to be applied.
         discrd[j] = rawcrd[j] + dtmp;
       } else {
-        /* Distortion function computes corrected coordinates. */
+        // Distortion function computes corrected coordinates directly.
         discrd[j] = dtmp;
       }
 
@@ -1108,9 +1188,9 @@ int disp2x(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
-/* This function is intended for debugging purposes only.                   */
-/* No documentation or prototype is provided in dis.h.                      */
+//----------------------------------------------------------------------------
+// This function is intended for debugging purposes only.
+// No documentation or prototype is provided in dis.h.
 
 int disitermax(int itermax)
 
@@ -1124,7 +1204,7 @@ int disitermax(int itermax)
   return ITERMAX;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disx2p(
   struct disprm *dis,
@@ -1142,28 +1222,28 @@ int disx2p(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
   naxis = dis->naxis;
 
-  /* Carve up working memory, noting that disp2x() gets to it first. */
+  // Carve up working memory, noting that disp2x() gets to it first.
   dcrd0 = dis->tmpmem + naxis;
   dcrd1 = dcrd0 + naxis;
   rcrd1 = dcrd1 + naxis;
   delta = rcrd1 + naxis;
 
 
-  /* Zeroth approximation.  The assumption here and below is that the     */
-  /* distortion is small so that, to first order in the neighbourhood of  */
-  /* the solution, discrd[j] ~= a + b*rawcrd[j], i.e. independent of      */
-  /* rawcrd[i], where i != j.  This is effectively equivalent to assuming */
-  /* that the distortion functions are separable to first order.          */
-  /* Furthermore, a is assumed to be small, and b close to unity.         */
+  // Zeroth approximation.  The assumption here and below is that the
+  // distortion is small so that, to first order in the neighbourhood of
+  // the solution, discrd[j] ~= a + b*rawcrd[j], i.e. independent of
+  // rawcrd[i], where i != j.  This is effectively equivalent to assuming
+  // that the distortion functions are separable to first order.
+  // Furthermore, a is assumed to be small, and b close to unity.
   memcpy(rawcrd, discrd, naxis*sizeof(double));
 
-  /* If available, use disprm::disx2p to improve the zeroth approximation. */
+  // If available, use disprm::disx2p to improve the zeroth approximation.
   for (j = 0; j < naxis; j++) {
     if (dis->disx2p[j]) {
       offset = dis->offset[j];
@@ -1182,28 +1262,28 @@ int disx2p(
       }
 
       if (dis->docorr[j]) {
-        /* Inverse distortion function computes a correction to be applied. */
+        // Inverse distortion function computes a correction to be applied.
         rawcrd[j] = discrd[j] + rtmp;
       } else {
-        /* Inverse distortion function computes corrected coordinates. */
+        // Inverse distortion function computes corrected coordinates directly.
         rawcrd[j] = rtmp;
       }
     }
   }
 
-  /* Quick return debugging hook, assumes inverse functions were defined. */
+  // Quick return debugging hook, assumes inverse functions were defined.
   if ((itermax = disitermax(-1)) == 0) {
     return 0;
   }
 
 
-  /* Iteratively invert the (well-behaved!) distortion function. */
+  // Iteratively invert the (well-behaved!) distortion function.
   for (iter = 0; iter < itermax; iter++) {
     if ((status = disp2x(dis, rawcrd, dcrd0))) {
       return wcserr_set(DIS_ERRMSG(status));
     }
 
-    /* Check for convergence. */
+    // Check for convergence.
     convergence = 1;
     for (j = 0; j < naxis; j++) {
       delta[j] = discrd[j] - dcrd0[j];
@@ -1211,22 +1291,22 @@ int disx2p(
       if (fabs(discrd[j]) < 1.0) {
         dd = delta[j];
       } else {
-        /* TOL may be below the precision achievable from floating point */
-        /* subtraction, so switch to a fractional tolerance.             */
+        // TOL may be below the precision achievable from floating point
+        // subtraction, so switch to a fractional tolerance.
         dd = delta[j] / discrd[j];
       }
 
       if (TOL < fabs(dd)) {
-        /* No convergence yet on this axis. */
+        // No convergence yet on this axis.
         convergence = 0;
       }
     }
 
     if (convergence) break;
 
-    /* Determine a suitable test point for computing the gradient. */
+    // Determine a suitable test point for computing the gradient.
     for (j = 0; j < naxis; j++) {
-      /* Constrain the displacement. */
+      // Constrain the displacement.
       delta[j] /= 2.0;
       if (fabs(delta[j]) < 1.0e-6) {
         if (delta[j] < 0.0) {
@@ -1244,40 +1324,40 @@ int disx2p(
     }
 
     if (iter < itermax/2) {
-      /* With the assumption of small distortions (as above), the gradient */
-      /* of discrd[j] should be dominated by the partial derivative with   */
-      /* respect to rawcrd[j], and we can neglect partials with respect    */
-      /* to rawcrd[i], where i != j.  Thus only one test point is needed,  */
-      /* not one for each axis.                                            */
+      // With the assumption of small distortions (as above), the gradient
+      // of discrd[j] should be dominated by the partial derivative with
+      // respect to rawcrd[j], and we can neglect partials with respect
+      // to rawcrd[i], where i != j.  Thus only one test point is needed,
+      // not one for each axis.
       for (j = 0; j < naxis; j++) {
         rcrd1[j] = rawcrd[j] + delta[j];
       }
 
-      /* Compute discrd[] at the test point. */
+      // Compute discrd[] at the test point.
       if ((status = disp2x(dis, rcrd1, dcrd1))) {
         return wcserr_set(DIS_ERRMSG(status));
       }
 
-      /* Compute the next approximation. */
+      // Compute the next approximation.
       for (j = 0; j < naxis; j++) {
         rawcrd[j] += (discrd[j] - dcrd0[j]) *
                         (delta[j]/(dcrd1[j] - dcrd0[j]));
       }
 
     } else {
-      /* Convergence should not take more than seven or so iterations.  As */
-      /* it is slow, try computing the gradient in full.                   */
+      // Convergence should not take more than seven or so iterations.  As
+      // it is slow, try computing the gradient in full.
       memcpy(rcrd1, rawcrd, naxis*sizeof(double));
 
       for (j = 0; j < naxis; j++) {
         rcrd1[j] += delta[j];
 
-        /* Compute discrd[] at the test point. */
+        // Compute discrd[] at the test point.
         if ((status = disp2x(dis, rcrd1, dcrd1))) {
           return wcserr_set(DIS_ERRMSG(status));
         }
 
-        /* Compute the next approximation. */
+        // Compute the next approximation.
         rawcrd[j] += (discrd[j] - dcrd0[j]) *
                        (delta[j]/(dcrd1[j] - dcrd0[j]));
 
@@ -1304,7 +1384,7 @@ int disx2p(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int diswarp(
   struct disprm *dis,
@@ -1328,7 +1408,7 @@ int diswarp(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
@@ -1344,16 +1424,16 @@ int diswarp(
   if (avgtot) *avgtot = 0.0;
   if (rmstot) *rmstot = 0.0;
 
-  /* Quick return if no distortions. */
+  // Quick return if no distortions.
   if (dis->ndis == 0) return 0;
 
-  /* Carve up working memory, noting that disp2x() gets to it first. */
+  // Carve up working memory, noting that disp2x() gets to it first.
   pixinc = dis->tmpmem + naxis;
   pixend = pixinc + naxis;
   sumdis = pixend + naxis;
   ssqdis = sumdis + naxis;
 
-  /* Work out increments on each axis. */
+  // Work out increments on each axis.
   for (j = 0; j < naxis; j++) {
     pixspan = pixtrc[j] - (pixblc ? pixblc[j] : 1.0);
 
@@ -1370,7 +1450,7 @@ int diswarp(
     }
   }
 
-  /* Get some more memory for coordinate vectors. */
+  // Get some more memory for coordinate vectors.
   if ((pix0 = calloc(2*naxis, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -1378,13 +1458,13 @@ int diswarp(
   pix1 = pix0 + naxis;
 
 
-  /* Set up the array of pixel coordinates. */
+  // Set up the array of pixel coordinates.
   for (j = 0; j < naxis; j++) {
     pix0[j] = pixblc ? pixblc[j] : 1.0;
     pixend[j] = pixtrc[j] + 0.5*pixinc[j];
   }
 
-  /* Initialize accumulators. */
+  // Initialize accumulators.
   for (j = 0; j < naxis; j++) {
     sumdis[j] = 0.0;
     ssqdis[j] = 0.0;
@@ -1393,15 +1473,15 @@ int diswarp(
   ssqtot = 0.0;
 
 
-  /* Loop over N dimensions. */
+  // Loop over N dimensions.
   carry = 0;
   while (carry == 0) {
     if ((status = disp2x(dis, pix0, pix1))) {
-      /* (Preserve the error message set by disp2x().) */
+      // (Preserve the error message set by disp2x().)
       goto cleanup;
     }
 
-    /* Accumulate statistics. */
+    // Accumulate statistics.
     (*nsamp)++;
 
     dssq = 0.0;
@@ -1427,7 +1507,7 @@ int diswarp(
       *maxtot = totdis;
     }
 
-    /* Next pixel. */
+    // Next pixel.
     for (j = 0; j < naxis; j++) {
       pix0[j] += pixinc[j];
       if (pix0[j] < pixend[j]) {
@@ -1441,7 +1521,7 @@ int diswarp(
   }
 
 
-  /* Compute the means and RMSs. */
+  // Compute the means and RMSs.
   for (j = 0; j < naxis; j++) {
     ssqdis[j] /= *nsamp;
     sumdis[j] /= *nsamp;
@@ -1461,7 +1541,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int polyset(int j, struct disprm *dis)
 
@@ -1476,7 +1556,7 @@ int polyset(int j, struct disprm *dis)
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
@@ -1484,7 +1564,7 @@ int polyset(int j, struct disprm *dis)
   sprintf(id, "Polynomial on axis %d", j+1);
 
 
-  /* Find the number of auxiliary variables and terms. */
+  // Find the number of auxiliary variables and terms.
   K = 0;
   M = 0;
   keyp = dis->dp;
@@ -1520,31 +1600,31 @@ int polyset(int j, struct disprm *dis)
   nTparm = 1 + nVar;
   ndparm = K*nKparm + M*nTparm;
 
-/* These iparm indices are specific to Polynomial.                          */
-#define I_NIDX    3	/* No. of indexes in iparm[].                       */
-#define I_LENDP   4	/* Full (allocated) length of dparm[].              */
-#define I_K       5	/* No. of auxiliary variables.                      */
-#define I_M       6	/* No. of terms in the polynomial.                  */
-#define I_NKPARM  7	/* No. of parameters used to define each auxiliary. */
-#define I_NTPARM  8	/* No. of parameters used to define each term.      */
-#define I_NVAR    9	/* No. of independent + auxiliary variables.        */
-#define I_MNVAR  10	/* No. of powers (exponents) in the polynomial.     */
-#define I_DPOLY  11	/* dparm offset for polynomial coefficients.        */
-#define I_DAUX   12	/* dparm offset for auxiliary coefficients.         */
-#define I_DVPOW  13	/* dparm offset for integral powers of variables.   */
-#define I_MAXPOW 14	/* iparm offset for max powers.                     */
-#define I_DPOFF  15	/* iparm offset for dparm offsets.                  */
-#define I_FLAGS  16	/* iparm offset for flags.                          */
-#define I_IPOW   17	/* iparm offset for integral powers.                */
+// These iparm indices are specific to Polynomial.
+#define I_NIDX    3	// No. of indexes in iparm[].
+#define I_LENDP   4	// Full (allocated) length of dparm[].
+#define I_K       5	// No. of auxiliary variables.
+#define I_M       6	// No. of terms in the polynomial.
+#define I_NKPARM  7	// No. of parameters used to define each auxiliary.
+#define I_NTPARM  8	// No. of parameters used to define each term.
+#define I_NVAR    9	// No. of independent + auxiliary variables.
+#define I_MNVAR  10	// No. of powers (exponents) in the polynomial.
+#define I_DPOLY  11	// dparm offset for polynomial coefficients.
+#define I_DAUX   12	// dparm offset for auxiliary coefficients.
+#define I_DVPOW  13	// dparm offset for integral powers of variables.
+#define I_MAXPOW 14	// iparm offset for max powers.
+#define I_DPOFF  15	// iparm offset for dparm offsets.
+#define I_FLAGS  16	// iparm offset for flags.
+#define I_IPOW   17	// iparm offset for integral powers.
 #define I_NPOLY  18
 
-  /* Add extra for handling integer exponents.  See "Optimization" below. */
+  // Add extra for handling integer exponents.  See "Optimization" below.
   niparm = I_NPOLY + (2 + 2*M)*nVar;
 
-  /* Add extra memory for temporaries. */
+  // Add extra memory for temporaries.
   lendp = ndparm + K;
 
-  /* Allocate memory for the indexes and parameter array. */
+  // Allocate memory for the indexes and parameter array.
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -1553,12 +1633,12 @@ int polyset(int j, struct disprm *dis)
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
 
-  /* These help a bit to stop the code from turning into hieroglyphics. */
+  // These help a bit to stop the code from turning into hieroglyphics.
   iparm = dis->iparm[j];
   dparm = dis->dparm[j];
 
 
-  /* Record the indexing parameters.  The first three are more widely used. */
+  // Record the indexing parameters.  The first three are more widely used.
   iparm[I_DTYPE]  = DIS_POLYNOMIAL;
   iparm[I_NIPARM] = niparm;
   iparm[I_NDPARM] = ndparm;
@@ -1579,7 +1659,7 @@ int polyset(int j, struct disprm *dis)
   iparm[I_FLAGS]  = iparm[I_DPOFF]  + nVar;
   iparm[I_IPOW]   = iparm[I_FLAGS]  + M*nVar;
 
-  /* Set default values of POWER for the auxiliary variables. */
+  // Set default values of POWER for the auxiliary variables.
   dptr = dparm + (1 + Nhat);
   for (k = 0; k < K; k++) {
     for (jhat = 0; jhat <= Nhat; jhat++) {
@@ -1588,24 +1668,24 @@ int polyset(int j, struct disprm *dis)
     dptr += nKparm;
   }
 
-  /* Set default values of COEFF for the independent variables. */
+  // Set default values of COEFF for the independent variables.
   dptr = dparm + iparm[I_DPOLY];
   for (m = 0; m < M; m++) {
     *dptr = 1.0;
     dptr += nTparm;
   }
 
-  /* Extract parameter values from DPja or DQia. */
+  // Extract parameter values from DPja or DQia.
   k = m = 0;
   keyp = dis->dp;
   for (idp = 0; idp < dis->ndp; idp++, keyp++) {
-    /* N.B. keyp->j is 1-relative, but j is 0-relative. */
+    // N.B. keyp->j is 1-relative, but j is 0-relative.
     if (keyp->j-1 != j) continue;
 
     fp = strchr(keyp->field, '.') + 1;
 
     if (strncmp(fp, "AUX.", 4) == 0) {
-      /* N.B. k here is 1-relative. */
+      // N.B. k here is 1-relative.
       fp += 4;
       sscanf(fp, "%d", &k);
       if (k < 1 || K < k) {
@@ -1633,7 +1713,7 @@ int polyset(int j, struct disprm *dis)
       fp += 6;
       sscanf(fp, "%d", &jhat);
       if (jhat < 0 || naxis < jhat) {
-        /* N.B. jhat == 0 is ok. */
+        // N.B. jhat == 0 is ok.
         return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
         "Invalid axis number (%d) for %s: %s", jhat, id, keyp->field);
       }
@@ -1642,7 +1722,7 @@ int polyset(int j, struct disprm *dis)
       dparm[i] = dpkeyd(keyp);
 
     } else if (strncmp(fp, "TERM.", 5) == 0) {
-      /* N.B. m here is 1-relative. */
+      // N.B. m here is 1-relative.
       fp += 5;
       sscanf(fp, "%d", &m);
       if (m < 1 || M < m) {
@@ -1661,7 +1741,7 @@ int polyset(int j, struct disprm *dis)
         dparm[i] = dpkeyd(keyp);
 
       } else if (strncmp(fp, "VAR.", 4) == 0) {
-        /* N.B. jhat here is 1-relative. */
+        // N.B. jhat here is 1-relative.
         fp += 4;
         sscanf(fp, "%d", &jhat);
         if (jhat < 1 || naxis < jhat) {
@@ -1674,7 +1754,7 @@ int polyset(int j, struct disprm *dis)
         dparm[i] = power;
 
       } else if (strncmp(fp, "AUX.", 4) == 0) {
-        /* N.B. k here is 1-relative. */
+        // N.B. k here is 1-relative.
         fp += 4;
         sscanf(fp, "%d", &k);
         if (k < 1 || K < k) {
@@ -1704,16 +1784,16 @@ int polyset(int j, struct disprm *dis)
   }
 
 
-  /* Optimization: when the power is integral, it is faster to multiply     */
-  /* ------------  repeatedly than call pow().  iparm[] is constructed as   */
-  /*               follows:                                                 */
-  /*  I_NPOLY indexing parameters, as above,                                */
-  /*     nVar elements record the largest integral power for each variable, */
-  /*     nVar elements record offsets into dparm for each variable,         */
-  /*   M*nVar flags to signal whether the power is integral,                */
-  /*   M*nVar integral powers.                                              */
+  // Optimization: when the power is integral, it is faster to multiply
+  // ------------  repeatedly than call pow().  iparm[] is constructed as
+  //               follows:
+  //  I_NPOLY indexing parameters, as above,
+  //     nVar elements record the largest integral power for each variable,
+  //     nVar elements record offsets into dparm for each variable,
+  //   M*nVar flags to signal whether the power is integral,
+  //   M*nVar integral powers.
   for (ivar = 0; ivar < nVar; ivar++) {
-    /* Want at least the first degree power for all variables. */
+    // Want at least the first degree power for all variables.
     i = iparm[I_MAXPOW] + ivar;
     iparm[i] = 1;
   }
@@ -1723,10 +1803,10 @@ int polyset(int j, struct disprm *dis)
       i = iparm[I_DPOLY] + m*nTparm + 1 + ivar;
       power = dparm[i];
 
-      /* Is it integral?  (Positive, negative, or zero.) */
+      // Is it integral?  (Positive, negative, or zero.)
       ipow = (int)power;
       if (power == (double)ipow) {
-        /* Signal that the power is integral. */
+        // Signal that the power is integral.
         i = iparm[I_FLAGS] + m*nVar + ivar;
         if (ipow == 0) {
           iparm[i] = 3;
@@ -1734,12 +1814,12 @@ int polyset(int j, struct disprm *dis)
           iparm[i] = 1;
         }
 
-        /* The integral power itself. */
+        // The integral power itself.
         i = iparm[I_IPOW] + m*nVar + ivar;
         iparm[i] = ipow;
       }
 
-      /* Record the largest integral power for each variable. */
+      // Record the largest integral power for each variable.
       i = iparm[I_MAXPOW] + ivar;
       if (iparm[i] < abs(ipow)) {
         iparm[i] = abs(ipow);
@@ -1747,10 +1827,10 @@ int polyset(int j, struct disprm *dis)
     }
   }
 
-  /* How many of all powers of each variable will there be? */
+  // How many of all powers of each variable will there be?
   npow = 0;
   for (ivar = 0; ivar < nVar; ivar++) {
-    /* Offset into dparm. */
+    // Offset into dparm.
     i = iparm[I_DPOFF] + ivar;
     iparm[i] = lendp + npow;
 
@@ -1758,7 +1838,7 @@ int polyset(int j, struct disprm *dis)
     npow += iparm[i];
   }
 
-  /* Expand dparm to store the extra powers. */
+  // Expand dparm to store the extra powers.
   if (npow) {
     lendp += npow;
     iparm[I_LENDP] = lendp;
@@ -1767,12 +1847,12 @@ int polyset(int j, struct disprm *dis)
     }
   }
 
-  /* No specialist de-distortions. */
+  // No specialist de-distortions.
   dis->disp2x[j] = dispoly;
   dis->disx2p[j] = 0x0;
 
-  /* Translate Polynomial to TPD if possible, it's much faster.  */
-  /* However don't do it if the name was given as "Polynomial*". */
+  // Translate Polynomial to TPD if possible, it's much faster.
+  // However don't do it if the name was given as "Polynomial*".
   if (strcmp(dis->dtype[j], "Polynomial") == 0) {
     pol2tpd(j, dis);
   }
@@ -1780,7 +1860,7 @@ int polyset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpdset(int j, struct disprm *dis)
 
@@ -1799,14 +1879,14 @@ int tpdset(int j, struct disprm *dis)
   sprintf(id, "TPD on axis %d", j+1);
 
 
-  /* TPD distortion. */
+  // TPD distortion.
   if (dis->Nhat[j] < 1 || 2 < dis->Nhat[j]) {
     return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
       "Axis map for %s must contain 1 or 2 entries, not %d", id,
       dis->Nhat[j]);
   }
 
-  /* Find the number of parameters. */
+  // Find the number of parameters.
   ncoeff[0] = 0;
   ncoeff[1] = 0;
   doaux     = 0;
@@ -1823,7 +1903,7 @@ int tpdset(int j, struct disprm *dis)
         idis = 0;
 
       } else if (strncmp(fp, "REV.", 4) == 0) {
-        /* TPD may provide a polynomial approximation for the inverse. */
+        // TPD may provide a polynomial approximation for the inverse.
         idis = 1;
 
       } else {
@@ -1835,7 +1915,7 @@ int tpdset(int j, struct disprm *dis)
       if (0 <= k && k <= 59) {
         if (ncoeff[idis] < k+1) ncoeff[idis] = k+1;
 
-        /* Any radial terms? */
+        // Any radial terms?
         if (k == 3 || k == 11 || k == 23 || k == 39 || k == 59) {
           doradial = 1;
         }
@@ -1846,7 +1926,7 @@ int tpdset(int j, struct disprm *dis)
       }
 
     } else if (strncmp(fp, "AUX.", 4) == 0) {
-      /* Flag usage of auxiliary variables. */
+      // Flag usage of auxiliary variables.
       doaux = 1;
 
     } else if (strcmp(fp, "DOCORR") &&
@@ -1864,43 +1944,43 @@ int tpdset(int j, struct disprm *dis)
   for (idis = 0; idis < 2; idis++) {
     if (ncoeff[idis] <= 4) {
       if (idis) {
-        /* No inverse polynomial. */
+        // No inverse polynomial.
         break;
       }
 
-      /* First degree. */
+      // First degree.
       ncoeff[idis] = 4;
       distpd[idis] = tpd1;
     } else if (ncoeff[idis] <= 7) {
-      /* Second degree. */
+      // Second degree.
       ncoeff[idis] = 7;
       distpd[idis] = tpd2;
     } else if (ncoeff[idis] <= 12) {
-      /* Third degree. */
+      // Third degree.
       ncoeff[idis] = 12;
       distpd[idis] = tpd3;
     } else if (ncoeff[idis] <= 17) {
-      /* Fourth degree. */
+      // Fourth degree.
       ncoeff[idis] = 17;
       distpd[idis] = tpd4;
     } else if (ncoeff[idis] <= 24) {
-      /* Fifth degree. */
+      // Fifth degree.
       ncoeff[idis] = 24;
       distpd[idis] = tpd5;
     } else if (ncoeff[idis] <= 31) {
-      /* Sixth degree. */
+      // Sixth degree.
       ncoeff[idis] = 31;
       distpd[idis] = tpd6;
     } else if (ncoeff[idis] <= 40) {
-      /* Seventh degree. */
+      // Seventh degree.
       ncoeff[idis] = 40;
       distpd[idis] = tpd7;
     } else if (ncoeff[idis] <= 49) {
-      /* Eighth degree. */
+      // Eighth degree.
       ncoeff[idis] = 49;
       distpd[idis] = tpd8;
     } else if (ncoeff[idis] <= 60) {
-      /* Ninth degree. */
+      // Ninth degree.
       ncoeff[idis] = 60;
       distpd[idis] = tpd9;
     } else {
@@ -1909,20 +1989,20 @@ int tpdset(int j, struct disprm *dis)
     }
   }
 
-  /* disx2p() only uses the inverse TPD, if present, to provide a better */
-  /* zeroth approximation. */
+  // disx2p() only uses the inverse TPD, if present, to provide a better
+  // zeroth approximation.
   dis->disp2x[j] = distpd[0];
   dis->disx2p[j] = distpd[1];
 
 
-/* These iparm indices are specific to TPD.                      */
-#define I_TPDNCO  3	/* No. of TPD coefficients, forward...   */
-#define I_TPDINV  4	/* ...and inverse.                       */
-#define I_TPDAUX  5	/* True if auxiliary variables are used. */
-#define I_TPDRAD  6	/* True if the radial variable is used.  */
+// These iparm indices are specific to TPD (matching definitions in wcshdr.c).
+#define I_TPDNCO  3	// No. of TPD coefficients, forward...
+#define I_TPDINV  4	// ...and inverse.
+#define I_TPDAUX  5	// True if auxiliary variables are used.
+#define I_TPDRAD  6	// True if the radial variable is used.
 #define I_NTPD    7
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -1930,28 +2010,28 @@ int tpdset(int j, struct disprm *dis)
 
   ndparm = (doaux?6:0) + ncoeff[0] + ncoeff[1];
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   dis->iparm[j][I_DTYPE]  = DIS_TPD;
   dis->iparm[j][I_NIPARM] = niparm;
   dis->iparm[j][I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   dis->iparm[j][I_TPDNCO] = ncoeff[0];
   dis->iparm[j][I_TPDINV] = ncoeff[1];
 
-  /* Flag for presence of auxiliary variables. */
+  // Flag for presence of auxiliary variables.
   dis->iparm[j][I_TPDAUX] = doaux;
 
-  /* Flag for presence of radial terms. */
+  // Flag for presence of radial terms.
   dis->iparm[j][I_TPDRAD] = doradial;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((dis->dparm[j] = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
 
-  /* Set default auxiliary coefficients. */
+  // Set default auxiliary coefficients.
   if (doaux) {
     dis->dparm[j][1] = 1.0;
     dis->dparm[j][5] = 1.0;
@@ -1964,7 +2044,7 @@ int tpdset(int j, struct disprm *dis)
     fp = strchr(keyp->field, '.') + 1;
 
     if (strncmp(fp, "AUX.", 4) == 0) {
-      /* Auxiliary variables. */
+      // Auxiliary variables.
       fp += 4;
       sscanf(fp, "%d", &k);
       if (k < 1 || 2 < k) {
@@ -2008,7 +2088,7 @@ int tpdset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int pol2tpd(int j, struct disprm *dis)
 
@@ -2031,7 +2111,7 @@ int pol2tpd(int j, struct disprm *dis)
   double *dparm, *dpolp, *tpd_dparm;
   struct wcserr **err;
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
@@ -2039,15 +2119,15 @@ int pol2tpd(int j, struct disprm *dis)
   dparm = dis->dparm[j];
 
 
-  /* Check the number of independent variables, no more than two. */
+  // Check the number of independent variables, no more than two.
   Nhat = dis->Nhat[j];
   if (2 < Nhat) return -1;
 
-  /* Check auxiliaries: only one is allowed... */
+  // Check auxiliaries: only one is allowed...
   K = iparm[I_K];
   if (1 < K) return -1;
   if (K) {
-    /* ...and it must be radial. */
+    // ...and it must be radial.
     if (dparm[0] != 0.0) return -1;
     if (dparm[1] != 1.0) return -1;
     if (dparm[2] != 1.0) return -1;
@@ -2056,14 +2136,14 @@ int pol2tpd(int j, struct disprm *dis)
     if (dparm[5] != 2.0) return -1;
   }
 
-  /* Check powers... */
+  // Check powers...
   iflgp = iparm + iparm[I_FLAGS];
   ipowp = iparm + iparm[I_IPOW];
   degree = 0;
   for (m = 0; m < iparm[I_M]; m++) {
     deg = 0;
     for (jhat = 0; jhat < Nhat; jhat++) {
-      /* ...they must be positive integral. */
+      // ...they must be positive integral.
       if (*iflgp == 0)  return -1;
       if (*ipowp < 0)   return -1;
       deg += *ipowp;
@@ -2071,20 +2151,20 @@ int pol2tpd(int j, struct disprm *dis)
       ipowp++;
     }
 
-    /* The polynomial degree can't be greater than 9. */
+    // The polynomial degree can't be greater than 9.
     if (9 < deg) return -1;
 
     if (K) {
-      /* Likewise for the radial variable. */
+      // Likewise for the radial variable.
       if (*iflgp == 0)  return -1;
       if (*ipowp) {
         if (*ipowp < 0) return -1;
         if (9 < *ipowp) return -1;
 
-        /* Can't mix the radial and other terms. */
+        // Can't mix the radial and other terms.
         if (deg)        return -1;
 
-        /* Can't have even powers of the radial variable. */
+        // Can't have even powers of the radial variable.
         deg = *ipowp;
         if (!(deg%2))   return -1;
       }
@@ -2096,7 +2176,7 @@ int pol2tpd(int j, struct disprm *dis)
   }
 
 
-  /* OK, it ticks all the boxes.  Now translate it. */
+  // OK, it ticks all the boxes.  Now translate it.
   ndparm = 0;
   if (degree == 1) {
     ndparm = 4;
@@ -2127,32 +2207,32 @@ int pol2tpd(int j, struct disprm *dis)
     dis->disp2x[j] = tpd9;
   }
 
-  /* No specialist de-distortions. */
+  // No specialist de-distortions.
   dis->disx2p[j] = 0x0;
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((tpd_iparm = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   tpd_iparm[I_DTYPE]  = DIS_TPD;
   tpd_iparm[I_NIPARM] = niparm;
   tpd_iparm[I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   tpd_iparm[I_TPDNCO] = ndparm;
   tpd_iparm[I_TPDINV] = 0;
 
-  /* No auxiliary variables yet. */
+  // No auxiliary variables yet.
   tpd_iparm[I_TPDAUX] = 0;
 
-  /* Flag for presence of radial terms. */
+  // Flag for presence of radial terms.
   tpd_iparm[I_TPDRAD] = K;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((tpd_dparm = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -2161,7 +2241,7 @@ int pol2tpd(int j, struct disprm *dis)
   dpolp = dparm + iparm[I_DPOLY];
   for (m = 0; m < iparm[I_M]; m++) {
     if (K && ipowp[Nhat]) {
-      /* The radial variable. */
+      // The radial variable.
       switch (ipowp[Nhat]) {
       case 1:
         tpd_dparm[3]  = *dpolp;
@@ -2181,7 +2261,7 @@ int pol2tpd(int j, struct disprm *dis)
       }
 
     } else {
-      /* The independent variables. */
+      // The independent variables.
       p[0] = p[1] = 0;
       for (jhat = 0; jhat < Nhat; jhat++) {
         p[jhat] = ipowp[jhat];
@@ -2197,7 +2277,7 @@ int pol2tpd(int j, struct disprm *dis)
   }
 
 
-  /* Switch from Polynomial to TPD. */
+  // Switch from Polynomial to TPD.
   free(iparm);
   free(dparm);
   dis->iparm[j] = tpd_iparm;
@@ -2206,7 +2286,7 @@ int pol2tpd(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpvset(int j, struct disprm *dis)
 
@@ -2219,14 +2299,15 @@ int tpvset(int j, struct disprm *dis)
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
-  /* TPV "projection". */
+  // TPV "projection".
   sprintf(id, "TPV on axis %d", j+1);
 
-  /* TPV computes corrected coordinates. */
+  // TPV is a sequent distortion, applied to intermediate world coordinates
+  // (normally used with CDi_ja).  It computes corrected coordinates directly.
   dis->docorr[j] = 0;
 
   if (dis->Nhat[j] != 2) {
@@ -2234,7 +2315,7 @@ int tpvset(int j, struct disprm *dis)
       "Axis map for %s must contain 2 entries, not %d", id, dis->Nhat[j]);
   }
 
-  /* Find the number of parameters. */
+  // Find the number of parameters.
   ndparm   = 0;
   doradial = 0;
   keyp = dis->dp;
@@ -2248,7 +2329,7 @@ int tpvset(int j, struct disprm *dis)
       if (0 <= k && k <= 39) {
         if (ndparm < k+1) ndparm = k+1;
 
-        /* Any radial terms? */
+        // Any radial terms?
         if (k == 3 || k == 11 || k == 23 || k == 39 || k == 59) {
           doradial = 1;
         }
@@ -2267,67 +2348,67 @@ int tpvset(int j, struct disprm *dis)
     }
   }
 
-  /* TPD is going to do the dirty work. */
+  // TPD is going to do the dirty work.
   if (ndparm <= 4) {
-    /* First degree. */
+    // First degree.
     ndparm = 4;
     dis->disp2x[j] = tpd1;
   } else if (ndparm <= 7) {
-    /* Second degree. */
+    // Second degree.
     ndparm = 7;
     dis->disp2x[j] = tpd2;
   } else if (ndparm <= 12) {
-    /* Third degree. */
+    // Third degree.
     ndparm = 12;
     dis->disp2x[j] = tpd3;
   } else if (ndparm <= 17) {
-    /* Fourth degree. */
+    // Fourth degree.
     ndparm = 17;
     dis->disp2x[j] = tpd4;
   } else if (ndparm <= 24) {
-    /* Fifth degree. */
+    // Fifth degree.
     ndparm = 24;
     dis->disp2x[j] = tpd5;
   } else if (ndparm <= 31) {
-    /* Sixth degree. */
+    // Sixth degree.
     ndparm = 31;
     dis->disp2x[j] = tpd6;
   } else if (ndparm <= 40) {
-    /* Seventh degree. */
+    // Seventh degree.
     ndparm = 40;
     dis->disp2x[j] = tpd7;
   } else {
-    /* Could go to ninth degree, but that wouldn't be legit. */
+    // Could go to ninth degree, but that wouldn't be legit.
     return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
       "Invalid number of parameters (%d) for %s", ndparm, id);
   }
 
-  /* No specialist de-distortions. */
+  // No specialist de-distortions.
   dis->disx2p[j] = 0x0;
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   dis->iparm[j][I_DTYPE]  = DIS_TPD;
   dis->iparm[j][I_NIPARM] = niparm;
   dis->iparm[j][I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   dis->iparm[j][I_TPDNCO] = ndparm;
   dis->iparm[j][I_TPDINV] = 0;
 
-  /* TPV never needs auxiliary variables. */
+  // TPV never needs auxiliary variables.
   dis->iparm[j][I_TPDAUX] = 0;
 
-  /* Flag for presence of radial terms. */
+  // Flag for presence of radial terms.
   dis->iparm[j][I_TPDRAD] = doradial;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((dis->dparm[j] = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -2338,7 +2419,7 @@ int tpvset(int j, struct disprm *dis)
 
     fp = strchr(keyp->field, '.') + 1;
 
-    /* One-to-one correspondence between TPV and TPD coefficients. */
+    // One-to-one correspondence between TPV and TPD coefficients.
     if (strncmp(fp, "TPV.", 4) == 0) {
       sscanf(fp+4, "%d", &k);
       dis->dparm[j][k] = dpkeyd(keyp);
@@ -2348,7 +2429,7 @@ int tpvset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sipset(int j, struct disprm *dis)
 
@@ -2373,15 +2454,15 @@ int sipset(int j, struct disprm *dis)
   int (*(distpd[2]))(DISP2X_ARGS);
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
-  /* Simple Imaging Polynomial. */
+  // Simple Imaging Polynomial.
   sprintf(id, "SIP on axis %d", j+1);
 
 
-  /* SIP computes an additive correction. */
+  // SIP is a prior distortion that computes an additive correction.
   dis->docorr[j] = 1;
 
   if (dis->Nhat[j] != 2) {
@@ -2389,7 +2470,7 @@ int sipset(int j, struct disprm *dis)
       "Axis map for %s must contain 2 entries, not %d", id, dis->Nhat[j]);
   }
 
-  /* Find the polynomial degree, at least 1 for the forward function. */
+  // Find the polynomial degree, at least 1 for the forward function.
   degree[0] =  1;
   degree[1] = -1;
   keyp = dis->dp;
@@ -2404,7 +2485,7 @@ int sipset(int j, struct disprm *dis)
         idis = 0;
 
       } else if (strncmp(fp, "REV.", 4) == 0) {
-        /* SIP uses a polynomial approximation for the inverse. */
+        // SIP uses a polynomial approximation for the inverse.
         idis = 1;
 
       } else {
@@ -2433,7 +2514,7 @@ int sipset(int j, struct disprm *dis)
 
   if (degree[1] == 0 ) degree[1] = 1;
 
-  /* TPD is going to do the dirty work. */
+  // TPD is going to do the dirty work.
   distpd[0] = 0x0;
   distpd[1] = 0x0;
   for (idis = 0; idis < 2; idis++) {
@@ -2468,13 +2549,13 @@ int sipset(int j, struct disprm *dis)
     }
   }
 
-  /* SIP uses a polynomial approximation to the inverse.  It's not very    */
-  /* accurate but may provide disx2p() with a better zeroth approximation. */
+  // SIP uses a polynomial approximation to the inverse.  It's not very
+  // accurate but may provide disx2p() with a better zeroth approximation.
   dis->disp2x[j] = distpd[0];
   dis->disx2p[j] = distpd[1];
 
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -2482,23 +2563,23 @@ int sipset(int j, struct disprm *dis)
 
   ndparm = ncoeff[0] + ncoeff[1];
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   dis->iparm[j][I_DTYPE]  = DIS_TPD;
   dis->iparm[j][I_NIPARM] = niparm;
   dis->iparm[j][I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   dis->iparm[j][I_TPDNCO] = ncoeff[0];
   dis->iparm[j][I_TPDINV] = ncoeff[1];
 
-  /* SIP never needs auxiliary variables. */
+  // SIP never needs auxiliary variables.
   dis->iparm[j][I_TPDAUX] = 0;
 
-  /* SIP never needs the radial terms. */
+  // SIP never needs the radial terms.
   dis->iparm[j][I_TPDRAD] = 0;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((dis->dparm[j] = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -2519,7 +2600,7 @@ int sipset(int j, struct disprm *dis)
 
       sscanf(fp+4, "%d_%d", &p, &q);
 
-      /* Map to TPD coefficient number. */
+      // Map to TPD coefficient number.
       idis += map[p][q];
 
       dis->dparm[j][idis] = dpkeyd(keyp);
@@ -2530,7 +2611,7 @@ int sipset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int dssset(int j, struct disprm *dis)
 
@@ -2544,15 +2625,16 @@ int dssset(int j, struct disprm *dis)
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
-  /* Digitized Sky Survey. */
+  // Digitized Sky Survey.
   sprintf(id, "DSS on axis %d", j+1);
 
 
-  /* DSS computes corrected coordinates. */
+  // DSS is translated into a sequent distortion, applied to intermediate
+  // pixel coordinates.  It computes corrected coordinates directly.
   dis->docorr[j] = 0;
 
   if (dis->Nhat[j] != 2) {
@@ -2560,15 +2642,15 @@ int dssset(int j, struct disprm *dis)
       "Axis map for %s must contain 2 entries, not %d", id, dis->Nhat[j]);
   }
 
-  /* Safe to assume the polynomial degree is 5 (or less). */
+  // Safe to assume the polynomial degree is 5 (or less).
   ncoeff = 24;
   dis->disp2x[j] = tpd5;
 
-  /* No specialist de-distortions. */
+  // No specialist de-distortions.
   dis->disx2p[j] = 0x0;
 
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -2576,29 +2658,29 @@ int dssset(int j, struct disprm *dis)
 
   ndparm = 6 + ncoeff;
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   dis->iparm[j][I_DTYPE]  = DIS_TPD;
   dis->iparm[j][I_NIPARM] = niparm;
   dis->iparm[j][I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   dis->iparm[j][I_TPDNCO] = ncoeff;
   dis->iparm[j][I_TPDINV] = 0;
 
-  /* DSS always needs auxiliary variables. */
+  // DSS always needs auxiliary variables.
   dis->iparm[j][I_TPDAUX] = 1;
 
-  /* DSS never needs the radial terms. */
+  // DSS never needs the radial terms.
   dis->iparm[j][I_TPDRAD] = 0;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((dis->dparm[j] = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
 
-  /* This translation follows WCS Paper IV, Sect. 5.2 using the same */
-  /* variable names.  Find A1, A2, A3, B1, B2, and B3.               */
+  // This translation follows WCS Paper IV, Sect. 5.2 using the same
+  // variable names.  Find A1, A2, A3, B1, B2, and B3.
   A1 = A2 = A3 = 0.0;
   B1 = B2 = B3 = 0.0;
   keyp = dis->dp;
@@ -2639,7 +2721,7 @@ int dssset(int j, struct disprm *dis)
       "Coefficient scale for %s is zero.", id);
   }
 
-  /* Coefficients for the auxiliary variables. */
+  // Coefficients for the auxiliary variables.
   dparm = dis->dparm[j];
   if (j == 0) {
     dparm[0] =  X0;
@@ -2649,7 +2731,7 @@ int dssset(int j, struct disprm *dis)
     dparm[4] =  B2/S;
     dparm[5] =  A1/S;
 
-    /* Change the sign of S for scaling the A coefficients. */
+    // Change the sign of S for scaling the A coefficients.
     S *= -1.0;
 
   } else {
@@ -2661,7 +2743,7 @@ int dssset(int j, struct disprm *dis)
     dparm[5] = -A2/S;
   }
 
-  /* Translate DSS coefficients to TPD. */
+  // Translate DSS coefficients to TPD.
   dparm += 6;
   degree = 3;
   keyp = dis->dp;
@@ -2671,13 +2753,13 @@ int dssset(int j, struct disprm *dis)
     fp = strchr(keyp->field, '.') + 1;
 
     if (strncmp(fp, "DSS.AMD.", 8) == 0) {
-      /* Skip zero coefficients. */
+      // Skip zero coefficients.
       if ((coeff = dpkeyd(keyp)) == 0.0) continue;
 
       fp += 8;
       sscanf(fp, "%d", &m);
 
-      /* Apply the coefficient scale factor. */
+      // Apply the coefficient scale factor.
       coeff /= S;
 
       if (m == 1) {
@@ -2725,8 +2807,8 @@ int dssset(int j, struct disprm *dis)
     }
   }
 
-  /* The DSS polynomial doesn't have 4th degree terms, and the 5th degree
-     coefficient is often zero. */
+  // The DSS polynomial doesn't have 4th degree terms, and the 5th degree
+  // coefficient is often zero.
   if (degree == 3) {
     dis->iparm[j][I_TPDNCO] = 12;
     dis->disp2x[j] = tpd3;
@@ -2735,7 +2817,7 @@ int dssset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define CHEBYSHEV 1
 #define LEGENDRE  2
@@ -2766,15 +2848,16 @@ int watset(int j, struct disprm *dis)
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
-  /* WAT (TNX or ZPX) Polynomial. */
+  // WAT (TNX or ZPX) Polynomial.
   sprintf(id, "WAT (%s) on axis %d", dis->dtype[0]+4, j+1);
 
 
-  /* WAT computes an additive correction. */
+  // WAT is a sequent distortion, applied to intermediate world coordinates
+  // (normally used with CDi_ja).  It computes an additive correction.
   dis->docorr[j] = 1;
 
   if (dis->Nhat[j] != 2) {
@@ -2782,7 +2865,7 @@ int watset(int j, struct disprm *dis)
       "Axis map for %s must contain 2 entries, not %d", id, dis->Nhat[j]);
   }
 
-  /* Find the polynomial degree (at least 1), kind, and domain. */
+  // Find the polynomial degree (at least 1), kind, and domain.
   degree = 1;
   kind = 0;
   xmin = xmax = 0.0;
@@ -2836,51 +2919,51 @@ int watset(int j, struct disprm *dis)
 
   doaux = (kind == 1 || kind == 2);
 
-  /* TPD is going to do the dirty work. */
+  // TPD is going to do the dirty work.
   ncoeff = 0;
   if (degree == 1) {
-    /* First degree. */
+    // First degree.
     ncoeff = 4;
     dis->disp2x[j] = tpd1;
   } else if (degree == 2) {
-    /* Second degree. */
+    // Second degree.
     ncoeff = 7;
     dis->disp2x[j] = tpd2;
   } else if (degree == 3) {
-    /* Third degree. */
+    // Third degree.
     ncoeff = 12;
     dis->disp2x[j] = tpd3;
   } else if (degree == 4) {
-    /* Fourth degree. */
+    // Fourth degree.
     ncoeff = 17;
     dis->disp2x[j] = tpd4;
   } else if (degree == 5) {
-    /* Fifth degree. */
+    // Fifth degree.
     ncoeff = 24;
     dis->disp2x[j] = tpd5;
   } else if (degree == 6) {
-    /* Sixth degree. */
+    // Sixth degree.
     ncoeff = 31;
     dis->disp2x[j] = tpd6;
   } else if (degree == 7) {
-    /* Seventh degree. */
+    // Seventh degree.
     ncoeff = 40;
     dis->disp2x[j] = tpd7;
   } else if (degree == 8) {
-    /* Eighth degree. */
+    // Eighth degree.
     ncoeff = 49;
     dis->disp2x[j] = tpd8;
   } else if (degree == 9) {
-    /* Ninth degree. */
+    // Ninth degree.
     ncoeff = 60;
     dis->disp2x[j] = tpd9;
   }
 
-  /* No specialist de-distortions. */
+  // No specialist de-distortions.
   dis->disx2p[j] = 0x0;
 
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -2890,23 +2973,23 @@ int watset(int j, struct disprm *dis)
 
   ndparm = 6 + ncoeff;
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   iparm[I_DTYPE]  = DIS_TPD;
   iparm[I_NIPARM] = niparm;
   iparm[I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   iparm[I_TPDNCO] = ncoeff;
   iparm[I_TPDINV] = 0;
 
-  /* The Chebyshev and Legendre polynomials use auxiliary variables. */
+  // The Chebyshev and Legendre polynomials use auxiliary variables.
   iparm[I_TPDAUX] = doaux;
 
-  /* WAT never needs the radial terms. */
+  // WAT never needs the radial terms.
   iparm[I_TPDRAD] = 0;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((dis->dparm[j] = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -2914,7 +2997,7 @@ int watset(int j, struct disprm *dis)
   dparm = dis->dparm[j];
 
 
-  /* Coefficients for the auxiliary variables. */
+  // Coefficients for the auxiliary variables.
   if (doaux) {
     x0 = (xmax + xmin)/2.0;
     dx = (xmax - xmin)/2.0;
@@ -2942,7 +3025,7 @@ int watset(int j, struct disprm *dis)
   }
 
 
-  /* Unpack the polynomial coefficients. */
+  // Unpack the polynomial coefficients.
   keyp = dis->dp;
   for (idp = 0; idp < dis->ndp; idp++, keyp++) {
     if (keyp->j-1 != j) continue;
@@ -2957,13 +3040,13 @@ int watset(int j, struct disprm *dis)
       sscanf(fp, "%d_%d", &m, &n);
 
       if (kind == MONOMIAL) {
-        /* Monomial coefficient, maps simply to TPD coefficient number. */
+        // Monomial coefficient, maps simply to TPD coefficient number.
         idis = map[m][n];
         dparm[idis] = dpkeyd(keyp);
 
       } else {
-        /* Coefficient of the product of two Chebyshev or two Legendre */
-        /* polynomials.  Find the corresponding monomial coefficients. */
+        // Coefficient of the product of two Chebyshev or two Legendre
+        // polynomials.  Find the corresponding monomial coefficients.
         coeff = dpkeyd(keyp);
 
         cheleg(kind, m, n, coeffm, coeffn);
@@ -2984,9 +3067,9 @@ int watset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
-/* Compute the coefficients of Chebyshev or Legendre polynomials of degree  */
-/* m and n.                                                                 */
+//----------------------------------------------------------------------------
+// Compute the coefficients of Chebyshev or Legendre polynomials of degree
+// m and n.
 
 int cheleg(int kind, int m, int n, double coeffm[], double coeffn[])
 
@@ -2996,7 +3079,7 @@ int cheleg(int kind, int m, int n, doubl
 
   N = (m > n) ? m : n;
 
-  /* Allocate work arrays. */
+  // Allocate work arrays.
   coeff[0] = calloc(3*(N+1), sizeof(double));
   coeff[1] = coeff[0] + (N+1);
   coeff[2] = coeff[1] + (N+1);
@@ -3011,7 +3094,7 @@ int cheleg(int kind, int m, int n, doubl
       coeff[1][1] = 1.0;
 
     } else {
-      /* Cyclic buffer indices. */
+      // Cyclic buffer indices.
       j1 = (j-1)%3;
       j2 = (j-2)%3;
 
@@ -3038,7 +3121,7 @@ int cheleg(int kind, int m, int n, doubl
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int dispoly(
   int dummy,
@@ -3054,10 +3137,10 @@ int dispoly(
   const double *cptr, *dpolp, *pptr;
   double *aux, auxp0, *dvarpow, *dpowp, term, var;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
-  /* Check for zeroes. */
+  // Check for zeroes.
   for (jhat = 0; jhat < Nhat; jhat++) {
     if (rawcrd[jhat] == 0.0) {
       *discrd = 0.0;
@@ -3065,10 +3148,10 @@ int dispoly(
     }
   }
 
-  /* Working memory for auxiliaries &c. was allocated at the end of p[]. */
+  // Working memory for auxiliaries &c. was allocated at the end of p[].
   aux = (double *)(dparm + iparm[I_DAUX]);
 
-  /* Compute the auxiliary variables. */
+  // Compute the auxiliary variables.
   for (k = 0; k < iparm[I_K]; k++) {
     cptr = dparm + k*iparm[I_NKPARM];
     pptr = cptr + (1+Nhat);
@@ -3082,7 +3165,7 @@ int dispoly(
 
     aux[k] = pow(aux[k], auxp0);
 
-    /* Check for zeroes. */
+    // Check for zeroes.
     if (aux[k] == 0.0) {
       *discrd = 0.0;
       return 0;
@@ -3090,7 +3173,7 @@ int dispoly(
   }
 
 
-  /* Compute all required integral powers of the variables. */
+  // Compute all required integral powers of the variables.
   imaxpow = iparm + iparm[I_MAXPOW];
   dvarpow = (double *)(dparm + iparm[I_DVPOW]);
 
@@ -3112,7 +3195,7 @@ int dispoly(
     }
   }
 
-  /* Loop for each term of the polynomial. */
+  // Loop for each term of the polynomial.
   *discrd = 0.0;
   iflgp = iparm + iparm[I_FLAGS];
   ipowp = iparm + iparm[I_IPOW];
@@ -3120,25 +3203,25 @@ int dispoly(
   for (m = 0; m < iparm[I_M]; m++) {
     term = *(dpolp++);
 
-    /* Loop over all variables. */
+    // Loop over all variables.
     imaxp = imaxpow;
     dpowp = dvarpow - 1;
     for (ivar = 0; ivar < iparm[I_NVAR]; ivar++) {
       if (*iflgp & 2) {
-        /* Nothing (zero power). */
+        // Nothing (zero power).
 
       } else if (*iflgp) {
-        /* Integral power. */
+        // Integral power.
         if (*ipowp < 0) {
-          /* Negative. */
+          // Negative.
           term /= dpowp[*ipowp];
         } else {
-          /* Positive. */
+          // Positive.
           term *= dpowp[*ipowp];
         }
 
       } else {
-        /* Fractional power. */
+        // Fractional power.
         term *= pow(dpowp[0], *dpolp);
       }
 
@@ -3156,7 +3239,7 @@ int dispoly(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd1(
   int inverse,
@@ -3176,7 +3259,7 @@ int tpd1(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3186,14 +3269,14 @@ int tpd1(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* First degree. */
+  // First degree.
   *discrd = p[0] + u*p[1];
 
   if (Nhat == 1) return 0;
 
   *discrd += v*p[2];
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3204,7 +3287,7 @@ int tpd1(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd2(
   int inverse,
@@ -3224,7 +3307,7 @@ int tpd2(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3234,7 +3317,7 @@ int tpd2(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Second degree. */
+  // Second degree.
   *discrd = p[0] + u*(p[1] + u*(p[4]));
 
   if (Nhat == 1) return 0;
@@ -3243,7 +3326,7 @@ int tpd2(
       v*(p[2]  + v*(p[6]))
     + u*(p[5])*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3254,7 +3337,7 @@ int tpd2(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd3(
   int inverse,
@@ -3274,7 +3357,7 @@ int tpd3(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3284,7 +3367,7 @@ int tpd3(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Third degree. */
+  // Third degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7])));
 
   if (Nhat == 1) return 0;
@@ -3294,7 +3377,7 @@ int tpd3(
     + u*(p[5]  + v*(p[9])
     + u*(p[8]))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3305,7 +3388,7 @@ int tpd3(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd4(
   int inverse,
@@ -3325,7 +3408,7 @@ int tpd4(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3335,7 +3418,7 @@ int tpd4(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Fourth degree. */
+  // Fourth degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12]))));
 
   if (Nhat == 1) return 0;
@@ -3346,7 +3429,7 @@ int tpd4(
     + u*(p[8]  + v*(p[14])
     + u*(p[13])))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3357,7 +3440,7 @@ int tpd4(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd5(
   int inverse,
@@ -3377,7 +3460,7 @@ int tpd5(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3387,7 +3470,7 @@ int tpd5(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Fifth degree. */
+  // Fifth degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12] + u*(p[17])))));
 
   if (Nhat == 1) return 0;
@@ -3399,7 +3482,7 @@ int tpd5(
     + u*(p[13] + v*(p[19])
     + u*(p[18]))))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3410,7 +3493,7 @@ int tpd5(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd6(
   int inverse,
@@ -3430,7 +3513,7 @@ int tpd6(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3440,7 +3523,7 @@ int tpd6(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Sixth degree. */
+  // Sixth degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12] + u*(p[17] + u*(p[24]))))));
 
   if (Nhat == 1) return 0;
@@ -3453,7 +3536,7 @@ int tpd6(
     + u*(p[18] + v*(p[26])
     + u*(p[25])))))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3464,7 +3547,7 @@ int tpd6(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd7(
   int inverse,
@@ -3484,7 +3567,7 @@ int tpd7(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3494,7 +3577,7 @@ int tpd7(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Seventh degree. */
+  // Seventh degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12] + u*(p[17] + u*(p[24] + u*(p[31])))))));
 
   if (Nhat == 1) return 0;
@@ -3508,7 +3591,7 @@ int tpd7(
     + u*(p[25] + v*(p[33])
     + u*(p[32]))))))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3519,7 +3602,7 @@ int tpd7(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd8(
   int inverse,
@@ -3539,7 +3622,7 @@ int tpd8(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3549,7 +3632,7 @@ int tpd8(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Eighth degree. */
+  // Eighth degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12] + u*(p[17] + u*(p[24] + u*(p[31] + u*(p[40]))))))));
 
   if (Nhat == 1) return 0;
@@ -3564,7 +3647,7 @@ int tpd8(
     + u*(p[32] + v*(p[42])
     + u*(p[41])))))))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3575,7 +3658,7 @@ int tpd8(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd9(
   int inverse,
@@ -3595,7 +3678,7 @@ int tpd9(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3605,7 +3688,7 @@ int tpd9(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Ninth degree. */
+  // Ninth degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12] + u*(p[17] + u*(p[24] + u*(p[31] + u*(p[40] + u*(p[49])))))))));
 
   if (Nhat == 1) return 0;
@@ -3621,7 +3704,7 @@ int tpd9(
     + u*(p[41] + v*(p[51])
     + u*(p[50]))))))))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
Index: astropy-4.2.1/cextern/wcslib/C/dis.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/dis.h
+++ astropy-4.2.1/cextern/wcslib/C/dis.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: dis.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: dis.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -92,6 +89,10 @@
 * WCSLIB would handle a FITS header containing these keywords, along with
 * CQDISia = 'TPV' and the required DQia.NAXES and DQia.AXIS.ihat keywords.
 *
+* Note that, as defined, TPV assumes that CDi_ja is used to define the linear
+* transformation.  The section on historical idiosyncrasies (below) cautions
+* about translating CDi_ja to PCi_ja plus CDELTia in this case.
+*
 * SIP - Simple Imaging Polynomial:
 * --------------------------------
 * These routines also support the Simple Imaging Polynomial (SIP), whose
@@ -166,6 +167,10 @@
 * the ZPN projection parameters are also encoded in WATi_n, and wcspih()
 * translates these to standard PVi_ma.
 *
+* Note that, as defined, TNX and ZPX assume that CDi_ja is used to define the
+* linear transformation.  The section on historical idiosyncrasies (below)
+* cautions about translating CDi_ja to PCi_ja plus CDELTia in this case.
+*
 * TPD - Template Polynomial Distortion:
 * -------------------------------------
 * The "Template Polynomial Distortion" (TPD) is a superset of the TPV, SIP,
@@ -246,6 +251,12 @@
 * where r = sqrt(xx + yy).  Note that even powers of r are excluded since they
 * can be accomodated by powers of (xx + yy).
 *
+* Note here that "x" refers to the axis to which the distortion function is
+* attached, with "y" being the complementary axis.  So, for example, with
+* longitude on axis 1 and latitude on axis 2, for TPD attached to axis 1, "x"
+* refers to axis 1 and "y" to axis 2.  For TPD attached to axis 2, "x" refers
+* to axis 2, and "y" to axis 1.
+*
 * TPV uses all terms up to 39.  The m in its PVi_ma keywords translates
 * directly to the TPD coefficient number.
 *
@@ -307,6 +318,13 @@
 *
 * where the value corresponds to CRPIXja.
 *
+* Likewise, because TPV, TNX, and ZPX are defined in terms of CDi_ja, the
+* independent variables of the polynomial are intermediate world coordinates
+* rather than intermediate pixel coordinates.  Because sequent distortions
+* are always applied before CDELTia, if CDi_ja is translated to PCi_ja plus
+* CDELTia, then either CDELTia must be unity, or the distortion polynomial
+* coefficients must be adjusted to account for the change of scale.
+*
 * Summary of the dis routines:
 * ----------------------------
 * These routines apply the distortion functions defined by the extension to
@@ -319,7 +337,8 @@
 * dpfill(), dpkeyi(), and dpkeyd() are provided to manage the dpkey struct.
 *
 * disndp(), disini(), disinit(), discpy(), and disfree() are provided to
-* manage the disprm struct, and another, disprt(), prints its contents.
+* manage the disprm struct, dissize() computes its total size including
+* allocated memory, and disprt() prints its contents.
 *
 * disperr() prints the error message(s) (if any) stored in a disprm struct.
 *
@@ -545,6 +564,35 @@
 *                         1: Null disprm pointer passed.
 *
 *
+* dissize() - Compute the size of a disprm struct
+* -----------------------------------------------
+* dissize() computes the full size of a disprm struct, including allocated
+* memory.
+*
+* Given:
+*   dis       const struct disprm*
+*                       Distortion function parameters.
+*
+*                       If NULL, the base size of the struct and the allocated
+*                       size are both set to zero.
+*
+* Returned:
+*   sizes     int[2]    The first element is the base size of the struct as
+*                       returned by sizeof(struct disprm).  The second element
+*                       is the total allocated size, in bytes, assuming that
+*                       the allocation was done by disini().  This figure
+*                       includes memory allocated for members of constituent
+*                       structs, such as disprm::dp.
+*
+*                       It is not an error for the struct not to have been set
+*                       up via tabset(), which normally results in additional
+*                       memory allocation. 
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*
+*
 * disprt() - Print routine for the disprm struct
 * ----------------------------------------------
 * disprt() prints the contents of a disprm struct using wcsprintf().  Mainly
@@ -1010,88 +1058,88 @@ extern "C" {
 extern const char *dis_errmsg[];
 
 enum dis_errmsg_enum {
-  DISERR_SUCCESS      = 0,	/* Success. */
-  DISERR_NULL_POINTER = 1,	/* Null disprm pointer passed. */
-  DISERR_MEMORY       = 2,	/* Memory allocation failed. */
-  DISERR_BAD_PARAM    = 3,	/* Invalid parameter value. */
-  DISERR_DISTORT      = 4,	/* Distortion error. */
-  DISERR_DEDISTORT    = 5	/* De-distortion error. */
+  DISERR_SUCCESS      = 0,	// Success.
+  DISERR_NULL_POINTER = 1,	// Null disprm pointer passed.
+  DISERR_MEMORY       = 2,	// Memory allocation failed.
+  DISERR_BAD_PARAM    = 3,	// Invalid parameter value.
+  DISERR_DISTORT      = 4,	// Distortion error.
+  DISERR_DEDISTORT    = 5	// De-distortion error.
 };
 
-/* For use in declaring distortion function prototypes (= DISX2P_ARGS). */
+// For use in declaring distortion function prototypes (= DISX2P_ARGS).
 #define DISP2X_ARGS int inverse, const int iparm[], const double dparm[], \
 int ncrd, const double rawcrd[], double *discrd
 
-/* For use in declaring de-distortion function prototypes (= DISP2X_ARGS). */
+// For use in declaring de-distortion function prototypes (= DISP2X_ARGS).
 #define DISX2P_ARGS int inverse, const int iparm[], const double dparm[], \
 int ncrd, const double discrd[], double *rawcrd
 
 
-/* Struct used for storing DPja and DQia keyvalues. */
+// Struct used for storing DPja and DQia keyvalues.
 struct dpkey {
-  char field[72];		/* Full record field name (no colon).       */
-  int j;			/* Axis number, as in DPja (1-relative).    */
-  int type;			/* Data type of value.                      */
+  char field[72];		// Full record field name (no colon).
+  int j;			// Axis number, as in DPja (1-relative).
+  int type;			// Data type of value.
   union {
-    int    i;			/* Integer record value.                    */
-    double f;			/* Floating point record value.             */
-  } value;			/* Record value.                            */
+    int    i;			// Integer record value.
+    double f;			// Floating point record value.
+  } value;			// Record value.
 };
 
-/* Size of the dpkey struct in int units, used by the Fortran wrappers. */
+// Size of the dpkey struct in int units, used by the Fortran wrappers.
 #define DPLEN (sizeof(struct dpkey)/sizeof(int))
 
 
 struct disprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  int naxis;			/* The number of pixel coordinate elements, */
-				/* given by NAXIS.                          */
-  char   (*dtype)[72];		/* For each axis, the distortion type.      */
-  int    ndp;			/* Number of DPja or DQia keywords, and the */
-  int    ndpmax;		/* number for which space was allocated.    */
-  struct dpkey *dp;		/* DPja or DQia keyvalues (not both).       */
-  double *maxdis;		/* For each axis, the maximum distortion.   */
-  double totdis;		/* The maximum combined distortion.         */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  int    *docorr;		/* For each axis, the mode of correction.   */
-  int    *Nhat;			/* For each axis, the number of coordinate  */
-				/* axes that form the independent variables */
-				/* of the distortion function.              */
-  int    **axmap;		/* For each axis, the axis mapping array.   */
-  double **offset;		/* For each axis, renormalization offsets.  */
-  double **scale;		/* For each axis, renormalization scales.   */
-  int    **iparm;		/* For each axis, the array of integer      */
-				/* distortion parameters.                   */
-  double **dparm;		/* For each axis, the array of floating     */
-				/* point distortion parameters.             */
-  int    i_naxis;		/* Dimension of the internal arrays.        */
-  int    ndis;			/* The number of distortion functions.      */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  int naxis;			// The number of pixel coordinate elements,
+				// given by NAXIS.
+  char   (*dtype)[72];		// For each axis, the distortion type.
+  int    ndp;			// Number of DPja or DQia keywords, and the
+  int    ndpmax;		// number for which space was allocated.
+  struct dpkey *dp;		// DPja or DQia keyvalues (not both).
+  double *maxdis;		// For each axis, the maximum distortion.
+  double totdis;		// The maximum combined distortion.
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  int    *docorr;		// For each axis, the mode of correction.
+  int    *Nhat;			// For each axis, the number of coordinate
+				// axes that form the independent variables
+				// of the distortion function.
+  int    **axmap;		// For each axis, the axis mapping array.
+  double **offset;		// For each axis, renormalization offsets.
+  double **scale;		// For each axis, renormalization scales.
+  int    **iparm;		// For each axis, the array of integer
+				// distortion parameters.
+  double **dparm;		// For each axis, the array of floating
+				// point distortion parameters.
+  int    i_naxis;		// Dimension of the internal arrays.
+  int    ndis;			// The number of distortion functions.
 
-  /* Error handling, if enabled.                                            */
-  /*------------------------------------------------------------------------*/
+  // Error handling, if enabled.
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private - the remainder are for internal use.                          */
-  /*------------------------------------------------------------------------*/
-  int (**disp2x)(DISP2X_ARGS);	/* For each axis, pointers to the           */
-  int (**disx2p)(DISX2P_ARGS);	/* distortion function and its inverse.     */
+  // Private - the remainder are for internal use.
+  //--------------------------------------------------------------------------
+  int (**disp2x)(DISP2X_ARGS);	// For each axis, pointers to the
+  int (**disx2p)(DISX2P_ARGS);	// distortion function and its inverse.
 
   double *tmpmem;
 
-  int    m_flag, m_naxis;	/* The remainder are for memory management. */
+  int    m_flag, m_naxis;	// The remainder are for memory management.
   char   (*m_dtype)[72];
   struct dpkey *m_dp;
   double *m_maxdis;
 };
 
-/* Size of the disprm struct in int units, used by the Fortran wrappers. */
+// Size of the disprm struct in int units, used by the Fortran wrappers.
 #define DISLEN (sizeof(struct disprm)/sizeof(int))
 
 
@@ -1112,6 +1160,8 @@ int discpy(int alloc, const struct dispr
 
 int disfree(struct disprm *dis);
 
+int dissize(const struct disprm *dis, int sizes[2]);
+
 int disprt(const struct disprm *dis);
 
 int disperr(const struct disprm *dis, const char *prefix);
@@ -1134,4 +1184,4 @@ int diswarp(struct disprm *dis, const do
 }
 #endif
 
-#endif /* WCSLIB_DIS */
+#endif // WCSLIB_DIS
Index: astropy-4.2.1/cextern/wcslib/C/fitshdr.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/fitshdr.h
+++ astropy-4.2.1/cextern/wcslib/C/fitshdr.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: fitshdr.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: fitshdr.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -96,6 +93,7 @@
 *                         1: Null fitskey pointer passed.
 *                         2: Memory allocation failed.
 *                         3: Fatal error returned by Flex parser.
+*                         4: Unrecognised data type.
 *
 * Notes:
 *   1: Keyword parsing is done in accordance with the syntax defined by
@@ -384,17 +382,18 @@ extern "C" {
 #define FITSHDR_KEYVALUE 0x02
 #define FITSHDR_COMMENT  0x04
 #define FITSHDR_KEYREC   0x08
-#define FITSHDR_CARD     0x08	/* Alias for backwards compatibility. */
+#define FITSHDR_CARD     0x08	// Alias for backwards compatibility.
 #define FITSHDR_TRAILER  0x10
 
 
 extern const char *fitshdr_errmsg[];
 
 enum fitshdr_errmsg_enum {
-  FITSHDRERR_SUCCESS      = 0,	/* Success.                                 */
-  FITSHDRERR_NULL_POINTER = 1,	/* Null fitskey pointer passed.             */
-  FITSHDRERR_MEMORY       = 2,	/* Memory allocation failed.                */
-  FITSHDRERR_FLEX_PARSER  = 3	/* Fatal error returned by Flex parser.     */
+  FITSHDRERR_SUCCESS      = 0,	// Success.
+  FITSHDRERR_NULL_POINTER = 1,	// Null fitskey pointer passed.
+  FITSHDRERR_MEMORY       = 2,	// Memory allocation failed.
+  FITSHDRERR_FLEX_PARSER  = 3,	// Fatal error returned by Flex parser.
+  FITSHDRERR_DATA_TYPE    = 4 	// Unrecognised data type.
 };
 
 #ifdef WCSLIB_INT64
@@ -404,38 +403,38 @@ enum fitshdr_errmsg_enum {
 #endif
 
 
-/* Struct used for indexing the keywords. */
+// Struct used for indexing the keywords.
 struct fitskeyid {
-  char name[12];		/* Keyword name, null-terminated.           */
-  int  count;			/* Number of occurrences of keyword.        */
-  int  idx[2];			/* Indices into fitskey array.              */
+  char name[12];		// Keyword name, null-terminated.
+  int  count;			// Number of occurrences of keyword.
+  int  idx[2];			// Indices into fitskey array.
 };
 
-/* Size of the fitskeyid struct in int units, used by the Fortran wrappers. */
+// Size of the fitskeyid struct in int units, used by the Fortran wrappers.
 #define KEYIDLEN (sizeof(struct fitskeyid)/sizeof(int))
 
 
-/* Struct used for storing FITS keywords. */
+// Struct used for storing FITS keywords.
 struct fitskey {
-  int  keyno;			/* Header keyrecord sequence number (1-rel).*/
-  int  keyid;			/* Index into fitskeyid[].                  */
-  int  status;			/* Header keyrecord status bit flags.       */
-  char keyword[12];		/* Keyword name, null-filled.               */
-  int  type;			/* Keyvalue type (see above).               */
-  int  padding;			/* (Dummy inserted for alignment purposes.) */
+  int  keyno;			// Header keyrecord sequence number (1-rel).
+  int  keyid;			// Index into fitskeyid[].
+  int  status;			// Header keyrecord status bit flags.
+  char keyword[12];		// Keyword name, null-filled.
+  int  type;			// Keyvalue type (see above).
+  int  padding;			// (Dummy inserted for alignment purposes.)
   union {
-    int    i;			/* 32-bit integer and logical values.       */
-    int64  k;			/* 64-bit integer values.                   */
-    int    l[8];		/* Very long signed integer values.         */
-    double f;			/* Floating point values.                   */
-    double c[2];		/* Complex values.                          */
-    char   s[72];		/* String values, null-terminated.          */
-  } keyvalue;			/* Keyvalue.                                */
-  int  ulen;			/* Length of units string.                  */
-  char comment[84];		/* Comment (or keyrecord), null-terminated. */
+    int    i;			// 32-bit integer and logical values.
+    int64  k;			// 64-bit integer values.
+    int    l[8];		// Very long signed integer values.
+    double f;			// Floating point values.
+    double c[2];		// Complex values.
+    char   s[72];		// String values, null-terminated.
+  } keyvalue;			// Keyvalue.
+  int  ulen;			// Length of units string.
+  char comment[84];		// Comment (or keyrecord), null-terminated.
 };
 
-/* Size of the fitskey struct in int units, used by the Fortran wrappers. */
+// Size of the fitskey struct in int units, used by the Fortran wrappers.
 #define KEYLEN (sizeof(struct fitskey)/sizeof(int))
 
 
@@ -447,4 +446,4 @@ int fitshdr(const char header[], int nke
 }
 #endif
 
-#endif /* WCSLIB_FITSHDR */
+#endif // WCSLIB_FITSHDR
Index: astropy-4.2.1/cextern/wcslib/C/fitshdr.l
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/fitshdr.l
+++ astropy-4.2.1/cextern/wcslib/C/fitshdr.l
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: fitshdr.l,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: fitshdr.l,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
 * fitshdr.l is a Flex description file containing a lexical scanner
@@ -44,6 +41,7 @@
 %option outfile="fitshdr.c"
 %option prefix="fitshdr"
 %option reentrant
+%option extra-type="struct fitshdr_extra *"
 
 /* Keywords. */
 KEYCHR	[-_A-Z0-9]
@@ -84,35 +82,15 @@ UNITSTR \[[-+*/^(). 0-9a-zA-Z]+\]
 #include "fitshdr.h"
 #include "wcsutil.h"
 
-static int fitshdr_scanner(const char header[], int nkeyrec, int nkeyids, \
-                           struct fitskeyid keyids[], int *nreject, \
-                           struct fitskey **keys, yyscan_t yyscanner);
-
-/*--------------------------------------------------------------------------*/
-
-int fitshdr(
-  const char header[],
-  int nkeyrec,
-  int nkeyids,
-  struct fitskeyid keyids[],
-  int *nreject,
-  struct fitskey **keys)
-
-{
-  int status;
-  yyscan_t yyscanner;
-  int yylex_init(yyscan_t *yyscanner);
-  int yylex_destroy(yyscan_t yyscanner);
-
-  yylex_init(&yyscanner);
-  status = fitshdr_scanner(header, nkeyrec, nkeyids, keyids, nreject,
-                           keys, yyscanner);
-  yylex_destroy(yyscanner);
-
-  return status;
-}
-
-/*--------------------------------------------------------------------------*/
+// User data associated with yyscanner.
+struct fitshdr_extra {
+  // Values passed to YY_INPUT.
+  const char *hdr;
+  int  nkeyrec;
+
+  // Used in preempting the call to exit() by yy_fatal_error().
+  jmp_buf abort_jmp_env;
+};
 
 #define YY_DECL int fitshdr_scanner(const char header[], int nkeyrec, \
   int nkeyids, struct fitskeyid keyids[], int *nreject, \
@@ -120,26 +98,25 @@ int fitshdr(
 
 #define YY_INPUT(inbuff, count, bufsize) \
 	{ \
-	  if (fitshdr_nkeyrec) { \
-	    strncpy(inbuff, fitshdr_hdr, 80); \
+	  if (yyextra->nkeyrec) { \
+	    strncpy(inbuff, yyextra->hdr, 80); \
 	    inbuff[80] = '\n'; \
-	    fitshdr_hdr += 80; \
-	    fitshdr_nkeyrec--; \
+	    yyextra->hdr += 80; \
+	    yyextra->nkeyrec--; \
 	    count = 81; \
 	  } else { \
 	    count = YY_NULL; \
 	  } \
 	}
 
-/* These global variables are required by YY_INPUT. */
-const char *fitshdr_hdr;
-int  fitshdr_nkeyrec;
-
-/* Used in preempting the call to exit() by yy_fatal_error(). */
-jmp_buf fitshdr_abort_jmp_env;
-#define exit(status) longjmp(fitshdr_abort_jmp_env, status)
+// Preempt the call to exit() by yy_fatal_error().
+#define exit(status) longjmp(yyextra->abort_jmp_env, status);
 
-/* Map status return value to message. */
+// Internal helper functions.
+static YY_DECL;
+static void nullfill(char cptr[], int len);
+
+// Map status return value to message.
 const char *fitshdr_errmsg[] = {
    "Success",
    "Null fitskey pointer-pointer passed",
@@ -149,50 +126,65 @@ const char *fitshdr_errmsg[] = {
 %}
 
 %%
-	char *cptr, ctmp[72];
-	int  blank, continuation, end, j, k, keyno;
-	double dtmp;
-	struct fitskey *kptr;
-	struct fitskeyid *iptr;
-	void nullfill(char cptr[], int len);
-	
-	fitshdr_hdr = header;
-	fitshdr_nkeyrec = nkeyrec;
-	
-	*nreject = 0;
-	keyno = 0;
+	char ctmp[72];
 	
 	if (keys == 0x0) {
-	  return 1;
+	  return FITSHDRERR_NULL_POINTER;
 	}
 	
-	/* Allocate memory for the required number of fitskey structs. */
-	/* Recall that calloc() initializes allocated memory to zero.  */
+	// Allocate memory for the required number of fitskey structs.
+	// Recall that calloc() initializes allocated memory to zero.
+	struct fitskey *kptr;
 	if (!(kptr = *keys = calloc(nkeyrec, sizeof(struct fitskey)))) {
-	  return 2;
+	  return FITSHDRERR_MEMORY;
 	}
 	
-	/* Initialize keyids[]. */
-	iptr = keyids;
-	for (j = 0; j < nkeyids; j++, iptr++) {
+	// Initialize returned values.
+	*nreject = 0;
+	
+	// Initialize keyids[].
+	struct fitskeyid *iptr = keyids;
+	for (int j = 0; j < nkeyids; j++, iptr++) {
 	  iptr->count  = 0;
 	  iptr->idx[0] = -1;
 	  iptr->idx[1] = -1;
 	}
+
+	int keyno = 0;
+	
+	int blank = 0;
+	int continuation = 0;
+	int end = 0;
+	
+	#ifdef WCSLIB_INT64
+	  #define asString(S) stringize(S)
+	  #define stringize(S) #S
+	
+	  const char *int64fmt;
+	  if (strcmp(asString(WCSLIB_INT64), "long long int") == 0) {
+	    int64fmt = "%lld";
+	  } else if (strcmp(asString(WCSLIB_INT64), "long int") == 0) {
+	    int64fmt = "%ld";
+	  } else if (strcmp(asString(WCSLIB_INT64), "int") == 0) {
+	    int64fmt = "%d";
+	  } else {
+	    return FITSHDRERR_DATA_TYPE;
+	  }
+	#endif
+	
+	// User data associated with yyscanner.
+	yyextra->hdr = header;
+	yyextra->nkeyrec = nkeyrec;
 	
-	blank = 0;
-	continuation = 0;
-	end = 0;
-	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
-	if (setjmp(fitshdr_abort_jmp_env)) {
-	  return 3;
+	// Return here via longjmp() invoked by yy_fatal_error().
+	if (setjmp(yyextra->abort_jmp_env)) {
+	  return FITSHDRERR_FLEX_PARSER;
 	}
 	
 	BEGIN(INITIAL);
 
 ^" "{80} {
-	  /* A completely blank keyrecord. */
+	  // A completely blank keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  yyless(0);
 	  blank = 1;
@@ -211,14 +203,14 @@ const char *fitshdr_errmsg[] = {
 	}
 
 ^END" "{5}=" "+ {
-	  /* Illegal END keyrecord. */
+	  // Illegal END keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYREC;
 	  BEGIN(VALUE);
 	}
 
 ^END" "{5} {
-	  /* Illegal END keyrecord. */
+	  // Illegal END keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYREC;
 	  BEGIN(COMMENT);
@@ -230,57 +222,58 @@ const char *fitshdr_errmsg[] = {
 	}
 
 ^CONTINUE"  "+{STRING} {
-	  /* Continued string keyvalue. */
+	  // Continued string keyvalue.
 	  strncpy(kptr->keyword, yytext, 8);
 	
 	  if (keyno > 0 && (kptr-1)->type%10 == 8) {
-	    /* Put back the string keyvalue. */
+	    // Put back the string keyvalue.
+	    int k;
 	    for (k = 10; yytext[k] != '\''; k++);
 	    yyless(k);
 	    continuation = 1;
 	    BEGIN(VALUE);
 	
 	  } else {
-	    /* Not a valid continuation. */
+	    // Not a valid continuation.
 	    yyless(8);
 	    BEGIN(COMMENT);
 	  }
 	}
 
 ^{KEYWORD} {
-	  /* Keyword without value. */
+	  // Keyword without value.
 	  strncpy(kptr->keyword, yytext, 8);
 	  BEGIN(COMMENT);
 	}
 
 ^.{8}=" "+ {
-	  /* Illegal keyword, carry on regardless. */
+	  // Illegal keyword, carry on regardless.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYWORD;
 	  BEGIN(VALUE);
 	}
 
 ^.{8}	{
-	  /* Illegal keyword, carry on regardless. */
+	  // Illegal keyword, carry on regardless.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYWORD;
 	  BEGIN(COMMENT);
 	}
 
 <VALUE>" "*/\/ {
-	  /* Null keyvalue. */
+	  // Null keyvalue.
 	  BEGIN(INLINE);
 	}
 
 <VALUE>{LOGICAL} {
-	  /* Logical keyvalue. */
+	  // Logical keyvalue.
 	  kptr->type = 1;
 	  kptr->keyvalue.i = (*yytext == 'T');
 	  BEGIN(INLINE);
 	}
 
 <VALUE>{INT32} {
-	  /* 32-bit signed integer keyvalue. */
+	  // 32-bit signed integer keyvalue.
 	  kptr->type = 2;
 	  if (sscanf(yytext, "%d", &(kptr->keyvalue.i)) < 1) {
 	    kptr->status |= FITSHDR_KEYVALUE;
@@ -291,13 +284,14 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{INT64} {
-	  /* 64-bit signed integer keyvalue (up to 18 digits). */
+	  // 64-bit signed integer keyvalue (up to 18 digits).
+	  double dtmp;
 	  if (wcsutil_str2double(yytext, &dtmp)) {
 	    kptr->status |= FITSHDR_KEYVALUE;
 	    BEGIN(ERROR);
 	
 	  } else if (INT_MIN <= dtmp && dtmp <= INT_MAX) {
-	    /* Can be accomodated as a 32-bit signed integer. */
+	    // Can be accomodated as a 32-bit signed integer.
 	    kptr->type = 2;
 	    if (sscanf(yytext, "%d", &(kptr->keyvalue.i)) < 1) {
 	      kptr->status |= FITSHDR_KEYVALUE;
@@ -305,16 +299,16 @@ const char *fitshdr_errmsg[] = {
 	    }
 	
 	  } else {
-	    /* 64-bit signed integer. */
+	    // 64-bit signed integer.
 	    kptr->type = 3;
 	    #ifdef WCSLIB_INT64
-	      /* Native 64-bit integer is available. */
-	      if (sscanf(yytext, "%lld", &(kptr->keyvalue.k)) < 1) {
+	      // Native 64-bit integer is available.
+	      if (sscanf(yytext, int64fmt, &(kptr->keyvalue.k)) < 1) {
 	        kptr->status |= FITSHDR_KEYVALUE;
 	        BEGIN(ERROR);
 	      }
 	    #else
-	      /* 64-bit integer (up to 18 digits) implemented as int[3]. */
+	      // 64-bit integer (up to 18 digits) implemented as int[3].
 	      kptr->keyvalue.k[2] = 0;
 	
 	      sprintf(ctmp, "%%%dd%%9d", yyleng-9);
@@ -332,12 +326,12 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{INTVL} {
-	  /* Very long integer keyvalue (and 19-digit int64). */
+	  // Very long integer keyvalue (and 19-digit int64).
 	  kptr->type = 4;
 	  strcpy(ctmp, yytext);
-	  k = yyleng;
+	  int j, k = yyleng;
 	  for (j = 0; j < 8; j++) {
-	    /* Read it backwards. */
+	    // Read it backwards.
 	    k -= 9;
 	    if (k < 0) k = 0;
 	    if (sscanf(ctmp+k, "%d", kptr->keyvalue.l+j) < 1) {
@@ -352,7 +346,7 @@ const char *fitshdr_errmsg[] = {
 	    ctmp[k] = '\0';
 	  }
 	
-	  /* Can it be accomodated as a 64-bit signed integer? */
+	  // Can it be accomodated as a 64-bit signed integer?
 	  if (j == 2 && abs(kptr->keyvalue.l[2]) <=  9 &&
 	                abs(kptr->keyvalue.l[1]) <=  223372036 &&
 	                    kptr->keyvalue.l[0]  <=  854775807 &&
@@ -360,9 +354,9 @@ const char *fitshdr_errmsg[] = {
 	    kptr->type = 3;
 	
 	    #ifdef WCSLIB_INT64
-	      /* Native 64-bit integer is available. */
+	      // Native 64-bit integer is available.
 	      kptr->keyvalue.l[2] = 0;
-	      if (sscanf(yytext, "%lld", &(kptr->keyvalue.k)) < 1) {
+	      if (sscanf(yytext, int64fmt, &(kptr->keyvalue.k)) < 1) {
 	        kptr->status |= FITSHDR_KEYVALUE;
 	        BEGIN(ERROR);
 	      }
@@ -373,7 +367,7 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{FLOAT} {
-	  /* Float keyvalue. */
+	  // Float keyvalue.
 	  kptr->type = 5;
 	  if (wcsutil_str2double(yytext, &(kptr->keyvalue.f))) {
 	    kptr->status |= FITSHDR_KEYVALUE;
@@ -384,7 +378,7 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{ICOMPLX} {
-	  /* Integer complex keyvalue. */
+	  // Integer complex keyvalue.
 	  kptr->type = 6;
 	  if (sscanf(yytext, "(%lf,%lf)", kptr->keyvalue.c,
 	      kptr->keyvalue.c+1) < 2) {
@@ -396,9 +390,11 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{FCOMPLX} {
-	  /* Floating point complex keyvalue. */
+	  // Floating point complex keyvalue.
 	  kptr->type = 7;
 	
+	  char *cptr;
+	  int k;
 	  for (cptr = ctmp, k = 1; yytext[k] != ','; cptr++, k++) {
 	    *cptr = yytext[k];
 	  }
@@ -423,14 +419,14 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{STRING} {
-	  /* String keyvalue. */
+	  // String keyvalue.
 	  kptr->type = 8;
-	  cptr = kptr->keyvalue.s;
+	  char *cptr = kptr->keyvalue.s;
 	  strcpy(cptr, yytext+1);
 	
-	  /* Squeeze out repeated quotes. */
-	  k = 0;
-	  for (j = 0; j < 72; j++) {
+	  // Squeeze out repeated quotes.
+	  int k = 0;
+	  for (int j = 0; j < 72; j++) {
 	    if (k < j) {
 	      cptr[k] = cptr[j];
 	    }
@@ -446,7 +442,7 @@ const char *fitshdr_errmsg[] = {
 	  }
 	
 	  if (*cptr) {
-	    /* Retain the initial blank in all-blank strings. */
+	    // Retain the initial blank in all-blank strings.
 	    nullfill(cptr+1, 71);
 	  } else {
 	    nullfill(cptr, 72);
@@ -478,7 +474,7 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <INLINE>. {
-	  /* Keyvalue parsing must now also be suspect. */
+	  // Keyvalue parsing must now also be suspect.
 	  kptr->status |= FITSHDR_COMMENT;
 	  kptr->type = 0;
 	  BEGIN(ERROR);
@@ -504,7 +500,7 @@ const char *fitshdr_errmsg[] = {
 <ERROR>.* {
 	  if (!continuation) kptr->type = -abs(kptr->type);
 	
-	  sprintf(kptr->comment, "%.80s", fitshdr_hdr-80);
+	  sprintf(kptr->comment, "%.80s", yyextra->hdr-80);
 	  kptr->comment[80] = '\0';
 	  nullfill(kptr->comment+80, 4);
 	
@@ -512,18 +508,19 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <FLUSH>.*\n {
-	  /* Discard the rest of the input line. */
+	  // Discard the rest of the input line.
 	  kptr->keyno = ++keyno;
 	
-	  /* Null-fill the keyword. */
+	  // Null-fill the keyword.
 	  kptr->keyword[8] = '\0';
 	  nullfill(kptr->keyword, 12);
 	
-	  /* Do indexing. */
+	  // Do indexing.
 	  iptr = keyids;
 	  kptr->keyid = -1;
-	  for (j = 0; j < nkeyids; j++, iptr++) {
-	    cptr = iptr->name;
+	  for (int j = 0; j < nkeyids; j++, iptr++) {
+	    int k;
+	    char *cptr = iptr->name;
 	    cptr[8] = '\0';
 	    nullfill(cptr, 12);
 	    for (k = 0; k < 8; k++, cptr++) {
@@ -531,7 +528,7 @@ const char *fitshdr_errmsg[] = {
 	    }
 	
 	    if (k == 8) {
-	      /* Found a match. */
+	      // Found a match.
 	      iptr->count++;
 	      if (iptr->idx[0] == -1) {
 	        iptr->idx[0] = keyno-1;
@@ -544,17 +541,17 @@ const char *fitshdr_errmsg[] = {
 	    }
 	  }
 	
-	  /* Deal with continued strings. */
+	  // Deal with continued strings.
 	  if (continuation) {
-	    /* Tidy up the previous string keyvalue. */
+	    // Tidy up the previous string keyvalue.
 	    if ((kptr-1)->type == 8) (kptr-1)->type += 10;
-	    cptr = (kptr-1)->keyvalue.s;
+	    char *cptr = (kptr-1)->keyvalue.s;
 	    if (cptr[strlen(cptr)-1] == '&') cptr[strlen(cptr)-1] = '\0';
 	
 	    kptr->type = (kptr-1)->type + 10;
 	  }
 	
-	  /* Check for keyrecords following the END keyrecord. */
+	  // Check for keyrecords following the END keyrecord.
 	  if (end && (end++ > 1) && !blank) {
 	    kptr->status |= FITSHDR_TRAILER;
 	  }
@@ -568,30 +565,59 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <<EOF>>	{
-	  /* End-of-input. */
+	  // End-of-input.
 	  return 0;
 	}
 
 %%
 
-/*--------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+* External interface to the scanner.
+*---------------------------------------------------------------------------*/
 
-void nullfill(char cptr[], int len)
+int fitshdr(
+  const char header[],
+  int nkeyrec,
+  int nkeyids,
+  struct fitskeyid keyids[],
+  int *nreject,
+  struct fitskey **keys)
 
 {
-  int j, k;
+  // Function prototypes.
+  int yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *yyscanner);
+  int yylex_destroy(yyscan_t yyscanner);
 
-  /* Null-fill the string. */
+  struct fitshdr_extra extra;
+  yyscan_t yyscanner;
+  yylex_init_extra(&extra, &yyscanner);
+  int status = fitshdr_scanner(header, nkeyrec, nkeyids, keyids, nreject,
+                               keys, yyscanner);
+  yylex_destroy(yyscanner);
+
+  return status;
+}
+
+/*----------------------------------------------------------------------------
+* Pad a string with null characters.
+*---------------------------------------------------------------------------*/
+
+void nullfill(char cptr[], int len)
+
+{
+  // Propagate the terminating null to the end of the string.
+  int j;
   for (j = 0; j < len; j++) {
     if (cptr[j] == '\0') {
-      for (k = j+1; k < len; k++) {
+      for (int k = j+1; k < len; k++) {
         cptr[k] = '\0';
       }
       break;
     }
   }
 
-  for (k = j-1; k >= 0; k--) {
+  // Remove trailing blanks.
+  for (int k = j-1; k >= 0; k--) {
     if (cptr[k] != ' ') break;
     cptr[k] = '\0';
   }
Index: astropy-4.2.1/cextern/wcslib/C/flexed/README
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/flexed/README
+++ astropy-4.2.1/cextern/wcslib/C/flexed/README
@@ -1,5 +1,5 @@
 This directory contains C code generated by flex 2.6.4 under KDE Neon User
-Edition 5.17 (Kubuntu 18.04) from the Flex description files (*.l) in the
+Edition 5.19 (Kubuntu 18.04) from the Flex description files (*.l) in the
 parent directory.
 
 These pre-generated source files may be used during installation if
Index: astropy-4.2.1/cextern/wcslib/C/flexed/fitshdr.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/flexed/fitshdr.c
+++ astropy-4.2.1/cextern/wcslib/C/flexed/fitshdr.c
@@ -10233,9 +10233,8 @@ static const yy_state_type yy_NUL_trans[
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "fitshdr.l"
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -10252,11 +10251,9 @@ static const yy_state_type yy_NUL_trans[
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: fitshdr.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: fitshdr.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
 * fitshdr.l is a Flex description file containing a lexical scanner
@@ -10275,7 +10272,7 @@ static const yy_state_type yy_NUL_trans[
 /* Characters forming standard unit strings (jwBIQX are not used). */
 /* Exclusive start states. */
 
-#line 78 "fitshdr.l"
+#line 76 "fitshdr.l"
 #include <math.h>
 #include <limits.h>
 #include <setjmp.h>
@@ -10285,35 +10282,15 @@ static const yy_state_type yy_NUL_trans[
 #include "fitshdr.h"
 #include "wcsutil.h"
 
-static int fitshdr_scanner(const char header[], int nkeyrec, int nkeyids, \
-                           struct fitskeyid keyids[], int *nreject, \
-                           struct fitskey **keys, yyscan_t yyscanner);
-
-/*--------------------------------------------------------------------------*/
-
-int fitshdr(
-  const char header[],
-  int nkeyrec,
-  int nkeyids,
-  struct fitskeyid keyids[],
-  int *nreject,
-  struct fitskey **keys)
-
-{
-  int status;
-  yyscan_t yyscanner;
-  int yylex_init(yyscan_t *yyscanner);
-  int yylex_destroy(yyscan_t yyscanner);
-
-  yylex_init(&yyscanner);
-  status = fitshdr_scanner(header, nkeyrec, nkeyids, keyids, nreject,
-                           keys, yyscanner);
-  yylex_destroy(yyscanner);
-
-  return status;
-}
-
-/*--------------------------------------------------------------------------*/
+// User data associated with yyscanner.
+struct fitshdr_extra {
+  // Values passed to YY_INPUT.
+  const char *hdr;
+  int  nkeyrec;
+
+  // Used in preempting the call to exit() by yy_fatal_error().
+  jmp_buf abort_jmp_env;
+};
 
 #define YY_DECL int fitshdr_scanner(const char header[], int nkeyrec, \
   int nkeyids, struct fitskeyid keyids[], int *nreject, \
@@ -10321,34 +10298,33 @@ int fitshdr(
 
 #define YY_INPUT(inbuff, count, bufsize) \
 	{ \
-	  if (fitshdr_nkeyrec) { \
-	    strncpy(inbuff, fitshdr_hdr, 80); \
+	  if (yyextra->nkeyrec) { \
+	    strncpy(inbuff, yyextra->hdr, 80); \
 	    inbuff[80] = '\n'; \
-	    fitshdr_hdr += 80; \
-	    fitshdr_nkeyrec--; \
+	    yyextra->hdr += 80; \
+	    yyextra->nkeyrec--; \
 	    count = 81; \
 	  } else { \
 	    count = YY_NULL; \
 	  } \
 	}
 
-/* These global variables are required by YY_INPUT. */
-const char *fitshdr_hdr;
-int  fitshdr_nkeyrec;
-
-/* Used in preempting the call to exit() by yy_fatal_error(). */
-jmp_buf fitshdr_abort_jmp_env;
-#define exit(status) longjmp(fitshdr_abort_jmp_env, status)
+// Preempt the call to exit() by yy_fatal_error().
+#define exit(status) longjmp(yyextra->abort_jmp_env, status);
 
-/* Map status return value to message. */
+// Internal helper functions.
+static YY_DECL;
+static void nullfill(char cptr[], int len);
+
+// Map status return value to message.
 const char *fitshdr_errmsg[] = {
    "Success",
    "Null fitskey pointer-pointer passed",
    "Memory allocation failed",
    "Fatal error returned by Flex parser"};
 
-#line 10351 "fitshdr.c"
-#line 10352 "fitshdr.c"
+#line 10327 "fitshdr.c"
+#line 10328 "fitshdr.c"
 
 #define INITIAL 0
 #define VALUE 1
@@ -10366,9 +10342,7 @@ const char *fitshdr_errmsg[] = {
 #include <unistd.h>
 #endif
 
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
+#define YY_EXTRA_TYPE struct fitshdr_extra *
 
 /* Holds the entire state of the reentrant scanner. */
 struct yyguts_t
@@ -10599,52 +10573,67 @@ YY_DECL
 		}
 
 	{
-#line 151 "fitshdr.l"
+#line 128 "fitshdr.l"
 
-#line 153 "fitshdr.l"
-	char *cptr, ctmp[72];
-	int  blank, continuation, end, j, k, keyno;
-	double dtmp;
-	struct fitskey *kptr;
-	struct fitskeyid *iptr;
-	void nullfill(char cptr[], int len);
-	
-	fitshdr_hdr = header;
-	fitshdr_nkeyrec = nkeyrec;
-	
-	*nreject = 0;
-	keyno = 0;
+#line 130 "fitshdr.l"
+	char ctmp[72];
 	
 	if (keys == 0x0) {
-	  return 1;
+	  return FITSHDRERR_NULL_POINTER;
 	}
 	
-	/* Allocate memory for the required number of fitskey structs. */
-	/* Recall that calloc() initializes allocated memory to zero.  */
+	// Allocate memory for the required number of fitskey structs.
+	// Recall that calloc() initializes allocated memory to zero.
+	struct fitskey *kptr;
 	if (!(kptr = *keys = calloc(nkeyrec, sizeof(struct fitskey)))) {
-	  return 2;
+	  return FITSHDRERR_MEMORY;
 	}
 	
-	/* Initialize keyids[]. */
-	iptr = keyids;
-	for (j = 0; j < nkeyids; j++, iptr++) {
+	// Initialize returned values.
+	*nreject = 0;
+	
+	// Initialize keyids[].
+	struct fitskeyid *iptr = keyids;
+	for (int j = 0; j < nkeyids; j++, iptr++) {
 	  iptr->count  = 0;
 	  iptr->idx[0] = -1;
 	  iptr->idx[1] = -1;
 	}
+
+	int keyno = 0;
+	
+	int blank = 0;
+	int continuation = 0;
+	int end = 0;
 	
-	blank = 0;
-	continuation = 0;
-	end = 0;
-	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
-	if (setjmp(fitshdr_abort_jmp_env)) {
-	  return 3;
+#ifdef WCSLIB_INT64
+#define asString(S) stringize(S)
+#define stringize(S) #S
+	
+	  const char *int64fmt;
+	  if (strcmp(asString(WCSLIB_INT64), "long long int") == 0) {
+	    int64fmt = "%lld";
+	  } else if (strcmp(asString(WCSLIB_INT64), "long int") == 0) {
+	    int64fmt = "%ld";
+	  } else if (strcmp(asString(WCSLIB_INT64), "int") == 0) {
+	    int64fmt = "%d";
+	  } else {
+	    return FITSHDRERR_DATA_TYPE;
+	  }
+#endif
+	
+	// User data associated with yyscanner.
+	yyextra->hdr = header;
+	yyextra->nkeyrec = nkeyrec;
+	
+	// Return here via longjmp() invoked by yy_fatal_error().
+	if (setjmp(yyextra->abort_jmp_env)) {
+	  return FITSHDRERR_FLEX_PARSER;
 	}
 	
 	BEGIN(INITIAL);
 
-#line 10648 "fitshdr.c"
+#line 10637 "fitshdr.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -10698,9 +10687,9 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 195 "fitshdr.l"
+#line 187 "fitshdr.l"
 {
-	  /* A completely blank keyrecord. */
+	  // A completely blank keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  yyless(0);
 	  blank = 1;
@@ -10709,7 +10698,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 203 "fitshdr.l"
+#line 195 "fitshdr.l"
 {
 	  strncpy(kptr->keyword, yytext, 8);
 	  BEGIN(COMMENT);
@@ -10717,7 +10706,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 208 "fitshdr.l"
+#line 200 "fitshdr.l"
 {
 	  strncpy(kptr->keyword, yytext, 8);
 	  end = 1;
@@ -10726,9 +10715,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 214 "fitshdr.l"
+#line 206 "fitshdr.l"
 {
-	  /* Illegal END keyrecord. */
+	  // Illegal END keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYREC;
 	  BEGIN(VALUE);
@@ -10736,9 +10725,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 221 "fitshdr.l"
+#line 213 "fitshdr.l"
 {
-	  /* Illegal END keyrecord. */
+	  // Illegal END keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYREC;
 	  BEGIN(COMMENT);
@@ -10746,7 +10735,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 228 "fitshdr.l"
+#line 220 "fitshdr.l"
 {
 	  strncpy(kptr->keyword, yytext, 8);
 	  BEGIN(VALUE);
@@ -10755,20 +10744,21 @@ YY_RULE_SETUP
 case 7:
 /* rule 7 can match eol */
 YY_RULE_SETUP
-#line 233 "fitshdr.l"
+#line 225 "fitshdr.l"
 {
-	  /* Continued string keyvalue. */
+	  // Continued string keyvalue.
 	  strncpy(kptr->keyword, yytext, 8);
 	
 	  if (keyno > 0 && (kptr-1)->type%10 == 8) {
-	    /* Put back the string keyvalue. */
+	    // Put back the string keyvalue.
+	    int k;
 	    for (k = 10; yytext[k] != '\''; k++);
 	    yyless(k);
 	    continuation = 1;
 	    BEGIN(VALUE);
 	
 	  } else {
-	    /* Not a valid continuation. */
+	    // Not a valid continuation.
 	    yyless(8);
 	    BEGIN(COMMENT);
 	  }
@@ -10776,18 +10766,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 251 "fitshdr.l"
+#line 244 "fitshdr.l"
 {
-	  /* Keyword without value. */
+	  // Keyword without value.
 	  strncpy(kptr->keyword, yytext, 8);
 	  BEGIN(COMMENT);
 	}
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 257 "fitshdr.l"
+#line 250 "fitshdr.l"
 {
-	  /* Illegal keyword, carry on regardless. */
+	  // Illegal keyword, carry on regardless.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYWORD;
 	  BEGIN(VALUE);
@@ -10795,9 +10785,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 264 "fitshdr.l"
+#line 257 "fitshdr.l"
 {
-	  /* Illegal keyword, carry on regardless. */
+	  // Illegal keyword, carry on regardless.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYWORD;
 	  BEGIN(COMMENT);
@@ -10808,17 +10798,17 @@ case 11:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 271 "fitshdr.l"
+#line 264 "fitshdr.l"
 {
-	  /* Null keyvalue. */
+	  // Null keyvalue.
 	  BEGIN(INLINE);
 	}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 276 "fitshdr.l"
+#line 269 "fitshdr.l"
 {
-	  /* Logical keyvalue. */
+	  // Logical keyvalue.
 	  kptr->type = 1;
 	  kptr->keyvalue.i = (*yytext == 'T');
 	  BEGIN(INLINE);
@@ -10826,9 +10816,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 283 "fitshdr.l"
+#line 276 "fitshdr.l"
 {
-	  /* 32-bit signed integer keyvalue. */
+	  // 32-bit signed integer keyvalue.
 	  kptr->type = 2;
 	  if (sscanf(yytext, "%d", &(kptr->keyvalue.i)) < 1) {
 	    kptr->status |= FITSHDR_KEYVALUE;
@@ -10840,15 +10830,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 294 "fitshdr.l"
+#line 287 "fitshdr.l"
 {
-	  /* 64-bit signed integer keyvalue (up to 18 digits). */
+	  // 64-bit signed integer keyvalue (up to 18 digits).
+	  double dtmp;
 	  if (wcsutil_str2double(yytext, &dtmp)) {
 	    kptr->status |= FITSHDR_KEYVALUE;
 	    BEGIN(ERROR);
 	
 	  } else if (INT_MIN <= dtmp && dtmp <= INT_MAX) {
-	    /* Can be accomodated as a 32-bit signed integer. */
+	    // Can be accomodated as a 32-bit signed integer.
 	    kptr->type = 2;
 	    if (sscanf(yytext, "%d", &(kptr->keyvalue.i)) < 1) {
 	      kptr->status |= FITSHDR_KEYVALUE;
@@ -10856,16 +10847,16 @@ YY_RULE_SETUP
 	    }
 	
 	  } else {
-	    /* 64-bit signed integer. */
+	    // 64-bit signed integer.
 	    kptr->type = 3;
 #ifdef WCSLIB_INT64
-	      /* Native 64-bit integer is available. */
-	      if (sscanf(yytext, "%lld", &(kptr->keyvalue.k)) < 1) {
+	      // Native 64-bit integer is available.
+	      if (sscanf(yytext, int64fmt, &(kptr->keyvalue.k)) < 1) {
 	        kptr->status |= FITSHDR_KEYVALUE;
 	        BEGIN(ERROR);
 	      }
 #else
-	      /* 64-bit integer (up to 18 digits) implemented as int[3]. */
+	      // 64-bit integer (up to 18 digits) implemented as int[3].
 	      kptr->keyvalue.k[2] = 0;
 	
 	      sprintf(ctmp, "%%%dd%%9d", yyleng-9);
@@ -10884,14 +10875,14 @@ YY_RULE_SETUP
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 335 "fitshdr.l"
+#line 329 "fitshdr.l"
 {
-	  /* Very long integer keyvalue (and 19-digit int64). */
+	  // Very long integer keyvalue (and 19-digit int64).
 	  kptr->type = 4;
 	  strcpy(ctmp, yytext);
-	  k = yyleng;
+	  int j, k = yyleng;
 	  for (j = 0; j < 8; j++) {
-	    /* Read it backwards. */
+	    // Read it backwards.
 	    k -= 9;
 	    if (k < 0) k = 0;
 	    if (sscanf(ctmp+k, "%d", kptr->keyvalue.l+j) < 1) {
@@ -10906,7 +10897,7 @@ YY_RULE_SETUP
 	    ctmp[k] = '\0';
 	  }
 	
-	  /* Can it be accomodated as a 64-bit signed integer? */
+	  // Can it be accomodated as a 64-bit signed integer?
 	  if (j == 2 && abs(kptr->keyvalue.l[2]) <=  9 &&
 	                abs(kptr->keyvalue.l[1]) <=  223372036 &&
 	                    kptr->keyvalue.l[0]  <=  854775807 &&
@@ -10914,9 +10905,9 @@ YY_RULE_SETUP
 	    kptr->type = 3;
 	
 #ifdef WCSLIB_INT64
-	      /* Native 64-bit integer is available. */
+	      // Native 64-bit integer is available.
 	      kptr->keyvalue.l[2] = 0;
-	      if (sscanf(yytext, "%lld", &(kptr->keyvalue.k)) < 1) {
+	      if (sscanf(yytext, int64fmt, &(kptr->keyvalue.k)) < 1) {
 	        kptr->status |= FITSHDR_KEYVALUE;
 	        BEGIN(ERROR);
 	      }
@@ -10928,9 +10919,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 376 "fitshdr.l"
+#line 370 "fitshdr.l"
 {
-	  /* Float keyvalue. */
+	  // Float keyvalue.
 	  kptr->type = 5;
 	  if (wcsutil_str2double(yytext, &(kptr->keyvalue.f))) {
 	    kptr->status |= FITSHDR_KEYVALUE;
@@ -10942,9 +10933,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 387 "fitshdr.l"
+#line 381 "fitshdr.l"
 {
-	  /* Integer complex keyvalue. */
+	  // Integer complex keyvalue.
 	  kptr->type = 6;
 	  if (sscanf(yytext, "(%lf,%lf)", kptr->keyvalue.c,
 	      kptr->keyvalue.c+1) < 2) {
@@ -10957,11 +10948,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 399 "fitshdr.l"
+#line 393 "fitshdr.l"
 {
-	  /* Floating point complex keyvalue. */
+	  // Floating point complex keyvalue.
 	  kptr->type = 7;
 	
+	  char *cptr;
+	  int k;
 	  for (cptr = ctmp, k = 1; yytext[k] != ','; cptr++, k++) {
 	    *cptr = yytext[k];
 	  }
@@ -10988,16 +10981,16 @@ YY_RULE_SETUP
 case 19:
 /* rule 19 can match eol */
 YY_RULE_SETUP
-#line 426 "fitshdr.l"
+#line 422 "fitshdr.l"
 {
-	  /* String keyvalue. */
+	  // String keyvalue.
 	  kptr->type = 8;
-	  cptr = kptr->keyvalue.s;
+	  char *cptr = kptr->keyvalue.s;
 	  strcpy(cptr, yytext+1);
 	
-	  /* Squeeze out repeated quotes. */
-	  k = 0;
-	  for (j = 0; j < 72; j++) {
+	  // Squeeze out repeated quotes.
+	  int k = 0;
+	  for (int j = 0; j < 72; j++) {
 	    if (k < j) {
 	      cptr[k] = cptr[j];
 	    }
@@ -11013,7 +11006,7 @@ YY_RULE_SETUP
 	  }
 	
 	  if (*cptr) {
-	    /* Retain the initial blank in all-blank strings. */
+	    // Retain the initial blank in all-blank strings.
 	    nullfill(cptr+1, 71);
 	  } else {
 	    nullfill(cptr, 72);
@@ -11024,7 +11017,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 459 "fitshdr.l"
+#line 455 "fitshdr.l"
 {
 	  kptr->status |= FITSHDR_KEYVALUE;
 	  BEGIN(ERROR);
@@ -11035,7 +11028,7 @@ case 21:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 464 "fitshdr.l"
+#line 460 "fitshdr.l"
 {
 	  BEGIN(FLUSH);
 	}
@@ -11045,21 +11038,21 @@ case 22:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 468 "fitshdr.l"
+#line 464 "fitshdr.l"
 {
 	  BEGIN(FLUSH);
 	}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 472 "fitshdr.l"
+#line 468 "fitshdr.l"
 {
 	  BEGIN(UNITS);
 	}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 476 "fitshdr.l"
+#line 472 "fitshdr.l"
 {
 	  kptr->status |= FITSHDR_COMMENT;
 	  BEGIN(ERROR);
@@ -11067,9 +11060,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 481 "fitshdr.l"
+#line 477 "fitshdr.l"
 {
-	  /* Keyvalue parsing must now also be suspect. */
+	  // Keyvalue parsing must now also be suspect.
 	  kptr->status |= FITSHDR_COMMENT;
 	  kptr->type = 0;
 	  BEGIN(ERROR);
@@ -11077,7 +11070,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 488 "fitshdr.l"
+#line 484 "fitshdr.l"
 {
 	  kptr->ulen = yyleng;
 	  yymore();
@@ -11086,7 +11079,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 494 "fitshdr.l"
+#line 490 "fitshdr.l"
 {
 	  yymore();
 	  BEGIN(COMMENT);
@@ -11094,7 +11087,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 499 "fitshdr.l"
+#line 495 "fitshdr.l"
 {
 	  strcpy(kptr->comment, yytext);
 	  nullfill(kptr->comment, 84);
@@ -11103,11 +11096,11 @@ YY_RULE_SETUP
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 505 "fitshdr.l"
+#line 501 "fitshdr.l"
 {
 	  if (!continuation) kptr->type = -abs(kptr->type);
 	
-	  sprintf(kptr->comment, "%.80s", fitshdr_hdr-80);
+	  sprintf(kptr->comment, "%.80s", yyextra->hdr-80);
 	  kptr->comment[80] = '\0';
 	  nullfill(kptr->comment+80, 4);
 	
@@ -11117,20 +11110,21 @@ YY_RULE_SETUP
 case 30:
 /* rule 30 can match eol */
 YY_RULE_SETUP
-#line 515 "fitshdr.l"
+#line 511 "fitshdr.l"
 {
-	  /* Discard the rest of the input line. */
+	  // Discard the rest of the input line.
 	  kptr->keyno = ++keyno;
 	
-	  /* Null-fill the keyword. */
+	  // Null-fill the keyword.
 	  kptr->keyword[8] = '\0';
 	  nullfill(kptr->keyword, 12);
 	
-	  /* Do indexing. */
+	  // Do indexing.
 	  iptr = keyids;
 	  kptr->keyid = -1;
-	  for (j = 0; j < nkeyids; j++, iptr++) {
-	    cptr = iptr->name;
+	  for (int j = 0; j < nkeyids; j++, iptr++) {
+	    int k;
+	    char *cptr = iptr->name;
 	    cptr[8] = '\0';
 	    nullfill(cptr, 12);
 	    for (k = 0; k < 8; k++, cptr++) {
@@ -11138,7 +11132,7 @@ YY_RULE_SETUP
 	    }
 	
 	    if (k == 8) {
-	      /* Found a match. */
+	      // Found a match.
 	      iptr->count++;
 	      if (iptr->idx[0] == -1) {
 	        iptr->idx[0] = keyno-1;
@@ -11151,17 +11145,17 @@ YY_RULE_SETUP
 	    }
 	  }
 	
-	  /* Deal with continued strings. */
+	  // Deal with continued strings.
 	  if (continuation) {
-	    /* Tidy up the previous string keyvalue. */
+	    // Tidy up the previous string keyvalue.
 	    if ((kptr-1)->type == 8) (kptr-1)->type += 10;
-	    cptr = (kptr-1)->keyvalue.s;
+	    char *cptr = (kptr-1)->keyvalue.s;
 	    if (cptr[strlen(cptr)-1] == '&') cptr[strlen(cptr)-1] = '\0';
 	
 	    kptr->type = (kptr-1)->type + 10;
 	  }
 	
-	  /* Check for keyrecords following the END keyrecord. */
+	  // Check for keyrecords following the END keyrecord.
 	  if (end && (end++ > 1) && !blank) {
 	    kptr->status |= FITSHDR_TRAILER;
 	  }
@@ -11181,18 +11175,18 @@ case YY_STATE_EOF(UNITS):
 case YY_STATE_EOF(COMMENT):
 case YY_STATE_EOF(ERROR):
 case YY_STATE_EOF(FLUSH):
-#line 571 "fitshdr.l"
+#line 568 "fitshdr.l"
 {
-	  /* End-of-input. */
+	  // End-of-input.
 	  return 0;
 	}
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 576 "fitshdr.l"
+#line 573 "fitshdr.l"
 ECHO;
 	YY_BREAK
-#line 11196 "fitshdr.c"
+#line 11190 "fitshdr.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -12319,27 +12313,56 @@ void yyfree (void * ptr , yyscan_t yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 576 "fitshdr.l"
+#line 573 "fitshdr.l"
 
 
-/*--------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+* External interface to the scanner.
+*---------------------------------------------------------------------------*/
 
-void nullfill(char cptr[], int len)
+int fitshdr(
+  const char header[],
+  int nkeyrec,
+  int nkeyids,
+  struct fitskeyid keyids[],
+  int *nreject,
+  struct fitskey **keys)
 
 {
-  int j, k;
+  // Function prototypes.
+  int yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *yyscanner);
+  int yylex_destroy(yyscan_t yyscanner);
 
-  /* Null-fill the string. */
+  struct fitshdr_extra extra;
+  yyscan_t yyscanner;
+  yylex_init_extra(&extra, &yyscanner);
+  int status = fitshdr_scanner(header, nkeyrec, nkeyids, keyids, nreject,
+                               keys, yyscanner);
+  yylex_destroy(yyscanner);
+
+  return status;
+}
+
+/*----------------------------------------------------------------------------
+* Pad a string with null characters.
+*---------------------------------------------------------------------------*/
+
+void nullfill(char cptr[], int len)
+
+{
+  // Propagate the terminating null to the end of the string.
+  int j;
   for (j = 0; j < len; j++) {
     if (cptr[j] == '\0') {
-      for (k = j+1; k < len; k++) {
+      for (int k = j+1; k < len; k++) {
         cptr[k] = '\0';
       }
       break;
     }
   }
 
-  for (k = j-1; k >= 0; k--) {
+  // Remove trailing blanks.
+  for (int k = j-1; k >= 0; k--) {
     if (cptr[k] != ' ') break;
     cptr[k] = '\0';
   }
Index: astropy-4.2.1/cextern/wcslib/C/flexed/wcsbth.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/flexed/wcsbth.c
+++ astropy-4.2.1/cextern/wcslib/C/flexed/wcsbth.c
@@ -25388,9 +25388,8 @@ static const yy_state_type yy_NUL_trans[
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "wcsbth.l"
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -25407,11 +25406,9 @@ static const yy_state_type yy_NUL_trans[
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsbth.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsbth.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
 * wcsbth.l is a Flex description file containing the definition of a lexical
@@ -25473,7 +25470,7 @@ static const yy_state_type yy_NUL_trans[
 
 
 
-#line 115 "wcsbth.l"
+#line 113 "wcsbth.l"
 #include <math.h>
 #include <setjmp.h>
 #include <stddef.h>
@@ -25487,57 +25484,34 @@ static const yy_state_type yy_NUL_trans[
 #include "wcsprintf.h"
 #include "wcsutil.h"
 
-			/* Codes used for keyvalue data types. */
+			// Codes used for keyvalue data types.
 #define INTEGER 0
 #define FLOAT   1
 #define FLOAT2  2
 #define STRING  3
 
-			/* Bit masks used for keyword types:        */
-#define IMGAUX  0x1	/* Auxiliary image header, e.g. LONPOLEa or */
-			/* DATE-OBS.                                */
-#define IMGAXIS 0x2	/* Image header with axis number, e.g.      */
-			/* CTYPEia.                                 */
-#define IMGHEAD 0x3	/* IMGAUX | IMGAXIS, i.e. image header of   */
-			/* either type.                             */
-#define BIMGARR 0x4	/* Binary table image array, e.g. iCTYna.   */
-#define PIXLIST 0x8	/* Pixel list, e.g. TCTYna.                 */
-#define BINTAB  0xC	/* BIMGARR | PIXLIST, i.e. binary table     */
-			/* image array (without axis number) or     */
-			/* pixel list, e.g. LONPna or OBSGXn.       */
-
-static int wcsbth_scanner(char *header, int nkeyrec, int relax, int ctrl,
-                          int keysel, int *colsel, int *nreject, int *nwcs,
-                          struct wcsprm **wcs, yyscan_t yyscanner);
+			// Bit masks used for keyword types:
+#define IMGAUX  0x1	// Auxiliary image header, e.g. LONPOLEa or
+			// DATE-OBS.
+#define IMGAXIS 0x2	// Image header with axis number, e.g.
+			// CTYPEia.
+#define IMGHEAD 0x3	// IMGAUX | IMGAXIS, i.e. image header of
+			// either type.
+#define BIMGARR 0x4	// Binary table image array, e.g. iCTYna.
+#define PIXLIST 0x8	// Pixel list, e.g. TCTYna.
+#define BINTAB  0xC	// BIMGARR | PIXLIST, i.e. binary table
+			// image array (without axis number) or
+			// pixel list, e.g. LONPna or OBSGXn.
+
+// User data associated with yyscanner.
+struct wcsbth_extra {
+  // Values passed to YY_INPUT.
+  char *hdr;
+  int  nkeyrec;
 
-/*--------------------------------------------------------------------------*/
-
-int wcsbth(
-  char *header,
-  int nkeyrec,
-  int relax,
-  int ctrl,
-  int keysel,
-  int *colsel,
-  int *nreject,
-  int *nwcs,
-  struct wcsprm **wcs)
-
-{
-  int status;
-  yyscan_t yyscanner;
-  int yylex_init(yyscan_t *yyscanner);
-  int yylex_destroy(yyscan_t yyscanner);
-
-  yylex_init(&yyscanner);
-  status = wcsbth_scanner(header, nkeyrec, relax, ctrl, keysel, colsel,
-                          nreject, nwcs, wcs, yyscanner);
-  yylex_destroy(yyscanner);
-
-  return status;
-}
-
-/*--------------------------------------------------------------------------*/
+  // Used in preempting the call to exit() by yy_fatal_error().
+  jmp_buf abort_jmp_env;
+};
 
 #define YY_DECL int wcsbth_scanner(char *header, int nkeyrec, int relax, \
  int ctrl, int keysel, int *colsel, int *nreject, int *nwcs, \
@@ -25545,29 +25519,28 @@ int wcsbth(
 
 #define YY_INPUT(inbuff, count, bufsize) \
 	{ \
-	  if (wcsbth_nkeyrec) { \
-	    strncpy(inbuff, wcsbth_hdr, 80); \
+	  if (yyextra->nkeyrec) { \
+	    strncpy(inbuff, yyextra->hdr, 80); \
 	    inbuff[80] = '\n'; \
-	    wcsbth_hdr += 80; \
-	    wcsbth_nkeyrec--; \
+	    yyextra->hdr += 80; \
+	    yyextra->nkeyrec--; \
 	    count = 81; \
 	  } else { \
 	    count = YY_NULL; \
 	  } \
 	}
 
-/* A convenience macro to get around incompatibilities between unput() and
-   yyless(): put yytext followed by a blank back onto the input stream. */
+// Preempt the call to exit() by yy_fatal_error().
+#define exit(status) longjmp(yyextra->abort_jmp_env, status);
+
+// A convenience macro to get around incompatibilities between unput() and
+// yyless(): put yytext followed by a blank back onto the input stream.
 #define WCSBTH_PUTBACK \
   sprintf(strtmp, "%s ", yytext); \
-  iz = strlen(strtmp); \
+  size_t iz = strlen(strtmp); \
   while (iz) unput(strtmp[--iz]);
 
-/* These global variables are required by YY_INPUT. */
-static char *wcsbth_hdr;
-static int  wcsbth_nkeyrec;
-
-/* Struct used internally for header bookkeeping. */
+// Struct used internally for header bookkeeping.
 struct wcsbth_alts {
   int ncol, ialt, icol, imgherit;
   short int (*arridx)[27];
@@ -25582,7 +25555,8 @@ struct wcsbth_alts {
   unsigned char pad2[2];
 };
 
-/* Internal helper functions. */
+// Internal helper functions.
+static YY_DECL;
 static int wcsbth_colax(struct wcsprm *wcs, struct wcsbth_alts *alts, int k,
         char a);
 static int wcsbth_final(struct wcsbth_alts *alts, int *nwcs,
@@ -25594,22 +25568,18 @@ static int wcsbth_init1(struct wcsbth_al
 static int wcsbth_pass1(int keytype, int i, int j, int n, int k, char a,
         char ptype, struct wcsbth_alts *alts);
 
-/* Helper functions for keywords that require special handling. */
+// Helper functions for keywords that require special handling.
 static int wcsbth_jdref(double *wptr,   const double *jdref);
 static int wcsbth_jdrefi(double *wptr,  const double *jdrefi);
 static int wcsbth_jdreff(double *wptr,  const double *jdreff);
 static int wcsbth_epoch(double *wptr,   const double *epoch);
 static int wcsbth_vsource(double *wptr, const double *vsource);
 
-/* Helper functions for keyvalue validity checking. */
+// Helper functions for keyvalue validity checking.
 static int wcsbth_timepixr(double timepixr);
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
-jmp_buf wcsbth_abort_jmp_env;
-#define exit(status) longjmp(wcsbth_abort_jmp_env, status)
-
-#line 25612 "wcsbth.c"
-#line 25613 "wcsbth.c"
+#line 25582 "wcsbth.c"
+#line 25583 "wcsbth.c"
 
 #define INITIAL 0
 #define CCCCCia 1
@@ -25654,9 +25624,7 @@ jmp_buf wcsbth_abort_jmp_env;
 #include <unistd.h>
 #endif
 
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
+#define YY_EXTRA_TYPE struct wcsbth_extra *
 
 /* Holds the entire state of the reentrant scanner. */
 struct yyguts_t
@@ -25889,102 +25857,89 @@ YY_DECL
 		}
 
 	{
-#line 251 "wcsbth.l"
+#line 222 "wcsbth.l"
 
-#line 253 "wcsbth.l"
-	/* Keyword indices, as used in the WCS papers, e.g. iVn_ma, TPn_ka. */
-	char a;
-	int  i, j, k, m, n;
-	
-	char *cptr, *errmsg, errtxt[80], exclude[1000], gotone, *hptr, *keep,
-	     *keyname, *keyrec, ptype, strtmp[80];
-	int  altlin, auxprm, ialt, icol, incl, imherit, inttmp, ipass, ipx,
-	     itmp, ix, jx, keytype, naux, nother, nsel, npass, nvalid, status,
-	     valtype;
-	ptrdiff_t voff;
-	size_t iz;
+#line 224 "wcsbth.l"
+	char *errmsg, errtxt[80], *keyname, strtmp[80];
+	int  auxprm, inttmp;
 	double dbltmp, dbl2tmp[2];
-	void   *vptr, *wptr;
-	struct wcsbth_alts alts;
-	struct auxprm *auxp, auxtem;
-	struct wcsprm *wcsp, wcstem;
-	int (*chekval)(double);
-	int (*special)(double *, const double *);
+	struct auxprm auxtem;
+	struct wcsprm wcstem;
 	
-	/* The data structures produced. */
+	// Initialize returned values.
+	*nreject = 0;
 	*nwcs = 0;
 	*wcs  = 0x0;
 	
-	/* Parameters used to implement YY_INPUT. */
-	wcsbth_hdr = header;
-	wcsbth_nkeyrec = nkeyrec;
-	
-	/* Our handle on the input stream. */
-	keyrec = header;
-	hptr = header;
-	keep = 0x0;
-	
-	/* For keeping tallies of keywords found. */
-	*nreject = 0;
-	nvalid = 0;
-	nother = 0;
+	// Our handle on the input stream.
+	char *keyrec = header;
+	char *hptr = header;
+	char *keep = 0x0;
+	
+	// For keeping tallies of keywords found.
+	int nvalid = 0;
+	int nother = 0;
 	
-	/* Used to flag image header keywords that are always inherited. */
-	imherit = 1;
+	// Used to flag image header keywords that are always inherited.
+	int imherit = 1;
 	
-	/* If strict, then also reject. */
+	// If strict, then also reject.
 	if (relax & WCSHDR_strict) relax |= WCSHDR_reject;
 	
-	/* Keyword parameters. */
-	i = j = 0;
-	n = k = 0;
-	m = 0;
-	a = ' ';
+	// Keyword indices, as used in the WCS papers, e.g. iVn_ma, TPn_ka.
+	int i = 0;
+	int j = 0;
+	int k = 0;
+	int n = 0;
+	int m = 0;
+	char a = ' ';
 	
-	/* Header bookkeeping. */
+	// Header bookkeeping.
+	struct wcsbth_alts alts;
 	alts.ncol = 0;
 	alts.arridx  = 0x0;
 	alts.pixlist = 0x0;
 	alts.npv = 0x0;
 	alts.nps = 0x0;
 	
-	for (ialt = 0; ialt < 27; ialt++) {
+	for (int ialt = 0; ialt < 27; ialt++) {
 	  alts.pixidx[ialt] = 0;
 	  alts.pixnpv[ialt] = 0;
 	  alts.pixnps[ialt] = 0;
 	}
 	
-	/* For decoding the keyvalue. */
-	keytype =  0;
-	valtype = -1;
-	vptr    = 0x0;
-	
-	/* For keywords that require special handling. */
-	altlin  = 0;
-	ptype   = ' ';
-	chekval = 0x0;
-	special = 0x0;
-	auxprm  = 0;
-	naux    = 0;
-	
-	/* Selection by column number. */
-	nsel = colsel ? colsel[0] : 0;
-	incl = (nsel > 0);
-	for (icol = 0; icol < 1000; icol++) {
+	// For decoding the keyvalue.
+	int keytype =  0;
+	int valtype = -1;
+	void *vptr  = 0x0;
+	
+	// For keywords that require special handling.
+	int altlin  = 0;
+	char ptype  = ' ';
+	int (*chekval)(double) = 0x0;
+	int (*special)(double *, const double *) = 0x0;
+	struct auxprm *auxp = 0x0;
+	int naux = 0;
+	
+	// Selection by column number.
+	int nsel = colsel ? colsel[0] : 0;
+	int incl = (nsel > 0);
+	char exclude[1000];
+	for (int icol = 0; icol < 1000; icol++) {
 	  exclude[icol] = incl;
 	}
-	for (icol = 1; icol <= abs(nsel); icol++) {
-	  itmp = colsel[icol];
+	for (int icol = 1; icol <= abs(nsel); icol++) {
+	  int itmp = colsel[icol];
 	  if (0 < itmp && itmp < 1000) {
 	    exclude[itmp] = !incl;
 	  }
 	}
 	exclude[0] = 0;
 	
-	/* Selection by keyword type. */
-	itmp = keysel;
-	keysel = 0;
-	if (itmp) {
+	// Selection by keyword type.
+	if (keysel) {
+	  int itmp = keysel;
+	  keysel = 0;
 	  if (itmp & WCSHDR_IMGHEAD) keysel |= IMGHEAD;
 	  if (itmp & WCSHDR_BIMGARR) keysel |= BIMGARR;
 	  if (itmp & WCSHDR_PIXLIST) keysel |= PIXLIST;
@@ -25993,19 +25948,23 @@ YY_DECL
 	  keysel = IMGHEAD | BINTAB;
 	}
 	
-	/* Control variables. */
-	ipass = 1;
-	npass = 2;
-	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
-	if (setjmp(wcsbth_abort_jmp_env)) {
-	  return 4;
+	// Control variables.
+	int ipass = 1;
+	int npass = 2;
+	
+	// User data associated with yyscanner.
+	yyextra->hdr = header;
+	yyextra->nkeyrec = nkeyrec;
+	
+	// Return here via longjmp() invoked by yy_fatal_error().
+	if (setjmp(yyextra->abort_jmp_env)) {
+	  return WCSHDRERR_PARSER;
 	}
 	
 	BEGIN(INITIAL);
 
 
-#line 26009 "wcsbth.c"
+#line 25968 "wcsbth.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -26053,7 +26012,7 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 366 "wcsbth.l"
+#line 328 "wcsbth.l"
 {
 	  if (ipass == 1) {
 	    if (alts.ncol == 0) {
@@ -26071,10 +26030,10 @@ YY_RULE_SETUP
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 381 "wcsbth.l"
+#line 343 "wcsbth.l"
 {
 	  if (!(keysel & IMGAXIS)) {
-	    /* Ignore this key type. */
+	    // Ignore this key type.
 	    BEGIN(DISCARD);
 	
 	  } else {
@@ -26099,28 +26058,28 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	  }
 	}
 	YY_BREAK
 case 3:
-#line 415 "wcsbth.l"
+#line 377 "wcsbth.l"
 case 4:
-#line 416 "wcsbth.l"
+#line 378 "wcsbth.l"
 case 5:
 YY_RULE_SETUP
-#line 416 "wcsbth.l"
+#line 378 "wcsbth.l"
 {
 	  keyname = "WCAXna";
 	
-	  /* Note that a blank in the sscanf() format string matches zero or
-	     more of them in the input. */
+	  // Note that a blank in the sscanf() format string matches zero or
+	  // more of them in the input.
 	  sscanf(yytext, "WCAX%d%c = %d", &n, &a, &i);
 	
 	  if (!(keysel & BIMGARR) || exclude[n]) {
-	    /* Ignore this key type or column. */
+	    // Ignore this key type or column.
 	    BEGIN(DISCARD);
 	
 	  } else if (i < 0) {
@@ -26139,16 +26098,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 6:
 /* rule 6 can match eol */
-#line 442 "wcsbth.l"
+#line 404 "wcsbth.l"
 case 7:
 /* rule 7 can match eol */
-#line 443 "wcsbth.l"
+#line 405 "wcsbth.l"
 case 8:
 /* rule 8 can match eol */
 YY_RULE_SETUP
-#line 443 "wcsbth.l"
+#line 405 "wcsbth.l"
 {
-	  /* Cross-reference supplier. */
+	  // Cross-reference supplier.
 	  keyname = "WCSTna";
 	  errmsg = "cross-references are not implemented";
 	  BEGIN(ERROR);
@@ -26156,16 +26115,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 9:
 /* rule 9 can match eol */
-#line 451 "wcsbth.l"
+#line 413 "wcsbth.l"
 case 10:
 /* rule 10 can match eol */
-#line 452 "wcsbth.l"
+#line 414 "wcsbth.l"
 case 11:
 /* rule 11 can match eol */
 YY_RULE_SETUP
-#line 452 "wcsbth.l"
+#line 414 "wcsbth.l"
 {
-	  /* Cross-reference consumer. */
+	  // Cross-reference consumer.
 	  keyname = "WCSXna";
 	  errmsg = "cross-references are not implemented";
 	  BEGIN(ERROR);
@@ -26173,7 +26132,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 459 "wcsbth.l"
+#line 421 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crpix);
@@ -26183,10 +26142,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 13:
-#line 468 "wcsbth.l"
+#line 430 "wcsbth.l"
 case 14:
 YY_RULE_SETUP
-#line 468 "wcsbth.l"
+#line 430 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crpix);
@@ -26203,10 +26162,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 15:
-#line 484 "wcsbth.l"
+#line 446 "wcsbth.l"
 case 16:
 YY_RULE_SETUP
-#line 484 "wcsbth.l"
+#line 446 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crpix);
@@ -26222,7 +26181,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 497 "wcsbth.l"
+#line 459 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pc);
@@ -26234,7 +26193,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 506 "wcsbth.l"
+#line 468 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pc);
@@ -26247,10 +26206,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 19:
-#line 518 "wcsbth.l"
+#line 480 "wcsbth.l"
 case 20:
 YY_RULE_SETUP
-#line 518 "wcsbth.l"
+#line 480 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pc);
@@ -26267,7 +26226,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 532 "wcsbth.l"
+#line 494 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cd);
@@ -26279,7 +26238,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 541 "wcsbth.l"
+#line 503 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cd);
@@ -26292,10 +26251,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 23:
-#line 553 "wcsbth.l"
+#line 515 "wcsbth.l"
 case 24:
 YY_RULE_SETUP
-#line 553 "wcsbth.l"
+#line 515 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cd);
@@ -26312,7 +26271,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 567 "wcsbth.l"
+#line 529 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cdelt);
@@ -26322,10 +26281,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 26:
-#line 576 "wcsbth.l"
+#line 538 "wcsbth.l"
 case 27:
 YY_RULE_SETUP
-#line 576 "wcsbth.l"
+#line 538 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cdelt);
@@ -26342,10 +26301,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 28:
-#line 592 "wcsbth.l"
+#line 554 "wcsbth.l"
 case 29:
 YY_RULE_SETUP
-#line 592 "wcsbth.l"
+#line 554 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cdelt);
@@ -26361,7 +26320,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 605 "wcsbth.l"
+#line 567 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crota);
@@ -26373,7 +26332,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 614 "wcsbth.l"
+#line 576 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crota);
@@ -26387,7 +26346,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 625 "wcsbth.l"
+#line 587 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crota);
@@ -26399,7 +26358,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 634 "wcsbth.l"
+#line 596 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cunit);
@@ -26409,10 +26368,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 34:
-#line 643 "wcsbth.l"
+#line 605 "wcsbth.l"
 case 35:
 YY_RULE_SETUP
-#line 643 "wcsbth.l"
+#line 605 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cunit);
@@ -26429,10 +26388,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 36:
-#line 659 "wcsbth.l"
+#line 621 "wcsbth.l"
 case 37:
 YY_RULE_SETUP
-#line 659 "wcsbth.l"
+#line 621 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cunit);
@@ -26448,7 +26407,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 672 "wcsbth.l"
+#line 634 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ctype);
@@ -26458,10 +26417,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 39:
-#line 681 "wcsbth.l"
+#line 643 "wcsbth.l"
 case 40:
 YY_RULE_SETUP
-#line 681 "wcsbth.l"
+#line 643 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ctype);
@@ -26478,10 +26437,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 41:
-#line 697 "wcsbth.l"
+#line 659 "wcsbth.l"
 case 42:
 YY_RULE_SETUP
-#line 697 "wcsbth.l"
+#line 659 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ctype);
@@ -26497,7 +26456,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 710 "wcsbth.l"
+#line 672 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crval);
@@ -26507,10 +26466,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 44:
-#line 719 "wcsbth.l"
+#line 681 "wcsbth.l"
 case 45:
 YY_RULE_SETUP
-#line 719 "wcsbth.l"
+#line 681 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crval);
@@ -26527,10 +26486,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 46:
-#line 735 "wcsbth.l"
+#line 697 "wcsbth.l"
 case 47:
 YY_RULE_SETUP
-#line 735 "wcsbth.l"
+#line 697 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crval);
@@ -26545,10 +26504,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 48:
-#line 749 "wcsbth.l"
+#line 711 "wcsbth.l"
 case 49:
 YY_RULE_SETUP
-#line 749 "wcsbth.l"
+#line 711 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.lonpole);
@@ -26564,10 +26523,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 50:
-#line 764 "wcsbth.l"
+#line 726 "wcsbth.l"
 case 51:
 YY_RULE_SETUP
-#line 764 "wcsbth.l"
+#line 726 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.latpole);
@@ -26583,12 +26542,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 52:
-#line 779 "wcsbth.l"
+#line 741 "wcsbth.l"
 case 53:
-#line 780 "wcsbth.l"
+#line 742 "wcsbth.l"
 case 54:
 YY_RULE_SETUP
-#line 780 "wcsbth.l"
+#line 742 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.restfrq);
@@ -26616,10 +26575,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 55:
-#line 807 "wcsbth.l"
+#line 769 "wcsbth.l"
 case 56:
 YY_RULE_SETUP
-#line 807 "wcsbth.l"
+#line 769 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.restwav);
@@ -26635,7 +26594,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 820 "wcsbth.l"
+#line 782 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -26646,10 +26605,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 58:
-#line 830 "wcsbth.l"
+#line 792 "wcsbth.l"
 case 59:
 YY_RULE_SETUP
-#line 830 "wcsbth.l"
+#line 792 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -26667,10 +26626,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 60:
-#line 847 "wcsbth.l"
+#line 809 "wcsbth.l"
 case 61:
 YY_RULE_SETUP
-#line 847 "wcsbth.l"
+#line 809 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -26687,7 +26646,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 861 "wcsbth.l"
+#line 823 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -26699,7 +26658,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 870 "wcsbth.l"
+#line 832 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ps);
@@ -26710,10 +26669,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 64:
-#line 880 "wcsbth.l"
+#line 842 "wcsbth.l"
 case 65:
 YY_RULE_SETUP
-#line 880 "wcsbth.l"
+#line 842 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ps);
@@ -26731,10 +26690,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 66:
-#line 897 "wcsbth.l"
+#line 859 "wcsbth.l"
 case 67:
 YY_RULE_SETUP
-#line 897 "wcsbth.l"
+#line 859 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ps);
@@ -26751,7 +26710,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 911 "wcsbth.l"
+#line 873 "wcsbth.l"
 {
 	  sscanf(yytext, "VELREF%c", &a);
 	
@@ -26780,7 +26739,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 937 "wcsbth.l"
+#line 899 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cname);
@@ -26790,10 +26749,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 70:
-#line 946 "wcsbth.l"
+#line 908 "wcsbth.l"
 case 71:
 YY_RULE_SETUP
-#line 946 "wcsbth.l"
+#line 908 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cname);
@@ -26811,10 +26770,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 72:
-#line 963 "wcsbth.l"
+#line 925 "wcsbth.l"
 case 73:
 YY_RULE_SETUP
-#line 963 "wcsbth.l"
+#line 925 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cname);
@@ -26831,7 +26790,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 977 "wcsbth.l"
+#line 939 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crder);
@@ -26841,10 +26800,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 75:
-#line 986 "wcsbth.l"
+#line 948 "wcsbth.l"
 case 76:
 YY_RULE_SETUP
-#line 986 "wcsbth.l"
+#line 948 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crder);
@@ -26862,10 +26821,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 77:
-#line 1003 "wcsbth.l"
+#line 965 "wcsbth.l"
 case 78:
 YY_RULE_SETUP
-#line 1003 "wcsbth.l"
+#line 965 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crder);
@@ -26882,7 +26841,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 1017 "wcsbth.l"
+#line 979 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.csyer);
@@ -26892,10 +26851,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 80:
-#line 1026 "wcsbth.l"
+#line 988 "wcsbth.l"
 case 81:
 YY_RULE_SETUP
-#line 1026 "wcsbth.l"
+#line 988 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.csyer);
@@ -26913,10 +26872,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 82:
-#line 1043 "wcsbth.l"
+#line 1005 "wcsbth.l"
 case 83:
 YY_RULE_SETUP
-#line 1043 "wcsbth.l"
+#line 1005 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.csyer);
@@ -26933,7 +26892,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 1057 "wcsbth.l"
+#line 1019 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.czphs);
@@ -26943,10 +26902,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 85:
-#line 1066 "wcsbth.l"
+#line 1028 "wcsbth.l"
 case 86:
 YY_RULE_SETUP
-#line 1066 "wcsbth.l"
+#line 1028 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.czphs);
@@ -26964,10 +26923,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 87:
-#line 1083 "wcsbth.l"
+#line 1045 "wcsbth.l"
 case 88:
 YY_RULE_SETUP
-#line 1083 "wcsbth.l"
+#line 1045 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.czphs);
@@ -26984,7 +26943,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 1097 "wcsbth.l"
+#line 1059 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cperi);
@@ -26994,10 +26953,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 90:
-#line 1106 "wcsbth.l"
+#line 1068 "wcsbth.l"
 case 91:
 YY_RULE_SETUP
-#line 1106 "wcsbth.l"
+#line 1068 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cperi);
@@ -27015,10 +26974,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 92:
-#line 1123 "wcsbth.l"
+#line 1085 "wcsbth.l"
 case 93:
 YY_RULE_SETUP
-#line 1123 "wcsbth.l"
+#line 1085 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cperi);
@@ -27034,12 +26993,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 94:
-#line 1138 "wcsbth.l"
+#line 1100 "wcsbth.l"
 case 95:
-#line 1139 "wcsbth.l"
+#line 1101 "wcsbth.l"
 case 96:
 YY_RULE_SETUP
-#line 1139 "wcsbth.l"
+#line 1101 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.wcsname;
@@ -27061,7 +27020,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 1158 "wcsbth.l"
+#line 1120 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.timesys;
@@ -27071,10 +27030,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 98:
-#line 1167 "wcsbth.l"
+#line 1129 "wcsbth.l"
 case 99:
 YY_RULE_SETUP
-#line 1167 "wcsbth.l"
+#line 1129 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.trefpos;
@@ -27090,10 +27049,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 100:
-#line 1182 "wcsbth.l"
+#line 1144 "wcsbth.l"
 case 101:
 YY_RULE_SETUP
-#line 1182 "wcsbth.l"
+#line 1144 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.trefdir;
@@ -27110,7 +27069,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 1196 "wcsbth.l"
+#line 1158 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.plephem;
@@ -27121,7 +27080,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 1204 "wcsbth.l"
+#line 1166 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.timeunit;
@@ -27131,10 +27090,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 104:
-#line 1213 "wcsbth.l"
+#line 1175 "wcsbth.l"
 case 105:
 YY_RULE_SETUP
-#line 1213 "wcsbth.l"
+#line 1175 "wcsbth.l"
 {
 	  if ((yytext[4] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = STRING;
@@ -27153,10 +27112,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 106:
-#line 1231 "wcsbth.l"
+#line 1193 "wcsbth.l"
 case 107:
 YY_RULE_SETUP
-#line 1231 "wcsbth.l"
+#line 1193 "wcsbth.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT2;
@@ -27175,13 +27134,13 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 108:
-#line 1249 "wcsbth.l"
+#line 1211 "wcsbth.l"
 case 109:
 YY_RULE_SETUP
-#line 1249 "wcsbth.l"
+#line 1211 "wcsbth.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	
@@ -27198,10 +27157,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 110:
-#line 1268 "wcsbth.l"
+#line 1230 "wcsbth.l"
 case 111:
 YY_RULE_SETUP
-#line 1268 "wcsbth.l"
+#line 1230 "wcsbth.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT;
@@ -27220,10 +27179,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 112:
-#line 1286 "wcsbth.l"
+#line 1248 "wcsbth.l"
 case 113:
 YY_RULE_SETUP
-#line 1286 "wcsbth.l"
+#line 1248 "wcsbth.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT2;
@@ -27243,13 +27202,13 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 114:
-#line 1305 "wcsbth.l"
+#line 1267 "wcsbth.l"
 case 115:
 YY_RULE_SETUP
-#line 1305 "wcsbth.l"
+#line 1267 "wcsbth.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	    special = wcsbth_jdrefi;
@@ -27267,10 +27226,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 116:
-#line 1325 "wcsbth.l"
+#line 1287 "wcsbth.l"
 case 117:
 YY_RULE_SETUP
-#line 1325 "wcsbth.l"
+#line 1287 "wcsbth.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT;
@@ -27291,7 +27250,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 1343 "wcsbth.l"
+#line 1305 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timeoffs);
@@ -27302,7 +27261,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 1351 "wcsbth.l"
+#line 1313 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateobs;
@@ -27314,12 +27273,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 120:
-#line 1362 "wcsbth.l"
+#line 1324 "wcsbth.l"
 case 121:
-#line 1363 "wcsbth.l"
+#line 1325 "wcsbth.l"
 case 122:
 YY_RULE_SETUP
-#line 1363 "wcsbth.l"
+#line 1325 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateobs;
@@ -27341,7 +27300,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-#line 1382 "wcsbth.l"
+#line 1344 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.datebeg;
@@ -27352,10 +27311,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 124:
-#line 1392 "wcsbth.l"
+#line 1354 "wcsbth.l"
 case 125:
 YY_RULE_SETUP
-#line 1392 "wcsbth.l"
+#line 1354 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateavg;
@@ -27372,7 +27331,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 126:
 YY_RULE_SETUP
-#line 1406 "wcsbth.l"
+#line 1368 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateend;
@@ -27383,10 +27342,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 127:
-#line 1416 "wcsbth.l"
+#line 1378 "wcsbth.l"
 case 128:
 YY_RULE_SETUP
-#line 1416 "wcsbth.l"
+#line 1378 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdobs);
@@ -27404,7 +27363,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 129:
 YY_RULE_SETUP
-#line 1431 "wcsbth.l"
+#line 1393 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdbeg);
@@ -27415,10 +27374,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 130:
-#line 1441 "wcsbth.l"
+#line 1403 "wcsbth.l"
 case 131:
 YY_RULE_SETUP
-#line 1441 "wcsbth.l"
+#line 1403 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdavg);
@@ -27435,7 +27394,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 132:
 YY_RULE_SETUP
-#line 1455 "wcsbth.l"
+#line 1417 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdend);
@@ -27447,7 +27406,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 133:
 YY_RULE_SETUP
-#line 1464 "wcsbth.l"
+#line 1426 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.jepoch);
@@ -27459,7 +27418,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 134:
 YY_RULE_SETUP
-#line 1473 "wcsbth.l"
+#line 1435 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.bepoch);
@@ -27471,7 +27430,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 135:
 YY_RULE_SETUP
-#line 1482 "wcsbth.l"
+#line 1444 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.tstart);
@@ -27483,7 +27442,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 136:
 YY_RULE_SETUP
-#line 1491 "wcsbth.l"
+#line 1453 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.tstop);
@@ -27495,7 +27454,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 137:
 YY_RULE_SETUP
-#line 1500 "wcsbth.l"
+#line 1462 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.xposure);
@@ -27507,7 +27466,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 138:
 YY_RULE_SETUP
-#line 1509 "wcsbth.l"
+#line 1471 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.telapse);
@@ -27519,7 +27478,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 139:
 YY_RULE_SETUP
-#line 1518 "wcsbth.l"
+#line 1480 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timsyer);
@@ -27531,7 +27490,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 140:
 YY_RULE_SETUP
-#line 1527 "wcsbth.l"
+#line 1489 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timrder);
@@ -27543,7 +27502,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 141:
 YY_RULE_SETUP
-#line 1536 "wcsbth.l"
+#line 1498 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timedel);
@@ -27555,7 +27514,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 142:
 YY_RULE_SETUP
-#line 1545 "wcsbth.l"
+#line 1507 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timepixr);
@@ -27567,10 +27526,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 143:
-#line 1556 "wcsbth.l"
+#line 1518 "wcsbth.l"
 case 144:
 YY_RULE_SETUP
-#line 1556 "wcsbth.l"
+#line 1518 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo;
@@ -27586,10 +27545,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 145:
-#line 1571 "wcsbth.l"
+#line 1533 "wcsbth.l"
 case 146:
 YY_RULE_SETUP
-#line 1571 "wcsbth.l"
+#line 1533 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 1;
@@ -27605,10 +27564,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 147:
-#line 1586 "wcsbth.l"
+#line 1548 "wcsbth.l"
 case 148:
 YY_RULE_SETUP
-#line 1586 "wcsbth.l"
+#line 1548 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 2;
@@ -27625,7 +27584,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 149:
 YY_RULE_SETUP
-#line 1600 "wcsbth.l"
+#line 1562 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 3;
@@ -27636,12 +27595,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 150:
-#line 1610 "wcsbth.l"
+#line 1572 "wcsbth.l"
 case 151:
-#line 1611 "wcsbth.l"
+#line 1573 "wcsbth.l"
 case 152:
 YY_RULE_SETUP
-#line 1611 "wcsbth.l"
+#line 1573 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.obsgeo + 3;
@@ -27663,7 +27622,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 153:
 YY_RULE_SETUP
-#line 1630 "wcsbth.l"
+#line 1592 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 4;
@@ -27674,12 +27633,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 154:
-#line 1640 "wcsbth.l"
+#line 1602 "wcsbth.l"
 case 155:
-#line 1641 "wcsbth.l"
+#line 1603 "wcsbth.l"
 case 156:
 YY_RULE_SETUP
-#line 1641 "wcsbth.l"
+#line 1603 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.obsgeo + 3;
@@ -27701,7 +27660,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 157:
 YY_RULE_SETUP
-#line 1660 "wcsbth.l"
+#line 1622 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 5;
@@ -27712,12 +27671,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 158:
-#line 1670 "wcsbth.l"
+#line 1632 "wcsbth.l"
 case 159:
-#line 1671 "wcsbth.l"
+#line 1633 "wcsbth.l"
 case 160:
 YY_RULE_SETUP
-#line 1671 "wcsbth.l"
+#line 1633 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.obsgeo + 3;
@@ -27739,7 +27698,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 161:
 YY_RULE_SETUP
-#line 1690 "wcsbth.l"
+#line 1652 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.obsorbit;
@@ -27749,10 +27708,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 162:
-#line 1699 "wcsbth.l"
+#line 1661 "wcsbth.l"
 case 163:
 YY_RULE_SETUP
-#line 1699 "wcsbth.l"
+#line 1661 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.radesys;
@@ -27769,7 +27728,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 164:
 YY_RULE_SETUP
-#line 1713 "wcsbth.l"
+#line 1675 "wcsbth.l"
 {
 	  if (relax & WCSHDR_RADECSYS) {
 	    valtype = STRING;
@@ -27792,7 +27751,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 165:
 YY_RULE_SETUP
-#line 1733 "wcsbth.l"
+#line 1695 "wcsbth.l"
 {
 	  sscanf(yytext, "EPOCH%c", &a);
 	
@@ -27821,10 +27780,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 166:
-#line 1761 "wcsbth.l"
+#line 1723 "wcsbth.l"
 case 167:
 YY_RULE_SETUP
-#line 1761 "wcsbth.l"
+#line 1723 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.equinox);
@@ -27840,10 +27799,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 168:
-#line 1776 "wcsbth.l"
+#line 1738 "wcsbth.l"
 case 169:
 YY_RULE_SETUP
-#line 1776 "wcsbth.l"
+#line 1738 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.specsys;
@@ -27858,10 +27817,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 170:
-#line 1790 "wcsbth.l"
+#line 1752 "wcsbth.l"
 case 171:
 YY_RULE_SETUP
-#line 1790 "wcsbth.l"
+#line 1752 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.ssysobs;
@@ -27876,10 +27835,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 172:
-#line 1804 "wcsbth.l"
+#line 1766 "wcsbth.l"
 case 173:
 YY_RULE_SETUP
-#line 1804 "wcsbth.l"
+#line 1766 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.velosys);
@@ -27895,7 +27854,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 174:
 YY_RULE_SETUP
-#line 1817 "wcsbth.l"
+#line 1779 "wcsbth.l"
 {
 	  if (relax & WCSHDR_VSOURCE) {
 	    valtype = FLOAT;
@@ -27917,12 +27876,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 175:
-#line 1838 "wcsbth.l"
+#line 1800 "wcsbth.l"
 case 176:
-#line 1839 "wcsbth.l"
+#line 1801 "wcsbth.l"
 case 177:
 YY_RULE_SETUP
-#line 1839 "wcsbth.l"
+#line 1801 "wcsbth.l"
 {
 	  if (relax & WCSHDR_VSOURCE) {
 	    valtype = FLOAT;
@@ -27938,16 +27897,16 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 178:
-#line 1860 "wcsbth.l"
+#line 1822 "wcsbth.l"
 case 179:
 YY_RULE_SETUP
-#line 1860 "wcsbth.l"
+#line 1822 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.zsource);
@@ -27962,10 +27921,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 180:
-#line 1874 "wcsbth.l"
+#line 1836 "wcsbth.l"
 case 181:
 YY_RULE_SETUP
-#line 1874 "wcsbth.l"
+#line 1836 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.ssyssrc;
@@ -27980,10 +27939,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 182:
-#line 1888 "wcsbth.l"
+#line 1850 "wcsbth.l"
 case 183:
 YY_RULE_SETUP
-#line 1888 "wcsbth.l"
+#line 1850 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.velangl);
@@ -27999,7 +27958,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 184:
 YY_RULE_SETUP
-#line 1901 "wcsbth.l"
+#line 1863 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -28011,7 +27970,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 185:
 YY_RULE_SETUP
-#line 1910 "wcsbth.l"
+#line 1872 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -28023,7 +27982,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 186:
 YY_RULE_SETUP
-#line 1919 "wcsbth.l"
+#line 1881 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -28035,7 +27994,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 187:
 YY_RULE_SETUP
-#line 1928 "wcsbth.l"
+#line 1890 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -28046,10 +28005,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 188:
-#line 1938 "wcsbth.l"
+#line 1900 "wcsbth.l"
 case 189:
 YY_RULE_SETUP
-#line 1938 "wcsbth.l"
+#line 1900 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -28061,10 +28020,10 @@ YY_RULE_SETUP
 	YY_BREAK
 case 190:
 YY_RULE_SETUP
-#line 1947 "wcsbth.l"
+#line 1909 "wcsbth.l"
 {
-	  if (wcsbth_nkeyrec) {
-	    wcsbth_nkeyrec = 0;
+	  if (yyextra->nkeyrec) {
+	    yyextra->nkeyrec = 0;
 	    errmsg = "keyrecords following the END keyrecord were ignored";
 	    BEGIN(ERROR);
 	  } else {
@@ -28074,16 +28033,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 191:
 YY_RULE_SETUP
-#line 1957 "wcsbth.l"
+#line 1919 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 192:
-#line 1962 "wcsbth.l"
+#line 1924 "wcsbth.l"
 case 193:
 YY_RULE_SETUP
-#line 1962 "wcsbth.l"
+#line 1924 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    sscanf(yytext, "%d%c", &i, &a);
@@ -28097,26 +28056,26 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 194:
-#line 1981 "wcsbth.l"
+#line 1943 "wcsbth.l"
 case 195:
 YY_RULE_SETUP
-#line 1981 "wcsbth.l"
+#line 1943 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (relax & WCSHDR_reject) {
-	      /* Violates the basic FITS standard. */
+	      // Violates the basic FITS standard.
 	      errmsg = "indices in parameterized keywords must not have "
 	               "leading zeroes";
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -28127,21 +28086,21 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 196:
-#line 2007 "wcsbth.l"
+#line 1969 "wcsbth.l"
 case 197:
-#line 2008 "wcsbth.l"
+#line 1970 "wcsbth.l"
 case 198:
 YY_RULE_SETUP
-#line 2008 "wcsbth.l"
+#line 1970 "wcsbth.l"
 {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  if (relax & WCSHDR_ALLIMG) {
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
@@ -28153,41 +28112,41 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 199:
 YY_RULE_SETUP
-#line 2027 "wcsbth.l"
+#line 1989 "wcsbth.l"
 {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "keyword looks very much like %s but isn't",
 	      keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 200:
-#line 2042 "wcsbth.l"
+#line 2004 "wcsbth.l"
 case 201:
-#line 2043 "wcsbth.l"
+#line 2005 "wcsbth.l"
 case 202:
-#line 2044 "wcsbth.l"
+#line 2006 "wcsbth.l"
 case 203:
-#line 2045 "wcsbth.l"
+#line 2007 "wcsbth.l"
 case 204:
-#line 2046 "wcsbth.l"
+#line 2008 "wcsbth.l"
 case 205:
 YY_RULE_SETUP
-#line 2046 "wcsbth.l"
+#line 2008 "wcsbth.l"
 {
 	  if (vptr) {
 	    WCSBTH_PUTBACK;
@@ -28204,14 +28163,14 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 206:
-#line 2062 "wcsbth.l"
+#line 2024 "wcsbth.l"
 case 207:
-#line 2063 "wcsbth.l"
+#line 2025 "wcsbth.l"
 case 208:
-#line 2064 "wcsbth.l"
+#line 2026 "wcsbth.l"
 case 209:
 YY_RULE_SETUP
-#line 2064 "wcsbth.l"
+#line 2026 "wcsbth.l"
 {
 	  if (vptr && (relax & WCSHDR_LONGKEY)) {
 	    WCSBTH_PUTBACK;
@@ -28228,33 +28187,33 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 210:
-#line 2086 "wcsbth.l"
+#line 2048 "wcsbth.l"
 case 211:
 YY_RULE_SETUP
-#line 2086 "wcsbth.l"
+#line 2048 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 212:
-#line 2091 "wcsbth.l"
+#line 2053 "wcsbth.l"
 case 213:
-#line 2092 "wcsbth.l"
+#line 2054 "wcsbth.l"
 case 214:
-#line 2093 "wcsbth.l"
+#line 2055 "wcsbth.l"
 case 215:
-#line 2094 "wcsbth.l"
+#line 2056 "wcsbth.l"
 case 216:
-#line 2095 "wcsbth.l"
+#line 2057 "wcsbth.l"
 case 217:
 YY_RULE_SETUP
-#line 2095 "wcsbth.l"
+#line 2057 "wcsbth.l"
 {
 	  sscanf(yytext, "%d%c", &n, &a);
 	  if (YY_START == TCCCna) i = wcsbth_colax(*wcs, &alts, n, a);
@@ -28263,23 +28222,23 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 218:
-#line 2103 "wcsbth.l"
+#line 2065 "wcsbth.l"
 case 219:
 YY_RULE_SETUP
-#line 2103 "wcsbth.l"
+#line 2065 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 220:
-#line 2108 "wcsbth.l"
+#line 2070 "wcsbth.l"
 case 221:
-#line 2109 "wcsbth.l"
+#line 2071 "wcsbth.l"
 case 222:
-#line 2110 "wcsbth.l"
+#line 2072 "wcsbth.l"
 case 223:
 YY_RULE_SETUP
-#line 2110 "wcsbth.l"
+#line 2072 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    sscanf(yytext, "%d_%d%c", &i, &j, &a);
@@ -28293,54 +28252,54 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 224:
-#line 2129 "wcsbth.l"
+#line 2091 "wcsbth.l"
 case 225:
-#line 2130 "wcsbth.l"
+#line 2092 "wcsbth.l"
 case 226:
-#line 2131 "wcsbth.l"
+#line 2093 "wcsbth.l"
 case 227:
-#line 2132 "wcsbth.l"
+#line 2094 "wcsbth.l"
 case 228:
-#line 2133 "wcsbth.l"
+#line 2095 "wcsbth.l"
 case 229:
-#line 2134 "wcsbth.l"
+#line 2096 "wcsbth.l"
 case 230:
-#line 2135 "wcsbth.l"
+#line 2097 "wcsbth.l"
 case 231:
-#line 2136 "wcsbth.l"
+#line 2098 "wcsbth.l"
 case 232:
-#line 2137 "wcsbth.l"
+#line 2099 "wcsbth.l"
 case 233:
-#line 2138 "wcsbth.l"
+#line 2100 "wcsbth.l"
 case 234:
-#line 2139 "wcsbth.l"
+#line 2101 "wcsbth.l"
 case 235:
-#line 2140 "wcsbth.l"
+#line 2102 "wcsbth.l"
 case 236:
-#line 2141 "wcsbth.l"
+#line 2103 "wcsbth.l"
 case 237:
-#line 2142 "wcsbth.l"
+#line 2104 "wcsbth.l"
 case 238:
-#line 2143 "wcsbth.l"
+#line 2105 "wcsbth.l"
 case 239:
-#line 2144 "wcsbth.l"
+#line 2106 "wcsbth.l"
 case 240:
-#line 2145 "wcsbth.l"
+#line 2107 "wcsbth.l"
 case 241:
-#line 2146 "wcsbth.l"
+#line 2108 "wcsbth.l"
 case 242:
-#line 2147 "wcsbth.l"
+#line 2109 "wcsbth.l"
 case 243:
-#line 2148 "wcsbth.l"
+#line 2110 "wcsbth.l"
 case 244:
 YY_RULE_SETUP
-#line 2148 "wcsbth.l"
+#line 2110 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (((altlin == 1) && (relax & WCSHDR_PC0i_0ja)) ||
@@ -28355,7 +28314,7 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -28366,35 +28325,35 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 245:
-#line 2179 "wcsbth.l"
+#line 2141 "wcsbth.l"
 case 246:
-#line 2180 "wcsbth.l"
+#line 2142 "wcsbth.l"
 case 247:
-#line 2181 "wcsbth.l"
+#line 2143 "wcsbth.l"
 case 248:
-#line 2182 "wcsbth.l"
+#line 2144 "wcsbth.l"
 case 249:
-#line 2183 "wcsbth.l"
+#line 2145 "wcsbth.l"
 case 250:
-#line 2184 "wcsbth.l"
+#line 2146 "wcsbth.l"
 case 251:
-#line 2185 "wcsbth.l"
+#line 2147 "wcsbth.l"
 case 252:
-#line 2186 "wcsbth.l"
+#line 2148 "wcsbth.l"
 case 253:
-#line 2187 "wcsbth.l"
+#line 2149 "wcsbth.l"
 case 254:
 YY_RULE_SETUP
-#line 2187 "wcsbth.l"
+#line 2149 "wcsbth.l"
 {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  if (relax & WCSHDR_ALLIMG) {
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
@@ -28406,32 +28365,32 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 255:
-#line 2207 "wcsbth.l"
+#line 2169 "wcsbth.l"
 case 256:
-#line 2208 "wcsbth.l"
+#line 2170 "wcsbth.l"
 case 257:
-#line 2209 "wcsbth.l"
+#line 2171 "wcsbth.l"
 case 258:
-#line 2210 "wcsbth.l"
+#line 2172 "wcsbth.l"
 case 259:
-#line 2211 "wcsbth.l"
+#line 2173 "wcsbth.l"
 case 260:
-#line 2212 "wcsbth.l"
+#line 2174 "wcsbth.l"
 case 261:
-#line 2213 "wcsbth.l"
+#line 2175 "wcsbth.l"
 case 262:
-#line 2214 "wcsbth.l"
+#line 2176 "wcsbth.l"
 case 263:
-#line 2215 "wcsbth.l"
+#line 2177 "wcsbth.l"
 case 264:
 YY_RULE_SETUP
-#line 2215 "wcsbth.l"
+#line 2177 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    errmsg = errtxt;
@@ -28446,16 +28405,16 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 265:
 YY_RULE_SETUP
-#line 2234 "wcsbth.l"
+#line 2196 "wcsbth.l"
 {
-	  /* This covers the defunct forms CD00i00j and PC00i00j. */
+	  // This covers the defunct forms CD00i00j and PC00i00j.
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (((altlin == 1) && (relax & WCSHDR_PC00i00j)) ||
 	        ((altlin == 2) && (relax & WCSHDR_CD00i00j))) {
@@ -28472,7 +28431,7 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -28483,25 +28442,25 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 266:
 YY_RULE_SETUP
-#line 2268 "wcsbth.l"
+#line 2230 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 267:
-#line 2273 "wcsbth.l"
+#line 2235 "wcsbth.l"
 case 268:
-#line 2274 "wcsbth.l"
+#line 2236 "wcsbth.l"
 case 269:
 YY_RULE_SETUP
-#line 2274 "wcsbth.l"
+#line 2236 "wcsbth.l"
 {
 	  sscanf(yytext, "%d%c", &n, &a);
 	  keytype = BIMGARR;
@@ -28509,18 +28468,18 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 270:
-#line 2281 "wcsbth.l"
+#line 2243 "wcsbth.l"
 case 271:
-#line 2282 "wcsbth.l"
+#line 2244 "wcsbth.l"
 case 272:
-#line 2283 "wcsbth.l"
+#line 2245 "wcsbth.l"
 case 273:
-#line 2284 "wcsbth.l"
+#line 2246 "wcsbth.l"
 case 274:
-#line 2285 "wcsbth.l"
+#line 2247 "wcsbth.l"
 case 275:
 YY_RULE_SETUP
-#line 2285 "wcsbth.l"
+#line 2247 "wcsbth.l"
 {
 	  if (relax & WCSHDR_LONGKEY) {
 	    WCSBTH_PUTBACK;
@@ -28532,31 +28491,31 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 276:
 YY_RULE_SETUP
-#line 2301 "wcsbth.l"
+#line 2263 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 277:
-#line 2306 "wcsbth.l"
+#line 2268 "wcsbth.l"
 case 278:
-#line 2307 "wcsbth.l"
+#line 2269 "wcsbth.l"
 case 279:
-#line 2308 "wcsbth.l"
+#line 2270 "wcsbth.l"
 case 280:
-#line 2309 "wcsbth.l"
+#line 2271 "wcsbth.l"
 case 281:
-#line 2310 "wcsbth.l"
+#line 2272 "wcsbth.l"
 case 282:
 YY_RULE_SETUP
-#line 2310 "wcsbth.l"
+#line 2272 "wcsbth.l"
 {
 	  sscanf(yytext, "%d_%d%c", &n, &k, &a);
 	  i = wcsbth_colax(*wcs, &alts, n, a);
@@ -28566,14 +28525,14 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 283:
-#line 2319 "wcsbth.l"
+#line 2281 "wcsbth.l"
 case 284:
-#line 2320 "wcsbth.l"
+#line 2282 "wcsbth.l"
 case 285:
-#line 2321 "wcsbth.l"
+#line 2283 "wcsbth.l"
 case 286:
 YY_RULE_SETUP
-#line 2321 "wcsbth.l"
+#line 2283 "wcsbth.l"
 {
 	  sscanf(yytext, "%d_%d", &n, &k);
 	  a = ' ';
@@ -28585,18 +28544,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 287:
 YY_RULE_SETUP
-#line 2330 "wcsbth.l"
+#line 2292 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 288:
-#line 2335 "wcsbth.l"
+#line 2297 "wcsbth.l"
 case 289:
-#line 2336 "wcsbth.l"
+#line 2298 "wcsbth.l"
 case 290:
 YY_RULE_SETUP
-#line 2336 "wcsbth.l"
+#line 2298 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    a = ' ';
@@ -28615,7 +28574,7 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -28626,51 +28585,51 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 291:
 YY_RULE_SETUP
-#line 2370 "wcsbth.l"
+#line 2332 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    yyless(0);
 	    BEGIN(CCCCCia);
 	  } else {
-	    /* Let it go. */
+	    // Let it go.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 292:
-#line 2381 "wcsbth.l"
+#line 2343 "wcsbth.l"
 case 293:
-#line 2382 "wcsbth.l"
+#line 2344 "wcsbth.l"
 case 294:
-#line 2383 "wcsbth.l"
+#line 2345 "wcsbth.l"
 case 295:
-#line 2384 "wcsbth.l"
+#line 2346 "wcsbth.l"
 case 296:
-#line 2385 "wcsbth.l"
+#line 2347 "wcsbth.l"
 case 297:
 YY_RULE_SETUP
-#line 2385 "wcsbth.l"
+#line 2347 "wcsbth.l"
 {
 	  WCSBTH_PUTBACK;
 	  BEGIN((YY_START == iCROTn) ? iCCCna : TCCCna);
 	}
 	YY_BREAK
 case 298:
-#line 2391 "wcsbth.l"
+#line 2353 "wcsbth.l"
 case 299:
-#line 2392 "wcsbth.l"
+#line 2354 "wcsbth.l"
 case 300:
-#line 2393 "wcsbth.l"
+#line 2355 "wcsbth.l"
 case 301:
 YY_RULE_SETUP
-#line 2393 "wcsbth.l"
+#line 2355 "wcsbth.l"
 {
 	  if (relax & WCSHDR_CROTAia) {
 	    WCSBTH_PUTBACK;
@@ -28683,27 +28642,27 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 302:
-#line 2411 "wcsbth.l"
+#line 2373 "wcsbth.l"
 case 303:
 YY_RULE_SETUP
-#line 2411 "wcsbth.l"
+#line 2373 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 304:
-#line 2416 "wcsbth.l"
+#line 2378 "wcsbth.l"
 case 305:
 YY_RULE_SETUP
-#line 2416 "wcsbth.l"
+#line 2378 "wcsbth.l"
 {
-	  /* Image-header keyword. */
+	  // Image-header keyword.
 	  if (imherit || (relax & (WCSHDR_AUXIMG | WCSHDR_ALLIMG))) {
 	    if (YY_START == CCCCCCCa) {
 	      sscanf(yytext, "%c", &a);
@@ -28721,39 +28680,39 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 306:
 YY_RULE_SETUP
-#line 2440 "wcsbth.l"
+#line 2402 "wcsbth.l"
 {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "invalid alternate code, keyword resembles %s "
 	      "but isn't", keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 307:
-#line 2455 "wcsbth.l"
+#line 2417 "wcsbth.l"
 case 308:
-#line 2456 "wcsbth.l"
+#line 2418 "wcsbth.l"
 case 309:
-#line 2457 "wcsbth.l"
+#line 2419 "wcsbth.l"
 case 310:
-#line 2458 "wcsbth.l"
+#line 2420 "wcsbth.l"
 case 311:
 YY_RULE_SETUP
-#line 2458 "wcsbth.l"
+#line 2420 "wcsbth.l"
 {
 	  sscanf(yytext, "%d%c", &n, &a);
 	  keytype = BINTAB;
@@ -28762,7 +28721,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 312:
 YY_RULE_SETUP
-#line 2464 "wcsbth.l"
+#line 2426 "wcsbth.l"
 {
 	  sscanf(yytext, "%d", &n);
 	  a = ' ';
@@ -28771,29 +28730,29 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 313:
-#line 2472 "wcsbth.l"
+#line 2434 "wcsbth.l"
 case 314:
 YY_RULE_SETUP
-#line 2472 "wcsbth.l"
+#line 2434 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 315:
-#line 2477 "wcsbth.l"
+#line 2439 "wcsbth.l"
 case 316:
-#line 2478 "wcsbth.l"
+#line 2440 "wcsbth.l"
 case 317:
-#line 2479 "wcsbth.l"
+#line 2441 "wcsbth.l"
 case 318:
-#line 2480 "wcsbth.l"
+#line 2442 "wcsbth.l"
 case 319:
-#line 2481 "wcsbth.l"
+#line 2443 "wcsbth.l"
 case 320:
-#line 2482 "wcsbth.l"
+#line 2444 "wcsbth.l"
 case 321:
 YY_RULE_SETUP
-#line 2482 "wcsbth.l"
+#line 2444 "wcsbth.l"
 {
 	  sscanf(yytext, "%d", &n);
 	  a = 0;
@@ -28802,25 +28761,25 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 322:
-#line 2490 "wcsbth.l"
+#line 2452 "wcsbth.l"
 case 323:
 YY_RULE_SETUP
-#line 2490 "wcsbth.l"
+#line 2452 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 324:
-#line 2495 "wcsbth.l"
+#line 2457 "wcsbth.l"
 case 325:
-#line 2496 "wcsbth.l"
+#line 2458 "wcsbth.l"
 case 326:
-#line 2497 "wcsbth.l"
+#line 2459 "wcsbth.l"
 case 327:
 YY_RULE_SETUP
-#line 2497 "wcsbth.l"
+#line 2459 "wcsbth.l"
 {
-	  /* Image-header keyword. */
+	  // Image-header keyword.
 	  if (relax & WCSHDR_ALLIMG) {
 	    sscanf(yytext, "%d_%d%c", &i, &m, &a);
 	    keytype = IMGAXIS;
@@ -28833,54 +28792,54 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 328:
-#line 2517 "wcsbth.l"
+#line 2479 "wcsbth.l"
 case 329:
-#line 2518 "wcsbth.l"
+#line 2480 "wcsbth.l"
 case 330:
-#line 2519 "wcsbth.l"
+#line 2481 "wcsbth.l"
 case 331:
-#line 2520 "wcsbth.l"
+#line 2482 "wcsbth.l"
 case 332:
-#line 2521 "wcsbth.l"
+#line 2483 "wcsbth.l"
 case 333:
-#line 2522 "wcsbth.l"
+#line 2484 "wcsbth.l"
 case 334:
-#line 2523 "wcsbth.l"
+#line 2485 "wcsbth.l"
 case 335:
-#line 2524 "wcsbth.l"
+#line 2486 "wcsbth.l"
 case 336:
-#line 2525 "wcsbth.l"
+#line 2487 "wcsbth.l"
 case 337:
-#line 2526 "wcsbth.l"
+#line 2488 "wcsbth.l"
 case 338:
-#line 2527 "wcsbth.l"
+#line 2489 "wcsbth.l"
 case 339:
-#line 2528 "wcsbth.l"
+#line 2490 "wcsbth.l"
 case 340:
-#line 2529 "wcsbth.l"
+#line 2491 "wcsbth.l"
 case 341:
-#line 2530 "wcsbth.l"
+#line 2492 "wcsbth.l"
 case 342:
-#line 2531 "wcsbth.l"
+#line 2493 "wcsbth.l"
 case 343:
-#line 2532 "wcsbth.l"
+#line 2494 "wcsbth.l"
 case 344:
-#line 2533 "wcsbth.l"
+#line 2495 "wcsbth.l"
 case 345:
-#line 2534 "wcsbth.l"
+#line 2496 "wcsbth.l"
 case 346:
-#line 2535 "wcsbth.l"
+#line 2497 "wcsbth.l"
 case 347:
-#line 2536 "wcsbth.l"
+#line 2498 "wcsbth.l"
 case 348:
 YY_RULE_SETUP
-#line 2536 "wcsbth.l"
+#line 2498 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (((valtype == FLOAT)  && (relax & WCSHDR_PV0i_0ma)) ||
@@ -28895,7 +28854,7 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -28906,36 +28865,36 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 349:
-#line 2567 "wcsbth.l"
+#line 2529 "wcsbth.l"
 case 350:
-#line 2568 "wcsbth.l"
+#line 2530 "wcsbth.l"
 case 351:
-#line 2569 "wcsbth.l"
+#line 2531 "wcsbth.l"
 case 352:
-#line 2570 "wcsbth.l"
+#line 2532 "wcsbth.l"
 case 353:
-#line 2571 "wcsbth.l"
+#line 2533 "wcsbth.l"
 case 354:
-#line 2572 "wcsbth.l"
+#line 2534 "wcsbth.l"
 case 355:
-#line 2573 "wcsbth.l"
+#line 2535 "wcsbth.l"
 case 356:
-#line 2574 "wcsbth.l"
+#line 2536 "wcsbth.l"
 case 357:
-#line 2575 "wcsbth.l"
+#line 2537 "wcsbth.l"
 case 358:
 YY_RULE_SETUP
-#line 2575 "wcsbth.l"
+#line 2537 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
-	    /* Anything that has fallen through to this point must contain */
-	    /* an invalid parameter. */
+	    // Anything that has fallen through to this point must contain
+	    // an invalid parameter.
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
 	
@@ -28946,32 +28905,32 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 359:
-#line 2595 "wcsbth.l"
+#line 2557 "wcsbth.l"
 case 360:
-#line 2596 "wcsbth.l"
+#line 2558 "wcsbth.l"
 case 361:
-#line 2597 "wcsbth.l"
+#line 2559 "wcsbth.l"
 case 362:
-#line 2598 "wcsbth.l"
+#line 2560 "wcsbth.l"
 case 363:
-#line 2599 "wcsbth.l"
+#line 2561 "wcsbth.l"
 case 364:
-#line 2600 "wcsbth.l"
+#line 2562 "wcsbth.l"
 case 365:
-#line 2601 "wcsbth.l"
+#line 2563 "wcsbth.l"
 case 366:
-#line 2602 "wcsbth.l"
+#line 2564 "wcsbth.l"
 case 367:
-#line 2603 "wcsbth.l"
+#line 2565 "wcsbth.l"
 case 368:
 YY_RULE_SETUP
-#line 2603 "wcsbth.l"
+#line 2565 "wcsbth.l"
 {
 	  errmsg = errtxt;
 	  sprintf(errmsg, "%s keyword must use an underscore, not a dash",
@@ -28981,36 +28940,36 @@ YY_RULE_SETUP
 	YY_BREAK
 case 369:
 YY_RULE_SETUP
-#line 2610 "wcsbth.l"
+#line 2572 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 370:
-#line 2615 "wcsbth.l"
+#line 2577 "wcsbth.l"
 case 371:
-#line 2616 "wcsbth.l"
+#line 2578 "wcsbth.l"
 case 372:
-#line 2617 "wcsbth.l"
+#line 2579 "wcsbth.l"
 case 373:
-#line 2618 "wcsbth.l"
+#line 2580 "wcsbth.l"
 case 374:
-#line 2619 "wcsbth.l"
+#line 2581 "wcsbth.l"
 case 375:
-#line 2620 "wcsbth.l"
+#line 2582 "wcsbth.l"
 case 376:
-#line 2621 "wcsbth.l"
+#line 2583 "wcsbth.l"
 case 377:
-#line 2622 "wcsbth.l"
+#line 2584 "wcsbth.l"
 case 378:
-#line 2623 "wcsbth.l"
+#line 2585 "wcsbth.l"
 case 379:
-#line 2624 "wcsbth.l"
+#line 2586 "wcsbth.l"
 case 380:
-#line 2625 "wcsbth.l"
+#line 2587 "wcsbth.l"
 case 381:
 YY_RULE_SETUP
-#line 2625 "wcsbth.l"
+#line 2587 "wcsbth.l"
 {
 	  if (relax & WCSHDR_LONGKEY) {
 	    WCSBTH_PUTBACK;
@@ -29022,45 +28981,45 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 382:
-#line 2642 "wcsbth.l"
+#line 2604 "wcsbth.l"
 case 383:
 YY_RULE_SETUP
-#line 2642 "wcsbth.l"
+#line 2604 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 384:
-#line 2647 "wcsbth.l"
+#line 2609 "wcsbth.l"
 case 385:
-#line 2648 "wcsbth.l"
+#line 2610 "wcsbth.l"
 case 386:
-#line 2649 "wcsbth.l"
+#line 2611 "wcsbth.l"
 case 387:
-#line 2650 "wcsbth.l"
+#line 2612 "wcsbth.l"
 case 388:
-#line 2651 "wcsbth.l"
+#line 2613 "wcsbth.l"
 case 389:
-#line 2652 "wcsbth.l"
+#line 2614 "wcsbth.l"
 case 390:
-#line 2653 "wcsbth.l"
+#line 2615 "wcsbth.l"
 case 391:
-#line 2654 "wcsbth.l"
+#line 2616 "wcsbth.l"
 case 392:
-#line 2655 "wcsbth.l"
+#line 2617 "wcsbth.l"
 case 393:
-#line 2656 "wcsbth.l"
+#line 2618 "wcsbth.l"
 case 394:
-#line 2657 "wcsbth.l"
+#line 2619 "wcsbth.l"
 case 395:
 YY_RULE_SETUP
-#line 2657 "wcsbth.l"
+#line 2619 "wcsbth.l"
 {
 	  sscanf(yytext, "%d_%d%c", &n, &m, &a);
 	  if (YY_START == TCn_ma) i = wcsbth_colax(*wcs, &alts, n, a);
@@ -29069,24 +29028,24 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 396:
-#line 2665 "wcsbth.l"
+#line 2627 "wcsbth.l"
 case 397:
-#line 2666 "wcsbth.l"
+#line 2628 "wcsbth.l"
 case 398:
-#line 2667 "wcsbth.l"
+#line 2629 "wcsbth.l"
 case 399:
-#line 2668 "wcsbth.l"
+#line 2630 "wcsbth.l"
 case 400:
-#line 2669 "wcsbth.l"
+#line 2631 "wcsbth.l"
 case 401:
-#line 2670 "wcsbth.l"
+#line 2632 "wcsbth.l"
 case 402:
-#line 2671 "wcsbth.l"
+#line 2633 "wcsbth.l"
 case 403:
 YY_RULE_SETUP
-#line 2671 "wcsbth.l"
+#line 2633 "wcsbth.l"
 {
-	  /* Invalid combinations will be flagged by <VALUE>. */
+	  // Invalid combinations will be flagged by <VALUE>.
 	  sscanf(yytext, "%d_%d", &n, &m);
 	  a = ' ';
 	  if (YY_START == TCn_ma) i = wcsbth_colax(*wcs, &alts, n, a);
@@ -29095,17 +29054,17 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 404:
-#line 2681 "wcsbth.l"
+#line 2643 "wcsbth.l"
 case 405:
 YY_RULE_SETUP
-#line 2681 "wcsbth.l"
+#line 2643 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 406:
 YY_RULE_SETUP
-#line 2685 "wcsbth.l"
+#line 2647 "wcsbth.l"
 {
 	  if (relax & WCSHDR_PROJPn) {
 	    sscanf(yytext, "%d", &m);
@@ -29119,16 +29078,16 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 407:
-#line 2704 "wcsbth.l"
+#line 2666 "wcsbth.l"
 case 408:
 YY_RULE_SETUP
-#line 2704 "wcsbth.l"
+#line 2666 "wcsbth.l"
 {
 	  if (relax & (WCSHDR_PROJPn | WCSHDR_reject)) {
 	    errmsg = "invalid PROJPn keyword";
@@ -29141,26 +29100,26 @@ YY_RULE_SETUP
 	YY_BREAK
 case 409:
 YY_RULE_SETUP
-#line 2714 "wcsbth.l"
+#line 2676 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 410:
 YY_RULE_SETUP
-#line 2718 "wcsbth.l"
+#line 2680 "wcsbth.l"
 {
-	  /* Do checks on i, j, m, n, k. */
+	  // Do checks on i, j, m, n, k.
 	  if (!(keytype & keysel)) {
-	    /* Selection by keyword type. */
+	    // Selection by keyword type.
 	    BEGIN(DISCARD);
 	
 	  } else if (exclude[n] || exclude[k]) {
-	    /* One or other column is not selected. */
+	    // One or other column is not selected.
 	    if (k && (exclude[n] != exclude[k])) {
-	      /* For keywords such as TCn_ka, both columns must be excluded.
-	         User error, so return immediately. */
-	      return 3;
+	      // For keywords such as TCn_ka, both columns must be excluded.
+	      // User error, so return immediately.
+	      return WCSHDRERR_BAD_COLUMN;
 	
 	    } else {
 	      BEGIN(DISCARD);
@@ -29179,18 +29138,18 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
 	  } else if (ipass == 2 && npass == 3 && (keytype & BINTAB)) {
-	    /* Skip keyvalues that won't be inherited. */
+	    // Skip keyvalues that won't be inherited.
 	    BEGIN(FLUSH);
 	
 	  } else {
 	    if (ipass == 3 && (keytype & IMGHEAD)) {
-	      /* IMGHEAD keytypes are always dealt with on the second pass. */
-	      /* However, they must be re-parsed in order to report errors. */
+	      // IMGHEAD keytypes are always dealt with on the second pass.
+	      // However, they must be re-parsed in order to report errors.
 	      vptr = 0x0;
 	    }
 	
@@ -29213,7 +29172,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 411:
 YY_RULE_SETUP
-#line 2780 "wcsbth.l"
+#line 2742 "wcsbth.l"
 {
 	  errmsg = "invalid KEYWORD = VALUE syntax";
 	  BEGIN(ERROR);
@@ -29221,13 +29180,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 412:
 YY_RULE_SETUP
-#line 2785 "wcsbth.l"
+#line 2747 "wcsbth.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    sscanf(yytext, "%d", &inttmp);
 	
 	    BEGIN(COMMENT);
@@ -29236,7 +29195,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 413:
 YY_RULE_SETUP
-#line 2797 "wcsbth.l"
+#line 2759 "wcsbth.l"
 {
 	  errmsg = "an integer value was expected";
 	  BEGIN(ERROR);
@@ -29244,13 +29203,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 414:
 YY_RULE_SETUP
-#line 2802 "wcsbth.l"
+#line 2764 "wcsbth.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    wcsutil_str2double(yytext, &dbltmp);
 	
 	    if (chekval && chekval(dbltmp)) {
@@ -29264,7 +29223,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 415:
 YY_RULE_SETUP
-#line 2819 "wcsbth.l"
+#line 2781 "wcsbth.l"
 {
 	  errmsg = "a floating-point value was expected";
 	  BEGIN(ERROR);
@@ -29272,13 +29231,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 416:
 YY_RULE_SETUP
-#line 2824 "wcsbth.l"
+#line 2786 "wcsbth.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue as integer and fractional parts. */
+	    // Read the keyvalue as integer and fractional parts.
 	    wcsutil_str2double2(yytext, dbl2tmp);
 	
 	    BEGIN(COMMENT);
@@ -29287,7 +29246,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 417:
 YY_RULE_SETUP
-#line 2836 "wcsbth.l"
+#line 2798 "wcsbth.l"
 {
 	  errmsg = "a floating-point value was expected";
 	  BEGIN(ERROR);
@@ -29296,18 +29255,18 @@ YY_RULE_SETUP
 case 418:
 /* rule 418 can match eol */
 YY_RULE_SETUP
-#line 2841 "wcsbth.l"
+#line 2803 "wcsbth.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
-	      strcpy(strtmp, yytext+1);
+	    // Read the keyvalue.
+	    strcpy(strtmp, yytext+1);
 	
-	    /* Squeeze out repeated quotes. */
-	    ix = 0;
-	    for (jx = 0; jx < 72; jx++) {
+	    // Squeeze out repeated quotes.
+	    int ix = 0;
+	    for (int jx = 0; jx < 72; jx++) {
 	      if (ix < jx) {
 	        strtmp[ix] = strtmp[jx];
 	      }
@@ -29328,7 +29287,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 419:
 YY_RULE_SETUP
-#line 2870 "wcsbth.l"
+#line 2832 "wcsbth.l"
 {
 	  errmsg = "a string value was expected";
 	  BEGIN(ERROR);
@@ -29339,32 +29298,34 @@ case 420:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2875 "wcsbth.l"
+#line 2837 "wcsbth.l"
 {
 	  if (ipass == 1) {
-	    /* Do first-pass bookkeeping. */
+	    // Do first-pass bookkeeping.
 	    wcsbth_pass1(keytype, i, j, n, k, a, ptype, &alts);
 	    BEGIN(FLUSH);
 	
 	  } else if (*wcs) {
-	    /* Store the value now that the keyrecord has been validated. */
+	    // Store the value now that the keyrecord has been validated.
 	    alts.icol = 0;
 	    alts.ialt = 0;
 	
-	    /* Update each coordinate representation. */
-	    gotone = 0;
+	    // Update each coordinate representation.
+	    int gotone = 0;
+	    struct wcsprm *wcsp;
 	    while ((wcsp = wcsbth_idx(*wcs, &alts, keytype, n, a))) {
 	      gotone = 1;
 	
 	      if (vptr) {
+	        void *wptr;
 	        if (auxprm) {
-	          /* Additional auxiliary parameter. */
+	          // Additional auxiliary parameter.
 	          auxp = wcsp->aux;
-	          voff = (char *)vptr - (char *)(&auxtem);
+	          ptrdiff_t voff = (char *)vptr - (char *)(&auxtem);
 	          wptr = (void *)((char *)auxp + voff);
 	        } else {
-	          /* A parameter that lives directly in wcsprm. */
-	          voff = (char *)vptr - (char *)(&wcstem);
+	          // A parameter that lives directly in wcsprm.
+	          ptrdiff_t voff = (char *)vptr - (char *)(&wcstem);
 	          wptr = (void *)((char *)wcsp + voff);
 	        }
 	
@@ -29372,9 +29333,9 @@ YY_RULE_SETUP
 	          *((int *)wptr) = inttmp;
 	
 	        } else if (valtype == FLOAT) {
-	          /* Apply keyword parameterization. */
+	          // Apply keyword parameterization.
 	          if (ptype == 'v') {
-	            ipx = (wcsp->npv)++;
+	            int ipx = (wcsp->npv)++;
 	            wcsp->pv[ipx].i = i;
 	            wcsp->pv[ipx].m = m;
 	            wptr = &(wcsp->pv[ipx].value);
@@ -29393,14 +29354,14 @@ YY_RULE_SETUP
 	            *((double *)wptr) = dbltmp;
 	          }
 	
-	          /* Flag the presence of PCi_ja, or CDi_ja and/or CROTAia. */
+	          // Flag the presence of PCi_ja, or CDi_ja and/or CROTAia.
 	          if (altlin) {
 	            wcsp->altlin |= altlin;
 	            altlin = 0;
 	          }
 	
 	          } else if (valtype == FLOAT2) {
-	            /* Split MJDREF and JDREF into integer and fraction.*/
+	            // Split MJDREF and JDREF into integer and fraction.
 	            if (special) {
 	              special(wptr, dbl2tmp);
 	            } else {
@@ -29409,9 +29370,9 @@ YY_RULE_SETUP
 	            }
 	
 	        } else if (valtype == STRING) {
-	          /* Apply keyword parameterization. */
+	          // Apply keyword parameterization.
 	          if (ptype == 's') {
-	            ipx = wcsp->nps++;
+	            int ipx = wcsp->nps++;
 	            wcsp->ps[ipx].i = i;
 	            wcsp->ps[ipx].m = m;
 	            wptr = wcsp->ps[ipx].value;
@@ -29424,7 +29385,7 @@ YY_RULE_SETUP
 	            wptr = *((char (**)[72])wptr) + (i - 1);
 	          }
 	
-	          cptr = (char *)wptr;
+	          char *cptr = (char *)wptr;
 	          strcpy(cptr, strtmp);
 	        }
 	      }
@@ -29460,7 +29421,7 @@ case 421:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2990 "wcsbth.l"
+#line 2954 "wcsbth.l"
 {
 	  errmsg = "invalid keyvalue";
 	  BEGIN(ERROR);
@@ -29471,7 +29432,7 @@ case 422:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2995 "wcsbth.l"
+#line 2959 "wcsbth.l"
 {
 	  errmsg = "invalid keyvalue";
 	  BEGIN(ERROR);
@@ -29482,7 +29443,7 @@ case 423:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 3000 "wcsbth.l"
+#line 2964 "wcsbth.l"
 {
 	  errmsg = "invalid keyvalue or malformed keycomment";
 	  BEGIN(ERROR);
@@ -29493,7 +29454,7 @@ case 424:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 3005 "wcsbth.l"
+#line 2969 "wcsbth.l"
 {
 	  errmsg = "malformed keycomment";
 	  BEGIN(ERROR);
@@ -29504,11 +29465,11 @@ case 425:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 3010 "wcsbth.l"
+#line 2974 "wcsbth.l"
 {
 	  if (ipass == npass) {
 	    if (ctrl < 0) {
-	      /* Preserve discards. */
+	      // Preserve discards.
 	      keep = keyrec;
 	
 	    } else if (2 < ctrl) {
@@ -29525,7 +29486,7 @@ case 426:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 3025 "wcsbth.l"
+#line 2989 "wcsbth.l"
 {
 	  if (ipass == npass) {
 	    (*nreject)++;
@@ -29545,7 +29506,7 @@ YY_RULE_SETUP
 case 427:
 /* rule 427 can match eol */
 YY_RULE_SETUP
-#line 3041 "wcsbth.l"
+#line 3005 "wcsbth.l"
 {
 	  if (ipass == npass && keep) {
 	    if (hptr < keep) {
@@ -29556,7 +29517,7 @@ YY_RULE_SETUP
 	
 	  naux += auxprm;
 	
-	  /* Throw away the rest of the line and reset for the next one. */
+	  // Throw away the rest of the line and reset for the next one.
 	  i = j = 0;
 	  n = k = 0;
 	  m = 0;
@@ -29611,10 +29572,11 @@ case YY_STATE_EOF(COMMENT):
 case YY_STATE_EOF(DISCARD):
 case YY_STATE_EOF(ERROR):
 case YY_STATE_EOF(FLUSH):
-#line 3072 "wcsbth.l"
+#line 3036 "wcsbth.l"
 {
-	  /* End-of-input. */
+	  // End-of-input.
 	  if (ipass == 1) {
+	    int status;
 	    if ((status = wcsbth_init1(&alts, naux, nwcs, wcs)) ||
 	        (*nwcs == 0 && ctrl == 0)) {
 	      return status;
@@ -29635,8 +29597,8 @@ case YY_STATE_EOF(FLUSH):
 	  }
 	
 	  if (ipass++ < npass) {
-	    wcsbth_hdr = header;
-	    wcsbth_nkeyrec = nkeyrec;
+	    yyextra->hdr = header;
+	    yyextra->nkeyrec = nkeyrec;
 	    keyrec = header;
 	    *nreject = 0;
 	
@@ -29682,10 +29644,10 @@ case YY_STATE_EOF(FLUSH):
 	YY_BREAK
 case 428:
 YY_RULE_SETUP
-#line 3140 "wcsbth.l"
+#line 3105 "wcsbth.l"
 ECHO;
 	YY_BREAK
-#line 29689 "wcsbth.c"
+#line 29651 "wcsbth.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -30850,8 +30812,38 @@ void yyfree (void * ptr , yyscan_t yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 3140 "wcsbth.l"
+#line 3105 "wcsbth.l"
+
+
+/*----------------------------------------------------------------------------
+* External interface to the scanner.
+*---------------------------------------------------------------------------*/
+
+int wcsbth(
+  char *header,
+  int nkeyrec,
+  int relax,
+  int ctrl,
+  int keysel,
+  int *colsel,
+  int *nreject,
+  int *nwcs,
+  struct wcsprm **wcs)
+
+{
+  // Function prototypes.
+  int yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *yyscanner);
+  int yylex_destroy(yyscan_t yyscanner);
+
+  struct wcsbth_extra extra;
+  yyscan_t yyscanner;
+  yylex_init_extra(&extra, &yyscanner);
+  int status = wcsbth_scanner(header, nkeyrec, relax, ctrl, keysel, colsel,
+                              nreject, nwcs, wcs, yyscanner);
+  yylex_destroy(yyscanner);
 
+  return status;
+}
 
 /*----------------------------------------------------------------------------
 * Perform first-pass tasks:
@@ -30890,23 +30882,21 @@ int wcsbth_pass1(
   struct wcsbth_alts *alts)
 
 {
-  int ialt, icol, mask, ncol;
-
   if (a == 0) {
-    /* Keywords such as DATE-OBS go along for the ride. */
+    // Keywords such as DATE-OBS go along for the ride.
     return 0;
   }
 
-  ncol = alts->ncol;
+  int ncol = alts->ncol;
 
-  /* Do we need to allocate memory for alts? */
+  // Do we need to allocate memory for alts?
   if (alts->arridx == 0x0) {
     if (ncol == 0) {
-      /* Can only happen if TFIELDS is missing or out-of-sequence.  If n and
-         k are both zero then we may be processing an image header so leave
-         ncol alone - the array will be realloc'd later if required. */
+      // Can only happen if TFIELDS is missing or out-of-sequence.  If n and
+      // k are both zero then we may be processing an image header so leave
+      // ncol alone - the array will be realloc'd later if required.
       if (n || k) {
-        /* The header is mangled, assume the worst. */
+        // The header is mangled, assume the worst.
         ncol = 999;
       }
     }
@@ -30919,13 +30909,13 @@ int wcsbth_pass1(
       if (alts->npv)     free(alts->npv);
       if (alts->nps)     free(alts->nps);
       if (alts->pixlist) free(alts->pixlist);
-      return 2;
+      return WCSHDRERR_MEMORY;
     }
 
     alts->ncol = ncol;
 
   } else if (n > ncol || k > ncol) {
-    /* Can only happen if TFIELDS or the WCS keyword is wrong; carry on. */
+    // Can only happen if TFIELDS or the WCS keyword is wrong; carry on.
     ncol = 999;
     if (!(alts->arridx  = realloc(alts->arridx,
                                     27*(1 + ncol)*sizeof(short int))) ||
@@ -30939,12 +30929,12 @@ int wcsbth_pass1(
       if (alts->npv)     free(alts->npv);
       if (alts->nps)     free(alts->nps);
       if (alts->pixlist) free(alts->pixlist);
-      return 2;
+      return WCSHDRERR_MEMORY;
     }
 
-    /* Since realloc() doesn't initialize the extra memory. */
-    for (icol = (1 + alts->ncol); icol < (1 + ncol); icol++) {
-      for (ialt = 0; ialt < 27; ialt++) {
+    // Since realloc() doesn't initialize the extra memory.
+    for (int icol = (1 + alts->ncol); icol < (1 + ncol); icol++) {
+      for (int ialt = 0; ialt < 27; ialt++) {
         alts->arridx[icol][ialt] = 0;
         alts->npv[icol][ialt] = 0;
         alts->nps[icol][ialt] = 0;
@@ -30955,23 +30945,23 @@ int wcsbth_pass1(
     alts->ncol = ncol;
   }
 
-  ialt = 0;
+  int ialt = 0;
   if (a != ' ') {
     ialt = a - 'A' + 1;
   }
 
-  /* A BINTAB keytype such as LONPna, in conjunction with an IMGAXIS keytype
-     causes a table column to be recognized as an image array. */
+  // A BINTAB keytype such as LONPna, in conjunction with an IMGAXIS keytype
+  // causes a table column to be recognized as an image array.
   if (keytype & IMGHEAD || keytype & BIMGARR) {
-    /* n == 0 is expected for IMGHEAD keywords. */
+    // n == 0 is expected for IMGHEAD keywords.
     if (i == 0 && j == 0) {
       if (alts->arridx[n][ialt] == 0) {
-        /* Flag that an auxiliary keyword was seen. */
+        // Flag that an auxiliary keyword was seen.
         alts->arridx[n][ialt] = -1;
       }
 
     } else {
-      /* Record the maximum axis number found. */
+      // Record the maximum axis number found.
       if (alts->arridx[n][ialt] < i) {
         alts->arridx[n][ialt] = i;
       }
@@ -30988,17 +30978,17 @@ int wcsbth_pass1(
     }
   }
 
-  /* BINTAB keytypes, which apply both to pixel lists as well as binary table
-     image arrays, never contribute to recognizing a table column as a pixel
-     list axis.  A PIXLIST keytype is required for that. */
+  // BINTAB keytypes, which apply both to pixel lists as well as binary table
+  // image arrays, never contribute to recognizing a table column as a pixel
+  // list axis.  A PIXLIST keytype is required for that.
   if (keytype == PIXLIST) {
-    mask = 1 << ialt;
+    int mask = 1 << ialt;
 
-    /* n > 0 for PIXLIST keytypes. */
+    // n > 0 for PIXLIST keytypes.
     alts->pixlist[n] |= mask;
     if (k) alts->pixlist[k] |= mask;
 
-    /* Used as a flag over all columns. */
+    // Used as a flag over all columns.
     alts->pixlist[0] |= mask;
 
     if (ptype == 'v') {
@@ -31026,22 +31016,20 @@ int wcsbth_init1(
   struct wcsprm **wcs)
 
 {
-  int ialt, icol, inherit[27], ix, mask, ncol, npsmax, npvmax, status = 0;
-  struct wcsprm *wcsp;
-
+  int status = 0;
 
   if (alts->arridx == 0x0) {
     *nwcs = 0;
     return 0;
   }
 
-  /* Determine the number of axes in each pixel list representation. */
-  ncol = alts->ncol;
+  // Determine the number of axes in each pixel list representation.
+  int ialt, mask, ncol = alts->ncol;
   for (ialt = 0, mask = 1; ialt < 27; ialt++, mask <<= 1) {
     alts->pixidx[ialt] = 0;
 
     if (alts->pixlist[0] | mask) {
-      for (icol = 1; icol <= ncol; icol++) {
+      for (int icol = 1; icol <= ncol; icol++) {
         if (alts->pixlist[icol] & mask) {
           alts->pixidx[ialt]++;
         }
@@ -31049,18 +31037,19 @@ int wcsbth_init1(
     }
   }
 
-  /* Find the total number of coordinate representations. */
+  // Find the total number of coordinate representations.
   *nwcs = 0;
   alts->imgherit = 0;
-  for (ialt = 0; ialt < 27; ialt++) {
+  int inherit[27];
+  for (int ialt = 0; ialt < 27; ialt++) {
     inherit[ialt] = 0;
 
-    for (icol = 1; icol <= ncol; icol++) {
+    for (int icol = 1; icol <= ncol; icol++) {
       if (alts->arridx[icol][ialt] < 0) {
-        /* No BIMGARR keytype but there's at least one BINTAB. */
+        // No BIMGARR keytype but there's at least one BINTAB.
         if (alts->arridx[0][ialt] > 0) {
-          /* There is an IMGAXIS keytype that we will inherit, so count this
-             representation. */
+          // There is an IMGAXIS keytype that we will inherit, so count this
+          // representation.
           alts->arridx[icol][ialt] = alts->arridx[0][ialt];
         } else {
           alts->arridx[icol][ialt] = 0;
@@ -31069,11 +31058,11 @@ int wcsbth_init1(
 
       if (alts->arridx[icol][ialt]) {
         if (alts->arridx[0][ialt]) {
-          /* All IMGHEAD keywords are inherited for this ialt. */
+          // All IMGHEAD keywords are inherited for this ialt.
           inherit[ialt] = 1;
 
           if (alts->arridx[icol][ialt] < alts->arridx[0][ialt]) {
-            /* The extra axes are also inherited. */
+            // The extra axes are also inherited.
             alts->arridx[icol][ialt] = alts->arridx[0][ialt];
           }
         }
@@ -31082,10 +31071,10 @@ int wcsbth_init1(
       }
     }
 
-    /* Count every "a" found in any IMGHEAD keyword... */
+    // Count every "a" found in any IMGHEAD keyword...
     if (alts->arridx[0][ialt]) {
       if (inherit[ialt]) {
-        /* ...but not if the IMGHEAD keywords will be inherited. */
+        // ...but not if the IMGHEAD keywords will be inherited.
         alts->arridx[0][ialt] = 0;
         alts->imgherit = 1;
       } else if (alts->arridx[0][ialt] > 0) {
@@ -31093,7 +31082,7 @@ int wcsbth_init1(
       }
     }
 
-    /* We need a struct for every "a" found in a PIXLIST keyword. */
+    // We need a struct for every "a" found in a PIXLIST keyword.
     if (alts->pixidx[ialt]) {
       (*nwcs)++;
     }
@@ -31101,95 +31090,95 @@ int wcsbth_init1(
 
 
   if (*nwcs) {
-    /* Allocate memory for the required number of wcsprm structs. */
+    // Allocate memory for the required number of wcsprm structs.
     if (!(*wcs = calloc(*nwcs, sizeof(struct wcsprm)))) {
-      return 2;
+      return WCSHDRERR_MEMORY;
     }
 
-    /* Initialize each wcsprm struct. */
-    wcsp = *wcs;
+    // Initialize each wcsprm struct.
+    struct wcsprm *wcsp = *wcs;
     *nwcs = 0;
-    for (icol = 0; icol <= ncol; icol++) {
-      for (ialt = 0; ialt < 27; ialt++) {
+    for (int icol = 0; icol <= ncol; icol++) {
+      for (int ialt = 0; ialt < 27; ialt++) {
         if (alts->arridx[icol][ialt] > 0) {
-          /* Image-header representations that are not for inheritance
-             (icol == 0) or binary table image array representations. */
+          // Image-header representations that are not for inheritance
+          // (icol == 0) or binary table image array representations.
           wcsp->flag = -1;
-          npvmax = alts->npv[icol][ialt];
-          npsmax = alts->nps[icol][ialt];
+          int npvmax = alts->npv[icol][ialt];
+          int npsmax = alts->nps[icol][ialt];
           if ((status = wcsinit(1, (int)(alts->arridx[icol][ialt]), wcsp,
                                 npvmax, npsmax, -1))) {
             wcsvfree(nwcs, wcs);
             break;
           }
 
-          /* Record the alternate version code. */
+          // Record the alternate version code.
           if (ialt) {
             wcsp->alt[0] = 'A' + ialt - 1;
           }
 
-          /* Any additional auxiliary keywords present? */
+          // Any additional auxiliary keywords present?
           if (naux) {
             if (wcsauxi(1, wcsp)) {
               return WCSHDRERR_MEMORY;
             }
           }
 
-          /* Record the table column number. */
+          // Record the table column number.
           wcsp->colnum = icol;
 
-          /* On the second pass alts->arridx[icol][27] indexes the array of
-             wcsprm structs. */
+          // On the second pass alts->arridx[icol][27] indexes the array of
+          // wcsprm structs.
           alts->arridx[icol][ialt] = (*nwcs)++;
 
           wcsp++;
 
         } else {
-          /* Signal that this column has no WCS for this "a". */
+          // Signal that this column has no WCS for this "a".
           alts->arridx[icol][ialt] = -1;
         }
       }
     }
 
-    for (ialt = 0; ialt < 27; ialt++) {
+    for (int ialt = 0; ialt < 27; ialt++) {
       if (alts->pixidx[ialt]) {
-        /* Pixel lists representations. */
+        // Pixel lists representations.
         wcsp->flag = -1;
-        npvmax = alts->pixnpv[ialt];
-        npsmax = alts->pixnps[ialt];
+        int npvmax = alts->pixnpv[ialt];
+        int npsmax = alts->pixnps[ialt];
         if ((status = wcsinit(1, (int)(alts->pixidx[ialt]), wcsp, npvmax,
                               npsmax, -1))) {
           wcsvfree(nwcs, wcs);
           break;
         }
 
-        /* Record the alternate version code. */
+        // Record the alternate version code.
         if (ialt) {
           wcsp->alt[0] = 'A' + ialt - 1;
         }
 
-        /* Any additional auxiliary keywords present? */
+        // Any additional auxiliary keywords present?
         if (naux) {
           if (wcsauxi(1, wcsp)) {
             return WCSHDRERR_MEMORY;
           }
         }
 
-        /* Record the pixel list column numbers. */
-        mask = (1 << ialt);
+        // Record the pixel list column numbers.
+        int icol, ix, mask = (1 << ialt);
         for (icol = 1, ix = 0; icol <= ncol; icol++) {
           if (alts->pixlist[icol] & mask) {
             wcsp->colax[ix++] = icol;
           }
         }
 
-        /* alts->pixidx[] indexes the array of wcsprm structs. */
+        // alts->pixidx[] indexes the array of wcsprm structs.
         alts->pixidx[ialt] = (*nwcs)++;
 
         wcsp++;
 
       } else {
-        /* Signal that this column is not a pixel list axis for this "a". */
+        // Signal that this column is not a pixel list axis for this "a".
         alts->pixidx[ialt] = -1;
       }
     }
@@ -31213,28 +31202,27 @@ struct wcsprm *wcsbth_idx(
 
 {
   const char as[] = " ABCDEFGHIJKLMNOPQRSTUVWXYZ";
-  int iwcs;
 
   if (!wcs) return 0x0;
 
-  iwcs = -1;
+  int iwcs = -1;
   for (; iwcs < 0 && alts->ialt < 27; alts->ialt++) {
-    /* Note that a == 0 applies to every alternate, otherwise this
-       loop simply determines the appropriate value of alts->ialt. */
+    // Note that a == 0 applies to every alternate, otherwise this
+    // loop simply determines the appropriate value of alts->ialt.
     if (a && a != as[alts->ialt]) continue;
 
     if (keytype & (IMGHEAD | BIMGARR)) {
       for (; iwcs < 0 && alts->icol <= alts->ncol; alts->icol++) {
-        /* Image header keywords, n == 0, apply to all columns, otherwise this
-           loop simply determines the appropriate value of alts->icol. */
+        // Image header keywords, n == 0, apply to all columns, otherwise this
+        // loop simply determines the appropriate value of alts->icol.
         if (n && n != alts->icol) continue;
         iwcs = alts->arridx[alts->icol][alts->ialt];
       }
 
-      /* Break out of the loop to stop alts->ialt from being incremented. */
+      // Break out of the loop to stop alts->ialt from being incremented.
       if (iwcs >= 0) break;
 
-      /* Start from scratch for the next alts->ialt. */
+      // Start from scratch for the next alts->ialt.
       alts->icol = 0;
     }
 
@@ -31259,17 +31247,14 @@ int wcsbth_colax(
   char a)
 
 {
-  int ix;
-  struct wcsprm *wcsp;
-
   if (!wcs) return 0;
 
-  wcsp = wcs;
+  struct wcsprm *wcsp = wcs;
   if (a != ' ') {
     wcsp += alts->pixidx[a-'A'+1];
   }
 
-  for (ix = 0; ix < wcsp->naxis; ix++) {
+  for (int ix = 0; ix < wcsp->naxis; ix++) {
     if (wcsp->colax[ix] == n) {
       return ++ix;
     }
@@ -31286,7 +31271,7 @@ int wcsbth_colax(
 int wcsbth_jdref(double *mjdref, const double *jdref)
 
 {
-  /* Set MJDREF from JDREF. */
+  // Set MJDREF from JDREF.
   if (undefined(mjdref[0] && undefined(mjdref[1]))) {
     mjdref[0] = jdref[0] - 2400000.0;
     mjdref[1] = jdref[1] - 0.5;
@@ -31303,7 +31288,7 @@ int wcsbth_jdref(double *mjdref, const d
 int wcsbth_jdrefi(double *mjdref, const double *jdrefi)
 
 {
-  /* Set the integer part of MJDREF from JDREFI. */
+  // Set the integer part of MJDREF from JDREFI.
   if (undefined(mjdref[0])) {
     mjdref[0] = *jdrefi - 2400000.5;
   }
@@ -31315,7 +31300,7 @@ int wcsbth_jdrefi(double *mjdref, const
 int wcsbth_jdreff(double *mjdref, const double *jdreff)
 
 {
-  /* Set the fractional part of MJDREF from JDREFF. */
+  // Set the fractional part of MJDREF from JDREFF.
   if (undefined(mjdref[1])) {
     mjdref[1] = *jdreff;
   }
@@ -31331,7 +31316,7 @@ int wcsbth_jdreff(double *mjdref, const
 int wcsbth_epoch(double *equinox, const double *epoch)
 
 {
-  /* If EQUINOXa is currently undefined then set it from EPOCHa. */
+  // If EQUINOXa is currently undefined then set it from EPOCHa.
   if (undefined(*equinox)) {
     *equinox = *epoch;
   }
@@ -31347,12 +31332,12 @@ int wcsbth_epoch(double *equinox, const
 int wcsbth_vsource(double *zsource, const double *vsource)
 
 {
-  double beta, c = 299792458.0;
+  const double c = 299792458.0;
 
-  /* If ZSOURCEa is currently undefined then set it from VSOURCEa. */
+  // If ZSOURCEa is currently undefined then set it from VSOURCEa.
   if (undefined(*zsource)) {
-    /* Convert relativistic Doppler velocity to redshift. */
-    beta = *vsource/c;
+    // Convert relativistic Doppler velocity to redshift.
+    double beta = *vsource/c;
     *zsource = (1.0 + beta)/sqrt(1.0 - beta*beta) - 1.0;
   }
 
@@ -31381,15 +31366,14 @@ int wcsbth_final(
   struct wcsprm **wcs)
 
 {
-  int ialt, status;
-
   if (alts->arridx)  free(alts->arridx);
   if (alts->npv)     free(alts->npv);
   if (alts->nps)     free(alts->nps);
   if (alts->pixlist) free(alts->pixlist);
 
-  for (ialt = 0; ialt < *nwcs; ialt++) {
-    /* Interpret -TAB header keywords. */
+  for (int ialt = 0; ialt < *nwcs; ialt++) {
+    // Interpret -TAB header keywords.
+    int status;
     if ((status = wcstab(*wcs+ialt))) {
        wcsvfree(nwcs, wcs);
        return status;
Index: astropy-4.2.1/cextern/wcslib/C/flexed/wcspih.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/flexed/wcspih.c
+++ astropy-4.2.1/cextern/wcslib/C/flexed/wcspih.c
@@ -20763,9 +20763,8 @@ static const yy_state_type yy_NUL_trans[
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "wcspih.l"
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -20782,11 +20781,9 @@ static const yy_state_type yy_NUL_trans[
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcspih.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcspih.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
 * wcspih.l is a Flex description file containing the definition of a lexical
@@ -20841,7 +20838,7 @@ static const yy_state_type yy_NUL_trans[
 
 
 
-#line 112 "wcspih.l"
+#line 110 "wcspih.l"
 #include <math.h>
 #include <setjmp.h>
 #include <stddef.h>
@@ -20870,58 +20867,37 @@ static const yy_state_type yy_NUL_trans[
 #define DSS     2
 #define WAT     3
 
-static int wcspih_scanner(char *header, int nkeyrec, int relax, int ctrl,
-                          int *nreject, int *nwcs, struct wcsprm **wcs,
-                          yyscan_t yyscanner);
-
-/*--------------------------------------------------------------------------*/
-
-int wcspih(
-  char *header,
-  int nkeyrec,
-  int relax,
-  int ctrl,
-  int *nreject,
-  int *nwcs,
-  struct wcsprm **wcs)
-
-{
-  int status;
-  yyscan_t yyscanner;
-  int yylex_init(yyscan_t *yyscanner);
-  int yylex_destroy(yyscan_t yyscanner);
-
-  yylex_init(&yyscanner);
-  status = wcspih_scanner(header, nkeyrec, relax, ctrl, nreject, nwcs, wcs,
-                          yyscanner);
-  yylex_destroy(yyscanner);
-
-  return status;
-}
-
-/*--------------------------------------------------------------------------*/
+// User data associated with yyscanner.
+struct wcspih_extra {
+  // Values passed to YY_INPUT.
+  char *hdr;
+  int  nkeyrec;
+
+  // Used in preempting the call to exit() by yy_fatal_error().
+  jmp_buf abort_jmp_env;
+};
 
 #define YY_DECL int wcspih_scanner(char *header, int nkeyrec, int relax, \
  int ctrl, int *nreject, int *nwcs, struct wcsprm **wcs, yyscan_t yyscanner)
 
 #define YY_INPUT(inbuff, count, bufsize) \
 	{ \
-	  if (wcspih_nkeyrec) { \
-	    strncpy(inbuff, wcspih_hdr, 80); \
+	  if (yyextra->nkeyrec) { \
+	    strncpy(inbuff, yyextra->hdr, 80); \
 	    inbuff[80] = '\n'; \
-	    wcspih_hdr += 80; \
-	    wcspih_nkeyrec--; \
+	    yyextra->hdr += 80; \
+	    yyextra->nkeyrec--; \
 	    count = 81; \
 	  } else { \
 	    count = YY_NULL; \
 	  } \
 	}
 
-/* These global variables are required by YY_INPUT. */
-static char *wcspih_hdr;
-static int  wcspih_nkeyrec;
+// Preempt the call to exit() by yy_fatal_error().
+#define exit(status) longjmp(yyextra->abort_jmp_env, status);
 
-/* Internal helper functions. */
+// Internal helper functions.
+static YY_DECL;
 static int wcspih_final(int ndp[], int ndq[], int distran, double dsstmp[],
              char *wat[], int *nwcs, struct wcsprm **wcs);
 static int wcspih_init1(int naxis, int alts[], int dpq[], int npv[],
@@ -20938,12 +20914,8 @@ static int wcspih_vsource(double *wptr,
 
 static int wcspih_timepixr(double timepixr);
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
-jmp_buf wcspih_abort_jmp_env;
-#define exit(status) longjmp(wcspih_abort_jmp_env, status)
-
-#line 20946 "wcspih.c"
-#line 20947 "wcspih.c"
+#line 20918 "wcspih.c"
+#line 20919 "wcspih.c"
 
 #define INITIAL 0
 #define CCia 1
@@ -20981,9 +20953,7 @@ jmp_buf wcspih_abort_jmp_env;
 #include <unistd.h>
 #endif
 
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
+#define YY_EXTRA_TYPE struct wcspih_extra *
 
 /* Holds the entire state of the reentrant scanner. */
 struct yyguts_t
@@ -21216,30 +21186,20 @@ YY_DECL
 		}
 
 	{
-#line 214 "wcspih.l"
+#line 187 "wcspih.l"
 
-#line 216 "wcspih.l"
-	/* Keyword indices, as used in the WCS papers, e.g. PCi_ja, PVi_ma. */
-	char a;
-	int  i, j, m, p, q;
-	
-	char *cptr, *errmsg, errtxt[80], *hptr, *keep, *keyname, *keyrec,
-	     keyword[16], strtmp[80], *wat[2], *watstr;
-	int  altlin, alts[27], auxprm, distran, distype, dpq[27], dssflag,
-	     gotone, ialt, inttmp, ipass, ipx, ix, jx, naux, naxis,
-	     ndp[27], ndq[27], nother, *npptr, nps[27], npass, npv[27],
-	     nvalid, rectype, sipflag, status, valtype, watflag, watn;
-	ptrdiff_t voff;
+#line 189 "wcspih.l"
+	int  p, q;
+	char *errmsg, errtxt[80], *keyname, strtmp[80], *wat[2], *watstr;
+	int  alts[27], dpq[27], inttmp, ndp[27], ndq[27], nps[27], npv[27],
+	     rectype;
 	double dbltmp, dbl2tmp[2], dsstmp[20];
-	void *vptr, *wptr;
-	struct auxprm *auxp, auxtem;
-	struct disprm *disp, distem;
-	struct wcsprm *wcsp, wcstem;
-	int (*chekval)(double);
-	int (*special)(double *, const double *);
+	struct auxprm auxtem;
+	struct disprm distem;
+	struct wcsprm wcstem;
 	
-	naxis = 0;
-	for (ialt = 0; ialt < 27; ialt++) {
+	int naxis = 0;
+	for (int ialt = 0; ialt < 27; ialt++) {
 	  alts[ialt] = 0;
 	  dpq[ialt]  = 0;
 	  npv[ialt]  = 0;
@@ -21248,63 +21208,64 @@ YY_DECL
 	  ndq[ialt]  = 0;
 	}
 	
-	/* Parameters used to implement YY_INPUT. */
-	wcspih_hdr = header;
-	wcspih_nkeyrec = nkeyrec;
-	
-	/* Our handle on the input stream. */
-	keyrec = header;
-	hptr = header;
-	keep = 0x0;
+	// Our handle on the input stream.
+	char *keyrec = header;
+	char *hptr = header;
+	char *keep = 0x0;
 	
-	/* For keeping tallies of keywords found. */
+	// For keeping tallies of keywords found.
 	*nreject = 0;
-	nvalid = 0;
-	nother = 0;
+	int nvalid = 0;
+	int nother = 0;
 	
-	/* If strict, then also reject. */
+	// If strict, then also reject.
 	if (relax & WCSHDR_strict) relax |= WCSHDR_reject;
 	
-	/* Keyword parameters. */
-	i = j = 0;
-	m = 0;
-	a = ' ';
-	
-	/* For decoding the keyvalue. */
-	valtype = -1;
-	distype =  0;
-	vptr    = 0x0;
-	
-	/* For keywords that require special handling. */
-	altlin  = 0;
-	npptr   = 0x0;
-	chekval = 0x0;
-	special = 0x0;
-	auxprm  = 0;
-	naux    = 0;
-	distran = 0;
-	sipflag = 0;
-	dssflag = 0;
-	watflag = 0;
-	watn    = 0;
+	// Keyword indices, as used in the WCS papers, e.g. PCi_ja, PVi_ma.
+	int i = 0;
+	int j = 0;
+	int m = 0;
+	char a = ' ';
+	
+	// For decoding the keyvalue.
+	int valtype = -1;
+	int distype =  0;
+	void *vptr  = 0x0;
+	
+	// For keywords that require special handling.
+	int altlin  = 0;
+	int *npptr  = 0x0;
+	int (*chekval)(double) = 0x0;
+	int (*special)(double *, const double *) = 0x0;
+	int auxprm  = 0;
+	int naux    = 0;
+	int distran = 0;
+	int sipflag = 0;
+	int dssflag = 0;
+	int watflag = 0;
+	int watn    = 0;
 	
-	/* The data structures produced. */
+	// The data structures produced.
 	*nwcs = 0;
 	*wcs  = 0x0;
 	
-	/* Control variables. */
-	ipass = 1;
-	npass = 2;
-	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
-	if (setjmp(wcspih_abort_jmp_env)) {
-	  return 3;
+	// Control variables.
+	int ipass = 1;
+	int npass = 2;
+	
+	// User data associated with yyscanner.
+	yyextra->hdr = header;
+	yyextra->nkeyrec = nkeyrec;
+	
+	// Return here via longjmp() invoked by yy_fatal_error().
+	if (setjmp(yyextra->abort_jmp_env)) {
+	  return WCSHDRERR_PARSER;
 	}
 	
 	BEGIN(INITIAL);
 
 
-#line 21308 "wcspih.c"
+#line 21269 "wcspih.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -21352,7 +21313,7 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 301 "wcspih.l"
+#line 265 "wcspih.l"
 {
 	  keyname = "NAXISn";
 	
@@ -21375,7 +21336,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 321 "wcspih.l"
+#line 285 "wcspih.l"
 {
 	  sscanf(yytext, "WCSAXES%c= %d", &a, &i);
 	
@@ -21394,7 +21355,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 337 "wcspih.l"
+#line 301 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crpix);
@@ -21405,7 +21366,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 345 "wcspih.l"
+#line 309 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pc);
@@ -21417,7 +21378,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 354 "wcspih.l"
+#line 318 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cd);
@@ -21429,7 +21390,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 363 "wcspih.l"
+#line 327 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cdelt);
@@ -21440,7 +21401,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 371 "wcspih.l"
+#line 335 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crota);
@@ -21452,7 +21413,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 380 "wcspih.l"
+#line 344 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cunit);
@@ -21463,7 +21424,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 388 "wcspih.l"
+#line 352 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ctype);
@@ -21474,7 +21435,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 396 "wcspih.l"
+#line 360 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crval);
@@ -21485,7 +21446,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 404 "wcspih.l"
+#line 368 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.lonpole);
@@ -21496,7 +21457,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 412 "wcspih.l"
+#line 376 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.latpole);
@@ -21507,7 +21468,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 420 "wcspih.l"
+#line 384 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.restfrq);
@@ -21518,7 +21479,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 428 "wcspih.l"
+#line 392 "wcspih.l"
 {
 	  if (relax & WCSHDR_strict) {
 	    errmsg = "the RESTFREQ keyword is deprecated, use RESTFRQa";
@@ -21537,7 +21498,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 444 "wcspih.l"
+#line 408 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.restwav);
@@ -21548,7 +21509,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 452 "wcspih.l"
+#line 416 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -21560,7 +21521,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 461 "wcspih.l"
+#line 425 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -21572,7 +21533,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 470 "wcspih.l"
+#line 434 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ps);
@@ -21584,7 +21545,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 479 "wcspih.l"
+#line 443 "wcspih.l"
 {
 	  sscanf(yytext, "VELREF%c", &a);
 	
@@ -21612,7 +21573,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 504 "wcspih.l"
+#line 468 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cname);
@@ -21623,7 +21584,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 512 "wcspih.l"
+#line 476 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crder);
@@ -21634,7 +21595,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 520 "wcspih.l"
+#line 484 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.csyer);
@@ -21645,7 +21606,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 528 "wcspih.l"
+#line 492 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.czphs);
@@ -21656,7 +21617,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 536 "wcspih.l"
+#line 500 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cperi);
@@ -21667,7 +21628,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 544 "wcspih.l"
+#line 508 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.wcsname;
@@ -21678,7 +21639,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 552 "wcspih.l"
+#line 516 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.timesys;
@@ -21689,7 +21650,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 560 "wcspih.l"
+#line 524 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.trefpos;
@@ -21700,7 +21661,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 568 "wcspih.l"
+#line 532 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.trefdir;
@@ -21711,7 +21672,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 576 "wcspih.l"
+#line 540 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.plephem;
@@ -21722,7 +21683,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 584 "wcspih.l"
+#line 548 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.timeunit;
@@ -21732,10 +21693,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 31:
-#line 593 "wcspih.l"
+#line 557 "wcspih.l"
 case 32:
 YY_RULE_SETUP
-#line 593 "wcspih.l"
+#line 557 "wcspih.l"
 {
 	  if ((yytext[4] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = STRING;
@@ -21754,10 +21715,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 33:
-#line 611 "wcspih.l"
+#line 575 "wcspih.l"
 case 34:
 YY_RULE_SETUP
-#line 611 "wcspih.l"
+#line 575 "wcspih.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT2;
@@ -21776,13 +21737,13 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 35:
-#line 629 "wcspih.l"
+#line 593 "wcspih.l"
 case 36:
 YY_RULE_SETUP
-#line 629 "wcspih.l"
+#line 593 "wcspih.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	
@@ -21799,10 +21760,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 37:
-#line 648 "wcspih.l"
+#line 612 "wcspih.l"
 case 38:
 YY_RULE_SETUP
-#line 648 "wcspih.l"
+#line 612 "wcspih.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT;
@@ -21821,10 +21782,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 39:
-#line 666 "wcspih.l"
+#line 630 "wcspih.l"
 case 40:
 YY_RULE_SETUP
-#line 666 "wcspih.l"
+#line 630 "wcspih.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT2;
@@ -21844,13 +21805,13 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 41:
-#line 685 "wcspih.l"
+#line 649 "wcspih.l"
 case 42:
 YY_RULE_SETUP
-#line 685 "wcspih.l"
+#line 649 "wcspih.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	    special = wcspih_jdrefi;
@@ -21868,10 +21829,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 43:
-#line 705 "wcspih.l"
+#line 669 "wcspih.l"
 case 44:
 YY_RULE_SETUP
-#line 705 "wcspih.l"
+#line 669 "wcspih.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT;
@@ -21892,7 +21853,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 723 "wcspih.l"
+#line 687 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timeoffs);
@@ -21903,7 +21864,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 731 "wcspih.l"
+#line 695 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateobs;
@@ -21915,7 +21876,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 740 "wcspih.l"
+#line 704 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.datebeg;
@@ -21927,7 +21888,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 749 "wcspih.l"
+#line 713 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateavg;
@@ -21939,7 +21900,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 758 "wcspih.l"
+#line 722 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateend;
@@ -21951,7 +21912,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 767 "wcspih.l"
+#line 731 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdobs);
@@ -21963,7 +21924,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 776 "wcspih.l"
+#line 740 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdbeg);
@@ -21975,7 +21936,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 785 "wcspih.l"
+#line 749 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdavg);
@@ -21987,7 +21948,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 794 "wcspih.l"
+#line 758 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdend);
@@ -21999,7 +21960,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 803 "wcspih.l"
+#line 767 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.jepoch);
@@ -22011,7 +21972,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 812 "wcspih.l"
+#line 776 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.bepoch);
@@ -22023,7 +21984,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 821 "wcspih.l"
+#line 785 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.tstart);
@@ -22035,7 +21996,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 830 "wcspih.l"
+#line 794 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.tstop);
@@ -22047,7 +22008,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 839 "wcspih.l"
+#line 803 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.xposure);
@@ -22059,7 +22020,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 848 "wcspih.l"
+#line 812 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.telapse);
@@ -22071,7 +22032,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 857 "wcspih.l"
+#line 821 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timsyer);
@@ -22083,7 +22044,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 866 "wcspih.l"
+#line 830 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timrder);
@@ -22095,7 +22056,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 875 "wcspih.l"
+#line 839 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timedel);
@@ -22107,7 +22068,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 884 "wcspih.l"
+#line 848 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timepixr);
@@ -22120,7 +22081,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 894 "wcspih.l"
+#line 858 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo;
@@ -22132,7 +22093,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 903 "wcspih.l"
+#line 867 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 1;
@@ -22144,7 +22105,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 912 "wcspih.l"
+#line 876 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 2;
@@ -22156,7 +22117,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 921 "wcspih.l"
+#line 885 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 3;
@@ -22168,7 +22129,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 930 "wcspih.l"
+#line 894 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 4;
@@ -22180,7 +22141,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 939 "wcspih.l"
+#line 903 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 5;
@@ -22192,7 +22153,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 948 "wcspih.l"
+#line 912 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.obsorbit;
@@ -22203,7 +22164,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 956 "wcspih.l"
+#line 920 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.radesys;
@@ -22214,7 +22175,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 964 "wcspih.l"
+#line 928 "wcspih.l"
 {
 	  if (relax & WCSHDR_RADECSYS) {
 	    valtype = STRING;
@@ -22236,7 +22197,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 983 "wcspih.l"
+#line 947 "wcspih.l"
 {
 	  sscanf(yytext, "EPOCH%c", &a);
 	
@@ -22265,7 +22226,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 1009 "wcspih.l"
+#line 973 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.equinox);
@@ -22276,7 +22237,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 1017 "wcspih.l"
+#line 981 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.specsys;
@@ -22287,7 +22248,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 1025 "wcspih.l"
+#line 989 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.ssysobs;
@@ -22298,7 +22259,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 1033 "wcspih.l"
+#line 997 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.velosys);
@@ -22309,7 +22270,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 1041 "wcspih.l"
+#line 1005 "wcspih.l"
 {
 	  if (relax & WCSHDR_VSOURCE) {
 	    valtype = FLOAT;
@@ -22332,7 +22293,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 1061 "wcspih.l"
+#line 1025 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.zsource);
@@ -22343,7 +22304,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 1069 "wcspih.l"
+#line 1033 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.ssyssrc;
@@ -22354,7 +22315,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 1077 "wcspih.l"
+#line 1041 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.velangl);
@@ -22365,7 +22326,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 1085 "wcspih.l"
+#line 1049 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -22377,7 +22338,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 1094 "wcspih.l"
+#line 1058 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -22389,7 +22350,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 1103 "wcspih.l"
+#line 1067 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -22401,7 +22362,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 1112 "wcspih.l"
+#line 1076 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -22412,10 +22373,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 86:
-#line 1122 "wcspih.l"
+#line 1086 "wcspih.l"
 case 87:
 YY_RULE_SETUP
-#line 1122 "wcspih.l"
+#line 1086 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -22427,7 +22388,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 1131 "wcspih.l"
+#line 1095 "wcspih.l"
 {
 	  valtype = STRING;
 	  distype = PRIOR;
@@ -22439,7 +22400,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 1140 "wcspih.l"
+#line 1104 "wcspih.l"
 {
 	  valtype = STRING;
 	  distype = SEQUENT;
@@ -22451,7 +22412,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 1149 "wcspih.l"
+#line 1113 "wcspih.l"
 {
 	  valtype = RECORD;
 	  distype = PRIOR;
@@ -22464,7 +22425,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
-#line 1159 "wcspih.l"
+#line 1123 "wcspih.l"
 {
 	  valtype = RECORD;
 	  distype = SEQUENT;
@@ -22477,7 +22438,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-#line 1169 "wcspih.l"
+#line 1133 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  distype = PRIOR;
@@ -22489,7 +22450,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 1178 "wcspih.l"
+#line 1142 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  distype = SEQUENT;
@@ -22501,7 +22462,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-#line 1187 "wcspih.l"
+#line 1151 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  distype = PRIOR;
@@ -22513,9 +22474,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
-#line 1196 "wcspih.l"
+#line 1160 "wcspih.l"
 {
-	  /* SIP: axis 1 polynomial degree (not stored). */
+	  // SIP: axis 1 polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -22529,9 +22490,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 1209 "wcspih.l"
+#line 1173 "wcspih.l"
 {
-	  /* SIP: axis 2 polynomial degree (not stored). */
+	  // SIP: axis 2 polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -22545,9 +22506,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 1222 "wcspih.l"
+#line 1186 "wcspih.l"
 {
-	  /* SIP: axis 1 inverse polynomial degree (not stored). */
+	  // SIP: axis 1 inverse polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -22561,9 +22522,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-#line 1235 "wcspih.l"
+#line 1199 "wcspih.l"
 {
-	  /* SIP: axis 2 inverse polynomial degree (not stored). */
+	  // SIP: axis 2 inverse polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -22577,9 +22538,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-#line 1248 "wcspih.l"
+#line 1212 "wcspih.l"
 {
-	  /* SIP: axis 1 maximum distortion. */
+	  // SIP: axis 1 maximum distortion.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.maxdis);
@@ -22593,9 +22554,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-#line 1261 "wcspih.l"
+#line 1225 "wcspih.l"
 {
-	  /* SIP: axis 2 maximum distortion. */
+	  // SIP: axis 2 maximum distortion.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.maxdis);
@@ -22609,9 +22570,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-#line 1274 "wcspih.l"
+#line 1238 "wcspih.l"
 {
-	  /* SIP: axis 1 polynomial coefficient. */
+	  // SIP: axis 1 polynomial coefficient.
 	  i = 1;
 	  sipflag = 2;
 	
@@ -22621,9 +22582,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 1283 "wcspih.l"
+#line 1247 "wcspih.l"
 {
-	  /* SIP: axis 2 polynomial coefficient. */
+	  // SIP: axis 2 polynomial coefficient.
 	  i = 2;
 	  sipflag = 2;
 	
@@ -22633,9 +22594,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 1292 "wcspih.l"
+#line 1256 "wcspih.l"
 {
-	  /* SIP: axis 1 inverse polynomial coefficient. */
+	  // SIP: axis 1 inverse polynomial coefficient.
 	  i = 1;
 	  sipflag = 3;
 	
@@ -22645,9 +22606,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
-#line 1301 "wcspih.l"
+#line 1265 "wcspih.l"
 {
-	  /* SIP: axis 2 inverse polynomial coefficient. */
+	  // SIP: axis 2 inverse polynomial coefficient.
 	  i = 2;
 	  sipflag = 3;
 	
@@ -22657,9 +22618,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-#line 1310 "wcspih.l"
+#line 1274 "wcspih.l"
 {
-	  /* DSS: LLH corner pixel coordinate 1. */
+	  // DSS: LLH corner pixel coordinate 1.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp;
@@ -22672,9 +22633,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-#line 1322 "wcspih.l"
+#line 1286 "wcspih.l"
 {
-	  /* DSS: LLH corner pixel coordinate 2. */
+	  // DSS: LLH corner pixel coordinate 2.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+1;
@@ -22687,9 +22648,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-#line 1334 "wcspih.l"
+#line 1298 "wcspih.l"
 {
-	  /* DSS: plate centre x-coordinate in micron. */
+	  // DSS: plate centre x-coordinate in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+2;
@@ -22702,9 +22663,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-#line 1346 "wcspih.l"
+#line 1310 "wcspih.l"
 {
-	  /* DSS: plate centre y-coordinate in micron. */
+	  // DSS: plate centre y-coordinate in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+3;
@@ -22717,9 +22678,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
-#line 1358 "wcspih.l"
+#line 1322 "wcspih.l"
 {
-	  /* DSS: pixel x-dimension in micron. */
+	  // DSS: pixel x-dimension in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+4;
@@ -22732,9 +22693,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-#line 1370 "wcspih.l"
+#line 1334 "wcspih.l"
 {
-	  /* DSS: pixel y-dimension in micron. */
+	  // DSS: pixel y-dimension in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+5;
@@ -22747,9 +22708,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
-#line 1382 "wcspih.l"
+#line 1346 "wcspih.l"
 {
-	  /* DSS: plate centre, right ascension - hours. */
+	  // DSS: plate centre, right ascension - hours.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+6;
@@ -22762,9 +22723,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-#line 1394 "wcspih.l"
+#line 1358 "wcspih.l"
 {
-	  /* DSS: plate centre, right ascension - minutes. */
+	  // DSS: plate centre, right ascension - minutes.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+7;
@@ -22777,9 +22738,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-#line 1406 "wcspih.l"
+#line 1370 "wcspih.l"
 {
-	  /* DSS: plate centre, right ascension - seconds. */
+	  // DSS: plate centre, right ascension - seconds.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+8;
@@ -22792,9 +22753,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 114:
 YY_RULE_SETUP
-#line 1418 "wcspih.l"
+#line 1382 "wcspih.l"
 {
-	  /* DSS: plate centre, declination - sign. */
+	  // DSS: plate centre, declination - sign.
 	  valtype = STRING;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+9;
@@ -22807,9 +22768,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
-#line 1430 "wcspih.l"
+#line 1394 "wcspih.l"
 {
-	  /* DSS: plate centre, declination - degrees. */
+	  // DSS: plate centre, declination - degrees.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+10;
@@ -22822,9 +22783,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-#line 1442 "wcspih.l"
+#line 1406 "wcspih.l"
 {
-	  /* DSS: plate centre, declination - arcmin. */
+	  // DSS: plate centre, declination - arcmin.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+11;
@@ -22837,9 +22798,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-#line 1454 "wcspih.l"
+#line 1418 "wcspih.l"
 {
-	  /* DSS: plate centre, declination - arcsec. */
+	  // DSS: plate centre, declination - arcsec.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+12;
@@ -22852,9 +22813,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 1466 "wcspih.l"
+#line 1430 "wcspih.l"
 {
-	  /* DSS: plate identification (insufficient to trigger DSS). */
+	  // DSS: plate identification (insufficient to trigger DSS).
 	  valtype = STRING;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+13;
@@ -22867,9 +22828,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 1478 "wcspih.l"
+#line 1442 "wcspih.l"
 {
-	  /* DSS: axis 1 polynomial coefficient. */
+	  // DSS: axis 1 polynomial coefficient.
 	  i = 1;
 	  dssflag = 3;
 	
@@ -22879,9 +22840,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-#line 1487 "wcspih.l"
+#line 1451 "wcspih.l"
 {
-	  /* DSS: axis 2 polynomial coefficient. */
+	  // DSS: axis 2 polynomial coefficient.
 	  i = 2;
 	  dssflag = 3;
 	
@@ -22891,9 +22852,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 121:
 YY_RULE_SETUP
-#line 1496 "wcspih.l"
+#line 1460 "wcspih.l"
 {
-	  /* TNX or ZPX: string-encoded data array. */
+	  // TNX or ZPX: string-encoded data array.
 	  sscanf(yytext, "WAT%d_%d", &i, &m);
 	  if (watn < m) watn = m;
 	  watflag = 1;
@@ -22911,10 +22872,10 @@ YY_RULE_SETUP
 	YY_BREAK
 case 122:
 YY_RULE_SETUP
-#line 1513 "wcspih.l"
+#line 1477 "wcspih.l"
 {
-	  if (wcspih_nkeyrec) {
-	    wcspih_nkeyrec = 0;
+	  if (yyextra->nkeyrec) {
+	    yyextra->nkeyrec = 0;
 	    errmsg = "keyrecords following the END keyrecord were ignored";
 	    BEGIN(ERROR);
 	  } else {
@@ -22924,161 +22885,161 @@ YY_RULE_SETUP
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-#line 1523 "wcspih.l"
+#line 1487 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 124:
-#line 1528 "wcspih.l"
+#line 1492 "wcspih.l"
 case 125:
-#line 1529 "wcspih.l"
+#line 1493 "wcspih.l"
 case 126:
-#line 1530 "wcspih.l"
+#line 1494 "wcspih.l"
 case 127:
 YY_RULE_SETUP
-#line 1530 "wcspih.l"
+#line 1494 "wcspih.l"
 {
 	  sscanf(yytext, "%d%c", &i, &a);
 	  BEGIN(VALUE);
 	}
 	YY_BREAK
 case 128:
-#line 1536 "wcspih.l"
+#line 1500 "wcspih.l"
 case 129:
-#line 1537 "wcspih.l"
+#line 1501 "wcspih.l"
 case 130:
-#line 1538 "wcspih.l"
+#line 1502 "wcspih.l"
 case 131:
-#line 1539 "wcspih.l"
+#line 1503 "wcspih.l"
 case 132:
-#line 1540 "wcspih.l"
+#line 1504 "wcspih.l"
 case 133:
-#line 1541 "wcspih.l"
+#line 1505 "wcspih.l"
 case 134:
 YY_RULE_SETUP
-#line 1541 "wcspih.l"
+#line 1505 "wcspih.l"
 {
 	  if (relax & WCSHDR_reject) {
-	    /* Violates the basic FITS standard. */
+	    // Violates the basic FITS standard.
 	    errmsg = "indices in parameterized keywords must not have "
 	             "leading zeroes";
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 135:
-#line 1555 "wcspih.l"
+#line 1519 "wcspih.l"
 case 136:
-#line 1556 "wcspih.l"
+#line 1520 "wcspih.l"
 case 137:
-#line 1557 "wcspih.l"
+#line 1521 "wcspih.l"
 case 138:
-#line 1558 "wcspih.l"
+#line 1522 "wcspih.l"
 case 139:
-#line 1559 "wcspih.l"
+#line 1523 "wcspih.l"
 case 140:
-#line 1560 "wcspih.l"
+#line 1524 "wcspih.l"
 case 141:
-#line 1561 "wcspih.l"
+#line 1525 "wcspih.l"
 case 142:
-#line 1562 "wcspih.l"
+#line 1526 "wcspih.l"
 case 143:
 YY_RULE_SETUP
-#line 1562 "wcspih.l"
+#line 1526 "wcspih.l"
 {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
 	YY_BREAK
 case 144:
 YY_RULE_SETUP
-#line 1569 "wcspih.l"
+#line 1533 "wcspih.l"
 {
-	  /* Let it go. */
+	  // Let it go.
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 145:
 YY_RULE_SETUP
-#line 1574 "wcspih.l"
+#line 1538 "wcspih.l"
 {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "keyword looks very much like %s but isn't",
 	      keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Let it go. */
+	    // Let it go.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 146:
-#line 1589 "wcspih.l"
+#line 1553 "wcspih.l"
 case 147:
-#line 1590 "wcspih.l"
+#line 1554 "wcspih.l"
 case 148:
-#line 1591 "wcspih.l"
+#line 1555 "wcspih.l"
 case 149:
 YY_RULE_SETUP
-#line 1591 "wcspih.l"
+#line 1555 "wcspih.l"
 {
 	  sscanf(yytext, "%d_%d%c", &i, &j, &a);
 	  BEGIN(VALUE);
 	}
 	YY_BREAK
 case 150:
-#line 1598 "wcspih.l"
+#line 1562 "wcspih.l"
 case 151:
-#line 1599 "wcspih.l"
+#line 1563 "wcspih.l"
 case 152:
-#line 1600 "wcspih.l"
+#line 1564 "wcspih.l"
 case 153:
-#line 1601 "wcspih.l"
+#line 1565 "wcspih.l"
 case 154:
-#line 1602 "wcspih.l"
+#line 1566 "wcspih.l"
 case 155:
-#line 1603 "wcspih.l"
+#line 1567 "wcspih.l"
 case 156:
-#line 1604 "wcspih.l"
+#line 1568 "wcspih.l"
 case 157:
-#line 1605 "wcspih.l"
+#line 1569 "wcspih.l"
 case 158:
-#line 1606 "wcspih.l"
+#line 1570 "wcspih.l"
 case 159:
-#line 1607 "wcspih.l"
+#line 1571 "wcspih.l"
 case 160:
-#line 1608 "wcspih.l"
+#line 1572 "wcspih.l"
 case 161:
-#line 1609 "wcspih.l"
+#line 1573 "wcspih.l"
 case 162:
-#line 1610 "wcspih.l"
+#line 1574 "wcspih.l"
 case 163:
-#line 1611 "wcspih.l"
+#line 1575 "wcspih.l"
 case 164:
-#line 1612 "wcspih.l"
+#line 1576 "wcspih.l"
 case 165:
-#line 1613 "wcspih.l"
+#line 1577 "wcspih.l"
 case 166:
-#line 1614 "wcspih.l"
+#line 1578 "wcspih.l"
 case 167:
-#line 1615 "wcspih.l"
+#line 1579 "wcspih.l"
 case 168:
-#line 1616 "wcspih.l"
+#line 1580 "wcspih.l"
 case 169:
-#line 1617 "wcspih.l"
+#line 1581 "wcspih.l"
 case 170:
 YY_RULE_SETUP
-#line 1617 "wcspih.l"
+#line 1581 "wcspih.l"
 {
 	  if (((altlin == 1) && (relax & WCSHDR_PC0i_0ja)) ||
 	      ((altlin == 2) && (relax & WCSHDR_CD0i_0ja))) {
@@ -23091,60 +23052,60 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 171:
-#line 1635 "wcspih.l"
+#line 1599 "wcspih.l"
 case 172:
-#line 1636 "wcspih.l"
+#line 1600 "wcspih.l"
 case 173:
-#line 1637 "wcspih.l"
+#line 1601 "wcspih.l"
 case 174:
-#line 1638 "wcspih.l"
+#line 1602 "wcspih.l"
 case 175:
-#line 1639 "wcspih.l"
+#line 1603 "wcspih.l"
 case 176:
-#line 1640 "wcspih.l"
+#line 1604 "wcspih.l"
 case 177:
-#line 1641 "wcspih.l"
+#line 1605 "wcspih.l"
 case 178:
-#line 1642 "wcspih.l"
+#line 1606 "wcspih.l"
 case 179:
-#line 1643 "wcspih.l"
+#line 1607 "wcspih.l"
 case 180:
 YY_RULE_SETUP
-#line 1643 "wcspih.l"
+#line 1607 "wcspih.l"
 {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
 	YY_BREAK
 case 181:
-#line 1651 "wcspih.l"
+#line 1615 "wcspih.l"
 case 182:
-#line 1652 "wcspih.l"
+#line 1616 "wcspih.l"
 case 183:
-#line 1653 "wcspih.l"
+#line 1617 "wcspih.l"
 case 184:
-#line 1654 "wcspih.l"
+#line 1618 "wcspih.l"
 case 185:
-#line 1655 "wcspih.l"
+#line 1619 "wcspih.l"
 case 186:
-#line 1656 "wcspih.l"
+#line 1620 "wcspih.l"
 case 187:
-#line 1657 "wcspih.l"
+#line 1621 "wcspih.l"
 case 188:
-#line 1658 "wcspih.l"
+#line 1622 "wcspih.l"
 case 189:
-#line 1659 "wcspih.l"
+#line 1623 "wcspih.l"
 case 190:
 YY_RULE_SETUP
-#line 1659 "wcspih.l"
+#line 1623 "wcspih.l"
 {
 	  errmsg = errtxt;
 	  sprintf(errmsg, "%s keyword must use an underscore, not a dash",
@@ -23154,9 +23115,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 191:
 YY_RULE_SETUP
-#line 1666 "wcspih.l"
+#line 1630 "wcspih.l"
 {
-	  /* This covers the defunct forms CD00i00j and PC00i00j. */
+	  // This covers the defunct forms CD00i00j and PC00i00j.
 	  if (((altlin == 1) && (relax & WCSHDR_PC00i00j)) ||
 	      ((altlin == 2) && (relax & WCSHDR_CD00i00j))) {
 	    sscanf(yytext, "%3d%3d", &i, &j);
@@ -23171,23 +23132,23 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 192:
 YY_RULE_SETUP
-#line 1687 "wcspih.l"
+#line 1651 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 193:
-#line 1692 "wcspih.l"
+#line 1656 "wcspih.l"
 case 194:
 YY_RULE_SETUP
-#line 1692 "wcspih.l"
+#line 1656 "wcspih.l"
 {
 	  if (YY_START == CCCCCCCa) {
 	    sscanf(yytext, "%c", &a);
@@ -23201,78 +23162,78 @@ YY_RULE_SETUP
 	YY_BREAK
 case 195:
 YY_RULE_SETUP
-#line 1703 "wcspih.l"
+#line 1667 "wcspih.l"
 {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "invalid alternate code, keyword resembles %s "
 	      "but isn't", keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 196:
-#line 1718 "wcspih.l"
+#line 1682 "wcspih.l"
 case 197:
-#line 1719 "wcspih.l"
+#line 1683 "wcspih.l"
 case 198:
-#line 1720 "wcspih.l"
+#line 1684 "wcspih.l"
 case 199:
 YY_RULE_SETUP
-#line 1720 "wcspih.l"
+#line 1684 "wcspih.l"
 {
 	  sscanf(yytext, "%d_%d%c", &i, &m, &a);
 	  BEGIN(VALUE);
 	}
 	YY_BREAK
 case 200:
-#line 1726 "wcspih.l"
+#line 1690 "wcspih.l"
 case 201:
-#line 1727 "wcspih.l"
+#line 1691 "wcspih.l"
 case 202:
-#line 1728 "wcspih.l"
+#line 1692 "wcspih.l"
 case 203:
-#line 1729 "wcspih.l"
+#line 1693 "wcspih.l"
 case 204:
-#line 1730 "wcspih.l"
+#line 1694 "wcspih.l"
 case 205:
-#line 1731 "wcspih.l"
+#line 1695 "wcspih.l"
 case 206:
-#line 1732 "wcspih.l"
+#line 1696 "wcspih.l"
 case 207:
-#line 1733 "wcspih.l"
+#line 1697 "wcspih.l"
 case 208:
-#line 1734 "wcspih.l"
+#line 1698 "wcspih.l"
 case 209:
-#line 1735 "wcspih.l"
+#line 1699 "wcspih.l"
 case 210:
-#line 1736 "wcspih.l"
+#line 1700 "wcspih.l"
 case 211:
-#line 1737 "wcspih.l"
+#line 1701 "wcspih.l"
 case 212:
-#line 1738 "wcspih.l"
+#line 1702 "wcspih.l"
 case 213:
-#line 1739 "wcspih.l"
+#line 1703 "wcspih.l"
 case 214:
-#line 1740 "wcspih.l"
+#line 1704 "wcspih.l"
 case 215:
-#line 1741 "wcspih.l"
+#line 1705 "wcspih.l"
 case 216:
-#line 1742 "wcspih.l"
+#line 1706 "wcspih.l"
 case 217:
-#line 1743 "wcspih.l"
+#line 1707 "wcspih.l"
 case 218:
-#line 1744 "wcspih.l"
+#line 1708 "wcspih.l"
 case 219:
-#line 1745 "wcspih.l"
+#line 1709 "wcspih.l"
 case 220:
 YY_RULE_SETUP
-#line 1745 "wcspih.l"
+#line 1709 "wcspih.l"
 {
 	  if (((valtype == FLOAT)  && (relax & WCSHDR_PV0i_0ma)) ||
 	      ((valtype == STRING) && (relax & WCSHDR_PS0i_0ma))) {
@@ -23285,60 +23246,60 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 221:
-#line 1763 "wcspih.l"
+#line 1727 "wcspih.l"
 case 222:
-#line 1764 "wcspih.l"
+#line 1728 "wcspih.l"
 case 223:
-#line 1765 "wcspih.l"
+#line 1729 "wcspih.l"
 case 224:
-#line 1766 "wcspih.l"
+#line 1730 "wcspih.l"
 case 225:
-#line 1767 "wcspih.l"
+#line 1731 "wcspih.l"
 case 226:
-#line 1768 "wcspih.l"
+#line 1732 "wcspih.l"
 case 227:
-#line 1769 "wcspih.l"
+#line 1733 "wcspih.l"
 case 228:
-#line 1770 "wcspih.l"
+#line 1734 "wcspih.l"
 case 229:
-#line 1771 "wcspih.l"
+#line 1735 "wcspih.l"
 case 230:
 YY_RULE_SETUP
-#line 1771 "wcspih.l"
+#line 1735 "wcspih.l"
 {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
 	YY_BREAK
 case 231:
-#line 1779 "wcspih.l"
+#line 1743 "wcspih.l"
 case 232:
-#line 1780 "wcspih.l"
+#line 1744 "wcspih.l"
 case 233:
-#line 1781 "wcspih.l"
+#line 1745 "wcspih.l"
 case 234:
-#line 1782 "wcspih.l"
+#line 1746 "wcspih.l"
 case 235:
-#line 1783 "wcspih.l"
+#line 1747 "wcspih.l"
 case 236:
-#line 1784 "wcspih.l"
+#line 1748 "wcspih.l"
 case 237:
-#line 1785 "wcspih.l"
+#line 1749 "wcspih.l"
 case 238:
-#line 1786 "wcspih.l"
+#line 1750 "wcspih.l"
 case 239:
-#line 1787 "wcspih.l"
+#line 1751 "wcspih.l"
 case 240:
 YY_RULE_SETUP
-#line 1787 "wcspih.l"
+#line 1751 "wcspih.l"
 {
 	  errmsg = errtxt;
 	  sprintf(errmsg, "%s keyword must use an underscore, not a dash",
@@ -23348,18 +23309,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 241:
 YY_RULE_SETUP
-#line 1794 "wcspih.l"
+#line 1758 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 242:
-#line 1799 "wcspih.l"
+#line 1763 "wcspih.l"
 case 243:
-#line 1800 "wcspih.l"
+#line 1764 "wcspih.l"
 case 244:
 YY_RULE_SETUP
-#line 1800 "wcspih.l"
+#line 1764 "wcspih.l"
 {
 	  a = ' ';
 	  sscanf(yytext, "%d%c", &i, &a);
@@ -23377,14 +23338,14 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 245:
 YY_RULE_SETUP
-#line 1822 "wcspih.l"
+#line 1786 "wcspih.l"
 {
 	  yyless(0);
 	  BEGIN(CCCCCia);
@@ -23392,7 +23353,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 246:
 YY_RULE_SETUP
-#line 1827 "wcspih.l"
+#line 1791 "wcspih.l"
 {
 	  if (relax & WCSHDR_PROJPn) {
 	    sscanf(yytext, "%d", &m);
@@ -23410,10 +23371,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 247:
-#line 1844 "wcspih.l"
+#line 1808 "wcspih.l"
 case 248:
 YY_RULE_SETUP
-#line 1844 "wcspih.l"
+#line 1808 "wcspih.l"
 {
 	  if (relax & (WCSHDR_PROJPn | WCSHDR_reject)) {
 	    errmsg = "invalid PROJPn keyword";
@@ -23426,18 +23387,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 249:
 YY_RULE_SETUP
-#line 1854 "wcspih.l"
+#line 1818 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 250:
-#line 1859 "wcspih.l"
+#line 1823 "wcspih.l"
 case 251:
 YY_RULE_SETUP
-#line 1859 "wcspih.l"
+#line 1823 "wcspih.l"
 {
-	  /* SIP keywords. */
+	  // SIP keywords.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.dp);
@@ -23451,21 +23412,21 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 252:
-#line 1874 "wcspih.l"
+#line 1838 "wcspih.l"
 case 253:
 YY_RULE_SETUP
-#line 1874 "wcspih.l"
+#line 1838 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 254:
-#line 1879 "wcspih.l"
+#line 1843 "wcspih.l"
 case 255:
 YY_RULE_SETUP
-#line 1879 "wcspih.l"
+#line 1843 "wcspih.l"
 {
-	  /* DSS keywords. */
+	  // DSS keywords.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = &(distem.dp);
@@ -23480,7 +23441,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 256:
 YY_RULE_SETUP
-#line 1893 "wcspih.l"
+#line 1857 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
@@ -23488,11 +23449,11 @@ YY_RULE_SETUP
 case 257:
 /* rule 257 can match eol */
 YY_RULE_SETUP
-#line 1897 "wcspih.l"
+#line 1861 "wcspih.l"
 {
-	  /* Special handling for this iconic DSS keyword. */
+	  // Special handling for this iconic DSS keyword.
 	  if (1 < ipass) {
-	    /* Look for a minus sign. */
+	    // Look for a minus sign.
 	    sscanf(yytext, "= '%s", strtmp);
 	    dbltmp = strcmp(strtmp, "-") ? 1.0 : -1.0;
 	  }
@@ -23502,16 +23463,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 258:
 YY_RULE_SETUP
-#line 1908 "wcspih.l"
+#line 1872 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 259:
 YY_RULE_SETUP
-#line 1912 "wcspih.l"
+#line 1876 "wcspih.l"
 {
-	  /* Do checks on i, j & m. */
+	  // Do checks on i, j & m.
 	  if (99 < i || 99 < j || 99 < m) {
 	    if (relax & WCSHDR_reject) {
 	      if (99 < i || 99 < j) {
@@ -23522,7 +23483,7 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -23548,7 +23509,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 260:
 YY_RULE_SETUP
-#line 1948 "wcspih.l"
+#line 1912 "wcspih.l"
 {
 	  errmsg = "invalid KEYWORD = VALUE syntax";
 	  BEGIN(ERROR);
@@ -23556,13 +23517,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 261:
 YY_RULE_SETUP
-#line 1953 "wcspih.l"
+#line 1917 "wcspih.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    sscanf(yytext, "%d", &inttmp);
 	
 	    BEGIN(COMMENT);
@@ -23571,7 +23532,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 262:
 YY_RULE_SETUP
-#line 1965 "wcspih.l"
+#line 1929 "wcspih.l"
 {
 	  errmsg = "an integer value was expected";
 	  BEGIN(ERROR);
@@ -23579,13 +23540,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 263:
 YY_RULE_SETUP
-#line 1970 "wcspih.l"
+#line 1934 "wcspih.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    wcsutil_str2double(yytext, &dbltmp);
 
 	    if (chekval && chekval(dbltmp)) {
@@ -23599,7 +23560,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 264:
 YY_RULE_SETUP
-#line 1987 "wcspih.l"
+#line 1951 "wcspih.l"
 {
 	  errmsg = "a floating-point value was expected";
 	  BEGIN(ERROR);
@@ -23607,13 +23568,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 265:
 YY_RULE_SETUP
-#line 1992 "wcspih.l"
+#line 1956 "wcspih.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue as integer and fractional parts. */
+	    // Read the keyvalue as integer and fractional parts.
 	    wcsutil_str2double2(yytext, dbl2tmp);
 	
 	    BEGIN(COMMENT);
@@ -23622,7 +23583,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 266:
 YY_RULE_SETUP
-#line 2004 "wcspih.l"
+#line 1968 "wcspih.l"
 {
 	  errmsg = "a floating-point value was expected";
 	  BEGIN(ERROR);
@@ -23631,18 +23592,18 @@ YY_RULE_SETUP
 case 267:
 /* rule 267 can match eol */
 YY_RULE_SETUP
-#line 2009 "wcspih.l"
+#line 1973 "wcspih.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    strcpy(strtmp, yytext+1);
 	
-	    /* Squeeze out repeated quotes. */
-	    ix = 0;
-	    for (jx = 0; jx < 72; jx++) {
+	    // Squeeze out repeated quotes.
+	    int ix = 0;
+	    for (int jx = 0; jx < 72; jx++) {
 	      if (ix < jx) {
 	        strtmp[ix] = strtmp[jx];
 	      }
@@ -23663,7 +23624,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 268:
 YY_RULE_SETUP
-#line 2038 "wcspih.l"
+#line 2002 "wcspih.l"
 {
 	  errmsg = "a string value was expected";
 	  BEGIN(ERROR);
@@ -23672,7 +23633,7 @@ YY_RULE_SETUP
 case 269:
 /* rule 269 can match eol */
 YY_RULE_SETUP
-#line 2043 "wcspih.l"
+#line 2007 "wcspih.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
@@ -23686,7 +23647,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 270:
 YY_RULE_SETUP
-#line 2054 "wcspih.l"
+#line 2018 "wcspih.l"
 {
 	  errmsg = "a record was expected";
 	  BEGIN(ERROR);
@@ -23694,7 +23655,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 271:
 YY_RULE_SETUP
-#line 2059 "wcspih.l"
+#line 2023 "wcspih.l"
 {
 	  strcpy(strtmp, yytext);
 	  BEGIN(RECCOLON);
@@ -23702,7 +23663,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 272:
 YY_RULE_SETUP
-#line 2064 "wcspih.l"
+#line 2028 "wcspih.l"
 {
 	  errmsg = "invalid record field";
 	  BEGIN(ERROR);
@@ -23710,14 +23671,14 @@ YY_RULE_SETUP
 	YY_BREAK
 case 273:
 YY_RULE_SETUP
-#line 2069 "wcspih.l"
+#line 2033 "wcspih.l"
 {
 	  BEGIN(RECVALUE);
 	}
 	YY_BREAK
 case 274:
 YY_RULE_SETUP
-#line 2073 "wcspih.l"
+#line 2037 "wcspih.l"
 {
 	  errmsg = "invalid record syntax";
 	  BEGIN(ERROR);
@@ -23725,7 +23686,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 275:
 YY_RULE_SETUP
-#line 2078 "wcspih.l"
+#line 2042 "wcspih.l"
 {
 	  rectype = 0;
 	  sscanf(yytext, "%d", &inttmp);
@@ -23734,7 +23695,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 276:
 YY_RULE_SETUP
-#line 2084 "wcspih.l"
+#line 2048 "wcspih.l"
 {
 	  rectype = 1;
 	  wcsutil_str2double(yytext, &dbltmp);
@@ -23743,7 +23704,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 277:
 YY_RULE_SETUP
-#line 2090 "wcspih.l"
+#line 2054 "wcspih.l"
 {
 	  errmsg = "invalid record value";
 	  BEGIN(ERROR);
@@ -23751,7 +23712,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 278:
 YY_RULE_SETUP
-#line 2095 "wcspih.l"
+#line 2059 "wcspih.l"
 {
 	  BEGIN(COMMENT);
 	}
@@ -23761,19 +23722,19 @@ case 279:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2099 "wcspih.l"
+#line 2063 "wcspih.l"
 {
 	  if (ipass == 1) {
-	    /* Do first-pass bookkeeping. */
+	    // Do first-pass bookkeeping.
 	    wcspih_pass1(naxis, i, j, a, distype, alts, dpq, npptr);
 	    BEGIN(FLUSH);
 	
 	  } else if (*wcs) {
-	    /* Store the value now that the keyrecord has been validated. */
-	    gotone = 0;
-	    for (ialt = 0; ialt < *nwcs; ialt++) {
-	      /* The loop here is for keywords that apply */
-	      /* to every alternate; these have a == 0. */
+	    // Store the value now that the keyrecord has been validated.
+	    int gotone = 0;
+	    for (int ialt = 0; ialt < *nwcs; ialt++) {
+	      // The loop here is for keywords that apply
+	      // to every alternate; these have a == 0.
 	      if (a >= 'A') {
 	        ialt = alts[a-'A'+1];
 	        if (ialt < 0) break;
@@ -23782,11 +23743,12 @@ YY_RULE_SETUP
 	
 	      if (vptr) {
 	        if (sipflag) {
-	          /* Translate a SIP keyword into DPja. */
-	          disp = (*wcs)->lin.dispre;
-	          ipx = (disp->ndp)++;
+	          // Translate a SIP keyword into DPja.
+	          struct disprm *disp = (*wcs)->lin.dispre;
+	          int ipx = (disp->ndp)++;
 	
-	          /* SIP doesn't have alternates. */
+	          // SIP doesn't have alternates.
+		  char keyword[16];
 	          sprintf(keyword, "DP%d", i);
 	          sprintf(strtmp, "SIP.%s.%d_%d", (sipflag==2)?"FWD":"REV",
 	                  p, q);
@@ -23797,27 +23759,28 @@ YY_RULE_SETUP
 	          }
 	
 	        } else if (dssflag) {
-	          /* All DSS keywords require special handling. */
+	          // All DSS keywords require special handling.
 	          if (dssflag == 1) {
-	            /* Temporary parameter for DSS used by wcspih_final(). */
+	            // Temporary parameter for DSS used by wcspih_final().
 	            *((double *)vptr) = dbltmp;
 	
 	          } else if (dssflag == 2) {
-	            /* Temporary parameter for DSS used by wcspih_final(). */
+	            // Temporary parameter for DSS used by wcspih_final().
 	            strcpy((char *)vptr, strtmp);
 	
 	          } else {
-	            /* Translate a DSS keyword into DQia. */
+	            // Translate a DSS keyword into DQia.
 	            if (m <= 13 || dbltmp != 0.0) {
-	              disp = (*wcs)->lin.disseq;
-	              ipx = (disp->ndp)++;
+	              struct disprm *disp = (*wcs)->lin.disseq;
+	              int ipx = (disp->ndp)++;
 	
-	              /* DSS doesn't have alternates. */
+	              // DSS doesn't have alternates.
+		      char keyword[16];
 	              sprintf(keyword, "DQ%d", i);
 	              sprintf(strtmp, "DSS.AMD.%d", m);
 	              dpfill(disp->dp+ipx, keyword, strtmp, i, 1, 0, dbltmp);
 	
-	              /* Also required by wcspih_final(). */
+	              // Also required by wcspih_final().
 	              if (m <= 3) {
 	                dsstmp[13+(i-1)*3+m] = dbltmp;
 	              }
@@ -23825,32 +23788,35 @@ YY_RULE_SETUP
 	          }
 	
 	        } else if (watflag) {
-	          /* String array for TNX and ZPX used by wcspih_final(). */
+	          // String array for TNX and ZPX used by wcspih_final().
 	          strcpy((char *)vptr, strtmp);
 	
 	        } else {
-	          /* An "ordinary" keyword. */
-	          wcsp = *wcs + ialt;
+	          // An "ordinary" keyword.
+	          struct wcsprm *wcsp = *wcs + ialt;
+		  struct disprm *disp;
+	          void *wptr;
+	          ptrdiff_t voff;
 	          if (auxprm) {
-	            /* Additional auxiliary parameter. */
-	            auxp = wcsp->aux;
+	            // Additional auxiliary parameter.
+	            struct auxprm *auxp = wcsp->aux;
 	            voff = (char *)vptr - (char *)(&auxtem);
 	            wptr = (void *)((char *)auxp + voff);
 	
 	          } else if (distype) {
-	            /* Distortion parameter of some kind. */
+	            // Distortion parameter of some kind.
 	            if (distype == PRIOR) {
-	              /* Prior distortion. */
+	              // Prior distortion.
 	              disp = wcsp->lin.dispre;
 	            } else {
-	              /* Sequent distortion. */
+	              // Sequent distortion.
 	              disp = wcsp->lin.disseq;
 	            }
 	            voff = (char *)vptr - (char *)(&distem);
 	            wptr = (void *)((char *)disp + voff);
 	
 	          } else {
-	            /* A parameter that lives directly in wcsprm. */
+	            // A parameter that lives directly in wcsprm.
 	            voff = (char *)vptr - (char *)(&wcstem);
 	            wptr = (void *)((char *)wcsp + voff);
 	          }
@@ -23859,9 +23825,9 @@ YY_RULE_SETUP
 	            *((int *)wptr) = inttmp;
 	
 	          } else if (valtype == FLOAT) {
-	            /* Apply keyword parameterization. */
+	            // Apply keyword parameterization.
 	            if (npptr == npv) {
-	              ipx = (wcsp->npv)++;
+	              int ipx = (wcsp->npv)++;
 	              wcsp->pv[ipx].i = i;
 	              wcsp->pv[ipx].m = m;
 	              wptr = &(wcsp->pv[ipx].value);
@@ -23880,14 +23846,14 @@ YY_RULE_SETUP
 	              *((double *)wptr) = dbltmp;
 	            }
 	
-	            /* Flag presence of PCi_ja, or CDi_ja and/or CROTAia. */
+	            // Flag presence of PCi_ja, or CDi_ja and/or CROTAia.
 	            if (altlin) {
 	              wcsp->altlin |= altlin;
 	              altlin = 0;
 	            }
 	
 	          } else if (valtype == FLOAT2) {
-	            /* Split MJDREF and JDREF into integer and fraction.*/
+	            // Split MJDREF and JDREF into integer and fraction.
 	            if (special) {
 	              special(wptr, dbl2tmp);
 	            } else {
@@ -23896,9 +23862,9 @@ YY_RULE_SETUP
 	            }
 	
 	          } else if (valtype == STRING) {
-	            /* Apply keyword parameterization. */
+	            // Apply keyword parameterization.
 	            if (npptr == nps) {
-	              ipx = (wcsp->nps)++;
+	              int ipx = (wcsp->nps)++;
 	              wcsp->ps[ipx].i = i;
 	              wcsp->ps[ipx].m = m;
 	              wptr = wcsp->ps[ipx].value;
@@ -23911,12 +23877,13 @@ YY_RULE_SETUP
 	              wptr = *((char (**)[72])wptr) + (i - 1);
 	            }
 	
-	            cptr = (char *)wptr;
+	            char *cptr = (char *)wptr;
 	            strcpy(cptr, strtmp);
 	
 	          } else if (valtype == RECORD) {
-	            ipx = (disp->ndp)++;
+	            int ipx = (disp->ndp)++;
 	
+		    char keyword[16];
 	            if (a == ' ') {
 	              sprintf(keyword, "%.2s%d", keyname, i);
 	            } else {
@@ -23937,7 +23904,7 @@ YY_RULE_SETUP
 	      if (ctrl == 4) {
 	        if (distran || dssflag) {
 	          wcsfprintf(stderr, "%.80s\n  Accepted (%d) as a "
-	            "recognised WCS convention.\n", keyrec, nvalid);
+	            "recognized WCS convention.\n", keyrec, nvalid);
 	        } else {
 	          wcsfprintf(stderr, "%.80s\n  Accepted (%d) as a "
 	            "valid WCS keyrecord.\n", keyrec, nvalid);
@@ -23961,7 +23928,7 @@ case 280:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2293 "wcspih.l"
+#line 2263 "wcspih.l"
 {
 	  errmsg = "invalid keyvalue";
 	  BEGIN(ERROR);
@@ -23972,7 +23939,7 @@ case 281:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2298 "wcspih.l"
+#line 2268 "wcspih.l"
 {
 	  errmsg = "invalid keyvalue";
 	  BEGIN(ERROR);
@@ -23983,7 +23950,7 @@ case 282:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2303 "wcspih.l"
+#line 2273 "wcspih.l"
 {
 	  errmsg = "invalid keyvalue or malformed keycomment";
 	  BEGIN(ERROR);
@@ -23994,7 +23961,7 @@ case 283:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2308 "wcspih.l"
+#line 2278 "wcspih.l"
 {
 	  errmsg = "malformed keycomment";
 	  BEGIN(ERROR);
@@ -24005,11 +23972,11 @@ case 284:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2313 "wcspih.l"
+#line 2283 "wcspih.l"
 {
 	  if (ipass == npass) {
 	    if (ctrl < 0) {
-	      /* Preserve discards. */
+	      // Preserve discards.
 	      keep = keyrec;
 	
 	    } else if (2 < ctrl) {
@@ -24026,13 +23993,13 @@ case 285:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2328 "wcspih.l"
+#line 2298 "wcspih.l"
 {
 	  if (ipass == npass) {
 	    (*nreject)++;
 	
 	    if (ctrl%10 == -1) {
-	      /* Preserve rejects. */
+	      // Preserve rejects.
 	      keep = keyrec;
 	    }
 	
@@ -24047,7 +24014,7 @@ YY_RULE_SETUP
 case 286:
 /* rule 286 can match eol */
 YY_RULE_SETUP
-#line 2345 "wcspih.l"
+#line 2315 "wcspih.l"
 {
 	  if (ipass == npass && keep) {
 	    if (hptr < keep) {
@@ -24058,7 +24025,7 @@ YY_RULE_SETUP
 	
 	  naux += auxprm;
 	
-	  /* Throw away the rest of the line and reset for the next one. */
+	  // Throw away the rest of the line and reset for the next one.
 	  i = j = 0;
 	  m = 0;
 	  a = ' ';
@@ -24109,9 +24076,10 @@ case YY_STATE_EOF(COMMENT):
 case YY_STATE_EOF(DISCARD):
 case YY_STATE_EOF(ERROR):
 case YY_STATE_EOF(FLUSH):
-#line 2379 "wcspih.l"
+#line 2349 "wcspih.l"
 {
-	  /* End-of-input. */
+	  // End-of-input.
+	  int status;
 	  if (ipass == 1) {
 	    if ((status = wcspih_init1(naxis, alts, dpq, npv, nps, ndp, ndq,
 	                               naux, distran, nwcs, wcs)) ||
@@ -24136,8 +24104,8 @@ case YY_STATE_EOF(FLUSH):
 	  }
 	
 	  if (ipass++ < npass) {
-	    wcspih_hdr = header;
-	    wcspih_nkeyrec = nkeyrec;
+	    yyextra->hdr = header;
+	    yyextra->nkeyrec = nkeyrec;
 	    keyrec = header;
 	    *nreject = 0;
 	
@@ -24185,10 +24153,10 @@ case YY_STATE_EOF(FLUSH):
 	YY_BREAK
 case 287:
 YY_RULE_SETUP
-#line 2452 "wcspih.l"
+#line 2423 "wcspih.l"
 ECHO;
 	YY_BREAK
-#line 24192 "wcspih.c"
+#line 24160 "wcspih.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -25353,7 +25321,36 @@ void yyfree (void * ptr , yyscan_t yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 2452 "wcspih.l"
+#line 2423 "wcspih.l"
+
+
+/*----------------------------------------------------------------------------
+* External interface to the scanner.
+*---------------------------------------------------------------------------*/
+
+int wcspih(
+  char *header,
+  int nkeyrec,
+  int relax,
+  int ctrl,
+  int *nreject,
+  int *nwcs,
+  struct wcsprm **wcs)
+
+{
+  // Function prototypes.
+  int yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *yyscanner);
+  int yylex_destroy(yyscan_t yyscanner);
+
+  struct wcspih_extra extra;
+  yyscan_t yyscanner;
+  yylex_init_extra(&extra, &yyscanner);
+  int status = wcspih_scanner(header, nkeyrec, relax, ctrl, nreject, nwcs,
+                              wcs, yyscanner);
+  yylex_destroy(yyscanner);
+
+  return status;
+}
 
 
 /*----------------------------------------------------------------------------
@@ -25373,26 +25370,24 @@ void wcspih_pass1(
   int *npptr)
 
 {
-  /* On the first pass alts[] is used to determine the number of axes */
-  /* for each of the 27 possible alternate coordinate descriptions.   */
-  int ialt, *ip;
-
+  // On the first pass alts[] is used to determine the number of axes
+  // for each of the 27 possible alternate coordinate descriptions.
   if (a == 0) {
     return;
   }
 
-  ialt = 0;
+  int ialt = 0;
   if (a != ' ') {
     ialt = a - 'A' + 1;
   }
 
-  ip = alts + ialt;
+  int *ip = alts + ialt;
 
   if (*ip < naxis) {
     *ip = naxis;
   }
 
-  /* i or j can be greater than naxis. */
+  // i or j can be greater than naxis.
   if (*ip < i) {
     *ip = i;
   }
@@ -25401,10 +25396,10 @@ void wcspih_pass1(
     *ip = j;
   }
 
-  /* Type of distortions present. */
+  // Type of distortions present.
   dpq[ialt] |= distype;
 
-  /* Count PVi_ma, PSi_ma, DPja, or DQia keywords. */
+  // Count PVi_ma, PSi_ma, DPja, or DQia keywords.
   if (npptr) {
     npptr[ialt]++;
   }
@@ -25430,115 +25425,115 @@ int wcspih_init1(
   struct wcsprm **wcs)
 
 {
-  int ialt, defaults, ndis, ndpmax, npsmax, npvmax, status = 0;
-  struct wcsprm *wcsp;
-  struct disprm *dis;
+  int status = 0;
 
-  /* Find the number of coordinate descriptions. */
+  // Find the number of coordinate descriptions.
   *nwcs = 0;
-  for (ialt = 0; ialt < 27; ialt++) {
+  for (int ialt = 0; ialt < 27; ialt++) {
     if (alts[ialt]) (*nwcs)++;
   }
 
+  int defaults;
   if ((defaults = !(*nwcs) && naxis)) {
-    /* NAXIS is non-zero but there were no WCS keywords with an alternate
-       version code; create a default WCS with blank alternate version. */
+    // NAXIS is non-zero but there were no WCS keywords with an alternate
+    // version code; create a default WCS with blank alternate version.
     wcspih_pass1(naxis, 0, 0, ' ', 0, alts, dpq, 0x0);
     *nwcs = 1;
   }
 
   if (*nwcs) {
-    /* Allocate memory for the required number of wcsprm structs. */
+    // Allocate memory for the required number of wcsprm structs.
     if ((*wcs = calloc(*nwcs, sizeof(struct wcsprm))) == 0x0) {
       return WCSHDRERR_MEMORY;
     }
 
-    ndis = 0;
+    int ndis = 0;
     if (distran == SIP) {
-      /* DPja.NAXES and DPja.OFFSET.j to be added for SIP (see below and
-         wcspih_final()). */
+      // DPja.NAXES and DPja.OFFSET.j to be added for SIP (see below and
+      // wcspih_final()).
       ndp[0] += 6;
 
     } else if (distran == DSS) {
-      /* DPja.NAXES to be added for DSS (see below and wcspih_final()). */
+      // DPja.NAXES to be added for DSS (see below and wcspih_final()).
       ndq[0] += 2;
     }
 
-    /* Initialize each wcsprm struct. */
-    wcsp = *wcs;
+    // Initialize each wcsprm struct.
+    struct wcsprm *wcsp = *wcs;
     *nwcs = 0;
-    for (ialt = 0; ialt < 27; ialt++) {
+    for (int ialt = 0; ialt < 27; ialt++) {
       if (alts[ialt]) {
         wcsp->flag = -1;
-        npvmax = npv[ialt];
-        npsmax = nps[ialt];
+        int npvmax = npv[ialt];
+        int npsmax = nps[ialt];
         if ((status = wcsinit(1, alts[ialt], wcsp, npvmax, npsmax, -1))) {
           wcsvfree(nwcs, wcs);
           break;
         }
 
-        /* Record the alternate version code. */
+        // Record the alternate version code.
         if (ialt) {
           wcsp->alt[0] = 'A' + ialt - 1;
         }
 
-        /* Record in wcsname whether this is a default description. */
+        // Record in wcsname whether this is a default description.
         if (defaults) {
           strcpy(wcsp->wcsname, "DEFAULTS");
         }
 
-        /* Any additional auxiliary keywords present? */
+        // Any additional auxiliary keywords present?
         if (naux) {
           if (wcsauxi(1, wcsp)) {
             return WCSHDRERR_MEMORY;
           }
         }
 
-        /* Any distortions present? */
+        // Any distortions present?
+        struct disprm *disp;
         if (dpq[ialt] & 1) {
-          if ((dis = calloc(1, sizeof(struct disprm))) == 0x0) {
+          if ((disp = calloc(1, sizeof(struct disprm))) == 0x0) {
             return WCSHDRERR_MEMORY;
           }
 
-          /* Attach it to linprm.  Also inits it. */
+          // Attach it to linprm.  Also inits it.
           ndis++;
-          ndpmax = ndp[ialt];
-          dis->flag = -1;
-          lindist(1, &(wcsp->lin), dis, ndpmax);
+          int ndpmax = ndp[ialt];
+          disp->flag = -1;
+          lindist(1, &(wcsp->lin), disp, ndpmax);
         }
 
         if (dpq[ialt] & 2) {
-          if ((dis = calloc(1, sizeof(struct disprm))) == 0x0) {
+          if ((disp = calloc(1, sizeof(struct disprm))) == 0x0) {
             return WCSHDRERR_MEMORY;
           }
 
-          /* Attach it to linprm.  Also inits it. */
+          // Attach it to linprm.  Also inits it.
           ndis++;
-          ndpmax = ndq[ialt];
-          dis->flag = -1;
-          lindist(2, &(wcsp->lin), dis, ndpmax);
+          int ndpmax = ndq[ialt];
+          disp->flag = -1;
+          lindist(2, &(wcsp->lin), disp, ndpmax);
         }
 
-        /* On the second pass alts[] indexes the array of wcsprm structs. */
+        // On the second pass alts[] indexes the array of wcsprm structs.
         alts[ialt] = (*nwcs)++;
 
         wcsp++;
 
       } else {
-        /* Signal that there is no wcsprm for this alt. */
+        // Signal that there is no wcsprm for this alt.
         alts[ialt] = -1;
       }
     }
 
 
-    /* Translated distortion?  Neither SIP nor DSS have alternates, so the */
-    /* presence of keywords for either (not both together), as flagged by  */
-    /* distran, necessarily refers to the primary representation.          */
+    // Translated distortion?  Neither SIP nor DSS have alternates, so the
+    // presence of keywords for either (not both together), as flagged by
+    // distran, necessarily refers to the primary representation.
     if (distran == SIP) {
       strcpy((*wcs)->lin.dispre->dtype[0], "SIP");
       strcpy((*wcs)->lin.dispre->dtype[1], "SIP");
 
-      /* SIP doesn't have axis mapping. */
+      // SIP doesn't have axis mapping.
       (*wcs)->lin.dispre->ndp = 6;
       dpfill((*wcs)->lin.dispre->dp,   "DP1", "NAXES",  0, 0, 2, 0.0);
       dpfill((*wcs)->lin.dispre->dp+3, "DP2", "NAXES",  0, 0, 2, 0.0);
@@ -25547,7 +25542,7 @@ int wcspih_init1(
       strcpy((*wcs)->lin.disseq->dtype[0], "DSS");
       strcpy((*wcs)->lin.disseq->dtype[1], "DSS");
 
-      /* The Paper IV translation of DSS doesn't require an axis mapping. */
+      // The Paper IV translation of DSS doesn't require an axis mapping.
       (*wcs)->lin.disseq->ndp = 2;
       dpfill((*wcs)->lin.disseq->dp,   "DQ1", "NAXES",  0, 0, 2, 0.0);
       dpfill((*wcs)->lin.disseq->dp+1, "DQ2", "NAXES",  0, 0, 2, 0.0);
@@ -25565,7 +25560,7 @@ int wcspih_init1(
 int wcspih_jdref(double *mjdref, const double *jdref)
 
 {
-  /* Set MJDREF from JDREF. */
+  // Set MJDREF from JDREF.
   if (undefined(mjdref[0] && undefined(mjdref[1]))) {
     mjdref[0] = jdref[0] - 2400000.0;
     mjdref[1] = jdref[1] - 0.5;
@@ -25582,7 +25577,7 @@ int wcspih_jdref(double *mjdref, const d
 int wcspih_jdrefi(double *mjdref, const double *jdrefi)
 
 {
-  /* Set the integer part of MJDREF from JDREFI. */
+  // Set the integer part of MJDREF from JDREFI.
   if (undefined(mjdref[0])) {
     mjdref[0] = *jdrefi - 2400000.5;
   }
@@ -25594,7 +25589,7 @@ int wcspih_jdrefi(double *mjdref, const
 int wcspih_jdreff(double *mjdref, const double *jdreff)
 
 {
-  /* Set the fractional part of MJDREF from JDREFF. */
+  // Set the fractional part of MJDREF from JDREFF.
   if (undefined(mjdref[1])) {
     mjdref[1] = *jdreff;
   }
@@ -25610,7 +25605,7 @@ int wcspih_jdreff(double *mjdref, const
 int wcspih_epoch(double *equinox, const double *epoch)
 
 {
-  /* If EQUINOXa is currently undefined then set it from EPOCHa. */
+  // If EQUINOXa is currently undefined then set it from EPOCHa.
   if (undefined(*equinox)) {
     *equinox = *epoch;
   }
@@ -25626,12 +25621,12 @@ int wcspih_epoch(double *equinox, const
 int wcspih_vsource(double *zsource, const double *vsource)
 
 {
-  double beta, c = 299792458.0;
+  const double c = 299792458.0;
 
-  /* If ZSOURCEa is currently undefined then set it from VSOURCEa. */
+  // If ZSOURCEa is currently undefined then set it from VSOURCEa.
   if (undefined(*zsource)) {
-    /* Convert relativistic Doppler velocity to redshift. */
-    beta = *vsource/c;
+    // Convert relativistic Doppler velocity to redshift.
+    double beta = *vsource/c;
     *zsource = (1.0 + beta)/sqrt(1.0 - beta*beta) - 1.0;
   }
 
@@ -25664,58 +25659,52 @@ int wcspih_final(
   struct wcsprm **wcs)
 
 {
-  char   field[32], *wp, wpoly[12], wtype[8];
-  int    i, ialt, idp, ipv, m, npv, n, nterms, omax, omin, status, wctrl[4];
-  double A1, A2, A3, B1, B2, B3, CNPIX1, CNPIX2, *crval, Rx, Ry, S, wval,
-         X0, Y0, Xc, Yc;
-  struct disprm *disp;
-  struct wcsprm *wcsp;
-
-  for (ialt = 0; ialt < *nwcs; ialt++) {
-    /* Interpret -TAB header keywords. */
+  for (int ialt = 0; ialt < *nwcs; ialt++) {
+    // Interpret -TAB header keywords.
+    int status;
     if ((status = wcstab(*wcs+ialt))) {
        wcsvfree(nwcs, wcs);
        return status;
     }
 
     if (ndp[ialt] && ndq[ialt]) {
-      /* Prior and sequent distortions co-exist in this representation;
-         ensure the latter gets DVERRa. */
+      // Prior and sequent distortions co-exist in this representation;
+      // ensure the latter gets DVERRa.
       (*wcs+ialt)->lin.disseq->totdis = (*wcs+ialt)->lin.dispre->totdis;
     }
   }
 
-  /* Translated distortion functions; apply only to the primary WCS. */
-  wcsp = *wcs;
+  // Translated distortion functions; apply only to the primary WCS.
+  struct wcsprm *wcsp = *wcs;
   if (distran == SIP) {
-    /* SIP doesn't have alternates, nor axis mapping. */
-    disp = wcsp->lin.dispre;
+    // SIP doesn't have alternates, nor axis mapping.
+    struct disprm *disp = wcsp->lin.dispre;
     dpfill(disp->dp+1, "DP1", "OFFSET.1",  0, 1, 0, wcsp->crpix[0]);
     dpfill(disp->dp+2, "DP1", "OFFSET.2",  0, 1, 0, wcsp->crpix[1]);
     dpfill(disp->dp+4, "DP2", "OFFSET.1",  0, 1, 0, wcsp->crpix[0]);
     dpfill(disp->dp+5, "DP2", "OFFSET.2",  0, 1, 0, wcsp->crpix[1]);
 
   } else if (distran == DSS) {
-    /* DSS doesn't have alternates, nor axis mapping.  This translation */
-    /* follows Paper IV, Sect. 5.2 using the same variable names.       */
-    CNPIX1 = dsstmp[0];
-    CNPIX2 = dsstmp[1];
-
-    Xc = dsstmp[2]/1000.0;
-    Yc = dsstmp[3]/1000.0;
-    Rx = dsstmp[4]/1000.0;
-    Ry = dsstmp[5]/1000.0;
-
-    A1 = dsstmp[14];
-    A2 = dsstmp[15];
-    A3 = dsstmp[16];
-    B1 = dsstmp[17];
-    B2 = dsstmp[18];
-    B3 = dsstmp[19];
-    S  = sqrt(fabs(A1*B1 - A2*B2));
+    // DSS doesn't have alternates, nor axis mapping.  This translation
+    // follows Paper IV, Sect. 5.2 using the same variable names.
+    double CNPIX1 = dsstmp[0];
+    double CNPIX2 = dsstmp[1];
+
+    double Xc = dsstmp[2]/1000.0;
+    double Yc = dsstmp[3]/1000.0;
+    double Rx = dsstmp[4]/1000.0;
+    double Ry = dsstmp[5]/1000.0;
+
+    double A1 = dsstmp[14];
+    double A2 = dsstmp[15];
+    double A3 = dsstmp[16];
+    double B1 = dsstmp[17];
+    double B2 = dsstmp[18];
+    double B3 = dsstmp[19];
+    double S  = sqrt(fabs(A1*B1 - A2*B2));
 
-    X0 = (A2*B3 - A3*B1) / (A1*B1 - A2*B2);
-    Y0 = (A3*B2 - A1*B3) / (A1*B1 - A2*B2);
+    double X0 = (A2*B3 - A3*B1) / (A1*B1 - A2*B2);
+    double Y0 = (A3*B2 - A1*B3) / (A1*B1 - A2*B2);
 
     wcsp->crpix[0] = (Xc - X0)/Rx - (CNPIX1 - 0.5);
     wcsp->crpix[1] = (Yc + Y0)/Ry - (CNPIX2 - 0.5);
@@ -25729,7 +25718,7 @@ int wcspih_final(
     wcsp->cdelt[0] = -S/3600.0;
     wcsp->cdelt[1] =  S/3600.0;
 
-    crval = wcsp->crval;
+    double *crval = wcsp->crval;
     crval[0] = (dsstmp[6]  + (dsstmp[7]  + dsstmp[8] /60.0)/60.0)*15.0;
     crval[1] =  dsstmp[10] + (dsstmp[11] + dsstmp[12]/60.0)/60.0;
     if (dsstmp[9] == -1.0) crval[1] *= -1.0;
@@ -25739,19 +25728,23 @@ int wcspih_final(
 
     sprintf(wcsp->wcsname, "DSS PLATEID %.4s", (char *)(dsstmp+13));
 
-    /* Erase the approximate WCS provided in modern DSS headers. */
+    // Erase the approximate WCS provided in modern DSS headers.
     wcsp->cd[0] = 0.0;
     wcsp->cd[1] = 0.0;
     wcsp->cd[2] = 0.0;
     wcsp->cd[3] = 0.0;
 
   } else if (distran == WAT) {
-    /* TNX and ZPX don't have alternates, nor axis mapping. */
-    disp = wcsp->lin.disseq;
+    // TNX and ZPX don't have alternates, nor axis mapping.
+    char *wp;
+    int  omax, omin, wctrl[4];
+    double wval;
+    struct disprm *disp = wcsp->lin.disseq;
 
-    /* Disassemble the core dump stored in the WATi_m strings. */
-    nterms = 0;
+    // Disassemble the core dump stored in the WATi_m strings.
+    int i, nterms = 0;
     for (i = 0; i < 2; i++) {
+      char wtype[8];
       sscanf(wat[i], "wtype=%s", wtype);
 
       if (strcmp(wtype, "tnx") == 0) {
@@ -25759,22 +25752,23 @@ int wcspih_final(
       } else if (strcmp(wtype, "zpx") == 0) {
         strcpy(disp->dtype[i], "WAT-ZPX");
       } else {
-        /* Could contain "tan" or something else to be ignored. */
+        // Could contain "tan" or something else to be ignored.
         lindist(2, &(wcsp->lin), 0x0, 0);
         return 0;
       }
 
-      /* The PROJPn parameters are duplicated on each ZPX axis. */
+      // The PROJPn parameters are duplicated on each ZPX axis.
       if (i == 1 && strcmp(wtype, "zpx") == 0) {
-        /* Take those on the second (latitude) axis ignoring the other. */
-        /* First we have to count them and allocate space in wcsprm.    */
-        wp  = wat[i];
+        // Take those on the second (latitude) axis ignoring the other.
+        // First we have to count them and allocate space in wcsprm.
+        wp = wat[i];
+	int npv;
         for (npv = 0; npv < 30; npv++) {
           if ((wp = strstr(wp, "projp")) == 0x0) break;
           wp += 5;
         }
 
-        /* Allocate space. */
+        // Allocate space.
         if (npv) {
           wcsp->npvmax += npv;
           wcsp->pv = realloc(wcsp->pv, wcsp->npvmax*sizeof(struct pvcard));
@@ -25785,11 +25779,12 @@ int wcspih_final(
           wcsp->m_pv = wcsp->pv;
         }
 
-        /* Copy the values. */
+        // Copy the values.
         wp = wat[i];
-        for (ipv = wcsp->npv; ipv < wcsp->npvmax; ipv++) {
+        for (int ipv = wcsp->npv; ipv < wcsp->npvmax; ipv++) {
           if ((wp = strstr(wp, "projp")) == 0x0) break;
 
+          int m;
           sscanf(wp, "projp%d=%lf", &m, &wval);
           wcsp->pv[ipv].i = 2;
           wcsp->pv[ipv].m = m;
@@ -25801,13 +25796,13 @@ int wcspih_final(
         wcsp->npv += npv;
       }
 
-      /* Read the control parameters. */
+      // Read the control parameters.
       if ((wp = strchr(wat[i], '"')) == 0x0) {
         return WCSHDRERR_PARSER;
       }
       wp++;
 
-      for (m = 0; m < 4; m++) {
+      for (int m = 0; m < 4; m++) {
         sscanf(wp, "%d", wctrl+m);
         if ((wp = strchr(wp, ' ')) == 0x0) {
           return WCSHDRERR_PARSER;
@@ -25815,24 +25810,24 @@ int wcspih_final(
         wp++;
       }
 
-      /* How many coefficients are we expecting? */
+      // How many coefficients are we expecting?
       omin = (wctrl[1] < wctrl[2]) ? wctrl[1] : wctrl[2];
       omax = (wctrl[1] < wctrl[2]) ? wctrl[2] : wctrl[1];
       if (wctrl[3] == 0) {
-        /* No cross terms. */
+        // No cross terms.
         nterms += omin + omax;
 
       } else if (wctrl[3] == 1) {
-        /* Full cross terms. */
+        // Full cross terms.
         nterms += omin*omax;
 
       } else if (wctrl[3] == 2) {
-        /* Half cross terms. */
+        // Half cross terms.
         nterms += omin*omax - omin*(omin-1)/2;
       }
     }
 
-    /* Allocate memory for dpkeys. */
+    // Allocate memory for dpkeys.
     ndq[0] += 2*(1 + 1 + 4) + nterms;
 
     disp->ndpmax += ndq[0];
@@ -25844,18 +25839,18 @@ int wcspih_final(
     disp->m_dp = disp->dp;
 
 
-    /* Populate dpkeys. */
-    idp = disp->ndp;
+    // Populate dpkeys.
+    int idp = disp->ndp;
     for (i = 0; i < 2; i++) {
       dpfill(disp->dp+(idp++), "DQ", "NAXES", i+1, 0, 2, 0.0);
 
-      /* Read the control parameters. */
+      // Read the control parameters.
       if ((wp = strchr(wat[i], '"')) == 0x0) {
         return WCSHDRERR_PARSER;
       }
       wp++;
 
-      for (m = 0; m < 4; m++) {
+      for (int m = 0; m < 4; m++) {
         sscanf(wp, "%d", wctrl+m);
         if ((wp = strchr(wp, ' ')) == 0x0) {
           return WCSHDRERR_PARSER;
@@ -25863,24 +25858,26 @@ int wcspih_final(
         wp++;
       }
 
-      /* Polynomial type. */
+      // Polynomial type.
+      char wpoly[12];
       dpfill(disp->dp+(idp++), "DQ", "WAT.POLY", i+1, 0, wctrl[0], 0.0);
       if (wctrl[0] == 1) {
-        /* Chebyshev polynomial. */
+        // Chebyshev polynomial.
         strcpy(wpoly, "CHBY");
       } else if (wctrl[0] == 2) {
-        /* Legendre polynomial. */
+        // Legendre polynomial.
         strcpy(wpoly, "LEGR");
       } else if (wctrl[0] == 3) {
-        /* Polynomial is the sum of monomials. */
+        // Polynomial is the sum of monomials.
         strcpy(wpoly, "MONO");
       } else {
-        /* Unknown code. */
+        // Unknown code.
         strcpy(wpoly, "UNKN");
       }
 
-      /* Read the scaling parameters. */
-      for (m = 0; m < 4; m++) {
+      // Read the scaling parameters.
+      char field[40];
+      for (int m = 0; m < 4; m++) {
         sscanf(wp, "%lf", &wval);
         sprintf(field, "WAT.%c%s", (m<2)?'X':'Y', (m%2)?"MAX":"MIN");
         dpfill(disp->dp+(idp++), "DQ", field, i+1, 1, 0, wval);
@@ -25891,9 +25888,9 @@ int wcspih_final(
         wp++;
       }
 
-      /* Read the coefficients. */
-      for (n = 0; n < wctrl[2]; n++) {
-        for (m = 0; m < wctrl[1]; m++) {
+      // Read the coefficients.
+      for (int n = 0; n < wctrl[2]; n++) {
+        for (int m = 0; m < wctrl[1]; m++) {
           if (wctrl[3] == 0) {
             if (m && n) continue;
           } else if (wctrl[3] == 2) {
Index: astropy-4.2.1/cextern/wcslib/C/flexed/wcsulex.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/flexed/wcsulex.c
+++ astropy-4.2.1/cextern/wcslib/C/flexed/wcsulex.c
@@ -7150,9 +7150,8 @@ static const yy_state_type yy_NUL_trans[
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "wcsulex.l"
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -7169,11 +7168,9 @@ static const yy_state_type yy_NUL_trans[
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsulex.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsulex.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
 * wcsulex.l is a Flex description file containing the definition of a
@@ -7198,7 +7195,7 @@ static const yy_state_type yy_NUL_trans[
 /* All additional recognized units. */
 /* Exclusive start states. */
 
-#line 87 "wcsulex.l"
+#line 85 "wcsulex.l"
 #include <math.h>
 #include <setjmp.h>
 #include <stdio.h>
@@ -7209,47 +7206,27 @@ static const yy_state_type yy_NUL_trans[
 #include "wcsunits.h"
 #include "wcsutil.h"
 
-static int wcsulex_scanner(const char unitstr[], int *func, double *scale,
-                           double units[WCSUNITS_NTYPE], struct wcserr **err,
-                           yyscan_t yyscanner);
-
-/*--------------------------------------------------------------------------*/
-
-int wcsulexe(
-  const char unitstr[],
-  int *func,
-  double *scale,
-  double units[WCSUNITS_NTYPE],
-  struct wcserr **err)
-
-{
-  int status;
-  yyscan_t yyscanner;
-  int yylex_init(yyscan_t *yyscanner);
-  int yylex_destroy(yyscan_t yyscanner);
-
-  yylex_init(&yyscanner);
-  status = wcsulex_scanner(unitstr, func, scale, units, err, yyscanner);
-  yylex_destroy(yyscanner);
-
-  return status;
-}
-
-/*--------------------------------------------------------------------------*/
+// User data associated with yyscanner.
+struct wcsulex_extra {
+  // Used in preempting the call to exit() by yy_fatal_error().
+  jmp_buf abort_jmp_env;
+};
 
-#define YY_DECL int wcsulex_scanner(const char unitstr[], int *func, \
+#define YY_DECL int wcsulexe_scanner(const char unitstr[], int *func, \
  double *scale, double units[WCSUNITS_NTYPE], struct wcserr **err, \
  yyscan_t yyscanner)
 
-/* Dummy definition to circumvent compiler warnings. */
+// Dummy definition to circumvent compiler warnings.
 #define YY_INPUT(inbuff, count, bufsize) { count = YY_NULL; }
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
-jmp_buf wcsulex_abort_jmp_env;
-#define exit(status) longjmp(wcsulex_abort_jmp_env, status)
+// Preempt the call to exit() by yy_fatal_error().
+#define exit(status) longjmp(yyextra->abort_jmp_env, status);
+
+// Internal helper functions.
+static YY_DECL;
 
-#line 7252 "wcsulex.c"
-#line 7253 "wcsulex.c"
+#line 7229 "wcsulex.c"
+#line 7230 "wcsulex.c"
 
 #define INITIAL 0
 #define PAREN 1
@@ -7266,9 +7243,7 @@ jmp_buf wcsulex_abort_jmp_env;
 #include <unistd.h>
 #endif
 
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
+#define YY_EXTRA_TYPE struct wcsulex_extra *
 
 /* Holds the entire state of the reentrant scanner. */
 struct yyguts_t
@@ -7501,42 +7476,45 @@ YY_DECL
 		}
 
 	{
-#line 138 "wcsulex.l"
+#line 116 "wcsulex.l"
 
-#line 140 "wcsulex.l"
-	static const char *function = "wcsulexe";
+#line 118 "wcsulex.l"
+	static const char *function = "wcsulexe_scanner";
 	
-	char ctmp[72];
-	int bracket  = 0;
-	int operator = 0;
-	int paren    = 0;
-	int status   = 0;
-	int func_r, i, j;
-	double dexp, expon, factor, factor_r, types[WCSUNITS_NTYPE];
-	YY_BUFFER_STATE buf;
 	void add(double *factor, double types[], double *expon, double *scale,
 	    double units[]);
 	
-	if (err) *err = 0x0;
+	// Initialise returned values.
+	*func  = 0;
+	*scale = 1.0;
 	
-	*func = 0;
-	for (i = 0; i < WCSUNITS_NTYPE; i++) {
+	for (int i = 0; i < WCSUNITS_NTYPE; i++) {
 	  units[i] = 0.0;
+	}
+	
+	if (err) *err = 0x0;
+	
+	double types[WCSUNITS_NTYPE];
+	for (int i = 0; i < WCSUNITS_NTYPE; i++) {
 	  types[i] = 0.0;
 	}
-	expon  = 1.0;
-	factor = 1.0;
-	*scale = 1.0;
+	double expon  = 1.0;
+	double factor = 1.0;
+	
+	int bracket  = 0;
+	int operator = 0;
+	int paren    = 0;
+	int status   = 0;
 	
-	/* Avert a flex-induced memory leak. */
+	// Avert a flex-induced memory leak.
 	if (YY_CURRENT_BUFFER && YY_CURRENT_BUFFER->yy_input_file == stdin) {
 	  yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
 	}
 	
 	yy_scan_string(unitstr, yyscanner);
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
-	if (setjmp(wcsulex_abort_jmp_env)) {
+	// Return here via longjmp() invoked by yy_fatal_error().
+	if (setjmp(yyextra->abort_jmp_env)) {
 	  return wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
 	}
@@ -7547,7 +7525,7 @@ YY_DECL
 	fprintf(stderr, "\n%s ->\n", unitstr);
 #endif
 
-#line 7551 "wcsulex.c"
+#line 7529 "wcsulex.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -7601,15 +7579,15 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 183 "wcsulex.l"
+#line 164 "wcsulex.l"
 {
-	  /* Pretend initial whitespace doesn't exist. */
+	  // Pretend initial whitespace doesn't exist.
 	  yy_set_bol(1);
 	}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 188 "wcsulex.l"
+#line 169 "wcsulex.l"
 {
 	  if (bracket++) {
 	    BEGIN(FLUSH);
@@ -7620,7 +7598,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 196 "wcsulex.l"
+#line 177 "wcsulex.l"
 {
 	  status = wcserr_set(WCSERR_SET(UNITSERR_BAD_NUM_MULTIPLIER),
 	    "Invalid exponent in '%s'", unitstr);
@@ -7629,7 +7607,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 202 "wcsulex.l"
+#line 183 "wcsulex.l"
 {
 	  factor = 10.0;
 	  BEGIN(EXPON);
@@ -7637,7 +7615,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 207 "wcsulex.l"
+#line 188 "wcsulex.l"
 {
 	  *func = 1;
 	  unput('(');
@@ -7646,7 +7624,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 213 "wcsulex.l"
+#line 194 "wcsulex.l"
 {
 	  *func = 2;
 	  unput('(');
@@ -7655,7 +7633,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 219 "wcsulex.l"
+#line 200 "wcsulex.l"
 {
 	  *func = 3;
 	  unput('(');
@@ -7664,9 +7642,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 225 "wcsulex.l"
+#line 206 "wcsulex.l"
 {
-	  /* Leading binary multiply. */
+	  // Leading binary multiply.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_DANGLING_BINOP),
 	    "Dangling binary operator in '%s'", unitstr);
 	  BEGIN(FLUSH);
@@ -7674,12 +7652,12 @@ YY_RULE_SETUP
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 232 "wcsulex.l"
-/* Discard whitespace in INITIAL context. */
+#line 213 "wcsulex.l"
+// Discard whitespace in INITIAL context.
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 234 "wcsulex.l"
+#line 215 "wcsulex.l"
 {
 	  expon /= 2.0;
 	  unput('(');
@@ -7688,16 +7666,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 240 "wcsulex.l"
+#line 221 "wcsulex.l"
 {
-	  /* Gather terms in parentheses. */
+	  // Gather terms in parentheses.
 	  yyless(0);
 	  BEGIN(PAREN);
 	}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 246 "wcsulex.l"
+#line 227 "wcsulex.l"
 {
 	  if (operator++) {
 	    BEGIN(FLUSH);
@@ -7705,10 +7683,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 13:
-#line 253 "wcsulex.l"
+#line 234 "wcsulex.l"
 case 14:
 YY_RULE_SETUP
-#line 253 "wcsulex.l"
+#line 234 "wcsulex.l"
 {
 	  if (operator++) {
 	    BEGIN(FLUSH);
@@ -7719,7 +7697,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 261 "wcsulex.l"
+#line 242 "wcsulex.l"
 {
 	  operator = 0;
 	  yyless(0);
@@ -7727,12 +7705,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 16:
-#line 268 "wcsulex.l"
+#line 249 "wcsulex.l"
 case 17:
-#line 269 "wcsulex.l"
+#line 250 "wcsulex.l"
 case 18:
 YY_RULE_SETUP
-#line 269 "wcsulex.l"
+#line 250 "wcsulex.l"
 {
 	  operator = 0;
 	  yyless(0);
@@ -7741,7 +7719,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 275 "wcsulex.l"
+#line 256 "wcsulex.l"
 {
 	  bracket = !bracket;
 	  BEGIN(FLUSH);
@@ -7749,7 +7727,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 280 "wcsulex.l"
+#line 261 "wcsulex.l"
 {
 	  status = wcserr_set(WCSERR_SET(UNITSERR_BAD_INITIAL_SYMBOL),
 	    "Invalid symbol in INITIAL context in '%s'", unitstr);
@@ -7758,7 +7736,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 286 "wcsulex.l"
+#line 267 "wcsulex.l"
 {
 	  paren++;
 	  operator = 0;
@@ -7767,19 +7745,22 @@ YY_RULE_SETUP
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 292 "wcsulex.l"
+#line 273 "wcsulex.l"
 {
 	  paren--;
 	  if (paren) {
-	    /* Not balanced yet. */
+	    // Not balanced yet.
 	    yymore();
 	
 	  } else {
-	    /* Balanced; strip off the outer parentheses and recurse. */
+	    // Balanced; strip off the outer parentheses and recurse.
 	    yytext[yyleng-1] = '\0';
 	
-	    buf = YY_CURRENT_BUFFER;
+	    int func_r;
+	    double factor_r;
 	    status = wcsulexe(yytext+1, &func_r, &factor_r, types, err);
+	
+	    YY_BUFFER_STATE buf = YY_CURRENT_BUFFER;
 	    yy_switch_to_buffer(buf, yyscanner);
 	
 	    if (func_r) {
@@ -7799,14 +7780,14 @@ YY_RULE_SETUP
 case 23:
 /* rule 23 can match eol */
 YY_RULE_SETUP
-#line 320 "wcsulex.l"
+#line 304 "wcsulex.l"
 {
 	  yymore();
 	}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 324 "wcsulex.l"
+#line 308 "wcsulex.l"
 {
 	  factor = 1e-1;
 	  BEGIN(UNITS);
@@ -7814,7 +7795,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 329 "wcsulex.l"
+#line 313 "wcsulex.l"
 {
 	  factor = 1e-2;
 	  BEGIN(UNITS);
@@ -7822,7 +7803,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 334 "wcsulex.l"
+#line 318 "wcsulex.l"
 {
 	  factor = 1e-3;
 	  BEGIN(UNITS);
@@ -7830,7 +7811,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 339 "wcsulex.l"
+#line 323 "wcsulex.l"
 {
 	  factor = 1e-6;
 	  BEGIN(UNITS);
@@ -7838,7 +7819,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 344 "wcsulex.l"
+#line 328 "wcsulex.l"
 {
 	  factor = 1e-9;
 	  BEGIN(UNITS);
@@ -7846,7 +7827,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 349 "wcsulex.l"
+#line 333 "wcsulex.l"
 {
 	  factor = 1e-12;
 	  BEGIN(UNITS);
@@ -7854,7 +7835,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 354 "wcsulex.l"
+#line 338 "wcsulex.l"
 {
 	  factor = 1e-15;
 	  BEGIN(UNITS);
@@ -7862,7 +7843,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 359 "wcsulex.l"
+#line 343 "wcsulex.l"
 {
 	  factor = 1e-18;
 	  BEGIN(UNITS);
@@ -7870,7 +7851,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 364 "wcsulex.l"
+#line 348 "wcsulex.l"
 {
 	  factor = 1e-21;
 	  BEGIN(UNITS);
@@ -7878,7 +7859,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 369 "wcsulex.l"
+#line 353 "wcsulex.l"
 {
 	  factor = 1e-24;
 	  BEGIN(UNITS);
@@ -7886,7 +7867,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 374 "wcsulex.l"
+#line 358 "wcsulex.l"
 {
 	  factor = 1e+1;
 	  BEGIN(UNITS);
@@ -7894,7 +7875,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 379 "wcsulex.l"
+#line 363 "wcsulex.l"
 {
 	  factor = 1e+2;
 	  BEGIN(UNITS);
@@ -7902,7 +7883,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 384 "wcsulex.l"
+#line 368 "wcsulex.l"
 {
 	  factor = 1e+3;
 	  BEGIN(UNITS);
@@ -7910,7 +7891,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 389 "wcsulex.l"
+#line 373 "wcsulex.l"
 {
 	  factor = 1e+6;
 	  BEGIN(UNITS);
@@ -7918,7 +7899,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 394 "wcsulex.l"
+#line 378 "wcsulex.l"
 {
 	  factor = 1e+9;
 	  BEGIN(UNITS);
@@ -7926,7 +7907,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 399 "wcsulex.l"
+#line 383 "wcsulex.l"
 {
 	  factor = 1e+12;
 	  BEGIN(UNITS);
@@ -7934,7 +7915,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 404 "wcsulex.l"
+#line 388 "wcsulex.l"
 {
 	  factor = 1e+15;
 	  BEGIN(UNITS);
@@ -7942,7 +7923,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 409 "wcsulex.l"
+#line 393 "wcsulex.l"
 {
 	  factor = 1e+18;
 	  BEGIN(UNITS);
@@ -7950,7 +7931,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 414 "wcsulex.l"
+#line 398 "wcsulex.l"
 {
 	  factor = 1e+21;
 	  BEGIN(UNITS);
@@ -7958,7 +7939,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 419 "wcsulex.l"
+#line 403 "wcsulex.l"
 {
 	  factor = 1e+24;
 	  BEGIN(UNITS);
@@ -7966,9 +7947,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 424 "wcsulex.l"
+#line 408 "wcsulex.l"
 {
-	  /* Internal parser error. */
+	  // Internal parser error.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
 	  BEGIN(FLUSH);
@@ -7976,9 +7957,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 431 "wcsulex.l"
+#line 415 "wcsulex.l"
 {
-	  /* Ampere. */
+	  // Ampere.
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  types[WCSUNITS_TIME]   -= 1.0;
 	  BEGIN(EXPON);
@@ -7986,9 +7967,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 438 "wcsulex.l"
+#line 422 "wcsulex.l"
 {
-	  /* Julian year (annum). */
+	  // Julian year (annum).
 	  factor *= 31557600.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
@@ -7996,18 +7977,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 445 "wcsulex.l"
+#line 429 "wcsulex.l"
 {
-	  /* Analogue-to-digital converter units. */
+	  // Analogue-to-digital converter units.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 451 "wcsulex.l"
+#line 435 "wcsulex.l"
 {
-	  /* Angstrom. */
+	  // Angstrom.
 	  factor *= 1e-10;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
@@ -8015,9 +7996,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 458 "wcsulex.l"
+#line 442 "wcsulex.l"
 {
-	  /* Minute of arc. */
+	  // Minute of arc.
 	  factor /= 60.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8025,9 +8006,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 465 "wcsulex.l"
+#line 449 "wcsulex.l"
 {
-	  /* Second of arc. */
+	  // Second of arc.
 	  factor /= 3600.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8035,9 +8016,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 472 "wcsulex.l"
+#line 456 "wcsulex.l"
 {
-	  /* Astronomical unit. */
+	  // Astronomical unit.
 	  factor *= 1.49598e+11;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
@@ -8045,9 +8026,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 479 "wcsulex.l"
+#line 463 "wcsulex.l"
 {
-	  /* Barn. */
+	  // Barn.
 	  factor *= 1e-28;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  BEGIN(EXPON);
@@ -8055,36 +8036,36 @@ YY_RULE_SETUP
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 486 "wcsulex.l"
+#line 470 "wcsulex.l"
 {
-	  /* Beam, as in Jy/beam. */
+	  // Beam, as in Jy/beam.
 	  types[WCSUNITS_BEAM] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 492 "wcsulex.l"
+#line 476 "wcsulex.l"
 {
-	  /* Bin (e.g. histogram). */
+	  // Bin (e.g. histogram).
 	  types[WCSUNITS_BIN] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 498 "wcsulex.l"
+#line 482 "wcsulex.l"
 {
-	  /* Bit. */
+	  // Bit.
 	  types[WCSUNITS_BIT] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 504 "wcsulex.l"
+#line 488 "wcsulex.l"
 {
-	  /* Byte. */
+	  // Byte.
 	  factor *= 8.0;
 	  types[WCSUNITS_BIT] += 1.0;
 	  BEGIN(EXPON);
@@ -8092,45 +8073,45 @@ YY_RULE_SETUP
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 511 "wcsulex.l"
+#line 495 "wcsulex.l"
 {
-	  /* Coulomb. */
+	  // Coulomb.
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 517 "wcsulex.l"
+#line 501 "wcsulex.l"
 {
-	  /* Candela. */
+	  // Candela.
 	  types[WCSUNITS_LUMINTEN] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 523 "wcsulex.l"
+#line 507 "wcsulex.l"
 {
-	  /* Channel. */
+	  // Channel.
 	  types[WCSUNITS_BIN] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 529 "wcsulex.l"
+#line 513 "wcsulex.l"
 {
-	  /* Count. */
+	  // Count.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 535 "wcsulex.l"
+#line 519 "wcsulex.l"
 {
-	  /* Julian century. */
+	  // Julian century.
 	  factor *= 3155760000.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
@@ -8138,9 +8119,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 542 "wcsulex.l"
+#line 526 "wcsulex.l"
 {
-	  /* Debye. */
+	  // Debye.
 	  factor *= 1e-29 / 3.0;
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
@@ -8149,9 +8130,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 550 "wcsulex.l"
+#line 534 "wcsulex.l"
 {
-	  /* Day. */
+	  // Day.
 	  factor *= 86400.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
@@ -8159,18 +8140,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 557 "wcsulex.l"
+#line 541 "wcsulex.l"
 {
-	  /* Degree. */
+	  // Degree.
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 563 "wcsulex.l"
+#line 547 "wcsulex.l"
 {
-	  /* Erg. */
+	  // Erg.
 	  factor *= 1e-7;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -8180,9 +8161,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 572 "wcsulex.l"
+#line 556 "wcsulex.l"
 {
-	  /* Electron volt. */
+	  // Electron volt.
 	  factor *= 1.6021765e-19;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -8192,9 +8173,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 581 "wcsulex.l"
+#line 565 "wcsulex.l"
 {
-	  /* Farad. */
+	  // Farad.
 	  types[WCSUNITS_MASS]   -= 1.0;
 	  types[WCSUNITS_LENGTH] -= 2.0;
 	  types[WCSUNITS_TIME]   += 3.0;
@@ -8204,9 +8185,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 590 "wcsulex.l"
+#line 574 "wcsulex.l"
 {
-	  /* Gauss. */
+	  // Gauss.
 	  factor *= 1e-4;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -8216,9 +8197,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 599 "wcsulex.l"
+#line 583 "wcsulex.l"
 {
-	  /* Gram. */
+	  // Gram.
 	  factor *= 1e-3;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
@@ -8226,9 +8207,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 606 "wcsulex.l"
+#line 590 "wcsulex.l"
 {
-	  /* Henry. */
+	  // Henry.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   += 2.0;
@@ -8238,9 +8219,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 615 "wcsulex.l"
+#line 599 "wcsulex.l"
 {
-	  /* Hour. */
+	  // Hour.
 	  factor *= 3600.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
@@ -8248,18 +8229,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 622 "wcsulex.l"
+#line 606 "wcsulex.l"
 {
-	  /* Hertz. */
+	  // Hertz.
 	  types[WCSUNITS_TIME] -= 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 628 "wcsulex.l"
+#line 612 "wcsulex.l"
 {
-	  /* Joule. */
+	  // Joule.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -8268,9 +8249,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 636 "wcsulex.l"
+#line 620 "wcsulex.l"
 {
-	  /* Jansky. */
+	  // Jansky.
 	  factor *= 1e-26;
 	  types[WCSUNITS_MASS] += 1.0;
 	  types[WCSUNITS_TIME] -= 2.0;
@@ -8279,18 +8260,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 644 "wcsulex.l"
+#line 628 "wcsulex.l"
 {
-	  /* Kelvin. */
+	  // Kelvin.
 	  types[WCSUNITS_TEMPERATURE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 650 "wcsulex.l"
+#line 634 "wcsulex.l"
 {
-	  /* Lumen. */
+	  // Lumen.
 	  types[WCSUNITS_LUMINTEN]    += 1.0;
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8298,9 +8279,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 657 "wcsulex.l"
+#line 641 "wcsulex.l"
 {
-	  /* Lux. */
+	  // Lux.
 	  types[WCSUNITS_LUMINTEN]    += 1.0;
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  types[WCSUNITS_LENGTH]      -= 2.0;
@@ -8309,9 +8290,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 665 "wcsulex.l"
+#line 649 "wcsulex.l"
 {
-	  /* Light year. */
+	  // Light year.
 	  factor *= 2.99792458e8 * 31557600.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
@@ -8319,27 +8300,27 @@ YY_RULE_SETUP
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 672 "wcsulex.l"
+#line 656 "wcsulex.l"
 {
-	  /* Metre. */
+	  // Metre.
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 678 "wcsulex.l"
+#line 662 "wcsulex.l"
 {
-	  /* Stellar magnitude. */
+	  // Stellar magnitude.
 	  types[WCSUNITS_MAGNITUDE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 684 "wcsulex.l"
+#line 668 "wcsulex.l"
 {
-	  /* Milli-arcsec. */
+	  // Milli-arcsec.
 	  factor /= 3600e+3;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8347,9 +8328,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 691 "wcsulex.l"
+#line 675 "wcsulex.l"
 {
-	  /* Minute. */
+	  // Minute.
 	  factor *= 60.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
@@ -8357,18 +8338,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 698 "wcsulex.l"
+#line 682 "wcsulex.l"
 {
-	  /* Mole. */
+	  // Mole.
 	  types[WCSUNITS_MOLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 704 "wcsulex.l"
+#line 688 "wcsulex.l"
 {
-	  /* Newton. */
+	  // Newton.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -8377,9 +8358,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 712 "wcsulex.l"
+#line 696 "wcsulex.l"
 {
-	  /* Ohm. */
+	  // Ohm.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 1.0;
@@ -8389,9 +8370,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
-#line 721 "wcsulex.l"
+#line 705 "wcsulex.l"
 {
-	  /* Pascal. */
+	  // Pascal.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] -= 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -8400,9 +8381,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
-#line 729 "wcsulex.l"
+#line 713 "wcsulex.l"
 {
-	  /* Parsec. */
+	  // Parsec.
 	  factor *= 3.0857e16;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
@@ -8410,27 +8391,27 @@ YY_RULE_SETUP
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 736 "wcsulex.l"
+#line 720 "wcsulex.l"
 {
-	  /* Photon. */
+	  // Photon.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 742 "wcsulex.l"
+#line 726 "wcsulex.l"
 {
-	  /* Pixel. */
+	  // Pixel.
 	  types[WCSUNITS_PIXEL] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 748 "wcsulex.l"
+#line 732 "wcsulex.l"
 {
-	  /* Rayleigh. */
+	  // Rayleigh.
 	  factor *= 1e10 / (4.0 * PI);
 	  types[WCSUNITS_LENGTH]      -= 2.0;
 	  types[WCSUNITS_TIME]        -= 1.0;
@@ -8440,9 +8421,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
-#line 757 "wcsulex.l"
+#line 741 "wcsulex.l"
 {
-	  /* Radian. */
+	  // Radian.
 	  factor *= 180.0 / PI;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8450,9 +8431,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-#line 764 "wcsulex.l"
+#line 748 "wcsulex.l"
 {
-	  /* Rydberg. */
+	  // Rydberg.
 	  factor *= 13.605692 * 1.6021765e-19;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -8462,9 +8443,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 773 "wcsulex.l"
+#line 757 "wcsulex.l"
 {
-	  /* Siemen. */
+	  // Siemen.
 	  types[WCSUNITS_MASS]   -= 1.0;
 	  types[WCSUNITS_LENGTH] -= 2.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -8474,18 +8455,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-#line 782 "wcsulex.l"
+#line 766 "wcsulex.l"
 {
-	  /* Second. */
+	  // Second.
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
-#line 788 "wcsulex.l"
+#line 772 "wcsulex.l"
 {
-	  /* Solar luminosity. */
+	  // Solar luminosity.
 	  factor *= 3.8268e26;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -8495,9 +8476,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 797 "wcsulex.l"
+#line 781 "wcsulex.l"
 {
-	  /* Solar mass. */
+	  // Solar mass.
 	  factor *= 1.9891e30;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
@@ -8505,9 +8486,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 804 "wcsulex.l"
+#line 788 "wcsulex.l"
 {
-	  /* Solar radius. */
+	  // Solar radius.
 	  factor *= 6.9599e8;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
@@ -8515,27 +8496,27 @@ YY_RULE_SETUP
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-#line 811 "wcsulex.l"
+#line 795 "wcsulex.l"
 {
-	  /* Steradian. */
+	  // Steradian.
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-#line 817 "wcsulex.l"
+#line 801 "wcsulex.l"
 {
-	  /* Sun (with respect to). */
+	  // Sun (with respect to).
 	  types[WCSUNITS_SOLRATIO] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-#line 823 "wcsulex.l"
+#line 807 "wcsulex.l"
 {
-	  /* Tesla. */
+	  // Tesla.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_TIME]   += 1.0;
 	  types[WCSUNITS_CHARGE] -= 1.0;
@@ -8544,9 +8525,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-#line 831 "wcsulex.l"
+#line 815 "wcsulex.l"
 {
-	  /* Turn. */
+	  // Turn.
 	  factor *= 360.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8554,9 +8535,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 838 "wcsulex.l"
+#line 822 "wcsulex.l"
 {
-	  /* Unified atomic mass unit. */
+	  // Unified atomic mass unit.
 	  factor *= 1.6605387e-27;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
@@ -8564,9 +8545,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 845 "wcsulex.l"
+#line 829 "wcsulex.l"
 {
-	  /* Volt. */
+	  // Volt.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -8576,18 +8557,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
-#line 854 "wcsulex.l"
+#line 838 "wcsulex.l"
 {
-	  /* Voxel. */
+	  // Voxel.
 	  types[WCSUNITS_VOXEL] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-#line 860 "wcsulex.l"
+#line 844 "wcsulex.l"
 {
-	  /* Watt. */
+	  // Watt.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 3.0;
@@ -8596,9 +8577,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-#line 868 "wcsulex.l"
+#line 852 "wcsulex.l"
 {
-	  /* Weber. */
+	  // Weber.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -8608,9 +8589,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-#line 877 "wcsulex.l"
+#line 861 "wcsulex.l"
 {
-	  /* Internal parser error. */
+	  // Internal parser error.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
 	  BEGIN(FLUSH);
@@ -8618,9 +8599,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-#line 884 "wcsulex.l"
+#line 868 "wcsulex.l"
 {
-	  /* Exponentiation. */
+	  // Exponentiation.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  }
@@ -8628,8 +8609,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
-#line 891 "wcsulex.l"
+#line 875 "wcsulex.l"
 {
+	  int i;
 	  sscanf(yytext, " %d", &i);
 	  expon *= (double)i;
 	  add(&factor, types, &expon, scale, units);
@@ -8639,8 +8621,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-#line 899 "wcsulex.l"
+#line 884 "wcsulex.l"
 {
+	  int i;
 	  sscanf(yytext, " (%d)", &i);
 	  expon *= (double)i;
 	  add(&factor, types, &expon, scale, units);
@@ -8650,8 +8633,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
-#line 907 "wcsulex.l"
+#line 893 "wcsulex.l"
 {
+	  int i, j;
 	  sscanf(yytext, " (%d/%d)", &i, &j);
 	  expon *= (double)i / (double)j;
 	  add(&factor, types, &expon, scale, units);
@@ -8661,9 +8645,11 @@ YY_RULE_SETUP
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-#line 915 "wcsulex.l"
+#line 902 "wcsulex.l"
 {
+	  char ctmp[72];
 	  sscanf(yytext, " (%s)", ctmp);
+	  double dexp;
 	  wcsutil_str2double(ctmp, &dexp);
 	  expon *= dexp;
 	  add(&factor, types, &expon, scale, units);
@@ -8673,9 +8659,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-#line 924 "wcsulex.l"
+#line 913 "wcsulex.l"
 {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -8686,9 +8672,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 114:
 YY_RULE_SETUP
-#line 934 "wcsulex.l"
+#line 923 "wcsulex.l"
 {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -8700,9 +8686,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
-#line 945 "wcsulex.l"
+#line 934 "wcsulex.l"
 {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -8713,9 +8699,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-#line 955 "wcsulex.l"
+#line 944 "wcsulex.l"
 {
-	  /* Divide. */
+	  // Divide.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -8727,7 +8713,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-#line 966 "wcsulex.l"
+#line 955 "wcsulex.l"
 {
 	  add(&factor, types, &expon, scale, units);
 	  bracket = !bracket;
@@ -8736,7 +8722,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 972 "wcsulex.l"
+#line 961 "wcsulex.l"
 {
 	  status = wcserr_set(WCSERR_SET(UNITSERR_BAD_EXPON_SYMBOL),
 	    "Invalid symbol in EXPON context in '%s'", unitstr);
@@ -8745,9 +8731,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 978 "wcsulex.l"
+#line 967 "wcsulex.l"
 {
-	  /* Discard any remaining input. */
+	  // Discard any remaining input.
 	}
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
@@ -8756,9 +8742,9 @@ case YY_STATE_EOF(PREFIX):
 case YY_STATE_EOF(UNITS):
 case YY_STATE_EOF(EXPON):
 case YY_STATE_EOF(FLUSH):
-#line 982 "wcsulex.l"
+#line 971 "wcsulex.l"
 {
-	  /* End-of-string. */
+	  // End-of-string.
 	  if (YY_START == EXPON) {
 	    add(&factor, types, &expon, scale, units);
 	  }
@@ -8782,7 +8768,7 @@ case YY_STATE_EOF(FLUSH):
 	  }
 	
 	  if (status) {
-	    for (i = 0; i < WCSUNITS_NTYPE; i++) {
+	    for (int i = 0; i < WCSUNITS_NTYPE; i++) {
 	      units[i] = 0.0;
 	      *scale = 0.0;
 	    }
@@ -8793,10 +8779,10 @@ case YY_STATE_EOF(FLUSH):
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-#line 1016 "wcsulex.l"
+#line 1005 "wcsulex.l"
 ECHO;
 	YY_BREAK
-#line 8800 "wcsulex.c"
+#line 8786 "wcsulex.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -9961,7 +9947,35 @@ void yyfree (void * ptr , yyscan_t yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 1016 "wcsulex.l"
+#line 1005 "wcsulex.l"
+
+
+/*----------------------------------------------------------------------------
+* External interface to the scanner.
+*---------------------------------------------------------------------------*/
+
+int wcsulexe(
+  const char unitstr[],
+  int *func,
+  double *scale,
+  double units[WCSUNITS_NTYPE],
+  struct wcserr **err)
+
+{
+  static const char *function = "wcsulexe";
+
+  // Function prototypes.
+  int yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *yyscanner);
+  int yylex_destroy(yyscan_t yyscanner);
+
+  struct wcsulex_extra extra;
+  yyscan_t yyscanner;
+  yylex_init_extra(&extra, &yyscanner);
+  int status = wcsulexe_scanner(unitstr, func, scale, units, err, yyscanner);
+  yylex_destroy(yyscanner);
+
+  return status;
+}
 
 
 /*----------------------------------------------------------------------------
@@ -9976,11 +9990,9 @@ void add(
   double units[])
 
 {
-  int i;
-
   *scale *= pow(*factor, *expon);
 
-  for (i = 0; i < WCSUNITS_NTYPE; i++) {
+  for (int i = 0; i < WCSUNITS_NTYPE; i++) {
     units[i] += *expon * types[i];
     types[i] = 0.0;
   }
Index: astropy-4.2.1/cextern/wcslib/C/flexed/wcsutrn.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/flexed/wcsutrn.c
+++ astropy-4.2.1/cextern/wcslib/C/flexed/wcsutrn.c
@@ -724,7 +724,7 @@ static const flex_int16_t yy_nxt[][128]
        43,  -10,  -10,  -10,  -10,  -10,  -10,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       45,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -10,  -10,  -10,  -10,  -10
     },
 
@@ -735,14 +735,14 @@ static const flex_int16_t yy_nxt[][128]
       -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
       -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
       -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
-      -11,  -11,  -11,  -11,  -11,   43,   43,   43,   43,   45,
+      -11,  -11,  -11,  -11,  -11,   43,   43,   43,   43,   46,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -11,  -11,  -11,  -11,  -11,  -11,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   46,   43,  -11,  -11,  -11,  -11,  -11
+       43,   47,   43,  -11,  -11,  -11,  -11,  -11
     },
 
     {
@@ -770,11 +770,11 @@ static const flex_int16_t yy_nxt[][128]
       -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
       -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
       -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
-      -13,  -13,  -13,  -13,  -13,   47,   43,   43,   43,   48,
+      -13,  -13,  -13,  -13,  -13,   48,   43,   43,   43,   49,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -13,  -13,  -13,  -13,  -13,  -13,   43,   43,   43,
-       43,   49,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   50,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -13,  -13,  -13,  -13,  -13
@@ -788,7 +788,7 @@ static const flex_int16_t yy_nxt[][128]
       -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
       -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
       -14,  -14,  -14,  -14,  -14,   43,   43,   43,   43,   43,
-       43,   43,   50,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   51,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -14,  -14,  -14,  -14,  -14,  -14,   43,   43,   43,
@@ -807,8 +807,8 @@ static const flex_int16_t yy_nxt[][128]
       -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
       -15,  -15,  -15,  -15,  -15,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   51,   43,   43,   43,   43,   43,   43,   43,
-       52,  -15,  -15,  -15,  -15,  -15,  -15,   43,   43,   43,
+       43,   43,   52,   43,   43,   43,   43,   43,   43,   43,
+       53,  -15,  -15,  -15,  -15,  -15,  -15,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -15,  -15,  -15,  -15,  -15
@@ -824,7 +824,7 @@ static const flex_int16_t yy_nxt[][128]
       -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
       -16,  -16,  -16,  -16,  -16,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   53,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   54,
        43,  -16,  -16,  -16,  -16,  -16,  -16,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -839,12 +839,12 @@ static const flex_int16_t yy_nxt[][128]
       -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
       -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
       -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
-      -17,  -17,  -17,  -17,  -17,   43,   43,   43,   43,   54,
-       43,   43,   55,   43,   43,   43,   43,   56,   43,   43,
+      -17,  -17,  -17,  -17,  -17,   43,   43,   43,   43,   55,
+       43,   43,   56,   43,   43,   43,   43,   57,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -17,  -17,  -17,  -17,  -17,  -17,   43,   43,   43,
-       43,   57,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   58,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -17,  -17,  -17,  -17,  -17
     },
@@ -857,8 +857,8 @@ static const flex_int16_t yy_nxt[][128]
       -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
       -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
 
-      -18,  -18,  -18,  -18,  -18,   43,   43,   43,   43,   58,
-       43,   43,   59,   60,   43,   43,   43,   43,   43,   43,
+      -18,  -18,  -18,  -18,  -18,   43,   43,   43,   43,   59,
+       43,   43,   60,   61,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -18,  -18,  -18,  -18,  -18,  -18,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -878,7 +878,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -19,  -19,  -19,  -19,  -19,  -19,   43,   43,   43,
-       43,   43,   43,   43,   61,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   62,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -19,  -19,  -19,  -19,  -19
 
@@ -891,10 +891,10 @@ static const flex_int16_t yy_nxt[][128]
       -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
       -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
       -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
-      -20,  -20,  -20,  -20,  -20,   62,   43,   43,   43,   43,
-       43,   43,   43,   63,   43,   43,   43,   43,   43,   43,
+      -20,  -20,  -20,  -20,  -20,   63,   43,   43,   43,   43,
+       43,   43,   43,   64,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -20,  -20,  -20,  -20,  -20,  -20,   64,   43,   43,
+       43,  -20,  -20,  -20,  -20,  -20,  -20,   65,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -908,7 +908,7 @@ static const flex_int16_t yy_nxt[][128]
       -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
       -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
       -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
-      -21,  -21,  -21,  -21,  -21,   65,   43,   43,   43,   43,
+      -21,  -21,  -21,  -21,  -21,   66,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -926,7 +926,7 @@ static const flex_int16_t yy_nxt[][128]
 
       -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
       -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
-      -22,  -22,  -22,  -22,  -22,   43,   43,   43,   43,   66,
+      -22,  -22,  -22,  -22,  -22,   43,   43,   43,   43,   67,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -22,  -22,  -22,  -22,  -22,  -22,   43,   43,   43,
@@ -944,12 +944,12 @@ static const flex_int16_t yy_nxt[][128]
       -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
       -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
       -23,  -23,  -23,  -23,  -23,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   67,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   68,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -23,  -23,  -23,  -23,  -23,  -23,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   68,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   69,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -23,  -23,  -23,  -23,  -23
     },
 
@@ -960,10 +960,10 @@ static const flex_int16_t yy_nxt[][128]
       -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
       -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
       -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
-      -24,  -24,  -24,  -24,  -24,   43,   43,   43,   43,   69,
+      -24,  -24,  -24,  -24,  -24,   43,   43,   43,   43,   70,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   70,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   71,   43,   43,   43,   43,   43,   43,   43,
        43,  -24,  -24,  -24,  -24,  -24,  -24,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -983,7 +983,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -25,  -25,  -25,  -25,  -25,  -25,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       71,   43,   43,   43,   72,   43,   43,   43,   43,   43,
+       72,   43,   43,   43,   73,   43,   43,   43,   43,   43,
        43,   43,   43,  -25,  -25,  -25,  -25,  -25
     },
 
@@ -998,8 +998,8 @@ static const flex_int16_t yy_nxt[][128]
       -26,  -26,  -26,  -26,  -26,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -26,  -26,  -26,  -26,  -26,  -26,   73,   43,   43,
-       43,   74,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -26,  -26,  -26,  -26,  -26,  -26,   74,   43,   43,
+       43,   75,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,  -26,  -26,  -26,  -26,  -26
@@ -1018,8 +1018,8 @@ static const flex_int16_t yy_nxt[][128]
 
        43,  -27,  -27,  -27,  -27,  -27,  -27,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   51,   43,   43,   43,   43,   43,
-       43,   43,   52,  -27,  -27,  -27,  -27,  -27
+       43,   43,   43,   43,   52,   43,   43,   43,   43,   43,
+       43,   43,   53,  -27,  -27,  -27,  -27,  -27
     },
 
     {
@@ -1034,7 +1034,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -28,  -28,  -28,  -28,  -28,  -28,   43,   43,   43,
-       43,   57,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   58,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -28,  -28,  -28,  -28,  -28
     },
@@ -1051,7 +1051,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -29,  -29,  -29,  -29,  -29,  -29,   43,   43,   43,
-       43,   75,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   76,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -29,  -29,  -29,  -29,  -29
 
@@ -1067,9 +1067,9 @@ static const flex_int16_t yy_nxt[][128]
       -30,  -30,  -30,  -30,  -30,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -30,  -30,  -30,  -30,  -30,  -30,   64,   43,   43,
+       43,  -30,  -30,  -30,  -30,  -30,  -30,   65,   43,   43,
 
-       43,   43,   43,   43,   43,   76,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   77,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -30,  -30,  -30,  -30,  -30
     },
@@ -1085,7 +1085,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -31,  -31,  -31,  -31,  -31,  -31,   77,   43,   43,
+       43,  -31,  -31,  -31,  -31,  -31,  -31,   78,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -31,  -31,  -31,  -31,  -31
@@ -1103,7 +1103,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -32,  -32,  -32,  -32,  -32,  -32,   43,   43,   43,
-       43,   78,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   79,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -32,  -32,  -32,  -32,  -32
     },
@@ -1122,7 +1122,7 @@ static const flex_int16_t yy_nxt[][128]
        43,  -33,  -33,  -33,  -33,  -33,  -33,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   68,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   69,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -33,  -33,  -33,  -33,  -33
     },
 
@@ -1138,7 +1138,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -34,  -34,  -34,  -34,  -34,  -34,   43,   43,   43,
-       43,   79,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   80,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -34,  -34,  -34,  -34,  -34
     },
@@ -1147,14 +1147,14 @@ static const flex_int16_t yy_nxt[][128]
         7,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
-      -35,  -35,   80,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,   81,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
 
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
-      -35,   81,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   82,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35
@@ -1213,20 +1213,20 @@ static const flex_int16_t yy_nxt[][128]
     },
 
     {
-        7,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-
-       82,   82,   83,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   82,   82,   82,   82,   82,   82,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   82,   82,   82,   82,   82
+        7,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+
+       83,   83,   84,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   83,   83,   83,   83,   83,   83,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   83,   83,   83,   83,   83
 
     },
 
@@ -1237,31 +1237,31 @@ static const flex_int16_t yy_nxt[][128]
       -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
       -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
       -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
-      -40,  -40,  -40,  -40,  -40,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,  -40,  -40,  -40,  -40,  -40,  -40,   85,   85,   85,
-
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,  -40,  -40,  -40,  -40,  -40
-    },
-
-    {
-        7,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-      -41,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+      -40,  -40,  -40,  -40,  -40,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,  -40,  -40,  -40,  -40,  -40,  -40,   86,   86,   86,
 
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86
+       86,   86,   86,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+        7,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+      -41,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87
     },
 
     {
@@ -1306,7 +1306,7 @@ static const flex_int16_t yy_nxt[][128]
       -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
       -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
       -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
-      -44,  -44,  -44,  -44,  -44,   43,   43,   87,   43,   43,
+      -44,  -44,  -44,  -44,  -44,   43,   43,   88,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -1324,11 +1324,11 @@ static const flex_int16_t yy_nxt[][128]
       -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
 
       -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
-      -45,  -45,  -45,  -45,  -45,   88,   43,   43,   43,   43,
+      -45,  -45,  -45,  -45,  -45,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -45,  -45,  -45,  -45,  -45,  -45,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   89,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -45,  -45,  -45,  -45,  -45
     },
@@ -1341,12 +1341,12 @@ static const flex_int16_t yy_nxt[][128]
       -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
       -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
       -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
-      -46,  -46,  -46,  -46,  -46,   43,   43,   43,   43,   43,
+      -46,  -46,  -46,  -46,  -46,   90,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -46,  -46,  -46,  -46,  -46,  -46,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   89,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,  -46,  -46,  -46,  -46,  -46
     },
@@ -1360,11 +1360,11 @@ static const flex_int16_t yy_nxt[][128]
       -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
       -47,  -47,  -47,  -47,  -47,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   90,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -47,  -47,  -47,  -47,  -47,  -47,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   91,   43,   43,   43,
        43,   43,   43,  -47,  -47,  -47,  -47,  -47
     },
 
@@ -1377,8 +1377,8 @@ static const flex_int16_t yy_nxt[][128]
       -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
 
       -48,  -48,  -48,  -48,  -48,   43,   43,   43,   43,   43,
-       43,   91,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   92,
        43,  -48,  -48,  -48,  -48,  -48,  -48,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -1394,10 +1394,10 @@ static const flex_int16_t yy_nxt[][128]
       -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
       -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
       -49,  -49,  -49,  -49,  -49,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   93,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -49,  -49,  -49,  -49,  -49,  -49,   43,   43,   43,
-       43,   43,   43,   92,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -49,  -49,  -49,  -49,  -49
 
@@ -1413,9 +1413,9 @@ static const flex_int16_t yy_nxt[][128]
       -50,  -50,  -50,  -50,  -50,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       93,  -50,  -50,  -50,  -50,  -50,  -50,   43,   43,   43,
+       43,  -50,  -50,  -50,  -50,  -50,  -50,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   94,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -50,  -50,  -50,  -50,  -50
     },
@@ -1431,7 +1431,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -51,  -51,  -51,  -51,  -51,  -51,   43,   43,   43,
+       95,  -51,  -51,  -51,  -51,  -51,  -51,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -51,  -51,  -51,  -51,  -51
@@ -1480,7 +1480,7 @@ static const flex_int16_t yy_nxt[][128]
       -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
       -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
       -54,  -54,  -54,  -54,  -54,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   94,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -54,  -54,  -54,  -54,  -54,  -54,   43,   43,   43,
@@ -1498,9 +1498,9 @@ static const flex_int16_t yy_nxt[][128]
 
       -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
       -55,  -55,  -55,  -55,  -55,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   96,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       95,  -55,  -55,  -55,  -55,  -55,  -55,   43,   43,   43,
+       43,  -55,  -55,  -55,  -55,  -55,  -55,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -55,  -55,  -55,  -55,  -55
@@ -1517,7 +1517,7 @@ static const flex_int16_t yy_nxt[][128]
       -56,  -56,  -56,  -56,  -56,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -56,  -56,  -56,  -56,  -56,  -56,   43,   43,   43,
+       97,  -56,  -56,  -56,  -56,  -56,  -56,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
@@ -1536,7 +1536,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -57,  -57,  -57,  -57,  -57,  -57,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   96,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -57,  -57,  -57,  -57,  -57
     },
@@ -1551,9 +1551,9 @@ static const flex_int16_t yy_nxt[][128]
 
       -58,  -58,  -58,  -58,  -58,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   97,   43,   43,   43,   43,   43,
-       43,  -58,  -58,  -58,  -58,  -58,  -58,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -58,  -58,  -58,  -58,  -58,  -58,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   98,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -58,  -58,  -58,  -58,  -58
     },
@@ -1568,8 +1568,8 @@ static const flex_int16_t yy_nxt[][128]
       -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
       -59,  -59,  -59,  -59,  -59,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       98,  -59,  -59,  -59,  -59,  -59,  -59,   43,   43,   43,
+       43,   43,   43,   43,   99,   43,   43,   43,   43,   43,
+       43,  -59,  -59,  -59,  -59,  -59,  -59,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -59,  -59,  -59,  -59,  -59
@@ -1584,9 +1584,9 @@ static const flex_int16_t yy_nxt[][128]
       -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
       -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
       -60,  -60,  -60,  -60,  -60,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   99,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -60,  -60,  -60,  -60,  -60,  -60,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      100,  -60,  -60,  -60,  -60,  -60,  -60,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -1602,10 +1602,10 @@ static const flex_int16_t yy_nxt[][128]
       -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
       -61,  -61,  -61,  -61,  -61,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  101,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -61,  -61,  -61,  -61,  -61,  -61,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,  100,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -61,  -61,  -61,  -61,  -61
     },
@@ -1620,9 +1620,9 @@ static const flex_int16_t yy_nxt[][128]
       -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
       -62,  -62,  -62,  -62,  -62,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  101,   43,   43,   43,   43,   43,   43,
-       43,  -62,  -62,  -62,  -62,  -62,  -62,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -62,  -62,  -62,  -62,  -62,  -62,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,  102,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -62,  -62,  -62,  -62,  -62
     },
@@ -1637,7 +1637,7 @@ static const flex_int16_t yy_nxt[][128]
       -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,
       -63,  -63,  -63,  -63,  -63,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  102,   43,
+       43,   43,   43,  103,   43,   43,   43,   43,   43,   43,
        43,  -63,  -63,  -63,  -63,  -63,  -63,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
@@ -1655,10 +1655,10 @@ static const flex_int16_t yy_nxt[][128]
       -64,  -64,  -64,  -64,  -64,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  104,   43,
        43,  -64,  -64,  -64,  -64,  -64,  -64,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  103,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -64,  -64,  -64,  -64,  -64
     },
 
@@ -1670,12 +1670,12 @@ static const flex_int16_t yy_nxt[][128]
       -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,
 
       -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,
-      -65,  -65,  -65,  -65,  -65,   43,   43,   43,  104,   43,
+      -65,  -65,  -65,  -65,  -65,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -65,  -65,  -65,  -65,  -65,  -65,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  105,   43,   43,   43,   43,
        43,   43,   43,  -65,  -65,  -65,  -65,  -65
     },
 
@@ -1687,7 +1687,7 @@ static const flex_int16_t yy_nxt[][128]
       -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
       -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
       -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
-      -66,  -66,  -66,  -66,  -66,   43,   43,  105,   43,   43,
+      -66,  -66,  -66,  -66,  -66,   43,   43,   43,  106,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -66,  -66,  -66,  -66,  -66,  -66,   43,   43,   43,
@@ -1704,8 +1704,8 @@ static const flex_int16_t yy_nxt[][128]
       -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
       -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
       -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
-      -67,  -67,  -67,  -67,  -67,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  106,   43,   43,   43,
+      -67,  -67,  -67,  -67,  -67,   43,   43,  107,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -67,  -67,  -67,  -67,  -67,  -67,   43,   43,   43,
@@ -1723,10 +1723,10 @@ static const flex_int16_t yy_nxt[][128]
       -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,
 
       -68,  -68,  -68,  -68,  -68,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  108,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -68,  -68,  -68,  -68,  -68,  -68,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  107,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -68,  -68,  -68,  -68,  -68
     },
@@ -1739,11 +1739,11 @@ static const flex_int16_t yy_nxt[][128]
       -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
       -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
       -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
-      -69,  -69,  -69,  -69,  -69,  108,   43,   43,   43,   43,
+      -69,  -69,  -69,  -69,  -69,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -69,  -69,  -69,  -69,  -69,  -69,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  109,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -69,  -69,  -69,  -69,  -69
 
@@ -1756,7 +1756,7 @@ static const flex_int16_t yy_nxt[][128]
       -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,
       -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,
       -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,
-      -70,  -70,  -70,  -70,  -70,   43,   43,   43,   43,   43,
+      -70,  -70,  -70,  -70,  -70,  110,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -70,  -70,  -70,  -70,  -70,  -70,   43,   43,   43,
@@ -1778,7 +1778,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -71,  -71,  -71,  -71,  -71,  -71,   43,   43,   43,
-       43,   43,   43,  109,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -71,  -71,  -71,  -71,  -71
     },
@@ -1794,8 +1794,8 @@ static const flex_int16_t yy_nxt[][128]
       -72,  -72,  -72,  -72,  -72,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -72,  -72,  -72,  -72,  -72,  -72,   43,   43,  110,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -72,  -72,  -72,  -72,  -72,  -72,   43,   43,   43,
+       43,   43,   43,  111,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -72,  -72,  -72,  -72,  -72
     },
@@ -1811,11 +1811,11 @@ static const flex_int16_t yy_nxt[][128]
       -73,  -73,  -73,  -73,  -73,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -73,  -73,  -73,  -73,  -73,  -73,   43,   43,   43,
+       43,  -73,  -73,  -73,  -73,  -73,  -73,   43,   43,  112,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  111,   43,  -73,  -73,  -73,  -73,  -73
+       43,   43,   43,  -73,  -73,  -73,  -73,  -73
     },
 
     {
@@ -1830,9 +1830,9 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -74,  -74,  -74,  -74,  -74,  -74,   43,   43,   43,
-       43,   43,   43,  112,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  -74,  -74,  -74,  -74,  -74
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  113,   43,  -74,  -74,  -74,  -74,  -74
     },
 
     {
@@ -1847,8 +1847,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -75,  -75,  -75,  -75,  -75,  -75,   43,   43,   43,
+       43,   43,   43,  114,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  113,   43,   43,   43,
        43,   43,   43,  -75,  -75,  -75,  -75,  -75
     },
 
@@ -1865,9 +1865,9 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -76,  -76,  -76,  -76,  -76,  -76,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  115,   43,   43,   43,
 
-      114,   43,   43,  -76,  -76,  -76,  -76,  -76
+       43,   43,   43,  -76,  -76,  -76,  -76,  -76
     },
 
     {
@@ -1882,9 +1882,9 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -77,  -77,  -77,  -77,  -77,  -77,   43,   43,   43,
-      115,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  -77,  -77,  -77,  -77,  -77
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      116,   43,   43,  -77,  -77,  -77,  -77,  -77
     },
 
     {
@@ -1898,8 +1898,8 @@ static const flex_int16_t yy_nxt[][128]
       -78,  -78,  -78,  -78,  -78,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -78,  -78,  -78,  -78,  -78,  -78,   43,   43,  116,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -78,  -78,  -78,  -78,  -78,  -78,   43,   43,   43,
+      117,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -78,  -78,  -78,  -78,  -78
     },
@@ -1915,7 +1915,7 @@ static const flex_int16_t yy_nxt[][128]
       -79,  -79,  -79,  -79,  -79,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -79,  -79,  -79,  -79,  -79,  -79,  117,   43,   43,
+       43,  -79,  -79,  -79,  -79,  -79,  -79,   43,   43,  118,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -79,  -79,  -79,  -79,  -79
@@ -1926,31 +1926,31 @@ static const flex_int16_t yy_nxt[][128]
         7,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,   80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,   81,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -80,  -80,  -80,  -80,  -80,  -80,  119,   43,   43,
 
-      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  -80,  -80,  -80,  -80,  -80
     },
 
     {
         7,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
-      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,   81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
 
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
-      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,   82,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81
@@ -1974,38 +1974,38 @@ static const flex_int16_t yy_nxt[][128]
     },
 
     {
-        7,   82,   82,   82,   82,   82,   82,   82,   82,   82,
+        7,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
 
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   83,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   82,   82,   82,   82,   82,   82,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   82,   82,   82,   82,   82
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83
     },
 
     {
-        7,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84
+        7,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   84,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   83,   83,   83,   83,   83,   83,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   83,   83,   83,   83,   83
     },
 
     {
@@ -2016,48 +2016,48 @@ static const flex_int16_t yy_nxt[][128]
       -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
 
       -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
-      -85,  -85,  -85,  -85,  -85,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,  -85,  -85,  -85,  -85,  -85,  -85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,  -85,  -85,  -85,  -85,  -85
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85
     },
 
     {
-        7,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-      -86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+        7,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
 
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,  -86,  -86,  -86,  -86,  -86,  -86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
 
-       86,   86,   86,   86,   86,   86,   86,   86
+       86,   86,   86,  -86,  -86,  -86,  -86,  -86
     },
 
     {
-        7,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,  118,   43,   43,
-       43,   43,   43,  119,   43,   43,   43,   43,   43,   43,
-
-       43,  -87,  -87,  -87,  -87,  -87,  -87,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  -87,  -87,  -87,  -87,  -87
+        7,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+      -87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87
     },
 
     {
@@ -2070,7 +2070,7 @@ static const flex_int16_t yy_nxt[][128]
 
       -88,  -88,  -88,  -88,  -88,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,  120,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  121,   43,   43,   43,   43,   43,   43,
        43,  -88,  -88,  -88,  -88,  -88,  -88,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2089,8 +2089,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -89,  -89,  -89,  -89,  -89,  -89,   43,   43,   43,
-       43,  121,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  122,   43,   43,   43,   43,
        43,   43,   43,  -89,  -89,  -89,  -89,  -89
 
     },
@@ -2103,8 +2103,8 @@ static const flex_int16_t yy_nxt[][128]
       -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
       -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
       -90,  -90,  -90,  -90,  -90,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,  123,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  122,   43,   43,   43,   43,   43,   43,
        43,  -90,  -90,  -90,  -90,  -90,  -90,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2122,9 +2122,9 @@ static const flex_int16_t yy_nxt[][128]
       -91,  -91,  -91,  -91,  -91,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,  123,   43,   43,   43,   43,   43,   43,   43,
-       43,  -91,  -91,  -91,  -91,  -91,  -91,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -91,  -91,  -91,  -91,  -91,  -91,   43,   43,   43,
+       43,  124,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -91,  -91,  -91,  -91,  -91
     },
@@ -2139,10 +2139,10 @@ static const flex_int16_t yy_nxt[][128]
       -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,
       -92,  -92,  -92,  -92,  -92,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  125,   43,   43,   43,   43,   43,   43,
        43,  -92,  -92,  -92,  -92,  -92,  -92,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  124,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -92,  -92,  -92,  -92,  -92
     },
 
@@ -2156,7 +2156,7 @@ static const flex_int16_t yy_nxt[][128]
       -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
       -93,  -93,  -93,  -93,  -93,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,  126,   43,   43,   43,   43,   43,   43,   43,
        43,  -93,  -93,  -93,  -93,  -93,  -93,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
@@ -2174,10 +2174,10 @@ static const flex_int16_t yy_nxt[][128]
       -94,  -94,  -94,  -94,  -94,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,  125,   43,   43,   43,
-       43,  -94,  -94,  -94,  -94,  -94,  -94,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -94,  -94,  -94,  -94,  -94,  -94,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  127,   43,   43,   43,   43,   43,
        43,   43,   43,  -94,  -94,  -94,  -94,  -94
     },
 
@@ -2208,10 +2208,10 @@ static const flex_int16_t yy_nxt[][128]
       -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,
       -96,  -96,  -96,  -96,  -96,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  128,   43,   43,   43,
        43,  -96,  -96,  -96,  -96,  -96,  -96,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  126,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,  -96,  -96,  -96,  -96,  -96
     },
@@ -2223,9 +2223,9 @@ static const flex_int16_t yy_nxt[][128]
       -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,
       -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,
       -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,
-      -97,  -97,  -97,  -97,  -97,   43,   43,   43,   43,  127,
+      -97,  -97,  -97,  -97,  -97,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,  128,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -97,  -97,  -97,  -97,  -97,  -97,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2246,7 +2246,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -98,  -98,  -98,  -98,  -98,  -98,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  129,   43,
        43,   43,   43,  -98,  -98,  -98,  -98,  -98
     },
 
@@ -2258,9 +2258,9 @@ static const flex_int16_t yy_nxt[][128]
       -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
       -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
       -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
-      -99,  -99,  -99,  -99,  -99,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      -99,  -99,  -99,  -99,  -99,   43,   43,   43,   43,  130,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,  131,   43,   43,   43,   43,   43,   43,   43,
        43,  -99,  -99,  -99,  -99,  -99,  -99,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2292,7 +2292,7 @@ static const flex_int16_t yy_nxt[][128]
      -101, -101, -101, -101, -101, -101, -101, -101, -101, -101,
      -101, -101, -101, -101, -101, -101, -101, -101, -101, -101,
      -101, -101, -101, -101, -101, -101, -101, -101, -101, -101,
-     -101, -101, -101, -101, -101,   43,   43,  129,   43,   43,
+     -101, -101, -101, -101, -101,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2310,7 +2310,7 @@ static const flex_int16_t yy_nxt[][128]
 
      -102, -102, -102, -102, -102, -102, -102, -102, -102, -102,
      -102, -102, -102, -102, -102, -102, -102, -102, -102, -102,
-     -102, -102, -102, -102, -102,   43,   43,   43,   43,  130,
+     -102, -102, -102, -102, -102,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -102, -102, -102, -102, -102, -102,   43,   43,   43,
@@ -2327,10 +2327,10 @@ static const flex_int16_t yy_nxt[][128]
      -103, -103, -103, -103, -103, -103, -103, -103, -103, -103,
      -103, -103, -103, -103, -103, -103, -103, -103, -103, -103,
      -103, -103, -103, -103, -103, -103, -103, -103, -103, -103,
-     -103, -103, -103, -103, -103,   43,   43,   43,   43,   43,
+     -103, -103, -103, -103, -103,   43,   43,  132,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -103, -103, -103, -103, -103, -103,   43,   43,  131,
+       43, -103, -103, -103, -103, -103, -103,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2344,8 +2344,8 @@ static const flex_int16_t yy_nxt[][128]
      -104, -104, -104, -104, -104, -104, -104, -104, -104, -104,
      -104, -104, -104, -104, -104, -104, -104, -104, -104, -104,
      -104, -104, -104, -104, -104, -104, -104, -104, -104, -104,
-     -104, -104, -104, -104, -104,   43,   43,   43,   43,   43,
-       43,   43,   43,  132,   43,   43,   43,   43,   43,   43,
+     -104, -104, -104, -104, -104,   43,   43,   43,   43,  133,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -104, -104, -104, -104, -104, -104,   43,   43,   43,
@@ -2363,9 +2363,9 @@ static const flex_int16_t yy_nxt[][128]
 
      -105, -105, -105, -105, -105, -105, -105, -105, -105, -105,
      -105, -105, -105, -105, -105,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,  133,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -105, -105, -105, -105, -105, -105,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -105, -105, -105, -105, -105, -105,   43,   43,  134,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -105, -105, -105, -105, -105
@@ -2380,8 +2380,8 @@ static const flex_int16_t yy_nxt[][128]
      -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
      -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
      -106, -106, -106, -106, -106,   43,   43,   43,   43,   43,
+       43,   43,   43,  135,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  134,   43,   43,   43,   43,   43,
        43, -106, -106, -106, -106, -106, -106,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2397,12 +2397,12 @@ static const flex_int16_t yy_nxt[][128]
      -107, -107, -107, -107, -107, -107, -107, -107, -107, -107,
      -107, -107, -107, -107, -107, -107, -107, -107, -107, -107,
      -107, -107, -107, -107, -107,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,  136,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -107, -107, -107, -107, -107, -107,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  135,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -107, -107, -107, -107, -107
     },
 
@@ -2416,7 +2416,7 @@ static const flex_int16_t yy_nxt[][128]
 
      -108, -108, -108, -108, -108,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,  136,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  137,   43,   43,   43,   43,   43,
        43, -108, -108, -108, -108, -108, -108,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2436,7 +2436,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -109, -109, -109, -109, -109, -109,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  137,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  138,   43,   43,   43,
        43,   43,   43, -109, -109, -109, -109, -109
 
     },
@@ -2450,11 +2450,11 @@ static const flex_int16_t yy_nxt[][128]
      -110, -110, -110, -110, -110, -110, -110, -110, -110, -110,
      -110, -110, -110, -110, -110,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,  139,   43,   43,   43,   43,   43,   43,   43,
        43, -110, -110, -110, -110, -110, -110,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,  138,
-       43,   43,   43,   43,   43,  139,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -110, -110, -110, -110, -110
     },
 
@@ -2487,8 +2487,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -112, -112, -112, -112, -112, -112,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  141,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,  141,
+       43,   43,   43,   43,   43,  142,   43,   43,   43,   43,
        43,   43,   43, -112, -112, -112, -112, -112
     },
 
@@ -2504,9 +2504,9 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -113, -113, -113, -113, -113, -113,   43,   43,   43,
-       43,  142,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,  143,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  143,   43,   43,   43,   43,
        43,   43,   43, -113, -113, -113, -113, -113
     },
 
@@ -2522,8 +2522,8 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -114, -114, -114, -114, -114, -114,   43,   43,   43,
-       43,  144,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  144,   43,   43,   43,   43,   43,
        43,   43,   43, -114, -114, -114, -114, -114
     },
 
@@ -2539,8 +2539,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -115, -115, -115, -115, -115, -115,   43,   43,   43,
-       43,   43,   43,   43,   43,  145,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  145,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  146,   43,   43,   43,   43,   43,
        43,   43,   43, -115, -115, -115, -115, -115
     },
 
@@ -2556,8 +2556,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -116, -116, -116, -116, -116, -116,   43,   43,   43,
+       43,  147,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  146,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43, -116, -116, -116, -116, -116
     },
@@ -2574,8 +2574,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -117, -117, -117, -117, -117, -117,   43,   43,   43,
+       43,   43,   43,   43,   43,  148,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  147,   43,   43,   43,   43,   43,
        43,   43,   43, -117, -117, -117, -117, -117
     },
 
@@ -2588,11 +2588,11 @@ static const flex_int16_t yy_nxt[][128]
      -118, -118, -118, -118, -118, -118, -118, -118, -118, -118,
 
      -118, -118, -118, -118, -118,   43,   43,   43,   43,   43,
-       43,   43,   43,  148,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -118, -118, -118, -118, -118, -118,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -118, -118, -118, -118, -118, -118,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  149,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -118, -118, -118, -118, -118
     },
 
@@ -2604,12 +2604,12 @@ static const flex_int16_t yy_nxt[][128]
      -119, -119, -119, -119, -119, -119, -119, -119, -119, -119,
      -119, -119, -119, -119, -119, -119, -119, -119, -119, -119,
      -119, -119, -119, -119, -119, -119, -119, -119, -119, -119,
-     -119, -119, -119, -119, -119,   43,   43,   43,   43,  149,
+     -119, -119, -119, -119, -119,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -119, -119, -119, -119, -119, -119,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  150,   43,   43,   43,   43,   43,
        43,   43,   43, -119, -119, -119, -119, -119
 
     },
@@ -2622,7 +2622,7 @@ static const flex_int16_t yy_nxt[][128]
      -120, -120, -120, -120, -120, -120, -120, -120, -120, -120,
      -120, -120, -120, -120, -120, -120, -120, -120, -120, -120,
      -120, -120, -120, -120, -120,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  151,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -120, -120, -120, -120, -120, -120,   43,   43,   43,
 
@@ -2638,7 +2638,7 @@ static const flex_int16_t yy_nxt[][128]
      -121, -121, -121, -121, -121, -121, -121, -121, -121, -121,
      -121, -121, -121, -121, -121, -121, -121, -121, -121, -121,
      -121, -121, -121, -121, -121, -121, -121, -121, -121, -121,
-     -121, -121, -121, -121, -121,   43,   43,   43,   43,   43,
+     -121, -121, -121, -121, -121,   43,   43,   43,   43,  152,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2661,7 +2661,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -122, -122, -122, -122, -122, -122,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  153,   43,   43,   43,
        43,   43,   43, -122, -122, -122, -122, -122
     },
 
@@ -2673,7 +2673,7 @@ static const flex_int16_t yy_nxt[][128]
      -123, -123, -123, -123, -123, -123, -123, -123, -123, -123,
      -123, -123, -123, -123, -123, -123, -123, -123, -123, -123,
      -123, -123, -123, -123, -123, -123, -123, -123, -123, -123,
-     -123, -123, -123, -123, -123,   43,   43,   43,   43,  150,
+     -123, -123, -123, -123, -123,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -123, -123, -123, -123, -123, -123,   43,   43,   43,
@@ -2695,7 +2695,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -124, -124, -124, -124, -124, -124,   43,   43,   43,
-       43,  151,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -124, -124, -124, -124, -124
     },
@@ -2709,7 +2709,7 @@ static const flex_int16_t yy_nxt[][128]
 
      -125, -125, -125, -125, -125, -125, -125, -125, -125, -125,
      -125, -125, -125, -125, -125,   43,   43,   43,   43,   43,
-       43,   43,   43,  152,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -125, -125, -125, -125, -125, -125,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2725,11 +2725,11 @@ static const flex_int16_t yy_nxt[][128]
      -126, -126, -126, -126, -126, -126, -126, -126, -126, -126,
      -126, -126, -126, -126, -126, -126, -126, -126, -126, -126,
      -126, -126, -126, -126, -126, -126, -126, -126, -126, -126,
-     -126, -126, -126, -126, -126,   43,   43,   43,   43,   43,
+     -126, -126, -126, -126, -126,   43,   43,   43,   43,  154,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -126, -126, -126, -126, -126, -126,   43,   43,   43,
-       43,   43,   43,   43,   43,  153,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43, -126, -126, -126, -126, -126
@@ -2744,10 +2744,10 @@ static const flex_int16_t yy_nxt[][128]
      -127, -127, -127, -127, -127, -127, -127, -127, -127, -127,
      -127, -127, -127, -127, -127,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,  154,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -127, -127, -127, -127, -127, -127,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  155,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -127, -127, -127, -127, -127
     },
@@ -2760,8 +2760,8 @@ static const flex_int16_t yy_nxt[][128]
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
 
-     -128, -128, -128, -128, -128,   43,   43,   43,   43,  155,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+     -128, -128, -128, -128, -128,   43,   43,   43,   43,   43,
+       43,   43,   43,  156,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -128, -128, -128, -128, -128, -128,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2777,11 +2777,11 @@ static const flex_int16_t yy_nxt[][128]
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
-     -129, -129, -129, -129, -129,  156,   43,   43,   43,   43,
+     -129, -129, -129, -129, -129,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -129, -129, -129, -129, -129, -129,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  157,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -129, -129, -129, -129, -129
 
@@ -2795,8 +2795,8 @@ static const flex_int16_t yy_nxt[][128]
      -130, -130, -130, -130, -130, -130, -130, -130, -130, -130,
      -130, -130, -130, -130, -130, -130, -130, -130, -130, -130,
      -130, -130, -130, -130, -130,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  157,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,  158,   43,   43,   43,   43,   43,   43,   43,
        43, -130, -130, -130, -130, -130, -130,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2811,11 +2811,11 @@ static const flex_int16_t yy_nxt[][128]
      -131, -131, -131, -131, -131, -131, -131, -131, -131, -131,
      -131, -131, -131, -131, -131, -131, -131, -131, -131, -131,
      -131, -131, -131, -131, -131, -131, -131, -131, -131, -131,
-     -131, -131, -131, -131, -131,   43,   43,   43,   43,   43,
+     -131, -131, -131, -131, -131,   43,   43,   43,   43,  159,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -131, -131, -131, -131, -131, -131,  158,   43,   43,
+       43, -131, -131, -131, -131, -131, -131,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -131, -131, -131, -131, -131
@@ -2829,7 +2829,7 @@ static const flex_int16_t yy_nxt[][128]
 
      -132, -132, -132, -132, -132, -132, -132, -132, -132, -132,
      -132, -132, -132, -132, -132, -132, -132, -132, -132, -132,
-     -132, -132, -132, -132, -132,  159,   43,   43,   43,   43,
+     -132, -132, -132, -132, -132,  160,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -132, -132, -132, -132, -132, -132,   43,   43,   43,
@@ -2847,7 +2847,7 @@ static const flex_int16_t yy_nxt[][128]
      -133, -133, -133, -133, -133, -133, -133, -133, -133, -133,
      -133, -133, -133, -133, -133, -133, -133, -133, -133, -133,
      -133, -133, -133, -133, -133,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  160,   43,
+       43,   43,   43,   43,   43,   43,  161,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -133, -133, -133, -133, -133, -133,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2866,8 +2866,8 @@ static const flex_int16_t yy_nxt[][128]
      -134, -134, -134, -134, -134,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,  161,   43,   43,   43,   43,   43,   43,
-       43, -134, -134, -134, -134, -134, -134,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -134, -134, -134, -134, -134, -134,  162,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -134, -134, -134, -134, -134
@@ -2881,12 +2881,12 @@ static const flex_int16_t yy_nxt[][128]
      -135, -135, -135, -135, -135, -135, -135, -135, -135, -135,
 
      -135, -135, -135, -135, -135, -135, -135, -135, -135, -135,
-     -135, -135, -135, -135, -135,   43,   43,   43,   43,   43,
+     -135, -135, -135, -135, -135,  163,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -135, -135, -135, -135, -135, -135,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  162,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -135, -135, -135, -135, -135
     },
 
@@ -2899,8 +2899,8 @@ static const flex_int16_t yy_nxt[][128]
      -136, -136, -136, -136, -136, -136, -136, -136, -136, -136,
      -136, -136, -136, -136, -136, -136, -136, -136, -136, -136,
      -136, -136, -136, -136, -136,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  164,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  163,   43,   43,   43,   43,   43,   43,
        43, -136, -136, -136, -136, -136, -136,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2917,11 +2917,11 @@ static const flex_int16_t yy_nxt[][128]
      -137, -137, -137, -137, -137, -137, -137, -137, -137, -137,
      -137, -137, -137, -137, -137,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  165,   43,   43,   43,   43,   43,   43,
 
        43, -137, -137, -137, -137, -137, -137,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  164,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -137, -137, -137, -137, -137
     },
 
@@ -2937,8 +2937,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -138, -138, -138, -138, -138, -138,   43,   43,   43,
-       43,   43,   43,   43,   43,  165,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  166,   43,   43,   43,   43,
        43,   43,   43, -138, -138, -138, -138, -138
     },
 
@@ -2952,9 +2952,9 @@ static const flex_int16_t yy_nxt[][128]
      -139, -139, -139, -139, -139, -139, -139, -139, -139, -139,
      -139, -139, -139, -139, -139,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  167,   43,   43,   43,   43,   43,   43,
        43, -139, -139, -139, -139, -139, -139,   43,   43,   43,
-       43,  166,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -139, -139, -139, -139, -139
 
@@ -2973,7 +2973,7 @@ static const flex_int16_t yy_nxt[][128]
        43, -140, -140, -140, -140, -140, -140,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  168,   43,   43,   43,
        43,   43,   43, -140, -140, -140, -140, -140
     },
 
@@ -2989,7 +2989,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -141, -141, -141, -141, -141, -141,   43,   43,   43,
-       43,  167,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  169,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -141, -141, -141, -141, -141
     },
@@ -3006,8 +3006,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -142, -142, -142, -142, -142, -142,   43,   43,   43,
+       43,  170,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  168,   43,   43,   43,   43,   43,
        43,   43,   43, -142, -142, -142, -142, -142
     },
 
@@ -3023,7 +3023,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -143, -143, -143, -143, -143, -143,   43,   43,   43,
-       43,  169,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -143, -143, -143, -143, -143
@@ -3041,7 +3041,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -144, -144, -144, -144, -144, -144,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  170,   43,
+       43,  171,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -144, -144, -144, -144, -144
     },
@@ -3057,9 +3057,9 @@ static const flex_int16_t yy_nxt[][128]
      -145, -145, -145, -145, -145,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -145, -145, -145, -145, -145, -145,  171,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -145, -145, -145, -145, -145, -145,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  172,   43,   43,   43,   43,   43,
        43,   43,   43, -145, -145, -145, -145, -145
     },
 
@@ -3075,8 +3075,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -146, -146, -146, -146, -146, -146,   43,   43,   43,
+       43,  173,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-      172,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43, -146, -146, -146, -146, -146
     },
@@ -3093,8 +3093,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -147, -147, -147, -147, -147, -147,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  174,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   70,   43,   43,   43,   43,
        43,   43,   43, -147, -147, -147, -147, -147
     },
 
@@ -3107,9 +3107,9 @@ static const flex_int16_t yy_nxt[][128]
      -148, -148, -148, -148, -148, -148, -148, -148, -148, -148,
 
      -148, -148, -148, -148, -148,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  173,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -148, -148, -148, -148, -148, -148,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -148, -148, -148, -148, -148, -148,  175,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -148, -148, -148, -148, -148
@@ -3123,12 +3123,12 @@ static const flex_int16_t yy_nxt[][128]
      -149, -149, -149, -149, -149, -149, -149, -149, -149, -149,
      -149, -149, -149, -149, -149, -149, -149, -149, -149, -149,
      -149, -149, -149, -149, -149, -149, -149, -149, -149, -149,
-     -149, -149, -149, -149, -149,   43,   43,  174,   43,   43,
+     -149, -149, -149, -149, -149,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -149, -149, -149, -149, -149, -149,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      176,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -149, -149, -149, -149, -149
 
     },
@@ -3140,13 +3140,13 @@ static const flex_int16_t yy_nxt[][128]
      -150, -150, -150, -150, -150, -150, -150, -150, -150, -150,
      -150, -150, -150, -150, -150, -150, -150, -150, -150, -150,
      -150, -150, -150, -150, -150, -150, -150, -150, -150, -150,
-     -150, -150, -150, -150, -150,   43,   43,   43,   43,  175,
+     -150, -150, -150, -150, -150,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -150, -150, -150, -150, -150, -150,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   71,   43,   43,   43,   43,
        43,   43,   43, -150, -150, -150, -150, -150
     },
 
@@ -3159,10 +3159,10 @@ static const flex_int16_t yy_nxt[][128]
      -151, -151, -151, -151, -151, -151, -151, -151, -151, -151,
      -151, -151, -151, -151, -151,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  177,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -151, -151, -151, -151, -151, -151,   43,   43,   43,
-       43,  176,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -151, -151, -151, -151, -151
     },
@@ -3175,8 +3175,8 @@ static const flex_int16_t yy_nxt[][128]
 
      -152, -152, -152, -152, -152, -152, -152, -152, -152, -152,
      -152, -152, -152, -152, -152, -152, -152, -152, -152, -152,
-     -152, -152, -152, -152, -152,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  177,   43,
+     -152, -152, -152, -152, -152,   43,   43,  178,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -152, -152, -152, -152, -152, -152,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3198,7 +3198,7 @@ static const flex_int16_t yy_nxt[][128]
        43, -153, -153, -153, -153, -153, -153,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-      178,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  179,   43,   43,   43,   43,   43,
        43,   43,   43, -153, -153, -153, -153, -153
     },
 
@@ -3209,10 +3209,10 @@ static const flex_int16_t yy_nxt[][128]
      -154, -154, -154, -154, -154, -154, -154, -154, -154, -154,
      -154, -154, -154, -154, -154, -154, -154, -154, -154, -154,
      -154, -154, -154, -154, -154, -154, -154, -154, -154, -154,
-     -154, -154, -154, -154, -154,   43,   43,   43,   43,   43,
+     -154, -154, -154, -154, -154,   43,   43,   43,   43,  180,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,  179,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -154, -154, -154, -154, -154, -154,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3229,9 +3229,9 @@ static const flex_int16_t yy_nxt[][128]
      -155, -155, -155, -155, -155, -155, -155, -155, -155, -155,
      -155, -155, -155, -155, -155,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  180,   43,   43,   43,   43,   43,   43,
-       43, -155, -155, -155, -155, -155, -155,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -155, -155, -155, -155, -155, -155,   43,   43,   43,
+       43,  181,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -155, -155, -155, -155, -155
     },
@@ -3245,7 +3245,7 @@ static const flex_int16_t yy_nxt[][128]
      -156, -156, -156, -156, -156, -156, -156, -156, -156, -156,
      -156, -156, -156, -156, -156, -156, -156, -156, -156, -156,
      -156, -156, -156, -156, -156,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  181,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  182,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -156, -156, -156, -156, -156, -156,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3263,11 +3263,11 @@ static const flex_int16_t yy_nxt[][128]
      -157, -157, -157, -157, -157, -157, -157, -157, -157, -157,
      -157, -157, -157, -157, -157,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  182,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -157, -157, -157, -157, -157, -157,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      183,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -157, -157, -157, -157, -157
     },
 
@@ -3281,9 +3281,9 @@ static const flex_int16_t yy_nxt[][128]
 
      -158, -158, -158, -158, -158,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  184,   43,   43,   43,   43,   43,   43,
        43, -158, -158, -158, -158, -158, -158,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  183,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -158, -158, -158, -158, -158
     },
@@ -3297,8 +3297,8 @@ static const flex_int16_t yy_nxt[][128]
      -159, -159, -159, -159, -159, -159, -159, -159, -159, -159,
      -159, -159, -159, -159, -159, -159, -159, -159, -159, -159,
      -159, -159, -159, -159, -159,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  184,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  185,   43,   43,   43,   43,   43,   43,
        43, -159, -159, -159, -159, -159, -159,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3313,8 +3313,8 @@ static const flex_int16_t yy_nxt[][128]
      -160, -160, -160, -160, -160, -160, -160, -160, -160, -160,
      -160, -160, -160, -160, -160, -160, -160, -160, -160, -160,
      -160, -160, -160, -160, -160, -160, -160, -160, -160, -160,
-     -160, -160, -160, -160, -160,   43,   43,   43,  185,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+     -160, -160, -160, -160, -160,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  186,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -160, -160, -160, -160, -160, -160,   43,   43,   43,
 
@@ -3333,7 +3333,7 @@ static const flex_int16_t yy_nxt[][128]
      -161, -161, -161, -161, -161,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  187,   43,   43,   43,   43,   43,   43,
        43, -161, -161, -161, -161, -161, -161,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3352,7 +3352,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -162, -162, -162, -162, -162, -162,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  188,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -162, -162, -162, -162, -162
     },
@@ -3366,7 +3366,7 @@ static const flex_int16_t yy_nxt[][128]
      -163, -163, -163, -163, -163, -163, -163, -163, -163, -163,
      -163, -163, -163, -163, -163, -163, -163, -163, -163, -163,
      -163, -163, -163, -163, -163,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  189,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -163, -163, -163, -163, -163, -163,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3382,13 +3382,13 @@ static const flex_int16_t yy_nxt[][128]
      -164, -164, -164, -164, -164, -164, -164, -164, -164, -164,
      -164, -164, -164, -164, -164, -164, -164, -164, -164, -164,
      -164, -164, -164, -164, -164, -164, -164, -164, -164, -164,
-     -164, -164, -164, -164, -164,   43,   43,   43,   43,   43,
+     -164, -164, -164, -164, -164,   43,   43,   43,  190,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -164, -164, -164, -164, -164, -164,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  186,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -164, -164, -164, -164, -164
     },
 
@@ -3405,7 +3405,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -165, -165, -165, -165, -165, -165,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-      187,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -165, -165, -165, -165, -165
     },
 
@@ -3420,7 +3420,7 @@ static const flex_int16_t yy_nxt[][128]
      -166, -166, -166, -166, -166,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -166, -166, -166, -166, -166, -166,   43,   43,  188,
+       43, -166, -166, -166, -166, -166, -166,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
@@ -3439,7 +3439,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -167, -167, -167, -167, -167, -167,   43,   43,   43,
-       43,  189,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -167, -167, -167, -167, -167
     },
@@ -3457,7 +3457,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -168, -168, -168, -168, -168, -168,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  190,   43,   43,   43,   43,
+       43,   43,   43,   43,  191,   43,   43,   43,   43,   43,
        43,   43,   43, -168, -168, -168, -168, -168
     },
 
@@ -3474,7 +3474,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -169, -169, -169, -169, -169, -169,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  191,   43,   43,   43,   43,
+      192,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -169, -169, -169, -169, -169
 
     },
@@ -3489,10 +3489,10 @@ static const flex_int16_t yy_nxt[][128]
      -170, -170, -170, -170, -170,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -170, -170, -170, -170, -170, -170,   43,   43,   43,
+       43, -170, -170, -170, -170, -170, -170,   43,   43,  193,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  182,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -170, -170, -170, -170, -170
     },
 
@@ -3508,8 +3508,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -171, -171, -171, -171, -171, -171,   43,   43,   43,
+       43,  194,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-      192,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -171, -171, -171, -171, -171
     },
 
@@ -3525,8 +3525,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -172, -172, -172, -172, -172, -172,   43,   43,   43,
-      193,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  195,   43,   43,   43,   43,
        43,   43,   43, -172, -172, -172, -172, -172
     },
 
@@ -3540,11 +3540,11 @@ static const flex_int16_t yy_nxt[][128]
      -173, -173, -173, -173, -173, -173, -173, -173, -173, -173,
      -173, -173, -173, -173, -173,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  194,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -173, -173, -173, -173, -173, -173,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  196,   43,   43,   43,   43,
        43,   43,   43, -173, -173, -173, -173, -173
     },
 
@@ -3558,10 +3558,10 @@ static const flex_int16_t yy_nxt[][128]
      -174, -174, -174, -174, -174,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,  195,   43,   43,   43,   43,   43,   43,
-       43, -174, -174, -174, -174, -174, -174,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -174, -174, -174, -174, -174, -174,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  187,   43,   43,   43,   43,
        43,   43,   43, -174, -174, -174, -174, -174
     },
 
@@ -3575,10 +3575,10 @@ static const flex_int16_t yy_nxt[][128]
      -175, -175, -175, -175, -175, -175, -175, -175, -175, -175,
      -175, -175, -175, -175, -175,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  196,   43,   43,   43,   43,   43,   43,
-       43, -175, -175, -175, -175, -175, -175,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -175, -175, -175, -175, -175, -175,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      197,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -175, -175, -175, -175, -175
     },
 
@@ -3594,8 +3594,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -176, -176, -176, -176, -176, -176,   43,   43,   43,
+      198,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  197,   43,   43,   43,   43,
 
        43,   43,   43, -176, -176, -176, -176, -176
     },
@@ -3609,7 +3609,7 @@ static const flex_int16_t yy_nxt[][128]
      -177, -177, -177, -177, -177, -177, -177, -177, -177, -177,
      -177, -177, -177, -177, -177,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  198,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  199,   43,   43,   43,   43,   43,   43,
 
        43, -177, -177, -177, -177, -177, -177,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3627,10 +3627,10 @@ static const flex_int16_t yy_nxt[][128]
 
      -178, -178, -178, -178, -178,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  200,   43,   43,   43,   43,   43,   43,
        43, -178, -178, -178, -178, -178, -178,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  199,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -178, -178, -178, -178, -178
     },
 
@@ -3647,7 +3647,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -179, -179, -179, -179, -179, -179,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  201,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -179, -179, -179, -179, -179
 
     },
@@ -3661,7 +3661,7 @@ static const flex_int16_t yy_nxt[][128]
      -180, -180, -180, -180, -180, -180, -180, -180, -180, -180,
      -180, -180, -180, -180, -180,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  202,   43,   43,   43,   43,   43,   43,
        43, -180, -180, -180, -180, -180, -180,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3679,10 +3679,10 @@ static const flex_int16_t yy_nxt[][128]
      -181, -181, -181, -181, -181,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  200,   43,   43,   43,   43,   43,   43,
-       43, -181, -181, -181, -181, -181, -181,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -181, -181, -181, -181, -181, -181,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  203,   43,   43,   43,   43,
        43,   43,   43, -181, -181, -181, -181, -181
     },
 
@@ -3696,7 +3696,7 @@ static const flex_int16_t yy_nxt[][128]
      -182, -182, -182, -182, -182, -182, -182, -182, -182, -182,
      -182, -182, -182, -182, -182,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  204,   43,   43,   43,   43,   43,   43,
        43, -182, -182, -182, -182, -182, -182,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3717,7 +3717,7 @@ static const flex_int16_t yy_nxt[][128]
        43, -183, -183, -183, -183, -183, -183,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,  201,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  205,   43,   43,   43,   43,
        43,   43,   43, -183, -183, -183, -183, -183
     },
 
@@ -3731,7 +3731,7 @@ static const flex_int16_t yy_nxt[][128]
      -184, -184, -184, -184, -184,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,  202,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -184, -184, -184, -184, -184, -184,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3748,7 +3748,7 @@ static const flex_int16_t yy_nxt[][128]
      -185, -185, -185, -185, -185, -185, -185, -185, -185, -185,
      -185, -185, -185, -185, -185,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  203,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -185, -185, -185, -185, -185, -185,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3765,10 +3765,10 @@ static const flex_int16_t yy_nxt[][128]
      -186, -186, -186, -186, -186, -186, -186, -186, -186, -186,
      -186, -186, -186, -186, -186,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  206,   43,   43,   43,   43,   43,   43,
        43, -186, -186, -186, -186, -186, -186,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  204,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43, -186, -186, -186, -186, -186
     },
@@ -3786,7 +3786,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43, -187, -187, -187, -187, -187, -187,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  194,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -187, -187, -187, -187, -187
     },
 
@@ -3803,7 +3803,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -188, -188, -188, -188, -188, -188,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  195,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  207,   43,   43,   43,   43,
        43,   43,   43, -188, -188, -188, -188, -188
     },
 
@@ -3817,10 +3817,10 @@ static const flex_int16_t yy_nxt[][128]
      -189, -189, -189, -189, -189, -189, -189, -189, -189, -189,
      -189, -189, -189, -189, -189,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  208,   43,   43,   43,   43,   43,   43,
        43, -189, -189, -189, -189, -189, -189,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  205,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -189, -189, -189, -189, -189
 
     },
@@ -3834,7 +3834,7 @@ static const flex_int16_t yy_nxt[][128]
      -190, -190, -190, -190, -190, -190, -190, -190, -190, -190,
      -190, -190, -190, -190, -190,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  209,   43,   43,   43,   43,   43,   43,
        43, -190, -190, -190, -190, -190, -190,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3855,7 +3855,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -191, -191, -191, -191, -191, -191,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  210,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -191, -191, -191, -191, -191
     },
 
@@ -3872,7 +3872,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -192, -192, -192, -192, -192, -192,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  206,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  199,   43,   43,   43,   43,
        43,   43,   43, -192, -192, -192, -192, -192
     },
 
@@ -3890,7 +3890,7 @@ static const flex_int16_t yy_nxt[][128]
        43, -193, -193, -193, -193, -193, -193,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,  207,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  200,   43,   43,   43,   43,
        43,   43,   43, -193, -193, -193, -193, -193
     },
 
@@ -3907,7 +3907,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -194, -194, -194, -194, -194, -194,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  211,   43,   43,   43,   43,
        43,   43,   43, -194, -194, -194, -194, -194
     },
 
@@ -3959,7 +3959,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43, -197, -197, -197, -197, -197, -197,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  212,   43,   43,   43,   43,
        43,   43,   43, -197, -197, -197, -197, -197
     },
 
@@ -3976,7 +3976,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -198, -198, -198, -198, -198, -198,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  213,   43,   43,   43,   43,
        43,   43,   43, -198, -198, -198, -198, -198
     },
 
@@ -4027,7 +4027,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -201, -201, -201, -201, -201, -201,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,  214,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -201, -201, -201, -201, -201
     },
@@ -4079,7 +4079,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -204, -204, -204, -204, -204, -204,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,  208,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -204, -204, -204, -204, -204
     },
@@ -4153,6 +4153,145 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43, -208, -208, -208, -208, -208
     },
 
+    {
+        7, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -209, -209, -209, -209, -209, -209,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43, -209, -209, -209, -209, -209
+
+    },
+
+    {
+        7, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -210, -210, -210, -210, -210, -210,   43,   43,   43,
+
+       43,   43,   43,   43,   43,   43,   43,   43,   43,  215,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43, -210, -210, -210, -210, -210
+    },
+
+    {
+        7, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211,   43,   43,   43,   43,   43,
+
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -211, -211, -211, -211, -211, -211,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43, -211, -211, -211, -211, -211
+    },
+
+    {
+        7, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+     -212, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+     -212, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+     -212, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+
+     -212, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+     -212, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+     -212, -212, -212, -212, -212,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -212, -212, -212, -212, -212, -212,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43, -212, -212, -212, -212, -212
+    },
+
+    {
+        7, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+
+     -213, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+     -213, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+     -213, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+     -213, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+     -213, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+     -213, -213, -213, -213, -213,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -213, -213, -213, -213, -213, -213,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43, -213, -213, -213, -213, -213
+    },
+
+    {
+        7, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -214, -214, -214, -214, -214, -214,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  216,   43,   43,   43,   43,
+       43,   43,   43, -214, -214, -214, -214, -214
+    },
+
+    {
+        7, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+     -215, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+     -215, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+     -215, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+     -215, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+
+     -215, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+     -215, -215, -215, -215, -215,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -215, -215, -215, -215, -215, -215,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  216,   43,   43,   43,   43,
+       43,   43,   43, -215, -215, -215, -215, -215
+    },
+
+    {
+        7, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+     -216, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+
+     -216, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+     -216, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+     -216, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+     -216, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+     -216, -216, -216, -216, -216,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -216, -216, -216, -216, -216, -216,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+
+       43,   43,   43, -216, -216, -216, -216, -216
+    },
+
     } ;
 
 static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );
@@ -4178,44 +4317,45 @@ struct yy_trans_info
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static const flex_int16_t yy_accept[209] =
+static const flex_int16_t yy_accept[217] =
     {   0,
         0,    0,    0,    0,   36,   36,   38,    3,    2,   31,
        31,   31,   10,   31,   14,   31,   31,   20,   31,   31,
        31,   28,   31,   31,   31,   31,   31,   31,   31,   31,
        31,   31,   31,   31,    2,    1,   35,   37,   35,   32,
        36,    2,   31,   31,   31,   31,   31,   31,   31,   31,
-       13,   15,   17,   31,   31,   19,   31,   31,   31,   31,
-       31,   31,   31,   31,   31,   31,   31,   31,   31,   30,
-       31,   31,   31,   31,   31,   31,   31,   31,   31,    2,
-        1,   33,   33,   34,   32,   36,   31,   31,   31,    9,
-       11,   11,   12,   31,   16,   31,   31,   22,   21,   23,
-
-       31,   31,   31,   26,   27,   31,   31,   31,   31,   31,
-        9,   31,   31,   31,   31,   27,   31,   31,   31,    7,
-        8,    9,   31,   31,   31,   31,   31,   31,   31,   31,
-       31,   31,   31,   29,   29,   30,   31,   31,   31,    9,
-       31,   31,   31,   31,   31,   31,   30,   31,   31,   31,
-       31,   31,   31,   20,   20,   31,   25,   31,   31,   31,
-       29,   29,   30,   31,   31,   31,   31,   20,   20,   31,
-       31,   31,    5,    6,   11,   11,   18,   18,   20,   20,
-       24,   25,   24,   26,   27,   31,   31,   31,   11,   20,
-       20,   26,   27,    5,    6,   11,   11,   18,   18,   24,
+       31,   13,   15,   17,   31,   31,   19,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       30,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+        2,    1,   33,   33,   34,   32,   36,   31,   31,   31,
+       31,    9,   11,   11,   12,   31,   16,   31,   31,   22,
+
+       21,   23,   31,   31,   31,   26,   27,   31,   31,   31,
+       31,   31,    9,   31,   31,   31,   31,   27,   31,   31,
+       31,   31,    7,    8,    9,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   29,   29,   30,   31,
+       31,   31,    9,   31,   31,   31,   31,   31,   31,   30,
+       31,   31,   31,   31,   31,   31,   31,   20,   20,   31,
+       25,   31,   31,   31,   29,   29,   30,   31,   31,   31,
+       31,   20,   20,   31,   31,   31,    5,    6,   31,   11,
+       11,   18,   18,   20,   20,   24,   25,   24,   26,   27,
+       31,   31,   31,   11,   20,   20,   26,   27,    5,    6,
 
-       24,   26,   27,   31,   11,   26,   27,    4
+       31,   11,   11,   18,   18,   24,   24,   26,   27,   31,
+       11,   26,   27,   31,    4,    4
     } ;
 
-static const yy_state_type yy_NUL_trans[209] =
+static const yy_state_type yy_NUL_trans[217] =
     {   0,
         8,    8,   37,   37,   41,   41,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,   82,    0,
-       86,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   83,    0,
+       87,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,   82,    0,    0,   86,    0,    0,    0,    0,
+        0,    0,    0,   83,    0,    0,   87,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
@@ -4229,7 +4369,8 @@ static const yy_state_type yy_NUL_trans[
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 
-        0,    0,    0,    0,    0,    0,    0,    0
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0
     } ;
 
 /* The intent behind this definition is that it'll catch
@@ -4241,9 +4382,8 @@ static const yy_state_type yy_NUL_trans[
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "wcsutrn.l"
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -4260,11 +4400,9 @@ static const yy_state_type yy_NUL_trans[
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsutrn.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsutrn.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
 * wcsutrn.l is a Flex description file containing the definition of a lexical
@@ -4280,7 +4418,7 @@ static const yy_state_type yy_NUL_trans[
 #define YY_NO_INPUT 1
 /* Exclusive start states. */
 
-#line 51 "wcsutrn.l"
+#line 49 "wcsutrn.l"
 #include <setjmp.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -4289,43 +4427,26 @@ static const yy_state_type yy_NUL_trans[
 #include "wcserr.h"
 #include "wcsunits.h"
 
-static int wcsutrne_scanner(int ctrl, char unitstr[], struct wcserr **err,
-                            yyscan_t yyscanner);
-
-/*--------------------------------------------------------------------------*/
-
-int wcsutrne(
-  int ctrl,
-  char unitstr[],
-  struct wcserr **err)
-
-{
-  int status;
-  yyscan_t yyscanner;
-  int yylex_init(yyscan_t *yyscanner);
-  int yylex_destroy(yyscan_t yyscanner);
-
-  yylex_init(&yyscanner);
-  status = wcsutrne_scanner(ctrl, unitstr, err, yyscanner);
-  yylex_destroy(yyscanner);
-
-  return status;
-}
-
-/*--------------------------------------------------------------------------*/
+// User data associated with yyscanner.
+struct wcsutrn_extra {
+  // Used in preempting the call to exit() by yy_fatal_error().
+  jmp_buf abort_jmp_env;
+};
 
 #define YY_DECL int wcsutrne_scanner(int ctrl, char unitstr[], \
  struct wcserr **err, yyscan_t yyscanner)
 
-/* Dummy definition to circumvent compiler warnings. */
+// Dummy definition to circumvent compiler warnings.
 #define YY_INPUT(inbuff, count, bufsize) { count = YY_NULL; }
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
-jmp_buf wcsutrn_abort_jmp_env;
-#define exit(status) longjmp(wcsutrn_abort_jmp_env, status)
+// Preempt the call to exit() by yy_fatal_error().
+#define exit(status) longjmp(yyextra->abort_jmp_env, status);
+
+// Internal helper functions.
+static YY_DECL;
 
-#line 4328 "wcsutrn.c"
-#line 4329 "wcsutrn.c"
+#line 4449 "wcsutrn.c"
+#line 4450 "wcsutrn.c"
 
 #define INITIAL 0
 #define NEXT 1
@@ -4339,9 +4460,7 @@ jmp_buf wcsutrn_abort_jmp_env;
 #include <unistd.h>
 #endif
 
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
+#define YY_EXTRA_TYPE struct wcsutrn_extra *
 
 /* Holds the entire state of the reentrant scanner. */
 struct yyguts_t
@@ -4574,29 +4693,29 @@ YY_DECL
 		}
 
 	{
-#line 96 "wcsutrn.l"
+#line 77 "wcsutrn.l"
 
-#line 98 "wcsutrn.l"
-	static const char *function = "wcsutrne";
-	
-	char orig[80], subs[80];
-	int bracket = 0;
-	int unsafe  = 0;
-	int status  = -1;
+#line 79 "wcsutrn.l"
+	static const char *function = "wcsutrne_scanner";
 	
 	if (err) *err = 0x0;
 	
+	char orig[80], subs[80];
 	*orig = '\0';
 	*subs = '\0';
 	
+	int bracket = 0;
+	int unsafe  = 0;
+	int status  = -1;
+	
 	yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
 	yy_scan_string(unitstr, yyscanner);
 	*unitstr = '\0';
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
-	if (setjmp(wcsutrn_abort_jmp_env)) {
+	// Return here via longjmp() invoked by yy_fatal_error().
+	if (setjmp(yyextra->abort_jmp_env)) {
 	  return wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
-	    "Internal units translator error parsing '%s'", unitstr);
+	    "Internal units translator error");
 	}
 	
 	BEGIN(INITIAL);
@@ -4605,7 +4724,7 @@ YY_DECL
 	fprintf(stderr, "\n%s ->\n", unitstr);
 #endif
 
-#line 4609 "wcsutrn.c"
+#line 4728 "wcsutrn.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -4638,24 +4757,24 @@ do_action:	/* This label is used only to
 	{ /* beginning of action switch */
 case 1:
 YY_RULE_SETUP
-#line 126 "wcsutrn.l"
+#line 107 "wcsutrn.l"
 {
-	  /* Looks like a keycomment. */
+	  // Looks like a keycomment.
 	  strcat(unitstr, "[");
 	  bracket = 1;
 	}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 132 "wcsutrn.l"
-/* Discard leading whitespace. */
+#line 113 "wcsutrn.l"
+// Discard leading whitespace.
 	YY_BREAK
 case 3:
 /* rule 3 can match eol */
 YY_RULE_SETUP
-#line 134 "wcsutrn.l"
+#line 115 "wcsutrn.l"
 {
-	  /* Non-alphabetic character. */
+	  // Non-alphabetic character.
 	  strcat(unitstr, yytext);
 	  if (bracket && *yytext == ']') {
 	    BEGIN(FLUSH);
@@ -4664,7 +4783,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 142 "wcsutrn.l"
+#line 123 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "Angstrom");
@@ -4673,7 +4792,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 148 "wcsutrn.l"
+#line 129 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "arcmin");
@@ -4682,7 +4801,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 154 "wcsutrn.l"
+#line 135 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "arcsec");
@@ -4691,7 +4810,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 160 "wcsutrn.l"
+#line 141 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "beam");
@@ -4700,7 +4819,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 166 "wcsutrn.l"
+#line 147 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "byte");
@@ -4709,7 +4828,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 172 "wcsutrn.l"
+#line 153 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "d");
@@ -4718,7 +4837,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 178 "wcsutrn.l"
+#line 159 "wcsutrn.l"
 {
 	  unsafe = 1;
 	  strcpy(orig, yytext);
@@ -4728,7 +4847,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 185 "wcsutrn.l"
+#line 166 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "deg");
@@ -4737,7 +4856,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 191 "wcsutrn.l"
+#line 172 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "GHz");
@@ -4746,7 +4865,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 197 "wcsutrn.l"
+#line 178 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "h");
@@ -4755,7 +4874,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 203 "wcsutrn.l"
+#line 184 "wcsutrn.l"
 {
 	  unsafe = 1;
 	  strcpy(orig, yytext);
@@ -4765,7 +4884,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 210 "wcsutrn.l"
+#line 191 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "Hz");
@@ -4774,7 +4893,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 216 "wcsutrn.l"
+#line 197 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "kHz");
@@ -4783,7 +4902,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 222 "wcsutrn.l"
+#line 203 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "Jy");
@@ -4792,7 +4911,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 228 "wcsutrn.l"
+#line 209 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "K");
@@ -4801,7 +4920,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 234 "wcsutrn.l"
+#line 215 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "km");
@@ -4810,7 +4929,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 240 "wcsutrn.l"
+#line 221 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "m");
@@ -4819,7 +4938,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 246 "wcsutrn.l"
+#line 227 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "min");
@@ -4828,7 +4947,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 252 "wcsutrn.l"
+#line 233 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "MHz");
@@ -4837,7 +4956,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 258 "wcsutrn.l"
+#line 239 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "ohm");
@@ -4846,7 +4965,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 264 "wcsutrn.l"
+#line 245 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "Pa");
@@ -4855,7 +4974,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 270 "wcsutrn.l"
+#line 251 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "pixel");
@@ -4864,7 +4983,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 276 "wcsutrn.l"
+#line 257 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "rad");
@@ -4873,7 +4992,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 282 "wcsutrn.l"
+#line 263 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "s");
@@ -4882,7 +5001,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 288 "wcsutrn.l"
+#line 269 "wcsutrn.l"
 {
 	  unsafe = 1;
 	  strcpy(orig, yytext);
@@ -4892,7 +5011,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 295 "wcsutrn.l"
+#line 276 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "V");
@@ -4901,7 +5020,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 301 "wcsutrn.l"
+#line 282 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "yr");
@@ -4910,9 +5029,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 307 "wcsutrn.l"
+#line 288 "wcsutrn.l"
 {
-	  /* Not a recognized alias. */
+	  // Not a recognized alias.
 	  strcpy(orig, yytext);
 	  strcpy(subs, orig);
 	  BEGIN(NEXT);
@@ -4920,9 +5039,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 314 "wcsutrn.l"
+#line 295 "wcsutrn.l"
 {
-	  /* Reject the alias match. */
+	  // Reject the alias match.
 	  strcat(orig, yytext);
 	  strcpy(subs, orig);
 	}
@@ -4930,17 +5049,17 @@ YY_RULE_SETUP
 case 33:
 /* rule 33 can match eol */
 YY_RULE_SETUP
-#line 320 "wcsutrn.l"
+#line 301 "wcsutrn.l"
 {
-	  /* Discard separating whitespace. */
+	  // Discard separating whitespace.
 	  unput(yytext[yyleng-1]);
 	}
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 325 "wcsutrn.l"
+#line 306 "wcsutrn.l"
 {
-	  /* Compress separating whitespace. */
+	  // Compress separating whitespace.
 	  strcat(unitstr, subs);
 	  strcat(unitstr, " ");
 	  if (strcmp(orig, subs)) status = 0;
@@ -4951,9 +5070,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 335 "wcsutrn.l"
+#line 316 "wcsutrn.l"
 {
-	  /* Copy anything else unchanged. */
+	  // Copy anything else unchanged.
 	  strcat(unitstr, subs);
 	  if (strcmp(orig, subs)) status = 0;
 	  unput(*yytext);
@@ -4963,18 +5082,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 344 "wcsutrn.l"
+#line 325 "wcsutrn.l"
 {
-	  /* Copy out remaining input. */
+	  // Copy out remaining input.
 	  strcat(unitstr, yytext);
 	}
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(NEXT):
 case YY_STATE_EOF(FLUSH):
-#line 349 "wcsutrn.l"
+#line 330 "wcsutrn.l"
 {
-	  /* End-of-string. */
+	  // End-of-string.
 	  if (*subs) {
 	    strcat(unitstr, subs);
 	    if (strcmp(orig, subs)) status = 0;
@@ -4989,10 +5108,10 @@ case YY_STATE_EOF(FLUSH):
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 363 "wcsutrn.l"
+#line 344 "wcsutrn.l"
 ECHO;
 	YY_BREAK
-#line 4996 "wcsutrn.c"
+#line 5115 "wcsutrn.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -6142,6 +6261,31 @@ void yyfree (void * ptr , yyscan_t yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 363 "wcsutrn.l"
+#line 344 "wcsutrn.l"
+
 
+/*----------------------------------------------------------------------------
+* External interface to the scanner.
+*---------------------------------------------------------------------------*/
+
+int wcsutrne(
+  int ctrl,
+  char unitstr[],
+  struct wcserr **err)
+
+{
+  static const char *function = "wcsutrne";
+
+  // Function prototypes.
+  int yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *yyscanner);
+  int yylex_destroy(yyscan_t yyscanner);
+
+  struct wcsutrn_extra extra;
+  yyscan_t yyscanner;
+  yylex_init_extra(&extra, &yyscanner);
+  int status = wcsutrne_scanner(ctrl, unitstr, err, yyscanner);
+  yylex_destroy(yyscanner);
+
+  return status;
+}
 
Index: astropy-4.2.1/cextern/wcslib/C/getwcstab.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/getwcstab.c
+++ astropy-4.2.1/cextern/wcslib/C/getwcstab.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: getwcstab.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: getwcstab.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <stdlib.h>
@@ -32,7 +29,7 @@
 
 #include "getwcstab.h"
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int fits_read_wcstab(
   fitsfile   *fptr,
@@ -54,30 +51,30 @@ int fits_read_wcstab(
 
   if (nwtb == 0) return 0;
 
-  /* Zero the array pointers. */
+  // Zero the array pointers.
   wtbp = wtb;
   for (iwtb = 0; iwtb < nwtb; iwtb++, wtbp++) {
     *wtbp->arrayp = 0x0;
   }
 
-  /* Save HDU number so that we can move back to it later. */
+  // Save HDU number so that we can move back to it later.
   fits_get_hdu_num(fptr, &hdunum);
 
   wtbp = wtb;
   for (iwtb = 0; iwtb < nwtb; iwtb++, wtbp++) {
-    /* Move to the required binary table extension. */
+    // Move to the required binary table extension.
     if (fits_movnam_hdu(fptr, BINARY_TBL, (char *)(wtbp->extnam),
         wtbp->extver, status)) {
       goto cleanup;
     }
 
-    /* Locate the table column. */
+    // Locate the table column.
     if (fits_get_colnum(fptr, CASEINSEN, (char *)(wtbp->ttype), &colnum,
         status)) {
       goto cleanup;
     }
 
-    /* Get the array dimensions and check for consistency. */
+    // Get the array dimensions and check for consistency.
     if (wtbp->ndim < 1) {
       *status = NEG_AXIS;
       goto cleanup;
@@ -94,7 +91,7 @@ int fits_read_wcstab(
 
     if (naxis != wtbp->ndim) {
       if (wtbp->kind == 'c' && wtbp->ndim == 2) {
-        /* Allow TDIMn to be omitted for degenerate coordinate arrays. */
+        // Allow TDIMn to be omitted for degenerate coordinate arrays.
         naxis = 2;
         naxes[1] = naxes[0];
         naxes[0] = 1;
@@ -105,16 +102,16 @@ int fits_read_wcstab(
     }
 
     if (wtbp->kind == 'c') {
-      /* Coordinate array; calculate the array size. */
+      // Coordinate array; calculate the array size.
       nelem = naxes[0];
       for (m = 0; m < naxis-1; m++) {
         *(wtbp->dimlen + m) = naxes[m+1];
         nelem *= naxes[m+1];
       }
     } else {
-      /* Index vector; check length. */
+      // Index vector; check length.
       if ((nelem = naxes[0]) != *(wtbp->dimlen)) {
-        /* N.B. coordinate array precedes the index vectors. */
+        // N.B. coordinate array precedes the index vectors.
         *status = BAD_TDIM;
         goto cleanup;
       }
@@ -123,13 +120,13 @@ int fits_read_wcstab(
     free(naxes);
     naxes = 0;
 
-    /* Allocate memory for the array. */
+    // Allocate memory for the array.
     if (!(*wtbp->arrayp = calloc((size_t)nelem, sizeof(double)))) {
       *status = MEMORY_ALLOCATION;
       goto cleanup;
     }
 
-    /* Read the array from the table. */
+    // Read the array from the table.
     if (fits_read_col_dbl(fptr, colnum, wtbp->row, 1L, nelem, 0.0,
         *wtbp->arrayp, &anynul, status)) {
       goto cleanup;
@@ -137,11 +134,11 @@ int fits_read_wcstab(
   }
 
 cleanup:
-  /* Move back to the starting HDU. */
+  // Move back to the starting HDU.
   nostat = 0;
   fits_movabs_hdu(fptr, hdunum, 0, &nostat);
 
-  /* Release allocated memory. */
+  // Release allocated memory.
   if (naxes) free(naxes);
   if (*status) {
     wtbp = wtb;
Index: astropy-4.2.1/cextern/wcslib/C/getwcstab.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/getwcstab.h
+++ astropy-4.2.1/cextern/wcslib/C/getwcstab.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: getwcstab.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: getwcstab.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -68,50 +65,50 @@
 *             int       CFITSIO status value.
 *
 * Notes:
-*   In order to maintain WCSLIB and CFITSIO as independent libraries it is not
-*   permissible for any CFITSIO library code to include WCSLIB header files,
-*   or vice versa.  However, the CFITSIO function fits_read_wcstab() accepts
-*   an array of wtbarr structs defined in wcs.h within WCSLIB.
-*
-*   The problem therefore is to define the wtbarr struct within fitsio.h
-*   without including wcs.h, especially noting that wcs.h will often (but not
-*   always) be included together with fitsio.h in an applications program that
-*   uses fits_read_wcstab().
-*
-*   The solution adopted is for WCSLIB to define "struct wtbarr" while
-*   fitsio.h defines "typedef wtbarr" as an untagged struct with identical
-*   members.  This allows both wcs.h and fitsio.h to define a wtbarr data type
-*   without conflict by virtue of the fact that structure tags and typedef
-*   names share different name spaces in C; Appendix A, Sect. A11.1 (p227) of
-*   the K&R ANSI edition states that:
-*
-*     Identifiers fall into several name spaces that do not interfere with one
-*     another; the same identifier may be used for different purposes, even in
-*     the same scope, if the uses are in different name spaces.  These classes
-*     are: objects, functions, typedef names, and enum constants; labels; tags
-*     of structures, unions, and enumerations; and members of each structure
-*     or union individually.
-*
-*   Therefore, declarations within WCSLIB look like
-*
-=     struct wtbarr *w;
-*
-*   while within CFITSIO they are simply
-*
-=     wtbarr *w;
-*
-*   As suggested by the commonality of the names, these are really the same
-*   aggregate data type.  However, in passing a (struct wtbarr *) to
-*   fits_read_wcstab() a cast to (wtbarr *) is formally required.
-*
-*   When using WCSLIB and CFITSIO together in C++ the situation is complicated
-*   by the fact that typedefs and structs share the same namespace; C++
-*   Annotated Reference Manual, Sect. 7.1.3 (p105).  In that case the wtbarr
-*   struct in wcs.h is renamed by preprocessor macro substitution to wtbarr_s
-*   to distinguish it from the typedef defined in fitsio.h.  However, the
-*   scope of this macro substitution is limited to wcs.h itself and CFITSIO
-*   programmer code, whether in C++ or C, should always use the wtbarr
-*   typedef.
+*   1: In order to maintain WCSLIB and CFITSIO as independent libraries it is
+*      not permissible for any CFITSIO library code to include WCSLIB header
+*      files, or vice versa.  However, the CFITSIO function fits_read_wcstab()
+*      accepts an array of wtbarr structs defined in wcs.h within WCSLIB.
+*
+*      The problem therefore is to define the wtbarr struct within fitsio.h
+*      without including wcs.h, especially noting that wcs.h will often (but
+*      not always) be included together with fitsio.h in an applications
+*      program that uses fits_read_wcstab().
+*
+*      The solution adopted is for WCSLIB to define "struct wtbarr" while
+*      fitsio.h defines "typedef wtbarr" as an untagged struct with identical
+*      members.  This allows both wcs.h and fitsio.h to define a wtbarr data
+*      type without conflict by virtue of the fact that structure tags and
+*      typedef names share different name spaces in C; Appendix A, Sect. A11.1
+*      (p227) of the K&R ANSI edition states that:
+*
+=        Identifiers fall into several name spaces that do not interfere with
+=        one another; the same identifier may be used for different purposes,
+=        even in the same scope, if the uses are in different name spaces.
+=        These classes are: objects, functions, typedef names, and enum
+=        constants; labels; tags of structures, unions, and enumerations; and
+=        members of each structure or union individually.
+*
+*      Therefore, declarations within WCSLIB look like
+*
+=        struct wtbarr *w;
+*
+*      while within CFITSIO they are simply
+*
+=        wtbarr *w;
+*
+*      As suggested by the commonality of the names, these are really the same
+*      aggregate data type.  However, in passing a (struct wtbarr *) to
+*      fits_read_wcstab() a cast to (wtbarr *) is formally required.
+*
+*      When using WCSLIB and CFITSIO together in C++ the situation is
+*      complicated by the fact that typedefs and structs share the same
+*      namespace; C++ Annotated Reference Manual, Sect. 7.1.3 (p105).  In that
+*      case the wtbarr struct in wcs.h is renamed by preprocessor macro
+*      substitution to wtbarr_s to distinguish it from the typedef defined in
+*      fitsio.h.  However, the scope of this macro substitution is limited to
+*      wcs.h itself and CFITSIO programmer code, whether in C++ or C, should
+*      always use the wtbarr typedef.
 *
 *
 * wtbarr typedef
@@ -168,18 +165,18 @@ extern "C" {
 #include <fitsio.h>
 
 typedef struct {
-  int  i;			/* Image axis number.                       */
-  int  m;			/* Array axis number for index vectors.     */
-  int  kind;			/* Array type, 'c' (coord) or 'i' (index).  */
-  char extnam[72];		/* EXTNAME of binary table extension.       */
-  int  extver;			/* EXTVER  of binary table extension.       */
-  int  extlev;			/* EXTLEV  of binary table extension.       */
-  char ttype[72];		/* TTYPEn of column containing the array.   */
-  long row;			/* Table row number.                        */
-  int  ndim;			/* Expected array dimensionality.           */
-  int  *dimlen;			/* Where to write the array axis lengths.   */
-  double **arrayp;		/* Where to write the address of the array  */
-				/* allocated to store the array.            */
+  int  i;			// Image axis number.
+  int  m;			// Array axis number for index vectors.
+  int  kind;			// Array type, 'c' (coord) or 'i' (index).
+  char extnam[72];		// EXTNAME of binary table extension.
+  int  extver;			// EXTVER  of binary table extension.
+  int  extlev;			// EXTLEV  of binary table extension.
+  char ttype[72];		// TTYPEn of column containing the array.
+  long row;			// Table row number.
+  int  ndim;			// Expected array dimensionality.
+  int  *dimlen;			// Where to write the array axis lengths.
+  double **arrayp;		// Where to write the address of the array
+				// allocated to store the array.
 } wtbarr;
 
 
@@ -190,4 +187,4 @@ int fits_read_wcstab(fitsfile *fptr, int
 }
 #endif
 
-#endif /* WCSLIB_GETWCSTAB */
+#endif // WCSLIB_GETWCSTAB
Index: astropy-4.2.1/cextern/wcslib/C/lin.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/lin.c
+++ astropy-4.2.1/cextern/wcslib/C/lin.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,17 +17,15 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: lin.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: lin.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
+#include <math.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <math.h>
 
 #include "wcserr.h"
 #include "wcsprintf.h"
@@ -37,7 +34,7 @@
 
 const int LINSET = 137;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *lin_errmsg[] = {
   "Success",
   "Null linprm pointer passed",
@@ -47,20 +44,20 @@ const char *lin_errmsg[] = {
   "Distort error",
   "De-distort error"};
 
-/* Map error returns for lower-level routines. */
+// Map error returns for lower-level routines.
 const int lin_diserr[] = {
-  LINERR_SUCCESS,		/*  0: DISERR_SUCCESS         */
-  LINERR_NULL_POINTER,		/*  1: DISERR_NULL_POINTER    */
-  LINERR_MEMORY,		/*  2: DISERR_MEMORY          */
-  LINERR_DISTORT_INIT,		/*  3: DISERR_BAD_PARAM       */
-  LINERR_DISTORT,		/*  4: DISERR_DISTORT         */
-  LINERR_DEDISTORT		/*  5: DISERR_DEDISTORT       */
+  LINERR_SUCCESS,		//  0: DISERR_SUCCESS
+  LINERR_NULL_POINTER,		//  1: DISERR_NULL_POINTER
+  LINERR_MEMORY,		//  2: DISERR_MEMORY
+  LINERR_DISTORT_INIT,		//  3: DISERR_BAD_PARAM
+  LINERR_DISTORT,		//  4: DISERR_DISTORT
+  LINERR_DEDISTORT		//  5: DISERR_DEDISTORT
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define LIN_ERRMSG(status) WCSERR_SET(status), lin_errmsg[status]
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linini(int alloc, int naxis, struct linprm *lin)
 
@@ -68,7 +65,7 @@ int linini(int alloc, int naxis, struct
   return lininit(alloc, naxis, lin, -1);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int lininit(int alloc, int naxis, struct linprm *lin, int ndpmax)
 
@@ -81,7 +78,7 @@ int lininit(int alloc, int naxis, struct
 
   if (lin == 0x0) return LINERR_NULL_POINTER;
 
-  /* Initialize error message handling. */
+  // Initialize error message handling.
   if (lin->flag == -1) {
     lin->err = 0x0;
   }
@@ -89,7 +86,7 @@ int lininit(int alloc, int naxis, struct
   wcserr_clear(err);
 
 
-  /* Initialize memory management. */
+  // Initialize memory management.
   if (lin->flag == -1 || lin->m_flag != LINSET) {
     if (lin->flag == -1) {
       lin->dispre = 0x0;
@@ -112,21 +109,21 @@ int lininit(int alloc, int naxis, struct
   }
 
 
-  /* Allocate memory for arrays if required. */
+  // Allocate memory for arrays if required.
   if (alloc ||
       lin->crpix  == 0x0 ||
       lin->pc     == 0x0 ||
       lin->cdelt  == 0x0) {
 
-    /* Was sufficient allocated previously? */
+    // Was sufficient allocated previously?
     if (lin->m_flag == LINSET && lin->m_naxis < naxis) {
-      /* No, free it. */
+      // No, free it.
       linfree(lin);
     }
 
     if (alloc || lin->crpix == 0x0) {
       if (lin->m_crpix) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         lin->crpix = lin->m_crpix;
 
       } else {
@@ -142,7 +139,7 @@ int lininit(int alloc, int naxis, struct
 
     if (alloc || lin->pc == 0x0) {
       if (lin->m_pc) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         lin->pc = lin->m_pc;
 
       } else {
@@ -159,7 +156,7 @@ int lininit(int alloc, int naxis, struct
 
     if (alloc || lin->cdelt == 0x0) {
       if (lin->m_cdelt) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         lin->cdelt = lin->m_cdelt;
 
       } else {
@@ -176,7 +173,7 @@ int lininit(int alloc, int naxis, struct
   }
 
 
-  /* Reinitialize disprm structs if we are managing them. */
+  // Reinitialize disprm structs if we are managing them.
   if (lin->m_dispre) {
     disinit(1, naxis, lin->dispre, ndpmax);
   }
@@ -186,7 +183,7 @@ int lininit(int alloc, int naxis, struct
   }
 
 
-  /* Free memory allocated by linset(). */
+  // Free memory allocated by linset().
   if (lin->flag == LINSET) {
     if (lin->piximg) free(lin->piximg);
     if (lin->imgpix) free(lin->imgpix);
@@ -206,12 +203,12 @@ int lininit(int alloc, int naxis, struct
   lin->naxis = naxis;
 
 
-  /* CRPIXja defaults to 0.0. */
+  // CRPIXja defaults to 0.0.
   for (j = 0; j < naxis; j++) {
     lin->crpix[j] = 0.0;
   }
 
-  /* PCi_ja defaults to the unit matrix. */
+  // PCi_ja defaults to the unit matrix.
   pc = lin->pc;
   for (i = 0; i < naxis; i++) {
     for (j = 0; j < naxis; j++) {
@@ -224,7 +221,7 @@ int lininit(int alloc, int naxis, struct
     }
   }
 
-  /* CDELTia defaults to 1.0. */
+  // CDELTia defaults to 1.0.
   for (i = 0; i < naxis; i++) {
     lin->cdelt[i] = 1.0;
   }
@@ -233,7 +230,7 @@ int lininit(int alloc, int naxis, struct
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int lindis(int sequence, struct linprm *lin, struct disprm *dis)
 
@@ -241,7 +238,7 @@ int lindis(int sequence, struct linprm *
   return lindist(sequence, lin, dis, -1);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int lindist(int sequence, struct linprm *lin, struct disprm *dis, int ndpmax)
 
@@ -288,7 +285,7 @@ int lindist(int sequence, struct linprm
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int lincpy(int alloc, const struct linprm *linsrc, struct linprm *lindst)
 
@@ -384,7 +381,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linfree(struct linprm *lin)
 
@@ -392,7 +389,7 @@ int linfree(struct linprm *lin)
   if (lin == 0x0) return LINERR_NULL_POINTER;
 
   if (lin->flag != -1) {
-    /* Optionally allocated by lininit() for given parameters. */
+    // Optionally allocated by lininit() for given parameters.
     if (lin->m_flag == LINSET) {
       if (lin->crpix  == lin->m_crpix)  lin->crpix  = 0x0;
       if (lin->pc     == lin->m_pc)     lin->pc     = 0x0;
@@ -415,7 +412,7 @@ int linfree(struct linprm *lin)
       }
     }
 
-    /* Allocated unconditionally by linset(). */
+    // Allocated unconditionally by linset().
     if (lin->piximg) free(lin->piximg);
     if (lin->imgpix) free(lin->imgpix);
     if (lin->tmpcrd) free(lin->tmpcrd);
@@ -443,7 +440,65 @@ int linfree(struct linprm *lin)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
+
+int linsize(const struct linprm *lin, int sizes[2])
+
+{
+
+  if (lin == 0x0) {
+    sizes[0] = sizes[1] = 0;
+    return LINERR_SUCCESS;
+  }
+
+  // Base size, in bytes.
+  sizes[0] = sizeof(struct linprm);
+
+  // Total size of allocated memory, in bytes.
+  sizes[1] = 0;
+
+  int exsizes[2];
+  int naxis = lin->naxis;
+
+  // linprm::crpix[].
+  sizes[1] += naxis * sizeof(double);
+
+  // linprm::pc[].
+  sizes[1] += naxis*naxis * sizeof(double);
+
+  // linprm::cdelt[].
+  sizes[1] += naxis * sizeof(double);
+
+  // linprm::dispre[].
+  dissize(lin->dispre, exsizes);
+  sizes[2] += exsizes[0] + exsizes[1];
+
+  // linprm::disseq[].
+  dissize(lin->disseq, exsizes);
+  sizes[2] += exsizes[0] + exsizes[1];
+
+  // linprm::err[].
+  wcserr_size(lin->err, exsizes);
+  sizes[1] += exsizes[0] + exsizes[1];
+
+  // The remaining arrays are allocated unconditionally by linset().
+  if (lin->flag != LINSET) {
+    return LINERR_SUCCESS;
+  }
+
+  // linprm::piximg[].
+  sizes[1] += naxis*naxis * sizeof(double);
+
+  // linprm::imgpix[].
+  sizes[1] += naxis*naxis * sizeof(double);
+
+  // linprm::tmpcrd[].
+  sizes[1] += naxis * sizeof(double);
+
+  return LINERR_SUCCESS;
+}
+
+//----------------------------------------------------------------------------
 
 int linprt(const struct linprm *lin)
 
@@ -458,7 +513,7 @@ int linprt(const struct linprm *lin)
   }
   wcsprintf("       flag: %d\n", lin->flag);
 
-  /* Parameters supplied. */
+  // Parameters supplied.
   wcsprintf("      naxis: %d\n", lin->naxis);
 
   WCSPRINTF_PTR("      crpix: ", lin->crpix, "\n");
@@ -492,7 +547,7 @@ int linprt(const struct linprm *lin)
   if (lin->disseq != 0x0) wcsprintf("  (see below)");
   wcsprintf("\n");
 
-  /* Derived values. */
+  // Derived values.
   if (lin->piximg == 0x0) {
     wcsprintf("     piximg: (nil)\n");
   } else {
@@ -524,16 +579,16 @@ int linprt(const struct linprm *lin)
   wcsprintf("     affine: %d\n", lin->affine);
   wcsprintf("     simple: %d\n", lin->simple);
 
-  /* Error handling. */
+  // Error handling.
   WCSPRINTF_PTR("        err: ", lin->err, "\n");
   if (lin->err) {
     wcserr_prt(lin->err, "             ");
   }
 
-  /* Work arrays. */
+  // Work arrays.
   WCSPRINTF_PTR("     tmpcrd: ", lin->tmpcrd, "\n");
 
-  /* Memory management. */
+  // Memory management.
   wcsprintf("     m_flag: %d\n", lin->m_flag);
   wcsprintf("    m_naxis: %d\n", lin->m_naxis);
   WCSPRINTF_PTR("    m_crpix: ", lin->m_crpix, "");
@@ -552,7 +607,7 @@ int linprt(const struct linprm *lin)
   if (lin->disseq && lin->m_disseq == lin->disseq) wcsprintf("  (= disseq)");
   wcsprintf("\n");
 
-  /* Distortion parameters (from above). */
+  // Distortion parameters (from above).
   if (lin->dispre) {
     wcsprintf("\n");
     wcsprintf("dispre.*\n");
@@ -568,7 +623,7 @@ int linprt(const struct linprm *lin)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linperr(const struct linprm *lin, const char *prefix)
 
@@ -583,7 +638,7 @@ int linperr(const struct linprm *lin, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linset(struct linprm *lin)
 
@@ -599,7 +654,7 @@ int linset(struct linprm *lin)
 
   naxis = lin->naxis;
 
-  /* Check for a unit matrix. */
+  // Check for a unit matrix.
   lin->unity = 1;
   pc = lin->pc;
   for (i = 0; i < naxis; i++) {
@@ -621,7 +676,7 @@ int linset(struct linprm *lin)
 
   if (lin->unity) {
     if (lin->flag == LINSET) {
-      /* Free memory that may have been allocated previously. */
+      // Free memory that may have been allocated previously.
       if (lin->piximg) free(lin->piximg);
       if (lin->imgpix) free(lin->imgpix);
     }
@@ -630,7 +685,7 @@ int linset(struct linprm *lin)
     lin->imgpix  = 0x0;
     lin->i_naxis = 0;
 
-    /* Check cdelt. */
+    // Check cdelt.
     for (i = 0; i < naxis; i++) {
       if (lin->cdelt[i] == 0.0) {
         return wcserr_set(LIN_ERRMSG(LINERR_SINGULAR_MTX));
@@ -640,12 +695,12 @@ int linset(struct linprm *lin)
   } else {
     if (lin->flag != LINSET || lin->i_naxis < naxis) {
       if (lin->flag == LINSET) {
-        /* Free memory that may have been allocated previously. */
+        // Free memory that may have been allocated previously.
         if (lin->piximg) free(lin->piximg);
         if (lin->imgpix) free(lin->imgpix);
       }
 
-      /* Allocate memory for internal arrays. */
+      // Allocate memory for internal arrays.
       if ((lin->piximg = calloc(naxis*naxis, sizeof(double))) == 0x0) {
         return wcserr_set(LIN_ERRMSG(LINERR_MEMORY));
       }
@@ -658,28 +713,30 @@ int linset(struct linprm *lin)
       lin->i_naxis = naxis;
     }
 
-    /* Compute the pixel-to-image transformation matrix. */
+    // Compute the pixel-to-image transformation matrix.
     pc     = lin->pc;
     piximg = lin->piximg;
     for (i = 0; i < naxis; i++) {
-      for (j = 0; j < naxis; j++) {
-        if (lin->disseq == 0x0) {
-          /* No sequent distortions, incorporate cdelt into piximg. */
+      if (lin->disseq == 0x0) {
+        // No sequent distortions.  Incorporate cdelt into piximg.
+        for (j = 0; j < naxis; j++) {
           *(piximg++) = lin->cdelt[i] * (*(pc++));
-        } else {
+        }
+      } else {
+        for (j = 0; j < naxis; j++) {
           *(piximg++) = *(pc++);
         }
       }
     }
 
-    /* Compute the image-to-pixel transformation matrix. */
+    // Compute the image-to-pixel transformation matrix.
     if ((status = matinv(naxis, lin->piximg, lin->imgpix))) {
       return wcserr_set(LIN_ERRMSG(status));
     }
   }
 
 
-  /* Set up the distortion functions. */
+  // Set up the distortion functions.
   lin->affine = 1;
   if (lin->dispre) {
     if ((status = disset(lin->dispre))) {
@@ -700,7 +757,7 @@ int linset(struct linprm *lin)
   lin->simple = lin->unity && lin->affine;
 
 
-  /* Create work arrays. */
+  // Create work arrays.
   if (lin->tmpcrd) free(lin->tmpcrd);
   if ((lin->tmpcrd = calloc(naxis, sizeof(double))) == 0x0) {
     linfree(lin);
@@ -713,7 +770,7 @@ int linset(struct linprm *lin)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linp2x(
   struct linprm *lin,
@@ -732,7 +789,7 @@ int linp2x(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (lin == 0x0) return LINERR_NULL_POINTER;
   err = &(lin->err);
 
@@ -743,12 +800,12 @@ int linp2x(
   n = lin->naxis;
 
 
-  /* Convert pixel coordinates to intermediate world coordinates. */
+  // Convert pixel coordinates to intermediate world coordinates.
   pix = pixcrd;
   img = imgcrd;
 
   if (lin->simple) {
-    /* Handle the simplest and most common case with maximum efficiency. */
+    // Handle the simplest and most common case with maximum efficiency.
     nelemn = nelem - n;
     for (k = 0; k < ncoord; k++) {
       for (i = 0; i < n; i++) {
@@ -760,17 +817,17 @@ int linp2x(
     }
 
   } else if (lin->affine) {
-    /* No distortions. */
+    // No distortions.
     ndbl   = n * sizeof(double);
     nelemn = nelem - n;
     for (k = 0; k < ncoord; k++) {
       memset(img, 0, ndbl);
 
       for (j = 0; j < n; j++) {
-        /* cdelt will have been incorporated into piximg. */
+        // cdelt will have been incorporated into piximg.
         piximg = lin->piximg + j;
 
-        /* Column-wise multiplication allows this to be cached. */
+        // Column-wise multiplication allows this to be cached.
         temp = *(pix++) - lin->crpix[j];
         for (i = 0; i < n; i++, piximg += n) {
           img[i] += *piximg * temp;
@@ -782,7 +839,7 @@ int linp2x(
     }
 
   } else {
-    /* Distortions are present. */
+    // Distortions are present.
     ndbl = n * sizeof(double);
     tmp  = lin->tmpcrd;
 
@@ -819,13 +876,13 @@ int linp2x(
           return wcserr_set(LIN_ERRMSG(lin_diserr[status]));
         }
 
-        /* With sequent distortions, cdelt is not incorporated into piximg. */
+        // With sequent distortions, cdelt is not incorporated into piximg...
         for (i = 0; i < n; i++) {
           img[i] = lin->cdelt[i] * tmp[i];
         }
 
       } else if (lin->unity) {
-        /* ...nor if the matrix is unity. */
+        // ...nor if the matrix is unity.
         for (i = 0; i < n; i++) {
           img[i] *= lin->cdelt[i];
         }
@@ -839,7 +896,7 @@ int linp2x(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linx2p(
   struct linprm *lin,
@@ -857,7 +914,7 @@ int linx2p(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (lin == 0x0) return LINERR_NULL_POINTER;
   err = &(lin->err);
 
@@ -868,12 +925,12 @@ int linx2p(
   n = lin->naxis;
 
 
-  /* Convert intermediate world coordinates to pixel coordinates. */
+  // Convert intermediate world coordinates to pixel coordinates.
   img = imgcrd;
   pix = pixcrd;
 
   if (lin->simple) {
-    /* Handle the simplest and most common case with maximum efficiency. */
+    // Handle the simplest and most common case with maximum efficiency.
     nelemn = nelem - n;
     for (k = 0; k < ncoord; k++) {
       for (j = 0; j < n; j++) {
@@ -885,10 +942,10 @@ int linx2p(
     }
 
   } else if (lin->affine) {
-    /* No distortions. */
+    // No distortions.
     nelemn = nelem - n;
     for (k = 0; k < ncoord; k++) {
-      /* cdelt will have been incorporated into imgpix. */
+      // cdelt will have been incorporated into imgpix.
       imgpix = lin->imgpix;
 
       for (j = 0; j < n; j++) {
@@ -906,13 +963,13 @@ int linx2p(
     }
 
   } else {
-    /* Distortions are present. */
+    // Distortions are present.
     ndbl = n * sizeof(double);
     tmp  = lin->tmpcrd;
 
     for (k = 0; k < ncoord; k++) {
       if (lin->disseq) {
-        /* With sequent distortions, cdelt is not incorporated into imgpix. */
+        // With sequent distortions, cdelt is not incorporated into imgpix...
         for (i = 0; i < n; i++) {
           tmp[i] = img[i] / lin->cdelt[i];
         }
@@ -924,13 +981,13 @@ int linx2p(
         memcpy(tmp, pix, ndbl);
 
       } else if (lin->unity) {
-        /* ...nor if the matrix is unity. */
+        // ...nor if the matrix is unity.
         for (i = 0; i < n; i++) {
           tmp[i] = img[i] / lin->cdelt[i];
         }
 
       } else {
-        /* cdelt will have been incorporated into imgpix. */
+        // cdelt will have been incorporated into imgpix.
         memcpy(tmp, img, ndbl);
       }
 
@@ -965,7 +1022,7 @@ int linx2p(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linwarp(
   struct linprm *lin,
@@ -990,7 +1047,7 @@ int linwarp(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (lin == 0x0) return LINERR_NULL_POINTER;
   err = &(lin->err);
 
@@ -1006,17 +1063,17 @@ int linwarp(
   if (avgtot) *avgtot = 0.0;
   if (rmstot) *rmstot = 0.0;
 
-  /* Quick return if no distortions. */
+  // Quick return if no distortions.
   if (lin->affine) return 0;
 
-  /* It's easier if there are no sequent distortions! */
+  // It's easier if there are no sequent distortions!
   if (lin->disseq == 0x0) {
     status = diswarp(lin->dispre, pixblc, pixtrc, pixsamp, nsamp,
                      maxdis, maxtot, avgdis, avgtot, rmsdis, rmstot);
     return wcserr_set(LIN_ERRMSG(lin_diserr[status]));
   }
 
-  /* Make a reference copy of lin without distortions. */
+  // Make a reference copy of lin without distortions.
   affine.flag = -1;
   if ((status = (lincpy(1, lin, &affine) ||
                  lindist(1, &affine, 0x0, 0) ||
@@ -1025,7 +1082,7 @@ int linwarp(
     return wcserr_set(LIN_ERRMSG(status));
   }
 
-  /* Work out increments on each axis. */
+  // Work out increments on each axis.
   pixinc = lin->tmpcrd;
   ncoord = 0;
   for (j = 0; j < naxis; j++) {
@@ -1044,12 +1101,12 @@ int linwarp(
     }
 
     if (j == 0) {
-      /* Number of samples on axis 1. */
+      // Number of samples on axis 1.
       ncoord = 1 + (int)((pixspan/pixinc[0]) + 0.5);
     }
   }
 
-  /* Get memory for processing the image row by row. */
+  // Get memory for processing the image row by row.
   if ((pix0 = calloc((3*ncoord+4)*naxis, sizeof(double))) == 0x0) {
     return wcserr_set(LIN_ERRMSG(LINERR_MEMORY));
   }
@@ -1062,10 +1119,10 @@ int linwarp(
   ssqdis = sumdis + naxis;
 
 
-  /* Copy tmpcrd since linp2x() will overwrite it. */
+  // Copy tmpcrd since linp2x() will overwrite it.
   memcpy(pixinc, lin->tmpcrd, naxis*sizeof(double));
 
-  /* Set up the array of pixel coordinates. */
+  // Set up the array of pixel coordinates.
   for (j = 0; j < naxis; j++) {
     pix0[j] = pixblc ? pixblc[j] : 1.0;
     pixend[j] = pixtrc[j] + 0.5*pixinc[j];
@@ -1080,7 +1137,7 @@ int linwarp(
     }
   }
 
-  /* Initialize accumulators. */
+  // Initialize accumulators.
   for (j = 0; j < naxis; j++) {
     sumdis[j] = 0.0;
     ssqdis[j] = 0.0;
@@ -1089,20 +1146,20 @@ int linwarp(
   ssqtot = 0.0;
 
 
-  /* Loop over N dimensions. */
+  // Loop over N dimensions.
   carry = 0;
   while (carry == 0) {
     if ((status = linp2x(lin, ncoord, naxis, pix0, img))) {
-      /* (Preserve the error message set by linp2x().) */
+      // (Preserve the error message set by linp2x().)
       goto cleanup;
     }
 
     if ((status = linx2p(&affine, ncoord, naxis, img, pix1))) {
-      /* (Preserve the error message set by linx2p().) */
+      // (Preserve the error message set by linx2p().)
       goto cleanup;
     }
 
-    /* Accumulate statistics. */
+    // Accumulate statistics.
     pix0p = pix0;
     pix1p = pix1;
     for (i = 0; i < ncoord; i++) {
@@ -1128,7 +1185,7 @@ int linwarp(
       if (maxtot && *maxtot < totdis) *maxtot = totdis;
     }
 
-    /* Next array of pixel coordinates. */
+    // Next array of pixel coordinates.
     for (j = 1; j < naxis; j++) {
       pix0[j] += pixinc[j];
       if ((carry = (pix0[j] > pixend[j]))) {
@@ -1146,7 +1203,7 @@ int linwarp(
   }
 
 
-  /* Compute the means and RMSs. */
+  // Compute the means and RMSs.
   for (j = 0; j < naxis; j++) {
     ssqdis[j] /= *nsamp;
     sumdis[j] /= *nsamp;
@@ -1167,7 +1224,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int matinv(int n, const double mat[], double inv[])
 
@@ -1177,7 +1234,7 @@ int matinv(int n, const double mat[], do
   double colmax, *lu, *rowmax, dtemp;
 
 
-  /* Allocate memory for internal arrays. */
+  // Allocate memory for internal arrays.
   if ((mxl = calloc(n, sizeof(int))) == 0x0) {
     return LINERR_MEMORY;
   }
@@ -1200,9 +1257,9 @@ int matinv(int n, const double mat[], do
   }
 
 
-  /* Initialize arrays. */
+  // Initialize arrays.
   for (i = 0, ij = 0; i < n; i++) {
-    /* Vector that records row interchanges. */
+    // Vector that records row interchanges.
     mxl[i] = i;
 
     rowmax[i] = 0.0;
@@ -1214,7 +1271,7 @@ int matinv(int n, const double mat[], do
       lu[ij] = mat[ij];
     }
 
-    /* A row of zeroes indicates a singular matrix. */
+    // A row of zeroes indicates a singular matrix.
     if (rowmax[i] == 0.0) {
       free(mxl);
       free(lxm);
@@ -1225,9 +1282,9 @@ int matinv(int n, const double mat[], do
   }
 
 
-  /* Form the LU triangular factorization using scaled partial pivoting. */
+  // Form the LU triangular factorization using scaled partial pivoting.
   for (k = 0; k < n; k++) {
-    /* Decide whether to pivot. */
+    // Decide whether to pivot.
     colmax = fabs(lu[k*n+k]) / rowmax[k];
     pivot = k;
 
@@ -1241,34 +1298,34 @@ int matinv(int n, const double mat[], do
     }
 
     if (pivot > k) {
-      /* We must pivot, interchange the rows of the design matrix. */
+      // We must pivot, interchange the rows of the design matrix.
       for (j = 0, pj = pivot*n, kj = k*n; j < n; j++, pj++, kj++) {
         dtemp = lu[pj];
         lu[pj] = lu[kj];
         lu[kj] = dtemp;
       }
 
-      /* Amend the vector of row maxima. */
+      // Amend the vector of row maxima.
       dtemp = rowmax[pivot];
       rowmax[pivot] = rowmax[k];
       rowmax[k] = dtemp;
 
-      /* Record the interchange for later use. */
+      // Record the interchange for later use.
       itemp = mxl[pivot];
       mxl[pivot] = mxl[k];
       mxl[k] = itemp;
     }
 
-    /* Gaussian elimination. */
+    // Gaussian elimination.
     for (i = k+1; i < n; i++) {
       ik = i*n + k;
 
-      /* Nothing to do if lu[ik] is zero. */
+      // Nothing to do if lu[ik] is zero.
       if (lu[ik] != 0.0) {
-        /* Save the scaling factor. */
+        // Save the scaling factor.
         lu[ik] /= lu[k*n+k];
 
-        /* Subtract rows. */
+        // Subtract rows.
         for (j = k+1; j < n; j++) {
           lu[i*n+j] -= lu[ik]*lu[k*n+j];
         }
@@ -1277,14 +1334,14 @@ int matinv(int n, const double mat[], do
   }
 
 
-  /* mxl[i] records which row of mat corresponds to row i of lu.  */
-  /* lxm[i] records which row of lu  corresponds to row i of mat. */
+  // mxl[i] records which row of mat corresponds to row i of lu.
+  // lxm[i] records which row of lu  corresponds to row i of mat.
   for (i = 0; i < n; i++) {
     lxm[mxl[i]] = i;
   }
 
 
-  /* Determine the inverse matrix. */
+  // Determine the inverse matrix.
   for (i = 0, ij = 0; i < n; i++) {
     for (j = 0; j < n; j++, ij++) {
       inv[ij] = 0.0;
@@ -1294,14 +1351,14 @@ int matinv(int n, const double mat[], do
   for (k = 0; k < n; k++) {
     inv[lxm[k]*n+k] = 1.0;
 
-    /* Forward substitution. */
+    // Forward substitution.
     for (i = lxm[k]+1; i < n; i++) {
       for (j = lxm[k]; j < i; j++) {
         inv[i*n+k] -= lu[i*n+j]*inv[j*n+k];
       }
     }
 
-    /* Backward substitution. */
+    // Backward substitution.
     for (i = n-1; i >= 0; i--) {
       for (j = i+1; j < n; j++) {
         inv[i*n+k] -= lu[i*n+j]*inv[j*n+k];
Index: astropy-4.2.1/cextern/wcslib/C/lin.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/lin.h
+++ astropy-4.2.1/cextern/wcslib/C/lin.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: lin.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: lin.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -44,8 +41,8 @@
 * like a C++ class but with no encapsulation.
 *
 * Six routines, linini(), lininit(), lindis(), lindist() lincpy(), and
-* linfree() are provided to manage the linprm struct, and another, linprt(),
-* prints its contents.
+* linfree() are provided to manage the linprm struct, linsize() computes its
+* total size including allocated memory, and linprt() prints its contents.
 *
 * linperr() prints the error message(s) (if any) stored in a linprm struct,
 * and the disprm structs that it may contain.
@@ -225,6 +222,35 @@
 *                         1: Null linprm pointer passed.
 *
 *
+* linsize() - Compute the size of a linprm struct
+* -----------------------------------------------
+* linsize() computes the full size of a linprm struct, including allocated
+* memory.
+*
+* Given:
+*   lin       const struct linprm*
+*                       Linear transformation parameters.
+*
+*                       If NULL, the base size of the struct and the allocated
+*                       size are both set to zero.
+*
+* Returned:
+*   sizes     int[2]    The first element is the base size of the struct as
+*                       returned by sizeof(struct linprm).  The second element
+*                       is the total allocated size, in bytes, assuming that
+*                       the allocation was done by linini().  This figure
+*                       includes memory allocated for members of constituent
+*                       structs, such as linprm::dispre.
+*
+*                       It is not an error for the struct not to have been set
+*                       up via linset(), which normally results in additional
+*                       memory allocation.
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*
+*
 * linprt() - Print routine for the linprm struct
 * ----------------------------------------------
 * linprt() prints the contents of a linprm struct using wcsprintf().  Mainly
@@ -619,44 +645,44 @@ extern "C" {
 extern const char *lin_errmsg[];
 
 enum lin_errmsg_enum {
-  LINERR_SUCCESS      = 0,	/* Success. */
-  LINERR_NULL_POINTER = 1,	/* Null linprm pointer passed. */
-  LINERR_MEMORY       = 2,	/* Memory allocation failed. */
-  LINERR_SINGULAR_MTX = 3,	/* PCi_ja matrix is singular. */
-  LINERR_DISTORT_INIT = 4,	/* Failed to initialise distortions. */
-  LINERR_DISTORT      = 5,	/* Distort error. */
-  LINERR_DEDISTORT    = 6	/* De-distort error. */
+  LINERR_SUCCESS      = 0,	// Success.
+  LINERR_NULL_POINTER = 1,	// Null linprm pointer passed.
+  LINERR_MEMORY       = 2,	// Memory allocation failed.
+  LINERR_SINGULAR_MTX = 3,	// PCi_ja matrix is singular.
+  LINERR_DISTORT_INIT = 4,	// Failed to initialise distortions.
+  LINERR_DISTORT      = 5,	// Distort error.
+  LINERR_DEDISTORT    = 6	// De-distort error.
 };
 
 struct linprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  int naxis;			/* The number of axes, given by NAXIS.      */
-  double *crpix;		/* CRPIXja keywords for each pixel axis.    */
-  double *pc;			/* PCi_ja  linear transformation matrix.    */
-  double *cdelt;		/* CDELTia keywords for each coord axis.    */
-  struct disprm *dispre;	/* Prior   distortion parameters, if any.   */
-  struct disprm *disseq;	/* Sequent distortion parameters, if any.   */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  double *piximg;		/* Product of CDELTia and PCi_ja matrices.  */
-  double *imgpix;		/* Inverse of the piximg matrix.            */
-  int    i_naxis;		/* Dimension of piximg and imgpix.          */
-  int    unity;			/* True if the PCi_ja matrix is unity.      */
-  int    affine;		/* True if there are no distortions.        */
-  int    simple;		/* True if unity and no distortions.        */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  int naxis;			// The number of axes, given by NAXIS.
+  double *crpix;		// CRPIXja keywords for each pixel axis.
+  double *pc;			// PCi_ja  linear transformation matrix.
+  double *cdelt;		// CDELTia keywords for each coord axis.
+  struct disprm *dispre;	// Prior   distortion parameters, if any.
+  struct disprm *disseq;	// Sequent distortion parameters, if any.
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  double *piximg;		// Product of CDELTia and PCi_ja matrices.
+  double *imgpix;		// Inverse of the piximg matrix.
+  int    i_naxis;		// Dimension of piximg and imgpix.
+  int    unity;			// True if the PCi_ja matrix is unity.
+  int    affine;		// True if there are no distortions.
+  int    simple;		// True if unity and no distortions.
 
-  /* Error handling, if enabled.                                            */
-  /*------------------------------------------------------------------------*/
+  // Error handling, if enabled.
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private - the remainder are for internal use.                          */
-  /*------------------------------------------------------------------------*/
+  // Private - the remainder are for internal use.
+  //--------------------------------------------------------------------------
   double *tmpcrd;
 
   int    m_flag, m_naxis;
@@ -664,7 +690,7 @@ struct linprm {
   struct disprm *m_dispre, *m_disseq;
 };
 
-/* Size of the linprm struct in int units, used by the Fortran wrappers. */
+// Size of the linprm struct in int units, used by the Fortran wrappers.
 #define LINLEN (sizeof(struct linprm)/sizeof(int))
 
 
@@ -680,6 +706,8 @@ int lincpy(int alloc, const struct linpr
 
 int linfree(struct linprm *lin);
 
+int linsize(const struct linprm *lin, int sizes[2]);
+
 int linprt(const struct linprm *lin);
 
 int linperr(const struct linprm *lin, const char *prefix);
@@ -701,7 +729,7 @@ int linwarp(struct linprm *lin, const do
 int matinv(int n, const double mat[], double inv[]);
 
 
-/* Deprecated. */
+// Deprecated.
 #define linini_errmsg lin_errmsg
 #define lincpy_errmsg lin_errmsg
 #define linfree_errmsg lin_errmsg
@@ -714,4 +742,4 @@ int matinv(int n, const double mat[], do
 }
 #endif
 
-#endif /* WCSLIB_LIN */
+#endif // WCSLIB_LIN
Index: astropy-4.2.1/cextern/wcslib/C/log.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/log.c
+++ astropy-4.2.1/cextern/wcslib/C/log.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,18 +17,16 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: log.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: log.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
 
 #include "log.h"
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *log_errmsg[] = {
   "Success",
   "",
@@ -38,7 +35,7 @@ const char *log_errmsg[] = {
   "One or more of the world coordinates were invalid"};
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int logx2s(
   double crval,
@@ -71,7 +68,7 @@ int logx2s(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int logs2x(
   double crval,
Index: astropy-4.2.1/cextern/wcslib/C/log.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/log.h
+++ astropy-4.2.1/cextern/wcslib/C/log.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: log.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: log.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -144,13 +141,13 @@ extern "C" {
 extern const char *log_errmsg[];
 
 enum log_errmsg_enum {
-  LOGERR_SUCCESS         = 0,	/* Success. */
-  LOGERR_NULL_POINTER    = 1,	/* Null pointer passed. */
-  LOGERR_BAD_LOG_REF_VAL = 2,	/* Invalid log-coordinate reference value. */
-  LOGERR_BAD_X           = 3,	/* One or more of the x coordinates were
-				   invalid. */
-  LOGERR_BAD_WORLD       = 4 	/* One or more of the world coordinates were
-				   invalid. */
+  LOGERR_SUCCESS         = 0,	// Success.
+  LOGERR_NULL_POINTER    = 1,	// Null pointer passed.
+  LOGERR_BAD_LOG_REF_VAL = 2,	// Invalid log-coordinate reference value.
+  LOGERR_BAD_X           = 3,	// One or more of the x coordinates were
+				// invalid.
+  LOGERR_BAD_WORLD       = 4 	// One or more of the world coordinates were
+				// invalid.
 };
 
 int logx2s(double crval, int nx, int sx, int slogc, const double x[],
@@ -164,4 +161,4 @@ int logs2x(double crval, int nlogc, int
 }
 #endif
 
-#endif /* WCSLIB_LOG */
+#endif // WCSLIB_LOG
Index: astropy-4.2.1/cextern/wcslib/C/prj.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/prj.c
+++ astropy-4.2.1/cextern/wcslib/C/prj.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: prj.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: prj.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -38,7 +35,7 @@
 #include "prj.h"
 
 
-/* Projection categories. */
+// Projection categories.
 const int ZENITHAL          = 1;
 const int CYLINDRICAL       = 2;
 const int PSEUDOCYLINDRICAL = 3;
@@ -53,7 +50,7 @@ const char prj_categories[9][32] =
   "conventional", "conic", "polyconic", "quadcube", "HEALPix"};
 
 
-/* Projection codes. */
+// Projection codes.
 const int  prj_ncode = 28;
 const char prj_codes[28][4] =
   {"AZP", "SZP", "TAN", "STG", "SIN", "ARC", "ZPN", "ZEA", "AIR", "CYP",
@@ -90,7 +87,7 @@ const int HPX = 801;
 const int XPH = 802;
 
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *prj_errmsg[] = {
   "Success",
   "Null prjprm pointer passed",
@@ -98,7 +95,7 @@ const char *prj_errmsg[] = {
   "One or more of the (x,y) coordinates were invalid",
   "One or more of the (phi,theta) coordinates were invalid"};
 
-/* Convenience macros for generating common error messages. */
+// Convenience macros for generating common error messages.
 #define PRJERR_BAD_PARAM_SET(function) \
   wcserr_set(&(prj->err), PRJERR_BAD_PARAM, function, __FILE__, __LINE__, \
     "Invalid parameters for %s projection", prj->name);
@@ -124,6 +121,8 @@ const char *prj_errmsg[] = {
 * prjfree frees any memory that may have been allocated to store an error
 *        message in the prjprm struct.
 *
+* prjsize computed the size of a prjprm struct.
+*
 * prjprt prints the contents of a prjprm struct.
 *
 * prjbchk performs bounds checking on the native coordinates returned by the
@@ -184,7 +183,7 @@ int prjini(struct prjprm *prj)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjfree(struct prjprm *prj)
 
@@ -196,7 +195,32 @@ int prjfree(struct prjprm *prj)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
+
+int prjsize(const struct prjprm *prj, int sizes[2])
+
+{
+  if (prj == 0x0) {
+    sizes[0] = sizes[1] = 0;
+    return PRJERR_SUCCESS;
+  }
+
+  // Base size, in bytes.
+  sizes[0] = sizeof(struct prjprm);
+
+  // Total size of allocated memory, in bytes.
+  sizes[1] = 0;
+
+  int exsizes[2];
+
+  // prjprm::err.
+  wcserr_size(prj->err, exsizes);
+  sizes[1] += exsizes[0] + exsizes[1];
+
+  return PRJERR_SUCCESS;
+}
+
+//----------------------------------------------------------------------------
 
 int prjprt(const struct prjprm *prj)
 
@@ -284,7 +308,7 @@ int prjprt(const struct prjprm *prj)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjperr(const struct prjprm *prj, const char *prefix)
 
@@ -298,7 +322,7 @@ int prjperr(const struct prjprm *prj, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjbchk(
   double tol,
@@ -319,7 +343,7 @@ int prjbchk(
   statp  = stat;
   for (itheta = 0; itheta < ntheta; itheta++) {
     for (iphi = 0; iphi < nphi; iphi++, phip += spt, thetap += spt, statp++) {
-      /* Skip values already marked as illegal. */
+      // Skip values already marked as illegal.
       if (*statp == 0) {
         if (*phip < -180.0) {
           if (*phip < -180.0-tol) {
@@ -359,7 +383,7 @@ int prjbchk(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjset(struct prjprm *prj)
 
@@ -372,7 +396,7 @@ int prjset(struct prjprm *prj)
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   err = &(prj->err);
 
-  /* Invoke the relevant initialization routine. */
+  // Invoke the relevant initialization routine.
   prj->code[3] = '\0';
   if (strcmp(prj->code, "AZP") == 0) {
     status = azpset(prj);
@@ -431,7 +455,7 @@ int prjset(struct prjprm *prj)
   } else if (strcmp(prj->code, "XPH") == 0) {
     status = xphset(prj);
   } else {
-    /* Unrecognized projection code. */
+    // Unrecognized projection code.
     status = wcserr_set(WCSERR_SET(PRJERR_BAD_PARAM),
                "Unrecognized projection code '%s'", prj->code);
   }
@@ -439,7 +463,7 @@ int prjset(struct prjprm *prj)
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjx2s(
   struct prjprm *prj,
@@ -456,7 +480,7 @@ int prjx2s(
 {
   int status;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag == 0) {
     if ((status = prjset(prj))) return status;
@@ -465,7 +489,7 @@ int prjx2s(
   return prj->prjx2s(prj, nx, ny, sxy, spt, x, y, phi, theta, stat);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjs2x(
   struct prjprm *prj,
@@ -482,7 +506,7 @@ int prjs2x(
 {
   int status;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag == 0) {
     if ((status = prjset(prj))) return status;
@@ -511,7 +535,7 @@ int prjoff(
   prj->y0 = 0.0;
 
   if (undefined(prj->phi0) || undefined(prj->theta0)) {
-    /* Set both to the projection-specific default if either undefined. */
+    // Set both to the projection-specific default if either undefined.
     prj->phi0   = phi0;
     prj->theta0 = theta0;
 
@@ -607,7 +631,7 @@ int azpset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int azpx2s(
   struct prjprm *prj,
@@ -630,7 +654,7 @@ int azpx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AZP) {
     if ((status = azpset(prj))) return status;
@@ -648,7 +672,7 @@ int azpx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -663,7 +687,7 @@ int azpx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -718,7 +742,7 @@ int azpx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("azpx2s");
   }
@@ -726,7 +750,7 @@ int azpx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int azps2x(
   struct prjprm *prj,
@@ -748,7 +772,7 @@ int azps2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AZP) {
     if ((status = azpset(prj))) return status;
@@ -766,7 +790,7 @@ int azps2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -784,7 +808,7 @@ int azps2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -805,16 +829,16 @@ int azps2x(
       } else {
         r = prj->w[0]*costhe/t;
 
-        /* Bounds checking. */
+        // Bounds checking.
         istat = 0;
         if (prj->bounds&1) {
           if (*thetap < prj->w[5]) {
-            /* Overlap. */
+            // Overlap.
             istat = 1;
             if (!status) status = PRJERR_BAD_WORLD_SET("azps2x");
 
           } else if (prj->w[7] > 0.0) {
-            /* Divergence. */
+            // Divergence.
             t = prj->pv[1] / sqrt(1.0 + s*s);
 
             if (fabs(t) <= 1.0) {
@@ -926,7 +950,7 @@ int szpset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int szpx2s(
   struct prjprm *prj,
@@ -949,7 +973,7 @@ int szpx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SZP) {
     if ((status = szpset(prj))) return status;
@@ -967,7 +991,7 @@ int szpx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -982,7 +1006,7 @@ int szpx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -999,7 +1023,7 @@ int szpx2s(
       xy = xr*x1 + yr*y1;
 
       if (r2 < 1.0e-10) {
-        /* Use small angle formula. */
+        // Use small angle formula.
         z = r2/2.0;
         *thetap = 90.0 - R2D*sqrt(r2/(1.0 + xy));
 
@@ -1010,7 +1034,7 @@ int szpx2s(
         c = r2 - xy - xy + t - 1.0;
         d = b*b - a*c;
 
-        /* Check for a solution. */
+        // Check for a solution.
         if (d < 0.0) {
           *phip = 0.0;
           *thetap = 0.0;
@@ -1020,7 +1044,7 @@ int szpx2s(
         }
         d = sqrt(d);
 
-        /* Choose solution closest to pole. */
+        // Choose solution closest to pole.
         sinth1 = (-b + d)/a;
         sinth2 = (-b - d)/a;
         sinthe = (sinth1 > sinth2) ? sinth1 : sinth2;
@@ -1057,7 +1081,7 @@ int szpx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("szpx2s");
   }
@@ -1065,7 +1089,7 @@ int szpx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int szps2x(
   struct prjprm *prj,
@@ -1087,7 +1111,7 @@ int szps2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SZP) {
     if ((status = szpset(prj))) return status;
@@ -1105,7 +1129,7 @@ int szps2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -1123,7 +1147,7 @@ int szps2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -1147,16 +1171,16 @@ int szps2x(
       v = prj->w[5]*s/t + prj->y0;
 
       for (iphi = 0; iphi < mphi; iphi++, xp += sxy, yp += sxy) {
-        /* Bounds checking. */
+        // Bounds checking.
         istat = 0;
         if (prj->bounds&1) {
           if (*thetap < prj->w[8]) {
-            /* Divergence. */
+            // Divergence.
             istat = 1;
             if (!status) status = PRJERR_BAD_WORLD_SET("szps2x");
 
           } else if (fabs(prj->pv[1]) > 1.0) {
-            /* Overlap. */
+            // Overlap.
             s = prj->w[1]*(*xp) - prj->w[2]*(*yp);
             t = 1.0/sqrt(prj->w[7] + s*s);
 
@@ -1230,7 +1254,7 @@ int tanset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tanx2s(
   struct prjprm *prj,
@@ -1252,7 +1276,7 @@ int tanx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != TAN) {
     if ((status = tanset(prj))) return status;
@@ -1270,7 +1294,7 @@ int tanx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -1285,7 +1309,7 @@ int tanx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -1310,7 +1334,7 @@ int tanx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("tanx2s");
   }
@@ -1318,7 +1342,7 @@ int tanx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tans2x(
   struct prjprm *prj,
@@ -1340,7 +1364,7 @@ int tans2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != TAN) {
     if ((status = tanset(prj))) return status;
@@ -1358,7 +1382,7 @@ int tans2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -1376,7 +1400,7 @@ int tans2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -1394,7 +1418,7 @@ int tans2x(
     } else {
       r =  prj->r0*cosd(*thetap)/s;
 
-      /* Bounds checking. */
+      // Bounds checking.
       istat = 0;
       if (prj->bounds&1) {
         if (s < 0.0) {
@@ -1465,7 +1489,7 @@ int stgset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int stgx2s(
   struct prjprm *prj,
@@ -1487,7 +1511,7 @@ int stgx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != STG) {
     if ((status = stgset(prj))) return status;
@@ -1503,7 +1527,7 @@ int stgx2s(
   }
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -1518,7 +1542,7 @@ int stgx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -1545,7 +1569,7 @@ int stgx2s(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int stgs2x(
   struct prjprm *prj,
@@ -1567,7 +1591,7 @@ int stgs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != STG) {
     if ((status = stgset(prj))) return status;
@@ -1585,7 +1609,7 @@ int stgs2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -1603,7 +1627,7 @@ int stgs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -1688,7 +1712,7 @@ int sinset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sinx2s(
   struct prjprm *prj,
@@ -1712,7 +1736,7 @@ int sinx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SIN) {
     if ((status = sinset(prj))) return status;
@@ -1733,7 +1757,7 @@ int sinx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -1748,7 +1772,7 @@ int sinx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -1758,12 +1782,12 @@ int sinx2s(
     y02 = y0*y0;
 
     for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
-      /* Compute intermediaries. */
+      // Compute intermediaries.
       x0 = *phip;
       r2 = x0*x0 + y02;
 
       if (prj->w[1] == 0.0) {
-        /* Orthographic projection. */
+        // Orthographic projection.
         if (r2 != 0.0) {
           *phip = atan2d(x0, -y0);
         } else {
@@ -1781,11 +1805,11 @@ int sinx2s(
         }
 
       } else {
-        /* "Synthesis" projection. */
+        // "Synthesis" projection.
         xy = x0*xi + y0*eta;
 
         if (r2 < 1.0e-10) {
-          /* Use small angle formula. */
+          // Use small angle formula.
           z = r2/2.0;
           *thetap = 90.0 - R2D*sqrt(r2/(1.0 + xy));
 
@@ -1795,7 +1819,7 @@ int sinx2s(
           c = r2 - xy - xy + prj->w[3];
           d = b*b - a*c;
 
-          /* Check for a solution. */
+          // Check for a solution.
           if (d < 0.0) {
             *phip = 0.0;
             *thetap = 0.0;
@@ -1805,7 +1829,7 @@ int sinx2s(
           }
           d = sqrt(d);
 
-          /* Choose solution closest to pole. */
+          // Choose solution closest to pole.
           sinth1 = (-b + d)/a;
           sinth2 = (-b - d)/a;
           sinthe = (sinth1 > sinth2) ? sinth1 : sinth2;
@@ -1849,7 +1873,7 @@ int sinx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("sinx2s");
   }
@@ -1857,7 +1881,7 @@ int sinx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sins2x(
   struct prjprm *prj,
@@ -1879,7 +1903,7 @@ int sins2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SIN) {
     if ((status = sinset(prj))) return status;
@@ -1897,7 +1921,7 @@ int sins2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -1915,7 +1939,7 @@ int sins2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -1936,7 +1960,7 @@ int sins2x(
     r = prj->r0*costhe;
 
     if (prj->w[1] == 0.0) {
-      /* Orthographic projection. */
+      // Orthographic projection.
       istat = 0;
       if (prj->bounds&1) {
         if (*thetap < 0.0) {
@@ -1952,7 +1976,7 @@ int sins2x(
       }
 
     } else {
-      /* "Synthesis" projection. */
+      // "Synthesis" projection.
       z *= prj->r0;
       z1 = prj->pv[1]*z - prj->x0;
       z2 = prj->pv[2]*z - prj->y0;
@@ -2028,7 +2052,7 @@ int arcset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int arcx2s(
   struct prjprm *prj,
@@ -2050,7 +2074,7 @@ int arcx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ARC) {
     if ((status = arcset(prj))) return status;
@@ -2068,7 +2092,7 @@ int arcx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -2083,7 +2107,7 @@ int arcx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -2109,7 +2133,7 @@ int arcx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("arcx2s");
   }
@@ -2117,7 +2141,7 @@ int arcx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int arcs2x(
   struct prjprm *prj,
@@ -2139,7 +2163,7 @@ int arcs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ARC) {
     if ((status = arcset(prj))) return status;
@@ -2155,7 +2179,7 @@ int arcs2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -2173,7 +2197,7 @@ int arcs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -2240,7 +2264,7 @@ int zpnset(struct prjprm *prj)
   prj->global    = 0;
   prj->divergent = 0;
 
-  /* Find the highest non-zero coefficient. */
+  // Find the highest non-zero coefficient.
   for (k = PVN-1; k >= 0 && prj->pv[k] == 0.0; k--);
   if (k < 0) {
     return PRJERR_BAD_PARAM_SET("zpnset");
@@ -2249,18 +2273,18 @@ int zpnset(struct prjprm *prj)
   prj->n = k;
 
   if (k < 2) {
-    /* No point of inflection. */
+    // No point of inflection.
     prj->w[0] = PI;
 
   } else {
-    /* Find the point of inflection closest to the pole. */
+    // Find the point of inflection closest to the pole.
     zd1 = 0.0;
     d1  = prj->pv[1];
     if (d1 <= 0.0) {
       return PRJERR_BAD_PARAM_SET("zpnset");
     }
 
-    /* Find the point where the derivative first goes negative. */
+    // Find the point where the derivative first goes negative.
     for (j = 0; j < 180; j++) {
       zd2 = j*D2R;
       d2  = 0.0;
@@ -2274,11 +2298,11 @@ int zpnset(struct prjprm *prj)
     }
 
     if (j == 180) {
-      /* No negative derivative -> no point of inflection. */
+      // No negative derivative -> no point of inflection.
       zd = PI;
       prj->global = 1;
     } else {
-      /* Find where the derivative is zero. */
+      // Find where the derivative is zero.
       for (j = 1; j <= 10; j++) {
         zd = zd1 - d1*(zd2-zd1)/(d2-d1);
 
@@ -2313,7 +2337,7 @@ int zpnset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int zpnx2s(
   struct prjprm *prj,
@@ -2336,7 +2360,7 @@ int zpnx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ZPN) {
     if ((status = zpnset(prj))) return status;
@@ -2356,7 +2380,7 @@ int zpnx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -2371,7 +2395,7 @@ int zpnx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -2391,15 +2415,15 @@ int zpnx2s(
       }
 
       if (k < 1) {
-        /* Constant - no solution. */
+        // Constant - no solution.
         return PRJERR_BAD_PARAM_SET("zpnx2s");
 
       } else if (k == 1) {
-        /* Linear. */
+        // Linear.
         zd = (r - prj->pv[0])/prj->pv[1];
 
       } else if (k == 2) {
-        /* Quadratic. */
+        // Quadratic.
         a = prj->pv[2];
         b = prj->pv[1];
         c = prj->pv[0] - r;
@@ -2413,7 +2437,7 @@ int zpnx2s(
         }
         d = sqrt(d);
 
-        /* Choose solution closest to pole. */
+        // Choose solution closest to pole.
         zd1 = (-b + d)/(2.0*a);
         zd2 = (-b - d)/(2.0*a);
         zd  = (zd1<zd2) ? zd1 : zd2;
@@ -2436,7 +2460,7 @@ int zpnx2s(
           zd = PI;
         }
       } else {
-        /* Higher order - solve iteratively. */
+        // Higher order - solve iteratively.
         zd1 = 0.0;
         r1  = prj->pv[0];
         zd2 = prj->w[0];
@@ -2459,7 +2483,7 @@ int zpnx2s(
           }
           zd = zd2;
         } else {
-          /* Dissect the interval. */
+          // Dissect the interval.
           for (j = 0; j < 100; j++) {
             lambda = (r2 - r)/(r2 - r1);
             if (lambda < 0.1) {
@@ -2496,7 +2520,7 @@ int zpnx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("zpnx2s");
   }
@@ -2504,7 +2528,7 @@ int zpnx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int zpns2x(
   struct prjprm *prj,
@@ -2526,7 +2550,7 @@ int zpns2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ZPN) {
     if ((status = zpnset(prj))) return status;
@@ -2544,7 +2568,7 @@ int zpns2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -2562,7 +2586,7 @@ int zpns2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -2576,7 +2600,7 @@ int zpns2x(
     }
     r *= prj->r0;
 
-    /* Bounds checking. */
+    // Bounds checking.
     istat = 0;
     if (prj->bounds&1) {
       if (s > prj->w[0]) {
@@ -2646,7 +2670,7 @@ int zeaset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int zeax2s(
   struct prjprm *prj,
@@ -2669,7 +2693,7 @@ int zeax2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ZEA) {
     if ((status = zeaset(prj))) return status;
@@ -2687,7 +2711,7 @@ int zeax2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -2702,7 +2726,7 @@ int zeax2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -2740,7 +2764,7 @@ int zeax2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("zeax2s");
   }
@@ -2748,7 +2772,7 @@ int zeax2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int zeas2x(
   struct prjprm *prj,
@@ -2770,7 +2794,7 @@ int zeas2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ZEA) {
     if ((status = zeaset(prj))) return status;
@@ -2786,7 +2810,7 @@ int zeas2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -2804,7 +2828,7 @@ int zeas2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -2897,7 +2921,7 @@ int airset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int airx2s(
   struct prjprm *prj,
@@ -2920,7 +2944,7 @@ int airx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AIR) {
     if ((status = airset(prj))) return status;
@@ -2938,7 +2962,7 @@ int airx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -2953,7 +2977,7 @@ int airx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -2978,7 +3002,7 @@ int airx2s(
       } else if (r < prj->w[5]) {
         xi = r*prj->w[6];
       } else {
-        /* Find a solution interval. */
+        // Find a solution interval.
         x1 = x2 = 1.0;
         r1 = r2 = 0.0;
         for (k = 0; k < 30; k++) {
@@ -2998,7 +3022,7 @@ int airx2s(
         }
 
         for (k = 0; k < 100; k++) {
-          /* Weighted division of the interval. */
+          // Weighted division of the interval.
           lambda = (r2-r)/(r2-r1);
           if (lambda < 0.1) {
             lambda = 0.1;
@@ -3036,7 +3060,7 @@ int airx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("airx2s");
   }
@@ -3044,7 +3068,7 @@ int airx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int airs2x(
   struct prjprm *prj,
@@ -3066,7 +3090,7 @@ int airs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AIR) {
     if ((status = airset(prj))) return status;
@@ -3084,7 +3108,7 @@ int airs2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -3102,7 +3126,7 @@ int airs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -3222,7 +3246,7 @@ int cypset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cypx2s(
   struct prjprm *prj,
@@ -3244,7 +3268,7 @@ int cypx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CYP) {
     if ((status = cypset(prj))) return status;
@@ -3262,7 +3286,7 @@ int cypx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -3277,7 +3301,7 @@ int cypx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   thetap = theta;
   statp = stat;
@@ -3292,7 +3316,7 @@ int cypx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("cypx2s");
   }
@@ -3300,7 +3324,7 @@ int cypx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cyps2x(
   struct prjprm *prj,
@@ -3322,7 +3346,7 @@ int cyps2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CYP) {
     if ((status = cypset(prj))) return status;
@@ -3340,7 +3364,7 @@ int cyps2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -3355,7 +3379,7 @@ int cyps2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   yp = y;
   statp = stat;
@@ -3450,7 +3474,7 @@ int ceaset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int ceax2s(
   struct prjprm *prj,
@@ -3473,7 +3497,7 @@ int ceax2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CEA) {
     if ((status = ceaset(prj))) return status;
@@ -3491,7 +3515,7 @@ int ceax2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -3506,7 +3530,7 @@ int ceax2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   thetap = theta;
   statp = stat;
@@ -3533,7 +3557,7 @@ int ceax2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("ceax2s");
   }
@@ -3541,7 +3565,7 @@ int ceax2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int ceas2x(
   struct prjprm *prj,
@@ -3563,7 +3587,7 @@ int ceas2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CEA) {
     if ((status = ceaset(prj))) return status;
@@ -3579,7 +3603,7 @@ int ceas2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -3594,7 +3618,7 @@ int ceas2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   yp = y;
   statp = stat;
@@ -3661,7 +3685,7 @@ int carset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int carx2s(
   struct prjprm *prj,
@@ -3683,7 +3707,7 @@ int carx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CAR) {
     if ((status = carset(prj))) return status;
@@ -3701,7 +3725,7 @@ int carx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -3716,7 +3740,7 @@ int carx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   thetap = theta;
   statp = stat;
@@ -3730,7 +3754,7 @@ int carx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("carx2s");
   }
@@ -3738,7 +3762,7 @@ int carx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cars2x(
   struct prjprm *prj,
@@ -3760,7 +3784,7 @@ int cars2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CAR) {
     if ((status = carset(prj))) return status;
@@ -3776,7 +3800,7 @@ int cars2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -3791,7 +3815,7 @@ int cars2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   yp = y;
   statp = stat;
@@ -3858,7 +3882,7 @@ int merset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int merx2s(
   struct prjprm *prj,
@@ -3880,7 +3904,7 @@ int merx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != MER) {
     if ((status = merset(prj))) return status;
@@ -3898,7 +3922,7 @@ int merx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -3913,7 +3937,7 @@ int merx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   thetap = theta;
   statp  = stat;
@@ -3927,7 +3951,7 @@ int merx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("merx2s");
   }
@@ -3935,7 +3959,7 @@ int merx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int mers2x(
   struct prjprm *prj,
@@ -3957,7 +3981,7 @@ int mers2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != MER) {
     if ((status = merset(prj))) return status;
@@ -3975,7 +3999,7 @@ int mers2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -3990,7 +4014,7 @@ int mers2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   yp = y;
   statp = stat;
@@ -4065,7 +4089,7 @@ int sflset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sflx2s(
   struct prjprm *prj,
@@ -4087,7 +4111,7 @@ int sflx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SFL) {
     if ((status = sflset(prj))) return status;
@@ -4105,7 +4129,7 @@ int sflx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -4120,7 +4144,7 @@ int sflx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -4147,7 +4171,7 @@ int sflx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-12, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("sflx2s");
   }
@@ -4155,7 +4179,7 @@ int sflx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sfls2x(
   struct prjprm *prj,
@@ -4177,7 +4201,7 @@ int sfls2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SFL) {
     if ((status = sflset(prj))) return status;
@@ -4193,7 +4217,7 @@ int sfls2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -4208,7 +4232,7 @@ int sfls2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -4284,7 +4308,7 @@ int parset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int parx2s(
   struct prjprm *prj,
@@ -4307,7 +4331,7 @@ int parx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != PAR) {
     if ((status = parset(prj))) return status;
@@ -4325,7 +4349,7 @@ int parx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -4345,7 +4369,7 @@ int parx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -4363,7 +4387,7 @@ int parx2s(
     } else {
       s = 1.0 - 4.0*r*r;
       if (s == 0.0) {
-        /* Deferred test. */
+        // Deferred test.
         istat = -1;
       } else {
         s = 1.0/s;
@@ -4390,7 +4414,7 @@ int parx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-12, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("parx2s");
   }
@@ -4398,7 +4422,7 @@ int parx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int pars2x(
   struct prjprm *prj,
@@ -4420,7 +4444,7 @@ int pars2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != PAR) {
     if ((status = parset(prj))) return status;
@@ -4436,7 +4460,7 @@ int pars2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -4451,7 +4475,7 @@ int pars2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -4523,7 +4547,7 @@ int molset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int molx2s(
   struct prjprm *prj,
@@ -4546,7 +4570,7 @@ int molx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != MOL) {
     if ((status = molset(prj))) return status;
@@ -4564,7 +4588,7 @@ int molx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -4584,7 +4608,7 @@ int molx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -4600,7 +4624,7 @@ int molx2s(
         istat = 1;
         if (!status) status = PRJERR_BAD_PIX_SET("molx2s");
       } else {
-        /* OK if fabs(x) < tol whence phi = 0.0. */
+        // OK if fabs(x) < tol whence phi = 0.0.
         istat = -1;
       }
 
@@ -4655,7 +4679,7 @@ int molx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-11, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("molx2s");
   }
@@ -4663,7 +4687,7 @@ int molx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int mols2x(
   struct prjprm *prj,
@@ -4686,7 +4710,7 @@ int mols2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != MOL) {
     if ((status = molset(prj))) return status;
@@ -4702,7 +4726,7 @@ int mols2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -4717,7 +4741,7 @@ int mols2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -4815,7 +4839,7 @@ int aitset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int aitx2s(
   struct prjprm *prj,
@@ -4838,7 +4862,7 @@ int aitx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AIT) {
     if ((status = aitset(prj))) return status;
@@ -4856,7 +4880,7 @@ int aitx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -4876,7 +4900,7 @@ int aitx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -4925,7 +4949,7 @@ int aitx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("aitx2s");
   }
@@ -4933,7 +4957,7 @@ int aitx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int aits2x(
   struct prjprm *prj,
@@ -4955,7 +4979,7 @@ int aits2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AIT) {
     if ((status = aitset(prj))) return status;
@@ -4971,7 +4995,7 @@ int aits2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -4990,7 +5014,7 @@ int aits2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -5083,7 +5107,7 @@ int copset(struct prjprm *prj)
   return prjoff(prj, 0.0, prj->pv[1]);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int copx2s(
   struct prjprm *prj,
@@ -5104,7 +5128,7 @@ int copx2s(
   register const double *xp, *yp;
   register double *phip, *thetap;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COP) {
     if ((status = copset(prj))) return status;
@@ -5122,7 +5146,7 @@ int copx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -5137,7 +5161,7 @@ int copx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -5165,7 +5189,7 @@ int copx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("copx2s");
   }
@@ -5173,7 +5197,7 @@ int copx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cops2x(
   struct prjprm *prj,
@@ -5194,7 +5218,7 @@ int cops2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COP) {
     if ((status = copset(prj))) return status;
@@ -5212,7 +5236,7 @@ int cops2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -5231,7 +5255,7 @@ int cops2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -5243,16 +5267,16 @@ int cops2x(
 
     istat = 0;
     if (s == 0.0) {
-      /* Latitude of divergence. */
+      // Latitude of divergence.
       r = 0.0;
       istat = 1;
       if (!status) status = PRJERR_BAD_WORLD_SET("cops2x");
 
     } else if (fabs(*thetap) == 90.0) {
-      /* Return an exact value at the poles. */
+      // Return an exact value at the poles.
       r = 0.0;
 
-      /* Bounds checking. */
+      // Bounds checking.
       if (prj->bounds&1) {
         if ((*thetap < 0.0) != (prj->pv[1] < 0.0)) {
           istat = 1;
@@ -5263,7 +5287,7 @@ int cops2x(
     } else {
       r = prj->w[2] - prj->w[3]*sind(t)/s;
 
-      /* Bounds checking. */
+      // Bounds checking.
       if (prj->bounds&1) {
         if (r*prj->w[0] < 0.0) {
           istat = 1;
@@ -5363,7 +5387,7 @@ int coeset(struct prjprm *prj)
   return prjoff(prj, 0.0, prj->pv[1]);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int coex2s(
   struct prjprm *prj,
@@ -5385,7 +5409,7 @@ int coex2s(
   register const double *xp, *yp;
   register double *phip, *thetap;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COE) {
     if ((status = coeset(prj))) return status;
@@ -5403,7 +5427,7 @@ int coex2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -5418,7 +5442,7 @@ int coex2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -5466,7 +5490,7 @@ int coex2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("coex2s");
   }
@@ -5474,7 +5498,7 @@ int coex2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int coes2x(
   struct prjprm *prj,
@@ -5495,7 +5519,7 @@ int coes2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COE) {
     if ((status = coeset(prj))) return status;
@@ -5511,7 +5535,7 @@ int coes2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -5530,7 +5554,7 @@ int coes2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -5622,7 +5646,7 @@ int codset(struct prjprm *prj)
   return prjoff(prj, 0.0, prj->pv[1]);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int codx2s(
   struct prjprm *prj,
@@ -5643,7 +5667,7 @@ int codx2s(
   register const double *xp, *yp;
   register double *phip, *thetap;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COD) {
     if ((status = codset(prj))) return status;
@@ -5661,7 +5685,7 @@ int codx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -5676,7 +5700,7 @@ int codx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -5704,7 +5728,7 @@ int codx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("codx2s");
   }
@@ -5712,7 +5736,7 @@ int codx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cods2x(
   struct prjprm *prj,
@@ -5733,7 +5757,7 @@ int cods2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COD) {
     if ((status = codset(prj))) return status;
@@ -5749,7 +5773,7 @@ int cods2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -5768,7 +5792,7 @@ int cods2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -5873,7 +5897,7 @@ int cooset(struct prjprm *prj)
   return prjoff(prj, 0.0, prj->pv[1]);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int coox2s(
   struct prjprm *prj,
@@ -5894,7 +5918,7 @@ int coox2s(
   register const double *xp, *yp;
   register double *phip, *thetap;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COO) {
     if ((status = cooset(prj))) return status;
@@ -5912,7 +5936,7 @@ int coox2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -5927,7 +5951,7 @@ int coox2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -5968,7 +5992,7 @@ int coox2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("coox2s");
   }
@@ -5976,7 +6000,7 @@ int coox2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int coos2x(
   struct prjprm *prj,
@@ -5997,7 +6021,7 @@ int coos2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COO) {
     if ((status = cooset(prj))) return status;
@@ -6015,7 +6039,7 @@ int coos2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -6034,7 +6058,7 @@ int coos2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -6099,7 +6123,7 @@ int bonset(struct prjprm *prj)
   }
 
   if (prj->pv[1] == 0.0) {
-    /* Sanson-Flamsteed. */
+    // Sanson-Flamsteed.
     return sflset(prj);
   }
 
@@ -6126,7 +6150,7 @@ int bonset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int bonx2s(
   struct prjprm *prj,
@@ -6148,10 +6172,10 @@ int bonx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->pv[1] == 0.0) {
-    /* Sanson-Flamsteed. */
+    // Sanson-Flamsteed.
     return sflx2s(prj, nx, ny, sxy, spt, x, y, phi, theta, stat);
   }
 
@@ -6171,7 +6195,7 @@ int bonx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -6186,7 +6210,7 @@ int bonx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -6222,7 +6246,7 @@ int bonx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-11, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("bonx2s");
   }
@@ -6230,7 +6254,7 @@ int bonx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int bons2x(
   struct prjprm *prj,
@@ -6251,10 +6275,10 @@ int bons2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->pv[1] == 0.0) {
-    /* Sanson-Flamsteed. */
+    // Sanson-Flamsteed.
     return sfls2x(prj, nphi, ntheta, spt, sxy, phi, theta, x, y, stat);
   }
 
@@ -6274,7 +6298,7 @@ int bons2x(
   y0 = prj->y0 - prj->w[2];
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -6289,7 +6313,7 @@ int bons2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -6366,7 +6390,7 @@ int pcoset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int pcox2s(
   struct prjprm *prj,
@@ -6390,7 +6414,7 @@ int pcox2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != PCO) {
     if ((status = pcoset(prj))) return status;
@@ -6408,7 +6432,7 @@ int pcox2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -6423,7 +6447,7 @@ int pcox2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -6445,23 +6469,23 @@ int pcox2s(
 
       } else {
         if (w < 1.0e-4) {
-          /* To avoid cot(theta) blowing up near theta == 0. */
+          // To avoid cot(theta) blowing up near theta == 0.
           the    = yj / (prj->w[0] + prj->w[3]*xj*xj);
           ymthe  = yj - prj->w[0]*the;
           tanthe = tand(the);
 
         } else {
-          /* Iterative solution using weighted division of the interval. */
+          // Iterative solution using weighted division of the interval.
           thepos = yj / prj->w[0];
           theneg = 0.0;
 
-          /* Setting fneg = -fpos halves the interval in the first iter. */
+          // Setting fneg = -fpos halves the interval in the first iter.
           xx = xj*xj;
           fpos  =  xx;
           fneg  = -xx;
 
           for (k = 0; k < 64; k++) {
-            /* Weighted division of the interval. */
+            // Weighted division of the interval.
             lambda = fpos/(fpos-fneg);
             if (lambda < 0.1) {
               lambda = 0.1;
@@ -6470,16 +6494,16 @@ int pcox2s(
             }
             the = thepos - lambda*(thepos-theneg);
 
-            /* Compute the residue. */
+            // Compute the residue.
             ymthe  = yj - prj->w[0]*the;
             tanthe = tand(the);
             f = xx + ymthe*(ymthe - prj->w[2]/tanthe);
 
-            /* Check for convergence. */
+            // Check for convergence.
             if (fabs(f) < tol) break;
             if (fabs(thepos-theneg) < tol) break;
 
-            /* Redefine the interval. */
+            // Redefine the interval.
             if (f > 0.0) {
               thepos = the;
               fpos = f;
@@ -6506,7 +6530,7 @@ int pcox2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-12, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("pcox2s");
   }
@@ -6514,7 +6538,7 @@ int pcox2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int pcos2x(
   struct prjprm *prj,
@@ -6535,7 +6559,7 @@ int pcos2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != PCO) {
     if ((status = pcoset(prj))) return status;
@@ -6551,7 +6575,7 @@ int pcos2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -6564,7 +6588,7 @@ int pcos2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -6578,7 +6602,7 @@ int pcos2x(
       }
 
     } else if (fabs(*thetap) < 1.0e-4) {
-      /* To avoid cot(theta) blowing up near theta == 0. */
+      // To avoid cot(theta) blowing up near theta == 0.
       for (iphi = 0; iphi < mphi; iphi++, xp += sxy, yp += sxy) {
         *xp = prj->w[0]*(*xp)*cosd(*thetap) - prj->x0;
         *yp = (prj->w[0] + prj->w[3]*(*xp)*(*xp))*(*thetap) - prj->y0;
@@ -6653,7 +6677,7 @@ int tscset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tscx2s(
   struct prjprm *prj,
@@ -6675,7 +6699,7 @@ int tscx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != TSC) {
     if ((status = tscset(prj))) return status;
@@ -6693,7 +6717,7 @@ int tscx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -6708,7 +6732,7 @@ int tscx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -6719,7 +6743,7 @@ int tscx2s(
     for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
       xf = *phip;
 
-      /* Bounds checking. */
+      // Bounds checking.
       if (fabs(xf) <= 1.0) {
         if (fabs(yf) > 3.0) {
           *phip = 0.0;
@@ -6738,42 +6762,42 @@ int tscx2s(
         }
       }
 
-      /* Map negative faces to the other side. */
+      // Map negative faces to the other side.
       if (xf < -1.0) xf += 8.0;
 
-      /* Determine the face. */
+      // Determine the face.
       if (xf > 5.0) {
-        /* face = 4 */
+        // face = 4
         xf = xf - 6.0;
         m  = -1.0/sqrt(1.0 + xf*xf + yf*yf);
         l  = -m*xf;
         n  = -m*yf;
       } else if (xf > 3.0) {
-        /* face = 3 */
+        // face = 3
         xf = xf - 4.0;
         l  = -1.0/sqrt(1.0 + xf*xf + yf*yf);
         m  =  l*xf;
         n  = -l*yf;
       } else if (xf > 1.0) {
-        /* face = 2 */
+        // face = 2
         xf = xf - 2.0;
         m  =  1.0/sqrt(1.0 + xf*xf + yf*yf);
         l  = -m*xf;
         n  =  m*yf;
       } else if (yf > 1.0) {
-        /* face = 0 */
+        // face = 0
         yf = yf - 2.0;
         n  = 1.0/sqrt(1.0 + xf*xf + yf*yf);
         l  = -n*yf;
         m  =  n*xf;
       } else if (yf < -1.0) {
-        /* face = 5 */
+        // face = 5
         yf = yf + 2.0;
         n  = -1.0/sqrt(1.0 + xf*xf + yf*yf);
         l  = -n*yf;
         m  = -n*xf;
       } else {
-        /* face = 1 */
+        // face = 1
         l  =  1.0/sqrt(1.0 + xf*xf + yf*yf);
         m  =  l*xf;
         n  =  l*yf;
@@ -6791,7 +6815,7 @@ int tscx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("tscx2s");
   }
@@ -6799,7 +6823,7 @@ int tscx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tscs2x(
   struct prjprm *prj,
@@ -6821,7 +6845,7 @@ int tscs2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != TSC) {
     if ((status = tscset(prj))) return status;
@@ -6839,7 +6863,7 @@ int tscs2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -6857,7 +6881,7 @@ int tscs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -6925,7 +6949,7 @@ int tscs2x(
         y0 = -2.0;
         break;
       default:
-        /* face == 0 */
+        // face == 0
         xf =  m/zeta;
         yf = -l/zeta;
         x0 =  0.0;
@@ -7009,7 +7033,7 @@ int cscset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cscx2s(
   struct prjprm *prj,
@@ -7060,7 +7084,7 @@ int cscx2s(
   const float p15 =  0.52032238f;
   const float p06 =  0.14381585f;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CSC) {
     if ((status = cscset(prj))) return status;
@@ -7078,7 +7102,7 @@ int cscx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -7093,7 +7117,7 @@ int cscx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -7104,7 +7128,7 @@ int cscx2s(
     for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
       xf = (float)(*phip);
 
-      /* Bounds checking. */
+      // Bounds checking.
       if (fabs((double)xf) <= 1.0) {
         if (fabs((double)yf) > 3.0) {
           *phip = 0.0;
@@ -7123,10 +7147,10 @@ int cscx2s(
         }
       }
 
-      /* Map negative faces to the other side. */
+      // Map negative faces to the other side.
       if (xf < -1.0f) xf += 8.0f;
 
-      /* Determine the face. */
+      // Determine the face.
       if (xf > 5.0f) {
         face = 4;
         xf = xf - 6.0f;
@@ -7201,7 +7225,7 @@ int cscx2s(
         m = -chi*n;
         break;
       default:
-        /* face == 0 */
+        // face == 0
         n =  t;
         l = -psi*n;
         m =  chi*n;
@@ -7220,7 +7244,7 @@ int cscx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("cscx2s");
   }
@@ -7228,7 +7252,7 @@ int cscx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cscs2x(
   struct prjprm *prj,
@@ -7266,7 +7290,7 @@ int cscs2x(
   const float c02 =  0.106959469314f;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CSC) {
     if ((status = cscset(prj))) return status;
@@ -7284,7 +7308,7 @@ int cscs2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -7302,7 +7326,7 @@ int cscs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -7370,7 +7394,7 @@ int cscs2x(
         y0  = -2.0;
         break;
       default:
-        /* face == 0 */
+        // face == 0
         xi  =  m;
         eta = -l;
         x0  =  0.0;
@@ -7386,7 +7410,7 @@ int cscs2x(
       chi2co = 1.0f - chi2;
       psi2co = 1.0f - psi2;
 
-      /* Avoid floating underflows. */
+      // Avoid floating underflows.
       chipsi = (float)fabs((double)(chi*psi));
       chi4   = (chi2 > 1.0e-16f) ? chi2*chi2 : 0.0f;
       psi4   = (psi2 > 1.0e-16f) ? psi2*psi2 : 0.0f;
@@ -7475,7 +7499,7 @@ int qscset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int qscx2s(
   struct prjprm *prj,
@@ -7498,7 +7522,7 @@ int qscx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != QSC) {
     if ((status = qscset(prj))) return status;
@@ -7516,7 +7540,7 @@ int qscx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -7531,7 +7555,7 @@ int qscx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -7542,7 +7566,7 @@ int qscx2s(
     for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
       xf = *phip;
 
-      /* Bounds checking. */
+      // Bounds checking.
       if (fabs(xf) <= 1.0) {
         if (fabs(yf) > 3.0) {
           *phip = 0.0;
@@ -7561,10 +7585,10 @@ int qscx2s(
         }
       }
 
-      /* Map negative faces to the other side. */
+      // Map negative faces to the other side.
       if (xf < -1.0) xf += 8.0;
 
-      /* Determine the face. */
+      // Determine the face.
       if (xf > 5.0) {
         face = 4;
         xf -= 6.0;
@@ -7692,7 +7716,7 @@ int qscx2s(
         }
         break;
       default:
-        /* face == 0 */
+        // face == 0
         n = zeta;
         if (direct) {
           m = w;
@@ -7718,7 +7742,7 @@ int qscx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("qscx2s");
   }
@@ -7726,7 +7750,7 @@ int qscx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int qscs2x(
   struct prjprm *prj,
@@ -7750,7 +7774,7 @@ int qscs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != QSC) {
     if ((status = qscset(prj))) return status;
@@ -7768,7 +7792,7 @@ int qscs2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -7786,7 +7810,7 @@ int qscs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -7836,7 +7860,7 @@ int qscs2x(
         xi  = m;
         eta = n;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (*thetap)*D2R;
           p = atan2(*yp, *xp);
           zeco = (p*p + t*t)/2.0;
@@ -7848,7 +7872,7 @@ int qscs2x(
         xi  = -l;
         eta =  n;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (*thetap)*D2R;
           p = atan2(*yp, *xp) - PI/2.0;
           zeco = (p*p + t*t)/2.0;
@@ -7860,7 +7884,7 @@ int qscs2x(
         xi  = -m;
         eta =  n;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (*thetap)*D2R;
           p = atan2(*yp, *xp);
           p -= copysign(PI, p);
@@ -7873,7 +7897,7 @@ int qscs2x(
         xi  = l;
         eta = n;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (*thetap)*D2R;
           p = atan2(*yp, *xp) + PI/2.0;
           zeco = (p*p + t*t)/2.0;
@@ -7885,7 +7909,7 @@ int qscs2x(
         xi  =  m;
         eta =  l;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (*thetap + 90.0)*D2R;
           zeco = t*t/2.0;
         }
@@ -7893,11 +7917,11 @@ int qscs2x(
         y0 = -2;
          break;
       default:
-        /* face == 0 */
+        // face == 0
         xi  =  m;
         eta = -l;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (90.0 - *thetap)*D2R;
           zeco = t*t/2.0;
         }
@@ -8041,7 +8065,7 @@ int hpxset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int hpxx2s(
   struct prjprm *prj,
@@ -8063,7 +8087,7 @@ int hpxx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != HPX) {
     if ((status = hpxset(prj))) return status;
@@ -8084,20 +8108,20 @@ int hpxx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
   for (ix = 0; ix < nx; ix++, rowoff += spt, xp += sxy) {
     s = prj->w[1] * (*xp + prj->x0);
-    /* x_c for K odd or theta > 0. */
+    // x_c for K odd or theta > 0.
     t = -180.0 + (2.0 * floor((*xp + 180.0) * prj->w[7]) + 1.0) * prj->w[6];
     t = prj->w[1] * (*xp - t);
 
     phip   = phi + rowoff;
     thetap = theta + rowoff;
     for (iy = 0; iy < my; iy++) {
-      /* theta[] is used to hold (x - x_c). */
+      // theta[] is used to hold (x - x_c).
       *phip   = s;
       *thetap = t;
       phip   += rowlen;
@@ -8106,7 +8130,7 @@ int hpxx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -8117,7 +8141,7 @@ int hpxx2s(
 
     istat = 0;
     if (absy <= prj->w[5]) {
-      /* Equatorial regime. */
+      // Equatorial regime.
       t = asind(yr/prj->w[3]);
       for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
         *thetap = t;
@@ -8125,7 +8149,7 @@ int hpxx2s(
       }
 
     } else if (absy <= ylim) {
-      /* Polar regime. */
+      // Polar regime.
       offset = (prj->n || *yp > 0.0) ? 0 : 1;
 
       sigma = prj->w[4] - absy / prj->w[6];
@@ -8150,7 +8174,7 @@ int hpxx2s(
 
       for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
         if (offset) {
-          /* Offset the southern polar half-facets for even K. */
+          // Offset the southern polar half-facets for even K.
           h = (int)floor(*phip / prj->w[6]) + prj->m;
           if (h%2) {
             *thetap -= prj->w[6];
@@ -8159,10 +8183,10 @@ int hpxx2s(
           }
         }
 
-        /* Recall that theta[] holds (x - x_c). */
+        // Recall that theta[] holds (x - x_c).
         r = s * *thetap;
 
-        /* Bounds checking. */
+        // Bounds checking.
         if (prj->bounds&2) {
           if (slim <= fabs(r)) {
             istat = 1;
@@ -8178,7 +8202,7 @@ int hpxx2s(
       }
 
     } else {
-      /* Beyond latitude range. */
+      // Beyond latitude range.
       for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
         *phip   = 0.0;
         *thetap = 0.0;
@@ -8189,7 +8213,7 @@ int hpxx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-12, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("hpxx2s");
   }
@@ -8197,7 +8221,7 @@ int hpxx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int hpxs2x(
   struct prjprm *prj,
@@ -8219,7 +8243,7 @@ int hpxs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != HPX) {
     if ((status = hpxset(prj))) return status;
@@ -8235,21 +8259,21 @@ int hpxs2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
   for (iphi = 0; iphi < nphi; iphi++, rowoff += sxy, phip += spt) {
     xi = prj->w[0] * (*phip) - prj->x0;
 
-    /* phi_c for K odd or theta > 0. */
+    // phi_c for K odd or theta > 0.
     t = -180.0 + (2.0*floor((*phip+180.0) * prj->w[7]) + 1.0) * prj->w[6];
     t = prj->w[0] * (*phip - t);
 
     xp = x + rowoff;
     yp = y + rowoff;
     for (itheta = 0; itheta < mtheta; itheta++) {
-      /* y[] is used to hold (phi - phi_c). */
+      // y[] is used to hold (phi - phi_c).
       *xp = xi;
       *yp = t;
       xp += rowlen;
@@ -8258,7 +8282,7 @@ int hpxs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -8268,7 +8292,7 @@ int hpxs2x(
     abssin = fabs(sinthe);
 
     if (abssin <= prj->w[2]) {
-      /* Equatorial regime. */
+      // Equatorial regime.
       eta = prj->w[8] * sinthe - prj->y0;
       for (iphi = 0; iphi < mphi; iphi++, xp += sxy, yp += sxy) {
         *yp = eta;
@@ -8276,7 +8300,7 @@ int hpxs2x(
       }
 
     } else {
-      /* Polar regime. */
+      // Polar regime.
       offset = (prj->n || *thetap > 0.0) ? 0 : 1;
 
       sigma = sqrt(prj->pv[2]*(1.0 - abssin));
@@ -8288,7 +8312,7 @@ int hpxs2x(
 
       for (iphi = 0; iphi < mphi; iphi++, xp += sxy, yp += sxy) {
         if (offset) {
-          /* Offset the southern polar half-facets for even K. */
+          // Offset the southern polar half-facets for even K.
           h = (int)floor((*xp + prj->x0) / prj->w[9]) + prj->m;
           if (h%2) {
             *yp -= prj->w[9];
@@ -8297,12 +8321,12 @@ int hpxs2x(
           }
         }
 
-        /* Recall that y[] holds (phi - phi_c). */
+        // Recall that y[] holds (phi - phi_c).
         *xp += *yp * xi;
         *yp = eta;
         *(statp++) = 0;
 
-        /* Put the phi = 180 meridian in the expected place. */
+        // Put the phi = 180 meridian in the expected place.
         if (180.0 < *xp) *xp = 360.0 - *xp;
       }
     }
@@ -8375,7 +8399,7 @@ int xphset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int xphx2s(
   struct prjprm *prj,
@@ -8398,7 +8422,7 @@ int xphx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != XPH) {
     if ((status = xphset(prj))) return status;
@@ -8416,7 +8440,7 @@ int xphx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -8431,7 +8455,7 @@ int xphx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -8466,12 +8490,12 @@ int xphx2s(
 
       if (abseta <= 90.0) {
         if (abseta <= 45.0) {
-          /* Equatorial regime. */
+          // Equatorial regime.
           *phip  += xi;
           *thetap = asind(eta/67.5);
           istat = 0;
 
-          /* Bounds checking. */
+          // Bounds checking.
           if (prj->bounds&2) {
             if (45.0+tol < fabs(xi1)) {
               istat = 1;
@@ -8482,10 +8506,10 @@ int xphx2s(
           *(statp++) = istat;
 
         } else {
-          /* Polar regime. */
+          // Polar regime.
           sigma = (90.0 - abseta) / 45.0;
 
-          /* Ensure an exact result for points on the boundary. */
+          // Ensure an exact result for points on the boundary.
           if (xr == 0.0) {
             if (yr <= 0.0) {
               *phip = 0.0;
@@ -8509,7 +8533,7 @@ int xphx2s(
           }
           if (eta < 0.0) *thetap = -(*thetap);
 
-          /* Bounds checking. */
+          // Bounds checking.
           istat = 0;
           if (prj->bounds&2) {
             if (eta < -45.0 && eta+90.0+tol < fabs(xi1)) {
@@ -8522,7 +8546,7 @@ int xphx2s(
         }
 
       } else {
-        /* Beyond latitude range. */
+        // Beyond latitude range.
         *phip   = 0.0;
         *thetap = 0.0;
         *(statp++) = 1;
@@ -8532,7 +8556,7 @@ int xphx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-12, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("xphx2s");
   }
@@ -8540,7 +8564,7 @@ int xphx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int xphs2x(
   struct prjprm *prj,
@@ -8562,7 +8586,7 @@ int xphs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != XPH) {
     if ((status = xphset(prj))) return status;
@@ -8578,7 +8602,7 @@ int xphs2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -8593,14 +8617,14 @@ int xphs2x(
       }
     }
 
-    /* phi is also recomputed from chi to avoid rounding problems. */
+    // phi is also recomputed from chi to avoid rounding problems.
     chi += 180.0;
     psi = fmod(chi, 90.0);
 
     xp = x + rowoff;
     yp = y + rowoff;
     for (itheta = 0; itheta < mtheta; itheta++) {
-      /* y[] is used to hold phi (rounded). */
+      // y[] is used to hold phi (rounded).
       *xp = psi;
       *yp = chi - 180.0;
       xp += rowlen;
@@ -8609,7 +8633,7 @@ int xphs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -8620,12 +8644,12 @@ int xphs2x(
 
     for (iphi = 0; iphi < mphi; iphi++, xp += sxy, yp += sxy) {
       if (abssin <= prj->w[2]) {
-        /* Equatorial regime. */
+        // Equatorial regime.
         xi  = *xp;
         eta = 67.5 * sinthe;
 
       } else {
-        /* Polar regime. */
+        // Polar regime.
         if (*thetap < prj->w[5]) {
           sigma = sqrt(3.0*(1.0 - abssin));
         } else {
@@ -8640,7 +8664,7 @@ int xphs2x(
       xi  -= 45.0;
       eta -= 90.0;
 
-      /* Recall that y[] holds phi. */
+      // Recall that y[] holds phi.
       if (*yp < -90.0) {
         *xp = prj->w[0]*(-xi + eta) - prj->x0;
         *yp = prj->w[0]*(-xi - eta) - prj->y0;
Index: astropy-4.2.1/cextern/wcslib/C/prj.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/prj.h
+++ astropy-4.2.1/cextern/wcslib/C/prj.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: prj.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: prj.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -54,7 +51,8 @@
 *
 * Routine prjini() is provided to initialize the prjprm struct with default
 * values, prjfree() reclaims any memory that may have been allocated to store
-* an error message, and prjprt() prints its contents.
+* an error message, prjsize() computes its total size including allocated
+* memory, and prjprt() prints its contents.
 *
 * prjperr() prints the error message(s) (if any) stored in a prjprm struct.
 * prjbchk() performs bounds checking on native spherical coordinates.
@@ -76,7 +74,8 @@
 * In summary, the routines are:
 *   - prjini()                Initialization routine for the prjprm struct.
 *   - prjfree()               Reclaim memory allocated for error messages.
-*   - prjprt()                Print the prjprm struct.
+*   - prjsize()               Compute total size of a prjprm struct.
+*   - prjprt()                Print a prjprm struct.
 *   - prjperr()               Print error message (if any).
 *   - prjbchk()               Bounds checking on native coordinates.
 *
@@ -184,6 +183,33 @@
 *                         1: Null prjprm pointer passed.
 *
 *
+* prjsize() - Compute the size of a prjprm struct
+* -----------------------------------------------
+* prjsize() computes the full size of a prjprm struct, including allocated
+* memory.
+*
+* Given:
+*   prj       const struct prjprm*
+*                       Projection parameters.
+*
+*                       If NULL, the base size of the struct and the allocated
+*                       size are both set to zero.
+*
+* Returned:
+*   sizes     int[2]    The first element is the base size of the struct as
+*                       returned by sizeof(struct prjprm).  The second element
+*                       is the total allocated size, in bytes.  This figure
+*                       includes memory allocated for the constituent struct,
+*                       prjprm::err.
+*
+*                       It is not an error for the struct not to have been set
+*                       up via prjset().
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*
+*
 * prjprt() - Print routine for the prjprm struct
 * ----------------------------------------------
 * prjprt() prints the contents of a prjprm struct using wcsprintf().  Mainly
@@ -630,19 +656,19 @@ extern "C" {
 #endif
 
 
-/* Total number of projection parameters; 0 to PVN-1. */
+// Total number of projection parameters; 0 to PVN-1.
 #define PVN 30
 
 extern const char *prj_errmsg[];
 
 enum prj_errmsg_enum {
-  PRJERR_SUCCESS      = 0,	/* Success. */
-  PRJERR_NULL_POINTER = 1,	/* Null prjprm pointer passed. */
-  PRJERR_BAD_PARAM    = 2,	/* Invalid projection parameters. */
-  PRJERR_BAD_PIX      = 3,	/* One or more of the (x, y) coordinates were
-				   invalid. */
-  PRJERR_BAD_WORLD    = 4	/* One or more of the (phi, theta) coordinates
-				   were invalid. */
+  PRJERR_SUCCESS      = 0,	// Success.
+  PRJERR_NULL_POINTER = 1,	// Null prjprm pointer passed.
+  PRJERR_BAD_PARAM    = 2,	// Invalid projection parameters.
+  PRJERR_BAD_PIX      = 3,	// One or more of the (x, y) coordinates were
+				// invalid.
+  PRJERR_BAD_WORLD    = 4	// One or more of the (phi, theta) coordinates
+				// were invalid.
 };
 
 extern const int CONIC, CONVENTIONAL, CYLINDRICAL, POLYCONIC,
@@ -660,66 +686,72 @@ extern const char prj_codes[28][4];
 #undef PRJS2X_ARGS
 #endif
 
-/* For use in declaring deprojection function prototypes. */
+// For use in declaring deprojection function prototypes.
 #define PRJX2S_ARGS struct prjprm *prj, int nx, int ny, int sxy, int spt, \
 const double x[], const double y[], double phi[], double theta[], int stat[]
 
-/* For use in declaring projection function prototypes. */
+// For use in declaring projection function prototypes.
 #define PRJS2X_ARGS struct prjprm *prj, int nx, int ny, int sxy, int spt, \
 const double phi[], const double theta[], double x[], double y[], int stat[]
 
 
 struct prjprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int    flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  char   code[4];		/* Three-letter projection code.            */
-  double r0;			/* Radius of the generating sphere.         */
-  double pv[PVN];		/* Projection parameters.                   */
-  double phi0, theta0;		/* Fiducial native coordinates.             */
-  int    bounds;		/* Controls bounds checking.                */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  char   name[40];		/* Projection name.                         */
-  int    category;		/* Projection category.                     */
-  int    pvrange;		/* Range of projection parameter indices.   */
-  int    simplezen;		/* Is it a simple zenithal projection?      */
-  int    equiareal;		/* Is it an equal area projection?          */
-  int    conformal;		/* Is it a conformal projection?            */
-  int    global;		/* Can it map the whole sphere?             */
-  int    divergent;		/* Does the projection diverge in latitude? */
-  double x0, y0;		/* Fiducial offsets.                        */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  char   code[4];		// Three-letter projection code.
+  double r0;			// Radius of the generating sphere.
+  double pv[PVN];		// Projection parameters.
+  double phi0, theta0;		// Fiducial native coordinates.
+  int    bounds;		// Controls bounds checking.
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  char   name[40];		// Projection name.
+  int    category;		// Projection category.
+  int    pvrange;		// Range of projection parameter indices.
+  int    simplezen;		// Is it a simple zenithal projection?
+  int    equiareal;		// Is it an equal area projection?
+  int    conformal;		// Is it a conformal projection?
+  int    global;		// Can it map the whole sphere?
+  int    divergent;		// Does the projection diverge in latitude?
+  double x0, y0;		// Fiducial offsets.
 
-  /* Error handling                                                         */
-  /*------------------------------------------------------------------------*/
+  // Error handling
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private                                                                */
-  /*------------------------------------------------------------------------*/
-  void   *padding;		/* (Dummy inserted for alignment purposes.) */
-  double w[10];			/* Intermediate values.                     */
-  int    m, n;			/* Intermediate values.                     */
+  // Private
+  //--------------------------------------------------------------------------
+  void   *padding;		// (Dummy inserted for alignment purposes.)
+  double w[10];			// Intermediate values.
+  int    m, n;			// Intermediate values.
 
-  int (*prjx2s)(PRJX2S_ARGS);	/* Pointers to the spherical projection and */
-  int (*prjs2x)(PRJS2X_ARGS);	/* deprojection functions.                  */
+  int (*prjx2s)(PRJX2S_ARGS);	// Pointers to the spherical projection and
+  int (*prjs2x)(PRJS2X_ARGS);	// deprojection functions.
 };
 
-/* Size of the prjprm struct in int units, used by the Fortran wrappers. */
+// Size of the prjprm struct in int units, used by the Fortran wrappers.
 #define PRJLEN (sizeof(struct prjprm)/sizeof(int))
 
 
-/* Use the preprocessor to help declare function prototypes (see above). */
 int prjini(struct prjprm *prj);
+
 int prjfree(struct prjprm *prj);
+
+int prjsize(const struct prjprm *prj, int sizes[2]);
+
 int prjprt(const struct prjprm *prj);
+
 int prjperr(const struct prjprm *prj, const char *prefix);
+
 int prjbchk(double tol, int nphi, int ntheta, int spt, double phi[],
             double theta[], int stat[]);
 
+// Use the preprocessor to help declare function prototypes (see above).
 int prjset(struct prjprm *prj);
 int prjx2s(PRJX2S_ARGS);
 int prjs2x(PRJS2X_ARGS);
@@ -837,7 +869,7 @@ int xphx2s(PRJX2S_ARGS);
 int xphs2x(PRJS2X_ARGS);
 
 
-/* Deprecated. */
+// Deprecated.
 #define prjini_errmsg prj_errmsg
 #define prjprt_errmsg prj_errmsg
 #define prjset_errmsg prj_errmsg
@@ -848,4 +880,4 @@ int xphs2x(PRJS2X_ARGS);
 }
 #endif
 
-#endif /* WCSLIB_PROJ */
+#endif // WCSLIB_PROJ
Index: astropy-4.2.1/cextern/wcslib/C/spc.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/spc.c
+++ astropy-4.2.1/cextern/wcslib/C/spc.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: spc.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: spc.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -38,29 +35,29 @@
 #include "spc.h"
 #include "spx.h"
 
-/* Spectral algorithm codes. */
-#define F2S 100;		/* Axis linear in frequency.          */
-#define W2S 200;		/* Axis linear in vacuum wavelengths. */
-#define A2S 300;		/* Axis linear in air wavelengths.    */
-#define V2S 400;		/* Axis linear in velocity.           */
-#define GRI 500;		/* Grism in vacuum.                   */
-#define GRA 600;		/* Grism in air.                      */
-
-/* S-type spectral variables. */
-#define FREQ  0;		/* Frequency-like.                    */
-#define AFRQ  1;		/* Frequency-like.                    */
-#define ENER  2;		/* Frequency-like.                    */
-#define WAVN  3;		/* Frequency-like.                    */
-#define VRAD  4;		/* Frequency-like.                    */
-#define WAVE 10;		/* Vacuum wavelength-like.            */
-#define VOPT 11;		/* Vacuum wavelength-like.            */
-#define ZOPT 12;		/* Vacuum wavelength-like.            */
-#define AWAV 20;		/* Air wavelength-like.               */
-#define VELO 30;		/* Velocity-like.                     */
-#define BETA 31;		/* Velocity-like.                     */
+// Spectral algorithm codes.
+#define F2S 100;		// Axis linear in frequency.
+#define W2S 200;		// Axis linear in vacuum wavelengths.
+#define A2S 300;		// Axis linear in air wavelengths.
+#define V2S 400;		// Axis linear in velocity.
+#define GRI 500;		// Grism in vacuum.
+#define GRA 600;		// Grism in air.
+
+// S-type spectral variables.
+#define FREQ  0;		// Frequency-like.
+#define AFRQ  1;		// Frequency-like.
+#define ENER  2;		// Frequency-like.
+#define WAVN  3;		// Frequency-like.
+#define VRAD  4;		// Frequency-like.
+#define WAVE 10;		// Vacuum wavelength-like.
+#define VOPT 11;		// Vacuum wavelength-like.
+#define ZOPT 12;		// Vacuum wavelength-like.
+#define AWAV 20;		// Air wavelength-like.
+#define VELO 30;		// Velocity-like.
+#define BETA 31;		// Velocity-like.
 
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *spc_errmsg[] = {
   "Success",
   "Null spcprm pointer passed",
@@ -68,24 +65,24 @@ const char *spc_errmsg[] = {
   "One or more of x coordinates were invalid",
   "One or more of the spec coordinates were invalid"};
 
-/* Map error returns for lower-level routines.  SPXERR_BAD_INSPEC_COORD */
-/* maps to either SPCERR_BAD_X or SPCERR_BAD_SPEC depending on context. */
+// Map error returns for lower-level routines.  SPXERR_BAD_INSPEC_COORD
+// maps to either SPCERR_BAD_X or SPCERR_BAD_SPEC depending on context.
 const int spc_spxerr[] = {
 
-  SPCERR_SUCCESS,		/*  0: SPXERR_SUCCESS          */
-  SPCERR_NULL_POINTER,		/*  1: SPXERR_NULL_POINTER     */
-  SPCERR_BAD_SPEC_PARAMS,	/*  2: SPXERR_BAD_SPEC_PARAMS  */
-  SPCERR_BAD_SPEC_PARAMS	/*  3: SPXERR_BAD_SPEC_VAR     */
-				/*  4: SPXERR_BAD_INSPEC_COORD */
+  SPCERR_SUCCESS,		//  0: SPXERR_SUCCESS
+  SPCERR_NULL_POINTER,		//  1: SPXERR_NULL_POINTER
+  SPCERR_BAD_SPEC_PARAMS,	//  2: SPXERR_BAD_SPEC_PARAMS
+  SPCERR_BAD_SPEC_PARAMS	//  3: SPXERR_BAD_SPEC_VAR
+				//  4: SPXERR_BAD_INSPEC_COORD
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define SPC_ERRMSG(status) WCSERR_SET(status), spc_errmsg[status]
 
 
 #define C 2.99792458e8
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcini(struct spcprm *spc)
 
@@ -126,7 +123,7 @@ int spcini(struct spcprm *spc)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcfree(struct spcprm *spc)
 
@@ -138,7 +135,32 @@ int spcfree(struct spcprm *spc)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
+
+int spcsize(const struct spcprm *spc, int sizes[2])
+
+{
+  if (spc == 0x0) {
+    sizes[0] = sizes[1] = 0;
+    return SPCERR_SUCCESS;
+  }
+
+  // Base size, in bytes.
+  sizes[0] = sizeof(struct spcprm);
+
+  // Total size of allocated memory, in bytes.
+  sizes[1] = 0;
+
+  int exsizes[2];
+
+  // spcprm::err.
+  wcserr_size(spc->err, exsizes);
+  sizes[1] += exsizes[0] + exsizes[1];
+
+  return SPCERR_SUCCESS;
+}
+
+//----------------------------------------------------------------------------
 
 int spcprt(const struct spcprm *spc)
 
@@ -215,7 +237,7 @@ int spcprt(const struct spcprm *spc)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcperr(const struct spcprm *spc, const char *prefix)
 
@@ -229,7 +251,7 @@ int spcperr(const struct spcprm *spc, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcset(struct spcprm *spc)
 
@@ -257,7 +279,7 @@ int spcset(struct spcprm *spc)
   spc->w[0] = 0.0;
 
 
-  /* Analyse the spectral axis type. */
+  // Analyse the spectral axis type.
   memset(ctype, 0, 9);
   memcpy(ctype, spc->type, 4);
   if (*(spc->code) != ' ') {
@@ -270,12 +292,12 @@ int spcset(struct spcprm *spc)
     return status;
   }
 
-  /* Satisfy rest frequency/wavelength requirements. */
+  // Satisfy rest frequency/wavelength requirements.
   if (restreq) {
     if (restreq == 3 && restfrq == 0.0 && restwav == 0.0) {
-      /* VRAD-V2F, VOPT-V2W, and ZOPT-V2W require the rest frequency or */
-      /* wavelength for the S-P and P-X transformations but not for S-X */
-      /* so supply a phoney value. */
+      // VRAD-V2F, VOPT-V2W, and ZOPT-V2W require the rest frequency or
+      // wavelength for the S-P and P-X transformations but not for S-X
+      // so supply a phoney value.
       restwav = 1.0;
     }
 
@@ -302,34 +324,34 @@ int spcset(struct spcprm *spc)
   spc->w[2] = dXdS;
 
 
-  /* Set pointers-to-functions for the linear part of the transformation. */
+  // Set pointers-to-functions for the linear part of the transformation.
   if (ptype == 'F') {
     if (strcmp(spc->type, "FREQ") == 0) {
-      /* Frequency. */
+      // Frequency.
       spc->flag = FREQ;
       spc->spxP2S = 0x0;
       spc->spxS2P = 0x0;
 
     } else if (strcmp(spc->type, "AFRQ") == 0) {
-      /* Angular frequency. */
+      // Angular frequency.
       spc->flag = AFRQ;
       spc->spxP2S = freqafrq;
       spc->spxS2P = afrqfreq;
 
     } else if (strcmp(spc->type, "ENER") == 0) {
-      /* Photon energy. */
+      // Photon energy.
       spc->flag = ENER;
       spc->spxP2S = freqener;
       spc->spxS2P = enerfreq;
 
     } else if (strcmp(spc->type, "WAVN") == 0) {
-      /* Wave number. */
+      // Wave number.
       spc->flag = WAVN;
       spc->spxP2S = freqwavn;
       spc->spxS2P = wavnfreq;
 
     } else if (strcmp(spc->type, "VRAD") == 0) {
-      /* Radio velocity. */
+      // Radio velocity.
       spc->flag = VRAD;
       spc->spxP2S = freqvrad;
       spc->spxS2P = vradfreq;
@@ -337,19 +359,19 @@ int spcset(struct spcprm *spc)
 
   } else if (ptype == 'W') {
     if (strcmp(spc->type, "WAVE") == 0) {
-      /* Vacuum wavelengths. */
+      // Vacuum wavelengths.
       spc->flag = WAVE;
       spc->spxP2S = 0x0;
       spc->spxS2P = 0x0;
 
     } else if (strcmp(spc->type, "VOPT") == 0) {
-      /* Optical velocity. */
+      // Optical velocity.
       spc->flag = VOPT;
       spc->spxP2S = wavevopt;
       spc->spxS2P = voptwave;
 
     } else if (strcmp(spc->type, "ZOPT") == 0) {
-      /* Redshift. */
+      // Redshift.
       spc->flag = ZOPT;
       spc->spxP2S = wavezopt;
       spc->spxS2P = zoptwave;
@@ -357,7 +379,7 @@ int spcset(struct spcprm *spc)
 
   } else if (ptype == 'A') {
     if (strcmp(spc->type, "AWAV") == 0) {
-      /* Air wavelengths. */
+      // Air wavelengths.
       spc->flag = AWAV;
       spc->spxP2S = 0x0;
       spc->spxS2P = 0x0;
@@ -365,13 +387,13 @@ int spcset(struct spcprm *spc)
 
   } else if (ptype == 'V') {
     if (strcmp(spc->type, "VELO") == 0) {
-      /* Relativistic velocity. */
+      // Relativistic velocity.
       spc->flag = VELO;
       spc->spxP2S = 0x0;
       spc->spxS2P = 0x0;
 
     } else if (strcmp(spc->type, "BETA") == 0) {
-      /* Velocity ratio (v/c). */
+      // Velocity ratio (v/c).
       spc->flag = BETA;
       spc->spxP2S = velobeta;
       spc->spxS2P = betavelo;
@@ -379,11 +401,11 @@ int spcset(struct spcprm *spc)
   }
 
 
-  /* Set pointers-to-functions for the non-linear part of the spectral */
-  /* transformation.                                                   */
+  // Set pointers-to-functions for the non-linear part of the spectral
+  // transformation.
   spc->isGrism = 0;
   if (xtype == 'F') {
-    /* Axis is linear in frequency. */
+    // Axis is linear in frequency.
     if (ptype == 'F') {
       spc->spxX2P = 0x0;
       spc->spxP2X = 0x0;
@@ -404,7 +426,7 @@ int spcset(struct spcprm *spc)
     spc->flag += F2S;
 
   } else if (xtype == 'W' || xtype == 'w') {
-    /* Axis is linear in vacuum wavelengths. */
+    // Axis is linear in vacuum wavelengths.
     if (ptype == 'F') {
       spc->spxX2P = wavefreq;
       spc->spxP2X = freqwave;
@@ -425,13 +447,13 @@ int spcset(struct spcprm *spc)
     if (xtype == 'W') {
       spc->flag += W2S;
     } else {
-      /* Grism in vacuum. */
+      // Grism in vacuum.
       spc->isGrism = 1;
       spc->flag += GRI;
     }
 
   } else if (xtype == 'A' || xtype == 'a') {
-    /* Axis is linear in air wavelengths. */
+    // Axis is linear in air wavelengths.
     if (ptype == 'F') {
       spc->spxX2P = awavfreq;
       spc->spxP2X = freqawav;
@@ -452,13 +474,13 @@ int spcset(struct spcprm *spc)
     if (xtype == 'A') {
       spc->flag += A2S;
     } else {
-      /* Grism in air. */
+      // Grism in air.
       spc->isGrism = 2;
       spc->flag += GRA;
     }
 
   } else if (xtype == 'V') {
-    /* Axis is linear in relativistic velocity. */
+    // Axis is linear in relativistic velocity.
     if (ptype == 'F') {
       spc->spxX2P = velofreq;
       spc->spxP2X = freqvelo;
@@ -480,12 +502,12 @@ int spcset(struct spcprm *spc)
   }
 
 
-  /* Check for grism axes. */
+  // Check for grism axes.
   if (spc->isGrism) {
-    /* Axis is linear in "grism parameter"; work in wavelength. */
+    // Axis is linear in "grism parameter"; work in wavelength.
     lambda_r = crvalX;
 
-    /* Set defaults. */
+    // Set defaults.
     if (undefined(spc->pv[0])) spc->pv[0] = 0.0;
     if (undefined(spc->pv[1])) spc->pv[1] = 0.0;
     if (undefined(spc->pv[2])) spc->pv[2] = 0.0;
@@ -494,7 +516,7 @@ int spcset(struct spcprm *spc)
     if (undefined(spc->pv[5])) spc->pv[5] = 0.0;
     if (undefined(spc->pv[6])) spc->pv[6] = 0.0;
 
-    /* Compute intermediaries. */
+    // Compute intermediaries.
     G       = spc->pv[0];
     m       = spc->pv[1];
     alpha   = spc->pv[2];
@@ -518,7 +540,7 @@ int spcset(struct spcprm *spc)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcx2s(
   struct spcprm *spc,
@@ -540,7 +562,7 @@ int spcx2s(
   register double *specp;
   struct wcserr **err;
 
-  /* Initialize. */
+  // Initialize.
   if (spc == 0x0) return SPCERR_NULL_POINTER;
   err = &(spc->err);
 
@@ -548,7 +570,7 @@ int spcx2s(
     if ((status = spcset(spc))) return status;
   }
 
-  /* Convert intermediate world coordinate x to X. */
+  // Convert intermediate world coordinate x to X.
   xp = x;
   specp = spec;
   statp = stat;
@@ -557,7 +579,7 @@ int spcx2s(
     *(statp++) = 0;
   }
 
-  /* If X is the grism parameter then convert it to wavelength. */
+  // If X is the grism parameter then convert it to wavelength.
   if (spc->isGrism) {
     specp = spec;
     for (ix = 0; ix < nx; ix++, specp += sspec) {
@@ -566,8 +588,8 @@ int spcx2s(
     }
   }
 
-  /* Apply the non-linear step of the algorithm chain to convert the    */
-  /* X-type spectral variable to P-type intermediate spectral variable. */
+  // Apply the non-linear step of the algorithm chain to convert the
+  // X-type spectral variable to P-type intermediate spectral variable.
   if (spc->spxX2P) {
     if ((statX2P = spc->spxX2P(spc->w[0], nx, sspec, sspec, spec, spec,
                                stat))) {
@@ -582,8 +604,8 @@ int spcx2s(
     }
   }
 
-  /* Apply the linear step of the algorithm chain to convert P-type  */
-  /* intermediate spectral variable to the required S-type variable. */
+  // Apply the linear step of the algorithm chain to convert P-type
+  // intermediate spectral variable to the required S-type variable.
   if (spc->spxP2S) {
     if ((statP2S = spc->spxP2S(spc->w[0], nx, sspec, sspec, spec, spec,
                                stat))) {
@@ -604,7 +626,7 @@ int spcx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcs2x(
   struct spcprm *spc,
@@ -626,7 +648,7 @@ int spcs2x(
   register double *xp;
   struct wcserr **err;
 
-  /* Initialize. */
+  // Initialize.
   if (spc == 0x0) return SPCERR_NULL_POINTER;
   err = &(spc->err);
 
@@ -634,8 +656,8 @@ int spcs2x(
     if ((status = spcset(spc))) return status;
   }
 
-  /* Apply the linear step of the algorithm chain to convert the S-type */
-  /* spectral variable to P-type intermediate spectral variable.        */
+  // Apply the linear step of the algorithm chain to convert the S-type
+  // spectral variable to P-type intermediate spectral variable.
   if (spc->spxS2P) {
     if ((statS2P = spc->spxS2P(spc->w[0], nspec, sspec, sx, spec, x, stat))) {
       if (statS2P == SPXERR_BAD_INSPEC_COORD) {
@@ -649,7 +671,7 @@ int spcs2x(
     }
 
   } else {
-    /* Just a copy. */
+    // Just a copy.
     xp = x;
     specp = spec;
     statp = stat;
@@ -660,8 +682,8 @@ int spcs2x(
   }
 
 
-  /* Apply the non-linear step of the algorithm chain to convert P-type */
-  /* intermediate spectral variable to X-type spectral variable. */
+  // Apply the non-linear step of the algorithm chain to convert P-type
+  // intermediate spectral variable to X-type spectral variable.
   if (spc->spxP2X) {
     if ((statP2X = spc->spxP2X(spc->w[0], nspec, sx, sx, x, x, stat))) {
       if (statP2X == SPCERR_BAD_SPEC) {
@@ -676,7 +698,7 @@ int spcs2x(
   }
 
   if (spc->isGrism) {
-    /* Convert X-type spectral variable (wavelength) to grism parameter. */
+    // Convert X-type spectral variable (wavelength) to grism parameter.
     xp = x;
     statp = stat;
     for (ispec = 0; ispec < nspec; ispec++, xp += sx, statp++) {
@@ -693,7 +715,7 @@ int spcs2x(
   }
 
 
-  /* Convert X-type spectral variable to intermediate world coordinate x. */
+  // Convert X-type spectral variable to intermediate world coordinate x.
   xp = x;
   statp = stat;
   for (ispec = 0; ispec < nspec; ispec++, xp += sx) {
@@ -709,7 +731,7 @@ int spcs2x(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spctyp(
   const char ctypei[9],
@@ -726,7 +748,7 @@ int spctyp(
     ctypei, stype, scode, sname, units, ptype, xtype, restreq, NULL);
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int spctype(
   const char ctypei[9],
@@ -747,11 +769,11 @@ int spctype(
 
   if (err) *err = 0x0;
 
-  /* Copy with blank padding. */
+  // Copy with blank padding.
   sprintf(ctype, "%-8.8s", ctypei);
   ctype[8] = '\0';
 
-  /* Validate the S-type spectral variable. */
+  // Validate the S-type spectral variable.
   if (strncmp(ctype, "FREQ", 4) == 0) {
     strcpy(sname_t, "Frequency");
     strcpy(units_t, "Hz");
@@ -805,9 +827,9 @@ int spctype(
   }
 
 
-  /* Determine X-type and validate the spectral algorithm code. */
+  // Determine X-type and validate the spectral algorithm code.
   if ((xtype_t = ctype[5]) == ' ') {
-    /* The algorithm code must be completely blank. */
+    // The algorithm code must be completely blank.
     if (strcmp(ctype+4, "    ") != 0) {
       return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
         "Invalid spectral algorithm '%s'", ctype+4);
@@ -820,21 +842,21 @@ int spctype(
       "Invalid spectral type '%s'", ctype);
 
   } else if (strcmp(ctype+5, "LOG") == 0 || strcmp(ctype+5, "TAB") == 0) {
-    /* Logarithmic or tabular axis, not linear in any spectral type. */
+    // Logarithmic or tabular axis, not linear in any spectral type.
 
   } else if (xtype_t == 'G') {
-    /* Validate the algorithm code. */
+    // Validate the algorithm code.
     if (ctype[6] != 'R') {
       return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
         "Invalid spectral algorithm '%s'", xtype_t);
     }
 
-    /* Grism coordinates... */
+    // Grism coordinates...
     if (ctype[7] == 'I') {
-      /* ...in vacuum. */
+      // ...in vacuum.
       xtype_t = 'w';
     } else if (ctype[7] == 'A') {
-      /* ...in air. */
+      // ...in air.
       xtype_t = 'a';
     } else {
       return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
@@ -842,22 +864,22 @@ int spctype(
     }
 
   } else if (ctype[6] != '2') {
-    /* Algorithm code has invalid syntax. */
+    // Algorithm code has invalid syntax.
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Invalid spectral algorithm syntax '%s'", xtype_t);
   } else if (ctype[7] != ptype_t && ctype[7] != '?') {
-    /* The P-, and S-type variables are inconsistent. */
+    // The P-, and S-type variables are inconsistent.
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "In spectral type '%s', P- and S-type variables are inconsistent",
       ctype);
 
   } else if (ctype[7] == ctype[5]) {
-    /* Degenerate algorithm code. */
+    // Degenerate algorithm code.
     sprintf(ctype+4, "    ");
   }
 
 
-  /* Rest freq/wavelength required for transformation between P and X? */
+  // Rest freq/wavelength required for transformation between P and X?
   if (strchr("FWAwa", (int)xtype_t)) {
     if (ptype_t == 'V') {
       restreq_t += 2;
@@ -867,13 +889,13 @@ int spctype(
       restreq_t += 2;
     }
   } else if (strchr("LT", (int)xtype_t) == 0) {
-    /* Invalid X-type variable code. */
+    // Invalid X-type variable code.
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "In spectral type '%s', invalid X-type variable code", ctype);
   }
 
 
-  /* Copy results. */
+  // Copy results.
   if (stype) {
     memcpy(stype, ctype, 4);
     stype[4] = '\0';
@@ -889,7 +911,7 @@ int spctype(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcspx(
   const char ctypeS[9],
@@ -907,7 +929,7 @@ int spcspx(
                  crvalX, dXdS, 0x0);
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int spcspxe(
   const char ctypeS[9],
@@ -930,25 +952,25 @@ int spcspxe(
   struct spxprm spx;
 
 
-  /* Analyse the spectral axis code. */
+  // Analyse the spectral axis code.
   if ((status = spctype(ctypeS, stype, scode, 0x0, 0x0, ptype, xtype, restreq,
                         err))) {
     return status;
   }
 
   if (strchr("LT", (int)(*xtype))) {
-    /* Can't handle logarithmic or tabular coordinates. */
+    // Can't handle logarithmic or tabular coordinates.
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Can't handle logarithmic or tabular coordinates");
   }
 
-  /* Do we have rest frequency and/or wavelength as required? */
+  // Do we have rest frequency and/or wavelength as required?
   if ((*restreq)%3 && restfrq == 0.0 && restwav == 0.0) {
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Missing required rest frequency or wavelength");
   }
 
-  /* Compute all spectral parameters and their derivatives. */
+  // Compute all spectral parameters and their derivatives.
   strcpy(type, stype);
   spx.err = (err ? *err : 0x0);
   if ((status = specx(type, crvalS, restfrq, restwav, &spx))) {
@@ -964,7 +986,7 @@ int spcspxe(
   }
 
 
-  /* Transform S-P (linear) and P-X (non-linear). */
+  // Transform S-P (linear) and P-X (non-linear).
   dPdS = 0.0;
   dXdP = 0.0;
   if (*ptype == 'F') {
@@ -1063,7 +1085,7 @@ int spcspxe(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcxps(
   const char ctypeS[9],
@@ -1081,7 +1103,7 @@ int spcxps(
                  crvalS, dSdX, NULL);
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int spcxpse(
   const char ctypeS[9],
@@ -1103,25 +1125,25 @@ int spcxpse(
   double dPdX, dSdP;
   struct spxprm spx;
 
-  /* Analyse the spectral axis type. */
+  // Analyse the spectral axis type.
   if ((status = spctype(ctypeS, stype, scode, 0x0, 0x0, ptype, xtype, restreq,
                         err))) {
     return status;
   }
 
   if (strchr("LT", (int)(*xtype))) {
-    /* Can't handle logarithmic or tabular coordinates. */
+    // Can't handle logarithmic or tabular coordinates.
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Can't handle logarithmic or tabular coordinates");
   }
 
-  /* Do we have rest frequency and/or wavelength as required? */
+  // Do we have rest frequency and/or wavelength as required?
   if ((*restreq)%3 && restfrq == 0.0 && restwav == 0.0) {
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Missing required rest frequency or wavelength");
   }
 
-  /* Compute all spectral parameters and their derivatives. */
+  // Compute all spectral parameters and their derivatives.
   if (*xtype == 'F') {
     strcpy(type, "FREQ");
   } else if (*xtype == 'W' || *xtype == 'w') {
@@ -1146,7 +1168,7 @@ int spcxpse(
   }
 
 
-  /* Transform X-P (non-linear) and P-S (linear). */
+  // Transform X-P (non-linear) and P-S (linear).
   dPdX = 0.0;
   dSdP = 0.0;
   if (*ptype == 'F') {
@@ -1240,7 +1262,7 @@ int spcxpse(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spctrn(
   const char ctypeS1[9],
@@ -1257,7 +1279,7 @@ int spctrn(
                  ctypeS2, crvalS2, cdeltS2, NULL);
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int spctrne(
   const char ctypeS1[9],
@@ -1278,9 +1300,9 @@ int spctrne(
   double crvalX, dS2dX, dXdS1;
 
   if (restfrq == 0.0 && restwav == 0.0) {
-    /* If translating between two velocity-characteristic types, or between
-       two wave-characteristic types, then we may need to set a dummy rest
-       frequency or wavelength to perform the calculations. */
+    // If translating between two velocity-characteristic types, or between
+    // two wave-characteristic types, then we may need to set a dummy rest
+    // frequency or wavelength to perform the calculations.
     strncpy(stype1, ctypeS1, 4);
     strncpy(stype2, ctypeS2, 4);
     stype1[4] = stype2[4] = '\0';
@@ -1295,13 +1317,13 @@ int spctrne(
     return status;
   }
 
-  /* Pad with blanks. */
+  // Pad with blanks.
   ctypeS2[8] = '\0';
   for (cp = ctypeS2; *cp; cp++);
   while (cp < ctypeS2+8) *(cp++) = ' ';
 
   if (strncmp(ctypeS2+5, "???", 3) == 0) {
-    /* Set the algorithm code if required. */
+    // Set the algorithm code if required.
     if (xtype1 == 'w') {
       strcpy(ctypeS2+5, "GRI");
     } else if (xtype1 == 'a') {
@@ -1317,7 +1339,7 @@ int spctrne(
     return status;
   }
 
-  /* Are the X-types compatible? */
+  // Are the X-types compatible?
   if (xtype2 != xtype1) {
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Incompatible X-types '%c' and '%c'", xtype1, xtype2);
@@ -1336,7 +1358,7 @@ int spctrne(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcaips(
   const char ctypeA[9],
@@ -1350,18 +1372,18 @@ int spcaips(
   char *fcode;
   int  ivf, status;
 
-  /* Make a null-filled copy of ctypeA. */
+  // Make a null-filled copy of ctypeA.
   if (ctype != ctypeA) strncpy(ctype, ctypeA, 8);
   ctype[8] = '\0';
   wcsutil_null_fill(9, ctype);
   *specsys = '\0';
 
-  /* Is it a recognized AIPS-convention type? */
+  // Is it a recognized AIPS-convention type?
   status = SPCERR_NO_CHANGE;
   if (strncmp(ctype, "FREQ", 4) == 0 ||
       strncmp(ctype, "VELO", 4) == 0 ||
       strncmp(ctype, "FELO", 4) == 0) {
-    /* Look for the Doppler frame. */
+    // Look for the Doppler frame.
     if (*(fcode = ctype+4)) {
       if (strcmp(fcode, "-LSR") == 0) {
         strcpy(specsys, "LSRK");
@@ -1370,7 +1392,7 @@ int spcaips(
       } else if (strcmp(fcode, "-OBS") == 0) {
         strcpy(specsys, "TOPOCENT");
       } else {
-        /* Not a recognized AIPS spectral type. */
+        // Not a recognized AIPS spectral type.
         return SPCERR_NO_CHANGE;
       }
 
@@ -1378,7 +1400,7 @@ int spcaips(
       status = 0;
     }
 
-    /* VELREF takes precedence if present. */
+    // VELREF takes precedence if present.
     ivf = velref%256;
     if (0 < ivf && ivf <= 7) {
       strcpy(specsys, frames[ivf-1]);
@@ -1388,9 +1410,9 @@ int spcaips(
     }
 
     if (strcmp(ctype, "VELO") == 0) {
-      /* Check that we found an AIPS-convention Doppler frame. */
+      // Check that we found an AIPS-convention Doppler frame.
       if (*specsys) {
-        /* 'VELO' in AIPS means radio or optical depending on VELREF. */
+        // 'VELO' in AIPS means radio or optical depending on VELREF.
         ivf = velref/256;
         if (ivf == 0) {
           strcpy(ctype, "VOPT");
@@ -1401,8 +1423,8 @@ int spcaips(
         }
       }
     } else if (strcmp(ctype, "FELO") == 0) {
-      /* Uniform in frequency but expressed as an optical velocity (strictly
-         we should also have found an AIPS-convention Doppler frame). */
+      // Uniform in frequency but expressed as an optical velocity (strictly
+      // we should also have found an AIPS-convention Doppler frame).
       strcpy(ctype, "VOPT-F2W");
       if (status < 0) status = 0;
     }
Index: astropy-4.2.1/cextern/wcslib/C/spc.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/spc.h
+++ astropy-4.2.1/cextern/wcslib/C/spc.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: spc.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: spc.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -52,7 +49,8 @@
 *
 * Routine spcini() is provided to initialize the spcprm struct with default
 * values, spcfree() reclaims any memory that may have been allocated to store
-* an error message, and spcprt() prints its contents.
+* an error message, spcsize() computes its total size including allocated
+* memory, and spcprt() prints its contents.
 *
 * spcperr() prints the error message(s) (if any) stored in a spcprm struct.
 *
@@ -213,6 +211,33 @@
 *                         1: Null spcprm pointer passed.
 *
 *
+* spcsize() - Compute the size of a spcprm struct
+* -----------------------------------------------
+* spcsize() computes the full size of a spcprm struct, including allocated
+* memory.
+*
+* Given:
+*   spc       const struct spcprm*
+*                       Spectral transformation parameters.
+*
+*                       If NULL, the base size of the struct and the allocated
+*                       size are both set to zero.
+*
+* Returned:
+*   sizes     int[2]    The first element is the base size of the struct as
+*                       returned by sizeof(struct spcprm).  The second element
+*                       is the total allocated size, in bytes.  This figure
+*                       includes memory allocated for the constituent struct,
+*                       spcprm::err.
+*
+*                       It is not an error for the struct not to have been set
+*                       up via spcset().
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*
+*
 * spcprt() - Print routine for the spcprm struct
 * ----------------------------------------------
 * spcprt() prints the contents of a spcprm struct using wcsprintf().  Mainly
@@ -794,67 +819,67 @@ extern "C" {
 extern const char *spc_errmsg[];
 
 enum spc_errmsg_enum {
-  SPCERR_NO_CHANGE       = -1,	/* No change. */
-  SPCERR_SUCCESS         =  0,	/* Success. */
-  SPCERR_NULL_POINTER    =  1,	/* Null spcprm pointer passed. */
-  SPCERR_BAD_SPEC_PARAMS =  2,	/* Invalid spectral parameters. */
-  SPCERR_BAD_X           =  3,	/* One or more of x coordinates were
-				   invalid. */
-  SPCERR_BAD_SPEC        =  4 	/* One or more of the spec coordinates were
-				   invalid. */
+  SPCERR_NO_CHANGE       = -1,	// No change.
+  SPCERR_SUCCESS         =  0,	// Success.
+  SPCERR_NULL_POINTER    =  1,	// Null spcprm pointer passed.
+  SPCERR_BAD_SPEC_PARAMS =  2,	// Invalid spectral parameters.
+  SPCERR_BAD_X           =  3,	// One or more of x coordinates were
+				// invalid.
+  SPCERR_BAD_SPEC        =  4 	// One or more of the spec coordinates were
+				// invalid.
 };
 
 struct spcprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int    flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  char   type[8];		/* Four-letter spectral variable type.      */
-  char   code[4];		/* Three-letter spectral algorithm code.    */
-
-  double crval;			/* Reference value (CRVALia), SI units.     */
-  double restfrq;		/* Rest frequency, Hz.                      */
-  double restwav;		/* Rest wavelength, m.                      */
-
-  double pv[7];			/* Grism parameters:                        */
-				/*   0: G, grating ruling density.          */
-				/*   1: m, interference order.              */
-				/*   2: alpha, angle of incidence.          */
-				/*   3: n_r, refractive index at lambda_r.  */
-				/*   4: n'_r, dn/dlambda at lambda_r.       */
-				/*   5: epsilon, grating tilt angle.        */
-				/*   6: theta, detector tilt angle.         */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  double w[6];			/* Intermediate values.                     */
-				/*   0: Rest frequency or wavelength (SI).  */
-				/*   1: CRVALX (SI units).                  */
-				/*   2: CDELTX/CDELTia = dX/dS (SI units).  */
-				/* The remainder are grism intermediates.   */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  char   type[8];		// Four-letter spectral variable type.
+  char   code[4];		// Three-letter spectral algorithm code.
+
+  double crval;			// Reference value (CRVALia), SI units.
+  double restfrq;		// Rest frequency, Hz.
+  double restwav;		// Rest wavelength, m.
+
+  double pv[7];			// Grism parameters:
+				//   0: G, grating ruling density.
+				//   1: m, interference order.
+				//   2: alpha, angle of incidence.
+				//   3: n_r, refractive index at lambda_r.
+				//   4: n'_r, dn/dlambda at lambda_r.
+				//   5: epsilon, grating tilt angle.
+				//   6: theta, detector tilt angle.
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  double w[6];			// Intermediate values.
+				//   0: Rest frequency or wavelength (SI).
+				//   1: CRVALX (SI units).
+				//   2: CDELTX/CDELTia = dX/dS (SI units).
+				// The remainder are grism intermediates.
 
-  int    isGrism;		/* Grism coordinates?  1: vacuum, 2: air.   */
-  int    padding1;		/* (Dummy inserted for alignment purposes.) */
+  int    isGrism;		// Grism coordinates?  1: vacuum, 2: air.
+  int    padding1;		// (Dummy inserted for alignment purposes.)
 
-  /* Error handling                                                         */
-  /*------------------------------------------------------------------------*/
+  // Error handling
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private                                                                */
-  /*------------------------------------------------------------------------*/
-  void   *padding2;		/* (Dummy inserted for alignment purposes.) */
-  int (*spxX2P)(SPX_ARGS);	/* Pointers to the transformation functions */
-  int (*spxP2S)(SPX_ARGS);	/* in the two-step algorithm chain in the   */
-				/* pixel-to-spectral direction.             */
-
-  int (*spxS2P)(SPX_ARGS);	/* Pointers to the transformation functions */
-  int (*spxP2X)(SPX_ARGS);	/* in the two-step algorithm chain in the   */
-				/* spectral-to-pixel direction.             */
+  // Private
+  //--------------------------------------------------------------------------
+  void   *padding2;		// (Dummy inserted for alignment purposes.)
+  int (*spxX2P)(SPX_ARGS);	// Pointers to the transformation functions
+  int (*spxP2S)(SPX_ARGS);	// in the two-step algorithm chain in the
+				// pixel-to-spectral direction.
+
+  int (*spxS2P)(SPX_ARGS);	// Pointers to the transformation functions
+  int (*spxP2X)(SPX_ARGS);	// in the two-step algorithm chain in the
+				// spectral-to-pixel direction.
 };
 
-/* Size of the spcprm struct in int units, used by the Fortran wrappers. */
+// Size of the spcprm struct in int units, used by the Fortran wrappers.
 #define SPCLEN (sizeof(struct spcprm)/sizeof(int))
 
 
@@ -862,6 +887,8 @@ int spcini(struct spcprm *spc);
 
 int spcfree(struct spcprm *spc);
 
+int spcsize(const struct spcprm *spc, int sizes[2]);
+
 int spcprt(const struct spcprm *spc);
 
 int spcperr(const struct spcprm *spc, const char *prefix);
@@ -893,7 +920,7 @@ int spctrne(const char ctypeS1[9], doubl
 int spcaips(const char ctypeA[9], int velref, char ctype[9], char specsys[9]);
 
 
-/* Deprecated. */
+// Deprecated.
 #define spcini_errmsg spc_errmsg
 #define spcprt_errmsg spc_errmsg
 #define spcset_errmsg spc_errmsg
@@ -916,4 +943,4 @@ int spctrn(const char ctypeS1[9], double
 }
 #endif
 
-#endif /* WCSLIB_SPC */
+#endif // WCSLIB_SPC
Index: astropy-4.2.1/cextern/wcslib/C/sph.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/sph.c
+++ astropy-4.2.1/cextern/wcslib/C/sph.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: sph.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: sph.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -33,7 +30,7 @@
 
 #define tol 1.0e-5
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sphx2s(
   const double eul[5],
@@ -64,10 +61,10 @@ int sphx2s(
   }
 
 
-  /* Check for special-case rotations. */
+  // Check for special-case rotations.
   if (eul[4] == 0.0) {
     if (eul[1] == 0.0) {
-      /* Simple change in origin of longitude. */
+      // Simple change in origin of longitude.
       dlng = fmod(eul[0] + 180.0 - eul[2], 360.0);
 
       jphi   = 0;
@@ -80,7 +77,7 @@ int sphx2s(
           *lngp = *phip + dlng;
           *latp = *thetap;
 
-          /* Normalize the celestial longitude. */
+          // Normalize the celestial longitude.
           if (eul[0] >= 0.0) {
             if (*lngp < 0.0) *lngp += 360.0;
           } else {
@@ -99,7 +96,7 @@ int sphx2s(
       }
 
     } else {
-      /* Pole-flip with change in origin of longitude. */
+      // Pole-flip with change in origin of longitude.
       dlng = fmod(eul[0] + eul[2], 360.0);
 
       jphi   = 0;
@@ -112,7 +109,7 @@ int sphx2s(
           *lngp = dlng - *phip;
           *latp = -(*thetap);
 
-          /* Normalize the celestial longitude. */
+          // Normalize the celestial longitude.
           if (eul[0] >= 0.0) {
             if (*lngp < 0.0) *lngp += 360.0;
           } else {
@@ -135,7 +132,7 @@ int sphx2s(
   }
 
 
-  /* Do phi dependency. */
+  // Do phi dependency.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sll;
@@ -150,7 +147,7 @@ int sphx2s(
   }
 
 
-  /* Do theta dependency. */
+  // Do theta dependency.
   thetap = theta;
   lngp = lng;
   latp = lat;
@@ -165,10 +162,10 @@ int sphx2s(
       dphi = *lngp;
       sincosd(dphi, &sinphi, &cosphi);
 
-      /* Compute the celestial longitude. */
+      // Compute the celestial longitude.
       x = sinthe4 - costhe3*cosphi;
       if (fabs(x) < tol) {
-        /* Rearrange formula to reduce roundoff errors. */
+        // Rearrange formula to reduce roundoff errors.
         x = -cosd(*thetap + eul[1]) + costhe3*(1.0 - cosphi);
       }
 
@@ -176,7 +173,7 @@ int sphx2s(
       if (x != 0.0 || y != 0.0) {
         dlng = atan2d(y, x);
       } else {
-        /* Change of origin of longitude. */
+        // Change of origin of longitude.
         if (eul[1] < 90.0) {
           dlng =  dphi + 180.0;
         } else {
@@ -185,7 +182,7 @@ int sphx2s(
       }
       *lngp = eul[0] + dlng;
 
-      /* Normalize the celestial longitude. */
+      // Normalize the celestial longitude.
       if (eul[0] >= 0.0) {
         if (*lngp < 0.0) *lngp += 360.0;
       } else {
@@ -198,7 +195,7 @@ int sphx2s(
         *lngp += 360.0;
       }
 
-      /* Compute the celestial latitude. */
+      // Compute the celestial latitude.
       if (fmod(dphi,180.0) == 0.0) {
         *latp = *thetap + cosphi*eul[1];
         if (*latp >  90.0) *latp =  180.0 - *latp;
@@ -206,7 +203,7 @@ int sphx2s(
       } else {
         z = sinthe3 + costhe4*cosphi;
         if (fabs(z) > 0.99) {
-          /* Use an alternative formula for greater accuracy. */
+          // Use an alternative formula for greater accuracy.
           *latp = copysign(acosd(sqrt(x*x+y*y)), z);
         } else {
           *latp = asind(z);
@@ -218,7 +215,7 @@ int sphx2s(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sphs2x(
   const double eul[5],
@@ -249,10 +246,10 @@ int sphs2x(
   }
 
 
-  /* Check for special-case rotations. */
+  // Check for special-case rotations.
   if (eul[4] == 0.0) {
     if (eul[1] == 0.0) {
-      /* Simple change in origin of longitude. */
+      // Simple change in origin of longitude.
       dphi = fmod(eul[2] - 180.0 - eul[0], 360.0);
 
       jlng   = 0;
@@ -265,7 +262,7 @@ int sphs2x(
           *phip = fmod(*lngp + dphi, 360.0);
           *thetap = *latp;
 
-          /* Normalize the native longitude. */
+          // Normalize the native longitude.
           if (*phip > 180.0) {
             *phip -= 360.0;
           } else if (*phip < -180.0) {
@@ -278,7 +275,7 @@ int sphs2x(
       }
 
     } else {
-      /* Pole-flip with change in origin of longitude. */
+      // Pole-flip with change in origin of longitude.
       dphi = fmod(eul[2] + eul[0], 360.0);
 
       jlng   = 0;
@@ -291,7 +288,7 @@ int sphs2x(
           *phip = fmod(dphi - *lngp, 360.0);
           *thetap = -(*latp);
 
-          /* Normalize the native longitude. */
+          // Normalize the native longitude.
           if (*phip > 180.0) {
             *phip -= 360.0;
           } else if (*phip < -180.0) {
@@ -308,7 +305,7 @@ int sphs2x(
   }
 
 
-  /* Do lng dependency. */
+  // Do lng dependency.
   lngp = lng;
   rowoff = 0;
   rowlen = nlng*spt;
@@ -324,7 +321,7 @@ int sphs2x(
   }
 
 
-  /* Do lat dependency. */
+  // Do lat dependency.
   latp = lat;
   phip   = phi;
   thetap = theta;
@@ -339,10 +336,10 @@ int sphs2x(
       dlng = *phip;
       sincosd(dlng, &sinlng, &coslng);
 
-      /* Compute the native longitude. */
+      // Compute the native longitude.
       x = sinlat4 - coslat3*coslng;
       if (fabs(x) < tol) {
-        /* Rearrange formula to reduce roundoff errors. */
+        // Rearrange formula to reduce roundoff errors.
         x = -cosd(*latp+eul[1]) + coslat3*(1.0 - coslng);
       }
 
@@ -350,7 +347,7 @@ int sphs2x(
       if (x != 0.0 || y != 0.0) {
         dphi = atan2d(y, x);
       } else {
-        /* Change of origin of longitude. */
+        // Change of origin of longitude.
         if (eul[1] < 90.0) {
           dphi =  dlng - 180.0;
         } else {
@@ -359,14 +356,14 @@ int sphs2x(
       }
       *phip = fmod(eul[2] + dphi, 360.0);
 
-      /* Normalize the native longitude. */
+      // Normalize the native longitude.
       if (*phip > 180.0) {
         *phip -= 360.0;
       } else if (*phip < -180.0) {
         *phip += 360.0;
       }
 
-      /* Compute the native latitude. */
+      // Compute the native latitude.
       if (fmod(dlng,180.0) == 0.0) {
         *thetap = *latp + coslng*eul[1];
         if (*thetap >  90.0) *thetap =  180.0 - *thetap;
@@ -374,7 +371,7 @@ int sphs2x(
       } else {
         z = sinlat3 + coslat4*coslng;
         if (fabs(z) > 0.99) {
-          /* Use an alternative formula for greater accuracy. */
+          // Use an alternative formula for greater accuracy.
           *thetap = copysign(acosd(sqrt(x*x+y*y)), z);
         } else {
           *thetap = asind(z);
@@ -386,7 +383,7 @@ int sphs2x(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sphdpa(
   int nfield,
@@ -401,21 +398,21 @@ int sphdpa(
   int i;
   double eul[5];
 
-  /* Set the Euler angles for the coordinate transformation. */
+  // Set the Euler angles for the coordinate transformation.
   eul[0] = lng0;
   eul[1] = 90.0 - lat0;
   eul[2] = 0.0;
   eul[3] = cosd(eul[1]);
   eul[4] = sind(eul[1]);
 
-  /* Transform field points to the new system. */
+  // Transform field points to the new system.
   sphs2x(eul, nfield, 0, 1, 1, lng, lat, pa, dist);
 
   for (i = 0; i < nfield; i++) {
-    /* Angular distance is obtained from latitude in the new frame. */
+    // Angular distance is obtained from latitude in the new frame.
     dist[i] = 90.0 - dist[i];
 
-    /* Position angle is obtained from longitude in the new frame. */
+    // Position angle is obtained from longitude in the new frame.
     pa[i] = -pa[i];
     if (pa[i] < -180.0) pa[i] += 360.0;
   }
@@ -423,7 +420,7 @@ int sphdpa(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sphpad(
   int nfield,
@@ -438,7 +435,7 @@ int sphpad(
   int i;
   double eul[5];
 
-  /* Set the Euler angles for the coordinate transformation. */
+  // Set the Euler angles for the coordinate transformation.
   eul[0] = lng0;
   eul[1] = 90.0 - lat0;
   eul[2] = 0.0;
@@ -446,14 +443,14 @@ int sphpad(
   eul[4] = sind(eul[1]);
 
   for (i = 0; i < nfield; i++) {
-    /* Latitude in the new frame is obtained from angular distance. */
+    // Latitude in the new frame is obtained from angular distance.
     lat[i] = 90.0 - dist[i];
 
-    /* Longitude in the new frame is obtained from position angle. */
+    // Longitude in the new frame is obtained from position angle.
     lng[i] = -pa[i];
   }
 
-  /* Transform field points to the old system. */
+  // Transform field points to the old system.
   sphx2s(eul, nfield, 0, 1, 1, lng, lat, lng, lat);
 
   return 0;
Index: astropy-4.2.1/cextern/wcslib/C/sph.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/sph.h
+++ astropy-4.2.1/cextern/wcslib/C/sph.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: sph.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: sph.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -144,41 +141,41 @@
 *                         0: Success.
 *
 * Notes:
-*   sphdpa() uses sphs2x() to rotate coordinates so that the reference point
-*   is at the north pole of the new system with the north pole of the old
-*   system at zero longitude in the new.  The Euler angles required by
-*   sphs2x() for this rotation are
-*
-=     eul[0] = lng0;
-=     eul[1] = 90.0 - lat0;
-=     eul[2] =  0.0;
-*
-*   The angular distance and generalized position angle are readily obtained
-*   from the longitude and latitude of the field point in the new system.
-*   This applies even if the reference point is at one of the poles, in which
-*   case the "position angle" returned is as would be computed for a reference
-*   point at (lng0,+90-epsilon) or (lng0,-90+epsilon), in the limit as epsilon
-*   goes to zero.
-*
-*   It is evident that the coordinate system in which the two points are
-*   expressed is irrelevant to the determination of the angular separation
-*   between the points.  However, this is not true of the generalized position
-*   angle.
-*
-*   The generalized position angle is here defined as the angle of
-*   intersection of the great circle containing the reference and field points
-*   with that containing the reference point and the pole.  It has its normal
-*   meaning when the the reference and field points are specified in
-*   equatorial coordinates (right ascension and declination).
-*
-*   Interchanging the reference and field points changes the position angle in
-*   a non-intuitive way (because the sum of the angles of a spherical triangle
-*   normally exceeds 180 degrees).
-*
-*   The position angle is undefined if the reference and field points are
-*   coincident or antipodal.  This may be detected by checking for a distance
-*   of 0 or 180 degrees (within rounding tolerance).  sphdpa() will return an
-*   arbitrary position angle in such circumstances.
+*   1. sphdpa() uses sphs2x() to rotate coordinates so that the reference
+*      point is at the north pole of the new system with the north pole of the
+*      old system at zero longitude in the new.  The Euler angles required by
+*      sphs2x() for this rotation are
+*
+=        eul[0] = lng0;
+=        eul[1] = 90.0 - lat0;
+=        eul[2] =  0.0;
+*
+*      The angular distance and generalized position angle are readily
+*      obtained from the longitude and latitude of the field point in the new
+*      system.  This applies even if the reference point is at one of the
+*      poles, in which case the "position angle" returned is as would be
+*      computed for a reference point at (lng0,+90-epsilon) or
+*      (lng0,-90+epsilon), in the limit as epsilon goes to zero.
+*
+*      It is evident that the coordinate system in which the two points are
+*      expressed is irrelevant to the determination of the angular separation
+*      between the points.  However, this is not true of the generalized
+*      position angle.
+*
+*      The generalized position angle is here defined as the angle of
+*      intersection of the great circle containing the reference and field
+*      points with that containing the reference point and the pole.  It has
+*      its normal meaning when the the reference and field points are
+*      specified in equatorial coordinates (right ascension and declination).
+*
+*      Interchanging the reference and field points changes the position angle
+*      in a non-intuitive way (because the sum of the angles of a spherical
+*      triangle normally exceeds 180 degrees).
+*
+*      The position angle is undefined if the reference and field points are
+*      coincident or antipodal.  This may be detected by checking for a
+*      distance of 0 or 180 degrees (within rounding tolerance).  sphdpa()
+*      will return an arbitrary position angle in such circumstances.
 *
 *
 * sphpad() - Compute field points offset from a given point
@@ -208,11 +205,11 @@
 *                         0: Success.
 *
 * Notes:
-*   sphpad() is implemented analogously to sphdpa() although using sphx2s()
-*   for the inverse transformation.  In particular, when the reference point
-*   is at one of the poles, "position angle" is interpreted as though the
-*   reference point was at (lng0,+90-epsilon) or (lng0,-90+epsilon), in the
-*   limit as epsilon goes to zero.
+*   1: sphpad() is implemented analogously to sphdpa() although using sphx2s()
+*      for the inverse transformation.  In particular, when the reference
+*      point is at one of the poles, "position angle" is interpreted as though
+*      the reference point was at (lng0,+90-epsilon) or (lng0,-90+epsilon), in
+*      the limit as epsilon goes to zero.
 *
 *   Applying sphpad() with the distances and position angles computed by
 *   sphdpa() should return the original field points.
@@ -248,4 +245,4 @@ int sphpad(int nfield, double lng0, doub
 }
 #endif
 
-#endif /* WCSLIB_SPH */
+#endif // WCSLIB_SPH
Index: astropy-4.2.1/cextern/wcslib/C/spx.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/spx.c
+++ astropy-4.2.1/cextern/wcslib/C/spx.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: spx.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: spx.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -34,7 +31,7 @@
 #include "spx.h"
 
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *spx_errmsg[] = {
   "Success",
   "Null spxprm pointer passed",
@@ -42,7 +39,7 @@ const char *spx_errmsg[] = {
   "Invalid spectral variable",
   "One or more of the inspec coordinates were invalid"};
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define SPX_ERRMSG(status) WCSERR_SET(status), spx_errmsg[status]
 
 #define C 2.99792458e8
@@ -75,10 +72,10 @@ int specx(
   haverest = 1;
   if (restfrq == 0.0) {
     if (restwav == 0.0) {
-      /* No line rest frequency supplied. */
+      // No line rest frequency supplied.
       haverest = 0;
 
-      /* Temporarily set a dummy value for conversions. */
+      // Temporarily set a dummy value for conversions.
       spx->restwav = 1.0;
     } else {
       spx->restwav = restwav;
@@ -92,7 +89,7 @@ int specx(
 
   spx->err = 0x0;
 
-  /* Convert to frequency. */
+  // Convert to frequency.
   spx->wavetype = 0;
   spx->velotype = 0;
   if (strcmp(type, "FREQ") == 0) {
@@ -188,13 +185,13 @@ int specx(
     spx->velotype = 1;
 
   } else {
-    /* Unrecognized type. */
+    // Unrecognized type.
     return wcserr_set(WCSERR_SET(SPXERR_BAD_SPEC_PARAMS),
       "Unrecognized spectral type '%s'", type);
   }
 
 
-  /* Convert frequency to the other spectral types. */
+  // Convert frequency to the other spectral types.
   n = 1.0;
   for (k = 0; k < 4; k++) {
     s = n*spx->freq/C;
@@ -219,7 +216,7 @@ int specx(
   spx->velo = C*(1.0 - s*s)/(1.0 + s*s);
   spx->beta = spx->velo/C;
 
-  /* Compute the required derivatives. */
+  // Compute the required derivatives.
   gamma = 1.0/sqrt(1.0 - spx->beta*spx->beta);
 
   spx->dfreqafrq = 1.0/(2.0*PI);
@@ -262,7 +259,7 @@ int specx(
   spx->dbetavelo = 1.0/spx->dvelobeta;
 
 
-  /* Reset values if no line rest frequency was supplied. */
+  // Reset values if no line rest frequency was supplied.
   if (haverest) {
     spx->wavetype = 1;
     spx->velotype = 1;
@@ -272,7 +269,7 @@ int specx(
     spx->restwav = 0.0;
 
     if (!spx->wavetype) {
-      /* Don't have wave characteristic types. */
+      // Don't have wave characteristic types.
       spx->freq = 0.0;
       spx->afrq = 0.0;
       spx->ener = 0.0;
@@ -290,7 +287,7 @@ int specx(
       spx->dawavwave = 0.0;
 
     } else {
-      /* Don't have velocity types. */
+      // Don't have velocity types.
       spx->vrad = 0.0;
       spx->vopt = 0.0;
       spx->zopt = 0.0;
@@ -320,7 +317,7 @@ int specx(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spxperr(const struct spxprm *spx, const char *prefix)
 
@@ -354,7 +351,7 @@ int freqwave(
   register const double *freqp;
   register double *wavep;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   freqp = freq;
@@ -376,7 +373,7 @@ int freqwave(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wavefreq(
   double dummy,
@@ -393,7 +390,7 @@ int wavefreq(
   register const double *wavep;
   register double *freqp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   wavep = wave;
@@ -438,7 +435,7 @@ int freqawav(
   return waveawav(dummy, nfreq, sawav, sawav, awav, awav, stat);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int awavfreq(
   double dummy,
@@ -495,7 +492,7 @@ int freqvelo(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int velofreq(
   double restfrq,
@@ -553,7 +550,7 @@ int waveawav(
   register const double *wavep;
   register double *awavp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   wavep = wave;
@@ -584,7 +581,7 @@ int waveawav(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int awavwave(
   double dummy,
@@ -602,7 +599,7 @@ int awavwave(
   register const double *awavp;
   register double *wavep;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   awavp = awav;
@@ -665,7 +662,7 @@ int wavevelo(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int velowave(
   double restwav,
@@ -726,7 +723,7 @@ int awavvelo(
   return wavevelo(dummy, nawav, svelo, svelo, velo, velo, stat);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int veloawav(
   double dummy,
@@ -765,7 +762,7 @@ int freqafrq(
   register const double *freqp;
   register double *afrqp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   freqp = freq;
@@ -782,7 +779,7 @@ int freqafrq(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int afrqfreq(
   double dummy,
@@ -798,7 +795,7 @@ int afrqfreq(
   register const double *afrqp;
   register double *freqp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   afrqp = afrq;
@@ -833,7 +830,7 @@ int freqener(
   register const double *freqp;
   register double *enerp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   freqp = freq;
@@ -850,7 +847,7 @@ int freqener(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int enerfreq(
   double dummy,
@@ -866,7 +863,7 @@ int enerfreq(
   register const double *enerp;
   register double *freqp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   enerp = ener;
@@ -901,7 +898,7 @@ int freqwavn(
   register const double *freqp;
   register double *wavnp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   freqp = freq;
@@ -918,7 +915,7 @@ int freqwavn(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wavnfreq(
   double dummy,
@@ -934,7 +931,7 @@ int wavnfreq(
   register const double *wavnp;
   register double *freqp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   wavnp = wavn;
@@ -989,7 +986,7 @@ int freqvrad(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int vradfreq(
   double restfrq,
@@ -1058,7 +1055,7 @@ int wavevopt(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int voptwave(
   double restwav,
@@ -1127,7 +1124,7 @@ int wavezopt(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int zoptwave(
   double restwav,
@@ -1174,7 +1171,7 @@ int velobeta(
   register const double *velop;
   register double *betap;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   velop = velo;
@@ -1191,7 +1188,7 @@ int velobeta(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int betavelo(
   double dummy,
@@ -1207,7 +1204,7 @@ int betavelo(
   register const double *betap;
   register double *velop;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   betap = beta;
Index: astropy-4.2.1/cextern/wcslib/C/spx.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/spx.h
+++ astropy-4.2.1/cextern/wcslib/C/spx.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: spx.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: spx.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -477,60 +474,60 @@ extern "C" {
 extern const char *spx_errmsg[];
 
 enum spx_errmsg {
-  SPXERR_SUCCESS          = 0,	/* Success. */
-  SPXERR_NULL_POINTER     = 1,	/* Null spxprm pointer passed. */
-  SPXERR_BAD_SPEC_PARAMS  = 2,	/* Invalid spectral parameters. */
-  SPXERR_BAD_SPEC_VAR     = 3,	/* Invalid spectral variable. */
-  SPXERR_BAD_INSPEC_COORD = 4 	/* One or more of the inspec coordinates were
-				   invalid. */
+  SPXERR_SUCCESS          = 0,	// Success.
+  SPXERR_NULL_POINTER     = 1,	// Null spxprm pointer passed.
+  SPXERR_BAD_SPEC_PARAMS  = 2,	// Invalid spectral parameters.
+  SPXERR_BAD_SPEC_VAR     = 3,	// Invalid spectral variable.
+  SPXERR_BAD_INSPEC_COORD = 4 	// One or more of the inspec coordinates were
+				// invalid.
 };
 
 struct spxprm {
-  double restfrq, restwav;	/* Rest frequency [Hz] and wavelength [m].  */
+  double restfrq, restwav;	// Rest frequency [Hz] and wavelength [m].
 
-  int wavetype, velotype;	/* True if wave/velocity types have been    */
-				/* computed; types are defined below.       */
+  int wavetype, velotype;	// True if wave/velocity types have been
+				// computed; types are defined below.
 
-  /* Spectral variables computed by specx().                                */
-  /*------------------------------------------------------------------------*/
-  double freq,			/* wavetype: Frequency [Hz].                */
-         afrq,			/* wavetype: Angular frequency [rad/s].     */
-         ener,			/* wavetype: Photon energy [J].             */
-         wavn,			/* wavetype: Wave number [/m].              */
-         vrad,			/* velotype: Radio velocity [m/s].          */
-         wave,			/* wavetype: Vacuum wavelength [m].         */
-         vopt,			/* velotype: Optical velocity [m/s].        */
-         zopt,			/* velotype: Redshift.                      */
-         awav,			/* wavetype: Air wavelength [m].            */
-         velo,			/* velotype: Relativistic velocity [m/s].   */
-         beta;			/* velotype: Relativistic beta.             */
-
-  /* Derivatives of spectral variables computed by specx().                 */
-  /*------------------------------------------------------------------------*/
-  double dfreqafrq, dafrqfreq,	/* Constant, always available.              */
-         dfreqener, denerfreq,	/* Constant, always available.              */
-         dfreqwavn, dwavnfreq,	/* Constant, always available.              */
-         dfreqvrad, dvradfreq,	/* wavetype && velotype.                    */
-         dfreqwave, dwavefreq,	/* wavetype.                                */
-         dfreqawav, dawavfreq,	/* wavetype.                                */
-         dfreqvelo, dvelofreq,	/* wavetype && velotype.                    */
-         dwavevopt, dvoptwave,	/* wavetype && velotype.                    */
-         dwavezopt, dzoptwave,	/* wavetype && velotype.                    */
-         dwaveawav, dawavwave,	/* wavetype.                                */
-         dwavevelo, dvelowave,	/* wavetype && velotype.                    */
-         dawavvelo, dveloawav,	/* wavetype && velotype.                    */
-         dvelobeta, dbetavelo;	/* Constant, always available.              */
+  // Spectral variables computed by specx().
+  //--------------------------------------------------------------------------
+  double freq,			// wavetype: Frequency [Hz].
+         afrq,			// wavetype: Angular frequency [rad/s].
+         ener,			// wavetype: Photon energy [J].
+         wavn,			// wavetype: Wave number [/m].
+         vrad,			// velotype: Radio velocity [m/s].
+         wave,			// wavetype: Vacuum wavelength [m].
+         vopt,			// velotype: Optical velocity [m/s].
+         zopt,			// velotype: Redshift.
+         awav,			// wavetype: Air wavelength [m].
+         velo,			// velotype: Relativistic velocity [m/s].
+         beta;			// velotype: Relativistic beta.
+
+  // Derivatives of spectral variables computed by specx().
+  //--------------------------------------------------------------------------
+  double dfreqafrq, dafrqfreq,	// Constant, always available.
+         dfreqener, denerfreq,	// Constant, always available.
+         dfreqwavn, dwavnfreq,	// Constant, always available.
+         dfreqvrad, dvradfreq,	// wavetype && velotype.
+         dfreqwave, dwavefreq,	// wavetype.
+         dfreqawav, dawavfreq,	// wavetype.
+         dfreqvelo, dvelofreq,	// wavetype && velotype.
+         dwavevopt, dvoptwave,	// wavetype && velotype.
+         dwavezopt, dzoptwave,	// wavetype && velotype.
+         dwaveawav, dawavwave,	// wavetype.
+         dwavevelo, dvelowave,	// wavetype && velotype.
+         dawavvelo, dveloawav,	// wavetype && velotype.
+         dvelobeta, dbetavelo;	// Constant, always available.
 
-  /* Error handling                                                         */
-  /*------------------------------------------------------------------------*/
+  // Error handling
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private                                                                */
-  /*------------------------------------------------------------------------*/
-  void   *padding;		/* (Dummy inserted for alignment purposes.) */
+  // Private
+  //--------------------------------------------------------------------------
+  void   *padding;		// (Dummy inserted for alignment purposes.)
 };
 
-/* Size of the spxprm struct in int units, used by the Fortran wrappers. */
+// Size of the spxprm struct in int units, used by the Fortran wrappers.
 #define SPXLEN (sizeof(struct spxprm)/sizeof(int))
 
 
@@ -539,7 +536,7 @@ int specx(const char *type, double spec,
 
 int spxperr(const struct spxprm *spx, const char *prefix);
 
-/* For use in declaring function prototypes, e.g. in spcprm. */
+// For use in declaring function prototypes, e.g. in spcprm.
 #define SPX_ARGS double param, int nspec, int instep, int outstep, \
     const double inspec[], double outspec[], int stat[]
 
@@ -589,4 +586,4 @@ int zoptwave(SPX_ARGS);
 }
 #endif
 
-#endif /* WCSLIB_SPEC */
+#endif // WCSLIB_SPEC
Index: astropy-4.2.1/cextern/wcslib/C/tab.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/tab.c
+++ astropy-4.2.1/cextern/wcslib/C/tab.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: tab.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: tab.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -38,7 +35,7 @@
 
 const int TABSET = 137;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *tab_errmsg[] = {
   "Success",
   "Null tabprm pointer passed",
@@ -47,27 +44,23 @@ const char *tab_errmsg[] = {
   "One or more of the x coordinates were invalid",
   "One or more of the world coordinates were invalid"};
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define TAB_ERRMSG(status) WCSERR_SET(status), tab_errmsg[status]
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabini(int alloc, int M, const int K[], struct tabprm *tab)
 
 {
   static const char *function = "tabini";
 
-  int k, m, N;
-  double *dp;
-  struct wcserr **err;
-
   if (tab == 0x0) return TABERR_NULL_POINTER;
 
-  /* Initialize error message handling. */
+  // Initialize error message handling.
   if (tab->flag == -1) {
     tab->err = 0x0;
   }
-  err = &(tab->err);
+  struct wcserr **err = &(tab->err);
   wcserr_clear(err);
 
 
@@ -76,11 +69,12 @@ int tabini(int alloc, int M, const int K
       "M must be positive, got %d", M);
   }
 
-  /* Determine the total number of elements in the coordinate array. */
+  // Determine the total number of elements in the coordinate array.
+  int N;
   if (K) {
     N = M;
 
-    for (m = 0; m < M; m++) {
+    for (int m = 0; m < M; m++) {
       if (K[m] < 0) {
         return wcserr_set(WCSERR_SET(TABERR_BAD_PARAMS),
           "Invalid tabular parameters: Each element of K must be "
@@ -91,12 +85,12 @@ int tabini(int alloc, int M, const int K
     }
 
   } else {
-    /* Axis lengths as yet unknown. */
+    // Axis lengths as yet unknown.
     N = 0;
   }
 
 
-  /* Initialize memory management. */
+  // Initialize memory management.
   if (tab->flag == -1 || tab->m_flag != TABSET) {
     if (tab->flag == -1) {
       tab->sense   = 0x0;
@@ -117,8 +111,8 @@ int tabini(int alloc, int M, const int K
     tab->m_coord = 0x0;
 
   } else {
-    /* Clear any outstanding signals set by wcstab(). */
-    for (m = 0; m < tab->m_M; m++) {
+    // Clear any outstanding signals set by wcstab().
+    for (int m = 0; m < tab->m_M; m++) {
       if (tab->m_indxs[m] == (double *)0x1) tab->m_indxs[m] = 0x0;
     }
 
@@ -126,7 +120,7 @@ int tabini(int alloc, int M, const int K
   }
 
 
-  /* Allocate memory for arrays if required. */
+  // Allocate memory for arrays if required.
   if (alloc ||
      tab->K == 0x0 ||
      tab->map == 0x0 ||
@@ -134,15 +128,15 @@ int tabini(int alloc, int M, const int K
      tab->index == 0x0 ||
      tab->coord == 0x0) {
 
-    /* Was sufficient allocated previously? */
+    // Was sufficient allocated previously?
     if (tab->m_flag == TABSET && (tab->m_M < M || tab->m_N < N)) {
-      /* No, free it. */
+      // No, free it.
       tabfree(tab);
     }
 
     if (alloc || tab->K == 0x0) {
       if (tab->m_K) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         tab->K = tab->m_K;
 
       } else {
@@ -158,7 +152,7 @@ int tabini(int alloc, int M, const int K
 
     if (alloc || tab->map == 0x0) {
       if (tab->m_map) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         tab->map = tab->m_map;
 
       } else {
@@ -174,7 +168,7 @@ int tabini(int alloc, int M, const int K
 
     if (alloc || tab->crval == 0x0) {
       if (tab->m_crval) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         tab->crval = tab->m_crval;
 
       } else {
@@ -190,7 +184,7 @@ int tabini(int alloc, int M, const int K
 
     if (alloc || tab->index == 0x0) {
       if (tab->m_index) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         tab->index = tab->m_index;
 
       } else {
@@ -207,9 +201,9 @@ int tabini(int alloc, int M, const int K
           return wcserr_set(TAB_ERRMSG(TABERR_MEMORY));
         }
 
-        /* Recall that calloc() initializes these pointers to zero. */
+        // Recall that calloc() initializes these pointers to zero.
         if (K) {
-          for (m = 0; m < M; m++) {
+          for (int m = 0; m < M; m++) {
             if (K[m]) {
               if (!(tab->index[m] = calloc(K[m], sizeof(double)))) {
                 return wcserr_set(TAB_ERRMSG(TABERR_MEMORY));
@@ -224,7 +218,7 @@ int tabini(int alloc, int M, const int K
 
     if (alloc || tab->coord == 0x0) {
       if (tab->m_coord) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         tab->coord = tab->m_coord;
 
       } else if (N) {
@@ -243,15 +237,16 @@ int tabini(int alloc, int M, const int K
   tab->flag = 0;
   tab->M = M;
 
-  /* Set defaults. */
-  for (m = 0; m < M; m++) {
+  // Set defaults.
+  for (int m = 0; m < M; m++) {
     tab->map[m] = -1;
     tab->crval[m] = 0.0;
 
     if (K) {
       tab->K[m] = K[m];
+      double *dp;
       if ((dp = tab->index[m])) {
-        for (k = 0; k < K[m]; k++) {
+        for (int k = 0; k < K[m]; k++) {
           *(dp++) = k;
         }
       }
@@ -260,36 +255,34 @@ int tabini(int alloc, int M, const int K
     }
   }
 
-  /* Initialize the coordinate array. */
-  for (dp = tab->coord; dp < tab->coord + N; dp++) {
+  // Initialize the coordinate array.
+  for (double *dp = tab->coord; dp < tab->coord + N; dp++) {
     *dp = UNDEFINED;
   }
 
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabmem(struct tabprm *tab)
 
 {
   static const char *function = "tabmem";
 
-  int m, M, N;
-  struct wcserr **err;
-
   if (tab == 0x0) return TABERR_NULL_POINTER;
-  err = &(tab->err);
+  struct wcserr **err = &(tab->err);
 
   if (tab->M == 0 || tab->K == 0x0) {
-    /* Should have been set by this time. */
+    // Should have been set by this time.
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "Null pointers in tabprm struct");
   }
 
 
-  N = M = tab->M;
-  for (m = 0; m < M; m++) {
+  int M = tab->M;
+  int N = tab->M;
+  for (int m = 0; m < M; m++) {
     if (tab->K[m] < 0) {
       return wcserr_set(WCSERR_SET(TABERR_BAD_PARAMS),
         "Invalid tabular parameters: Each element of K must be "
@@ -303,7 +296,7 @@ int tabmem(struct tabprm *tab)
   if (tab->m_M == 0) {
     tab->m_M = M;
   } else if (tab->m_M < M) {
-    /* Only possible if the user changed M. */
+    // Only possible if the user changed M.
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "tabprm struct inconsistent");
   }
@@ -311,7 +304,7 @@ int tabmem(struct tabprm *tab)
   if (tab->m_N == 0) {
     tab->m_N = N;
   } else if (tab->m_N < N) {
-    /* Only possible if the user changed K[]. */
+    // Only possible if the user changed K[].
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "tabprm struct inconsistent");
   }
@@ -340,7 +333,7 @@ int tabmem(struct tabprm *tab)
     }
   }
 
-  for (m = 0; m < tab->m_M; m++) {
+  for (int m = 0; m < tab->m_M; m++) {
     if (tab->m_indxs[m] == 0x0 || tab->m_indxs[m] == (double *)0x1) {
       if ((tab->m_indxs[m] = tab->index[m])) {
         tab->m_flag = TABSET;
@@ -359,22 +352,20 @@ int tabmem(struct tabprm *tab)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabcpy(int alloc, const struct tabprm *tabsrc, struct tabprm *tabdst)
 
 {
   static const char *function = "tabcpy";
 
-  int k, m, M, n, N, status;
-  double *dstp, *srcp;
-  struct wcserr **err;
+  int status;
 
   if (tabsrc == 0x0) return TABERR_NULL_POINTER;
   if (tabdst == 0x0) return TABERR_NULL_POINTER;
-  err = &(tabdst->err);
+  struct wcserr **err = &(tabdst->err);
 
-  M = tabsrc->M;
+  int M = tabsrc->M;
   if (M <= 0) {
     return wcserr_set(WCSERR_SET(TABERR_BAD_PARAMS),
       "M must be positive, got %d", M);
@@ -384,17 +375,18 @@ int tabcpy(int alloc, const struct tabpr
     return status;
   }
 
-  N = M;
-  for (m = 0; m < M; m++) {
+  int N = M;
+  for (int m = 0; m < M; m++) {
     tabdst->map[m]   = tabsrc->map[m];
     tabdst->crval[m] = tabsrc->crval[m];
     N *= tabsrc->K[m];
   }
 
-  for (m = 0; m < M; m++) {
+  double *dstp, *srcp;
+  for (int m = 0; m < M; m++) {
     if ((srcp = tabsrc->index[m])) {
       dstp = tabdst->index[m];
-      for (k = 0; k < tabsrc->K[m]; k++) {
+      for (int k = 0; k < tabsrc->K[m]; k++) {
         *(dstp++) = *(srcp++);
       }
     }
@@ -402,14 +394,14 @@ int tabcpy(int alloc, const struct tabpr
 
   srcp = tabsrc->coord;
   dstp = tabdst->coord;
-  for (n = 0; n < N; n++) {
+  for (int n = 0; n < N; n++) {
     *(dstp++) = *(srcp++);
   }
 
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabcmp(
   int dummy,
@@ -419,9 +411,7 @@ int tabcmp(
   int *equal)
 
 {
-  int m, M, N;
-
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   if (tab1  == 0x0) return TABERR_NULL_POINTER;
@@ -434,24 +424,24 @@ int tabcmp(
     return 0;
   }
 
-  M = tab1->M;
+  int M = tab1->M;
 
   if (!wcsutil_intEq(M, tab1->K, tab2->K) ||
       !wcsutil_intEq(M, tab1->map, tab2->map) ||
-      !wcsutil_Eq(M, tol, tab1->crval, tab2->crval)) {
+      !wcsutil_dblEq(M, tol, tab1->crval, tab2->crval)) {
     return 0;
   }
 
-  N = M;
-  for (m = 0; m < M; m++) {
-    if (!wcsutil_Eq(tab1->K[m], tol, tab1->index[m], tab2->index[m])) {
+  int N = M;
+  for (int m = 0; m < M; m++) {
+    if (!wcsutil_dblEq(tab1->K[m], tol, tab1->index[m], tab2->index[m])) {
       return 0;
     }
 
     N *= tab1->K[m];
   }
 
-  if (!wcsutil_Eq(N, tol, tab1->coord, tab2->coord)) {
+  if (!wcsutil_dblEq(N, tol, tab1->coord, tab2->coord)) {
     return 0;
   }
 
@@ -461,24 +451,22 @@ int tabcmp(
 }
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabfree(struct tabprm *tab)
 
 {
-  int m;
-
   if (tab == 0x0) return TABERR_NULL_POINTER;
 
   if (tab->flag != -1) {
-    /* Clear any outstanding signals set by wcstab(). */
-    for (m = 0; m < tab->m_M; m++) {
+    // Clear any outstanding signals set by wcstab().
+    for (int m = 0; m < tab->m_M; m++) {
       if (tab->m_indxs[m] == (double *)0x1) tab->m_indxs[m] = 0x0;
     }
 
     if (tab->m_coord == (double *)0x1) tab->m_coord = 0x0;
 
-    /* Free memory allocated by tabini(). */
+    // Free memory allocated by tabini().
     if (tab->m_flag == TABSET) {
       if (tab->K     == tab->m_K)     tab->K = 0x0;
       if (tab->map   == tab->m_map)   tab->map = 0x0;
@@ -491,7 +479,7 @@ int tabfree(struct tabprm *tab)
       if (tab->m_crval) free(tab->m_crval);
 
       if (tab->m_index) {
-        for (m = 0; m < tab->m_M; m++) {
+        for (int m = 0; m < tab->m_M; m++) {
           if (tab->m_indxs[m]) free(tab->m_indxs[m]);
         }
         free(tab->m_index);
@@ -501,7 +489,7 @@ int tabfree(struct tabprm *tab)
       if (tab->m_coord) free(tab->m_coord);
     }
 
-    /* Free memory allocated by tabset(). */
+    // Free memory allocated by tabset().
     if (tab->sense)   free(tab->sense);
     if (tab->p0)      free(tab->p0);
     if (tab->delta)   free(tab->delta);
@@ -531,13 +519,82 @@ int tabfree(struct tabprm *tab)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
+
+int tabsize(const struct tabprm *tab, int sizes[2])
+
+{
+  if (tab == 0x0) {
+    sizes[0] = sizes[1] = 0;
+    return TABERR_SUCCESS;
+  }
+
+  // Base size, in bytes.
+  sizes[0] = sizeof(struct tabprm);
+
+  // Total size of allocated memory, in bytes.
+  sizes[1] = 0;
+
+  int exsizes[2];
+  int M = tab->M;
+
+  // tabprm::K[];
+  sizes[1] += M * sizeof(int);
+
+  // tabprm::map[];
+  sizes[1] += M * sizeof(int);
+
+  // tabprm::crval[];
+  sizes[1] += M * sizeof(double);
+
+  // tabprm::index[] and tabprm::m_indxs;
+  sizes[1] += 2*M * sizeof(double *);
+  for (int m = 0; m < M; m++) {
+    if (tab->index[m]) {
+      sizes[1] += tab->K[m] * sizeof(double);
+    }
+  }
+
+  // tabprm::coord[];
+  sizes[1] += M * tab->nc * sizeof(double);
+
+  // tab::err[].
+  wcserr_size(tab->err, exsizes);
+  sizes[1] += exsizes[0] + exsizes[1];
+
+  // The remaining arrays are allocated by tabset().
+  if (tab->flag != TABSET) {
+    return TABERR_SUCCESS;
+  }
+
+  // tabprm::sense[].
+  if (tab->sense) {
+    sizes[1] += M * sizeof(int);
+  }
+
+  // tabprm::p0[].
+  if (tab->p0) {
+    sizes[1] += M * sizeof(int);
+  }
+
+  // tabprm::delta[].
+  if (tab->delta) {
+    sizes[1] += M * sizeof(double);
+  }
+
+  // tabprm::extrema[].
+  int ne = (tab->nc / tab->K[0]) * 2 * M;
+  sizes[1] += ne * sizeof(double);
+
+  return TABERR_SUCCESS;
+}
+
+//----------------------------------------------------------------------------
 
 int tabprt(const struct tabprm *tab)
 
 {
   char   *cp, text[128];
-  int    j, k, m, n, nd;
   double *dp;
 
   if (tab == 0x0) return TABERR_NULL_POINTER;
@@ -550,37 +607,37 @@ int tabprt(const struct tabprm *tab)
   wcsprintf("       flag: %d\n", tab->flag);
   wcsprintf("          M: %d\n", tab->M);
 
-  /* Array dimensions. */
+  // Array dimensions.
   WCSPRINTF_PTR("          K: ", tab->K, "\n");
   wcsprintf("            ");
-  for (m = 0; m < tab->M; m++) {
+  for (int m = 0; m < tab->M; m++) {
     wcsprintf("%6d", tab->K[m]);
   }
   wcsprintf("\n");
 
-  /* Map vector. */
+  // Map vector.
   WCSPRINTF_PTR("        map: ", tab->map, "\n");
   wcsprintf("            ");
-  for (m = 0; m < tab->M; m++) {
+  for (int m = 0; m < tab->M; m++) {
     wcsprintf("%6d", tab->map[m]);
   }
   wcsprintf("\n");
 
-  /* Reference index value. */
+  // Reference index value.
   WCSPRINTF_PTR("      crval: ", tab->crval, "\n");
   wcsprintf("            ");
-  for (m = 0; m < tab->M; m++) {
+  for (int m = 0; m < tab->M; m++) {
     wcsprintf("  %#- 11.5g", tab->crval[m]);
   }
   wcsprintf("\n");
 
-  /* Index vectors. */
+  // Index vectors.
   WCSPRINTF_PTR("      index: ", tab->index, "\n");
-  for (m = 0; m < tab->M; m++) {
+  for (int m = 0; m < tab->M; m++) {
     wcsprintf("   index[%d]: ", m);
     WCSPRINTF_PTR("", tab->index[m], "");
     if (tab->index[m]) {
-      for (k = 0; k < tab->K[m]; k++) {
+      for (int k = 0; k < tab->K[m]; k++) {
         if (k%5 == 0) {
           wcsprintf("\n            ");
         }
@@ -590,22 +647,22 @@ int tabprt(const struct tabprm *tab)
     }
   }
 
-  /* Coordinate array. */
+  // Coordinate array.
   WCSPRINTF_PTR("      coord: ", tab->coord, "\n");
   dp = tab->coord;
-  for (n = 0; n < tab->nc; n++) {
-    /* Array index. */
-    j = n;
+  for (int n = 0; n < tab->nc; n++) {
+    // Array index.
+    int j = n;
     cp = text;
-    for (m = 0; m < tab->M; m++) {
-      nd = (tab->K[m] < 10) ? 1 : 2;
+    for (int m = 0; m < tab->M; m++) {
+      int nd = (tab->K[m] < 10) ? 1 : 2;
       sprintf(cp, ",%*d", nd, j % tab->K[m] + 1);
       j /= tab->K[m];
       cp += strlen(cp);
     }
 
     wcsprintf("             (*%s)", text);
-    for (m = 0; m < tab->M; m++) {
+    for (int m = 0; m < tab->M; m++) {
       wcsprintf("  %#- 11.5g", *(dp++));
     }
     wcsprintf("\n");
@@ -616,7 +673,7 @@ int tabprt(const struct tabprm *tab)
   WCSPRINTF_PTR("      sense: ", tab->sense, "\n");
   if (tab->sense) {
     wcsprintf("            ");
-    for (m = 0; m < tab->M; m++) {
+    for (int m = 0; m < tab->M; m++) {
       wcsprintf("%6d", tab->sense[m]);
     }
     wcsprintf("\n");
@@ -625,7 +682,7 @@ int tabprt(const struct tabprm *tab)
   WCSPRINTF_PTR("         p0: ", tab->p0, "\n");
   if (tab->p0) {
     wcsprintf("            ");
-    for (m = 0; m < tab->M; m++) {
+    for (int m = 0; m < tab->M; m++) {
       wcsprintf("%6d", tab->p0[m]);
     }
     wcsprintf("\n");
@@ -634,7 +691,7 @@ int tabprt(const struct tabprm *tab)
   WCSPRINTF_PTR("      delta: ", tab->delta, "\n");
   if (tab->delta) {
     wcsprintf("            ");
-    for (m = 0; m < tab->M; m++) {
+    for (int m = 0; m < tab->M; m++) {
       wcsprintf("  %#- 11.5g", tab->delta[m]);
     }
     wcsprintf("\n");
@@ -642,20 +699,20 @@ int tabprt(const struct tabprm *tab)
 
   WCSPRINTF_PTR("    extrema: ", tab->extrema, "\n");
   dp = tab->extrema;
-  for (n = 0; n < tab->nc/tab->K[0]; n++) {
-    /* Array index. */
-    j = n;
+  for (int n = 0; n < tab->nc/tab->K[0]; n++) {
+    // Array index.
+    int j = n;
     cp = text;
     *cp = '\0';
-    for (m = 1; m < tab->M; m++) {
-      nd = (tab->K[m] < 10) ? 1 : 2;
+    for (int m = 1; m < tab->M; m++) {
+      int nd = (tab->K[m] < 10) ? 1 : 2;
       sprintf(cp, ",%*d", nd, j % tab->K[m] + 1);
       j /= tab->K[m];
       cp += strlen(cp);
     }
 
     wcsprintf("             (*,*%s)", text);
-    for (m = 0; m < 2*tab->M; m++) {
+    for (int m = 0; m < 2*tab->M; m++) {
       if (m == tab->M) wcsprintf("->  ");
       wcsprintf("  %#- 11.5g", *(dp++));
     }
@@ -667,7 +724,7 @@ int tabprt(const struct tabprm *tab)
     wcserr_prt(tab->err, "             ");
   }
 
-  /* Memory management. */
+  // Memory management.
   wcsprintf("     m_flag: %d\n", tab->m_flag);
   wcsprintf("        m_M: %d\n", tab->m_M);
   wcsprintf("        m_N: %d\n", tab->m_N);
@@ -687,7 +744,7 @@ int tabprt(const struct tabprm *tab)
   WCSPRINTF_PTR("    m_index: ", tab->m_index, "");
   if (tab->m_index == tab->index) wcsprintf("  (= index)");
   wcsprintf("\n");
-  for (m = 0; m < tab->M; m++) {
+  for (int m = 0; m < tab->M; m++) {
     wcsprintf(" m_indxs[%d]: ", m);
     WCSPRINTF_PTR("", tab->m_indxs[m], "");
     if (tab->m_indxs[m] == tab->index[m]) wcsprintf("  (= index[%d])", m);
@@ -701,7 +758,7 @@ int tabprt(const struct tabprm *tab)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabperr(const struct tabprm *tab, const char *prefix)
 
@@ -715,52 +772,49 @@ int tabperr(const struct tabprm *tab, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabset(struct tabprm *tab)
 
 {
   static const char *function = "tabset";
 
-  int i, ic, k, *Km, m, M, ne;
-  double *dcrd, *dmax, *dmin, dPsi, dval, *Psi;
-  struct wcserr **err;
-
   if (tab == 0x0) return TABERR_NULL_POINTER;
-  err = &(tab->err);
+  struct wcserr **err = &(tab->err);
 
-  /* Check the number of tabular coordinate axes. */
-  if ((M = tab->M) < 1) {
+  // Check the number of tabular coordinate axes.
+  int M = tab->M;
+  if (M < 1) {
     return wcserr_set(WCSERR_SET(TABERR_BAD_PARAMS),
       "Invalid tabular parameters: M must be positive, got %d", M);
   }
 
-  /* Check the axis lengths. */
+  // Check the axis lengths.
   if (!tab->K) {
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "Null pointers in tabprm struct");
   }
 
   tab->nc = 1;
-  for (m = 0; m < M; m++) {
+  for (int m = 0; m < M; m++) {
     if (tab->K[m] < 1) {
       return wcserr_set(WCSERR_SET(TABERR_BAD_PARAMS),
         "Invalid tabular parameters: Each element of K must be positive, "
         "got %d", tab->K[m]);
     }
 
-    /* Number of coordinate vectors in the coordinate array. */
+    // Number of coordinate vectors in the coordinate array.
     tab->nc *= tab->K[m];
   }
 
-  /* Check that the map vector is sensible. */
+  // Check that the map vector is sensible.
   if (!tab->map) {
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "Null pointers in tabprm struct");
   }
 
-  for (m = 0; m < M; m++) {
-    i = tab->map[m];
+  for (int m = 0; m < M; m++) {
+    int i = tab->map[m];
     if (i < 0) {
       return wcserr_set(WCSERR_SET(TABERR_BAD_PARAMS),
         "Invalid tabular parameters: Each element of map must be "
@@ -768,14 +822,14 @@ int tabset(struct tabprm *tab)
     }
   }
 
-  /* Check memory allocation for the remaining vectors. */
+  // Check memory allocation for the remaining vectors.
   if (!tab->crval || !tab->index || !tab->coord) {
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "Null pointers in tabprm struct");
   }
 
-  /* Take memory if signalled to by wcstab(). */
-  for (m = 0; m < tab->m_M; m++) {
+  // Take memory if signalled to by wcstab().
+  for (int m = 0; m < tab->m_M; m++) {
     if (tab->m_indxs[m] == (double *)0x1 &&
       (tab->m_indxs[m] = tab->index[m])) {
       tab->m_flag = TABSET;
@@ -788,15 +842,15 @@ int tabset(struct tabprm *tab)
   }
 
 
-  /* Allocate memory for work vectors. */
+  // Allocate memory for work vectors.
   if (tab->flag != TABSET || tab->set_M < M) {
-    /* Free memory that may have been allocated previously. */
+    // Free memory that may have been allocated previously.
     if (tab->sense)   free(tab->sense);
     if (tab->p0)      free(tab->p0);
     if (tab->delta)   free(tab->delta);
     if (tab->extrema) free(tab->extrema);
 
-    /* Allocate memory for internal arrays. */
+    // Allocate memory for internal arrays.
     if (!(tab->sense = calloc(M, sizeof(int)))) {
       return wcserr_set(TAB_ERRMSG(TABERR_MEMORY));
     }
@@ -812,7 +866,7 @@ int tabset(struct tabprm *tab)
       return wcserr_set(TAB_ERRMSG(TABERR_MEMORY));
     }
 
-    ne = M * tab->nc * 2 / tab->K[0];
+    int ne = (tab->nc / tab->K[0]) * 2 * M;
     if (!(tab->extrema = calloc(ne, sizeof(double)))) {
       free(tab->sense);
       free(tab->p0);
@@ -823,32 +877,33 @@ int tabset(struct tabprm *tab)
     tab->set_M = M;
   }
 
-  /* Check that the index vectors are monotonic. */
-  Km = tab->K;
-  for (m = 0; m < M; m++, Km++) {
+  // Check that the index vectors are monotonic.
+  int *Km = tab->K;
+  for (int m = 0; m < M; m++, Km++) {
     tab->sense[m] = 0;
 
     if (*Km > 1) {
+      double *Psi;
       if ((Psi = tab->index[m]) == 0x0) {
-        /* Default indexing. */
+        // Default indexing.
         tab->sense[m] = 1;
 
       } else {
-        for (k = 0; k < *Km-1; k++) {
+        for (int k = 0; k < *Km-1; k++) {
           switch (tab->sense[m]) {
           case 0:
             if (Psi[k] < Psi[k+1]) {
-              /* Monotonic increasing. */
+              // Monotonic increasing.
               tab->sense[m] = 1;
             } else if (Psi[k] > Psi[k+1]) {
-              /* Monotonic decreasing. */
+              // Monotonic decreasing.
               tab->sense[m] = -1;
             }
             break;
 
           case 1:
             if (Psi[k] > Psi[k+1]) {
-              /* Should be monotonic increasing. */
+              // Should be monotonic increasing.
               free(tab->sense);
               free(tab->p0);
               free(tab->delta);
@@ -861,7 +916,7 @@ int tabset(struct tabprm *tab)
 
           case -1:
             if (Psi[k] < Psi[k+1]) {
-              /* Should be monotonic decreasing. */
+              // Should be monotonic decreasing.
               free(tab->sense);
               free(tab->p0);
               free(tab->delta);
@@ -886,22 +941,23 @@ int tabset(struct tabprm *tab)
     }
   }
 
-  /* Find the extremal values of the coordinate elements in each row. */
-  dcrd = tab->coord;
-  dmin = tab->extrema;
-  dmax = tab->extrema + M;
-  for (ic = 0; ic < tab->nc; ic += tab->K[0]) {
-    for (m = 0; m < M; m++, dcrd++) {
+  // Find the extremal values of the coordinate elements in each row.
+  double *dcrd = tab->coord;
+  double *dmin = tab->extrema;
+  double *dmax = tab->extrema + M;
+  for (int ic = 0; ic < tab->nc; ic += tab->K[0]) {
+    for (int m = 0; m < M; m++, dcrd++) {
       if (tab->K[0] > 1) {
-        /* Extrapolate a little before the start of the row. */
-        Psi = tab->index[0];
+        // Extrapolate a little before the start of the row.
+        double dPsi;
+        double *Psi = tab->index[0];
         if (Psi == 0x0) {
           dPsi = 1.0;
         } else {
           dPsi = Psi[1] - Psi[0];
         }
 
-        dval = *dcrd;
+        double dval = *dcrd;
         if (dPsi != 0.0) {
           dval -= 0.5 * (*(dcrd+M) - *dcrd)/dPsi;
         }
@@ -913,21 +969,22 @@ int tabset(struct tabprm *tab)
     }
 
     dcrd -= M;
-    for (i = 0; i < tab->K[0]; i++) {
-      for (m = 0; m < M; m++, dcrd++) {
+    for (int i = 0; i < tab->K[0]; i++) {
+      for (int m = 0; m < M; m++, dcrd++) {
         if (*(dmax+m) < *dcrd) *(dmax+m) = *dcrd;
         if (*(dmin+m) > *dcrd) *(dmin+m) = *dcrd;
 
         if (tab->K[0] > 1 && i == tab->K[0]-1) {
-          /* Extrapolate a little beyond the end of the row. */
-          Psi = tab->index[0];
+          // Extrapolate a little beyond the end of the row.
+          double dPsi;
+          double *Psi = tab->index[0];
           if (Psi == 0x0) {
             dPsi = 1.0;
           } else {
             dPsi = Psi[i] - Psi[i-1];
           }
 
-          dval = *dcrd;
+          double dval = *dcrd;
           if (dPsi != 0.0) {
             dval += 0.5 * (*dcrd - *(dcrd-M))/dPsi;
           }
@@ -947,7 +1004,7 @@ int tabset(struct tabprm *tab)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabx2s(
   struct tabprm *tab,
@@ -960,48 +1017,44 @@ int tabx2s(
 {
   static const char *function = "tabx2s";
 
-  int i, iv, k, *Km, m, M, n, nv, offset, p1, status;
-  double *coord, *Psi, psi_m, upsilon, wgt;
-  register int *statp;
-  register const double *xp;
-  register double *wp;
-  struct wcserr **err;
+  int status;
 
   if (tab == 0x0) return TABERR_NULL_POINTER;
-  err = &(tab->err);
+  struct wcserr **err = &(tab->err);
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (tab->flag != TABSET) {
     if ((status = tabset(tab))) return status;
   }
 
-  /* This is used a lot. */
-  M = tab->M;
+  // This is used a lot.
+  int M = tab->M;
 
   status = 0;
-  xp = x;
-  wp = world;
-  statp = stat;
-  for (n = 0; n < ncoord; n++) {
-    /* Determine the indexes. */
-    Km = tab->K;
-    for (m = 0; m < M; m++, Km++) {
-      /* N.B. psi_m and Upsilon_m are 1-relative FITS indexes. */
-      i = tab->map[m];
-      psi_m = *(xp+i) + tab->crval[m];
+  register const double *xp = x;
+  register double *wp = world;
+  register int *statp = stat;
+  for (int n = 0; n < ncoord; n++) {
+    // Determine the indexes.
+    int *Km = tab->K;
+    for (int m = 0; m < M; m++, Km++) {
+      // N.B. psi_m and Upsilon_m are 1-relative FITS indexes.
+      int i = tab->map[m];
+      double psi_m = *(xp+i) + tab->crval[m];
 
-      Psi = tab->index[m];
+      double *Psi = tab->index[m];
+      double upsilon;
       if (Psi == 0x0) {
-        /* Default indexing is simple. */
+        // Default indexing is simple.
         upsilon = psi_m;
 
       } else {
-        /* To ease confusion, decrement Psi so that we can use 1-relative
-           C array indexing to match the 1-relative FITS indexing. */
+        // To ease confusion, decrement Psi so that we can use 1-relative
+        // C array indexing to match the 1-relative FITS indexing.
         Psi--;
 
         if (*Km == 1) {
-          /* Index vector is degenerate. */
+          // Index vector is degenerate.
           if (Psi[1]-0.5 <= psi_m && psi_m <= Psi[1]+0.5) {
             upsilon = psi_m;
           } else {
@@ -1011,16 +1064,17 @@ int tabx2s(
           }
 
         } else {
-          /* Interpolate in the indexing vector. */
+          // Interpolate in the indexing vector.
+	  int k;
           if (tab->sense[m] == 1) {
-            /* Monotonic increasing index values. */
+            // Monotonic increasing index values.
             if (psi_m < Psi[1]) {
               if (Psi[1] - 0.5*(Psi[2]-Psi[1]) <= psi_m) {
-                /* Allow minor extrapolation. */
+                // Allow minor extrapolation.
                 k = 1;
 
               } else {
-                /* Index is out of range. */
+                // Index is out of range.
                 *statp = 1;
                 status = wcserr_set(TAB_ERRMSG(TABERR_BAD_X));
                 goto next;
@@ -1028,11 +1082,11 @@ int tabx2s(
 
             } else if (Psi[*Km] < psi_m) {
               if (psi_m <= Psi[*Km] + 0.5*(Psi[*Km]-Psi[*Km-1])) {
-                /* Allow minor extrapolation. */
+                // Allow minor extrapolation.
                 k = *Km - 1;
 
               } else {
-                /* Index is out of range. */
+                // Index is out of range.
                 *statp = 1;
                 status = wcserr_set(TAB_ERRMSG(TABERR_BAD_X));
                 goto next;
@@ -1053,14 +1107,14 @@ int tabx2s(
             }
 
           } else {
-            /* Monotonic decreasing index values. */
+            // Monotonic decreasing index values.
             if (psi_m > Psi[1]) {
               if (Psi[1] + 0.5*(Psi[1]-Psi[2]) >= psi_m) {
-                /* Allow minor extrapolation. */
+                // Allow minor extrapolation.
                 k = 1;
 
               } else {
-                /* Index is out of range. */
+                // Index is out of range.
                 *statp = 1;
                 status = wcserr_set(TAB_ERRMSG(TABERR_BAD_X));
                 goto next;
@@ -1068,11 +1122,11 @@ int tabx2s(
 
             } else if (psi_m < Psi[*Km]) {
               if (Psi[*Km] - 0.5*(Psi[*Km-1]-Psi[*Km]) <= psi_m) {
-                /* Allow minor extrapolation. */
+                // Allow minor extrapolation.
                 k = *Km - 1;
 
               } else {
-                /* Index is out of range. */
+                // Index is out of range.
                 *statp = 1;
                 status = wcserr_set(TAB_ERRMSG(TABERR_BAD_X));
                 goto next;
@@ -1098,44 +1152,44 @@ int tabx2s(
       }
 
       if (upsilon < 0.5 || upsilon > *Km + 0.5) {
-        /* Index out of range. */
+        // Index out of range.
         *statp = 1;
         status = wcserr_set(TAB_ERRMSG(TABERR_BAD_X));
         goto next;
       }
 
-      /* Fiducial array indices and fractional offset.
-         p1 is 1-relative while tab::p0 is 0-relative. */
-      p1 = (int)floor(upsilon);
+      // Fiducial array indices and fractional offset.
+      // p1 is 1-relative while tab::p0 is 0-relative.
+      int p1 = (int)floor(upsilon);
       tab->p0[m] = p1 - 1;
       tab->delta[m] = upsilon - p1;
 
       if (p1 == 0) {
-        /* Extrapolation below p1 == 1. */
+        // Extrapolation below p1 == 1.
         tab->p0[m] += 1;
         tab->delta[m] -= 1.0;
       } else if (p1 == *Km && *Km > 1) {
-        /* Extrapolation above p1 == K_m. */
+        // Extrapolation above p1 == K_m.
         tab->p0[m] -= 1;
         tab->delta[m] += 1.0;
       }
     }
 
 
-    /* Now interpolate in the coordinate array; the M-dimensional linear  */
-    /* interpolation algorithm is described in Sect. 3.4 of WCS Paper IV. */
-    for (m = 0; m < M; m++) {
-     i = tab->map[m];
-     *(wp+i) = 0.0;
+    // Now interpolate in the coordinate array; the M-dimensional linear
+    // interpolation algorithm is described in Sect. 3.4 of WCS Paper IV.
+    for (int m = 0; m < M; m++) {
+      int i = tab->map[m];
+      *(wp+i) = 0.0;
     }
 
-    /* Loop over the 2^M vertices surrounding P. */
-    nv = 1 << M;
-    for (iv = 0; iv < nv; iv++) {
-      /* Locate vertex in the coordinate array and compute its weight. */
-      offset = 0;
-      wgt = 1.0;
-      for (m = M-1; m >= 0; m--) {
+    // Loop over the 2^M vertices surrounding P.
+    int nv = 1 << M;
+    for (int iv = 0; iv < nv; iv++) {
+      // Locate vertex in the coordinate array and compute its weight.
+      int offset = 0;
+      double wgt = 1.0;
+      for (int m = M-1; m >= 0; m--) {
         offset *= tab->K[m];
         offset += tab->p0[m];
         if (iv & (1 << m)) {
@@ -1148,10 +1202,10 @@ int tabx2s(
 
       if (wgt == 0.0) continue;
 
-      /* Add the contribution from this vertex to each element. */
-      coord = tab->coord + offset*M;
-      for (m = 0; m < M; m++) {
-        i = tab->map[m];
+      // Add the contribution from this vertex to each element.
+      double *coord = tab->coord + offset*M;
+      for (int m = 0; m < M; m++) {
+        int i = tab->map[m];
         *(wp+i) += *(coord++) * wgt;
       }
 
@@ -1169,9 +1223,9 @@ next:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
-/* Helper functions used only by tabs2x(). */
+// Helper functions used only by tabs2x().
 static int tabedge(struct tabprm *);
 static int tabrow(struct tabprm *, const double *);
 static int tabvox(struct tabprm *, const double *, int, double **,
@@ -1188,26 +1242,21 @@ int tabs2x(
 {
   static const char *function = "tabs2x";
 
-  int edge, i, ic, iv, k, *Km, M, m, n, nv, offset, status;
-  double *dcrd, delta, *Psi, psi_m, **tabcoord, upsilon;
-  register int *statp;
-  register const double *wp;
-  register double *xp;
-  struct wcserr **err;
+  int status;
 
   if (tab == 0x0) return TABERR_NULL_POINTER;
-  err = &(tab->err);
+  struct wcserr **err = &(tab->err);
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (tab->flag != TABSET) {
     if ((status = tabset(tab))) return status;
   }
 
-  /* This is used a lot. */
-  M = tab->M;
+  // This is used a lot.
+  int M = tab->M;
 
-  tabcoord = 0x0;
-  nv = 0;
+  double **tabcoord = 0x0;
+  int nv = 0;
   if (M > 1) {
     nv = 1 << M;
     tabcoord = calloc(nv, sizeof(double *));
@@ -1215,59 +1264,61 @@ int tabs2x(
 
 
   status = 0;
-  wp = world;
-  xp = x;
-  statp = stat;
-  for (n = 0; n < ncoord; n++) {
-    /* Locate this coordinate in the coordinate array. */
-    edge = 0;
-    for (m = 0; m < M; m++) {
+  register const double *wp = world;
+  register double *xp = x;
+  register int *statp = stat;
+  for (int n = 0; n < ncoord; n++) {
+    // Locate this coordinate in the coordinate array.
+    int edge = 0;
+    for (int m = 0; m < M; m++) {
       tab->p0[m] = 0;
     }
 
+    int ic;
     for (ic = 0; ic < tab->nc; ic++) {
       if (tab->p0[0] == 0) {
-        /* New row, could it contain a solution? */
+        // New row, could it contain a solution?
         if (edge || tabrow(tab, wp)) {
-          /* No, skip it. */
+          // No, skip it.
           ic += tab->K[0];
           if (1 < M) {
             tab->p0[1]++;
             edge = tabedge(tab);
           }
 
-          /* Because ic will be incremented when the loop is reentered. */
+          // Because ic will be incremented when the loop is reentered.
           ic--;
           continue;
         }
       }
 
       if (M == 1) {
-        /* Deal with the one-dimensional case separately for efficiency. */
-        if (*wp == tab->coord[0]) {
+        // Deal with the one-dimensional case separately for efficiency.
+        double w = wp[tab->map[0]];
+        if (w == tab->coord[0]) {
           tab->p0[0] = 0;
           tab->delta[0] = 0.0;
           break;
 
         } else if (ic < tab->nc - 1) {
-          if (((tab->coord[ic] <= *wp && *wp <= tab->coord[ic+1]) ||
-               (tab->coord[ic] >= *wp && *wp >= tab->coord[ic+1])) &&
+          if (((tab->coord[ic] <= w && w <= tab->coord[ic+1]) ||
+               (tab->coord[ic] >= w && w >= tab->coord[ic+1])) &&
                (tab->index[0] == 0x0 ||
                 tab->index[0][ic] != tab->index[0][ic+1])) {
             tab->p0[0] = ic;
-            tab->delta[0] = (*wp - tab->coord[ic]) /
+            tab->delta[0] = (w - tab->coord[ic]) /
                             (tab->coord[ic+1] - tab->coord[ic]);
             break;
           }
         }
 
       } else {
-        /* Multi-dimensional tables are harder. */
+        // Multi-dimensional tables are harder.
         if (!edge) {
-          /* Addresses of the coordinates for each corner of the "voxel". */
-          for (iv = 0; iv < nv; iv++) {
-            offset = 0;
-            for (m = M-1; m >= 0; m--) {
+          // Addresses of the coordinates for each corner of the "voxel".
+          for (int iv = 0; iv < nv; iv++) {
+            int offset = 0;
+            for (int m = M-1; m >= 0; m--) {
               offset *= tab->K[m];
               offset += tab->p0[m];
               if ((iv & (1 << m)) && (tab->K[m] > 1)) offset++;
@@ -1276,12 +1327,12 @@ int tabs2x(
           }
 
           if (tabvox(tab, wp, 0, tabcoord, 0x0) == 0) {
-            /* Found a solution. */
+            // Found a solution.
             break;
           }
         }
 
-        /* Next voxel. */
+        // Next voxel.
         tab->p0[0]++;
         edge = tabedge(tab);
       }
@@ -1289,15 +1340,16 @@ int tabs2x(
 
 
     if (ic == tab->nc) {
-      /* Coordinate not found; allow minor extrapolation. */
+      // Coordinate not found; allow minor extrapolation.
       if (M == 1) {
-        /* Should there be a solution? */
-        if (tab->extrema[0] <= *wp && *wp <= tab->extrema[1]) {
-          dcrd = tab->coord;
-          for (i = 0; i < 2; i++) {
+        // Should there be a solution?
+        double w = wp[tab->map[0]];
+        if (tab->extrema[0] <= w && w <= tab->extrema[1]) {
+          double *dcrd = tab->coord;
+          for (int i = 0; i < 2; i++) {
             if (i) dcrd += tab->K[0] - 2;
 
-            delta = (*wp - *dcrd) / (*(dcrd+1) - *dcrd);
+            double delta = (w - *dcrd) / (*(dcrd+1) - *dcrd);
 
             if (i == 0) {
               if (-0.5 <= delta && delta <= 0.0) {
@@ -1317,46 +1369,47 @@ int tabs2x(
         }
 
       } else {
-        /* Multi-dimensional tables. */
-        /* >>> TBD <<< */
+        // Multi-dimensional tables.
+        // >>> TBD <<<
       }
     }
 
 
     if (ic == tab->nc) {
-      /* Coordinate not found. */
+      // Coordinate not found.
       *statp = 1;
       status = wcserr_set(TAB_ERRMSG(TABERR_BAD_WORLD));
 
     } else {
-      /* Determine the intermediate world coordinates. */
-      Km = tab->K;
-      for (m = 0; m < M; m++, Km++) {
-        /* N.B. Upsilon_m and psi_m are 1-relative FITS indexes. */
-        upsilon = (tab->p0[m] + 1) + tab->delta[m];
+      // Determine the intermediate world coordinates.
+      int *Km = tab->K;
+      for (int m = 0; m < M; m++, Km++) {
+        // N.B. Upsilon_m and psi_m are 1-relative FITS indexes.
+        double upsilon = (tab->p0[m] + 1) + tab->delta[m];
 
         if (upsilon < 0.5 || upsilon > *Km + 0.5) {
-          /* Index out of range. */
+          // Index out of range.
           *statp = 1;
           status = wcserr_set(TAB_ERRMSG(TABERR_BAD_WORLD));
 
         } else {
-          /* Do inverse lookup of the index vector. */
-          Psi = tab->index[m];
+          // Do inverse lookup of the index vector.
+          double *Psi = tab->index[m];
+          double psi_m;
           if (Psi == 0x0) {
-            /* Default indexing. */
+            // Default indexing.
             psi_m = upsilon;
 
           } else {
-            /* Decrement Psi and use 1-relative C array indexing to match the
-               1-relative FITS indexing. */
+            // Decrement Psi and use 1-relative C array indexing to match the
+            // 1-relative FITS indexing.
             Psi--;
 
             if (*Km == 1) {
-              /* Degenerate index vector. */
+              // Degenerate index vector.
               psi_m = Psi[1];
             } else {
-              k = (int)(upsilon);
+              int k = (int)(upsilon);
               psi_m = Psi[k];
               if (k < *Km) {
                 psi_m += (upsilon - k) * (Psi[k+1] - Psi[k]);
@@ -1364,8 +1417,7 @@ int tabs2x(
             }
           }
 
-          i = tab->map[m];
-          xp[i] = psi_m - tab->crval[m];
+          xp[tab->map[m]] = psi_m - tab->crval[m];
         }
       }
       *statp = 0;
@@ -1391,19 +1443,18 @@ int tabs2x(
 int tabedge(struct tabprm* tab)
 
 {
-  int edge, m;
+  int edge = 0;
 
-  edge = 0;
-  for (m = 0; m < tab->M; m++) {
+  for (int m = 0; m < tab->M; m++) {
     if (tab->p0[m] == tab->K[m]) {
-      /* p0 has been incremented beyond the end of an index vector, point it
-         to the next one. */
+      // p0 has been incremented beyond the end of an index vector, point it
+      // to the next one.
       tab->p0[m] = 0;
       if (m < tab->M-1) {
         tab->p0[m+1]++;
       }
     } else if (tab->p0[m] == tab->K[m]-1 && tab->K[m] > 1) {
-      /* p0 is sitting at the end of a non-degenerate index vector. */
+      // p0 is sitting at the end of a non-degenerate index vector.
       edge = 1;
     }
   }
@@ -1443,55 +1494,52 @@ int tabedge(struct tabprm* tab)
 int tabrow(struct tabprm* tab, const double *wp)
 
 {
-  int M, m, offset;
-  unsigned int eq, gt, iv, lt, nv;
   const double tol = 1e-10;
-  double *cp, w;
 
-  M = tab->M;
+  int M = tab->M;
 
-  /* The number of corners in a "voxel".  We need examine only half this
-     number of rows.  The extra factor of two will be used to select between
-     the minimal and maximal values in each row. */
-  nv = 1 << M;
-
-  eq = 0;
-  lt = 0;
-  gt = 0;
-  for (iv = 0; iv < nv; iv++) {
-    /* Find the index into tabprm::extrema for this row. */
-    offset = 0;
-    for (m = M-1; m > 0; m--) {
+  // The number of corners in a "voxel".  We need examine only half this
+  // number of rows.  The extra factor of two will be used to select between
+  // the minimal and maximal values in each row.
+  unsigned int nv = 1 << M;
+
+  unsigned int eq = 0;
+  unsigned int lt = 0;
+  unsigned int gt = 0;
+  for (unsigned int iv = 0; iv < nv; iv++) {
+    // Find the index into tabprm::extrema for this row.
+    int offset = 0;
+    for (int m = M-1; m > 0; m--) {
       offset *= tab->K[m];
       offset += tab->p0[m];
 
-      /* Select the row. */
+      // Select the row.
       if (iv & (1 << m)) {
         if (tab->K[m] > 1) offset++;
       }
     }
 
-    /* The K_1 dimension has length 2 (see prologue). */
+    // The K_1 dimension has length 2 (see prologue).
     offset *= 2;
 
-    /* Select the minimum on even numbered iterations, else the maximum. */
+    // Select the minimum on even numbered iterations, else the maximum.
     if (iv & 1) offset++;
 
-    /* The last dimension has length M (see prologue). */
+    // The last dimension has length M (see prologue).
     offset *= M;
 
-    /* Address of the extremal elements (min or max) for this row. */
-    cp = tab->extrema + offset;
+    // Address of the extremal elements (min or max) for this row.
+    double *cp = tab->extrema + offset;
 
-    /* For each coordinate element, we only need to find one row where its
-       minimum value is less than that of wp, and one row where the maximum
-       value is greater.  That doesn't mean that there is a solution, only
-       that there might be. */
-    for (m = 0; m < M; m++, cp++) {
-      /* Apply the axis mapping. */
-      w = wp[tab->map[m]];
+    // For each coordinate element, we only need to find one row where its
+    // minimum value is less than that of wp, and one row where the maximum
+    // value is greater.  That doesn't mean that there is a solution, only
+    // that there might be.
+    for (int m = 0; m < M; m++, cp++) {
+      // Apply the axis mapping.
+      double w = wp[tab->map[m]];
 
-      /* Finally the test itself; set bits in the bitmask. */
+      // Finally the test itself; set bits in the bitmask.
       if (fabs(*cp - w) < tol) {
         eq |= (1 << m);
       } else if (*cp < w) {
@@ -1501,14 +1549,14 @@ int tabrow(struct tabprm* tab, const dou
       }
     }
 
-    /* Have all bits been switched on? */
+    // Have all bits been switched on?
     if ((lt | eq) == nv-1 && (gt | eq) == nv-1) {
-      /* A solution could lie within this row of voxels. */
+      // A solution could lie within this row of voxels.
       return 0;
     }
   }
 
-  /* No solution in this row. */
+  // No solution in this row.
   return 1;
 }
 
@@ -1540,30 +1588,28 @@ int tabvox(
   unsigned int *vox)
 
 {
-  int i, M, m;
-  unsigned int eq, et, gt, iv, jv, lt, nv, vox2[32];
   const double tol = 1e-10;
-  double coord[32], *cp, dv, w, wgt;
 
-  M = tab->M;
+  int M = tab->M;
 
-  /* The number of corners in a voxel. */
-  nv = 1 << M;
+  // The number of corners in a voxel.
+  unsigned int nv = 1 << M;
 
-  dv = 1.0;
-  for (i = 0; i < level; i++) {
+  double dv = 1.0;
+  for (int i = 0; i < level; i++) {
     dv /= 2.0;
   }
 
-  /* Could the coordinate lie within this voxel (level == 0) or sub-voxel
-     (level > 0)?  We use the fact that with linear interpolation the
-     coordinate elements are extremal in a corner and test each one. */
-  lt = 0;
-  gt = 0;
-  eq = 0;
-  for (iv = 0; iv < nv; iv++) {
-    /* Select a corner of the sub-voxel. */
-    for (m = 0; m < M; m++) {
+  // Could the coordinate lie within this voxel (level == 0) or sub-voxel
+  // (level > 0)?  We use the fact that with linear interpolation the
+  // coordinate elements are extremal in a corner and test each one.
+  unsigned int lt = 0;
+  unsigned int gt = 0;
+  unsigned int eq = 0;
+  for (unsigned int iv = 0; iv < nv; iv++) {
+    // Select a corner of the sub-voxel.
+    double coord[32];
+    for (int m = 0; m < M; m++) {
       coord[m] = 0.0;
       tab->delta[m] = level ? dv*vox[m] : 0.0;
 
@@ -1572,13 +1618,13 @@ int tabvox(
       }
     }
 
-    /* Compute the coordinates of this corner of the sub-voxel by linear
-       interpolation using the weighting algorithm described in Sect. 3.4 of
-       WCS Paper IV. */
-    for (jv = 0; jv < nv; jv++) {
-      /* Find the weight for this corner of the parent voxel. */
-      wgt = 1.0;
-      for (m = 0; m < M; m++) {
+    // Compute the coordinates of this corner of the sub-voxel by linear
+    // interpolation using the weighting algorithm described in Sect. 3.4 of
+    // WCS Paper IV.
+    for (unsigned int jv = 0; jv < nv; jv++) {
+      // Find the weight for this corner of the parent voxel.
+      double wgt = 1.0;
+      for (int m = 0; m < M; m++) {
         if (jv & (1 << m)) {
           wgt *= tab->delta[m];
         } else {
@@ -1588,22 +1634,22 @@ int tabvox(
 
       if (wgt == 0.0) continue;
 
-      /* Add its contribution to each coordinate element. */
-      cp = tabcoord[jv];
-      for (m = 0; m < M; m++) {
+      // Add its contribution to each coordinate element.
+      double *cp = tabcoord[jv];
+      for (int m = 0; m < M; m++) {
         coord[m] += *(cp++) * wgt;
       }
 
       if (wgt == 1.0) break;
     }
 
-    /* Coordinate elements are minimal or maximal in a corner. */
-    et = 0;
-    for (m = 0; m < M; m++) {
-      /* Apply the axis mapping. */
-      w = wp[tab->map[m]];
+    // Coordinate elements are minimal or maximal in a corner.
+    unsigned int et = 0;
+    for (int m = 0; m < M; m++) {
+      // Apply the axis mapping.
+      double w = wp[tab->map[m]];
 
-      /* Finally the test itself; set bits in the bitmask. */
+      // Finally the test itself; set bits in the bitmask.
       if (fabs(coord[m] - w) < tol) {
         et |= (1 << m);
       } else if (coord[m] < w) {
@@ -1614,45 +1660,46 @@ int tabvox(
     }
 
     if (et == nv-1) {
-      /* We've stumbled across a solution in this corner of the sub-voxel. */
+      // We've stumbled across a solution in this corner of the sub-voxel.
       return 0;
     }
 
     eq |= et;
   }
 
-  /* Could the coordinate lie within this sub-voxel? */
+  // Could the coordinate lie within this sub-voxel?
   if ((lt | eq) == nv-1 && (gt | eq) == nv-1) {
-    /* Yes it could, but does it? */
+    // Yes it could, but does it?
 
-    /* Is it time to stop the recursion? */
+    // Is it time to stop the recursion?
     if (level == 31) {
-      /* We have a solution, squeeze out the last bit of juice. */
+      // We have a solution, squeeze out the last bit of juice.
       dv /= 2.0;
-      for (m = 0; m < M; m++) {
+      for (int m = 0; m < M; m++) {
         tab->delta[m] = dv * (2.0*vox[m] + 1.0);
       }
 
       return 0;
     }
 
-    /* Subdivide the sub-voxel and try again for each subdivision. */
-    for (iv = 0; iv < nv; iv++) {
-      /* Select the subdivision. */
-      for (m = 0; m < M; m++) {
+    // Subdivide the sub-voxel and try again for each subdivision.
+    for (unsigned int iv = 0; iv < nv; iv++) {
+      // Select the subdivision.
+      unsigned int vox2[32];
+      for (int m = 0; m < M; m++) {
         vox2[m] = level ? 2*vox[m] : 0;
         if (iv & (1 << m)) {
           vox2[m]++;
         }
       }
 
-      /* Recurse. */
+      // Recurse.
       if (tabvox(tab, wp, level+1, tabcoord, vox2) == 0) {
         return 0;
       }
     }
   }
 
-  /* No solution in this sub-voxel. */
+  // No solution in this sub-voxel.
   return 1;
 }
Index: astropy-4.2.1/cextern/wcslib/C/tab.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/tab.h
+++ astropy-4.2.1/cextern/wcslib/C/tab.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: tab.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: tab.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -52,7 +49,8 @@
 * encapsulation.
 *
 * tabini(), tabmem(), tabcpy(), and tabfree() are provided to manage the
-* tabprm struct, and another, tabprt(), to print its contents.
+* tabprm struct, tabsize() computes its total size including allocated memory,
+* and tabprt() prints its contents.
 *
 * tabperr() prints the error message(s) (if any) stored in a tabprm struct.
 *
@@ -235,6 +233,35 @@
 *                         1: Null tabprm pointer passed.
 *
 *
+* tabsize() - Compute the size of a tabprm struct
+* -----------------------------------------------
+* tabsize() computes the full size of a tabprm struct, including allocated
+* memory.
+*
+* Given:
+*   tab       const struct tabprm*
+*                       Tabular transformation parameters.
+*
+*                       If NULL, the base size of the struct and the allocated
+*                       size are both set to zero.
+*
+* Returned:
+*   sizes     int[2]    The first element is the base size of the struct as
+*                       returned by sizeof(struct tabprm).  The second element
+*                       is the total allocated size, in bytes, assuming that
+*                       the allocation was done by tabini().  This figure
+*                       includes memory allocated for the constituent struct,
+*                       tabprm::err.
+*
+*                       It is not an error for the struct not to have been set
+*                       up via tabset(), which normally results in additional
+*                       memory allocation. 
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*
+*
 * tabprt() - Print routine for the tabprm struct
 * ----------------------------------------------
 * tabprt() prints the contents of a tabprm struct using wcsprintf().  Mainly
@@ -533,65 +560,65 @@ extern "C" {
 extern const char *tab_errmsg[];
 
 enum tab_errmsg_enum {
-  TABERR_SUCCESS      = 0,	/* Success. */
-  TABERR_NULL_POINTER = 1,	/* Null tabprm pointer passed. */
-  TABERR_MEMORY       = 2,	/* Memory allocation failed. */
-  TABERR_BAD_PARAMS   = 3,	/* Invalid tabular parameters. */
-  TABERR_BAD_X        = 4,	/* One or more of the x coordinates were
-				   invalid. */
-  TABERR_BAD_WORLD    = 5	/* One or more of the world coordinates were
-				   invalid. */
+  TABERR_SUCCESS      = 0,	// Success.
+  TABERR_NULL_POINTER = 1,	// Null tabprm pointer passed.
+  TABERR_MEMORY       = 2,	// Memory allocation failed.
+  TABERR_BAD_PARAMS   = 3,	// Invalid tabular parameters.
+  TABERR_BAD_X        = 4,	// One or more of the x coordinates were
+				// invalid.
+  TABERR_BAD_WORLD    = 5	// One or more of the world coordinates were
+				// invalid.
 };
 
 struct tabprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int    flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  int    M;			/* Number of tabular coordinate axes.       */
-  int    *K;			/* Vector of length M whose elements        */
-				/* (K_1, K_2,... K_M) record the lengths of */
-				/* the axes of the coordinate array and of  */
-				/* each indexing vector.                    */
-  int    *map;			/* Vector of length M usually such that     */
-				/* map[m-1] == i-1 for coordinate array     */
-				/* axis m and image axis i (see above).     */
-  double *crval;		/* Vector of length M containing the index  */
-				/* value for the reference pixel for each   */
-				/* of the tabular coordinate axes.          */
-  double **index;		/* Vector of pointers to M indexing vectors */
-				/* of lengths (K_1, K_2,... K_M).           */
-  double *coord;		/* (1+M)-dimensional tabular coordinate     */
-				/* array (see above).                       */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  int    nc;			/* Number of coordinate vectors (of length  */
-				/* M) in the coordinate array.              */
-  int    padding;		/* (Dummy inserted for alignment purposes.) */
-  int    *sense;		/* Vector of M flags that indicate whether  */
-				/* the Mth indexing vector is monotonic     */
-				/* increasing, or else decreasing.          */
-  int    *p0;			/* Vector of M indices.                     */
-  double *delta;		/* Vector of M increments.                  */
-  double *extrema;		/* (1+M)-dimensional array of coordinate    */
-				/* extrema.                                 */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    M;			// Number of tabular coordinate axes.
+  int    *K;			// Vector of length M whose elements
+				// (K_1, K_2,... K_M) record the lengths of
+				// the axes of the coordinate array and of
+				// each indexing vector.
+  int    *map;			// Vector of length M usually such that
+				// map[m-1] == i-1 for coordinate array
+				// axis m and image axis i (see above).
+  double *crval;		// Vector of length M containing the index
+				// value for the reference pixel for each
+				// of the tabular coordinate axes.
+  double **index;		// Vector of pointers to M indexing vectors
+				// of lengths (K_1, K_2,... K_M).
+  double *coord;		// (1+M)-dimensional tabular coordinate
+				// array (see above).
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  int    nc;			// Number of coordinate vectors (of length
+				// M) in the coordinate array.
+  int    padding;		// (Dummy inserted for alignment purposes.)
+  int    *sense;		// Vector of M flags that indicate whether
+				// the Mth indexing vector is monotonic
+				// increasing, or else decreasing.
+  int    *p0;			// Vector of M indices.
+  double *delta;		// Vector of M increments.
+  double *extrema;		// (1+M)-dimensional array of coordinate
+				// extrema.
 
-  /* Error handling                                                         */
-  /*------------------------------------------------------------------------*/
+  // Error handling
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private - the remainder are for memory management.                     */
-  /*------------------------------------------------------------------------*/
+  // Private - the remainder are for memory management.
+  //--------------------------------------------------------------------------
   int    m_flag, m_M, m_N;
   int    set_M;
   int    *m_K, *m_map;
   double *m_crval, **m_index, **m_indxs, *m_coord;
 };
 
-/* Size of the tabprm struct in int units, used by the Fortran wrappers. */
+// Size of the tabprm struct in int units, used by the Fortran wrappers.
 #define TABLEN (sizeof(struct tabprm)/sizeof(int))
 
 
@@ -606,6 +633,8 @@ int tabcmp(int cmp, double tol, const st
 
 int tabfree(struct tabprm *tab);
 
+int tabsize(const struct tabprm *tab, int size[2]);
+
 int tabprt(const struct tabprm *tab);
 
 int tabperr(const struct tabprm *tab, const char *prefix);
@@ -619,7 +648,7 @@ int tabs2x(struct tabprm *tab, int ncoor
            double x[], int stat[]);
 
 
-/* Deprecated. */
+// Deprecated.
 #define tabini_errmsg tab_errmsg
 #define tabcpy_errmsg tab_errmsg
 #define tabfree_errmsg tab_errmsg
@@ -632,4 +661,4 @@ int tabs2x(struct tabprm *tab, int ncoor
 }
 #endif
 
-#endif /* WCSLIB_TAB */
+#endif // WCSLIB_TAB
Index: astropy-4.2.1/cextern/wcslib/C/wcs.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcs.c
+++ astropy-4.2.1/cextern/wcslib/C/wcs.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcs.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcs.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -49,11 +46,11 @@
 
 const int WCSSET = 137;
 
-/* Maximum number of PVi_ma and PSi_ma keywords. */
+// Maximum number of PVi_ma and PSi_ma keywords.
 int NPVMAX = 64;
 int NPSMAX =  8;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *wcs_errmsg[] = {
   "Success",
   "Null wcsprm pointer passed",
@@ -68,72 +65,73 @@ const char *wcs_errmsg[] = {
   "Invalid world coordinate",
   "No solution found in the specified interval",
   "Invalid subimage specification",
-  "Non-separable subimage coordinate system"};
+  "Non-separable subimage coordinate system",
+  "wcsprm struct is unset, use wcsset()"};
 
-/* Map error returns for lower-level routines. */
+// Map error returns for lower-level routines.
 const int wcs_linerr[] = {
-  WCSERR_SUCCESS,		/*  0: LINERR_SUCCESS         */
-  WCSERR_NULL_POINTER,		/*  1: LINERR_NULL_POINTER    */
-  WCSERR_MEMORY,		/*  2: LINERR_MEMORY          */
-  WCSERR_SINGULAR_MTX,		/*  3: LINERR_SINGULAR_MTX    */
-  WCSERR_BAD_PARAM,		/*  4: LINERR_DISTORT_INIT    */
-  WCSERR_BAD_PIX,		/*  5: LINERR_DISTORT         */
-  WCSERR_BAD_WORLD		/*  6: LINERR_DEDISTORT       */
+  WCSERR_SUCCESS,		//  0: LINERR_SUCCESS
+  WCSERR_NULL_POINTER,		//  1: LINERR_NULL_POINTER
+  WCSERR_MEMORY,		//  2: LINERR_MEMORY
+  WCSERR_SINGULAR_MTX,		//  3: LINERR_SINGULAR_MTX
+  WCSERR_BAD_PARAM,		//  4: LINERR_DISTORT_INIT
+  WCSERR_BAD_PIX,		//  5: LINERR_DISTORT
+  WCSERR_BAD_WORLD		//  6: LINERR_DEDISTORT
 };
 
 const int wcs_logerr[] = {
-  WCSERR_SUCCESS,		/*  0: LOGERR_SUCCESS         */
-  WCSERR_NULL_POINTER,		/*  1: LOGERR_NULL_POINTER    */
-  WCSERR_BAD_PARAM,		/*  2: LOGERR_BAD_LOG_REF_VAL */
-  WCSERR_BAD_PIX,		/*  3: LOGERR_BAD_X           */
-  WCSERR_BAD_WORLD		/*  4: LOGERR_BAD_WORLD       */
+  WCSERR_SUCCESS,		//  0: LOGERR_SUCCESS
+  WCSERR_NULL_POINTER,		//  1: LOGERR_NULL_POINTER
+  WCSERR_BAD_PARAM,		//  2: LOGERR_BAD_LOG_REF_VAL
+  WCSERR_BAD_PIX,		//  3: LOGERR_BAD_X
+  WCSERR_BAD_WORLD		//  4: LOGERR_BAD_WORLD
 };
 
 const int wcs_spcerr[] = {
-				/* -1: SPCERR_NO_CHANGE       */
-  WCSERR_SUCCESS,		/*  0: SPCERR_SUCCESS         */
-  WCSERR_NULL_POINTER,		/*  1: SPCERR_NULL_POINTER    */
-  WCSERR_BAD_PARAM,		/*  2: SPCERR_BAD_SPEC_PARAMS */
-  WCSERR_BAD_PIX,		/*  3: SPCERR_BAD_X           */
-  WCSERR_BAD_WORLD		/*  4: SPCERR_BAD_SPEC        */
+				// -1: SPCERR_NO_CHANGE
+  WCSERR_SUCCESS,		//  0: SPCERR_SUCCESS
+  WCSERR_NULL_POINTER,		//  1: SPCERR_NULL_POINTER
+  WCSERR_BAD_PARAM,		//  2: SPCERR_BAD_SPEC_PARAMS
+  WCSERR_BAD_PIX,		//  3: SPCERR_BAD_X
+  WCSERR_BAD_WORLD		//  4: SPCERR_BAD_SPEC
 };
 
 const int wcs_celerr[] = {
-  WCSERR_SUCCESS,		/*  0: CELERR_SUCCESS         */
-  WCSERR_NULL_POINTER,		/*  1: CELERR_NULL_POINTER    */
-  WCSERR_BAD_PARAM,		/*  2: CELERR_BAD_PARAM       */
-  WCSERR_BAD_COORD_TRANS,	/*  3: CELERR_BAD_COORD_TRANS */
-  WCSERR_ILL_COORD_TRANS,	/*  4: CELERR_ILL_COORD_TRANS */
-  WCSERR_BAD_PIX,		/*  5: CELERR_BAD_PIX         */
-  WCSERR_BAD_WORLD		/*  6: CELERR_BAD_WORLD       */
+  WCSERR_SUCCESS,		//  0: CELERR_SUCCESS
+  WCSERR_NULL_POINTER,		//  1: CELERR_NULL_POINTER
+  WCSERR_BAD_PARAM,		//  2: CELERR_BAD_PARAM
+  WCSERR_BAD_COORD_TRANS,	//  3: CELERR_BAD_COORD_TRANS
+  WCSERR_ILL_COORD_TRANS,	//  4: CELERR_ILL_COORD_TRANS
+  WCSERR_BAD_PIX,		//  5: CELERR_BAD_PIX
+  WCSERR_BAD_WORLD		//  6: CELERR_BAD_WORLD
 };
 
 const int wcs_taberr[] = {
-  WCSERR_SUCCESS,		/*  0: TABERR_SUCCESS         */
-  WCSERR_NULL_POINTER,		/*  1: TABERR_NULL_POINTER    */
-  WCSERR_MEMORY,		/*  2: TABERR_MEMORY          */
-  WCSERR_BAD_PARAM,		/*  3: TABERR_BAD_PARAMS      */
-  WCSERR_BAD_PIX,		/*  4: TABERR_BAD_X           */
-  WCSERR_BAD_WORLD		/*  5: TABERR_BAD_WORLD       */
+  WCSERR_SUCCESS,		//  0: TABERR_SUCCESS
+  WCSERR_NULL_POINTER,		//  1: TABERR_NULL_POINTER
+  WCSERR_MEMORY,		//  2: TABERR_MEMORY
+  WCSERR_BAD_PARAM,		//  3: TABERR_BAD_PARAMS
+  WCSERR_BAD_PIX,		//  4: TABERR_BAD_X
+  WCSERR_BAD_WORLD		//  5: TABERR_BAD_WORLD
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define WCS_ERRMSG(status) WCSERR_SET(status), wcs_errmsg[status]
 
 #ifndef signbit
 #define signbit(X) ((X) < 0.0 ? 1 : 0)
 #endif
 
-/* Internal helper functions, not for general use. */
+// Internal helper functions, not for general use.
 static int wcs_types(struct wcsprm *);
 static int wcs_units(struct wcsprm *);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsnpv(int npvmax) { if (npvmax >= 0) NPVMAX = npvmax; return NPVMAX; }
 int wcsnps(int npsmax) { if (npsmax >= 0) NPSMAX = npsmax; return NPSMAX; }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsini(int alloc, int naxis, struct wcsprm *wcs)
 
@@ -141,7 +139,7 @@ int wcsini(int alloc, int naxis, struct
   return wcsinit(alloc, naxis, wcs, -1, -1, -1);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsinit(
   int alloc,
@@ -158,23 +156,23 @@ int wcsinit(
   double *cd;
   struct wcserr **err;
 
-  /* Check inputs. */
+  // Check inputs.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
 
   if (npvmax < 0) npvmax = wcsnpv(-1);
   if (npsmax < 0) npsmax = wcsnps(-1);
 
 
-  /* Initialize error message handling... */
+  // Initialize error message handling...
   if (wcs->flag == -1) {
     wcs->err = 0x0;
   }
   err = &(wcs->err);
   wcserr_clear(err);
 
-  /* ...and also in the contained structs in case we have to return due to
-     an error before they can be initialized by their specialized routines,
-     since wcsperr() assumes their wcserr pointers are valid. */
+  // ...and also in the contained structs in case we have to return due to
+  // an error before they can be initialized by their specialized routines,
+  // since wcsperr() assumes their wcserr pointers are valid.
   if (wcs->flag == -1) {
     wcs->lin.err = 0x0;
     wcs->cel.err = 0x0;
@@ -185,7 +183,7 @@ int wcsinit(
   wcserr_clear(&(wcs->spc.err));
 
 
-  /* Initialize pointers. */
+  // Initialize pointers.
   if (wcs->flag == -1 || wcs->m_flag != WCSSET) {
     if (wcs->flag == -1) {
       wcs->tab   = 0x0;
@@ -193,7 +191,7 @@ int wcsinit(
       wcs->lin.flag = -1;
     }
 
-    /* Initialize memory management. */
+    // Initialize memory management.
     wcs->m_flag  = 0;
     wcs->m_naxis = 0;
     wcs->m_crpix = 0x0;
@@ -223,7 +221,7 @@ int wcsinit(
   }
 
 
-  /* Allocate memory for arrays if required. */
+  // Allocate memory for arrays if required.
   if (alloc ||
      wcs->crpix == 0x0 ||
      wcs->pc    == 0x0 ||
@@ -242,18 +240,18 @@ int wcsinit(
      wcs->czphs == 0x0 ||
      wcs->cperi == 0x0) {
 
-    /* Was sufficient allocated previously? */
+    // Was sufficient allocated previously?
     if (wcs->m_flag == WCSSET &&
        (wcs->m_naxis < naxis  ||
         wcs->npvmax  < npvmax ||
         wcs->npsmax  < npsmax)) {
-      /* No, free it. */
+      // No, free it.
       wcsfree(wcs);
     }
 
     if (alloc || wcs->crpix == 0x0) {
       if (wcs->m_crpix) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->crpix = wcs->m_crpix;
 
       } else {
@@ -269,7 +267,7 @@ int wcsinit(
 
     if (alloc || wcs->pc == 0x0) {
       if (wcs->m_pc) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->pc = wcs->m_pc;
 
       } else {
@@ -286,7 +284,7 @@ int wcsinit(
 
     if (alloc || wcs->cdelt == 0x0) {
       if (wcs->m_cdelt) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->cdelt = wcs->m_cdelt;
 
       } else {
@@ -303,7 +301,7 @@ int wcsinit(
 
     if (alloc || wcs->crval == 0x0) {
       if (wcs->m_crval) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->crval = wcs->m_crval;
 
       } else {
@@ -320,7 +318,7 @@ int wcsinit(
 
     if (alloc || wcs->cunit == 0x0) {
       if (wcs->m_cunit) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->cunit = wcs->m_cunit;
 
       } else {
@@ -337,7 +335,7 @@ int wcsinit(
 
     if (alloc || wcs->ctype == 0x0) {
       if (wcs->m_ctype) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->ctype = wcs->m_ctype;
 
       } else {
@@ -354,7 +352,7 @@ int wcsinit(
 
     if (alloc || wcs->pv == 0x0) {
       if (wcs->m_pv) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->pv = wcs->m_pv;
 
       } else {
@@ -377,7 +375,7 @@ int wcsinit(
 
     if (alloc || wcs->ps == 0x0) {
       if (wcs->m_ps) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->ps = wcs->m_ps;
 
       } else {
@@ -400,7 +398,7 @@ int wcsinit(
 
     if (alloc || wcs->cd == 0x0) {
       if (wcs->m_cd) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->cd = wcs->m_cd;
 
       } else {
@@ -417,7 +415,7 @@ int wcsinit(
 
     if (alloc || wcs->crota == 0x0) {
       if (wcs->m_crota) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->crota = wcs->m_crota;
 
       } else {
@@ -434,7 +432,7 @@ int wcsinit(
 
     if (alloc || wcs->colax == 0x0) {
       if (wcs->m_colax) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->colax = wcs->m_colax;
 
       } else {
@@ -451,7 +449,7 @@ int wcsinit(
 
     if (alloc || wcs->cname == 0x0) {
       if (wcs->m_cname) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->cname = wcs->m_cname;
 
       } else {
@@ -468,7 +466,7 @@ int wcsinit(
 
     if (alloc || wcs->crder == 0x0) {
       if (wcs->m_crder) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->crder = wcs->m_crder;
 
       } else {
@@ -485,7 +483,7 @@ int wcsinit(
 
     if (alloc || wcs->csyer == 0x0) {
       if (wcs->m_csyer) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->csyer = wcs->m_csyer;
 
       } else {
@@ -502,7 +500,7 @@ int wcsinit(
 
     if (alloc || wcs->czphs == 0x0) {
       if (wcs->m_czphs) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->czphs = wcs->m_czphs;
 
       } else {
@@ -519,7 +517,7 @@ int wcsinit(
 
     if (alloc || wcs->cperi == 0x0) {
       if (wcs->m_cperi) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->cperi = wcs->m_cperi;
 
       } else {
@@ -540,7 +538,7 @@ int wcsinit(
   wcs->naxis = naxis;
 
 
-  /* Set defaults for the linear transformation. */
+  // Set defaults for the linear transformation.
   wcs->lin.crpix  = wcs->crpix;
   wcs->lin.pc     = wcs->pc;
   wcs->lin.cdelt  = wcs->cdelt;
@@ -549,28 +547,28 @@ int wcsinit(
   }
 
 
-  /* CRVALia defaults to 0.0. */
+  // CRVALia defaults to 0.0.
   for (i = 0; i < naxis; i++) {
     wcs->crval[i] = 0.0;
   }
 
 
-  /* CUNITia and CTYPEia are blank by default. */
+  // CUNITia and CTYPEia are blank by default.
   for (i = 0; i < naxis; i++) {
     memset(wcs->cunit[i], 0, 72);
     memset(wcs->ctype[i], 0, 72);
   }
 
 
-  /* Set defaults for the celestial transformation parameters. */
+  // Set defaults for the celestial transformation parameters.
   wcs->lonpole = UNDEFINED;
   wcs->latpole = +90.0;
 
-  /* Set defaults for the spectral transformation parameters. */
+  // Set defaults for the spectral transformation parameters.
   wcs->restfrq = 0.0;
   wcs->restwav = 0.0;
 
-  /* Default parameter values. */
+  // Default parameter values.
   wcs->npv = 0;
   for (k = 0; k < wcs->npvmax; k++) {
     wcs->pv[k].i = 0;
@@ -585,7 +583,7 @@ int wcsinit(
     memset(wcs->ps[k].value, 0, 72);
   }
 
-  /* Defaults for alternate linear transformations. */
+  // Defaults for alternate linear transformations.
   cd = wcs->cd;
   for (i = 0; i < naxis; i++) {
     for (j = 0; j < naxis; j++) {
@@ -598,7 +596,7 @@ int wcsinit(
   wcs->altlin = 0;
   wcs->velref = 0;
 
-  /* Defaults for auxiliary coordinate system information. */
+  // Defaults for auxiliary coordinate system information.
   memset(wcs->alt, 0, 4);
   wcs->alt[0] = ' ';
   wcs->colnum = 0;
@@ -661,16 +659,16 @@ int wcsinit(
   memset(wcs->ssyssrc,  0, 72);
   wcs->velangl    = UNDEFINED;
 
-  /* No additional auxiliary coordinate system information. */
+  // No additional auxiliary coordinate system information.
   wcs->aux  = 0x0;
 
-  /* Tabular parameters. */
+  // Tabular parameters.
   wcs->ntab = 0;
   wcs->tab  = 0x0;
   wcs->nwtb = 0;
   wcs->wtb  = 0x0;
 
-  /* Reset derived values. */
+  // Reset derived values.
   strcpy(wcs->lngtyp, "    ");
   strcpy(wcs->lattyp, "    ");
   wcs->lng  = -1;
@@ -681,10 +679,10 @@ int wcsinit(
   celini(&(wcs->cel));
   spcini(&(wcs->spc));
 
-  return 0;
+  return WCSERR_SUCCESS;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsauxi(
   int alloc,
@@ -696,14 +694,14 @@ int wcsauxi(
   struct auxprm *aux;
   struct wcserr **err;
 
-  /* Check inputs. */
+  // Check inputs.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
-  /* Allocate memory if required. */
+  // Allocate memory if required.
   if (alloc || wcs->aux == 0x0) {
     if (wcs->m_aux) {
-      /* In case the caller fiddled with it. */
+      // In case the caller fiddled with it.
       wcs->aux = wcs->m_aux;
 
     } else {
@@ -722,10 +720,10 @@ int wcsauxi(
   aux->hgln_obs = UNDEFINED;
   aux->hglt_obs = UNDEFINED;
 
-  return 0;
+  return WCSERR_SUCCESS;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcssub(
   int alloc,
@@ -753,7 +751,7 @@ int wcssub(
   if (wcsdst == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcsdst->err);
 
-  /* N.B. we do not rely on the wcsprm struct having been set up. */
+  // N.B. we do not rely on the wcsprm struct having been set up.
   if ((naxis = wcssrc->naxis) <= 0) {
     return wcserr_set(WCSERR_SET(WCSERR_MEMORY),
       "naxis must be positive (got %d)", naxis);
@@ -766,14 +764,14 @@ int wcssub(
     *nsub = naxis;
   }
 
-  /* Allocate enough temporary storage to hold either axes[] xor map[].*/
+  // Allocate enough temporary storage to hold either axes[] xor map[].
   ntmp = (*nsub <= naxis) ? naxis : *nsub;
   if ((itmp = calloc(ntmp, sizeof(int))) == 0x0) {
     return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
   }
 
   if ((dealloc = (axes == 0x0))) {
-    /* Construct an index array. */
+    // Construct an index array.
     if ((axes = calloc(naxis, sizeof(int))) == 0x0) {
       free(itmp);
       return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
@@ -784,7 +782,7 @@ int wcssub(
     }
   }
 
-  /* So that we don't try to free uninitialized pointers on cleanup. */
+  // So that we don't try to free uninitialized pointers on cleanup.
   wcsdst->m_aux = 0x0;
   wcsdst->m_tab = 0x0;
 
@@ -794,7 +792,7 @@ int wcssub(
     axis = axes[j];
 
     if (abs(axis) > 0x1000) {
-      /* Subimage extraction by type. */
+      // Subimage extraction by type.
       k = abs(axis) & 0xFF;
 
       longitude = k & WCSSUB_LONGITUDE;
@@ -815,7 +813,7 @@ int wcssub(
         strncpy (ctypei, (char *)(wcssrc->ctype + i), 8);
         ctypei[8] = '\0';
 
-        /* Find the last non-blank character. */
+        // Find the last non-blank character.
         c = ctypei + 8;
         while (c-- > ctypei) {
           if (*c == ' ') *c = '\0';
@@ -874,7 +872,7 @@ int wcssub(
           continue;
         }
 
-        /* This axis is wanted, but has it already been added? */
+        // This axis is wanted, but has it already been added?
         for (k = 0; k < msub; k++) {
           if (itmp[k] == i+1) {
             break;
@@ -884,7 +882,7 @@ int wcssub(
       }
 
     } else if (0 < axis && axis <= naxis) {
-      /* Check that the requested axis has not already been added. */
+      // Check that the requested axis has not already been added.
       for (k = 0; k < msub; k++) {
         if (itmp[k] == axis) {
           break;
@@ -893,7 +891,7 @@ int wcssub(
       if (k == msub) itmp[msub++] = axis;
 
     } else if (axis == 0) {
-      /* Graft on a new axis. */
+      // Graft on a new axis.
       itmp[msub++] = 0;
 
     } else {
@@ -903,7 +901,7 @@ int wcssub(
   }
 
   if ((*nsub = msub) == 0) {
-    /* Zero out this struct. */
+    // Zero out this struct.
     status = wcsinit(alloc, 0, wcsdst, 0, 0, 0);
     goto cleanup;
   }
@@ -913,11 +911,11 @@ int wcssub(
   }
 
 
-  /* Construct the inverse axis map (i is 0-relative, j is 1-relative):
-     axes[i] == j means that output axis i+1 comes from input axis j,
-     axes[i] == 0 means to create a new axis,
-      map[i] == j means that input axis i+1 goes to output axis j,
-      map[i] == 0 means that input axis i+1 is not used. */
+  // Construct the inverse axis map (i is 0-relative, j is 1-relative):
+  // axes[i] == j means that output axis i+1 comes from input axis j,
+  // axes[i] == 0 means to create a new axis,
+  //  map[i] == j means that input axis i+1 goes to output axis j,
+  //  map[i] == 0 means that input axis i+1 is not used.
   map = itmp;
   for (i = 0; i < naxis; i++) {
     map[i] = 0;
@@ -930,8 +928,8 @@ int wcssub(
   }
 
 
-  /* Check that the subimage coordinate system is separable.  First check */
-  /* non-zero, off-diagonal elements of the linear transformation matrix. */
+  // Check that the subimage coordinate system is separable.  First check
+  // non-zero, off-diagonal elements of the linear transformation matrix.
   srcp = wcssrc->pc;
   for (i = 0; i < naxis; i++) {
     for (j = 0; j < naxis; j++) {
@@ -944,8 +942,8 @@ int wcssub(
     }
   }
 
-  /* Now check for distortions that depend on other axes.  As the disprm    */
-  /* struct may not have been initialized, we must parse the dpkey entries. */
+  // Now check for distortions that depend on other axes.  As the disprm
+  // struct may not have been initialized, we must parse the dpkey entries.
   ndpmax = 0;
   for (m = 0; m < 2; m++) {
     if (m == 0) {
@@ -959,7 +957,7 @@ int wcssub(
       for (j = 0; j < naxis; j++) {
         if (map[j] == 0) continue;
 
-        /* Axis numbers in axmap[] are 0-relative. */
+        // Axis numbers in axmap[] are 0-relative.
         for (jhat = 0; jhat < 32; jhat++) {
           axmap[jhat] = -1;
         }
@@ -967,7 +965,7 @@ int wcssub(
         Nhat = 0;
         dpsrc = dissrc->dp;
         for (idp = 0; idp < dissrc->ndp; idp++, dpsrc++) {
-          /* Thorough error checking will be done later by disset(). */
+          // Thorough error checking will be done later by disset().
           if (dpsrc->j != j+1) continue;
           if (dpsrc->field[1] != pq[m]) continue;
           if ((fp = strchr(dpsrc->field, '.')) == 0x0) continue;
@@ -994,12 +992,12 @@ int wcssub(
           if (axmap[jhat] < 0) {
             axmap[jhat] = jhat;
 
-            /* Make room for an additional DPja.AXIS.j record. */
+            // Make room for an additional DPja.AXIS.j record.
             ndp++;
           }
 
           if (map[axmap[jhat]] == 0) {
-            /* Distortion depends on an axis excluded from the subimage. */
+            // Distortion depends on an axis excluded from the subimage.
             status = wcserr_set(WCS_ERRMSG(WCSERR_NON_SEPARABLE));
             goto cleanup;
           }
@@ -1011,7 +1009,7 @@ int wcssub(
   }
 
 
-  /* Number of PVi_ma records in the subimage. */
+  // Number of PVi_ma records in the subimage.
   npvmax = 0;
   for (m = 0; m < wcssrc->npv; m++) {
     i = wcssrc->pv[m].i;
@@ -1020,7 +1018,7 @@ int wcssub(
     }
   }
 
-  /* Number of PSi_ma records in the subimage. */
+  // Number of PSi_ma records in the subimage.
   npsmax = 0;
   for (m = 0; m < wcssrc->nps; m++) {
     i = wcssrc->ps[m].i;
@@ -1029,7 +1027,7 @@ int wcssub(
     }
   }
 
-  /* Initialize the destination. */
+  // Initialize the destination.
   status = wcsinit(alloc, *nsub, wcsdst, npvmax, npsmax, ndpmax);
 
   for (m = 0; m < 2; m++) {
@@ -1046,7 +1044,7 @@ int wcssub(
         return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
       }
 
-      /* Also inits disdst. */
+      // Also inits disdst.
       disdst->flag = -1;
       lindist(m+1, &(wcsdst->lin), disdst, ndpmax);
     }
@@ -1057,7 +1055,7 @@ int wcssub(
   }
 
 
-  /* Linear transformation. */
+  // Linear transformation.
   srcp = wcssrc->crpix;
   dstp = wcsdst->crpix;
   for (j = 0; j < *nsub; j++, dstp++) {
@@ -1087,7 +1085,7 @@ int wcssub(
     }
   }
 
-  /* Coordinate reference value. */
+  // Coordinate reference value.
   srcp = wcssrc->crval;
   dstp = wcsdst->crval;
   for (i = 0; i < *nsub; i++, dstp++) {
@@ -1097,7 +1095,7 @@ int wcssub(
     }
   }
 
-  /* Coordinate units and type. */
+  // Coordinate units and type.
   for (i = 0; i < *nsub; i++) {
     if (axes[i] > 0) {
       k = axes[i] - 1;
@@ -1106,18 +1104,18 @@ int wcssub(
     }
   }
 
-  /* Celestial and spectral transformation parameters. */
+  // Celestial and spectral transformation parameters.
   wcsdst->lonpole = wcssrc->lonpole;
   wcsdst->latpole = wcssrc->latpole;
   wcsdst->restfrq = wcssrc->restfrq;
   wcsdst->restwav = wcssrc->restwav;
 
-  /* Parameter values. */
+  // Parameter values.
   npv = 0;
   for (m = 0; m < wcssrc->npv; m++) {
     i = wcssrc->pv[m].i;
     if (i == 0) {
-      /* i == 0 is a special code that means "the latitude axis". */
+      // i == 0 is a special code that means "the latitude axis".
       wcsdst->pv[npv] = wcssrc->pv[m];
       wcsdst->pv[npv].i = 0;
       npv++;
@@ -1140,47 +1138,51 @@ int wcssub(
   }
   wcsdst->nps = nps;
 
-  /* Alternate linear transformations. */
-  srcp = wcssrc->cd;
-  dstp = wcsdst->cd;
-  for (i = 0; i < *nsub; i++) {
-    for (j = 0; j < *nsub; j++, dstp++) {
-      if (axes[i] > 0 && axes[j] > 0) {
-        k = (axes[i]-1)*naxis + (axes[j]-1);
-        *dstp = *(srcp+k);
-      } else if (i == j && wcssrc->altlin & 2) {
-        /* A new axis is being created where CDi_ja was present in the input
-           header, so override the default value of 0 set by wcsinit(). */
-        *dstp = 1.0;
+  // Alternate linear transformations.
+  if (wcssrc->cd) {
+    srcp = wcssrc->cd;
+    dstp = wcsdst->cd;
+    for (i = 0; i < *nsub; i++) {
+      for (j = 0; j < *nsub; j++, dstp++) {
+        if (axes[i] > 0 && axes[j] > 0) {
+          k = (axes[i]-1)*naxis + (axes[j]-1);
+          *dstp = *(srcp+k);
+        } else if (i == j && wcssrc->altlin & 2) {
+          // A new axis is being created where CDi_ja was present in the input
+          // header, so override the default value of 0 set by wcsinit().
+          *dstp = 1.0;
+        }
       }
     }
   }
 
-  srcp = wcssrc->crota;
-  dstp = wcsdst->crota;
-  for (i = 0; i < *nsub; i++, dstp++) {
-    if (axes[i] > 0) {
-      k = axes[i] - 1;
-      *dstp = *(srcp+k);
+  if (wcssrc->crota) {
+    srcp = wcssrc->crota;
+    dstp = wcsdst->crota;
+    for (i = 0; i < *nsub; i++, dstp++) {
+      if (axes[i] > 0) {
+        k = axes[i] - 1;
+        *dstp = *(srcp+k);
+      }
     }
   }
 
   wcsdst->altlin = wcssrc->altlin;
   wcsdst->velref = wcssrc->velref;
 
-  /* Auxiliary coordinate system information. */
+  // Auxiliary coordinate system information.
   strncpy(wcsdst->alt, wcssrc->alt, 4);
   wcsdst->colnum = wcssrc->colnum;
 
   for (i = 0; i < *nsub; i++) {
     if (axes[i] > 0) {
       k = axes[i] - 1;
-      wcsdst->colax[i] = wcssrc->colax[k];
-      strncpy(wcsdst->cname[i], wcssrc->cname[k], 72);
-      wcsdst->crder[i] = wcssrc->crder[k];
-      wcsdst->csyer[i] = wcssrc->csyer[k];
-      wcsdst->czphs[i] = wcssrc->czphs[k];
-      wcsdst->cperi[i] = wcssrc->cperi[k];
+      if (wcssrc->colax) wcsdst->colax[i] = wcssrc->colax[k];
+      if (wcssrc->cname) strncpy(wcsdst->cname[i], wcssrc->cname[k], 72);
+      if (wcssrc->crder) wcsdst->crder[i] = wcssrc->crder[k];
+      if (wcssrc->csyer) wcsdst->csyer[i] = wcssrc->csyer[k];
+      if (wcssrc->czphs) wcsdst->czphs[i] = wcssrc->czphs[k];
+      if (wcssrc->cperi) wcsdst->cperi[i] = wcssrc->cperi[k];
     }
   }
 
@@ -1236,7 +1238,7 @@ int wcssub(
   wcsdst->velangl = wcssrc->velangl;
 
 
-  /* Additional auxiliary coordinate system information. */
+  // Additional auxiliary coordinate system information.
   if (wcssrc->aux && !wcsdst->aux) {
     if ((wcsdst->aux = calloc(1, sizeof(struct auxprm))) == 0x0) {
       status = wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
@@ -1253,10 +1255,10 @@ int wcssub(
   }
 
 
-  /* Coordinate lookup tables; only copy what's needed. */
+  // Coordinate lookup tables; only copy what's needed.
   wcsdst->ntab = 0;
   for (itab = 0; itab < wcssrc->ntab; itab++) {
-    /* Is this table wanted? */
+    // Is this table wanted?
     for (m = 0; m < wcssrc->tab[itab].M; m++) {
       i = wcssrc->tab[itab].map[m];
 
@@ -1268,7 +1270,7 @@ int wcssub(
   }
 
   if (wcsdst->ntab) {
-    /* Allocate memory for tabprm structs. */
+    // Allocate memory for tabprm structs.
     if ((wcsdst->tab = calloc(wcsdst->ntab, sizeof(struct tabprm))) == 0x0) {
       wcsdst->ntab = 0;
 
@@ -1297,7 +1299,7 @@ int wcssub(
   }
 
 
-  /* Distortion parameters (in linprm). */
+  // Distortion parameters (in linprm).
   for (m = 0; m < 2; m++) {
     if (m == 0) {
       dissrc = wcssrc->lin.dispre;
@@ -1310,7 +1312,7 @@ int wcssub(
     if (dissrc) {
       disdst->naxis = *nsub;
 
-      /* Distortion type and maximum distortion (but not total distortion). */
+      // Distortion type and maximum distortion (but not total distortion).
       for (j = 0; j < *nsub; j++) {
         if (axes[j] > 0) {
           k = axes[j] - 1;
@@ -1319,13 +1321,13 @@ int wcssub(
         }
       }
 
-      /* DPja or DQia keyvalues. */
+      // DPja or DQia keyvalues.
       ndp = 0;
       dpdst = disdst->dp;
       for (j = 0; j < *nsub; j++) {
         if (axes[j] == 0) continue;
 
-        /* Determine the axis mapping. */
+        // Determine the axis mapping.
         for (jhat = 0; jhat < 32; jhat++) {
           axmap[jhat] = -1;
         }
@@ -1352,7 +1354,7 @@ int wcssub(
           }
         }
 
-        /* Copy the DPja or DQia keyvalues. */
+        // Copy the DPja or DQia keyvalues.
         dpsrc = dissrc->dp;
         for (idp = 0; idp < dissrc->ndp; idp++, dpsrc++) {
           if (dpsrc->j != axes[j]) continue;
@@ -1361,7 +1363,7 @@ int wcssub(
           fp++;
 
           if (strncmp(fp, "AXIS.", 5) == 0) {
-            /* Skip it, we will create our own later. */
+            // Skip it, we will create our own later.
             continue;
           }
 
@@ -1416,7 +1418,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcscompare(
   int cmp,
@@ -1445,7 +1447,7 @@ int wcscompare(
   naxis2 = wcs1->naxis*wcs1->naxis;
 
   if (cmp & WCSCOMPARE_CRPIX) {
-    /* Don't compare crpix. */
+    // Don't compare crpix.
   } else if (cmp & WCSCOMPARE_TILING) {
     for (i = 0; i < naxis; ++i) {
       diff = wcs1->crpix[i] - wcs2->crpix[i];
@@ -1454,43 +1456,43 @@ int wcscompare(
       }
     }
   } else {
-    if (!wcsutil_Eq(naxis, tol, wcs1->crpix, wcs2->crpix)) {
+    if (!wcsutil_dblEq(naxis, tol, wcs1->crpix, wcs2->crpix)) {
       return 0;
     }
   }
 
-  if (!wcsutil_Eq(naxis2, tol, wcs1->pc, wcs2->pc) ||
-      !wcsutil_Eq(naxis, tol, wcs1->cdelt, wcs2->cdelt) ||
-      !wcsutil_Eq(naxis, tol, wcs1->crval, wcs2->crval) ||
+  if (!wcsutil_dblEq(naxis2, tol, wcs1->pc, wcs2->pc) ||
+      !wcsutil_dblEq(naxis, tol, wcs1->cdelt, wcs2->cdelt) ||
+      !wcsutil_dblEq(naxis, tol, wcs1->crval, wcs2->crval) ||
       !wcsutil_strEq(naxis, wcs1->cunit, wcs2->cunit) ||
       !wcsutil_strEq(naxis, wcs1->ctype, wcs2->ctype) ||
-      !wcsutil_Eq(1, tol, &wcs1->lonpole, &wcs2->lonpole) ||
-      !wcsutil_Eq(1, tol, &wcs1->latpole, &wcs2->latpole) ||
-      !wcsutil_Eq(1, tol, &wcs1->restfrq, &wcs2->restfrq) ||
-      !wcsutil_Eq(1, tol, &wcs1->restwav, &wcs2->restwav) ||
+      !wcsutil_dblEq(1, tol, &wcs1->lonpole, &wcs2->lonpole) ||
+      !wcsutil_dblEq(1, tol, &wcs1->latpole, &wcs2->latpole) ||
+      !wcsutil_dblEq(1, tol, &wcs1->restfrq, &wcs2->restfrq) ||
+      !wcsutil_dblEq(1, tol, &wcs1->restwav, &wcs2->restwav) ||
       wcs1->npv != wcs2->npv ||
       wcs1->nps != wcs2->nps) {
     return 0;
   }
 
-  /* Compare pv cards, which may not be in the same order */
+  // Compare pv cards, which may not be in the same order
   for (i = 0; i < wcs1->npv; ++i) {
     for (j = 0; j < wcs2->npv; ++j) {
       if (wcs1->pv[i].i == wcs2->pv[j].i &&
           wcs1->pv[i].m == wcs2->pv[j].m) {
-        if (!wcsutil_Eq(1, tol, &wcs1->pv[i].value, &wcs2->pv[j].value)) {
+        if (!wcsutil_dblEq(1, tol, &wcs1->pv[i].value, &wcs2->pv[j].value)) {
           return 0;
         }
         break;
       }
     }
-    /* We didn't find a match, so they are not equal */
+    // We didn't find a match, so they are not equal
     if (j == wcs2->npv) {
       return 0;
     }
   }
 
-  /* Compare ps cards, which may not be in the same order */
+  // Compare ps cards, which may not be in the same order
   for (i = 0; i < wcs1->nps; ++i) {
     for (j = 0; j < wcs2->nps; ++j) {
       if (wcs1->ps[i].i == wcs2->ps[j].i &&
@@ -1501,15 +1503,15 @@ int wcscompare(
         break;
       }
     }
-    /* We didn't find a match, so they are not equal */
+    // We didn't find a match, so they are not equal
     if (j == wcs2->nps) {
       return 0;
     }
   }
 
   if (wcs1->flag != WCSSET || wcs2->flag != WCSSET) {
-    if (!wcsutil_Eq(naxis2, tol, wcs1->cd, wcs2->cd) ||
-        !wcsutil_Eq(naxis, tol, wcs1->crota, wcs2->crota) ||
+    if (!wcsutil_dblEq(naxis2, tol, wcs1->cd, wcs2->cd) ||
+        !wcsutil_dblEq(naxis, tol, wcs1->crota, wcs2->crota) ||
         wcs1->altlin != wcs2->altlin ||
         wcs1->velref != wcs2->velref) {
       return 0;
@@ -1521,10 +1523,10 @@ int wcscompare(
         wcs1->colnum != wcs2->colnum ||
         !wcsutil_intEq(naxis, wcs1->colax, wcs2->colax) ||
         !wcsutil_strEq(naxis, wcs1->cname, wcs2->cname) ||
-        !wcsutil_Eq(naxis, tol, wcs1->crder, wcs2->crder) ||
-        !wcsutil_Eq(naxis, tol, wcs1->csyer, wcs2->csyer) ||
-        !wcsutil_Eq(naxis, tol, wcs1->czphs, wcs2->czphs) ||
-        !wcsutil_Eq(naxis, tol, wcs1->cperi, wcs2->cperi) ||
+        !wcsutil_dblEq(naxis, tol, wcs1->crder, wcs2->crder) ||
+        !wcsutil_dblEq(naxis, tol, wcs1->csyer, wcs2->csyer) ||
+        !wcsutil_dblEq(naxis, tol, wcs1->czphs, wcs2->czphs) ||
+        !wcsutil_dblEq(naxis, tol, wcs1->cperi, wcs2->cperi) ||
         strncmp(wcs1->wcsname,  wcs2->wcsname,  72) ||
         strncmp(wcs1->timesys,  wcs2->timesys,  72) ||
         strncmp(wcs1->trefpos,  wcs2->trefpos,  72) ||
@@ -1532,46 +1534,46 @@ int wcscompare(
         strncmp(wcs1->plephem,  wcs2->plephem,  72) ||
         strncmp(wcs1->timeunit, wcs2->timeunit, 72) ||
         strncmp(wcs1->dateref,  wcs2->dateref,  72) ||
-        !wcsutil_Eq(2, tol,  wcs1->mjdref,    wcs2->mjdref)   ||
-        !wcsutil_Eq(1, tol, &wcs1->timeoffs, &wcs2->timeoffs) ||
+        !wcsutil_dblEq(2, tol,  wcs1->mjdref,    wcs2->mjdref)   ||
+        !wcsutil_dblEq(1, tol, &wcs1->timeoffs, &wcs2->timeoffs) ||
         strncmp(wcs1->dateobs,  wcs2->dateobs, 72) ||
         strncmp(wcs1->datebeg,  wcs2->datebeg, 72) ||
         strncmp(wcs1->dateavg,  wcs2->dateavg, 72) ||
         strncmp(wcs1->dateend,  wcs2->dateend, 72) ||
-        !wcsutil_Eq(1, tol, &wcs1->mjdobs,   &wcs2->mjdobs)   ||
-        !wcsutil_Eq(1, tol, &wcs1->mjdbeg,   &wcs2->mjdbeg)   ||
-        !wcsutil_Eq(1, tol, &wcs1->mjdavg,   &wcs2->mjdavg)   ||
-        !wcsutil_Eq(1, tol, &wcs1->mjdend,   &wcs2->mjdend)   ||
-        !wcsutil_Eq(1, tol, &wcs1->jepoch,   &wcs2->jepoch)   ||
-        !wcsutil_Eq(1, tol, &wcs1->bepoch,   &wcs2->bepoch)   ||
-        !wcsutil_Eq(1, tol, &wcs1->tstart,   &wcs2->tstart)   ||
-        !wcsutil_Eq(1, tol, &wcs1->tstop,    &wcs2->tstop)    ||
-        !wcsutil_Eq(1, tol, &wcs1->xposure,  &wcs2->xposure)  ||
-        !wcsutil_Eq(1, tol, &wcs1->telapse,  &wcs2->telapse)  ||
-        !wcsutil_Eq(1, tol, &wcs1->timsyer,  &wcs2->timsyer)  ||
-        !wcsutil_Eq(1, tol, &wcs1->timrder,  &wcs2->timrder)  ||
-        !wcsutil_Eq(1, tol, &wcs1->timedel,  &wcs2->timedel)  ||
-        !wcsutil_Eq(1, tol, &wcs1->timepixr, &wcs2->timepixr) ||
-        !wcsutil_Eq(6, tol,  wcs1->obsgeo,    wcs2->obsgeo)   ||
+        !wcsutil_dblEq(1, tol, &wcs1->mjdobs,   &wcs2->mjdobs)   ||
+        !wcsutil_dblEq(1, tol, &wcs1->mjdbeg,   &wcs2->mjdbeg)   ||
+        !wcsutil_dblEq(1, tol, &wcs1->mjdavg,   &wcs2->mjdavg)   ||
+        !wcsutil_dblEq(1, tol, &wcs1->mjdend,   &wcs2->mjdend)   ||
+        !wcsutil_dblEq(1, tol, &wcs1->jepoch,   &wcs2->jepoch)   ||
+        !wcsutil_dblEq(1, tol, &wcs1->bepoch,   &wcs2->bepoch)   ||
+        !wcsutil_dblEq(1, tol, &wcs1->tstart,   &wcs2->tstart)   ||
+        !wcsutil_dblEq(1, tol, &wcs1->tstop,    &wcs2->tstop)    ||
+        !wcsutil_dblEq(1, tol, &wcs1->xposure,  &wcs2->xposure)  ||
+        !wcsutil_dblEq(1, tol, &wcs1->telapse,  &wcs2->telapse)  ||
+        !wcsutil_dblEq(1, tol, &wcs1->timsyer,  &wcs2->timsyer)  ||
+        !wcsutil_dblEq(1, tol, &wcs1->timrder,  &wcs2->timrder)  ||
+        !wcsutil_dblEq(1, tol, &wcs1->timedel,  &wcs2->timedel)  ||
+        !wcsutil_dblEq(1, tol, &wcs1->timepixr, &wcs2->timepixr) ||
+        !wcsutil_dblEq(6, tol,  wcs1->obsgeo,    wcs2->obsgeo)   ||
         strncmp(wcs1->obsorbit, wcs2->obsorbit, 72) ||
         strncmp(wcs1->radesys,  wcs2->radesys,  72) ||
-        !wcsutil_Eq(1, tol, &wcs1->equinox,  &wcs2->equinox)  ||
+        !wcsutil_dblEq(1, tol, &wcs1->equinox,  &wcs2->equinox)  ||
         strncmp(wcs1->specsys,  wcs2->specsys,  72) ||
         strncmp(wcs1->ssysobs,  wcs2->ssysobs,  72) ||
-        !wcsutil_Eq(1, tol, &wcs1->velosys,  &wcs2->velosys)  ||
-        !wcsutil_Eq(1, tol, &wcs1->zsource,  &wcs2->zsource)  ||
+        !wcsutil_dblEq(1, tol, &wcs1->velosys,  &wcs2->velosys)  ||
+        !wcsutil_dblEq(1, tol, &wcs1->zsource,  &wcs2->zsource)  ||
         strncmp(wcs1->ssyssrc,  wcs2->ssyssrc,  72) ||
-        !wcsutil_Eq(1, tol, &wcs1->velangl,  &wcs2->velangl)) {
+        !wcsutil_dblEq(1, tol, &wcs1->velangl,  &wcs2->velangl)) {
       return 0;
     }
 
-    /* Compare additional auxiliary parameters. */
+    // Compare additional auxiliary parameters.
     if (wcs1->aux && wcs2->aux) {
-      if (!wcsutil_Eq(1, tol, &wcs1->aux->rsun_ref, &wcs2->aux->rsun_ref) ||
-          !wcsutil_Eq(1, tol, &wcs1->aux->dsun_obs, &wcs2->aux->dsun_obs) ||
-          !wcsutil_Eq(1, tol, &wcs1->aux->crln_obs, &wcs2->aux->crln_obs) ||
-          !wcsutil_Eq(1, tol, &wcs1->aux->hgln_obs, &wcs2->aux->hgln_obs) ||
-          !wcsutil_Eq(1, tol, &wcs1->aux->hglt_obs, &wcs2->aux->hglt_obs)) {
+      if (!wcsutil_dblEq(1, tol, &wcs1->aux->rsun_ref, &wcs2->aux->rsun_ref) ||
+          !wcsutil_dblEq(1, tol, &wcs1->aux->dsun_obs, &wcs2->aux->dsun_obs) ||
+          !wcsutil_dblEq(1, tol, &wcs1->aux->crln_obs, &wcs2->aux->crln_obs) ||
+          !wcsutil_dblEq(1, tol, &wcs1->aux->hgln_obs, &wcs2->aux->hgln_obs) ||
+          !wcsutil_dblEq(1, tol, &wcs1->aux->hglt_obs, &wcs2->aux->hglt_obs)) {
         return 0;
       }
     } else if (wcs1->aux || wcs2->aux) {
@@ -1579,7 +1581,7 @@ int wcscompare(
     }
   }
 
-  /* Compare tabular parameters */
+  // Compare tabular parameters
   if (wcs1->ntab != wcs2->ntab) {
     return 0;
   }
@@ -1597,22 +1599,20 @@ int wcscompare(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsfree(struct wcsprm *wcs)
 
 {
-  int j;
-
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
 
   if (wcs->flag == -1) {
     wcs->lin.flag = -1;
 
   } else {
-    /* Optionally allocated by wcsinit() for given parameters. */
+    // Optionally allocated by wcsinit() for given parameters.
     if (wcs->m_flag == WCSSET) {
-      /* Start by cleaning the slate. */
+      // Start by cleaning the slate.
       if (wcs->crpix == wcs->m_crpix) wcs->crpix = 0x0;
       if (wcs->pc    == wcs->m_pc)    wcs->pc    = 0x0;
       if (wcs->cdelt == wcs->m_cdelt) wcs->cdelt = 0x0;
@@ -1634,7 +1634,7 @@ int wcsfree(struct wcsprm *wcs)
       if (wcs->tab   == wcs->m_tab)   wcs->tab   = 0x0;
       if (wcs->wtb   == wcs->m_wtb)   wcs->wtb   = 0x0;
 
-      /* Now release the memory. */
+      // Now release the memory.
       if (wcs->m_crpix)  free(wcs->m_crpix);
       if (wcs->m_pc)     free(wcs->m_pc);
       if (wcs->m_cdelt)  free(wcs->m_cdelt);
@@ -1652,13 +1652,13 @@ int wcsfree(struct wcsprm *wcs)
       if (wcs->m_czphs)  free(wcs->m_czphs);
       if (wcs->m_cperi)  free(wcs->m_cperi);
 
-      /* May have been allocated by wcspih() or wcssub(). */
+      // May have been allocated by wcspih() or wcssub().
       if (wcs->m_aux) free(wcs->m_aux);
 
-      /* Allocated unconditionally by wcstab(). */
+      // Allocated unconditionally by wcstab().
       if (wcs->m_tab) {
-        for (j = 0; j < wcs->ntab; j++) {
-          tabfree(wcs->m_tab + j);
+        for (int itab = 0; itab < wcs->ntab; itab++) {
+          tabfree(wcs->m_tab + itab);
         }
 
         free(wcs->m_tab);
@@ -1666,7 +1666,7 @@ int wcsfree(struct wcsprm *wcs)
       if (wcs->m_wtb) free(wcs->m_wtb);
     }
 
-    /* Allocated unconditionally by wcsset(). */
+    // Allocated unconditionally by wcsset().
     if (wcs->types) free(wcs->types);
 
     if (wcs->lin.crpix == wcs->m_crpix) wcs->lin.crpix = 0x0;
@@ -1710,10 +1710,251 @@ int wcsfree(struct wcsprm *wcs)
   celfree(&(wcs->cel));
   spcfree(&(wcs->spc));
 
-  return 0;
+  return WCSERR_SUCCESS;
+}
+
+//----------------------------------------------------------------------------
+
+int wcstrim(struct wcsprm *wcs)
+
+{
+  if (wcs == 0x0) return WCSERR_NULL_POINTER;
+
+  if (wcs->m_flag != WCSSET) {
+    // Nothing to do.
+    return WCSERR_SUCCESS;
+  }
+
+  if (wcs->flag != WCSSET) {
+    return WCSERR_UNSET;
+  }
+
+  if (wcs->npv < wcs->npvmax) {
+    if (wcs->m_pv) {
+      if (wcs->npv == 0) {
+        free(wcs->m_pv);
+        wcs->pv = wcs->m_pv = 0x0;
+      } else {
+        size_t size = wcs->npv * sizeof(struct pvcard);
+        // No error if realloc() fails, it will leave the array untouched.
+        if ((wcs->pv = wcs->m_pv = realloc(wcs->m_pv, size))) {
+          wcs->npvmax = wcs->npv;
+        }
+      }
+    }
+  }
+
+  if (wcs->nps < wcs->npsmax) {
+    if (wcs->m_ps) {
+      if (wcs->nps == 0) {
+        free(wcs->m_ps);
+        wcs->ps = wcs->m_ps = 0x0;
+      } else {
+        size_t size = wcs->nps * sizeof(struct pscard);
+        // No error if realloc() fails, it will leave the array untouched.
+        if ((wcs->ps = wcs->m_ps = realloc(wcs->m_ps, size))) {
+          wcs->npsmax = wcs->nps;
+        }
+      }
+    }
+  }
+
+  if (!(wcs->altlin & 2)) {
+    if (wcs->m_cd) {
+      free(wcs->m_cd);
+      wcs->cd = wcs->m_cd = 0x0;
+    }
+  }
+
+  if (!(wcs->altlin & 4)) {
+    if (wcs->m_crota) {
+      free(wcs->m_crota);
+      wcs->crota = wcs->m_crota = 0x0;
+    }
+  }
+
+  if (wcs->colax) {
+    if (wcsutil_all_ival(wcs->naxis, 0, wcs->colax)) {
+      free(wcs->m_colax);
+      wcs->colax = wcs->m_colax = 0x0;
+    }
+  }
+
+  if (wcs->cname) {
+    if (wcsutil_all_sval(wcs->naxis, "", wcs->cname)) {
+      free(wcs->m_cname);
+      wcs->cname = wcs->m_cname = 0x0;
+    }
+  }
+
+  if (wcs->crder) {
+    if (wcsutil_all_dval(wcs->naxis, UNDEFINED, wcs->crder)) {
+      free(wcs->m_crder);
+      wcs->crder = wcs->m_crder = 0x0;
+    }
+  }
+
+  if (wcs->csyer) {
+    if (wcsutil_all_dval(wcs->naxis, UNDEFINED, wcs->csyer)) {
+      free(wcs->m_csyer);
+      wcs->csyer = wcs->m_csyer = 0x0;
+    }
+  }
+
+  if (wcs->czphs) {
+    if (wcsutil_all_dval(wcs->naxis, UNDEFINED, wcs->czphs)) {
+      free(wcs->m_czphs);
+      wcs->czphs = wcs->m_czphs = 0x0;
+    }
+  }
+
+  if (wcs->cperi) {
+    if (wcsutil_all_dval(wcs->naxis, UNDEFINED, wcs->cperi)) {
+      free(wcs->m_cperi);
+      wcs->cperi = wcs->m_cperi = 0x0;
+    }
+  }
+
+  return WCSERR_SUCCESS;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
+
+int wcssize(const struct wcsprm *wcs, int sizes[2])
+
+{
+  if (wcs == 0x0) {
+    sizes[0] = sizes[1] = 0;
+    return WCSERR_SUCCESS;
+  }
+
+  // Base size, in bytes.
+  sizes[0] = sizeof(struct wcsprm);
+
+  // Total size of allocated memory, in bytes.
+  sizes[1] = 0;
+
+  int exsizes[2];
+  int naxis = wcs->naxis;
+
+  // wcsprm::crpix[].
+  sizes[1] += naxis * sizeof(double);
+
+  // wcsprm::pc[].
+  sizes[1] += naxis*naxis * sizeof(double);
+
+  // wcsprm::cdelt[].
+  sizes[1] += naxis * sizeof(double);
+
+  // wcsprm::crval[].
+  sizes[1] += naxis * sizeof(double);
+
+  // wcsprm::cunit[].
+  if (wcs->cunit) {
+    sizes[1] += naxis * sizeof(char [72]);
+  }
+
+  // wcsprm::ctype[].
+  sizes[1] += naxis * sizeof(char [72]);
+
+  // wcsprm::pv[].
+  if (wcs->pv) {
+    sizes[1] += wcs->npvmax * sizeof(struct pvcard);
+  }
+
+  // wcsprm::ps[].
+  if (wcs->ps) {
+    sizes[1] += wcs->npsmax * sizeof(struct pscard);
+  }
+
+  // wcsprm::cd[].
+  if (wcs->cd) {
+    sizes[1] += naxis*naxis * sizeof(double);
+  }
+
+  // wcsprm::crota[].
+  if (wcs->crota) {
+    sizes[1] += naxis * sizeof(double);
+  }
+
+  // wcsprm::colax[].
+  if (wcs->colax) {
+    sizes[1] += naxis * sizeof(int);
+  }
+
+  // wcsprm::cname[].
+  if (wcs->cname) {
+    sizes[1] += naxis * sizeof(char [72]);
+  }
+
+  // wcsprm::crder[].
+  if (wcs->crder) {
+    sizes[1] += naxis * sizeof(double);
+  }
+
+  // wcsprm::csyer[].
+  if (wcs->csyer) {
+    sizes[1] += naxis * sizeof(double);
+  }
+
+  // wcsprm::czphs[].
+  if (wcs->czphs) {
+    sizes[1] += naxis * sizeof(double);
+  }
+
+  // wcsprm::cperi[].
+  if (wcs->cperi) {
+    sizes[1] += naxis * sizeof(double);
+  }
+
+  // wcsprm::aux.
+  if (wcs->aux) {
+    sizes[1] += sizeof(struct auxprm);
+  }
+
+  // wcsprm::tab.
+  for (int itab = 0; itab < wcs->ntab; itab++) {
+    tabsize(wcs->tab + itab, exsizes);
+    sizes[1] += exsizes[0] + exsizes[1];
+  }
+
+  // wcsprm::wtb.
+  if (wcs->wtb) {
+    sizes[1] += wcs->nwtb * sizeof(struct wtbarr);
+  }
+
+  // wcsprm::lin.
+  linsize(&(wcs->lin), exsizes);
+  sizes[1] += exsizes[1];
+
+  // wcsprm::err.
+  wcserr_size(wcs->err, exsizes);
+  sizes[1] += exsizes[0] + exsizes[1];
+
+  return WCSERR_SUCCESS;
+}
+
+//----------------------------------------------------------------------------
+
+int auxsize(const struct auxprm *aux, int sizes[2])
+
+{
+  if (aux == 0x0) {
+    sizes[0] = sizes[1] = 0;
+    return WCSERR_SUCCESS;
+  }
+
+  // Base size, in bytes.
+  sizes[0] = sizeof(struct auxprm);
+
+  // Total size of allocated memory, in bytes.
+  sizes[1] = 0;
+
+  return WCSERR_SUCCESS;
+}
+
+
+//----------------------------------------------------------------------------
 
 static void wcsprt_auxc(const char *name, const char *value)
 {
@@ -1736,64 +1977,61 @@ static void wcsprt_auxd(const char *name
 int wcsprt(const struct wcsprm *wcs)
 
 {
-  int i, j, k;
-  struct wtbarr *wtbp;
-
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
 
   if (wcs->flag != WCSSET) {
     wcsprintf("The wcsprm struct is UNINITIALIZED.\n");
-    return 0;
+    return WCSERR_SUCCESS;
   }
 
   wcsprintf("       flag: %d\n", wcs->flag);
   wcsprintf("      naxis: %d\n", wcs->naxis);
   WCSPRINTF_PTR("      crpix: ", wcs->crpix, "\n");
   wcsprintf("            ");
-  for (i = 0; i < wcs->naxis; i++) {
+  for (int i = 0; i < wcs->naxis; i++) {
     wcsprintf("  %#- 11.5g", wcs->crpix[i]);
   }
   wcsprintf("\n");
 
-  /* Linear transformation. */
-  k = 0;
+  // Linear transformation.
+  int k = 0;
   WCSPRINTF_PTR("         pc: ", wcs->pc, "\n");
-  for (i = 0; i < wcs->naxis; i++) {
+  for (int i = 0; i < wcs->naxis; i++) {
     wcsprintf("    pc[%d][]:", i);
-    for (j = 0; j < wcs->naxis; j++) {
+    for (int j = 0; j < wcs->naxis; j++) {
       wcsprintf("  %#- 11.5g", wcs->pc[k++]);
     }
     wcsprintf("\n");
   }
 
-  /* Coordinate increment at reference point. */
+  // Coordinate increment at reference point.
   WCSPRINTF_PTR("      cdelt: ", wcs->cdelt, "\n");
   wcsprintf("            ");
-  for (i = 0; i < wcs->naxis; i++) {
+  for (int i = 0; i < wcs->naxis; i++) {
     wcsprintf("  %#- 11.5g", wcs->cdelt[i]);
   }
   wcsprintf("\n");
 
-  /* Coordinate value at reference point. */
+  // Coordinate value at reference point.
   WCSPRINTF_PTR("      crval: ", wcs->crval, "\n");
   wcsprintf("            ");
-  for (i = 0; i < wcs->naxis; i++) {
+  for (int i = 0; i < wcs->naxis; i++) {
     wcsprintf("  %#- 11.5g", wcs->crval[i]);
   }
   wcsprintf("\n");
 
-  /* Coordinate units and type. */
+  // Coordinate units and type.
   WCSPRINTF_PTR("      cunit: ", wcs->cunit, "\n");
-  for (i = 0; i < wcs->naxis; i++) {
+  for (int i = 0; i < wcs->naxis; i++) {
     wcsprintf("             \"%s\"\n", wcs->cunit[i]);
   }
 
   WCSPRINTF_PTR("      ctype: ", wcs->ctype, "\n");
-  for (i = 0; i < wcs->naxis; i++) {
+  for (int i = 0; i < wcs->naxis; i++) {
     wcsprintf("             \"%s\"\n", wcs->ctype[i]);
   }
 
-  /* Celestial and spectral transformation parameters. */
+  // Celestial and spectral transformation parameters.
   if (undefined(wcs->lonpole)) {
     wcsprintf("    lonpole: UNDEFINED\n");
   } else {
@@ -1803,29 +2041,29 @@ int wcsprt(const struct wcsprm *wcs)
   wcsprintf("    restfrq: %f\n", wcs->restfrq);
   wcsprintf("    restwav: %f\n", wcs->restwav);
 
-  /* Parameter values. */
+  // Parameter values.
   wcsprintf("        npv: %d\n", wcs->npv);
   wcsprintf("     npvmax: %d\n", wcs->npvmax);
   WCSPRINTF_PTR("         pv: ", wcs->pv, "\n");
-  for (i = 0; i < wcs->npv; i++) {
-    wcsprintf("             %3d%4d  %#- 11.5g\n", (wcs->pv[i]).i,
-      (wcs->pv[i]).m, (wcs->pv[i]).value);
+  for (int k = 0; k < wcs->npv; k++) {
+    wcsprintf("             %3d%4d  %#- 11.5g\n", (wcs->pv[k]).i,
+      (wcs->pv[k]).m, (wcs->pv[k]).value);
   }
   wcsprintf("        nps: %d\n", wcs->nps);
   wcsprintf("     npsmax: %d\n", wcs->npsmax);
   WCSPRINTF_PTR("         ps: ", wcs->ps, "\n");
-  for (i = 0; i < wcs->nps; i++) {
-    wcsprintf("             %3d%4d  %s\n", (wcs->ps[i]).i,
-      (wcs->ps[i]).m, (wcs->ps[i]).value);
+  for (int k = 0; k < wcs->nps; k++) {
+    wcsprintf("             %3d%4d  %s\n", (wcs->ps[k]).i,
+      (wcs->ps[k]).m, (wcs->ps[k]).value);
   }
 
-  /* Alternate linear transformations. */
+  // Alternate linear transformations.
   k = 0;
   WCSPRINTF_PTR("         cd: ", wcs->cd, "\n");
   if (wcs->cd) {
-    for (i = 0; i < wcs->naxis; i++) {
+    for (int i = 0; i < wcs->naxis; i++) {
       wcsprintf("    cd[%d][]:", i);
-      for (j = 0; j < wcs->naxis; j++) {
+      for (int j = 0; j < wcs->naxis; j++) {
         wcsprintf("  %#- 11.5g", wcs->cd[k++]);
       }
       wcsprintf("\n");
@@ -1835,7 +2073,7 @@ int wcsprt(const struct wcsprm *wcs)
   WCSPRINTF_PTR("      crota: ", wcs->crota, "\n");
   if (wcs->crota) {
     wcsprintf("            ");
-    for (i = 0; i < wcs->naxis; i++) {
+    for (int i = 0; i < wcs->naxis; i++) {
       wcsprintf("  %#- 11.5g", wcs->crota[i]);
     }
     wcsprintf("\n");
@@ -1846,14 +2084,14 @@ int wcsprt(const struct wcsprm *wcs)
 
 
 
-  /* Auxiliary coordinate system information. */
+  // Auxiliary coordinate system information.
   wcsprintf("        alt: '%c'\n", wcs->alt[0]);
   wcsprintf("     colnum: %d\n", wcs->colnum);
 
   WCSPRINTF_PTR("      colax: ", wcs->colax, "\n");
   if (wcs->colax) {
     wcsprintf("           ");
-    for (i = 0; i < wcs->naxis; i++) {
+    for (int i = 0; i < wcs->naxis; i++) {
       wcsprintf("  %5d", wcs->colax[i]);
     }
     wcsprintf("\n");
@@ -1861,7 +2099,7 @@ int wcsprt(const struct wcsprm *wcs)
 
   WCSPRINTF_PTR("      cname: ", wcs->cname, "\n");
   if (wcs->cname) {
-    for (i = 0; i < wcs->naxis; i++) {
+    for (int i = 0; i < wcs->naxis; i++) {
       if (wcs->cname[i][0] == '\0') {
         wcsprintf("             UNDEFINED\n");
       } else {
@@ -1873,7 +2111,7 @@ int wcsprt(const struct wcsprm *wcs)
   WCSPRINTF_PTR("      crder: ", wcs->crder, "\n");
   if (wcs->crder) {
     wcsprintf("           ");
-    for (i = 0; i < wcs->naxis; i++) {
+    for (int i = 0; i < wcs->naxis; i++) {
       if (undefined(wcs->crder[i])) {
         wcsprintf("    UNDEFINED");
       } else {
@@ -1886,7 +2124,7 @@ int wcsprt(const struct wcsprm *wcs)
   WCSPRINTF_PTR("      csyer: ", wcs->csyer, "\n");
   if (wcs->csyer) {
     wcsprintf("           ");
-    for (i = 0; i < wcs->naxis; i++) {
+    for (int i = 0; i < wcs->naxis; i++) {
       if (undefined(wcs->csyer[i])) {
         wcsprintf("    UNDEFINED");
       } else {
@@ -1899,7 +2137,7 @@ int wcsprt(const struct wcsprm *wcs)
   WCSPRINTF_PTR("      czphs: ", wcs->czphs, "\n");
   if (wcs->czphs) {
     wcsprintf("           ");
-    for (i = 0; i < wcs->naxis; i++) {
+    for (int i = 0; i < wcs->naxis; i++) {
       if (undefined(wcs->czphs[i])) {
         wcsprintf("    UNDEFINED");
       } else {
@@ -1912,7 +2150,7 @@ int wcsprt(const struct wcsprm *wcs)
   WCSPRINTF_PTR("      cperi: ", wcs->cperi, "\n");
   if (wcs->cperi) {
     wcsprintf("           ");
-    for (i = 0; i < wcs->naxis; i++) {
+    for (int i = 0; i < wcs->naxis; i++) {
       if (undefined(wcs->cperi[i])) {
         wcsprintf("    UNDEFINED");
       } else {
@@ -1931,11 +2169,11 @@ int wcsprt(const struct wcsprm *wcs)
   wcsprt_auxc("timeunit", wcs->timeunit);
   wcsprt_auxc(" dateref", wcs->dateref);
   wcsprintf("     mjdref: ");
-  for (i = 0; i < 2; i++) {
-    if (undefined(wcs->mjdref[i])) {
+  for (int k = 0; k < 2; k++) {
+    if (undefined(wcs->mjdref[k])) {
       wcsprintf("       UNDEFINED");
     } else {
-      wcsprintf(" %15.9f", wcs->mjdref[i]);
+      wcsprintf(" %15.9f", wcs->mjdref[k]);
     }
   }
   wcsprintf("\n");
@@ -1963,19 +2201,19 @@ int wcsprt(const struct wcsprm *wcs)
   wcsprt_auxd("timepixr", wcs->timepixr);
 
   wcsprintf("     obsgeo: ");
-  for (i = 0; i < 3; i++) {
-    if (undefined(wcs->obsgeo[i])) {
+  for (int k = 0; k < 3; k++) {
+    if (undefined(wcs->obsgeo[k])) {
       wcsprintf("       UNDEFINED");
     } else {
-      wcsprintf(" %15.6f", wcs->obsgeo[i]);
+      wcsprintf(" %15.6f", wcs->obsgeo[k]);
     }
   }
   wcsprintf("\n             ");
-  for (i = 3; i < 6; i++) {
-    if (undefined(wcs->obsgeo[i])) {
+  for (int k = 3; k < 6; k++) {
+    if (undefined(wcs->obsgeo[k])) {
       wcsprintf("       UNDEFINED");
     } else {
-      wcsprintf(" %15.6f", wcs->obsgeo[i]);
+      wcsprintf(" %15.6f", wcs->obsgeo[k]);
     }
   }
   wcsprintf("\n");
@@ -1990,7 +2228,7 @@ int wcsprt(const struct wcsprm *wcs)
   wcsprt_auxc(" ssyssrc", wcs->ssyssrc);
   wcsprt_auxd(" velangl", wcs->velangl);
 
-  /* Additional auxiliary coordinate system information. */
+  // Additional auxiliary coordinate system information.
   WCSPRINTF_PTR("        aux: ", wcs->aux, "\n");
   if (wcs->aux) {
     wcsprt_auxd("rsun_ref", wcs->aux->rsun_ref);
@@ -2009,9 +2247,9 @@ int wcsprt(const struct wcsprm *wcs)
   if (wcs->wtb != 0x0) wcsprintf("  (see below)");
   wcsprintf("\n");
 
-  /* Derived values. */
+  // Derived values.
   WCSPRINTF_PTR("      types: ", wcs->types, "\n           ");
-  for (i = 0; i < wcs->naxis; i++) {
+  for (int i = 0; i < wcs->naxis; i++) {
     wcsprintf("%5d", wcs->types[i]);
   }
   wcsprintf("\n");
@@ -2032,7 +2270,7 @@ int wcsprt(const struct wcsprm *wcs)
   wcsprintf("        cel: (see below)\n");
   wcsprintf("        spc: (see below)\n");
 
-  /* Memory management. */
+  // Memory management.
   wcsprintf("     m_flag: %d\n", wcs->m_flag);
   wcsprintf("    m_naxis: %d\n", wcs->m_naxis);
   WCSPRINTF_PTR("    m_crpix: ", wcs->m_crpix, "");
@@ -2094,11 +2332,12 @@ int wcsprt(const struct wcsprm *wcs)
   if (wcs->m_wtb == wcs->wtb) wcsprintf("  (= wtb)");
   wcsprintf("\n");
 
-  /* Tabular transformation parameters. */
-  if ((wtbp = wcs->wtb)) {
-    for (j = 0; j < wcs->nwtb; j++, wtbp++) {
+  // Tabular transformation parameters.
+  struct wtbarr *wtbp = wcs->wtb;
+  if (wtbp) {
+    for (int iwtb = 0; iwtb < wcs->nwtb; iwtb++, wtbp++) {
       wcsprintf("\n");
-      wcsprintf("wtb[%d].*\n", j);
+      wcsprintf("wtb[%d].*\n", iwtb);
       wcsprintf("          i: %d\n", wtbp->i);
       wcsprintf("          m: %d\n", wtbp->m);
       wcsprintf("       kind: %c\n", wtbp->kind);
@@ -2115,38 +2354,36 @@ int wcsprt(const struct wcsprm *wcs)
   }
 
   if (wcs->tab) {
-    for (j = 0; j < wcs->ntab; j++) {
+    for (int itab = 0; itab < wcs->ntab; itab++) {
       wcsprintf("\n");
-      wcsprintf("tab[%d].*\n", j);
-      tabprt(wcs->tab + j);
+      wcsprintf("tab[%d].*\n", itab);
+      tabprt(wcs->tab + itab);
     }
   }
 
-  /* Linear transformation parameters. */
+  // Linear transformation parameters.
   wcsprintf("\n");
   wcsprintf("   lin.*\n");
   linprt(&(wcs->lin));
 
-  /* Celestial transformation parameters. */
+  // Celestial transformation parameters.
   wcsprintf("\n");
   wcsprintf("   cel.*\n");
   celprt(&(wcs->cel));
 
-  /* Spectral transformation parameters. */
+  // Spectral transformation parameters.
   wcsprintf("\n");
   wcsprintf("   spc.*\n");
   spcprt(&(wcs->spc));
 
-  return 0;
+  return WCSERR_SUCCESS;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsperr(const struct wcsprm *wcs, const char *prefix)
 
 {
-  int j;
-
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
 
   if (wcs->err && wcserr_prt(wcs->err, prefix) == 0) {
@@ -2154,113 +2391,105 @@ int wcsperr(const struct wcsprm *wcs, co
     celperr(&(wcs->cel), prefix);
     wcserr_prt(wcs->spc.err, prefix);
     if (wcs->tab) {
-      for (j = 0; j < wcs->ntab; j++) {
-        wcserr_prt((wcs->tab + j)->err, prefix);
+      for (int itab = 0; itab < wcs->ntab; itab++) {
+        wcserr_prt((wcs->tab + itab)->err, prefix);
       }
     }
   }
 
-  return 0;
+  return WCSERR_SUCCESS;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsbchk(struct wcsprm *wcs, int bounds)
 
 {
-  int status;
-
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
 
   if (wcs->flag != WCSSET) {
+    int status;
     if ((status = wcsset(wcs))) return status;
   }
 
   wcs->cel.prj.bounds = bounds;
 
-  return 0;
+  return WCSERR_SUCCESS;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsset(struct wcsprm *wcs)
 
 {
   static const char *function = "wcsset";
 
-  char   dpq[16], scode[4], stype[5];
-  int    i, j, k, m, n, naxis, ndpmax, status;
-  double lambda, rho;
-  double *cd, *pc;
-  struct disprm *dis;
-  struct dpkey  *keyp;
-  struct linprm *wcslin = &(wcs->lin);
-  struct celprm *wcscel = &(wcs->cel);
-  struct prjprm *wcsprj = &(wcscel->prj);
-  struct spcprm *wcsspc = &(wcs->spc);
-  struct wcserr **err;
-
-
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
-  err = &(wcs->err);
+  struct wcserr **err = &(wcs->err);
 
-  /* Determine axis types from CTYPEia. */
+  // Determine axis types from CTYPEia.
+  int status;
   if ((status = wcs_types(wcs))) {
     return status;
   }
 
-  /* Convert to canonical units. */
+  // Convert to canonical units.
   if ((status = wcs_units(wcs))) {
     return status;
   }
 
-  naxis = wcs->naxis;
+  int naxis = wcs->naxis;
   if (32 < naxis) {
     return wcserr_set(WCSERR_SET(WCSERR_BAD_PARAM),
       "naxis must not exceed 32 (got %d)", naxis);
   }
 
 
-  /* Non-linear celestial axes present? */
+  // Non-linear celestial axes present?
   if (wcs->lng >= 0 && wcs->types[wcs->lng] == 2200) {
+    struct celprm *wcscel = &(wcs->cel);
     celini(wcscel);
 
-    /* CRVALia, LONPOLEa, and LATPOLEa keyvalues. */
+    // CRVALia, LONPOLEa, and LATPOLEa keyvalues.
     wcscel->ref[0] = wcs->crval[wcs->lng];
     wcscel->ref[1] = wcs->crval[wcs->lat];
     wcscel->ref[2] = wcs->lonpole;
     wcscel->ref[3] = wcs->latpole;
 
-    /* Do alias translation for TPU/TPV before dealing with PVi_ma. */
+    // Do alias translation for TPU/TPV before dealing with PVi_ma.
+    struct prjprm *wcsprj = &(wcscel->prj);
     strncpy(wcsprj->code, wcs->ctype[wcs->lng]+5, 3);
     wcsprj->code[3] = '\0';
     if (strncmp(wcsprj->code, "TPU", 3) == 0 ||
         strncmp(wcsprj->code, "TPV", 3) == 0) {
-      /* Translate the PV parameters. */
+      // Translate the PV parameters.
+      struct disprm *dis;
       if ((dis = calloc(1, sizeof(struct disprm))) == 0x0) {
         return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
       }
 
-      ndpmax = 6 + wcs->npv;
+      int ndpmax = 6 + wcs->npv;
 
-      /* Attach it to linprm.  Also inits it. */
+      // Attach it to linprm.  Also inits it.
+      char dpq[16];
+      struct linprm *wcslin = &(wcs->lin);
       dis->flag = -1;
       if (strncmp(wcsprj->code, "TPU", 3) == 0) {
-        /* Prior distortion. */
+        // Prior distortion.
         lindist(1, wcslin, dis, ndpmax);
         strcpy(dpq, "DP");
       } else {
-        /* Sequent distortion. */
+        // Sequent distortion.
         lindist(2, wcslin, dis, ndpmax);
         strcpy(dpq, "DQ");
       }
 
-      /* Yes, the distortion type is "TPV" even for TPU. */
+      // Yes, the distortion type is "TPV" even for TPU.
       strcpy(dis->dtype[wcs->lng], "TPV");
       strcpy(dis->dtype[wcs->lat], "TPV");
 
-      /* Keep the keywords in axis-order to aid debugging. */
-      keyp = dis->dp;
+      // Keep the keywords in axis-order to aid debugging.
+      struct dpkey *keyp = dis->dp;
       dis->ndp = 0;
 
       sprintf(dpq+2, "%d", wcs->lng+1);
@@ -2269,32 +2498,32 @@ int wcsset(struct wcsprm *wcs)
       dpfill(keyp++, dpq, "AXIS.2", 0, 0, 2, 0.0);
       dis->ndp += 3;
 
-      /* Copy distortion parameters for the longitude axis. */
-      for (k = 0; k < wcs->npv; k++) {
+      // Copy distortion parameters for the longitude axis.
+      for (int k = 0; k < wcs->npv; k++) {
         if (wcs->pv[k].i != wcs->lng+1) continue;
         sprintf(keyp->field, "%s.TPV.%d", dpq, wcs->pv[k].m);
         dpfill(keyp++, 0x0, 0x0, 0, 1, 0, wcs->pv[k].value);
         dis->ndp++;
       }
 
-      /* Now the latitude axis. */
+      // Now the latitude axis.
       sprintf(dpq+2, "%d", wcs->lat+1);
       dpfill(keyp++, dpq, "NAXES",  0, 0, 2, 0.0);
       dpfill(keyp++, dpq, "AXIS.1", 0, 0, 2, 0.0);
       dpfill(keyp++, dpq, "AXIS.2", 0, 0, 1, 0.0);
       dis->ndp += 3;
 
-      for (k = 0; k < wcs->npv; k++) {
+      for (int k = 0; k < wcs->npv; k++) {
         if (wcs->pv[k].i != wcs->lat+1) continue;
         sprintf(keyp->field, "%s.TPV.%d", dpq, wcs->pv[k].m);
         dpfill(keyp++, 0x0, 0x0, 0, 1, 0, wcs->pv[k].value);
         dis->ndp++;
       }
 
-      /* Erase PVi_ma associated with the celestial axes. */
-      n = 0;
-      for (k = 0; k < wcs->npv; k++) {
-        i = wcs->pv[k].i - 1;
+      // Erase PVi_ma associated with the celestial axes.
+      int n = 0;
+      for (int k = 0; k < wcs->npv; k++) {
+        int i = wcs->pv[k].i - 1;
         if (i == wcs->lng || i == wcs->lat) continue;
 
         wcs->pv[n].i = wcs->pv[k].i;
@@ -2307,42 +2536,42 @@ int wcsset(struct wcsprm *wcs)
       wcs->npv = n;
       strcpy(wcsprj->code, "TAN");
 
-      /* As the PVi_ma have now been erased, ctype must be reset to prevent
-         this translation from re-occurring if wcsset() is called again. */
+      // As the PVi_ma have now been erased, ctype must be reset to prevent
+      // this translation from re-occurring if wcsset() is called again.
       strcpy(wcs->ctype[wcs->lng]+5, "TAN");
       strcpy(wcs->ctype[wcs->lat]+5, "TAN");
 
     } else if (strncmp(wcsprj->code, "TNX", 3) == 0) {
-      /* The WAT distortion should already have been encoded in disseq. */
+      // The WAT distortion should already have been encoded in disseq.
       strcpy(wcsprj->code, "TAN");
       strcpy(wcs->ctype[wcs->lng]+5, "TAN");
       strcpy(wcs->ctype[wcs->lat]+5, "TAN");
 
     } else if (strncmp(wcsprj->code, "ZPX", 3) == 0) {
-      /* The WAT distortion should already have been encoded in disseq. */
+      // The WAT distortion should already have been encoded in disseq.
       strcpy(wcsprj->code, "ZPN");
       strcpy(wcs->ctype[wcs->lng]+5, "ZPN");
       strcpy(wcs->ctype[wcs->lat]+5, "ZPN");
     }
 
-    /* PVi_ma keyvalues. */
-    for (k = 0; k < wcs->npv; k++) {
+    // PVi_ma keyvalues.
+    for (int k = 0; k < wcs->npv; k++) {
       if (wcs->pv[k].i == 0) {
-        /* From a PROJPn keyword. */
+        // From a PROJPn keyword.
         wcs->pv[k].i = wcs->lat + 1;
       }
 
-      i = wcs->pv[k].i - 1;
-      m = wcs->pv[k].m;
+      int i = wcs->pv[k].i - 1;
+      int m = wcs->pv[k].m;
 
       if (i == wcs->lat) {
-        /* PVi_ma associated with latitude axis. */
+        // PVi_ma associated with latitude axis.
         if (m < 30) {
           wcsprj->pv[m] = wcs->pv[k].value;
         }
 
       } else if (i == wcs->lng) {
-        /* PVi_ma associated with longitude axis. */
+        // PVi_ma associated with longitude axis.
         switch (m) {
         case 0:
           wcscel->offset = (wcs->pv[k].value != 0.0);
@@ -2354,11 +2583,11 @@ int wcsset(struct wcsprm *wcs)
           wcscel->theta0 = wcs->pv[k].value;
           break;
         case 3:
-          /* If present, overrides LONPOLEa. */
+          // If present, overrides LONPOLEa.
           wcscel->ref[2] = wcs->pv[k].value;
           break;
         case 4:
-          /* If present, overrides LATPOLEa. */
+          // If present, overrides LATPOLEa.
           wcscel->ref[3] = wcs->pv[k].value;
           break;
         default:
@@ -2370,7 +2599,7 @@ int wcsset(struct wcsprm *wcs)
       }
     }
 
-    /* Do simple alias translations. */
+    // Do simple alias translations.
     if (strncmp(wcs->ctype[wcs->lng]+5, "GLS", 3) == 0) {
       wcscel->offset = 1;
       wcscel->phi0   = 0.0;
@@ -2378,7 +2607,7 @@ int wcsset(struct wcsprm *wcs)
       strcpy(wcsprj->code, "SFL");
 
     } else if (strncmp(wcs->ctype[wcs->lng]+5, "NCP", 3) == 0) {
-      /* Convert NCP to SIN. */
+      // Convert NCP to SIN.
       if (wcscel->ref[1] == 0.0) {
         return wcserr_set(WCSERR_SET(WCSERR_BAD_PARAM),
           "Invalid projection: NCP blows up on the equator");
@@ -2389,19 +2618,19 @@ int wcsset(struct wcsprm *wcs)
       wcsprj->pv[2] = cosd(wcscel->ref[1])/sind(wcscel->ref[1]);
     }
 
-    /* Initialize the celestial transformation routines. */
+    // Initialize the celestial transformation routines.
     wcsprj->r0 = 0.0;
     if ((status = celset(wcscel))) {
       return wcserr_set(WCS_ERRMSG(wcs_celerr[status]));
     }
 
-    /* Update LONPOLE, LATPOLE, and PVi_ma keyvalues. */
+    // Update LONPOLE, LATPOLE, and PVi_ma keyvalues.
     wcs->lonpole = wcscel->ref[2];
     wcs->latpole = wcscel->ref[3];
 
-    for (k = 0; k < wcs->npv; k++) {
-      i = wcs->pv[k].i - 1;
-      m = wcs->pv[k].m;
+    for (int k = 0; k < wcs->npv; k++) {
+      int i = wcs->pv[k].i - 1;
+      int m = wcs->pv[k].m;
 
       if (i == wcs->lng) {
         switch (m) {
@@ -2423,8 +2652,10 @@ int wcsset(struct wcsprm *wcs)
   }
 
 
-  /* Non-linear spectral axis present? */
+  // Non-linear spectral axis present?
   if (wcs->spec >= 0 && wcs->types[wcs->spec] == 3300) {
+    char scode[4], stype[5];
+    struct spcprm *wcsspc = &(wcs->spc);
     spcini(wcsspc);
     if ((status = spctype(wcs->ctype[wcs->spec], stype, scode, 0x0, 0x0, 0x0,
                           0x0, 0x0, err))) {
@@ -2433,64 +2664,65 @@ int wcsset(struct wcsprm *wcs)
     strcpy(wcsspc->type, stype);
     strcpy(wcsspc->code, scode);
 
-    /* CRVALia, RESTFRQa, and RESTWAVa keyvalues. */
+    // CRVALia, RESTFRQa, and RESTWAVa keyvalues.
     wcsspc->crval = wcs->crval[wcs->spec];
     wcsspc->restfrq = wcs->restfrq;
     wcsspc->restwav = wcs->restwav;
 
-    /* PVi_ma keyvalues. */
-    for (k = 0; k < wcs->npv; k++) {
-      i = wcs->pv[k].i - 1;
-      m = wcs->pv[k].m;
+    // PVi_ma keyvalues.
+    for (int k = 0; k < wcs->npv; k++) {
+      int i = wcs->pv[k].i - 1;
+      int m = wcs->pv[k].m;
 
       if (i == wcs->spec) {
-        /* PVi_ma associated with grism axis. */
+        // PVi_ma associated with grism axis.
         if (m < 7) {
           wcsspc->pv[m] = wcs->pv[k].value;
         }
       }
     }
 
-    /* Initialize the spectral transformation routines. */
+    // Initialize the spectral transformation routines.
     if ((status = spcset(wcsspc))) {
       return wcserr_set(WCS_ERRMSG(wcs_spcerr[status]));
     }
   }
 
 
-  /* Tabular axes present? */
-  for (j = 0; j < wcs->ntab; j++) {
-    if ((status = tabset(wcs->tab + j))) {
+  // Tabular axes present?
+  for (int itab = 0; itab < wcs->ntab; itab++) {
+    if ((status = tabset(wcs->tab + itab))) {
       return wcserr_set(WCS_ERRMSG(wcs_taberr[status]));
     }
   }
 
 
-  /* Initialize the linear transformation. */
-  wcs->altlin &= 7;
+  // Initialize the linear transformation.
+  wcs->altlin &= 15;
   if (wcs->altlin > 1 && !(wcs->altlin & 1)) {
-    pc = wcs->pc;
+    double *pc = wcs->pc;
 
-    if (wcs->altlin & 2) {
-      /* Copy CDi_ja to PCi_ja and reset CDELTia. */
-      cd = wcs->cd;
-      for (i = 0; i < naxis; i++) {
-        for (j = 0; j < naxis; j++) {
+    if ((wcs->altlin & 2) && !(wcs->altlin & 8)) {
+      // Copy CDi_ja to PCi_ja and reset CDELTia.
+      double *cd = wcs->cd;
+      for (int i = 0; i < naxis; i++) {
+        for (int j = 0; j < naxis; j++) {
           *(pc++) = *(cd++);
         }
         wcs->cdelt[i] = 1.0;
       }
 
     } else if (wcs->altlin & 4) {
-      /* Construct PCi_ja from CROTAia. */
+      // Construct PCi_ja from CROTAia.
+      int i, j;
       if ((i = wcs->lng) >= 0 && (j = wcs->lat) >= 0) {
-        rho = wcs->crota[j];
+        double rho = wcs->crota[j];
 
         if (wcs->cdelt[i] == 0.0) {
           return wcserr_set(WCSERR_SET(WCSERR_SINGULAR_MTX),
             "Singular transformation matrix, CDELT%d is zero", i+1);
         }
-        lambda = wcs->cdelt[j]/wcs->cdelt[i];
+        double lambda = wcs->cdelt[j]/wcs->cdelt[i];
 
         *(pc + i*naxis + i) = *(pc + j*naxis + j) = cosd(rho);
         *(pc + i*naxis + j) = *(pc + j*naxis + i) = sind(rho);
@@ -2508,7 +2740,7 @@ int wcsset(struct wcsprm *wcs)
   }
 
 
-  /* Set defaults for radesys and equinox for equatorial or ecliptic. */
+  // Set defaults for radesys and equinox for equatorial or ecliptic.
   if (strcmp(wcs->lngtyp, "RA")   == 0 ||
       strcmp(wcs->lngtyp, "ELON") == 0 ||
       strcmp(wcs->lngtyp, "HLON") == 0) {
@@ -2523,7 +2755,7 @@ int wcsset(struct wcsprm *wcs)
 
     } else if (strcmp(wcs->radesys, "ICRS")  == 0 ||
                strcmp(wcs->radesys, "GAPPT") == 0) {
-      /* Equinox is not applicable for these coordinate systems. */
+      // Equinox is not applicable for these coordinate systems.
       wcs->equinox = UNDEFINED;
 
     } else if (undefined(wcs->equinox)) {
@@ -2536,17 +2768,17 @@ int wcsset(struct wcsprm *wcs)
     }
 
   } else {
-    /* No celestial axes, ensure that radesys and equinox are unset. */
+    // No celestial axes, ensure that radesys and equinox are unset.
     memset(wcs->radesys, 0, 72);
     wcs->equinox = UNDEFINED;
   }
 
 
-  /* Strip off trailing blanks and null-fill auxiliary string members. */
+  // Strip off trailing blanks and null-fill auxiliary string members.
   if (wcs->alt[0] == '\0') wcs->alt[0] = ' ';
   memset(wcs->alt+1, '\0', 3);
 
-  for (i = 0; i < naxis; i++) {
+  for (int i = 0; i < naxis; i++) {
     wcsutil_null_fill(72, wcs->cname[i]);
   }
   wcsutil_null_fill(72, wcs->wcsname);
@@ -2566,7 +2798,7 @@ int wcsset(struct wcsprm *wcs)
   wcsutil_null_fill(72, wcs->ssysobs);
   wcsutil_null_fill(72, wcs->ssyssrc);
 
-  /* MJDREF defaults to zero if no reference date keywords were defined. */
+  // MJDREF defaults to zero if no reference date keywords were defined.
   if (wcs->dateref[0] == '\0') {
     if (undefined(wcs->mjdref[0])) {
       wcs->mjdref[0] = 0.0;
@@ -2578,10 +2810,10 @@ int wcsset(struct wcsprm *wcs)
 
   wcs->flag = WCSSET;
 
-  return 0;
+  return WCSERR_SUCCESS;
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int wcs_types(struct wcsprm *wcs)
 
@@ -2594,12 +2826,11 @@ int wcs_types(struct wcsprm *wcs)
   const char *alt = "";
   char ctypei[16], pcode[4], requir[16], scode[4], specsys[9];
   int i, j, m, naxis, *ndx = 0x0, type;
-  struct wcserr **err;
 
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
-  err = &(wcs->err);
+  struct wcserr **err = &(wcs->err);
 
-  /* Parse the CTYPEia keyvalues. */
+  // Parse the CTYPEia keyvalues.
   pcode[0]  = '\0';
   requir[0] = '\0';
   wcs->lng  = -1;
@@ -2617,63 +2848,63 @@ int wcs_types(struct wcsprm *wcs)
   }
 
   for (i = 0; i < naxis; i++) {
-    /* Null fill. */
+    // Null fill.
     wcsutil_null_fill(72, wcs->ctype[i]);
 
     strncpy(ctypei, wcs->ctype[i], 15);
     ctypei[15] = '\0';
 
-    /* Check for early Paper IV syntax (e.g. '-SIP' used by Spitzer). */
+    // Check for early Paper IV syntax (e.g. '-SIP' used by Spitzer).
     if (strlen(ctypei) == 12 && ctypei[8] == '-') {
-      /* Excise the "4-3-3" or "8-3"-form distortion code. */
+      // Excise the "4-3-3" or "8-3"-form distortion code.
       ctypei[8] = '\0';
 
-      /* Remove trailing dashes from "8-3"-form codes. */
+      // Remove trailing dashes from "8-3"-form codes.
       for (j = 7; j > 0; j--) {
         if (ctypei[j] != '-') break;
         ctypei[j] = '\0';
       }
     }
 
-    /* Logarithmic or tabular axis? */
+    // Logarithmic or tabular axis?
     wcs->types[i] = 0;
     if (strcmp(ctypei+4, "-LOG") == 0) {
-      /* Logarithmic axis. */
+      // Logarithmic axis.
       wcs->types[i] = 400;
 
     } else if (strcmp(ctypei+4, "-TAB") == 0) {
-      /* Tabular axis. */
+      // Tabular axis.
       wcs->types[i] = 500;
     }
 
     if (wcs->types[i]) {
-      /* Could have -LOG or -TAB with celestial or spectral types. */
+      // Could have -LOG or -TAB with celestial or spectral types.
       ctypei[4] = '\0';
 
-      /* Take care of things like 'FREQ-LOG' or 'RA---TAB'. */
+      // Take care of things like 'FREQ-LOG' or 'RA---TAB'.
       for (j = 3; j >= 0; j--) {
         if (ctypei[j] != '-') break;
         ctypei[j] = '\0';
       }
     }
 
-    /* Translate AIPS spectral types for spctyp(). */
+    // Translate AIPS spectral types for spctyp().
     if (spcaips(ctypei, wcs->velref, ctypei, specsys) == 0) {
       strcpy(wcs->ctype[i], ctypei);
       if (wcs->specsys[0] == '\0') strcpy(wcs->specsys, specsys);
     }
 
-    /* Process linear axes. */
+    // Process linear axes.
     if (!(strlen(ctypei) == 8 && ctypei[4] == '-')) {
-      /* Identify Stokes, celestial and spectral types. */
+      // Identify Stokes, celestial and spectral types.
       if (strcmp(ctypei, "STOKES") == 0) {
-        /* STOKES axis. */
+        // STOKES axis.
         wcs->types[i] = 1100;
 
       } else if (strcmp(ctypei, "RA")  == 0 ||
         strcmp(ctypei+1, "LON") == 0 ||
         strcmp(ctypei+2, "LN")  == 0) {
-        /* Longitude axis. */
+        // Longitude axis.
         wcs->types[i] += 2000;
         if (wcs->lng < 0) {
           wcs->lng = i;
@@ -2683,7 +2914,7 @@ int wcs_types(struct wcsprm *wcs)
       } else if (strcmp(ctypei,   "DEC") == 0 ||
                  strcmp(ctypei+1, "LAT") == 0 ||
                  strcmp(ctypei+2, "LT")  == 0) {
-        /* Latitude axis. */
+        // Latitude axis.
         wcs->types[i] += 2001;
         if (wcs->lat < 0) {
           wcs->lat = i;
@@ -2691,19 +2922,19 @@ int wcs_types(struct wcsprm *wcs)
         }
 
       } else if (strcmp(ctypei, "CUBEFACE") == 0) {
-        /* CUBEFACE axis. */
+        // CUBEFACE axis.
         if (wcs->cubeface == -1) {
           wcs->types[i] = 2102;
           wcs->cubeface = i;
         } else {
-          /* Multiple CUBEFACE axes! */
+          // Multiple CUBEFACE axes!
           return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
             "Multiple CUBEFACE axes (in CTYPE%d%.1s and CTYPE%d%.1s)",
             wcs->cubeface+1, alt, i+1, alt);
         }
 
       } else if (spctyp(ctypei, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0) == 0) {
-        /* Spectral axis. */
+        // Spectral axis.
         if (wcs->spec < 0) wcs->spec = i;
         wcs->types[i] += 3000;
       }
@@ -2712,12 +2943,12 @@ int wcs_types(struct wcsprm *wcs)
     }
 
 
-    /* CTYPEia is in "4-3" form; is it a recognized spectral type? */
+    // CTYPEia is in "4-3" form; is it a recognized spectral type?
     if (spctyp(ctypei, 0x0, scode, 0x0, 0x0, 0x0, 0x0, 0x0) == 0) {
-      /* Non-linear spectral axis found. */
+      // Non-linear spectral axis found.
       wcs->types[i] = 3300;
 
-      /* Check uniqueness. */
+      // Check uniqueness.
       if (wcs->spec >= 0) {
         return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
           "Multiple spectral axes (in CTYPE%d%.1s and CTYPE%d%.1s)",
@@ -2730,19 +2961,19 @@ int wcs_types(struct wcsprm *wcs)
     }
 
 
-    /* Is it a recognized celestial projection? */
+    // Is it a recognized celestial projection?
     for (j = 0; j < prj_ncode; j++) {
       if (strncmp(ctypei+5, prj_codes[j], 3) == 0) break;
     }
 
     if (j == prj_ncode) {
-      /* Not a standard projection code, maybe it's an alias. */
+      // Not a standard projection code, maybe it's an alias.
       for (j = 0; j < nalias; j++) {
         if (strncmp(ctypei+5, aliases[j], 3) == 0) break;
       }
 
       if (j == nalias) {
-        /* Not a recognized algorithm code of any type. */
+        // Not a recognized algorithm code of any type.
         wcs->types[i] = -1;
         return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
           "Unrecognized projection code (%s in CTYPE%d%.1s)",
@@ -2750,10 +2981,10 @@ int wcs_types(struct wcsprm *wcs)
       }
     }
 
-    /* Parse the celestial axis type. */
+    // Parse the celestial axis type.
     wcs->types[i] = 2200;
     if (*pcode == '\0') {
-      /* The first of the two celestial axes. */
+      // The first of the two celestial axes.
       sprintf(pcode, "%.3s", ctypei+5);
 
       if (strncmp(ctypei, "RA--", 4) == 0) {
@@ -2793,7 +3024,7 @@ int wcs_types(struct wcsprm *wcs)
         ndx = &wcs->lng;
         sprintf(requir, "%s-%s", wcs->lngtyp, pcode);
       } else {
-        /* Unrecognized celestial type. */
+        // Unrecognized celestial type.
         wcs->types[i] = -1;
 
         wcs->lng = -1;
@@ -2806,11 +3037,11 @@ int wcs_types(struct wcsprm *wcs)
       if (wcs->lat >= 0) wcs->types[i]++;
 
     } else {
-      /* Looking for the complementary celestial axis. */
+      // Looking for the complementary celestial axis.
       if (wcs->lat < 0) wcs->types[i]++;
 
       if (strncmp(ctypei, requir, 8) != 0) {
-        /* Inconsistent projection types. */
+        // Inconsistent projection types.
         wcs->lng = -1;
         wcs->lat = -1;
         return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE), "Inconsistent "
@@ -2823,19 +3054,19 @@ int wcs_types(struct wcsprm *wcs)
     }
   }
 
-  /* Do we have a complementary pair of celestial axes? */
+  // Do we have a complementary pair of celestial axes?
   if (strcmp(requir, "")) {
-    /* Unmatched celestial axis. */
+    // Unmatched celestial axis.
     wcs->lng = -1;
     wcs->lat = -1;
     return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
       "Unmatched celestial axes");
   }
 
-  /* Table group numbers. */
+  // Table group numbers.
   for (j = 0; j < wcs->ntab; j++) {
     for (m = 0; m < wcs->tab[j].M; m++) {
-      /* Get image axis number. */
+      // Get image axis number.
       i = wcs->tab[j].map[m];
 
       type = (wcs->types[i] / 100) % 10;
@@ -2847,10 +3078,10 @@ int wcs_types(struct wcsprm *wcs)
     }
   }
 
-  return 0;
+  return WCSERR_SUCCESS;
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int wcs_units(struct wcsprm *wcs)
 
@@ -2867,15 +3098,18 @@ int wcs_units(struct wcsprm *wcs)
 
   naxis = wcs->naxis;
   for (i = 0; i < naxis; i++) {
-    /* Use types set by wcs_types(). */
+    // Squeeze out trailing blanks.
+    wcsutil_null_fill(72, wcs->cunit[i]);
+
+    // Use types set by wcs_types().
     switch (wcs->types[i]/1000) {
     case 2:
-      /* Celestial axis. */
+      // Celestial axis.
       strcpy(units, "deg");
       break;
 
     case 3:
-      /* Spectral axis. */
+      // Spectral axis.
       strncpy(ctype, wcs->ctype[i], 8);
       ctype[8] = '\0';
       spctyp(ctype, 0x0, 0x0, 0x0, units, 0x0, 0x0, 0x0);
@@ -2885,18 +3119,20 @@ int wcs_units(struct wcsprm *wcs)
       continue;
     }
 
-    /* Tabular axis, CDELTia and CRVALia relate to indices. */
+    // Tabular axis, CDELTia and CRVALia relate to indices.
     if ((wcs->types[i]/100)%10 == 5) {
       continue;
     }
 
-    wcsutil_null_fill(72, wcs->cunit[i]);
     if (wcs->cunit[i][0]) {
       if (wcsunitse(wcs->cunit[i], units, &scale, &offset, &power,
                     &uniterr)) {
-        wcserr_set(WCSERR_SET(WCSERR_BAD_COORD_TRANS),
-          "In CUNIT%d%.1s: %s", i+1, (*wcs->alt)?wcs->alt:"", uniterr->msg);
-        free(uniterr);
+        if (uniterr) {
+          // uniterr will not be set if wcserr is not enabled.
+          wcserr_set(WCSERR_SET(WCSERR_BAD_COORD_TRANS),
+            "In CUNIT%d%.1s: %s", i+1, (*wcs->alt)?wcs->alt:"", uniterr->msg);
+          free(uniterr);
+        }
         return WCSERR_BAD_COORD_TRANS;
       }
 
@@ -2916,10 +3152,10 @@ int wcs_units(struct wcsprm *wcs)
     }
   }
 
-  return 0;
+  return WCSERR_SUCCESS;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsp2s(
   struct wcsprm *wcs,
@@ -2943,7 +3179,7 @@ int wcsp2s(
   struct prjprm *wcsprj = &(wcscel->prj);
   struct wcserr **err;
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
@@ -2951,19 +3187,19 @@ int wcsp2s(
     if ((status = wcsset(wcs))) return status;
   }
 
-  /* Sanity check. */
+  // Sanity check.
   if (ncoord < 1 || (ncoord > 1 && nelem < wcs->naxis)) {
     return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
       "ncoord and/or nelem inconsistent with the wcsprm");
   }
 
 
-  /* Apply pixel-to-world linear transformation. */
+  // Apply pixel-to-world linear transformation.
   if ((status = linp2x(&(wcs->lin), ncoord, nelem, pixcrd, imgcrd))) {
     return wcserr_set(WCS_ERRMSG(wcs_linerr[status]));
   }
 
-  /* Initialize status vectors. */
+  // Initialize status vectors.
   if ((istatp = calloc(ncoord, sizeof(int))) == 0x0) {
     return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
   }
@@ -2972,13 +3208,13 @@ int wcsp2s(
   wcsutil_setAli(ncoord, 1, stat);
 
 
-  /* Convert intermediate world coordinates to world coordinates. */
+  // Convert intermediate world coordinates to world coordinates.
   for (i = 0; i < wcs->naxis; i++) {
-    /* Extract the second digit of the axis type code. */
+    // Extract the second digit of the axis type code.
     type = (wcs->types[i] / 100) % 10;
 
     if (type <= 1) {
-      /* Linear or quantized coordinate axis. */
+      // Linear or quantized coordinate axis.
       img = imgcrd + i;
       wrl = world  + i;
       crvali = wcs->crval[i];
@@ -2989,16 +3225,16 @@ int wcsp2s(
       }
 
     } else if (wcs->types[i] == 2200) {
-      /* Convert celestial coordinates; do we have a CUBEFACE axis? */
+      // Convert celestial coordinates; do we have a CUBEFACE axis?
       if (wcs->cubeface != -1) {
-        /* Separation between faces. */
+        // Separation between faces.
         if (wcsprj->r0 == 0.0) {
           offset = 90.0;
         } else {
           offset = wcsprj->r0*PI/2.0;
         }
 
-        /* Lay out faces in a plane. */
+        // Lay out faces in a plane.
         img = imgcrd;
         statp = stat;
         bits = (1 << i) | (1 << wcs->lat);
@@ -3039,7 +3275,7 @@ int wcsp2s(
         }
       }
 
-      /* Check for constant x and/or y. */
+      // Check for constant x and/or y.
       nx = ncoord;
       ny = 0;
 
@@ -3051,7 +3287,7 @@ int wcsp2s(
         ny = 1;
       }
 
-      /* Transform projection plane coordinates to celestial coordinates. */
+      // Transform projection plane coordinates to celestial coordinates.
       if ((istat = celx2s(wcscel, nx, ny, nelem, nelem, imgcrd+i,
                           imgcrd+wcs->lat, phi, theta, world+i,
                           world+wcs->lat, istatp))) {
@@ -3063,7 +3299,7 @@ int wcsp2s(
         }
       }
 
-      /* If x and y were both constant, replicate values. */
+      // If x and y were both constant, replicate values.
       if (iso_x && iso_y) {
         wcsutil_setAll(ncoord, nelem, world+i);
         wcsutil_setAll(ncoord, nelem, world+wcs->lat);
@@ -3078,7 +3314,7 @@ int wcsp2s(
       }
 
     } else if (type == 3 || type == 4) {
-      /* Check for constant x. */
+      // Check for constant x.
       nx = ncoord;
       if ((iso_x = wcsutil_allEq(ncoord, nelem, imgcrd+i))) {
         nx = 1;
@@ -3086,7 +3322,7 @@ int wcsp2s(
 
       istat = 0;
       if (wcs->types[i] == 3300) {
-        /* Spectral coordinates. */
+        // Spectral coordinates.
         istat = spcx2s(&(wcs->spc), nx, nelem, nelem, imgcrd+i, world+i,
                        istatp);
         if (istat) {
@@ -3096,7 +3332,7 @@ int wcsp2s(
           }
         }
       } else if (type == 4) {
-        /* Logarithmic coordinates. */
+        // Logarithmic coordinates.
         istat = logx2s(wcs->crval[i], nx, nelem, nelem, imgcrd+i, world+i,
                        istatp);
         if (istat) {
@@ -3107,7 +3343,7 @@ int wcsp2s(
         }
       }
 
-      /* If x was constant, replicate values. */
+      // If x was constant, replicate values.
       if (iso_x) {
         wcsutil_setAll(ncoord, nelem, world+i);
         wcsutil_setAli(ncoord, 1, istatp);
@@ -3120,7 +3356,7 @@ int wcsp2s(
   }
 
 
-  /* Do tabular coordinates. */
+  // Do tabular coordinates.
   for (itab = 0; itab < wcs->ntab; itab++) {
     istat = tabx2s(wcs->tab + itab, ncoord, nelem, imgcrd, world, istatp);
 
@@ -3141,7 +3377,7 @@ int wcsp2s(
   }
 
 
-  /* Zero the unused world coordinate elements. */
+  // Zero the unused world coordinate elements.
   for (i = wcs->naxis; i < nelem; i++) {
     world[i] = 0.0;
     wcsutil_setAll(ncoord, nelem, world+i);
@@ -3152,7 +3388,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcss2p(
   struct wcsprm* wcs,
@@ -3178,7 +3414,7 @@ int wcss2p(
   struct wcserr **err;
 
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
@@ -3186,13 +3422,13 @@ int wcss2p(
     if ((status = wcsset(wcs))) return status;
   }
 
-  /* Sanity check. */
+  // Sanity check.
   if (ncoord < 1 || (ncoord > 1 && nelem < wcs->naxis)) {
     return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
       "ncoord and/or nelem inconsistent with the wcsprm");
   }
 
-  /* Initialize status vectors. */
+  // Initialize status vectors.
   if ((istatp = calloc(ncoord, sizeof(int))) == 0x0) {
     return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
   }
@@ -3202,13 +3438,13 @@ int wcss2p(
   wcsutil_setAli(ncoord, 1, stat);
 
 
-  /* Convert world coordinates to intermediate world coordinates. */
+  // Convert world coordinates to intermediate world coordinates.
   for (i = 0; i < wcs->naxis; i++) {
-    /* Extract the second digit of the axis type code. */
+    // Extract the second digit of the axis type code.
     type = (wcs->types[i] / 100) % 10;
 
     if (type <= 1) {
-      /* Linear or quantized coordinate axis. */
+      // Linear or quantized coordinate axis.
       wrl = world  + i;
       img = imgcrd + i;
       crvali = wcs->crval[i];
@@ -3219,7 +3455,7 @@ int wcss2p(
       }
 
     } else if (wcs->types[i] == 2200) {
-      /* Celestial coordinates; check for constant lng and/or lat. */
+      // Celestial coordinates; check for constant lng and/or lat.
       nlng = ncoord;
       nlat = 0;
 
@@ -3231,7 +3467,7 @@ int wcss2p(
         nlat = 1;
       }
 
-      /* Transform celestial coordinates to projection plane coordinates. */
+      // Transform celestial coordinates to projection plane coordinates.
       if ((istat = cels2x(wcscel, nlng, nlat, nelem, nelem, world+i,
                           world+wcs->lat, phi, theta, imgcrd+i,
                           imgcrd+wcs->lat, istatp))) {
@@ -3243,7 +3479,7 @@ int wcss2p(
         }
       }
 
-      /* If lng and lat were both constant, replicate values. */
+      // If lng and lat were both constant, replicate values.
       if (isolng && isolat) {
         wcsutil_setAll(ncoord, nelem, imgcrd+i);
         wcsutil_setAll(ncoord, nelem, imgcrd+wcs->lat);
@@ -3257,16 +3493,16 @@ int wcss2p(
         wcsutil_setBit(ncoord, istatp, bits, stat);
       }
 
-      /* Do we have a CUBEFACE axis? */
+      // Do we have a CUBEFACE axis?
       if (wcs->cubeface != -1) {
-        /* Separation between faces. */
+        // Separation between faces.
         if (wcsprj->r0 == 0.0) {
           offset = 90.0;
         } else {
           offset = wcsprj->r0*PI/2.0;
         }
 
-        /* Stack faces in a cube. */
+        // Stack faces in a cube.
         img = imgcrd;
         for (k = 0; k < ncoord; k++) {
           if (*(img+wcs->lat) < -0.5*offset) {
@@ -3293,7 +3529,7 @@ int wcss2p(
       }
 
     } else if (type == 3 || type == 4) {
-      /* Check for constancy. */
+      // Check for constancy.
       nwrld = ncoord;
       if ((isospec = wcsutil_allEq(ncoord, nelem, world+i))) {
         nwrld = 1;
@@ -3301,7 +3537,7 @@ int wcss2p(
 
       istat = 0;
       if (wcs->types[i] == 3300) {
-        /* Spectral coordinates. */
+        // Spectral coordinates.
         istat = spcs2x(&(wcs->spc), nwrld, nelem, nelem, world+i,
                        imgcrd+i, istatp);
         if (istat) {
@@ -3311,7 +3547,7 @@ int wcss2p(
           }
         }
       } else if (type == 4) {
-        /* Logarithmic coordinates. */
+        // Logarithmic coordinates.
         istat = logs2x(wcs->crval[i], nwrld, nelem, nelem, world+i,
                        imgcrd+i, istatp);
         if (istat) {
@@ -3322,7 +3558,7 @@ int wcss2p(
         }
       }
 
-      /* If constant, replicate values. */
+      // If constant, replicate values.
       if (isospec) {
         wcsutil_setAll(ncoord, nelem, imgcrd+i);
         wcsutil_setAli(ncoord, 1, istatp);
@@ -3335,7 +3571,7 @@ int wcss2p(
   }
 
 
-  /* Do tabular coordinates. */
+  // Do tabular coordinates.
   for (itab = 0; itab < wcs->ntab; itab++) {
     istat = tabs2x(wcs->tab + itab, ncoord, nelem, world, imgcrd, istatp);
 
@@ -3356,14 +3592,14 @@ int wcss2p(
   }
 
 
-  /* Zero the unused intermediate world coordinate elements. */
+  // Zero the unused intermediate world coordinate elements.
   for (i = wcs->naxis; i < nelem; i++) {
     imgcrd[i] = 0.0;
     wcsutil_setAll(ncoord, nelem, imgcrd+i);
   }
 
 
-  /* Apply world-to-pixel linear transformation. */
+  // Apply world-to-pixel linear transformation.
   if ((istat = linx2p(&(wcs->lin), ncoord, nelem, imgcrd, pixcrd))) {
     status = wcserr_set(WCS_ERRMSG(wcs_linerr[istat]));
     goto cleanup;
@@ -3374,7 +3610,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsmix(
   struct wcsprm *wcs,
@@ -3408,7 +3644,7 @@ int wcsmix(
   struct wcsprm wcs0;
   struct wcserr **err;
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
@@ -3416,28 +3652,33 @@ int wcsmix(
     if ((status = wcsset(wcs))) return status;
   }
 
+  if (wcs->lng < 0 || wcs->lat < 0) {
+    return wcserr_set(WCSERR_SET(WCSERR_BAD_SUBIMAGE),
+      "Image does not have celestial axes");
+  }
+
   worldlng = world + wcs->lng;
   worldlat = world + wcs->lat;
 
 
-  /* Check vspan. */
+  // Check vspan.
   if (vspan[0] <= vspan[1]) {
     span[0] = vspan[0];
     span[1] = vspan[1];
   } else {
-    /* Swap them. */
+    // Swap them.
     span[0] = vspan[1];
     span[1] = vspan[0];
   }
 
-  /* Check vstep. */
+  // Check vstep.
   step = fabs(vstep);
   if (step == 0.0) {
     step = (span[1] - span[0])/10.0;
     if (step > 1.0 || step == 0.0) step = 1.0;
   }
 
-  /* Check viter. */
+  // Check viter.
   nstep = viter;
   if (nstep < 5) {
     nstep = 5;
@@ -3445,18 +3686,18 @@ int wcsmix(
     nstep = 10;
   }
 
-  /* Given pixel element. */
+  // Given pixel element.
   pixmix = pixcrd[mixpix];
 
-  /* Iterate on the step size. */
+  // Iterate on the step size.
   for (istep = 0; istep <= nstep; istep++) {
     if (istep) step /= 2.0;
 
-    /* Iterate on the sky coordinate between the specified range. */
+    // Iterate on the sky coordinate between the specified range.
     if (mixcel == 1) {
-      /* Celestial longitude is given. */
+      // Celestial longitude is given.
 
-      /* Check whether the solution interval is a crossing interval. */
+      // Check whether the solution interval is a crossing interval.
       lat0 = span[0];
       *worldlat = lat0;
       if ((status = wcss2p(wcs, 1, 0, world, phi, theta, imgcrd, pixcrd,
@@ -3469,7 +3710,7 @@ int wcsmix(
       d0 = pixcrd[mixpix] - pixmix;
 
       dabs = fabs(d0);
-      if (dabs < tol) return 0;
+      if (dabs < tol) return WCSERR_SUCCESS;
 
       lat1 = span[1];
       *worldlat = lat1;
@@ -3483,12 +3724,12 @@ int wcsmix(
       d1 = pixcrd[mixpix] - pixmix;
 
       dabs = fabs(d1);
-      if (dabs < tol) return 0;
+      if (dabs < tol) return WCSERR_SUCCESS;
 
       lmin = lat1;
       dmin = dabs;
 
-      /* Check for a crossing point. */
+      // Check for a crossing point.
       if (signbit(d0) != signbit(d1)) {
         crossed = 1;
         dx = d1;
@@ -3498,7 +3739,7 @@ int wcsmix(
       }
 
       for (retry = 0; retry < 4; retry++) {
-        /* Refine the solution interval. */
+        // Refine the solution interval.
         while (lat0 > span[0]) {
           lat0 -= step;
           if (lat0 < span[0]) lat0 = span[0];
@@ -3512,32 +3753,32 @@ int wcsmix(
           }
           d0 = pixcrd[mixpix] - pixmix;
 
-          /* Check for a solution. */
+          // Check for a solution.
           dabs = fabs(d0);
-          if (dabs < tol) return 0;
+          if (dabs < tol) return WCSERR_SUCCESS;
 
-          /* Record the point of closest approach. */
+          // Record the point of closest approach.
           if (dabs < dmin) {
             lmin = lat0;
             dmin = dabs;
           }
 
-          /* Check for a crossing point. */
+          // Check for a crossing point.
           if (signbit(d0) != signbit(d1)) {
             crossed = 2;
             dx = d0;
             break;
           }
 
-          /* Advance to the next subinterval. */
+          // Advance to the next subinterval.
           lat1 = lat0;
           d1 = d0;
         }
 
         if (crossed) {
-          /* A crossing point was found. */
+          // A crossing point was found.
           for (iter = 0; iter < niter; iter++) {
-            /* Use regula falsi division of the interval. */
+            // Use regula falsi division of the interval.
             lambda = d0/(d0-d1);
             if (lambda < 0.1) {
               lambda = 0.1;
@@ -3556,20 +3797,20 @@ int wcsmix(
               return status;
             }
 
-            /* Check for a solution. */
+            // Check for a solution.
             d = pixcrd[mixpix] - pixmix;
             dabs = fabs(d);
-            if (dabs < tol) return 0;
+            if (dabs < tol) return WCSERR_SUCCESS;
 
             if (dlat < tol) {
-              /* An artifact of numerical imprecision. */
-              if (dabs < tol2) return 0;
+              // An artifact of numerical imprecision.
+              if (dabs < tol2) return WCSERR_SUCCESS;
 
-              /* Must be a discontinuity. */
+              // Must be a discontinuity.
               break;
             }
 
-            /* Record the point of closest approach. */
+            // Record the point of closest approach.
             if (dabs < dmin) {
               lmin = lat;
               dmin = dabs;
@@ -3584,14 +3825,14 @@ int wcsmix(
             }
           }
 
-          /* No convergence, must have been a discontinuity. */
+          // No convergence, must have been a discontinuity.
           if (crossed == 1) lat0 = span[1];
           lat1 = lat0;
           d1 = dx;
           crossed = 0;
 
         } else {
-          /* No crossing point; look for a tangent point. */
+          // No crossing point; look for a tangent point.
           if (lmin == span[0]) break;
           if (lmin == span[1]) break;
 
@@ -3635,7 +3876,7 @@ int wcsmix(
             }
             d0m = fabs(pixcrd[mixpix] - pixmix);
 
-            if (d0m < tol) return 0;
+            if (d0m < tol) return WCSERR_SUCCESS;
 
             lat1m = (lat1 + lat)/2.0;
             *worldlat = lat1m;
@@ -3648,7 +3889,7 @@ int wcsmix(
             }
             d1m = fabs(pixcrd[mixpix] - pixmix);
 
-            if (d1m < tol) return 0;
+            if (d1m < tol) return WCSERR_SUCCESS;
 
             if (d0m < d && d0m <= d1m) {
               lat1 = lat;
@@ -3671,9 +3912,9 @@ int wcsmix(
       }
 
     } else {
-      /* Celestial latitude is given. */
+      // Celestial latitude is given.
 
-      /* Check whether the solution interval is a crossing interval. */
+      // Check whether the solution interval is a crossing interval.
       lng0 = span[0];
       *worldlng = lng0;
       if ((status = wcss2p(wcs, 1, 0, world, phi, theta, imgcrd, pixcrd,
@@ -3686,7 +3927,7 @@ int wcsmix(
       d0 = pixcrd[mixpix] - pixmix;
 
       dabs = fabs(d0);
-      if (dabs < tol) return 0;
+      if (dabs < tol) return WCSERR_SUCCESS;
 
       lng1 = span[1];
       *worldlng = lng1;
@@ -3700,11 +3941,11 @@ int wcsmix(
       d1 = pixcrd[mixpix] - pixmix;
 
       dabs = fabs(d1);
-      if (dabs < tol) return 0;
+      if (dabs < tol) return WCSERR_SUCCESS;
       lmin = lng1;
       dmin = dabs;
 
-      /* Check for a crossing point. */
+      // Check for a crossing point.
       if (signbit(d0) != signbit(d1)) {
         crossed = 1;
         dx = d1;
@@ -3714,7 +3955,7 @@ int wcsmix(
       }
 
       for (retry = 0; retry < 4; retry++) {
-        /* Refine the solution interval. */
+        // Refine the solution interval.
         while (lng0 > span[0]) {
           lng0 -= step;
           if (lng0 < span[0]) lng0 = span[0];
@@ -3728,32 +3969,32 @@ int wcsmix(
           }
           d0 = pixcrd[mixpix] - pixmix;
 
-          /* Check for a solution. */
+          // Check for a solution.
           dabs = fabs(d0);
-          if (dabs < tol) return 0;
+          if (dabs < tol) return WCSERR_SUCCESS;
 
-          /* Record the point of closest approach. */
+          // Record the point of closest approach.
           if (dabs < dmin) {
             lmin = lng0;
             dmin = dabs;
           }
 
-          /* Check for a crossing point. */
+          // Check for a crossing point.
           if (signbit(d0) != signbit(d1)) {
             crossed = 2;
             dx = d0;
             break;
           }
 
-          /* Advance to the next subinterval. */
+          // Advance to the next subinterval.
           lng1 = lng0;
           d1 = d0;
         }
 
         if (crossed) {
-          /* A crossing point was found. */
+          // A crossing point was found.
           for (iter = 0; iter < niter; iter++) {
-            /* Use regula falsi division of the interval. */
+            // Use regula falsi division of the interval.
             lambda = d0/(d0-d1);
             if (lambda < 0.1) {
               lambda = 0.1;
@@ -3772,20 +4013,20 @@ int wcsmix(
               return status;
             }
 
-            /* Check for a solution. */
+            // Check for a solution.
             d = pixcrd[mixpix] - pixmix;
             dabs = fabs(d);
-            if (dabs < tol) return 0;
+            if (dabs < tol) return WCSERR_SUCCESS;
 
             if (dlng < tol) {
-              /* An artifact of numerical imprecision. */
-              if (dabs < tol2) return 0;
+              // An artifact of numerical imprecision.
+              if (dabs < tol2) return WCSERR_SUCCESS;
 
-              /* Must be a discontinuity. */
+              // Must be a discontinuity.
               break;
             }
 
-            /* Record the point of closest approach. */
+            // Record the point of closest approach.
             if (dabs < dmin) {
               lmin = lng;
               dmin = dabs;
@@ -3800,14 +4041,14 @@ int wcsmix(
             }
           }
 
-          /* No convergence, must have been a discontinuity. */
+          // No convergence, must have been a discontinuity.
           if (crossed == 1) lng0 = span[1];
           lng1 = lng0;
           d1 = dx;
           crossed = 0;
 
         } else {
-          /* No crossing point; look for a tangent point. */
+          // No crossing point; look for a tangent point.
           if (lmin == span[0]) break;
           if (lmin == span[1]) break;
 
@@ -3851,7 +4092,7 @@ int wcsmix(
             }
             d0m = fabs(pixcrd[mixpix] - pixmix);
 
-            if (d0m < tol) return 0;
+            if (d0m < tol) return WCSERR_SUCCESS;
 
             lng1m = (lng1 + lng)/2.0;
             *worldlng = lng1m;
@@ -3864,7 +4105,7 @@ int wcsmix(
             }
             d1m = fabs(pixcrd[mixpix] - pixmix);
 
-            if (d1m < tol) return 0;
+            if (d1m < tol) return WCSERR_SUCCESS;
 
             if (d0m < d && d0m <= d1m) {
               lng1 = lng;
@@ -3889,7 +4130,7 @@ int wcsmix(
   }
 
 
-  /* Set cel0 to the unity transformation. */
+  // Set cel0 to the unity transformation.
   wcs0 = *wcs;
   wcs0.cel.euler[0] = -90.0;
   wcs0.cel.euler[1] =   0.0;
@@ -3897,10 +4138,10 @@ int wcsmix(
   wcs0.cel.euler[3] =   1.0;
   wcs0.cel.euler[4] =   0.0;
 
-  /* No convergence, check for aberrant behaviour at a native pole. */
+  // No convergence, check for aberrant behaviour at a native pole.
   *theta = -90.0;
   for (j = 1; j <= 2; j++) {
-    /* Could the celestial coordinate element map to a native pole? */
+    // Could the celestial coordinate element map to a native pole?
     *phi = 0.0;
     *theta = -*theta;
     sphx2s(wcscel->euler, 1, 1, 1, 1, phi, theta, &lng, &lat);
@@ -3919,11 +4160,11 @@ int wcsmix(
       *worldlng = lng;
     }
 
-    /* Is there a solution for the given pixel coordinate element? */
+    // Is there a solution for the given pixel coordinate element?
     lng = *worldlng;
     lat = *worldlat;
 
-    /* Feed native coordinates to wcss2p() with cel0 set to unity. */
+    // Feed native coordinates to wcss2p() with cel0 set to unity.
     *worldlng = -180.0;
     *worldlat = *theta;
     if ((status = wcss2p(&wcs0, 1, 0, world, phi, theta, imgcrd, pixcrd,
@@ -3937,15 +4178,15 @@ int wcsmix(
     }
     d0 = pixcrd[mixpix] - pixmix;
 
-    /* Check for a solution. */
+    // Check for a solution.
     if (fabs(d0) < tol) {
-      /* Recall saved world coordinates. */
+      // Recall saved world coordinates.
       *worldlng = lng;
       *worldlat = lat;
-      return 0;
+      return WCSERR_SUCCESS;
     }
 
-    /* Search for a crossing interval. */
+    // Search for a crossing interval.
     phi0 = -180.0;
     for (k = -179; k <= 180; k++) {
       phi1 = (double) k;
@@ -3961,16 +4202,16 @@ int wcsmix(
       }
       d1 = pixcrd[mixpix] - pixmix;
 
-      /* Check for a solution. */
+      // Check for a solution.
       dabs = fabs(d1);
       if (dabs < tol) {
-        /* Recall saved world coordinates. */
+        // Recall saved world coordinates.
         *worldlng = lng;
         *worldlat = lat;
-        return 0;
+        return WCSERR_SUCCESS;
       }
 
-      /* Is it a crossing interval? */
+      // Is it a crossing interval?
       if (signbit(d0) != signbit(d1)) break;
 
       phi0 = phi1;
@@ -3978,7 +4219,7 @@ int wcsmix(
     }
 
     for (iter = 1; iter <= niter; iter++) {
-      /* Use regula falsi division of the interval. */
+      // Use regula falsi division of the interval.
       lambda = d0/(d0-d1);
       if (lambda < 0.1) {
         lambda = 0.1;
@@ -3998,14 +4239,14 @@ int wcsmix(
         return status;
       }
 
-      /* Check for a solution. */
+      // Check for a solution.
       d = pixcrd[mixpix] - pixmix;
       dabs = fabs(d);
       if (dabs < tol || (dphi < tol && dabs < tol2)) {
-        /* Recall saved world coordinates. */
+        // Recall saved world coordinates.
         *worldlng = lng;
         *worldlat = lat;
-        return 0;
+        return WCSERR_SUCCESS;
       }
 
       if (signbit(d0) == signbit(d)) {
@@ -4019,11 +4260,199 @@ int wcsmix(
   }
 
 
-  /* No solution. */
+  // No solution.
   return wcserr_set(WCS_ERRMSG(WCSERR_NO_SOLUTION));
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
+
+int wcsccs(
+  struct wcsprm *wcs,
+  double lng2P1,
+  double lat2P1,
+  double lng1P2,
+  const char *clng,
+  const char *clat,
+  const char *radesys,
+  double equinox,
+  const char *alt)
+
+{
+  static const char *function = "wcsccs";
+
+  int status;
+
+  // Initialize if required.
+  if (wcs == 0x0) return WCSERR_NULL_POINTER;
+  struct wcserr **err = &(wcs->err);
+
+  if (wcs->flag != WCSSET) {
+    if ((status = wcsset(wcs))) return status;
+  }
+
+  if (wcs->lng < 0 || wcs->lat < 0) {
+    return wcserr_set(WCSERR_SET(WCSERR_BAD_SUBIMAGE),
+      "Image does not have celestial axes");
+  }
+
+  // (lng1XX,lat1XX)  ...longitude and latitude of XX in the old system.
+  // (lng2XX,lat2XX)  ...longitude and latitude of XX in the new system.
+  // XX = NP          ...natuve pole,
+  //      P1          ...pole of the old system,
+  //      P2          ...pole of the new system,
+  //      FP          ...fiducial point.
+
+  // Set up the transformation from the old to the new system.
+  double euler12[5];
+  euler12[0] = lng2P1;
+  euler12[1] = 90.0 - lat2P1;
+  euler12[2] = lng1P2;
+  euler12[3] = cosd(euler12[1]);
+  euler12[4] = sind(euler12[1]);
+
+  // Transform coordinates of the fiducial point (FP) to the new system.
+  double lng1FP = wcs->crval[wcs->lng];
+  double lat1FP = wcs->crval[wcs->lat];
+  double lng2FP, lat2FP;
+  (void)sphx2s(euler12, 1, 1, 1, 1, &lng1FP, &lat1FP, &lng2FP, &lat2FP);
+
+  // Compute native coordinates of the new pole (noting lat1P2 == lat2P1).
+  double phiP2, thetaP2;
+  (void)sphs2x(wcs->cel.euler, 1, 1, 1, 1, &lng1P2, &lat2P1,
+               &phiP2, &thetaP2);
+
+  if (fabs(lat2FP) == 90.0 || fabs(thetaP2) == 90.0) {
+    // If one of the poles of the new system is at the fiducial point, then
+    // lng2FP is indeterminate, and if one of them is at the native pole, then
+    // phiP2 is indeterminate.  We have to work harder to obtain these values.
+
+    // Compute coordinates of the native pole (NP) in the old and new systems.
+    double phiNP = 0.0, thetaNP = 90.0;
+    double lng1NP, lat1NP;
+    (void)sphx2s(wcs->cel.euler, 1, 1, 1, 1, &phiNP, &thetaNP,
+                 &lng1NP, &lat1NP);
+
+    double lng2NP, lat2NP;
+    (void)sphx2s(euler12, 1, 1, 1, 1, &lng1NP, &lat1NP, &lng2NP, &lat2NP);
+
+    // Native latitude and longitude of the fiducial point, (phi0,theta0).
+    double phiFP   = wcs->cel.prj.phi0;
+    double thetaFP = wcs->cel.prj.theta0;
+
+    if (fabs(lat2NP) == 90.0) {
+      // Following WCS Paper II equations (3) and (4), we are free to choose
+      // phiP2 and set lng2NP accordingly.  So set phiP2 to its default value
+      // for the projection.
+      if (thetaFP < lat2FP) {
+        phiP2 = 0.0;
+      } else {
+        phiP2 = 180.0;
+      }
+
+      // Compute coordinates in the old system of test point X.
+      double phiX = 0.0, thetaX = 0.0;
+      double lng1X, lat1X;
+      (void)sphx2s(wcs->cel.euler, 1, 1, 1, 1, &phiX, &thetaX,
+                   &lng1X, &lat1X);
+
+      // Ensure that lng1X is not indeterminate.
+      if (fabs(lat1X) == 90.0) {
+        phiX = 90.0;
+        (void)sphx2s(wcs->cel.euler, 1, 1, 1, 1, &phiX, &thetaX,
+                     &lng1X, &lat1X);
+      }
+
+      // Compute coordinates in the new system of test point X.
+      double lng2X, lat2X;
+      (void)sphx2s(euler12, 1, 1, 1, 1, &lng1X, &lat1X, &lng2X, &lat2X);
+
+      // Apply WCS Paper II equations (3) and (4).
+      if (lat2NP == +90.0) {
+        lng2NP = lng2X + (phiP2 - phiX) + 180.0;
+      } else {
+        lng2NP = lng2X - (phiP2 - phiX);
+      }
+
+    } else {
+      // For (lng2NP + 90, 0), WCS Paper II equation (5) reduces to
+      // phi = phiP2 - 90.
+      double lng2X = lng2NP + 90.0;
+      double lat2X = 0.0;
+      double lng1X, lat1X;
+      (void)sphs2x(euler12, 1, 1, 1, 1, &lng2X, &lat2X, &lng1X, &lat1X);
+
+      double phiX, thetaX;
+      (void)sphs2x(wcs->cel.euler, 1, 1, 1, 1, &lng1X, &lat1X,
+                   &phiX, &thetaX);
+
+      phiP2 = phiX + 90.0;
+    }
+
+    // Compute the longitude of the fiducial point in the new system.
+    double eulerN2[5];
+    eulerN2[0] = lng2NP;
+    eulerN2[1] = 90.0 - lat2NP;
+    eulerN2[2] = phiP2;
+    eulerN2[3] = cosd(eulerN2[1]);
+    eulerN2[4] = sind(eulerN2[1]);
+
+    (void)sphx2s(eulerN2, 1, 1, 1, 1, &phiFP, &thetaFP, &lng2FP, &lat2FP);
+  }
+
+  // Update reference values in wcsprm.
+  wcs->flag = 0;
+  wcs->crval[wcs->lng] = lng2FP;
+  wcs->crval[wcs->lat] = lat2FP;
+  wcs->lonpole = phiP2;
+  wcs->latpole = thetaP2;
+
+  // Update wcsprm::ctype.
+  if (clng) {
+    strncpy(wcs->ctype[wcs->lng], clng, 4);
+    for (int i = 0; i < 4; i++) {
+      if (wcs->ctype[wcs->lng][i] == '\0') {
+        wcs->ctype[wcs->lng][i] = '-';
+      }
+    }
+  }
+
+  if (clat) {
+    strncpy(wcs->ctype[wcs->lat], clat, 4);
+    for (int i = 0; i < 4; i++) {
+      if (wcs->ctype[wcs->lat][i] == '\0') {
+        wcs->ctype[wcs->lat][i] = '-';
+      }
+    }
+  }
+
+  // Update auxiliary values.
+  if (strncmp(wcs->ctype[wcs->lng], "RA--", 4) == 0 &&
+      strncmp(wcs->ctype[wcs->lat], "DEC-", 4) == 0) {
+    // Transforming to equatorial coordinates.
+    if (radesys) {
+      strncpy(wcs->radesys, radesys, 71);
+    }
+
+    if (equinox != 0.0) {
+      wcs->equinox = equinox;
+    }
+  } else {
+    // Meaningless for other than equatorial coordinates.
+    memset(wcs->radesys, 0, 72);
+    wcs->equinox = UNDEFINED;
+  }
+
+  if (alt && *alt) {
+    wcs->alt[0] = *alt;
+  }
+
+  // Reset the struct.
+  if ((status = wcsset(wcs))) return status;
+
+  return WCSERR_SUCCESS;
+}
+
+//----------------------------------------------------------------------------
 
 int wcssptr(
   struct wcsprm *wcs,
@@ -4033,21 +4462,20 @@ int wcssptr(
 {
   static const char *function = "wcssptr";
 
-  int    j, status;
-  double cdelt, crval;
-  struct wcserr **err;
+  int status;
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
-  err = &(wcs->err);
+  struct wcserr **err = &(wcs->err);
 
   if (wcs->flag != WCSSET) {
     if ((status = wcsset(wcs))) return status;
   }
 
+  int j;
   if ((j = *i) < 0) {
     if ((j = wcs->spec) < 0) {
-      /* Look for a linear spectral axis. */
+      // Look for a linear spectral axis.
       for (j = 0; j < wcs->naxis; j++) {
         if (wcs->types[j]/100 == 30) {
           break;
@@ -4055,16 +4483,17 @@ int wcssptr(
       }
 
       if (j >= wcs->naxis) {
-        /* No spectral axis. */
+        // No spectral axis.
         return wcserr_set(WCSERR_SET(WCSERR_BAD_SUBIMAGE),
-          "No spectral axis found.");
+          "No spectral axis found");
       }
     }
 
     *i = j;
   }
 
-  /* Translate the spectral axis. */
+  // Translate the spectral axis.
+  double cdelt, crval;
   if ((status = spctrne(wcs->ctype[j], wcs->crval[j], wcs->cdelt[j],
                         wcs->restfrq, wcs->restwav, ctype, &crval, &cdelt,
                         &(wcs->spc.err)))) {
@@ -4072,21 +4501,24 @@ int wcssptr(
   }
 
 
-  /* Translate keyvalues. */
+  // Translate keyvalues.
   wcs->flag = 0;
   wcs->cdelt[j] = cdelt;
   wcs->crval[j] = crval;
   spctyp(ctype, 0x0, 0x0, 0x0, wcs->cunit[j], 0x0, 0x0, 0x0);
   strcpy(wcs->ctype[j], ctype);
 
-  /* This keeps things tidy if the spectral axis is linear. */
+  // This keeps things tidy if the spectral axis is linear.
   spcfree(&(wcs->spc));
   spcini(&(wcs->spc));
 
-  return 0;
+  // Reset the struct.
+  if ((status = wcsset(wcs))) return status;
+
+  return WCSERR_SUCCESS;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define STRINGIZE(s) STRINGIFY(s)
 #define STRINGIFY(s) #s
Index: astropy-4.2.1/cextern/wcslib/C/wcs.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcs.h
+++ astropy-4.2.1/cextern/wcslib/C/wcs.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcs.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcs.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -67,12 +64,13 @@
 * set by the user, and others that are maintained by these routines, somewhat
 * like a C++ class but with no encapsulation.
 *
-* wcsnpv(), wcsnps(), wcsini(), wcsinit(), wcssub(), and wcsfree() are
-* provided to manage the wcsprm struct and another, wcsprt(), prints its
-* contents.  Refer to the description of the wcsprm struct for an explanation
-* of the anticipated usage of these routines.  wcscopy(), which does a deep
-* copy of one wcsprm struct to another, is defined as a preprocessor macro
-* function that invokes wcssub().
+* wcsnpv(), wcsnps(), wcsini(), wcsinit(), wcssub(), wcsfree(), and wcstrim(),
+* are provided to manage the wcsprm struct, wcssize() computes its total size
+* including allocated memory, and wcsprt() prints its contents.  Refer to the
+* description of the wcsprm struct for an explanation of the anticipated usage
+* of these routines.  wcscopy(), which does a deep copy of one wcsprm struct
+* to another, is defined as a preprocessor macro function that invokes
+* wcssub().
 *
 * wcsperr() prints the error message(s) (if any) stored in a wcsprm struct,
 * and the linprm, celprm, prjprm, spcprm, and tabprm structs that it contains.
@@ -91,8 +89,10 @@
 * pixel coordinate a hybrid routine, wcsmix(), iteratively solves for the
 * unknown elements.
 *
-* wcssptr() translates the spectral axis in a wcsprm struct.  For example, a
-* 'FREQ' axis may be translated into 'ZOPT-F2W' and vice versa.
+* wcsccs() changes the celestial coordinate system of a wcsprm struct, for
+* example, from equatorial to galactic, and wcssptr() translates the spectral
+* axis.  For example, a 'FREQ' axis may be translated into 'ZOPT-F2W' and vice
+* versa.
 *
 * wcslib_version() returns the WCSLIB version number.
 *
@@ -358,38 +358,39 @@
 *                       wcsprm::err if enabled, see wcserr_enable().
 *
 * Notes:
-*   Combinations of subimage axes of particular types may be extracted in the
-*   same order as they occur in the input image by combining preprocessor
-*   codes, for example
-*
-=     *nsub = 1;
-=     axes[0] = WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_SPECTRAL;
-*
-*   would extract the longitude, latitude, and spectral axes in the same order
-*   as the input image.  If one of each were present, *nsub = 3 would be
-*   returned.
-*
-*   For convenience, WCSSUB_CELESTIAL is defined as the combination
-*   WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_CUBEFACE.
-*
-*   The codes may also be negated to extract all but the types specified, for
-*   example
-*
-=     *nsub = 4;
-=     axes[0] = WCSSUB_LONGITUDE;
-=     axes[1] = WCSSUB_LATITUDE;
-=     axes[2] = WCSSUB_CUBEFACE;
-=     axes[3] = -(WCSSUB_SPECTRAL | WCSSUB_STOKES);
-*
-*   The last of these specifies all axis types other than spectral or Stokes.
-*   Extraction is done in the order specified by axes[] a longitude axis (if
-*   present) would be extracted first (via axes[0]) and not subsequently (via
-*   axes[3]).  Likewise for the latitude and cubeface axes in this example.
-*
-*   From the foregoing, it is apparent that the value of *nsub returned may be
-*   less than or greater than that given.  However, it will never exceed the
-*   number of axes in the input image (plus the number of newly-created axes
-*   if any were specified on input).
+*   1: Combinations of subimage axes of particular types may be extracted in
+*      the same order as they occur in the input image by combining
+*      preprocessor codes, for example
+*
+=        *nsub = 1;
+=        axes[0] = WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_SPECTRAL;
+*
+*      would extract the longitude, latitude, and spectral axes in the same
+*      order as the input image.  If one of each were present, *nsub = 3 would
+*      be returned.
+*
+*      For convenience, WCSSUB_CELESTIAL is defined as the combination
+*      WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_CUBEFACE.
+*
+*      The codes may also be negated to extract all but the types specified,
+*      for example
+*
+=        *nsub = 4;
+=        axes[0] = WCSSUB_LONGITUDE;
+=        axes[1] = WCSSUB_LATITUDE;
+=        axes[2] = WCSSUB_CUBEFACE;
+=        axes[3] = -(WCSSUB_SPECTRAL | WCSSUB_STOKES);
+*
+*      The last of these specifies all axis types other than spectral or
+*      Stokes.  Extraction is done in the order specified by axes[] a
+*      longitude axis (if present) would be extracted first (via axes[0]) and
+*      not subsequently (via axes[3]).  Likewise for the latitude and cubeface
+*      axes in this example.
+*
+*      From the foregoing, it is apparent that the value of *nsub returned may
+*      be less than or greater than that given.  However, it will never exceed
+*      the number of axes in the input image (plus the number of newly-created
+*      axes if any were specified on input).
 *
 *
 * wcscompare() - Compare two wcsprm structs for equality
@@ -450,7 +451,7 @@
 * PLEASE NOTE: wcsfree() must not be invoked on a wcsprm struct that was not
 * initialized by wcsinit().
 *
-* Returned:
+* Given and returned:
 *   wcs       struct wcsprm*
 *                       Coordinate transformation parameters.
 *
@@ -460,6 +461,91 @@
 *                         1: Null wcsprm pointer passed.
 *
 *
+* wcstrim() - Free unused arrays in the wcsprm struct
+* ---------------------------------------------------
+* wcstrim() frees memory allocated by wcsinit() for arrays in the wcsprm
+* struct that remains unused after it has been set up by wcsset().
+*
+* The free'd array members are associated with FITS WCS keyrecords that are
+* rarely used and usually just bloat the struct: wcsprm::crota, wcsprm::colax,
+* wcsprm::cname, wcsprm::crder, wcsprm::csyer, wcsprm::czphs, and
+* wcsprm::cperi.  If unused, wcsprm::pv, wcsprm::ps, and wcsprm::cd are also
+* freed.
+*
+* Once these arrays have been freed, a test such as
+=
+=        if (!undefined(wcs->cname[i])) {...}
+=
+* must be protected as follows
+=
+=        if (wcs->cname && !undefined(wcs->cname[i])) {...}
+=
+* In addition, if wcsprm::npv is non-zero but less than wcsprm::npvmax, then
+* the unused space in wcsprm::pv will be recovered (using realloc()).
+* Likewise for wcsprm::ps.
+*
+* Given and returned:
+*   wcs       struct wcsprm*
+*                       Coordinate transformation parameters.
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*                         1: Null wcsprm pointer passed.
+*                        14: wcsprm struct is unset.
+*
+*
+* wcssize() - Compute the size of a wcsprm struct
+* -----------------------------------------------
+* wcssize() computes the full size of a wcsprm struct, including allocated
+* memory.
+*
+* Given:
+*   wcs       const struct wcsprm*
+*                       Coordinate transformation parameters.
+*
+*                       If NULL, the base size of the struct and the allocated
+*                       size are both set to zero.
+*
+* Returned:
+*   sizes     int[2]    The first element is the base size of the struct as
+*                       returned by sizeof(struct wcsprm).  The second element
+*                       is the total allocated size, in bytes, assuming that
+*                       the allocation was done by wcsini().  This figure
+*                       includes memory allocated for members of constituent
+*                       structs, such as wcsprm::lin.
+*
+*                       It is not an error for the struct not to have been set
+*                       up via wcsset(), which normally results in additional
+*                       memory allocation. 
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*
+*
+* auxsize() - Compute the size of a auxprm struct
+* -----------------------------------------------
+* auxsize() computes the full size of a auxprm struct, including allocated
+* memory.
+*
+* Given:
+*   aux       const struct auxprm*
+*                       Auxiliary coordinate information.
+*
+*                       If NULL, the base size of the struct and the allocated
+*                       size are both set to zero.
+*
+* Returned:
+*   sizes     int[2]    The first element is the base size of the struct as
+*                       returned by sizeof(struct auxprm).  The second element
+*                       is the total allocated size, in bytes, currently zero.
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*
+*
 * wcsprt() - Print routine for the wcsprm struct
 * ----------------------------------------------
 * wcsprt() prints the contents of a wcsprm struct using wcsprintf().  Mainly
@@ -561,9 +647,9 @@
 *                       wcsprm::err if enabled, see wcserr_enable().
 *
 * Notes:
-*   wcsset() always enables strict bounds checking in the projection routines
-*   (via a call to prjini()).  Use wcsbchk() to modify bounds-checking after
-*   wcsset() is invoked.
+*   1: wcsset() always enables strict bounds checking in the projection
+*      routines (via a call to prjini()).  Use wcsbchk() to modify
+*      bounds-checking after wcsset() is invoked.
 *
 *
 * wcsp2s() - Pixel-to-world transformation
@@ -780,31 +866,167 @@
 *                       wcsprm::err if enabled, see wcserr_enable().
 *
 * Notes:
-*   Initially the specified solution interval is checked to see if it's a
-*   "crossing" interval.  If it isn't, a search is made for a crossing
-*   solution by iterating on the unknown celestial coordinate starting at the
-*   upper limit of the solution interval and decrementing by the specified
-*   step size.  A crossing is indicated if the trial value of the pixel
-*   coordinate steps through the value specified.  If a crossing interval is
-*   found then the solution is determined by a modified form of "regula falsi"
-*   division of the crossing interval.  If no crossing interval was found
-*   within the specified solution interval then a search is made for a
-*   "non-crossing" solution as may arise from a point of tangency.  The
-*   process is complicated by having to make allowance for the discontinuities
-*   that occur in all map projections.
-*
-*   Once one solution has been determined others may be found by subsequent
-*   invokations of wcsmix() with suitably restricted solution intervals.
-*
-*   Note the circumstance that arises when the solution point lies at a native
-*   pole of a projection in which the pole is represented as a finite curve,
-*   for example the zenithals and conics.  In such cases two or more valid
-*   solutions may exist but wcsmix() only ever returns one.
-*
-*   Because of its generality wcsmix() is very compute-intensive.  For
-*   compute-limited applications more efficient special-case solvers could be
-*   written for simple projections, for example non-oblique cylindrical
-*   projections.
+*   1: Initially the specified solution interval is checked to see if it's a
+*      "crossing" interval.  If it isn't, a search is made for a crossing
+*      solution by iterating on the unknown celestial coordinate starting at
+*      the upper limit of the solution interval and decrementing by the
+*      specified step size.  A crossing is indicated if the trial value of the
+*      pixel coordinate steps through the value specified.  If a crossing
+*      interval is found then the solution is determined by a modified form of
+*      "regula falsi" division of the crossing interval.  If no crossing
+*      interval was found within the specified solution interval then a search
+*      is made for a "non-crossing" solution as may arise from a point of
+*      tangency.  The process is complicated by having to make allowance for
+*      the discontinuities that occur in all map projections.
+*
+*      Once one solution has been determined others may be found by subsequent
+*      invokations of wcsmix() with suitably restricted solution intervals.
+*
+*      Note the circumstance that arises when the solution point lies at a
+*      native pole of a projection in which the pole is represented as a
+*      finite curve, for example the zenithals and conics.  In such cases two
+*      or more valid solutions may exist but wcsmix() only ever returns one.
+*
+*      Because of its generality wcsmix() is very compute-intensive.  For
+*      compute-limited applications more efficient special-case solvers could
+*      be written for simple projections, for example non-oblique cylindrical
+*      projections.
+*
+*
+* wcsccs() - Change celestial coordinate system
+* ---------------------------------------------
+* wcsccs() changes the celestial coordinate system of a wcsprm struct.  For
+* example, from equatorial to galactic coordinates.
+*
+* Parameters that define the spherical coordinate transformation, essentially
+* being three Euler angles, must be provided.  Thereby wcsccs() does not need
+* prior knowledge of specific celestial coordinate systems.  It also has the
+* advantage of making it completely general.
+*
+* Auxiliary members of the wcsprm struct relating to equatorial celestial
+* coordinate systems may also be changed.
+*
+* Only orthodox spherical coordinate systems are supported.  That is, they
+* must be right-handed, with latitude increasing from zero at the equator to
+* +90 degrees at the pole.  This precludes systems such as aziumuth and zenith
+* distance, which, however, could be handled as negative azimuth and
+* elevation.
+*
+* PLEASE NOTE: Information in the wcsprm struct relating to the original
+* coordinate system will be overwritten and therefore lost.  If this is
+* undesirable, invoke wcsccs() on a copy of the struct made with wcssub().
+* The wcsprm struct is reset on return with an explicit call to wcsset().
+*
+* Given and returned:
+*   wcs       struct wcsprm*
+*                       Coordinate transformation parameters.  Particular
+*                       "values to be given" elements of the wcsprm struct
+*                       are modified.
+*
+* Given:
+*   lng2p1,
+*   lat2p1    double    Longitude and latitude in the new celestial coordinate
+*                       system of the pole (i.e. latitude +90) of the original
+*                       system [deg].  See notes 1 and 2 below.
+*
+*   lng1p2    double    Longitude in the original celestial coordinate system
+*                       of the pole (i.e. latitude +90) of the new system
+*                       [deg].  See note 1 below.
+*
+*   clng,clat const char*
+*                       Longitude and latitude identifiers of the new CTYPEia
+*                       celestial axis codes, without trailing dashes.  For
+*                       example, "RA" and "DEC" or "GLON" and "GLAT".  Up to
+*                       four characters are used, longer strings need not be
+*                       null-terminated.
+*
+*   radesys   const char*
+*                       Used when transforming to equatorial coordinates,
+*                       identified by clng == "RA" and clat = "DEC".  May be
+*                       set to the null pointer to preserve the current value.
+*                       Up to 71 characters are used, longer strings need not
+*                       be null-terminated.
+*
+*                       If the new coordinate system is anything other than
+*                       equatorial, then wcsprm::radesys will be cleared.
+*
+*   equinox   double    Used when transforming to equatorial coordinates.  May
+*                       be set to zero to preserve the current value.
+*
+*                       If the new coordinate system is not equatorial, then
+*                       wcsprm::equinox will be marked as undefined.
+*
+*   alt       const char*
+*                       Character code for alternate coordinate descriptions
+*                       (i.e. the 'a' in keyword names such as CTYPEia).  This
+*                       is blank for the primary coordinate description, or
+*                       one of the 26 upper-case letters, A-Z.  May be set to
+*                       the null pointer, or null string if no change is
+*                       required.
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*                         1: Null wcsprm pointer passed.
+*                        12: Invalid subimage specification (no celestial
+*                            axes).
+*
+* Notes:
+*   1: Follows the prescription given in WCS Paper II, Sect. 2.7 for changing
+*      celestial coordinates.
+*
+*      The implementation takes account of indeterminacies that arise in that
+*      prescription in the particular cases where one of the poles of the new
+*      system is at the fiducial point, or one of them is at the native pole.
+*
+*   2: If lat2p1 == +90, i.e. where the poles of the two coordinate systems
+*      coincide, then the spherical coordinate transformation becomes a simple
+*      change in origin of longitude given by
+*      lng2 = lng1 + (lng2p1 - lng1p2 - 180), and lat2 = lat1, where
+*      (lng2,lat2) are coordinates in the new system, and (lng1,lat1) are
+*      coordinates in the original system.
+*
+*      Likewise, if lat2p1 == -90, then lng2 = -lng1 + (lng2p1 + lng1p2), and
+*      lat2 = -lat1.
+*
+*   3: For example, if the original coordinate system is B1950 equatorial and
+*      the desired new coordinate system is galactic, then
+*
+*      - (lng2p1,lat2p1) are the galactic coordinates of the B1950 celestial
+*        pole, defined by the IAU to be (123.0,+27.4), and lng1p2 is the B1950
+*        right ascension of the galactic pole, defined as 192.25.  Clearly
+*        these coordinates are fixed for a particular coordinate
+*        transformation.
+*
+*      - (clng,clat) would be 'GLON' and 'GLAT', these being the FITS standard
+*        identifiers for galactic coordinates.
+*
+*      - Since the new coordinate system is not equatorial, wcsprm::radesys
+*        and wcsprm::equinox will be cleared.
+*
+*   4. The coordinates required for some common transformations (obtained from
+*      https://ned.ipac.caltech.edu/coordinate_calculator) are as follows:
+*
+=      (123.0000,+27.4000) galactic coordinates of B1950 celestial pole,
+=      (192.2500,+27.4000) B1950 equatorial coordinates of galactic pole.
+*
+=      (122.9319,+27.1283) galactic coordinates of J2000 celestial pole,
+=      (192.8595,+27.1283) J2000 equatorial coordinates of galactic pole.
+*
+=      (359.6774,+89.7217) B1950 equatorial coordinates of J2000 pole,
+=      (180.3162,+89.7217) J2000 equatorial coordinates of B1950 pole.
+*
+=      (270.0000,+66.5542) B1950 equatorial coordinates of B1950 ecliptic pole,
+=      ( 90.0000,+66.5542) B1950 ecliptic coordinates of B1950 celestial pole.
+*
+=      (270.0000,+66.5607) J2000 equatorial coordinates of J2000 ecliptic pole,
+=      ( 90.0000,+66.5607) J2000 ecliptic coordinates of J2000 celestial pole.
+*
+=      ( 26.7315,+15.6441) supergalactic coordinates of B1950 celestial pole,
+=      (283.1894,+15.6441) B1950 equatorial coordinates of supergalactic pole.
+*
+=      ( 26.4505,+15.7089) supergalactic coordinates of J2000 celestial pole,
+=      (283.7542,+15.7089) J2000 equatorial coordinates of supergalactic pole.
 *
 *
 * wcssptr() - Spectral axis translation
@@ -812,6 +1034,11 @@
 * wcssptr() translates the spectral axis in a wcsprm struct.  For example, a
 * 'FREQ' axis may be translated into 'ZOPT-F2W' and vice versa.
 *
+* PLEASE NOTE: Information in the wcsprm struct relating to the original
+* coordinate system will be overwritten and therefore lost.  If this is
+* undesirable, invoke wcssptr() on a copy of the struct made with wcssub().
+* The wcsprm struct is reset on return with an explicit call to wcsset().
+*
 * Given and returned:
 *   wcs       struct wcsprm*
 *                       Coordinate transformation parameters.
@@ -928,8 +1155,8 @@
 *       - wcsprm::wtb.
 *
 *     This signals the initialization routine, wcsset(), to recompute the
-*     returned members of the celprm struct.  celset() will reset flag to
-*     indicate that this has been done.
+*     returned members of the linprm, celprm, spcprm, and tabprm structs.
+*     wcsset() will reset flag to indicate that this has been done.
 *
 *     PLEASE NOTE: flag should be set to -1 when wcsinit() is called for the
 *     first time for a particular wcsprm struct in order to initialize memory
@@ -1101,38 +1328,45 @@
 *
 *     - Bit 1: CDi_ja is present.
 *
-*       Matrix elements in the IRAF convention are
-*       equivalent to the product CDi_ja = CDELTia * PCi_ja, but the
-*       defaults differ from that of the PCi_ja matrix.  If one or more
-*       CDi_ja keywords are present then all unspecified CDi_ja default to
-*       zero.  If no CDi_ja (or CROTAi) keywords are present, then the
-*       header is assumed to be in PCi_ja form whether or not any PCi_ja
-*       keywords are present since this results in an interpretation of
-*       CDELTia consistent with the original FITS specification.
+*       Matrix elements in the IRAF convention are equivalent to the product
+*       CDi_ja = CDELTia * PCi_ja, but the defaults differ from that of the
+*       PCi_ja matrix.  If one or more CDi_ja keywords are present then all
+*       unspecified CDi_ja default to zero.  If no CDi_ja (or CROTAi) keywords
+*       are present, then the header is assumed to be in PCi_ja form whether
+*       or not any PCi_ja keywords are present since this results in an
+*       interpretation of CDELTia consistent with the original FITS
+*       specification.
 *
 *       While CDi_ja may not formally co-exist with PCi_ja, it may co-exist
 *       with CDELTia and CROTAi which are to be ignored.
 *
 *     - Bit 2: CROTAi is present.
 *
-*       In the AIPS convention, CROTAi may only be
-*       associated with the latitude axis of a celestial axis pair.  It
-*       specifies a rotation in the image plane that is applied AFTER the
-*       CDELTia; any other CROTAi keywords are ignored.
+*       In the AIPS convention, CROTAi may only be associated with the
+*       latitude axis of a celestial axis pair.  It specifies a rotation in
+*       the image plane that is applied AFTER the CDELTia; any other CROTAi
+*       keywords are ignored.
 *
 *       CROTAi may not formally co-exist with PCi_ja.
 *
 *       CROTAi and CDELTia may formally co-exist with CDi_ja but if so are to
 *       be ignored.
 *
-*     CDi_ja and CROTAi keywords, if found, are to be stored in the
-*     wcsprm::cd and wcsprm::crota arrays which are dimensioned similarly to
-*     wcsprm::pc and wcsprm::cdelt.  FITS
-*     header parsers should use the following procedure:
+*     - Bit 3: PCi_ja + CDELTia was derived from CDi_ja by wcspcx().
+*
+*       This bit is set by wcspcx() when it derives PCi_ja and CDELTia from
+*       CDi_ja via an orthonormal decomposition.  In particular, it signals
+*       wcsset() not to replace PCi_ja by a copy of CDi_ja with CDELTia set
+*       to unity.
 *
-*     - Whenever a PCi_ja  keyword is encountered: altlin |= 1;
+*     CDi_ja and CROTAi keywords, if found, are to be stored in the wcsprm::cd
+*     and wcsprm::crota arrays which are dimensioned similarly to wcsprm::pc
+*     and wcsprm::cdelt.  FITS header parsers should use the following
+*     procedure:
 *
-*     - Whenever a CDi_ja  keyword is encountered: altlin |= 2;
+*     - Whenever a PCi_ja keyword is encountered: altlin |= 1;
+*
+*     - Whenever a CDi_ja keyword is encountered: altlin |= 2;
 *
 *     - Whenever a CROTAi keyword is encountered: altlin |= 4;
 *
@@ -1141,8 +1375,9 @@
 *
 *     These alternate specifications of the linear transformation matrix are
 *     translated immediately to PCi_ja by wcsset() and are invisible to the
-*     lower-level WCSLIB routines.  In particular, wcsset() resets
-*     wcsprm::cdelt to unity if CDi_ja is present (and no PCi_ja).
+*     lower-level WCSLIB routines.  In particular, unless bit 3 is also set,
+*     wcsset() resets wcsprm::cdelt to unity if CDi_ja is present (and no
+*     PCi_ja).
 *
 *     If CROTAi are present but none is associated with the latitude axis
 *     (and no PCi_ja or CDi_ja), then wcsset() reverts to a unity PCi_ja
@@ -1730,7 +1965,7 @@
 
 #ifdef __cplusplus
 extern "C" {
-#define wtbarr wtbarr_s		/* See prologue of wtbarr.h.                */
+#define wtbarr wtbarr_s		// See prologue of wtbarr.h.
 #endif
 
 #define WCSSUB_LONGITUDE 0x1001
@@ -1749,111 +1984,110 @@ extern "C" {
 extern const char *wcs_errmsg[];
 
 enum wcs_errmsg_enum {
-  WCSERR_SUCCESS         =  0,	/* Success. */
-  WCSERR_NULL_POINTER    =  1,	/* Null wcsprm pointer passed. */
-  WCSERR_MEMORY          =  2,	/* Memory allocation failed. */
-  WCSERR_SINGULAR_MTX    =  3,	/* Linear transformation matrix is
-				   singular. */
-  WCSERR_BAD_CTYPE       =  4,	/* Inconsistent or unrecognized coordinate
-				   axis type. */
-  WCSERR_BAD_PARAM       =  5,	/* Invalid parameter value. */
-  WCSERR_BAD_COORD_TRANS =  6,	/* Unrecognized coordinate transformation
-				   parameter. */
-  WCSERR_ILL_COORD_TRANS =  7,	/* Ill-conditioned coordinate transformation
-				   parameter. */
-  WCSERR_BAD_PIX         =  8,	/* One or more of the pixel coordinates were
-				   invalid. */
-  WCSERR_BAD_WORLD       =  9,	/* One or more of the world coordinates were
-				   invalid. */
-  WCSERR_BAD_WORLD_COORD = 10,	/* Invalid world coordinate. */
-  WCSERR_NO_SOLUTION     = 11,	/* No solution found in the specified
-				   interval. */
-  WCSERR_BAD_SUBIMAGE    = 12,	/* Invalid subimage specification. */
-  WCSERR_NON_SEPARABLE   = 13 	/* Non-separable subimage coordinate
-				   system. */
+  WCSERR_SUCCESS         =  0,	// Success.
+  WCSERR_NULL_POINTER    =  1,	// Null wcsprm pointer passed.
+  WCSERR_MEMORY          =  2,	// Memory allocation failed.
+  WCSERR_SINGULAR_MTX    =  3,	// Linear transformation matrix is singular.
+  WCSERR_BAD_CTYPE       =  4,	// Inconsistent or unrecognized coordinate
+				// axis type.
+  WCSERR_BAD_PARAM       =  5,	// Invalid parameter value.
+  WCSERR_BAD_COORD_TRANS =  6,	// Unrecognized coordinate transformation
+				// parameter.
+  WCSERR_ILL_COORD_TRANS =  7,	// Ill-conditioned coordinate transformation
+				// parameter.
+  WCSERR_BAD_PIX         =  8,	// One or more of the pixel coordinates were
+				// invalid.
+  WCSERR_BAD_WORLD       =  9,	// One or more of the world coordinates were
+				// invalid.
+  WCSERR_BAD_WORLD_COORD = 10,	// Invalid world coordinate.
+  WCSERR_NO_SOLUTION     = 11,	// No solution found in the specified
+				// interval.
+  WCSERR_BAD_SUBIMAGE    = 12,	// Invalid subimage specification.
+  WCSERR_NON_SEPARABLE   = 13,	// Non-separable subimage coordinate system.
+  WCSERR_UNSET           = 14 	// wcsprm struct is unset.
 };
 
 
-/* Struct used for storing PVi_ma keywords. */
+// Struct used for storing PVi_ma keywords.
 struct pvcard {
-  int i;			/* Axis number, as in PVi_ma (1-relative).  */
-  int m;			/* Parameter number, ditto  (0-relative).   */
-  double value;			/* Parameter value.                         */
+  int i;			// Axis number, as in PVi_ma (1-relative).
+  int m;			// Parameter number, ditto  (0-relative).
+  double value;			// Parameter value.
 };
 
-/* Size of the pvcard struct in int units, used by the Fortran wrappers. */
+// Size of the pvcard struct in int units, used by the Fortran wrappers.
 #define PVLEN (sizeof(struct pvcard)/sizeof(int))
 
-/* Struct used for storing PSi_ma keywords. */
+// Struct used for storing PSi_ma keywords.
 struct pscard {
-  int i;			/* Axis number, as in PSi_ma (1-relative).  */
-  int m;			/* Parameter number, ditto  (0-relative).   */
-  char value[72];		/* Parameter value.                         */
+  int i;			// Axis number, as in PSi_ma (1-relative).
+  int m;			// Parameter number, ditto  (0-relative).
+  char value[72];		// Parameter value.
 };
 
-/* Size of the pscard struct in int units, used by the Fortran wrappers. */
+// Size of the pscard struct in int units, used by the Fortran wrappers.
 #define PSLEN (sizeof(struct pscard)/sizeof(int))
 
-/* Struct used to hold additional auxiliary parameters.                     */
+// Struct used to hold additional auxiliary parameters.
 struct auxprm {
-  double rsun_ref;              /* Solar radius.                            */
-  double dsun_obs;              /* Distance from Sun centre to observer.    */
-  double crln_obs;              /* Carrington heliographic lng of observer. */
-  double hgln_obs;              /* Stonyhurst heliographic lng of observer. */
-  double hglt_obs;              /* Heliographic latitude of observer.       */
+  double rsun_ref;              // Solar radius.
+  double dsun_obs;              // Distance from Sun centre to observer.
+  double crln_obs;              // Carrington heliographic lng of observer.
+  double hgln_obs;              // Stonyhurst heliographic lng of observer.
+  double hglt_obs;              // Heliographic latitude of observer.
 };
 
-/* Size of the auxprm struct in int units, used by the Fortran wrappers. */
+// Size of the auxprm struct in int units, used by the Fortran wrappers.
 #define AUXLEN (sizeof(struct auxprm)/sizeof(int))
 
 
 struct wcsprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int    flag;			/* Set to zero to force initialization.     */
-
-  /* FITS header keyvalues to be provided (see the prologue above).         */
-  /*------------------------------------------------------------------------*/
-  int    naxis;			/* Number of axes (pixel and coordinate).   */
-  double *crpix;		/* CRPIXja keyvalues for each pixel axis.   */
-  double *pc;			/* PCi_ja  linear transformation matrix.    */
-  double *cdelt;		/* CDELTia keyvalues for each coord axis.   */
-  double *crval;		/* CRVALia keyvalues for each coord axis.   */
-
-  char   (*cunit)[72];		/* CUNITia keyvalues for each coord axis.   */
-  char   (*ctype)[72];		/* CTYPEia keyvalues for each coord axis.   */
-
-  double lonpole;		/* LONPOLEa keyvalue.                       */
-  double latpole;		/* LATPOLEa keyvalue.                       */
-
-  double restfrq;		/* RESTFRQa keyvalue.                       */
-  double restwav;		/* RESTWAVa keyvalue.                       */
-
-  int    npv;			/* Number of PVi_ma keywords, and the       */
-  int    npvmax;		/* number for which space was allocated.    */
-  struct pvcard *pv;		/* PVi_ma keywords for each i and m.        */
-
-  int    nps;			/* Number of PSi_ma keywords, and the       */
-  int    npsmax;		/* number for which space was allocated.    */
-  struct pscard *ps;		/* PSi_ma keywords for each i and m.        */
-
-  /* Alternative header keyvalues (see the prologue above).                 */
-  /*------------------------------------------------------------------------*/
-  double *cd;			/* CDi_ja linear transformation matrix.     */
-  double *crota;		/* CROTAi keyvalues for each coord axis.    */
-  int    altlin;		/* Alternative representations              */
-				/*   Bit 0: PCi_ja  is present,             */
-				/*   Bit 1: CDi_ja  is present,             */
-				/*   Bit 2: CROTAi is present.              */
-  int    velref;		/* AIPS velocity code, VELREF.              */
-
-  /* Auxiliary coordinate system information of a general nature.  Not      */
-  /* used by WCSLIB.  Refer to the prologue comments above for a brief      */
-  /* explanation of these values.                                           */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    flag;			// Set to zero to force initialization.
+
+  // FITS header keyvalues to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    naxis;			// Number of axes (pixel and coordinate).
+  double *crpix;		// CRPIXja keyvalues for each pixel axis.
+  double *pc;			// PCi_ja  linear transformation matrix.
+  double *cdelt;		// CDELTia keyvalues for each coord axis.
+  double *crval;		// CRVALia keyvalues for each coord axis.
+
+  char   (*cunit)[72];		// CUNITia keyvalues for each coord axis.
+  char   (*ctype)[72];		// CTYPEia keyvalues for each coord axis.
+
+  double lonpole;		// LONPOLEa keyvalue.
+  double latpole;		// LATPOLEa keyvalue.
+
+  double restfrq;		// RESTFRQa keyvalue.
+  double restwav;		// RESTWAVa keyvalue.
+
+  int    npv;			// Number of PVi_ma keywords, and the
+  int    npvmax;		// number for which space was allocated.
+  struct pvcard *pv;		// PVi_ma keywords for each i and m.
+
+  int    nps;			// Number of PSi_ma keywords, and the
+  int    npsmax;		// number for which space was allocated.
+  struct pscard *ps;		// PSi_ma keywords for each i and m.
+
+  // Alternative header keyvalues (see the prologue above).
+  //--------------------------------------------------------------------------
+  double *cd;			// CDi_ja linear transformation matrix.
+  double *crota;		// CROTAi keyvalues for each coord axis.
+  int    altlin;		// Alternative representations
+				//   Bit 0: PCi_ja is present,
+				//   Bit 1: CDi_ja is present,
+				//   Bit 2: CROTAi is present.
+  int    velref;		// AIPS velocity code, VELREF.
+
+  // Auxiliary coordinate system information of a general nature.  Not
+  // used by WCSLIB.  Refer to the prologue comments above for a brief
+  // explanation of these values.
   char   alt[4];
   int    colnum;
   int    *colax;
-				/* Auxiliary coordinate axis information.   */
+				// Auxiliary coordinate axis information.
   char   (*cname)[72];
   double *crder;
   double *csyer;
@@ -1861,22 +2095,22 @@ struct wcsprm {
   double *cperi;
 
   char   wcsname[72];
-				/* Time reference system and measurement.   */
+				// Time reference system and measurement.
   char   timesys[72], trefpos[72], trefdir[72], plephem[72];
   char   timeunit[72];
   char   dateref[72];
   double mjdref[2];
   double timeoffs;
-				/* Data timestamps and durations.           */
+				// Data timestamps and durations.
   char   dateobs[72], datebeg[72], dateavg[72], dateend[72];
   double mjdobs, mjdbeg, mjdavg, mjdend;
   double jepoch, bepoch;
   double tstart, tstop;
   double xposure, telapse;
-				/* Timing accuracy.                         */
+				// Timing accuracy.
   double timsyer, timrder;
   double timedel, timepixr;
-				/* Spatial & celestial reference frame.     */
+				// Spatial & celestial reference frame.
   double obsgeo[6];
   char   obsorbit[72];
   char   radesys[72];
@@ -1888,40 +2122,40 @@ struct wcsprm {
   char   ssyssrc[72];
   double velangl;
 
-  /* Additional auxiliary coordinate system information of a specialist     */
-  /* nature.  Not used by WCSLIB.  Refer to the prologue comments above.    */
+  // Additional auxiliary coordinate system information of a specialist
+  // nature.  Not used by WCSLIB.  Refer to the prologue comments above.
   struct auxprm *aux;
 
-  /* Coordinate lookup tables (see the prologue above).                     */
-  /*------------------------------------------------------------------------*/
-  int    ntab;			/* Number of separate tables.               */
-  int    nwtb;			/* Number of wtbarr structs.                */
-  struct tabprm *tab;		/* Tabular transformation parameters.       */
-  struct wtbarr *wtb;		/* Array of wtbarr structs.                 */
-
-  /*------------------------------------------------------------------------*/
-  /* Information derived from the FITS header keyvalues by wcsset().        */
-  /*------------------------------------------------------------------------*/
-  char   lngtyp[8], lattyp[8];	/* Celestial axis types, e.g. RA, DEC.      */
-  int    lng, lat, spec;	/* Longitude, latitude and spectral axis    */
-				/* indices (0-relative).                    */
-  int    cubeface;		/* True if there is a CUBEFACE axis.        */
-  int    *types;		/* Coordinate type codes for each axis.     */
-
-  struct linprm lin;		/*    Linear transformation parameters.     */
-  struct celprm cel;		/* Celestial transformation parameters.     */
-  struct spcprm spc;		/*  Spectral transformation parameters.     */
-
-  /*------------------------------------------------------------------------*/
-  /*             THE REMAINDER OF THE WCSPRM STRUCT IS PRIVATE.             */
-  /*------------------------------------------------------------------------*/
+  // Coordinate lookup tables (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    ntab;			// Number of separate tables.
+  int    nwtb;			// Number of wtbarr structs.
+  struct tabprm *tab;		// Tabular transformation parameters.
+  struct wtbarr *wtb;		// Array of wtbarr structs.
+
+  //--------------------------------------------------------------------------
+  // Information derived from the FITS header keyvalues by wcsset().
+  //--------------------------------------------------------------------------
+  char   lngtyp[8], lattyp[8];	// Celestial axis types, e.g. RA, DEC.
+  int    lng, lat, spec;	// Longitude, latitude and spectral axis
+				// indices (0-relative).
+  int    cubeface;		// True if there is a CUBEFACE axis.
+  int    *types;		// Coordinate type codes for each axis.
+
+  struct linprm lin;		//    Linear transformation parameters.
+  struct celprm cel;		// Celestial transformation parameters.
+  struct spcprm spc;		//  Spectral transformation parameters.
+
+  //--------------------------------------------------------------------------
+  //             THE REMAINDER OF THE WCSPRM STRUCT IS PRIVATE.
+  //--------------------------------------------------------------------------
 
-  /* Error handling, if enabled.                                            */
-  /*------------------------------------------------------------------------*/
+  // Error handling, if enabled.
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Memory management.                                                     */
-  /*------------------------------------------------------------------------*/
+  // Memory management.
+  //--------------------------------------------------------------------------
   int    m_flag, m_naxis;
   double *m_crpix, *m_pc, *m_cdelt, *m_crval;
   char  (*m_cunit)[72], (*m_ctype)[72];
@@ -1936,7 +2170,7 @@ struct wcsprm {
   struct wtbarr *m_wtb;
 };
 
-/* Size of the wcsprm struct in int units, used by the Fortran wrappers. */
+// Size of the wcsprm struct in int units, used by the Fortran wrappers.
 #define WCSLEN (sizeof(struct wcsprm)/sizeof(int))
 
 
@@ -1959,6 +2193,12 @@ int wcscompare(int cmp, double tol, cons
 
 int wcsfree(struct wcsprm *wcs);
 
+int wcstrim(struct wcsprm *wcs);
+
+int wcssize(const struct wcsprm *wcs, int sizes[2]);
+
+int auxsize(const struct auxprm *aux, int sizes[2]);
+
 int wcsprt(const struct wcsprm *wcs);
 
 int wcsperr(const struct wcsprm *wcs, const char *prefix);
@@ -1979,15 +2219,19 @@ int wcsmix(struct wcsprm *wcs, int mixpi
            double vstep, int viter, double world[], double phi[],
            double theta[], double imgcrd[], double pixcrd[]);
 
+int wcsccs(struct wcsprm *wcs, double lng2p1, double lat2p1, double lng1p2,
+           const char *clng, const char *clat, const char *radesys,
+           double equinox, const char *alt);
+
 int wcssptr(struct wcsprm *wcs, int *i, char ctype[9]);
 
 const char* wcslib_version(int vers[3]);
 
-/* Defined mainly for backwards compatibility, use wcssub() instead. */
+// Defined mainly for backwards compatibility, use wcssub() instead.
 #define wcscopy(alloc, wcssrc, wcsdst) wcssub(alloc, wcssrc, 0x0, 0x0, wcsdst)
 
 
-/* Deprecated. */
+// Deprecated.
 #define wcsini_errmsg wcs_errmsg
 #define wcssub_errmsg wcs_errmsg
 #define wcscopy_errmsg wcs_errmsg
@@ -2003,4 +2247,4 @@ const char* wcslib_version(int vers[3]);
 }
 #endif
 
-#endif /* WCSLIB_WCS */
+#endif // WCSLIB_WCS
Index: astropy-4.2.1/cextern/wcslib/C/wcsbth.l
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsbth.l
+++ astropy-4.2.1/cextern/wcslib/C/wcsbth.l
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsbth.l,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsbth.l,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
 * wcsbth.l is a Flex description file containing the definition of a lexical
@@ -76,6 +73,7 @@
 %option outfile="wcsbth.c"
 %option prefix="wcsbth"
 %option reentrant
+%option extra-type="struct wcsbth_extra *"
 
 /* Indices for parameterized keywords. */
 Z1	[0-9]
@@ -125,57 +123,34 @@ INLINE " "*(\/.*)?
 #include "wcsprintf.h"
 #include "wcsutil.h"
 
-			/* Codes used for keyvalue data types. */
+			// Codes used for keyvalue data types.
 #define INTEGER 0
 #define FLOAT   1
 #define FLOAT2  2
 #define STRING  3
 
-			/* Bit masks used for keyword types:        */
-#define IMGAUX  0x1	/* Auxiliary image header, e.g. LONPOLEa or */
-			/* DATE-OBS.                                */
-#define IMGAXIS 0x2	/* Image header with axis number, e.g.      */
-			/* CTYPEia.                                 */
-#define IMGHEAD 0x3	/* IMGAUX | IMGAXIS, i.e. image header of   */
-			/* either type.                             */
-#define BIMGARR 0x4	/* Binary table image array, e.g. iCTYna.   */
-#define PIXLIST 0x8	/* Pixel list, e.g. TCTYna.                 */
-#define BINTAB  0xC	/* BIMGARR | PIXLIST, i.e. binary table     */
-			/* image array (without axis number) or     */
-			/* pixel list, e.g. LONPna or OBSGXn.       */
-
-static int wcsbth_scanner(char *header, int nkeyrec, int relax, int ctrl,
-                          int keysel, int *colsel, int *nreject, int *nwcs,
-                          struct wcsprm **wcs, yyscan_t yyscanner);
-
-/*--------------------------------------------------------------------------*/
-
-int wcsbth(
-  char *header,
-  int nkeyrec,
-  int relax,
-  int ctrl,
-  int keysel,
-  int *colsel,
-  int *nreject,
-  int *nwcs,
-  struct wcsprm **wcs)
-
-{
-  int status;
-  yyscan_t yyscanner;
-  int yylex_init(yyscan_t *yyscanner);
-  int yylex_destroy(yyscan_t yyscanner);
-
-  yylex_init(&yyscanner);
-  status = wcsbth_scanner(header, nkeyrec, relax, ctrl, keysel, colsel,
-                          nreject, nwcs, wcs, yyscanner);
-  yylex_destroy(yyscanner);
-
-  return status;
-}
+			// Bit masks used for keyword types:
+#define IMGAUX  0x1	// Auxiliary image header, e.g. LONPOLEa or
+			// DATE-OBS.
+#define IMGAXIS 0x2	// Image header with axis number, e.g.
+			// CTYPEia.
+#define IMGHEAD 0x3	// IMGAUX | IMGAXIS, i.e. image header of
+			// either type.
+#define BIMGARR 0x4	// Binary table image array, e.g. iCTYna.
+#define PIXLIST 0x8	// Pixel list, e.g. TCTYna.
+#define BINTAB  0xC	// BIMGARR | PIXLIST, i.e. binary table
+			// image array (without axis number) or
+			// pixel list, e.g. LONPna or OBSGXn.
+
+// User data associated with yyscanner.
+struct wcsbth_extra {
+  // Values passed to YY_INPUT.
+  char *hdr;
+  int  nkeyrec;
 
-/*--------------------------------------------------------------------------*/
+  // Used in preempting the call to exit() by yy_fatal_error().
+  jmp_buf abort_jmp_env;
+};
 
 #define YY_DECL int wcsbth_scanner(char *header, int nkeyrec, int relax, \
  int ctrl, int keysel, int *colsel, int *nreject, int *nwcs, \
@@ -183,29 +158,28 @@ int wcsbth(
 
 #define YY_INPUT(inbuff, count, bufsize) \
 	{ \
-	  if (wcsbth_nkeyrec) { \
-	    strncpy(inbuff, wcsbth_hdr, 80); \
+	  if (yyextra->nkeyrec) { \
+	    strncpy(inbuff, yyextra->hdr, 80); \
 	    inbuff[80] = '\n'; \
-	    wcsbth_hdr += 80; \
-	    wcsbth_nkeyrec--; \
+	    yyextra->hdr += 80; \
+	    yyextra->nkeyrec--; \
 	    count = 81; \
 	  } else { \
 	    count = YY_NULL; \
 	  } \
 	}
 
-/* A convenience macro to get around incompatibilities between unput() and
-   yyless(): put yytext followed by a blank back onto the input stream. */
+// Preempt the call to exit() by yy_fatal_error().
+#define exit(status) longjmp(yyextra->abort_jmp_env, status);
+
+// A convenience macro to get around incompatibilities between unput() and
+// yyless(): put yytext followed by a blank back onto the input stream.
 #define WCSBTH_PUTBACK \
   sprintf(strtmp, "%s ", yytext); \
-  iz = strlen(strtmp); \
+  size_t iz = strlen(strtmp); \
   while (iz) unput(strtmp[--iz]);
 
-/* These global variables are required by YY_INPUT. */
-static char *wcsbth_hdr;
-static int  wcsbth_nkeyrec;
-
-/* Struct used internally for header bookkeeping. */
+// Struct used internally for header bookkeeping.
 struct wcsbth_alts {
   int ncol, ialt, icol, imgherit;
   short int (*arridx)[27];
@@ -220,7 +194,8 @@ struct wcsbth_alts {
   unsigned char pad2[2];
 };
 
-/* Internal helper functions. */
+// Internal helper functions.
+static YY_DECL;
 static int wcsbth_colax(struct wcsprm *wcs, struct wcsbth_alts *alts, int k,
         char a);
 static int wcsbth_final(struct wcsbth_alts *alts, int *nwcs,
@@ -232,116 +207,99 @@ static int wcsbth_init1(struct wcsbth_al
 static int wcsbth_pass1(int keytype, int i, int j, int n, int k, char a,
         char ptype, struct wcsbth_alts *alts);
 
-/* Helper functions for keywords that require special handling. */
+// Helper functions for keywords that require special handling.
 static int wcsbth_jdref(double *wptr,   const double *jdref);
 static int wcsbth_jdrefi(double *wptr,  const double *jdrefi);
 static int wcsbth_jdreff(double *wptr,  const double *jdreff);
 static int wcsbth_epoch(double *wptr,   const double *epoch);
 static int wcsbth_vsource(double *wptr, const double *vsource);
 
-/* Helper functions for keyvalue validity checking. */
+// Helper functions for keyvalue validity checking.
 static int wcsbth_timepixr(double timepixr);
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
-jmp_buf wcsbth_abort_jmp_env;
-#define exit(status) longjmp(wcsbth_abort_jmp_env, status)
-
 %}
 
 %%
-	/* Keyword indices, as used in the WCS papers, e.g. iVn_ma, TPn_ka. */
-	char a;
-	int  i, j, k, m, n;
-	
-	char *cptr, *errmsg, errtxt[80], exclude[1000], gotone, *hptr, *keep,
-	     *keyname, *keyrec, ptype, strtmp[80];
-	int  altlin, auxprm, ialt, icol, incl, imherit, inttmp, ipass, ipx,
-	     itmp, ix, jx, keytype, naux, nother, nsel, npass, nvalid, status,
-	     valtype;
-	ptrdiff_t voff;
-	size_t iz;
+	char *errmsg, errtxt[80], *keyname, strtmp[80];
+	int  auxprm, inttmp;
 	double dbltmp, dbl2tmp[2];
-	void   *vptr, *wptr;
-	struct wcsbth_alts alts;
-	struct auxprm *auxp, auxtem;
-	struct wcsprm *wcsp, wcstem;
-	int (*chekval)(double);
-	int (*special)(double *, const double *);
+	struct auxprm auxtem;
+	struct wcsprm wcstem;
 	
-	/* The data structures produced. */
+	// Initialize returned values.
+	*nreject = 0;
 	*nwcs = 0;
 	*wcs  = 0x0;
 	
-	/* Parameters used to implement YY_INPUT. */
-	wcsbth_hdr = header;
-	wcsbth_nkeyrec = nkeyrec;
-	
-	/* Our handle on the input stream. */
-	keyrec = header;
-	hptr = header;
-	keep = 0x0;
+	// Our handle on the input stream.
+	char *keyrec = header;
+	char *hptr = header;
+	char *keep = 0x0;
+	
+	// For keeping tallies of keywords found.
+	int nvalid = 0;
+	int nother = 0;
 	
-	/* For keeping tallies of keywords found. */
-	*nreject = 0;
-	nvalid = 0;
-	nother = 0;
+	// Used to flag image header keywords that are always inherited.
+	int imherit = 1;
 	
-	/* Used to flag image header keywords that are always inherited. */
-	imherit = 1;
-	
-	/* If strict, then also reject. */
+	// If strict, then also reject.
 	if (relax & WCSHDR_strict) relax |= WCSHDR_reject;
 	
-	/* Keyword parameters. */
-	i = j = 0;
-	n = k = 0;
-	m = 0;
-	a = ' ';
+	// Keyword indices, as used in the WCS papers, e.g. iVn_ma, TPn_ka.
+	int i = 0;
+	int j = 0;
+	int k = 0;
+	int n = 0;
+	int m = 0;
+	char a = ' ';
 	
-	/* Header bookkeeping. */
+	// Header bookkeeping.
+	struct wcsbth_alts alts;
 	alts.ncol = 0;
 	alts.arridx  = 0x0;
 	alts.pixlist = 0x0;
 	alts.npv = 0x0;
 	alts.nps = 0x0;
 	
-	for (ialt = 0; ialt < 27; ialt++) {
+	for (int ialt = 0; ialt < 27; ialt++) {
 	  alts.pixidx[ialt] = 0;
 	  alts.pixnpv[ialt] = 0;
 	  alts.pixnps[ialt] = 0;
 	}
 	
-	/* For decoding the keyvalue. */
-	keytype =  0;
-	valtype = -1;
-	vptr    = 0x0;
-	
-	/* For keywords that require special handling. */
-	altlin  = 0;
-	ptype   = ' ';
-	chekval = 0x0;
-	special = 0x0;
-	auxprm  = 0;
-	naux    = 0;
-	
-	/* Selection by column number. */
-	nsel = colsel ? colsel[0] : 0;
-	incl = (nsel > 0);
-	for (icol = 0; icol < 1000; icol++) {
+	// For decoding the keyvalue.
+	int keytype =  0;
+	int valtype = -1;
+	void *vptr  = 0x0;
+	
+	// For keywords that require special handling.
+	int altlin  = 0;
+	char ptype  = ' ';
+	int (*chekval)(double) = 0x0;
+	int (*special)(double *, const double *) = 0x0;
+	struct auxprm *auxp = 0x0;
+	int naux = 0;
+	
+	// Selection by column number.
+	int nsel = colsel ? colsel[0] : 0;
+	int incl = (nsel > 0);
+	char exclude[1000];
+	for (int icol = 0; icol < 1000; icol++) {
 	  exclude[icol] = incl;
 	}
-	for (icol = 1; icol <= abs(nsel); icol++) {
-	  itmp = colsel[icol];
+	for (int icol = 1; icol <= abs(nsel); icol++) {
+	  int itmp = colsel[icol];
 	  if (0 < itmp && itmp < 1000) {
 	    exclude[itmp] = !incl;
 	  }
 	}
 	exclude[0] = 0;
 	
-	/* Selection by keyword type. */
-	itmp = keysel;
-	keysel = 0;
-	if (itmp) {
+	// Selection by keyword type.
+	if (keysel) {
+	  int itmp = keysel;
+	  keysel = 0;
 	  if (itmp & WCSHDR_IMGHEAD) keysel |= IMGHEAD;
 	  if (itmp & WCSHDR_BIMGARR) keysel |= BIMGARR;
 	  if (itmp & WCSHDR_PIXLIST) keysel |= PIXLIST;
@@ -350,13 +308,17 @@ jmp_buf wcsbth_abort_jmp_env;
 	  keysel = IMGHEAD | BINTAB;
 	}
 	
-	/* Control variables. */
-	ipass = 1;
-	npass = 2;
-	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
-	if (setjmp(wcsbth_abort_jmp_env)) {
-	  return 4;
+	// Control variables.
+	int ipass = 1;
+	int npass = 2;
+	
+	// User data associated with yyscanner.
+	yyextra->hdr = header;
+	yyextra->nkeyrec = nkeyrec;
+	
+	// Return here via longjmp() invoked by yy_fatal_error().
+	if (setjmp(yyextra->abort_jmp_env)) {
+	  return WCSHDRERR_PARSER;
 	}
 	
 	BEGIN(INITIAL);
@@ -379,7 +341,7 @@ jmp_buf wcsbth_abort_jmp_env;
 
 ^WCSAXES{ALT}=" "" "*{INTEGER} {
 	  if (!(keysel & IMGAXIS)) {
-	    /* Ignore this key type. */
+	    // Ignore this key type.
 	    BEGIN(DISCARD);
 	
 	  } else {
@@ -404,7 +366,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	  }
@@ -415,12 +377,12 @@ jmp_buf wcsbth_abort_jmp_env;
 ^WCAX{I3}{ALT}"= "" "*{INTEGER} {
 	  keyname = "WCAXna";
 	
-	  /* Note that a blank in the sscanf() format string matches zero or
-	     more of them in the input. */
+	  // Note that a blank in the sscanf() format string matches zero or
+	  // more of them in the input.
 	  sscanf(yytext, "WCAX%d%c = %d", &n, &a, &i);
 	
 	  if (!(keysel & BIMGARR) || exclude[n]) {
-	    /* Ignore this key type or column. */
+	    // Ignore this key type or column.
 	    BEGIN(DISCARD);
 	
 	  } else if (i < 0) {
@@ -440,7 +402,7 @@ jmp_buf wcsbth_abort_jmp_env;
 ^WCST{I1}{ALT}"  = "" "*{STRING} |
 ^WCST{I2}{ALT}" = "" "*{STRING} |
 ^WCST{I3}{ALT}"= "" "*{STRING} {
-	  /* Cross-reference supplier. */
+	  // Cross-reference supplier.
 	  keyname = "WCSTna";
 	  errmsg = "cross-references are not implemented";
 	  BEGIN(ERROR);
@@ -449,7 +411,7 @@ jmp_buf wcsbth_abort_jmp_env;
 ^WCSX{I1}{ALT}"  = "" "*{STRING} |
 ^WCSX{I2}{ALT}" = "" "*{STRING} |
 ^WCSX{I3}{ALT}"= "" "*{STRING} {
-	  /* Cross-reference consumer. */
+	  // Cross-reference consumer.
 	  keyname = "WCSXna";
 	  errmsg = "cross-references are not implemented";
 	  BEGIN(ERROR);
@@ -1247,7 +1209,7 @@ jmp_buf wcsbth_abort_jmp_env;
 ^MJDREFI" " |
 ^MJD-REFI {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	
@@ -1303,7 +1265,7 @@ jmp_buf wcsbth_abort_jmp_env;
 ^JDREFI"  " |
 ^JD-REFI {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	    special = wcsbth_jdrefi;
@@ -1850,7 +1812,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1944,8 +1906,8 @@ jmp_buf wcsbth_abort_jmp_env;
 	}
 
 ^END" "{77} {
-	  if (wcsbth_nkeyrec) {
-	    wcsbth_nkeyrec = 0;
+	  if (yyextra->nkeyrec) {
+	    yyextra->nkeyrec = 0;
 	    errmsg = "keyrecords following the END keyrecord were ignored";
 	    BEGIN(ERROR);
 	  } else {
@@ -1971,7 +1933,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1980,13 +1942,13 @@ jmp_buf wcsbth_abort_jmp_env;
 <CCCCCia>00{I1} {
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (relax & WCSHDR_reject) {
-	      /* Violates the basic FITS standard. */
+	      // Violates the basic FITS standard.
 	      errmsg = "indices in parameterized keywords must not have "
 	               "leading zeroes";
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -1997,7 +1959,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2005,8 +1967,8 @@ jmp_buf wcsbth_abort_jmp_env;
 <CCCCCia>0{ALT}" " |
 <CCCCCia>00{ALT} |
 <CCCCCia>{Z3} {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  if (relax & WCSHDR_ALLIMG) {
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
@@ -2018,21 +1980,21 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 
 <CCCCCia>. {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "keyword looks very much like %s but isn't",
 	      keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2076,7 +2038,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2119,7 +2081,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2158,7 +2120,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -2169,7 +2131,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2184,8 +2146,8 @@ jmp_buf wcsbth_abort_jmp_env;
 <CCi_ja>{Z3}_{Z2} |
 <CCi_ja>{Z2}_{Z3} |
 <CCi_ja>{Z1}_{Z4} {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  if (relax & WCSHDR_ALLIMG) {
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
@@ -2197,7 +2159,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2225,13 +2187,13 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 
 <CCi_ja>{Z1}{6} {
-	  /* This covers the defunct forms CD00i00j and PC00i00j. */
+	  // This covers the defunct forms CD00i00j and PC00i00j.
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (((altlin == 1) && (relax & WCSHDR_PC00i00j)) ||
 	        ((altlin == 2) && (relax & WCSHDR_CD00i00j))) {
@@ -2248,7 +2210,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -2259,7 +2221,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2292,7 +2254,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2350,7 +2312,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -2361,7 +2323,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2371,7 +2333,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    yyless(0);
 	    BEGIN(CCCCCia);
 	  } else {
-	    /* Let it go. */
+	    // Let it go.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2401,7 +2363,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2413,7 +2375,7 @@ jmp_buf wcsbth_abort_jmp_env;
 
 <CCCCCCCa>{ALT} |
 <CCCCCCCC>. {
-	  /* Image-header keyword. */
+	  // Image-header keyword.
 	  if (imherit || (relax & (WCSHDR_AUXIMG | WCSHDR_ALLIMG))) {
 	    if (YY_START == CCCCCCCa) {
 	      sscanf(yytext, "%c", &a);
@@ -2431,21 +2393,21 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 
 <CCCCCCCa>. {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "invalid alternate code, keyword resembles %s "
 	      "but isn't", keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2494,7 +2456,7 @@ jmp_buf wcsbth_abort_jmp_env;
 <CCi_ma>{I1}_{I2}{ALT}" " |
 <CCi_ma>{I2}_{Z1}{ALT}" " |
 <CCi_ma>{I2}_{I2}{ALT} {
-	  /* Image-header keyword. */
+	  // Image-header keyword.
 	  if (relax & WCSHDR_ALLIMG) {
 	    sscanf(yytext, "%d_%d%c", &i, &m, &a);
 	    keytype = IMGAXIS;
@@ -2507,7 +2469,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2546,7 +2508,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -2557,7 +2519,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2573,8 +2535,8 @@ jmp_buf wcsbth_abort_jmp_env;
 <CCi_ma>{Z2}_{Z3} |
 <CCi_ma>{Z1}_{Z4} {
 	  if (relax & WCSHDR_ALLIMG) {
-	    /* Anything that has fallen through to this point must contain */
-	    /* an invalid parameter. */
+	    // Anything that has fallen through to this point must contain
+	    // an invalid parameter.
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
 	
@@ -2585,7 +2547,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2632,7 +2594,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2668,7 +2630,7 @@ jmp_buf wcsbth_abort_jmp_env;
 <TCn_ma>{I2}_{I3} |
 <TCn_ma>{I3}_{I2} |
 <TCn_ma>{I4}_{Z1} {
-	  /* Invalid combinations will be flagged by <VALUE>. */
+	  // Invalid combinations will be flagged by <VALUE>.
 	  sscanf(yytext, "%d_%d", &n, &m);
 	  a = ' ';
 	  if (YY_START == TCn_ma) i = wcsbth_colax(*wcs, &alts, n, a);
@@ -2694,7 +2656,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2715,17 +2677,17 @@ jmp_buf wcsbth_abort_jmp_env;
 	}
 
 <VALUE>=" "+ {
-	  /* Do checks on i, j, m, n, k. */
+	  // Do checks on i, j, m, n, k.
 	  if (!(keytype & keysel)) {
-	    /* Selection by keyword type. */
+	    // Selection by keyword type.
 	    BEGIN(DISCARD);
 	
 	  } else if (exclude[n] || exclude[k]) {
-	    /* One or other column is not selected. */
+	    // One or other column is not selected.
 	    if (k && (exclude[n] != exclude[k])) {
-	      /* For keywords such as TCn_ka, both columns must be excluded.
-	         User error, so return immediately. */
-	      return 3;
+	      // For keywords such as TCn_ka, both columns must be excluded.
+	      // User error, so return immediately.
+	      return WCSHDRERR_BAD_COLUMN;
 	
 	    } else {
 	      BEGIN(DISCARD);
@@ -2744,18 +2706,18 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
 	  } else if (ipass == 2 && npass == 3 && (keytype & BINTAB)) {
-	    /* Skip keyvalues that won't be inherited. */
+	    // Skip keyvalues that won't be inherited.
 	    BEGIN(FLUSH);
 	
 	  } else {
 	    if (ipass == 3 && (keytype & IMGHEAD)) {
-	      /* IMGHEAD keytypes are always dealt with on the second pass. */
-	      /* However, they must be re-parsed in order to report errors. */
+	      // IMGHEAD keytypes are always dealt with on the second pass.
+	      // However, they must be re-parsed in order to report errors.
 	      vptr = 0x0;
 	    }
 	
@@ -2786,7 +2748,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    sscanf(yytext, "%d", &inttmp);
 	
 	    BEGIN(COMMENT);
@@ -2803,7 +2765,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    wcsutil_str2double(yytext, &dbltmp);
 	
 	    if (chekval && chekval(dbltmp)) {
@@ -2825,7 +2787,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue as integer and fractional parts. */
+	    // Read the keyvalue as integer and fractional parts.
 	    wcsutil_str2double2(yytext, dbl2tmp);
 	
 	    BEGIN(COMMENT);
@@ -2842,12 +2804,12 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
-	      strcpy(strtmp, yytext+1);
+	    // Read the keyvalue.
+	    strcpy(strtmp, yytext+1);
 	
-	    /* Squeeze out repeated quotes. */
-	    ix = 0;
-	    for (jx = 0; jx < 72; jx++) {
+	    // Squeeze out repeated quotes.
+	    int ix = 0;
+	    for (int jx = 0; jx < 72; jx++) {
 	      if (ix < jx) {
 	        strtmp[ix] = strtmp[jx];
 	      }
@@ -2873,29 +2835,31 @@ jmp_buf wcsbth_abort_jmp_env;
 
 <COMMENT>{INLINE}$ {
 	  if (ipass == 1) {
-	    /* Do first-pass bookkeeping. */
+	    // Do first-pass bookkeeping.
 	    wcsbth_pass1(keytype, i, j, n, k, a, ptype, &alts);
 	    BEGIN(FLUSH);
 	
 	  } else if (*wcs) {
-	    /* Store the value now that the keyrecord has been validated. */
+	    // Store the value now that the keyrecord has been validated.
 	    alts.icol = 0;
 	    alts.ialt = 0;
 	
-	    /* Update each coordinate representation. */
-	    gotone = 0;
+	    // Update each coordinate representation.
+	    int gotone = 0;
+	    struct wcsprm *wcsp;
 	    while ((wcsp = wcsbth_idx(*wcs, &alts, keytype, n, a))) {
 	      gotone = 1;
 	
 	      if (vptr) {
+	        void *wptr;
 	        if (auxprm) {
-	          /* Additional auxiliary parameter. */
+	          // Additional auxiliary parameter.
 	          auxp = wcsp->aux;
-	          voff = (char *)vptr - (char *)(&auxtem);
+	          ptrdiff_t voff = (char *)vptr - (char *)(&auxtem);
 	          wptr = (void *)((char *)auxp + voff);
 	        } else {
-	          /* A parameter that lives directly in wcsprm. */
-	          voff = (char *)vptr - (char *)(&wcstem);
+	          // A parameter that lives directly in wcsprm.
+	          ptrdiff_t voff = (char *)vptr - (char *)(&wcstem);
 	          wptr = (void *)((char *)wcsp + voff);
 	        }
 	
@@ -2903,9 +2867,9 @@ jmp_buf wcsbth_abort_jmp_env;
 	          *((int *)wptr) = inttmp;
 	
 	        } else if (valtype == FLOAT) {
-	          /* Apply keyword parameterization. */
+	          // Apply keyword parameterization.
 	          if (ptype == 'v') {
-	            ipx = (wcsp->npv)++;
+	            int ipx = (wcsp->npv)++;
 	            wcsp->pv[ipx].i = i;
 	            wcsp->pv[ipx].m = m;
 	            wptr = &(wcsp->pv[ipx].value);
@@ -2924,14 +2888,14 @@ jmp_buf wcsbth_abort_jmp_env;
 	            *((double *)wptr) = dbltmp;
 	          }
 	
-	          /* Flag the presence of PCi_ja, or CDi_ja and/or CROTAia. */
+	          // Flag the presence of PCi_ja, or CDi_ja and/or CROTAia.
 	          if (altlin) {
 	            wcsp->altlin |= altlin;
 	            altlin = 0;
 	          }
 	
 	          } else if (valtype == FLOAT2) {
-	            /* Split MJDREF and JDREF into integer and fraction.*/
+	            // Split MJDREF and JDREF into integer and fraction.
 	            if (special) {
 	              special(wptr, dbl2tmp);
 	            } else {
@@ -2940,9 +2904,9 @@ jmp_buf wcsbth_abort_jmp_env;
 	            }
 	
 	        } else if (valtype == STRING) {
-	          /* Apply keyword parameterization. */
+	          // Apply keyword parameterization.
 	          if (ptype == 's') {
-	            ipx = wcsp->nps++;
+	            int ipx = wcsp->nps++;
 	            wcsp->ps[ipx].i = i;
 	            wcsp->ps[ipx].m = m;
 	            wptr = wcsp->ps[ipx].value;
@@ -2955,7 +2919,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	            wptr = *((char (**)[72])wptr) + (i - 1);
 	          }
 	
-	          cptr = (char *)wptr;
+	          char *cptr = (char *)wptr;
 	          strcpy(cptr, strtmp);
 	        }
 	      }
@@ -3009,7 +2973,7 @@ jmp_buf wcsbth_abort_jmp_env;
 <DISCARD>.*$ {
 	  if (ipass == npass) {
 	    if (ctrl < 0) {
-	      /* Preserve discards. */
+	      // Preserve discards.
 	      keep = keyrec;
 	
 	    } else if (2 < ctrl) {
@@ -3047,7 +3011,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	
 	  naux += auxprm;
 	
-	  /* Throw away the rest of the line and reset for the next one. */
+	  // Throw away the rest of the line and reset for the next one.
 	  i = j = 0;
 	  n = k = 0;
 	  m = 0;
@@ -3069,8 +3033,9 @@ jmp_buf wcsbth_abort_jmp_env;
 	}
 
 <<EOF>>	 {
-	  /* End-of-input. */
+	  // End-of-input.
 	  if (ipass == 1) {
+	    int status;
 	    if ((status = wcsbth_init1(&alts, naux, nwcs, wcs)) ||
 	        (*nwcs == 0 && ctrl == 0)) {
 	      return status;
@@ -3091,8 +3056,8 @@ jmp_buf wcsbth_abort_jmp_env;
 	  }
 	
 	  if (ipass++ < npass) {
-	    wcsbth_hdr = header;
-	    wcsbth_nkeyrec = nkeyrec;
+	    yyextra->hdr = header;
+	    yyextra->nkeyrec = nkeyrec;
 	    keyrec = header;
 	    *nreject = 0;
 	
@@ -3139,6 +3104,36 @@ jmp_buf wcsbth_abort_jmp_env;
 %%
 
 /*----------------------------------------------------------------------------
+* External interface to the scanner.
+*---------------------------------------------------------------------------*/
+
+int wcsbth(
+  char *header,
+  int nkeyrec,
+  int relax,
+  int ctrl,
+  int keysel,
+  int *colsel,
+  int *nreject,
+  int *nwcs,
+  struct wcsprm **wcs)
+
+{
+  // Function prototypes.
+  int yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *yyscanner);
+  int yylex_destroy(yyscan_t yyscanner);
+
+  struct wcsbth_extra extra;
+  yyscan_t yyscanner;
+  yylex_init_extra(&extra, &yyscanner);
+  int status = wcsbth_scanner(header, nkeyrec, relax, ctrl, keysel, colsel,
+                              nreject, nwcs, wcs, yyscanner);
+  yylex_destroy(yyscanner);
+
+  return status;
+}
+
+/*----------------------------------------------------------------------------
 * Perform first-pass tasks:
 *
 * 1) Count the number of coordinate axes in each of the 27 possible alternate
@@ -3175,23 +3170,21 @@ int wcsbth_pass1(
   struct wcsbth_alts *alts)
 
 {
-  int ialt, icol, mask, ncol;
-
   if (a == 0) {
-    /* Keywords such as DATE-OBS go along for the ride. */
+    // Keywords such as DATE-OBS go along for the ride.
     return 0;
   }
 
-  ncol = alts->ncol;
+  int ncol = alts->ncol;
 
-  /* Do we need to allocate memory for alts? */
+  // Do we need to allocate memory for alts?
   if (alts->arridx == 0x0) {
     if (ncol == 0) {
-      /* Can only happen if TFIELDS is missing or out-of-sequence.  If n and
-         k are both zero then we may be processing an image header so leave
-         ncol alone - the array will be realloc'd later if required. */
+      // Can only happen if TFIELDS is missing or out-of-sequence.  If n and
+      // k are both zero then we may be processing an image header so leave
+      // ncol alone - the array will be realloc'd later if required.
       if (n || k) {
-        /* The header is mangled, assume the worst. */
+        // The header is mangled, assume the worst.
         ncol = 999;
       }
     }
@@ -3204,13 +3197,13 @@ int wcsbth_pass1(
       if (alts->npv)     free(alts->npv);
       if (alts->nps)     free(alts->nps);
       if (alts->pixlist) free(alts->pixlist);
-      return 2;
+      return WCSHDRERR_MEMORY;
     }
 
     alts->ncol = ncol;
 
   } else if (n > ncol || k > ncol) {
-    /* Can only happen if TFIELDS or the WCS keyword is wrong; carry on. */
+    // Can only happen if TFIELDS or the WCS keyword is wrong; carry on.
     ncol = 999;
     if (!(alts->arridx  = realloc(alts->arridx,
                                     27*(1 + ncol)*sizeof(short int))) ||
@@ -3224,12 +3217,12 @@ int wcsbth_pass1(
       if (alts->npv)     free(alts->npv);
       if (alts->nps)     free(alts->nps);
       if (alts->pixlist) free(alts->pixlist);
-      return 2;
+      return WCSHDRERR_MEMORY;
     }
 
-    /* Since realloc() doesn't initialize the extra memory. */
-    for (icol = (1 + alts->ncol); icol < (1 + ncol); icol++) {
-      for (ialt = 0; ialt < 27; ialt++) {
+    // Since realloc() doesn't initialize the extra memory.
+    for (int icol = (1 + alts->ncol); icol < (1 + ncol); icol++) {
+      for (int ialt = 0; ialt < 27; ialt++) {
         alts->arridx[icol][ialt] = 0;
         alts->npv[icol][ialt] = 0;
         alts->nps[icol][ialt] = 0;
@@ -3240,23 +3233,23 @@ int wcsbth_pass1(
     alts->ncol = ncol;
   }
 
-  ialt = 0;
+  int ialt = 0;
   if (a != ' ') {
     ialt = a - 'A' + 1;
   }
 
-  /* A BINTAB keytype such as LONPna, in conjunction with an IMGAXIS keytype
-     causes a table column to be recognized as an image array. */
+  // A BINTAB keytype such as LONPna, in conjunction with an IMGAXIS keytype
+  // causes a table column to be recognized as an image array.
   if (keytype & IMGHEAD || keytype & BIMGARR) {
-    /* n == 0 is expected for IMGHEAD keywords. */
+    // n == 0 is expected for IMGHEAD keywords.
     if (i == 0 && j == 0) {
       if (alts->arridx[n][ialt] == 0) {
-        /* Flag that an auxiliary keyword was seen. */
+        // Flag that an auxiliary keyword was seen.
         alts->arridx[n][ialt] = -1;
       }
 
     } else {
-      /* Record the maximum axis number found. */
+      // Record the maximum axis number found.
       if (alts->arridx[n][ialt] < i) {
         alts->arridx[n][ialt] = i;
       }
@@ -3273,17 +3266,17 @@ int wcsbth_pass1(
     }
   }
 
-  /* BINTAB keytypes, which apply both to pixel lists as well as binary table
-     image arrays, never contribute to recognizing a table column as a pixel
-     list axis.  A PIXLIST keytype is required for that. */
+  // BINTAB keytypes, which apply both to pixel lists as well as binary table
+  // image arrays, never contribute to recognizing a table column as a pixel
+  // list axis.  A PIXLIST keytype is required for that.
   if (keytype == PIXLIST) {
-    mask = 1 << ialt;
+    int mask = 1 << ialt;
 
-    /* n > 0 for PIXLIST keytypes. */
+    // n > 0 for PIXLIST keytypes.
     alts->pixlist[n] |= mask;
     if (k) alts->pixlist[k] |= mask;
 
-    /* Used as a flag over all columns. */
+    // Used as a flag over all columns.
     alts->pixlist[0] |= mask;
 
     if (ptype == 'v') {
@@ -3311,22 +3304,20 @@ int wcsbth_init1(
   struct wcsprm **wcs)
 
 {
-  int ialt, icol, inherit[27], ix, mask, ncol, npsmax, npvmax, status = 0;
-  struct wcsprm *wcsp;
-
+  int status = 0;
 
   if (alts->arridx == 0x0) {
     *nwcs = 0;
     return 0;
   }
 
-  /* Determine the number of axes in each pixel list representation. */
-  ncol = alts->ncol;
+  // Determine the number of axes in each pixel list representation.
+  int ialt, mask, ncol = alts->ncol;
   for (ialt = 0, mask = 1; ialt < 27; ialt++, mask <<= 1) {
     alts->pixidx[ialt] = 0;
 
     if (alts->pixlist[0] | mask) {
-      for (icol = 1; icol <= ncol; icol++) {
+      for (int icol = 1; icol <= ncol; icol++) {
         if (alts->pixlist[icol] & mask) {
           alts->pixidx[ialt]++;
         }
@@ -3334,18 +3325,19 @@ int wcsbth_init1(
     }
   }
 
-  /* Find the total number of coordinate representations. */
+  // Find the total number of coordinate representations.
   *nwcs = 0;
   alts->imgherit = 0;
-  for (ialt = 0; ialt < 27; ialt++) {
+  int inherit[27];
+  for (int ialt = 0; ialt < 27; ialt++) {
     inherit[ialt] = 0;
 
-    for (icol = 1; icol <= ncol; icol++) {
+    for (int icol = 1; icol <= ncol; icol++) {
       if (alts->arridx[icol][ialt] < 0) {
-        /* No BIMGARR keytype but there's at least one BINTAB. */
+        // No BIMGARR keytype but there's at least one BINTAB.
         if (alts->arridx[0][ialt] > 0) {
-          /* There is an IMGAXIS keytype that we will inherit, so count this
-             representation. */
+          // There is an IMGAXIS keytype that we will inherit, so count this
+          // representation.
           alts->arridx[icol][ialt] = alts->arridx[0][ialt];
         } else {
           alts->arridx[icol][ialt] = 0;
@@ -3354,11 +3346,11 @@ int wcsbth_init1(
 
       if (alts->arridx[icol][ialt]) {
         if (alts->arridx[0][ialt]) {
-          /* All IMGHEAD keywords are inherited for this ialt. */
+          // All IMGHEAD keywords are inherited for this ialt.
           inherit[ialt] = 1;
 
           if (alts->arridx[icol][ialt] < alts->arridx[0][ialt]) {
-            /* The extra axes are also inherited. */
+            // The extra axes are also inherited.
             alts->arridx[icol][ialt] = alts->arridx[0][ialt];
           }
         }
@@ -3367,10 +3359,10 @@ int wcsbth_init1(
       }
     }
 
-    /* Count every "a" found in any IMGHEAD keyword... */
+    // Count every "a" found in any IMGHEAD keyword...
     if (alts->arridx[0][ialt]) {
       if (inherit[ialt]) {
-        /* ...but not if the IMGHEAD keywords will be inherited. */
+        // ...but not if the IMGHEAD keywords will be inherited.
         alts->arridx[0][ialt] = 0;
         alts->imgherit = 1;
       } else if (alts->arridx[0][ialt] > 0) {
@@ -3378,7 +3370,7 @@ int wcsbth_init1(
       }
     }
 
-    /* We need a struct for every "a" found in a PIXLIST keyword. */
+    // We need a struct for every "a" found in a PIXLIST keyword.
     if (alts->pixidx[ialt]) {
       (*nwcs)++;
     }
@@ -3386,95 +3378,95 @@ int wcsbth_init1(
 
 
   if (*nwcs) {
-    /* Allocate memory for the required number of wcsprm structs. */
+    // Allocate memory for the required number of wcsprm structs.
     if (!(*wcs = calloc(*nwcs, sizeof(struct wcsprm)))) {
-      return 2;
+      return WCSHDRERR_MEMORY;
     }
 
-    /* Initialize each wcsprm struct. */
-    wcsp = *wcs;
+    // Initialize each wcsprm struct.
+    struct wcsprm *wcsp = *wcs;
     *nwcs = 0;
-    for (icol = 0; icol <= ncol; icol++) {
-      for (ialt = 0; ialt < 27; ialt++) {
+    for (int icol = 0; icol <= ncol; icol++) {
+      for (int ialt = 0; ialt < 27; ialt++) {
         if (alts->arridx[icol][ialt] > 0) {
-          /* Image-header representations that are not for inheritance
-             (icol == 0) or binary table image array representations. */
+          // Image-header representations that are not for inheritance
+          // (icol == 0) or binary table image array representations.
           wcsp->flag = -1;
-          npvmax = alts->npv[icol][ialt];
-          npsmax = alts->nps[icol][ialt];
+          int npvmax = alts->npv[icol][ialt];
+          int npsmax = alts->nps[icol][ialt];
           if ((status = wcsinit(1, (int)(alts->arridx[icol][ialt]), wcsp,
                                 npvmax, npsmax, -1))) {
             wcsvfree(nwcs, wcs);
             break;
           }
 
-          /* Record the alternate version code. */
+          // Record the alternate version code.
           if (ialt) {
             wcsp->alt[0] = 'A' + ialt - 1;
           }
 
-          /* Any additional auxiliary keywords present? */
+          // Any additional auxiliary keywords present?
           if (naux) {
             if (wcsauxi(1, wcsp)) {
               return WCSHDRERR_MEMORY;
             }
           }
 
-          /* Record the table column number. */
+          // Record the table column number.
           wcsp->colnum = icol;
 
-          /* On the second pass alts->arridx[icol][27] indexes the array of
-             wcsprm structs. */
+          // On the second pass alts->arridx[icol][27] indexes the array of
+          // wcsprm structs.
           alts->arridx[icol][ialt] = (*nwcs)++;
 
           wcsp++;
 
         } else {
-          /* Signal that this column has no WCS for this "a". */
+          // Signal that this column has no WCS for this "a".
           alts->arridx[icol][ialt] = -1;
         }
       }
     }
 
-    for (ialt = 0; ialt < 27; ialt++) {
+    for (int ialt = 0; ialt < 27; ialt++) {
       if (alts->pixidx[ialt]) {
-        /* Pixel lists representations. */
+        // Pixel lists representations.
         wcsp->flag = -1;
-        npvmax = alts->pixnpv[ialt];
-        npsmax = alts->pixnps[ialt];
+        int npvmax = alts->pixnpv[ialt];
+        int npsmax = alts->pixnps[ialt];
         if ((status = wcsinit(1, (int)(alts->pixidx[ialt]), wcsp, npvmax,
                               npsmax, -1))) {
           wcsvfree(nwcs, wcs);
           break;
         }
 
-        /* Record the alternate version code. */
+        // Record the alternate version code.
         if (ialt) {
           wcsp->alt[0] = 'A' + ialt - 1;
         }
 
-        /* Any additional auxiliary keywords present? */
+        // Any additional auxiliary keywords present?
         if (naux) {
           if (wcsauxi(1, wcsp)) {
             return WCSHDRERR_MEMORY;
           }
         }
 
-        /* Record the pixel list column numbers. */
-        mask = (1 << ialt);
+        // Record the pixel list column numbers.
+        int icol, ix, mask = (1 << ialt);
         for (icol = 1, ix = 0; icol <= ncol; icol++) {
           if (alts->pixlist[icol] & mask) {
             wcsp->colax[ix++] = icol;
           }
         }
 
-        /* alts->pixidx[] indexes the array of wcsprm structs. */
+        // alts->pixidx[] indexes the array of wcsprm structs.
         alts->pixidx[ialt] = (*nwcs)++;
 
         wcsp++;
 
       } else {
-        /* Signal that this column is not a pixel list axis for this "a". */
+        // Signal that this column is not a pixel list axis for this "a".
         alts->pixidx[ialt] = -1;
       }
     }
@@ -3498,28 +3490,27 @@ struct wcsprm *wcsbth_idx(
 
 {
   const char as[] = " ABCDEFGHIJKLMNOPQRSTUVWXYZ";
-  int iwcs;
 
   if (!wcs) return 0x0;
 
-  iwcs = -1;
+  int iwcs = -1;
   for (; iwcs < 0 && alts->ialt < 27; alts->ialt++) {
-    /* Note that a == 0 applies to every alternate, otherwise this
-       loop simply determines the appropriate value of alts->ialt. */
+    // Note that a == 0 applies to every alternate, otherwise this
+    // loop simply determines the appropriate value of alts->ialt.
     if (a && a != as[alts->ialt]) continue;
 
     if (keytype & (IMGHEAD | BIMGARR)) {
       for (; iwcs < 0 && alts->icol <= alts->ncol; alts->icol++) {
-        /* Image header keywords, n == 0, apply to all columns, otherwise this
-           loop simply determines the appropriate value of alts->icol. */
+        // Image header keywords, n == 0, apply to all columns, otherwise this
+        // loop simply determines the appropriate value of alts->icol.
         if (n && n != alts->icol) continue;
         iwcs = alts->arridx[alts->icol][alts->ialt];
       }
 
-      /* Break out of the loop to stop alts->ialt from being incremented. */
+      // Break out of the loop to stop alts->ialt from being incremented.
       if (iwcs >= 0) break;
 
-      /* Start from scratch for the next alts->ialt. */
+      // Start from scratch for the next alts->ialt.
       alts->icol = 0;
     }
 
@@ -3544,17 +3535,14 @@ int wcsbth_colax(
   char a)
 
 {
-  int ix;
-  struct wcsprm *wcsp;
-
   if (!wcs) return 0;
 
-  wcsp = wcs;
+  struct wcsprm *wcsp = wcs;
   if (a != ' ') {
     wcsp += alts->pixidx[a-'A'+1];
   }
 
-  for (ix = 0; ix < wcsp->naxis; ix++) {
+  for (int ix = 0; ix < wcsp->naxis; ix++) {
     if (wcsp->colax[ix] == n) {
       return ++ix;
     }
@@ -3571,7 +3559,7 @@ int wcsbth_colax(
 int wcsbth_jdref(double *mjdref, const double *jdref)
 
 {
-  /* Set MJDREF from JDREF. */
+  // Set MJDREF from JDREF.
   if (undefined(mjdref[0] && undefined(mjdref[1]))) {
     mjdref[0] = jdref[0] - 2400000.0;
     mjdref[1] = jdref[1] - 0.5;
@@ -3588,7 +3576,7 @@ int wcsbth_jdref(double *mjdref, const d
 int wcsbth_jdrefi(double *mjdref, const double *jdrefi)
 
 {
-  /* Set the integer part of MJDREF from JDREFI. */
+  // Set the integer part of MJDREF from JDREFI.
   if (undefined(mjdref[0])) {
     mjdref[0] = *jdrefi - 2400000.5;
   }
@@ -3600,7 +3588,7 @@ int wcsbth_jdrefi(double *mjdref, const
 int wcsbth_jdreff(double *mjdref, const double *jdreff)
 
 {
-  /* Set the fractional part of MJDREF from JDREFF. */
+  // Set the fractional part of MJDREF from JDREFF.
   if (undefined(mjdref[1])) {
     mjdref[1] = *jdreff;
   }
@@ -3616,7 +3604,7 @@ int wcsbth_jdreff(double *mjdref, const
 int wcsbth_epoch(double *equinox, const double *epoch)
 
 {
-  /* If EQUINOXa is currently undefined then set it from EPOCHa. */
+  // If EQUINOXa is currently undefined then set it from EPOCHa.
   if (undefined(*equinox)) {
     *equinox = *epoch;
   }
@@ -3632,12 +3620,12 @@ int wcsbth_epoch(double *equinox, const
 int wcsbth_vsource(double *zsource, const double *vsource)
 
 {
-  double beta, c = 299792458.0;
+  const double c = 299792458.0;
 
-  /* If ZSOURCEa is currently undefined then set it from VSOURCEa. */
+  // If ZSOURCEa is currently undefined then set it from VSOURCEa.
   if (undefined(*zsource)) {
-    /* Convert relativistic Doppler velocity to redshift. */
-    beta = *vsource/c;
+    // Convert relativistic Doppler velocity to redshift.
+    double beta = *vsource/c;
     *zsource = (1.0 + beta)/sqrt(1.0 - beta*beta) - 1.0;
   }
 
@@ -3666,15 +3654,14 @@ int wcsbth_final(
   struct wcsprm **wcs)
 
 {
-  int ialt, status;
-
   if (alts->arridx)  free(alts->arridx);
   if (alts->npv)     free(alts->npv);
   if (alts->nps)     free(alts->nps);
   if (alts->pixlist) free(alts->pixlist);
 
-  for (ialt = 0; ialt < *nwcs; ialt++) {
-    /* Interpret -TAB header keywords. */
+  for (int ialt = 0; ialt < *nwcs; ialt++) {
+    // Interpret -TAB header keywords.
+    int status;
     if ((status = wcstab(*wcs+ialt))) {
        wcsvfree(nwcs, wcs);
        return status;
Index: astropy-4.2.1/cextern/wcslib/C/wcserr.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcserr.c
+++ astropy-4.2.1/cextern/wcslib/C/wcserr.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,12 +17,10 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   Module author: Michael Droettboom
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcserr.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcserr.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <stdarg.h>
@@ -36,7 +33,7 @@
 
 static int wcserr_enabled = 0;
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcserr_enable(int enable)
 
@@ -44,7 +41,30 @@ int wcserr_enable(int enable)
   return wcserr_enabled = (enable ? 1 : 0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
+
+int wcserr_size(const struct wcserr *err, int sizes[2])
+
+{
+  if (err == 0x0) {
+    sizes[0] = sizes[1] = 0;
+    return 0;
+  }
+
+  // Base size, in bytes.
+  sizes[0] = sizeof(struct wcserr);
+
+  // Total size of allocated memory, in bytes.
+  sizes[1] = 0;
+
+  if (err->msg) {
+    sizes[1] += strlen(err->msg) + 1;
+  }
+
+  return 0;
+}
+
+//----------------------------------------------------------------------------
 
 int wcserr_prt(const struct wcserr *err, const char *prefix)
 
@@ -66,7 +86,7 @@ int wcserr_prt(const struct wcserr *err,
         prefix, err->status, err->function, err->line_no, err->file, prefix,
         err->msg);
     } else {
-      /* An informative message only. */
+      // An informative message only.
       wcsprintf("%sINFORMATIVE message from %s() at line %d of file "
         "%s:\n%s%s.\n", prefix, err->function, err->line_no, err->file,
         prefix, err->msg);
@@ -76,7 +96,7 @@ int wcserr_prt(const struct wcserr *err,
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcserr_clear(struct wcserr **errp)
 
@@ -92,7 +112,7 @@ int wcserr_clear(struct wcserr **errp)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcserr_set(
   struct wcserr **errp,
@@ -130,7 +150,7 @@ int wcserr_set(
     err->line_no  = line_no;
     err->msg      = 0x0;
 
-    /* Determine the required message buffer size. */
+    // Determine the required message buffer size.
     va_start(argp, format);
     msglen = vsnprintf(0x0, 0, format, argp) + 1;
     va_end(argp);
@@ -140,7 +160,7 @@ int wcserr_set(
       return status;
     }
 
-    /* Write the message. */
+    // Write the message.
     va_start(argp, format);
     msglen = vsnprintf(err->msg, msglen, format, argp);
     va_end(argp);
@@ -153,7 +173,7 @@ int wcserr_set(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcserr_copy(const struct wcserr *src, struct wcserr *dst)
 
Index: astropy-4.2.1/cextern/wcslib/C/wcserr.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcserr.h
+++ astropy-4.2.1/cextern/wcslib/C/wcserr.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,15 +17,13 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   Module author: Michael Droettboom
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcserr.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcserr.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -34,7 +31,7 @@
 * ------------------------------
 * Most of the structs in WCSLIB contain a pointer to a wcserr struct as a
 * member.  Functions in WCSLIB that return an error status code can also
-* allocate and set a detailed error message in this struct which also
+* allocate and set a detailed error message in this struct, which also
 * identifies the function, source file, and line number where the error
 * occurred.
 *
@@ -97,6 +94,29 @@
 *                         1: Error messaging is enabled.
 *
 *
+* wcserr_size() - Compute the size of a wcserr struct
+* ---------------------------------------------------
+* wcserr_size() computes the full size of a wcserr struct, including allocated
+* memory.
+*
+* Given:
+*   err       const struct wcserr*
+*                       The error object.
+*
+*                       If NULL, the base size of the struct and the allocated
+*                       size are both set to zero.
+*
+* Returned:
+*   sizes     int[2]    The first element is the base size of the struct as
+*                       returned by sizeof(struct wcserr).  The second element
+*                       is the total allocated size of the message buffer, in
+*                       bytes.
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*
+*
 * wcserr_prt() - Print a wcserr struct
 * ------------------------------------
 * wcserr_prt() prints the error message (if any) contained in a wcserr struct.
@@ -221,35 +241,37 @@ extern "C" {
 #endif
 
 struct wcserr {
-  int  status;			/* Status code for the error.               */
-  int  line_no;			/* Line number where the error occurred.    */
-  const char *function;		/* Function name.                           */
-  const char *file;		/* Source file name.                        */
-  char *msg;			/* Informative error message.               */
+  int  status;			// Status code for the error.
+  int  line_no;			// Line number where the error occurred.
+  const char *function;		// Function name.
+  const char *file;		// Source file name.
+  char *msg;			// Informative error message.
 };
 
-/* Size of the wcserr struct in int units, used by the Fortran wrappers. */
+// Size of the wcserr struct in int units, used by the Fortran wrappers.
 #define ERRLEN (sizeof(struct wcserr)/sizeof(int))
 
 int wcserr_enable(int enable);
 
+int wcserr_size(const struct wcserr *err, int sizes[2]);
+
 int wcserr_prt(const struct wcserr *err, const char *prefix);
 
 int wcserr_clear(struct wcserr **err);
 
 
-/* INTERNAL USE ONLY -------------------------------------------------------*/
+// INTERNAL USE ONLY -------------------------------------------------------
 
 int wcserr_set(struct wcserr **err, int status, const char *function,
   const char *file, int line_no, const char *format, ...);
 
 int wcserr_copy(const struct wcserr *src, struct wcserr *dst);
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define WCSERR_SET(status) err, status, function, __FILE__, __LINE__
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* WSCLIB_WCSERR */
+#endif // WSCLIB_WCSERR
Index: astropy-4.2.1/cextern/wcslib/C/wcsfix.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsfix.c
+++ astropy-4.2.1/cextern/wcslib/C/wcsfix.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsfix.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsfix.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -30,22 +27,24 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "wcserr.h"
-#include "wcsmath.h"
-#include "wcstrig.h"
-#include "wcsutil.h"
 #include "lin.h"
 #include "sph.h"
+#include "tab.h"
 #include "wcs.h"
-#include "wcsunits.h"
+#include "wcserr.h"
 #include "wcsfix.h"
+#include "wcsmath.h"
+#include "wcstrig.h"
+#include "wcsunits.h"
+#include "wcsutil.h"
+#include "wtbarr.h"
 
 extern const int WCSSET;
 
-/* Maximum number of coordinate axes that can be handled. */
+// Maximum number of coordinate axes that can be handled.
 #define NMAX 16
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *wcsfix_errmsg[] = {
   "Success",
   "Null wcsprm pointer passed",
@@ -59,36 +58,36 @@ const char *wcsfix_errmsg[] = {
   "Could not determine reference pixel coordinate",
   "Could not determine reference pixel value"};
 
-/* Map error returns for lower-level routines. */
+// Map error returns for lower-level routines.
 const int fix_linerr[] = {
-  FIXERR_SUCCESS,		/*  0: LINERR_SUCCESS         */
-  FIXERR_NULL_POINTER,		/*  1: LINERR_NULL_POINTER    */
-  FIXERR_MEMORY,		/*  2: LINERR_MEMORY          */
-  FIXERR_SINGULAR_MTX,		/*  3: LINERR_SINGULAR_MTX    */
-  FIXERR_BAD_PARAM,		/*  4: LINERR_DISTORT_INIT    */
-  FIXERR_NO_REF_PIX_COORD,	/*  5: LINERR_DISTORT         */
-  FIXERR_NO_REF_PIX_VAL		/*  6: LINERR_DEDISTORT       */
+  FIXERR_SUCCESS,		//  0: LINERR_SUCCESS
+  FIXERR_NULL_POINTER,		//  1: LINERR_NULL_POINTER
+  FIXERR_MEMORY,		//  2: LINERR_MEMORY
+  FIXERR_SINGULAR_MTX,		//  3: LINERR_SINGULAR_MTX
+  FIXERR_BAD_PARAM,		//  4: LINERR_DISTORT_INIT
+  FIXERR_NO_REF_PIX_COORD,	//  5: LINERR_DISTORT
+  FIXERR_NO_REF_PIX_VAL		//  6: LINERR_DEDISTORT
 };
 
 const int fix_wcserr[] = {
-  FIXERR_SUCCESS,		/*  0: WCSERR_SUCCESS         */
-  FIXERR_NULL_POINTER,		/*  1: WCSERR_NULL_POINTER    */
-  FIXERR_MEMORY,		/*  2: WCSERR_MEMORY          */
-  FIXERR_SINGULAR_MTX,		/*  3: WCSERR_SINGULAR_MTX    */
-  FIXERR_BAD_CTYPE,		/*  4: WCSERR_BAD_CTYPE       */
-  FIXERR_BAD_PARAM,		/*  5: WCSERR_BAD_PARAM       */
-  FIXERR_BAD_COORD_TRANS,	/*  6: WCSERR_BAD_COORD_TRANS */
-  FIXERR_ILL_COORD_TRANS,	/*  7: WCSERR_ILL_COORD_TRANS */
-  FIXERR_BAD_CORNER_PIX,	/*  8: WCSERR_BAD_PIX         */
-  FIXERR_NO_REF_PIX_VAL,	/*  9: WCSERR_BAD_WORLD       */
-  FIXERR_NO_REF_PIX_VAL 	/* 10: WCSERR_BAD_WORLD_COORD */
-				/*     ...others not used     */
+  FIXERR_SUCCESS,		//  0: WCSERR_SUCCESS
+  FIXERR_NULL_POINTER,		//  1: WCSERR_NULL_POINTER
+  FIXERR_MEMORY,		//  2: WCSERR_MEMORY
+  FIXERR_SINGULAR_MTX,		//  3: WCSERR_SINGULAR_MTX
+  FIXERR_BAD_CTYPE,		//  4: WCSERR_BAD_CTYPE
+  FIXERR_BAD_PARAM,		//  5: WCSERR_BAD_PARAM
+  FIXERR_BAD_COORD_TRANS,	//  6: WCSERR_BAD_COORD_TRANS
+  FIXERR_ILL_COORD_TRANS,	//  7: WCSERR_ILL_COORD_TRANS
+  FIXERR_BAD_CORNER_PIX,	//  8: WCSERR_BAD_PIX
+  FIXERR_NO_REF_PIX_VAL,	//  9: WCSERR_BAD_WORLD
+  FIXERR_NO_REF_PIX_VAL 	// 10: WCSERR_BAD_WORLD_COORD
+				//     ...others not used
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define WCSFIX_ERRMSG(status) WCSERR_SET(status), wcsfix_errmsg[status]
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsfix(int ctrl, const int naxis[], struct wcsprm *wcs, int stat[])
 
@@ -126,7 +125,7 @@ int wcsfix(int ctrl, const int naxis[],
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsfixi(
   int ctrl,
@@ -136,23 +135,23 @@ int wcsfixi(
   struct wcserr info[])
 
 {
-  int ifix, status = 0;
-  struct wcserr err;
+  int status = 0;
 
-  /* Handling the status values returned from the sub-fixers is trickier than
-  it might seem, especially considering that wcs->err may contain an error
-  status on input which should be preserved if no translation errors occur.
-  The simplest way seems to be to save a copy of wcs->err and clear it before
-  each sub-fixer.  The last real error to occur, excluding informative
-  messages, is the one returned.
-
-  To get informative messages from spcfix() it must precede celfix() and
-  cylfix().  The latter call wcsset() which also translates AIPS-convention
-  spectral axes. */
+  // Handling the status values returned from the sub-fixers is trickier than
+  // it might seem, especially considering that wcs->err may contain an error
+  // status on input which should be preserved if no translation errors occur.
+  // The simplest way seems to be to save a copy of wcs->err and clear it
+  // before each sub-fixer.  The last real error to occur, excluding
+  // informative messages, is the one returned.
+
+  // To get informative messages from spcfix() it must precede celfix() and
+  // cylfix().  The latter call wcsset() which also translates AIPS-convention
+  // spectral axes.
+  struct wcserr err;
   wcserr_copy(wcs->err, &err);
 
-  for (ifix = CDFIX; ifix < NWCSFIX; ifix++) {
-    /* Clear (delete) wcs->err. */
+  for (int ifix = CDFIX; ifix < NWCSFIX; ifix++) {
+    // Clear (delete) wcs->err.
     wcserr_clear(&(wcs->err));
 
     switch (ifix) {
@@ -182,11 +181,11 @@ int wcsfixi(
     }
 
     if (stat[ifix] == FIXERR_NO_CHANGE) {
-      /* No change => no message. */
+      // No change => no message.
       wcserr_copy(0x0, info+ifix);
 
     } else if (stat[ifix] == 0) {
-      /* Successful translation, but there may be an informative message. */
+      // Successful translation, but there may be an informative message.
       if (wcs->err && wcs->err->status < 0) {
         wcserr_copy(wcs->err, info+ifix);
       } else {
@@ -194,17 +193,17 @@ int wcsfixi(
       }
 
     } else {
-      /* An informative message or error message. */
+      // An informative message or error message.
       wcserr_copy(wcs->err, info+ifix);
 
       if ((status = (stat[ifix] > 0))) {
-        /* It was an error, replace the previous one. */
+        // It was an error, replace the previous one.
         wcserr_copy(wcs->err, &err);
       }
     }
   }
 
-  /* Restore the last error to occur. */
+  // Restore the last error to occur.
   if (err.status) {
     wcserr_copy(&err, wcs->err);
   } else {
@@ -214,39 +213,36 @@ int wcsfixi(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cdfix(struct wcsprm *wcs)
 
 {
-  int  i, k, naxis, status = FIXERR_NO_CHANGE;
-  double *cd;
-
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
 
   if ((wcs->altlin & 1) || !(wcs->altlin & 2)) {
-    /* Either we have PCi_ja or there are no CDi_ja. */
+    // Either we have PCi_ja or there are no CDi_ja.
     return FIXERR_NO_CHANGE;
   }
 
-  naxis = wcs->naxis;
-  status = FIXERR_NO_CHANGE;
-  for (i = 0; i < naxis; i++) {
-    /* Row of zeros? */
-    cd = wcs->cd + i * naxis;
-    for (k = 0; k < naxis; k++, cd++) {
+  int naxis  = wcs->naxis;
+  int status = FIXERR_NO_CHANGE;
+  for (int i = 0; i < naxis; i++) {
+    // Row of zeros?
+    double *cd = wcs->cd + i*naxis;
+    for (int k = 0; k < naxis; k++, cd++) {
       if (*cd != 0.0) goto next;
     }
 
-    /* Column of zeros? */
+    // Column of zeros?
     cd = wcs->cd + i;
-    for (k = 0; k < naxis; k++, cd += naxis) {
+    for (int k = 0; k < naxis; k++, cd += naxis) {
       if (*cd != 0.0) goto next;
     }
 
     cd = wcs->cd + i * (naxis + 1);
     *cd = 1.0;
-    status = 0;
+    status = FIXERR_SUCCESS;
 
 next: ;
   }
@@ -254,13 +250,12 @@ next: ;
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 static int parse_date(const char *buf, int *hour, int *minute, double *sec)
 
 {
   char ctmp[72];
-
   if (sscanf(buf, "%2d:%2d:%s", hour, minute, ctmp) < 3 ||
       wcsutil_str2double(ctmp, sec)) {
     return 1;
@@ -274,7 +269,6 @@ static void write_date(char *buf, int ho
 
 {
   char ctmp[32];
-
   wcsutil_double2str(ctmp, "%04.1f", sec);
   sprintf(buf, "T%.2d:%.2d:%s", hour, minute, ctmp);
 }
@@ -284,7 +278,6 @@ static char *newline(char **cp)
 
 {
   size_t k;
-
   if ((k = strlen(*cp))) {
     *cp += k;
     strcat(*cp, ".\n");
@@ -300,32 +293,34 @@ int datfix(struct wcsprm *wcs)
 {
   static const char *function = "datfix";
 
-  /* MJD of J2000.0 and B1900.0. */
+  // MJD of J2000.0 and B1900.0.
   const double mjd2000 = 51544.5;
   const double mjd1900 = 15019.81352;
 
-  /* Days per Julian year and per tropical year. */
+  // Days per Julian year and per tropical year.
   const double djy = 365.25;
   const double dty = 365.242198781;
 
-  const char *dateid;
-  char *cp, *date, infomsg[512], orig_date[72];
-  int  day, dd, hour = 0, i, jd, minute = 0, month, msec, n4, status, year;
-  double bepoch, jepoch, mjd[2], mjdsum, mjdtmp, sec = 0.0, t, *wcsmjd;
-  struct wcserr **err;
+  int  day, hour = 0, minute = 0, month, year;
+  double sec = 0.0;
 
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
-  err = &(wcs->err);
+  struct wcserr **err = &(wcs->err);
 
-  cp = infomsg;
+  char infomsg[512];
+  char *cp = infomsg;
   *cp = '\0';
-  status = FIXERR_NO_CHANGE;
 
-  for (i = 0; i < 5; i++) {
-    /* MJDREF is split into integer and fractional parts, wheres MJDOBS and
-       the rest are a single value. */
+  int status = FIXERR_NO_CHANGE;
+
+  for (int i = 0; i < 5; i++) {
+    // MJDREF is split into integer and fractional parts, wheres MJDOBS and
+    // the rest are a single value.
+    const char *dateid;
+    char *date;
+    double *wcsmjd;
     if (i == 0) {
-      /* Note, DATEREF and MJDREF, not DATE-REF and MJD-REF (sigh). */
+      // Note, DATEREF and MJDREF, not DATE-REF and MJD-REF (sigh).
       dateid = "REF";
       date   = wcs->dateref;
       wcsmjd = wcs->mjdref;
@@ -347,55 +342,59 @@ int datfix(struct wcsprm *wcs)
       wcsmjd = &(wcs->mjdend);
     }
 
+    char orig_date[72];
     strncpy(orig_date, date, 72);
 
     if (date[0] == '\0') {
-      /* Fill in DATE from MJD if possible. */
+      // Fill in DATE from MJD if possible.
 
       if (i == 1 && undefined(*wcsmjd)) {
-        /* See if we have jepoch or bepoch. */
+        // See if we have jepoch or bepoch.
         if (!undefined(wcs->jepoch)) {
           *wcsmjd = mjd2000 + (wcs->jepoch - 2000.0)*djy;
           sprintf(newline(&cp), "Set MJD-OBS to %.6f from JEPOCH", *wcsmjd);
+	  if (status == FIXERR_NO_CHANGE) status = FIXERR_SUCCESS;
 
         } else if (!undefined(wcs->bepoch)) {
           *wcsmjd = mjd1900 + (wcs->bepoch - 1900.0)*dty;
           sprintf(newline(&cp), "Set MJD-OBS to %.6f from BEPOCH", *wcsmjd);
+	  if (status == FIXERR_NO_CHANGE) status = FIXERR_SUCCESS;
         }
       }
 
       if (undefined(*wcsmjd)) {
-        /* No date information was provided. */
+        // No date information was provided.
 
       } else {
-        /* Calendar date from MJD, with allowance for MJD < 0. */
+        // Calendar date from MJD, with allowance for MJD < 0.
+        double mjd[2], t;
         if (i == 0) {
-          /* MJDREF is already split into integer and fractional parts. */
+          // MJDREF is already split into integer and fractional parts.
           mjd[0] = wcsmjd[0];
           mjd[1] = wcsmjd[1];
           if (1.0 < mjd[1]) {
-            /* Ensure the fractional part lies between 0 and +1. */
+            // Ensure the fractional part lies between 0 and +1.
             t = floor(mjd[1]);
             mjd[0] += t;
             mjd[1] -= t;
           }
         } else {
-          /* Split it into integer and fractional parts. */
+          // Split it into integer and fractional parts.
           mjd[0] = floor(*wcsmjd);
           mjd[1] = *wcsmjd - mjd[0];
         }
 
-        jd = 2400001 + (int)mjd[0];
+        int jd = 2400001 + (int)mjd[0];
 
-        n4 =  4*(jd + ((2*((4*jd - 17918)/146097)*3)/4 + 1)/2 - 37);
-        dd = 10*(((n4-237)%1461)/4) + 5;
+        int n4 =  4*(jd + ((2*((4*jd - 17918)/146097)*3)/4 + 1)/2 - 37);
+        int dd = 10*(((n4-237)%1461)/4) + 5;
 
         year  = n4/1461 - 4712;
         month = (2 + dd/306)%12 + 1;
         day   = (dd%306)/10 + 1;
         sprintf(date, "%.4d-%.2d-%.2d", year, month, day);
 
-        /* Write time part only if non-zero. */
+        // Write time part only if non-zero.
         if (0.0 < (t = mjd[1])) {
           t *= 24.0;
           hour = (int)t;
@@ -403,15 +402,15 @@ int datfix(struct wcsprm *wcs)
           minute = (int)t;
           sec    = 60.0 * (t - minute);
 
-          /* Round to 1ms. */
+          // Round to 1ms.
           dd = 60000*(60*hour + minute) + (int)(1000*(sec+0.0005));
           hour = dd / 3600000;
           dd -= 3600000 * hour;
           minute = dd / 60000;
-          msec = dd - 60000 * minute;
+          int msec = dd - 60000 * minute;
           sprintf(date+10, "T%.2d:%.2d:%.2d", hour, minute, msec/1000);
 
-          /* Write fractions of a second only if non-zero. */
+          // Write fractions of a second only if non-zero.
           if (msec%1000) {
             sprintf(date+19, ".%.3d", msec%1000);
           }
@@ -420,16 +419,16 @@ int datfix(struct wcsprm *wcs)
 
     } else {
       if (strlen(date) < 8) {
-        /* Can't be a valid date. */
+        // Can't be a valid date.
         status = FIXERR_BAD_PARAM;
         sprintf(newline(&cp), "Invalid DATE%s format '%s' is too short",
           dateid, date);
         continue;
       }
 
-      /* Identify the date format. */
+      // Identify the date format.
       if (date[4] == '-' && date[7] == '-') {
-        /* Standard year-2000 form: CCYY-MM-DD[Thh:mm:ss[.sss...]] */
+        // Standard year-2000 form: CCYY-MM-DD[Thh:mm:ss[.sss...]]
         if (sscanf(date, "%4d-%2d-%2d", &year, &month, &day) < 3) {
           status = FIXERR_BAD_PARAM;
           sprintf(newline(&cp), "Invalid DATE%s format '%s'", dateid, date);
@@ -455,7 +454,7 @@ int datfix(struct wcsprm *wcs)
         }
 
       } else if (date[4] == '/' && date[7] == '/') {
-        /* Also allow CCYY/MM/DD[Thh:mm:ss[.sss...]] */
+        // Also allow CCYY/MM/DD[Thh:mm:ss[.sss...]]
         if (sscanf(date, "%4d/%2d/%2d", &year, &month, &day) < 3) {
           status = FIXERR_BAD_PARAM;
           sprintf(newline(&cp), "Invalid DATE%s format '%s'", dateid, date);
@@ -480,13 +479,13 @@ int datfix(struct wcsprm *wcs)
           }
         }
 
-        /* Looks ok, fix it up. */
+        // Looks ok, fix it up.
         date[4]  = '-';
         date[7]  = '-';
 
       } else {
         if (i == 1 && date[2] == '/' && date[5] == '/') {
-          /* Old format DATE-OBS date: DD/MM/YY, also allowing DD/MM/CCYY. */
+          // Old format DATE-OBS date: DD/MM/YY, also allowing DD/MM/CCYY.
           if (sscanf(date, "%2d/%2d/%4d", &day, &month, &year) < 3) {
             status = FIXERR_BAD_PARAM;
             sprintf(newline(&cp), "Invalid DATE%s format '%s'", dateid,
@@ -495,7 +494,7 @@ int datfix(struct wcsprm *wcs)
           }
 
         } else if (i == 1 && date[2] == '-' && date[5] == '-') {
-          /* Also recognize DD-MM-YY and DD-MM-CCYY */
+          // Also recognize DD-MM-YY and DD-MM-CCYY
           if (sscanf(date, "%2d-%2d-%4d", &day, &month, &year) < 3) {
             status = FIXERR_BAD_PARAM;
             sprintf(newline(&cp), "Invalid DATE%s format '%s'", dateid,
@@ -504,7 +503,7 @@ int datfix(struct wcsprm *wcs)
           }
 
         } else {
-          /* Not a valid date format. */
+          // Not a valid date format.
           status = FIXERR_BAD_PARAM;
           sprintf(newline(&cp), "Invalid DATE%s format '%s'", dateid, date);
           continue;
@@ -512,17 +511,18 @@ int datfix(struct wcsprm *wcs)
 
         if (year < 100) year += 1900;
 
-        /* Doesn't have a time. */
+        // Doesn't have a time.
         sprintf(date, "%.4d-%.2d-%.2d", year, month, day);
       }
 
-      /* Compute MJD. */
+      // Compute MJD.
+      double mjd[2];
       mjd[0] = (double)((1461*(year - (12-month)/10 + 4712))/4
                + (306*((month+9)%12) + 5)/10
                - (3*((year - (12-month)/10 + 4900)/100))/4
                + day - 2399904);
       mjd[1] = (hour + (minute + sec/60.0)/60.0)/24.0;
-      mjdsum = mjd[0] + mjd[1];
+      double mjdsum = mjd[0] + mjd[1];
 
       if (undefined(*wcsmjd)) {
         if (i == 0) {
@@ -534,8 +534,11 @@ int datfix(struct wcsprm *wcs)
         sprintf(newline(&cp), "Set MJD%s to %.6f from DATE%s", dateid,
           mjdsum, dateid);
 
+        if (status == FIXERR_NO_CHANGE) status = FIXERR_SUCCESS;
+
       } else {
-        /* Check for consistency. */
+        // Check for consistency.
+        double mjdtmp;
         if (i == 0) {
           mjdtmp = wcsmjd[0] + wcsmjd[1];
         } else {
@@ -552,21 +555,21 @@ int datfix(struct wcsprm *wcs)
 
       if (i == 1) {
         if (!undefined(wcs->jepoch)) {
-          /* Check consistency of JEPOCH. */
-          jepoch = 2000.0 + (*wcsmjd - mjd2000) / djy;
+          // Check consistency of JEPOCH.
+          double jepoch = 2000.0 + (*wcsmjd - mjd2000) / djy;
 
           if (0.000002 < fabs(jepoch - wcs->jepoch)) {
-            /* Informational only, no error. */
+            // Informational only, no error.
             sprintf(newline(&cp), "JEPOCH is inconsistent with DATE-OBS");
           }
         }
 
         if (!undefined(wcs->bepoch)) {
-          /* Check consistency of BEPOCH. */
-          bepoch = 1900.0 + (*wcsmjd - mjd1900) / dty;
+          // Check consistency of BEPOCH.
+          double bepoch = 1900.0 + (*wcsmjd - mjd1900) / dty;
 
           if (0.000002 < fabs(bepoch - wcs->bepoch)) {
-            /* Informational only, no error. */
+            // Informational only, no error.
             sprintf(newline(&cp), "BEPOCH is inconsistent with DATE-OBS");
           }
         }
@@ -582,7 +585,7 @@ int datfix(struct wcsprm *wcs)
           orig_date, date);
       }
 
-      if (status == FIXERR_NO_CHANGE) status = 0;
+      if (status == FIXERR_NO_CHANGE) status = FIXERR_SUCCESS;
     }
   }
 
@@ -593,37 +596,33 @@ int datfix(struct wcsprm *wcs)
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int obsfix(int ctrl, struct wcsprm *wcs)
 
 {
   static const char *function = "obsfix";
 
-  /* IAU(1976) ellipsoid (as prescribed by WCS Paper VII). */
-  const double a = 6378140.0, f = 1.0 / 298.2577;
+  // IAU(1976) ellipsoid (as prescribed by WCS Paper VII).
+  const double a  = 6378140.0;
+  const double f  = 1.0 / 298.2577;
   const double e2 = (2.0 - f)*f;
 
-  char   *cp, infomsg[256];
-  int    havelbh = 7, havexyz = 7, i, status;
-  size_t k;
-  double coslat, coslng, d, hgt, lat, lng, n, r2, rho, sinlat, sinlng, x, y,
-         z, zeta;
-  struct wcserr **err;
-
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
-  err = &(wcs->err);
+  struct wcserr **err = &(wcs->err);
 
-  /* Set masks for checking partially-defined coordinate triplets. */
+  // Set masks for checking partially-defined coordinate triplets.
+  int havexyz = 7;
   havexyz -= 1*undefined(wcs->obsgeo[0]);
   havexyz -= 2*undefined(wcs->obsgeo[1]);
   havexyz -= 4*undefined(wcs->obsgeo[2]);
+  int havelbh = 7;
   havelbh -= 1*undefined(wcs->obsgeo[3]);
   havelbh -= 2*undefined(wcs->obsgeo[4]);
   havelbh -= 4*undefined(wcs->obsgeo[5]);
 
   if (ctrl == 2) {
-    /* Make no changes. */
+    // Make no changes.
     if (0 < havexyz && havexyz < 7) {
       return wcserr_set(WCSERR_SET(FIXERR_BAD_PARAM),
         "Partially undefined Cartesian coordinate triplet");
@@ -644,24 +643,29 @@ int obsfix(int ctrl, struct wcsprm *wcs)
   }
 
 
+  char infomsg[256];
   infomsg[0] = '\0';
-  status = FIXERR_NO_CHANGE;
 
+  int status = FIXERR_NO_CHANGE;
+
+  size_t k;
+  double x, y, z;
   if (havelbh == 7) {
-    /* Compute (x,y,z) from (lng,lat,hgt). */
+    // Compute (x,y,z) from (lng,lat,hgt).
+    double coslat, coslng, sinlat, sinlng;
     sincosd(wcs->obsgeo[3], &sinlng, &coslng);
     sincosd(wcs->obsgeo[4], &sinlat, &coslat);
-    n = a / sqrt(1.0 - e2*sinlat*sinlat);
-    rho = n + wcs->obsgeo[5];
+    double n = a / sqrt(1.0 - e2*sinlat*sinlat);
+    double rho = n + wcs->obsgeo[5];
 
     x = rho*coslng*coslat;
     y = rho*sinlng*coslat;
     z = (rho - n*e2)*sinlat;
 
     if (havexyz < 7) {
-      /* One or more of the Cartesian elements was undefined. */
-      status = 0;
-      cp = infomsg;
+      // One or more of the Cartesian elements was undefined.
+      status = FIXERR_SUCCESS;
+      char *cp = infomsg;
 
       if (ctrl == 1 || !(havexyz & 1)) {
         wcs->obsgeo[0] = x;
@@ -695,21 +699,22 @@ int obsfix(int ctrl, struct wcsprm *wcs)
       wcserr_set(WCSERR_SET(FIXERR_OBSGEO_FIX), infomsg);
 
       if (havexyz == 0) {
-        /* Skip the consistency check. */
+        // Skip the consistency check.
         return status;
       }
     }
 
   } else if (havexyz == 7) {
-    /* Compute (lng,lat,hgt) from (x,y,z). */
+    // Compute (lng,lat,hgt) from (x,y,z).
     x = wcs->obsgeo[0];
     y = wcs->obsgeo[1];
     z = wcs->obsgeo[2];
-    r2 = x*x + y*y;
+    double r2 = x*x + y*y;
 
-    /* Iterate over the value of zeta. */
-    zeta = z;
-    for (i = 0; i < 4; i++) {
+    // Iterate over the value of zeta.
+    double coslat, coslng, sinlat, sinlng;
+    double n, rho, zeta = z;
+    for (int i = 0; i < 4; i++) {
       rho = sqrt(r2 + zeta*zeta);
       sinlat = zeta / rho;
       n = a / sqrt(1.0 - e2*sinlat*sinlat);
@@ -717,14 +722,14 @@ int obsfix(int ctrl, struct wcsprm *wcs)
       zeta = z / (1.0 - n*e2/rho);
     }
 
-    lng = atan2d(y, x);
-    lat = asind(sinlat);
-    hgt = rho - n;
+    double lng = atan2d(y, x);
+    double lat = asind(sinlat);
+    double hgt = rho - n;
 
     if (havelbh < 7) {
-      /* One or more of the Geodetic elements was undefined. */
-      status = 0;
-      cp = infomsg;
+      // One or more of the Geodetic elements was undefined.
+      status = FIXERR_SUCCESS;
+      char *cp = infomsg;
 
       if (ctrl == 1 || !(havelbh & 1)) {
         wcs->obsgeo[3] = lng;
@@ -757,12 +762,12 @@ int obsfix(int ctrl, struct wcsprm *wcs)
       wcserr_set(WCSERR_SET(FIXERR_OBSGEO_FIX), infomsg);
 
       if (havelbh == 0) {
-        /* Skip the consistency check. */
+        // Skip the consistency check.
         return status;
       }
     }
 
-    /* Compute (x,y,z) from (lng,lat,hgt) for consistency checking. */
+    // Compute (x,y,z) from (lng,lat,hgt) for consistency checking.
     sincosd(wcs->obsgeo[3], &sinlng, &coslng);
     sincosd(wcs->obsgeo[4], &sinlat, &coslat);
     n = a / sqrt(1.0 - e2*sinlat*sinlat);
@@ -778,8 +783,8 @@ int obsfix(int ctrl, struct wcsprm *wcs)
   }
 
 
-  /* Check consistency. */
-  r2 = 0.0;
+  // Check consistency.
+  double d, r2 = 0.0;
   d = wcs->obsgeo[0] - x;
   r2 += d*d;
   d = wcs->obsgeo[1] - y;
@@ -797,30 +802,30 @@ int obsfix(int ctrl, struct wcsprm *wcs)
 }
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int unitfix(int ctrl, struct wcsprm *wcs)
 
 {
   const char *function = "unitfix";
 
-  char   orig_unit[72], msg[512], msgtmp[192];
-  int    i, result, status = FIXERR_NO_CHANGE;
-  size_t msglen;
-  struct wcserr **err;
-
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
-  err = &(wcs->err);
+  struct wcserr **err = &(wcs->err);
 
+  int status = FIXERR_NO_CHANGE;
+
+  char msg[512];
   strncpy(msg, "Changed units:", 512);
 
-  for (i = 0; i < wcs->naxis; i++) {
+  for (int i = 0; i < wcs->naxis; i++) {
+    char orig_unit[72];
     strncpy(orig_unit, wcs->cunit[i], 71);
-    result = wcsutrne(ctrl, wcs->cunit[i], &(wcs->err));
+    int result = wcsutrne(ctrl, wcs->cunit[i], &(wcs->err));
     if (result == 0 || result == 12) {
-      msglen = strlen(msg);
+      size_t msglen = strlen(msg);
       if (msglen < 511) {
         wcsutil_null_fill(72, orig_unit);
+        char msgtmp[192];
         sprintf(msgtmp, "\n  '%s' -> '%s',", orig_unit, wcs->cunit[i]);
         strncpy(msg+msglen, msgtmp, 511-msglen);
         status = FIXERR_UNITS_ALIAS;
@@ -829,52 +834,49 @@ int unitfix(int ctrl, struct wcsprm *wcs
   }
 
   if (status == FIXERR_UNITS_ALIAS) {
-    /* Chop off the trailing ", ". */
-    msglen = strlen(msg) - 2;
+    // Chop off the trailing ", ".
+    size_t msglen = strlen(msg) - 2;
     msg[msglen] = '\0';
     wcserr_set(WCSERR_SET(FIXERR_UNITS_ALIAS), msg);
 
-    status = 0;
+    status = FIXERR_SUCCESS;
   }
 
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcfix(struct wcsprm *wcs)
 
 {
   static const char *function = "spcfix";
 
-  char ctype[9], specsys[9];
-  int  i, status;
-  struct wcserr **err;
-
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
-  err = &(wcs->err);
+  struct wcserr **err = &(wcs->err);
 
-  for (i = 0; i < wcs->naxis; i++) {
-    /* Translate an AIPS-convention spectral type if present. */
-    status = spcaips(wcs->ctype[i], wcs->velref, ctype, specsys);
-    if (status == 0) {
-      /* An AIPS type was found but it may match what we already have. */
+  for (int i = 0; i < wcs->naxis; i++) {
+    // Translate an AIPS-convention spectral type if present.
+    char ctype[9], specsys[9];
+    int status = spcaips(wcs->ctype[i], wcs->velref, ctype, specsys);
+    if (status == FIXERR_SUCCESS) {
+      // An AIPS type was found but it may match what we already have.
       status = FIXERR_NO_CHANGE;
 
-      /* Was specsys translated? */
+      // Was specsys translated?
       if (wcs->specsys[0] == '\0' && *specsys) {
         strncpy(wcs->specsys, specsys, 9);
         wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),
           "Changed SPECSYS to '%s'", specsys);
-        status = 0;
+        status = FIXERR_SUCCESS;
       }
 
-      /* Was ctype translated?  Have to null-fill for comparing them. */
+      // Was ctype translated?  Have to null-fill for comparing them.
       wcsutil_null_fill(9, wcs->ctype[i]);
       if (strncmp(wcs->ctype[i], ctype, 9)) {
-        /* ctype was translated... */
-        if (status == 0) {
-          /* ...and specsys was also. */
+        // ctype was translated...
+        if (status == FIXERR_SUCCESS) {
+          // ...and specsys was also.
           wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),
             "Changed CTYPE%d from '%s' to '%s', and SPECSYS to '%s' "
             "(VELREF=%d)", i+1, wcs->ctype[i], ctype, wcs->specsys,
@@ -883,23 +885,23 @@ int spcfix(struct wcsprm *wcs)
           wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),
             "Changed CTYPE%d from '%s' to '%s' (VELREF=%d)", i+1,
             wcs->ctype[i], ctype, wcs->velref);
-          status = 0;
+          status = FIXERR_SUCCESS;
         }
 
         strncpy(wcs->ctype[i], ctype, 9);
       }
 
-      /* Tidy up. */
-      if (status == 0) {
+      // Tidy up.
+      if (status == FIXERR_SUCCESS) {
         wcsutil_null_fill(72, wcs->ctype[i]);
         wcsutil_null_fill(72, wcs->specsys);
       }
 
-      /* No need to check for others, wcsset() will fail if so. */
+      // No need to check for others, wcsset() will fail if so.
       return status;
 
     } else if (status == SPCERR_BAD_SPEC_PARAMS) {
-      /* An AIPS spectral type was found but with invalid velref. */
+      // An AIPS spectral type was found but with invalid velref.
       return wcserr_set(WCSERR_SET(FIXERR_BAD_PARAM),
         "Invalid parameter value: velref = %d", wcs->velref);
     }
@@ -908,35 +910,31 @@ int spcfix(struct wcsprm *wcs)
   return FIXERR_NO_CHANGE;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celfix(struct wcsprm *wcs)
 
 {
   static const char *function = "celfix";
 
-  int k, status;
-  struct celprm *wcscel = &(wcs->cel);
-  struct prjprm *wcsprj = &(wcscel->prj);
-  struct wcserr **err;
-
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
-  err = &(wcs->err);
+  struct wcserr **err = &(wcs->err);
 
-  /* Initialize if required. */
+  // Initialize if required.
+  int status;
   if (wcs->flag != WCSSET) {
     if ((status = wcsset(wcs))) return fix_wcserr[status];
   }
 
-  /* Was an NCP or GLS projection code translated? */
+  // Was an NCP or GLS projection code translated?
   if (wcs->lat >= 0) {
-    /* Check ctype. */
+    // Check ctype.
     if (strcmp(wcs->ctype[wcs->lat]+5, "NCP") == 0) {
       strcpy(wcs->ctype[wcs->lng]+5, "SIN");
       strcpy(wcs->ctype[wcs->lat]+5, "SIN");
 
       if (wcs->npvmax < wcs->npv + 2) {
-        /* Allocate space for two more PVi_ma keyvalues. */
+        // Allocate space for two more PVi_ma keyvalues.
         if (wcs->m_flag == WCSSET && wcs->pv == wcs->m_pv) {
           if (!(wcs->pv = calloc(wcs->npv+2, sizeof(struct pvcard)))) {
             wcs->pv = wcs->m_pv;
@@ -946,7 +944,7 @@ int celfix(struct wcsprm *wcs)
           wcs->npvmax = wcs->npv + 2;
           wcs->m_flag = WCSSET;
 
-          for (k = 0; k < wcs->npv; k++) {
+          for (int k = 0; k < wcs->npv; k++) {
             wcs->pv[k] = wcs->m_pv[k];
           }
 
@@ -958,6 +956,8 @@ int celfix(struct wcsprm *wcs)
         }
       }
 
+      struct celprm *wcscel = &(wcs->cel);
+      struct prjprm *wcsprj = &(wcscel->prj);
       wcs->pv[wcs->npv].i = wcs->lat + 1;
       wcs->pv[wcs->npv].m = 1;
       wcs->pv[wcs->npv].value = wcsprj->pv[1];
@@ -968,23 +968,23 @@ int celfix(struct wcsprm *wcs)
       wcs->pv[wcs->npv].value = wcsprj->pv[2];
       (wcs->npv)++;
 
-      return 0;
+      return FIXERR_SUCCESS;
 
     } else if (strcmp(wcs->ctype[wcs->lat]+5, "GLS") == 0) {
       strcpy(wcs->ctype[wcs->lng]+5, "SFL");
       strcpy(wcs->ctype[wcs->lat]+5, "SFL");
 
       if (wcs->crval[wcs->lng] != 0.0 || wcs->crval[wcs->lat] != 0.0) {
-        /* In the AIPS convention, setting the reference longitude and
-         * latitude for GLS does not create an oblique graticule.  A non-zero
-         * reference longitude introduces an offset in longitude in the normal
-         * way, whereas a non-zero reference latitude simply translates the
-         * reference point (i.e. the map as a whole) to that latitude.  This
-         * might be effected by adjusting CRPIXja but that is complicated by
-         * the linear transformation and instead is accomplished here by
-         * setting theta_0. */
+        // In the AIPS convention, setting the reference longitude and
+        // latitude for GLS does not create an oblique graticule.  A non-zero
+        // reference longitude introduces an offset in longitude in the normal
+        // way, whereas a non-zero reference latitude simply translates the
+        // reference point (i.e. the map as a whole) to that latitude.  This
+        // might be effected by adjusting CRPIXja but that is complicated by
+        // the linear transformation and instead is accomplished here by
+        // setting theta_0.
         if (wcs->npvmax < wcs->npv + 3) {
-          /* Allocate space for three more PVi_ma keyvalues. */
+          // Allocate space for three more PVi_ma keyvalues.
           if (wcs->m_flag == WCSSET && wcs->pv == wcs->m_pv) {
             if (!(wcs->pv = calloc(wcs->npv+3, sizeof(struct pvcard)))) {
               wcs->pv = wcs->m_pv;
@@ -994,7 +994,7 @@ int celfix(struct wcsprm *wcs)
             wcs->npvmax = wcs->npv + 3;
             wcs->m_flag = WCSSET;
 
-            for (k = 0; k < wcs->npv; k++) {
+            for (int k = 0; k < wcs->npv; k++) {
               wcs->pv[k] = wcs->m_pv[k];
             }
 
@@ -1011,7 +1011,7 @@ int celfix(struct wcsprm *wcs)
         wcs->pv[wcs->npv].value = 1.0;
         (wcs->npv)++;
 
-        /* Note that the reference longitude is still zero. */
+        // Note that the reference longitude is still zero.
         wcs->pv[wcs->npv].i = wcs->lng + 1;
         wcs->pv[wcs->npv].m = 1;
         wcs->pv[wcs->npv].value = 0.0;
@@ -1023,55 +1023,54 @@ int celfix(struct wcsprm *wcs)
         (wcs->npv)++;
       }
 
-      return 0;
+      return FIXERR_SUCCESS;
     }
   }
 
   return FIXERR_NO_CHANGE;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cylfix(const int naxis[], struct wcsprm *wcs)
 
 {
   static const char *function = "cylfix";
 
-  unsigned short icnr, indx[NMAX], ncnr;
-  int    j, k, stat[4], status;
-  double img[4][NMAX], lat, lng, phi[4], phi0, phimax, phimin, pix[4][NMAX],
-         *pixj, theta[4], theta0, world[4][NMAX], x, y;
-  struct wcserr **err;
-
   if (naxis == 0x0) return FIXERR_NO_CHANGE;
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
-  err = &(wcs->err);
+  struct wcserr **err = &(wcs->err);
 
-  /* Initialize if required. */
+  // Initialize if required.
+  int status;
   if (wcs->flag != WCSSET) {
     if ((status = wcsset(wcs))) return fix_wcserr[status];
   }
 
-  /* Check that we have a cylindrical projection. */
+  // Check that we have a cylindrical projection.
   if (wcs->cel.prj.category != CYLINDRICAL) return FIXERR_NO_CHANGE;
   if (wcs->naxis < 2) return FIXERR_NO_CHANGE;
 
 
-  /* Compute the native longitude in each corner of the image. */
-  ncnr = 1 << wcs->naxis;
+  // Compute the native longitude in each corner of the image.
+  unsigned short ncnr = 1 << wcs->naxis;
 
-  for (k = 0; k < NMAX; k++) {
+  unsigned short indx[NMAX];
+  for (int k = 0; k < NMAX; k++) {
     indx[k] = 1 << k;
   }
 
-  phimin =  1.0e99;
-  phimax = -1.0e99;
-  for (icnr = 0; icnr < ncnr;) {
-    /* Do four corners at a time. */
-    for (j = 0; j < 4; j++, icnr++) {
-      pixj = pix[j];
+  int    stat[4];
+  double img[4][NMAX], phi[4], pix[4][NMAX], theta[4], world[4][NMAX];
+
+  double phimin =  1.0e99;
+  double phimax = -1.0e99;
+  for (unsigned short icnr = 0; icnr < ncnr;) {
+    // Do four corners at a time.
+    for (int j = 0; j < 4; j++, icnr++) {
+      double *pixj = pix[j];
 
-      for (k = 0; k < wcs->naxis; k++) {
+      for (int k = 0; k < wcs->naxis; k++) {
         if (icnr & indx[k]) {
           *(pixj++) = naxis[k] + 0.5;
         } else {
@@ -1082,7 +1081,7 @@ int cylfix(const int naxis[], struct wcs
 
     if (!(status = wcsp2s(wcs, 4, NMAX, pix[0], img[0], phi, theta, world[0],
                           stat))) {
-      for (j = 0; j < 4; j++) {
+      for (int j = 0; j < 4; j++) {
         if (phi[j] < phimin) phimin = phi[j];
         if (phi[j] > phimax) phimax = phi[j];
       }
@@ -1091,14 +1090,15 @@ int cylfix(const int naxis[], struct wcs
 
   if (phimin > phimax) return fix_wcserr[status];
 
-  /* Any changes needed? */
+  // Any changes needed?
   if (phimin >= -180.0 && phimax <= 180.0) return FIXERR_NO_CHANGE;
 
 
-  /* Compute the new reference pixel coordinates. */
-  phi0 = (phimin + phimax) / 2.0;
-  theta0 = 0.0;
+  // Compute the new reference pixel coordinates.
+  double phi0 = (phimin + phimax) / 2.0;
+  double theta0 = 0.0;
 
+  double x, y;
   if ((status = prjs2x(&(wcs->cel.prj), 1, 1, 1, 1, &phi0, &theta0, &x, &y,
                        stat))) {
     if (status == PRJERR_BAD_PARAM) {
@@ -1109,7 +1109,7 @@ int cylfix(const int naxis[], struct wcs
     return wcserr_set(WCSFIX_ERRMSG(status));
   }
 
-  for (k = 0; k < wcs->naxis; k++) {
+  for (int k = 0; k < wcs->naxis; k++) {
     img[0][k] = 0.0;
   }
   img[0][wcs->lng] = x;
@@ -1120,15 +1120,15 @@ int cylfix(const int naxis[], struct wcs
   }
 
 
-  /* Compute celestial coordinates at the new reference pixel. */
+  // Compute celestial coordinates at the new reference pixel.
   if ((status = wcsp2s(wcs, 1, 0, pix[0], img[0], phi, theta, world[0],
                        stat))) {
     return fix_wcserr[status];
   }
 
-  /* Compute native coordinates of the celestial pole. */
-  lng =  0.0;
-  lat = 90.0;
+  // Compute native coordinates of the celestial pole.
+  double lng =  0.0;
+  double lat = 90.0;
   (void)sphs2x(wcs->cel.euler, 1, 1, 1, 1, &lng, &lat, phi, theta);
 
   wcs->crpix[wcs->lng] = pix[0][wcs->lng];
@@ -1139,3 +1139,357 @@ int cylfix(const int naxis[], struct wcs
 
   return wcsset(wcs);
 }
+
+//----------------------------------------------------------------------------
+
+// Helper function used only by wcspcx().
+static int unscramble(int n, int mapto[], int step, int type, void *vptr);
+
+int wcspcx(
+  struct wcsprm *wcs,
+  int dopc,
+  int permute,
+  double rotn[2])
+
+{
+  static const char *function = "wcspcx";
+
+  // Initialize if required.
+  if (wcs == 0x0) return FIXERR_NULL_POINTER;
+  struct wcserr **err = &(wcs->err);
+
+  int status;
+  if (wcs->flag != WCSSET) {
+    if ((status = wcsset(wcs))) return fix_wcserr[status];
+  }
+
+  // Check for CDi_j usage.
+  double *wcscd = wcs->cd;
+  if ((wcs->altlin & 1) || !(wcs->altlin & 2)) {
+    if ((wcs->altlin & 1) && dopc == 1) {
+      // Recompose PCi_j + CDELTi.
+      wcscd = wcs->pc;
+    } else {
+      return wcserr_set(WCSERR_SET(FIXERR_BAD_PARAM),
+        "CDi_j is not used in this coordinate representation");
+    }
+  }
+
+  // Check for sequent distortions.
+  if (wcs->lin.disseq) {
+    return wcserr_set(WCSERR_SET(FIXERR_BAD_COORD_TRANS),
+      "Cannot handle coordinate descriptions containing sequent distortions");
+  }
+
+
+  // Allocate memory in bulk for two nxn matrices.
+  int naxis = wcs->naxis;
+  double *mem;
+  if ((mem = calloc(2*naxis*naxis, sizeof(double))) == 0x0) {
+    return wcserr_set(WCSFIX_ERRMSG(FIXERR_MEMORY));
+  }
+
+  double *mat = mem;
+  double *inv = mem + naxis*naxis;
+
+  // Construct the transpose of CDi_j with each element squared.
+  double *matij = mat;
+  for (int i = 0; i < naxis; i++) {
+    double *cdji = wcscd + i;
+    for (int j = 0; j < naxis; j++) {
+      *(matij++) = (*cdji) * (*cdji);
+      cdji += naxis;
+    }
+  }
+
+  // Invert the matrix.
+  if ((status = matinv(naxis, mat, inv))) {
+    return wcserr_set(WCSERR_SET(FIXERR_SINGULAR_MTX),
+      "No solution for CDi_j matrix decomposition");
+  }
+
+  // Apply scaling.
+  double *invij = inv;
+  double *pcij = wcs->pc;
+  double *cdij = wcscd;
+  for (int i = 0; i < naxis; i++) {
+    double scl = 0.0;
+    for (int j = 0; j < naxis; j++) {
+      scl += *(invij++);
+    }
+
+    scl = sqrt(scl);
+    wcs->cdelt[i] /= scl;
+
+    for (int j = 0; j < naxis; j++) {
+      *(pcij++) = *(cdij++) * scl;
+    }
+  }
+
+  // mapto[i] records where row i of PCi_j should move to.
+  int *mapto;
+  if ((mapto = (int*)malloc(naxis * sizeof(int))) == 0x0) {
+    free(mem);
+    return wcserr_set(WCSFIX_ERRMSG(FIXERR_MEMORY));
+  }
+  for (int i = 0; i < naxis; i++) {
+    mapto[i] = -1;
+  }
+
+  // Ensure that latitude always follows longitude.
+  if (wcs->lng >= 0 && wcs->lat >= 0) {
+    double *pci = wcs->pc + naxis*wcs->lng;
+
+    // Take the first non-zero element in the row.
+    for (int j = 0; j < naxis; j++) {
+      if (fabs(pci[j]) != 0.0) {
+        mapto[wcs->lng] = j;
+        break;
+      }
+    }
+
+    if (mapto[wcs->lng] == naxis-1) {
+      mapto[wcs->lng]--;
+    }
+
+    mapto[wcs->lat] = mapto[wcs->lng] + 1;
+  }
+
+  // Fill in the rest of the row permutation map.
+  for (int j = 0; j < naxis; j++) {
+    // Column j.
+    double *pcij = wcs->pc + j;
+    double colmax = 0.0;
+
+    // Look down the column to find the absolute maximum element.
+    for (int i = 0; i < naxis; i++, pcij += naxis) {
+      if (!(mapto[i] < 0)) {
+        // This row is already mapped.
+        continue;
+      }
+
+      if (fabs(*pcij) > colmax) {
+        mapto[i] = j;
+        colmax = fabs(*pcij);
+      }
+    }
+  }
+
+  // Fix the sign of CDELTi.  Celestial axes are special, otherwise diagonal
+  // elements of the correctly permuted matrix should be positive.
+  for (int i = 0; i < naxis; i++) {
+    int chsgn;
+    double *pci = wcs->pc + naxis*i;
+
+    // Celestial axes are special.
+    if (i == wcs->lng) {
+      // Longitude axis - force CDELTi < 0.0.
+      chsgn = (wcs->cdelt[i] > 0.0);
+    } else if (i == wcs->lat) {
+      // Latitude axis - force CDELTi > 0.0.
+      chsgn = (wcs->cdelt[i] < 0.0);
+    } else {
+      chsgn = (pci[mapto[i]] < 0.0);
+    }
+
+    if (chsgn) {
+      wcs->cdelt[i] = -wcs->cdelt[i];
+
+      for (int j = 0; j < naxis; j++) {
+        // Test needed to prevent negative zeros.
+        if (pci[j] != 0.0) {
+          pci[j] = -pci[j];
+        }
+      }
+    }
+  }
+
+  free(mem);
+
+  // Setting bit 3 in wcsprm::altlin stops wcsset() from reconstructing
+  // PCi_j and CDELTi from CDi_j.
+  wcs->altlin |= 8;
+
+
+  // Compute rotation angle of each basis vector of the celestial axes.
+  if (rotn) {
+    if (wcs->lng < 0 || wcs->lat < 0) {
+      // No celestial axes.
+      rotn[0] = 0.0;
+      rotn[1] = 0.0;
+
+    } else {
+      double x, y;
+      x =  wcs->pc[naxis*wcs->lng + mapto[wcs->lng]];
+      y =  wcs->pc[naxis*wcs->lat + mapto[wcs->lng]];
+      rotn[0] = atan2d(y, x);
+
+      y = -wcs->pc[naxis*wcs->lng + mapto[wcs->lat]];
+      x =  wcs->pc[naxis*wcs->lat + mapto[wcs->lat]];
+      rotn[1] = atan2d(y, x);
+    }
+  }
+
+
+  // Permute rows?
+  if (permute) {
+    // Check whether there's anything to unscramble.
+    int scrambled = 0;
+    for (int i = 0; i < naxis; i++) {
+      if (mapto[i] != i) {
+        scrambled = 1;
+        break;
+      }
+    }
+
+    if (scrambled) {
+      for (int i = 0; i < naxis; i++) {
+        // Do columns of the PCi_ja matrix.
+        if (unscramble(naxis, mapto, naxis, 1, wcs->pc + i)) {
+          free(mapto);
+          return wcserr_set(WCSFIX_ERRMSG(FIXERR_MEMORY));
+        }
+      }
+
+      if (unscramble(naxis, mapto, 1, 1, wcs->cdelt) ||
+          unscramble(naxis, mapto, 1, 1, wcs->crval) ||
+          unscramble(naxis, mapto, 1, 2, wcs->cunit) ||
+          unscramble(naxis, mapto, 1, 2, wcs->ctype)) {
+        free(mapto);
+        return wcserr_set(WCSFIX_ERRMSG(FIXERR_MEMORY));
+      }
+
+      for (int ipv = 0; ipv < wcs->npv; ipv++) {
+        // Noting that PVi_ma axis numbers are 1-relative.
+        int i = wcs->pv[ipv].i - 1;
+        wcs->pv[ipv].i = mapto[i] + 1;
+      }
+
+      for (int ips = 0; ips < wcs->nps; ips++) {
+        // Noting that PSi_ma axis numbers are 1-relative.
+        int i = wcs->ps[ips].i - 1;
+        wcs->ps[ips].i = mapto[i] + 1;
+      }
+
+      if (wcs->altlin & 2) {
+        for (int i = 0; i < naxis; i++) {
+          // Do columns of the CDi_ja matrix.
+          if (unscramble(naxis, mapto, naxis, 1, wcs->cd + i)) {
+            free(mapto);
+            return wcserr_set(WCSFIX_ERRMSG(FIXERR_MEMORY));
+          }
+        }
+      }
+
+      if (wcs->altlin & 4) {
+        if (unscramble(naxis, mapto, 1, 1, wcs->crota)) {
+          free(mapto);
+          return wcserr_set(WCSFIX_ERRMSG(FIXERR_MEMORY));
+        }
+      }
+
+      if (unscramble(naxis, mapto, 1, 3, wcs->colax) ||
+          unscramble(naxis, mapto, 1, 2, wcs->cname) ||
+          unscramble(naxis, mapto, 1, 1, wcs->crder) ||
+          unscramble(naxis, mapto, 1, 1, wcs->csyer) ||
+          unscramble(naxis, mapto, 1, 1, wcs->czphs) ||
+          unscramble(naxis, mapto, 1, 1, wcs->cperi)) {
+        free(mapto);
+        return wcserr_set(WCSFIX_ERRMSG(FIXERR_MEMORY));
+      }
+
+      // Coordinate lookup tables.
+      for (int itab = 0; itab < wcs->ntab; itab++) {
+        for (int m = 0; m < wcs->tab[itab].M; m++) {
+          int i = wcs->tab[itab].map[m];
+          wcs->tab[itab].map[m] = mapto[i];
+        }
+      }
+
+      for (int iwtb = 0; iwtb < wcs->nwtb; iwtb++) {
+        int i = wcs->wtb[iwtb].i;
+        wcs->wtb[iwtb].i = mapto[i];
+      }
+
+      // Distortions?  No. Prior distortions operate on pixel coordinates and
+      // therefore are not permuted, and sequent distortions are not handled.
+    }
+  }
+
+  free(mapto);
+
+  // Reset the struct.
+  if ((status = wcsset(wcs))) return fix_wcserr[status];
+
+  return FIXERR_SUCCESS;
+}
+
+
+int unscramble(
+  int n,
+  int mapto[],
+  int step,
+  int type,
+  void *vptr)
+
+{
+  if (step == 0) step = 1;
+
+  if (type == 1) {
+    double *dval = (double *)vptr;
+
+    double *dtmp;
+    if ((dtmp = (double *)malloc(n * sizeof(double))) == 0x0) {
+      return 1;
+    }
+
+    for (int i = 0; i < n; i++) {
+      dtmp[mapto[i]] = dval[i*step];
+    }
+
+    for (int i = 0; i < n; i++) {
+      dval[i*step] = dtmp[i];
+    }
+
+    free(dtmp);
+
+  } else if (type == 2) {
+    char (*cval)[72] = (char (*)[72])vptr;
+
+    int row_size = 72 * sizeof(char);
+    char *ctmp;
+    if ((ctmp = (char *)malloc(n * row_size)) == 0x0) {
+      return 1;
+    }
+
+    for (int i = 0; i < n; i++) {
+      memcpy(ctmp + row_size * mapto[i], cval[i], 72);
+    }
+
+    for (int i = 0; i < n; i++) {
+      memcpy(cval[i], ctmp + row_size * i, 72);
+    }
+
+    free(ctmp);
+
+  } else if (type == 3) {
+    int *ival = (int *)vptr;
+
+    int *itmp;
+    if ((itmp = (int *)malloc(n * sizeof(int))) == 0x0) {
+      return 1;
+    }
+
+    for (int i = 0; i < n; i++) {
+      itmp[mapto[i]] = ival[i];
+    }
+
+    for (int i = 0; i < n; i++) {
+      ival[i] = itmp[i];
+    }
+
+    free(itmp);
+  }
+
+  return 0;
+}
Index: astropy-4.2.1/cextern/wcslib/C/wcsfix.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsfix.h
+++ astropy-4.2.1/cextern/wcslib/C/wcsfix.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsfix.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsfix.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -57,6 +54,13 @@
 * consistency of pairs of keyvalues that define the same measure in two
 * different ways, for example, as a date and an MJD.
 *
+* A separate routine, wcspcx(), "regularizes" the linear transformation matrix
+* component (PCi_j) of the coordinate transformation to make it more human-
+* readable.  Where a coordinate description was constructed from CDi_j, it
+* decomposes it into PCi_j + CDELTi in a meaningful way.  Optionally, it can
+* also diagonalize the PCi_j matrix (as far as possible), i.e. undo the
+* transposition of axes in the intermediate pixel coordinate system.
+*
 * Non-standard keyvalues:
 * -----------------------
 *   AIPS-convention celestial projection types, NCP and GLS, and spectral
@@ -92,18 +96,17 @@
 *   header parser supplied with WCSLIB, refer to wcshdr.h.
 *
 * wcsfix() and wcsfixi() apply all of the corrections handled by the following
-* specific functions which may also be invoked separately:
+* specific functions, which may also be invoked separately:
 *
 *   - cdfix(): Sets the diagonal element of the CDi_ja matrix to 1.0 if all
 *     CDi_ja keywords associated with a particular axis are omitted.
 *
 *   - datfix(): recast an older DATE-OBS date format in dateobs to year-2000
-*     standard form.
-*
-*     Derive dateref from mjdref if not already set.  Alternatively, if
-*     dateref is set and mjdref isn't, then derive mjdref from it.  If both
-*     are set, then check consistency.  Likewise for dateobs and mjdobs;
-*     datebeg and mjdbeg; dateavg and mjdavg; and dateend and mjdend.
+*     standard form.  Derive dateref from mjdref if not already set.
+*     Alternatively, if dateref is set and mjdref isn't, then derive mjdref
+*     from it.  If both are set, then check consistency.  Likewise for dateobs
+*     and mjdobs; datebeg and mjdbeg; dateavg and mjdavg; and dateend and
+*     mjdend.
 *
 *   - obsfix(): if only one half of obsgeo[] is set, then derive the other
 *     half from it.  If both halves are set, then check consistency.
@@ -173,11 +176,14 @@
 * cdfix() - Fix erroneously omitted CDi_ja keywords
 * -------------------------------------------------
 * cdfix() sets the diagonal element of the CDi_ja matrix to unity if all
-* CDi_ja keywords associated with a given axis were omitted.  According to
+* CDi_ja keywords associated with a given axis were omitted.  According to WCS
 * Paper I, if any CDi_ja keywords at all are given in a FITS header then those
 * not given default to zero.  This results in a singular matrix with an
 * intersecting row and column of zeros.
 *
+* cdfix() is expected to be invoked before wcsset(), which will fail if these
+* errors have not been corrected.
+*
 * Given and returned:
 *   wcs       struct wcsprm*
 *                       Coordinate transformation parameters.
@@ -192,20 +198,22 @@
 * datfix() - Translate DATE-OBS and derive MJD-OBS or vice versa
 * --------------------------------------------------------------
 * datfix() translates the old DATE-OBS date format set in wcsprm::dateobs to
-* year-2000 standard form (yyyy-mm-ddThh:mm:ss).
-*
-* datfix() derives wcsprm::dateref from wcsprm::mjdref if not already set.
-* Alternatively, if dateref is set and mjdref isn't, then it derives mjdref
-* from it.  If both are set but disagree by more than 0.001 day (86.4 seconds)
-* then status 5 is returned.  Likewise for wcsprm::dateobs and wcsprm::mjdobs;
-* wcsprm::datebeg and wcsprm::mjdbeg; wcsprm::dateavg and wcsprm::mjdavg; and
-* wcsprm::dateend and wcsprm::mjdend.
+* year-2000 standard form (yyyy-mm-ddThh:mm:ss).  It derives wcsprm::dateref
+* from wcsprm::mjdref if not already set.  Alternatively, if dateref is set
+* and mjdref isn't, then it derives mjdref from it.  If both are set but
+* disagree by more than 0.001 day (86.4 seconds) then an error status is
+* returned.  Likewise for wcsprm::dateobs and wcsprm::mjdobs; wcsprm::datebeg
+* and wcsprm::mjdbeg; wcsprm::dateavg and wcsprm::mjdavg; and wcsprm::dateend
+* and wcsprm::mjdend.
 *
 * If neither dateobs nor mjdobs are set, but wcsprm::jepoch (primarily) or
 * wcsprm::bepoch is, then both are derived from it.  If jepoch and/or bepoch
 * are set but disagree with dateobs or mjdobs by more than 0.000002 year
 * (63.2 seconds), an informative message is produced.
 *
+* The translations done by datfix() do not affect and are not affected by
+* wcsset().
+*
 * Given and returned:
 *   wcs       struct wcsprm*
 *                       Coordinate transformation parameters.
@@ -222,13 +230,15 @@
 *                         1: Null wcsprm pointer passed.
 *                         5: Invalid parameter value.
 *
-*                       For returns > 1, a detailed error message is set in
-*                       wcsprm::err if enabled, see wcserr_enable().
+*                       For returns >= 0, a detailed message, whether
+*                       informative or an error message, may be set in
+*                       wcsprm::err if enabled, see wcserr_enable(), with
+*                       wcsprm::err.status set to FIXERR_DATE_FIX.
 *
 * Notes:
-*   The MJD algorithms used by datfix() are from D.A. Hatcher, 1984, QJRAS,
-*   25, 53-55, as modified by P.T. Wallace for use in SLALIB subroutines CLDJ
-*   and DJCL.
+*   1: The MJD algorithms used by datfix() are from D.A. Hatcher, 1984, QJRAS,
+*      25, 53-55, as modified by P.T. Wallace for use in SLALIB subroutines
+*      CLDJ and DJCL.
 *
 *
 * obsfix() - complete the OBSGEO-[XYZLBH] vector of observatory coordinates
@@ -239,6 +249,9 @@
 * it.  If both triplets are set, then it checks for consistency at the level
 * of 1 metre.
 *
+* The operations done by obsfix() do not affect and are not affected by
+* wcsset().
+*
 * Given:
 *   ctrl      int       Flag that controls behaviour if one triplet is
 *                       defined and the other is only partially defined:
@@ -261,8 +274,10 @@
 *                         1: Null wcsprm pointer passed.
 *                         5: Invalid parameter value.
 *
-*                       For returns > 1, a detailed error message is set in
-*                       wcsprm::err if enabled, see wcserr_enable().
+*                       For returns >= 0, a detailed message, whether
+*                       informative or an error message, may be set in
+*                       wcsprm::err if enabled, see wcserr_enable(), with
+*                       wcsprm::err.status set to FIXERR_OBS_FIX.
 *
 * Notes:
 *   1: While the International Terrestrial Reference System (ITRS) is based
@@ -318,6 +333,9 @@
 * unitfix() applies wcsutrn() to translate non-standard CUNITia keyvalues,
 * e.g. 'DEG' -> 'deg', also stripping off unnecessary whitespace.
 *
+* unitfix() is expected to be invoked before wcsset(), which will fail if
+* non-standard CUNITia keyvalues have not been translated.
+*
 * Given:
 *   ctrl      int       Do potentially unsafe translations described in the
 *                       usage notes to wcsutrn().
@@ -332,9 +350,10 @@
 *                         0: Success (an alias was applied).
 *                         1: Null wcsprm pointer passed.
 *
-*                       When units are translated (i.e. status 0), status -2
-*                       is set in the wcserr struct to allow an informative
-*                       message to be returned.
+*                       When units are translated (i.e. 0 is returned), an
+*                       informative message is set in wcsprm::err if enabled,
+*                       see wcserr_enable(), with wcsprm::err.status set to
+*                       FIXERR_UNITS_ALIAS.
 *
 *
 * spcfix() - Translate AIPS-convention spectral types
@@ -345,6 +364,16 @@
 *
 * Note that if wcs::specsys is already set then it will not be overridden.
 *
+* AIPS-convention spectral types set in CTYPEia are translated on-the-fly by
+* wcsset() but without modifying wcsprm::ctype[] or wcsprm::specsys.  That is,
+* only the information extracted from wcsprm::ctype[] is translated when
+* wcsset() fills in wcsprm::spc (spcprm struct).  spcfix() modifies
+* wcsprm::ctype[] so that if the header is subsequently written out, e.g. by
+* wcshdo(), then it will contain translated CTYPEia keyvalues.
+*
+* The operations done by spcfix() do not affect and are not affected by
+* wcsset().
+*
 * Given and returned:
 *   wcs       struct wcsprm*
 *                       Coordinate transformation parameters.  wcsprm::ctype[]
@@ -364,8 +393,10 @@
 *                         7: Ill-conditioned coordinate transformation
 *                            parameters.
 *
-*                       For returns > 1, a detailed error message is set in
-*                       wcsprm::err if enabled, see wcserr_enable().
+*                       For returns >= 0, a detailed message, whether
+*                       informative or an error message, may be set in
+*                       wcsprm::err if enabled, see wcserr_enable(), with
+*                       wcsprm::err.status set to FIXERR_SPC_UPDTE.
 *
 *
 * celfix() - Translate AIPS-convention celestial projection types
@@ -379,6 +410,18 @@
 * necessary.  Otherwise, error 2 will be returned if sufficient empty slots
 * are not already available for use.
 *
+* AIPS-convention celestial projection types set in CTYPEia are translated
+* on-the-fly by wcsset() but without modifying wcsprm::ctype[], wcsprm::pv[],
+* or wcsprm::npv.  That is, only the information extracted from
+* wcsprm::ctype[] is translated when wcsset() fills in wcsprm::cel (celprm
+* struct).  celfix() modifies wcsprm::ctype[], wcsprm::pv[], and wcsprm::npv
+* so that if the header is subsequently written out, e.g. by wcshdo(), then it
+* will contain translated CTYPEia keyvalues and the relevant PVi_ma.
+*
+* The operations done by celfix() do not affect and are not affected by
+* wcsset().  However, it uses information in the wcsprm struct provided by
+* wcsset(), and will invoke it if necessary.
+*
 * Given and returned:
 *   wcs       struct wcsprm*
 *                       Coordinate transformation parameters.  wcsprm::ctype[]
@@ -407,6 +450,10 @@
 * cylfix() fixes WCS keyvalues for malformed cylindrical projections that
 * suffer from the problem described in Sect. 7.3.4 of Paper I.
 *
+* cylfix() requires the wcsprm struct to have been set up by wcsset(), and
+* will invoke it if necessary.  After modification, the struct is reset on
+* return with an explicit call to wcsset().
+*
 * Given:
 *   naxis     const int []
 *                       Image axis lengths.
@@ -436,6 +483,98 @@
 *                       wcsprm::err if enabled, see wcserr_enable().
 *
 *
+* wcspcx() - regularize PCi_j
+* ---------------------------
+* wcspcx() "regularizes" the linear transformation matrix component of the
+* coordinate transformation (PCi_ja) to make it more human-readable.
+*
+* Normally, upon encountering a FITS header containing a CDi_ja matrix,
+* wcsset() simply treats it as PCi_ja and sets CDELTia to unity.  However,
+* wcspcx() decomposes CDi_ja into PCi_ja and CDELTia in such a way that
+* CDELTia form meaningful scaling parameters.  In practice, the residual
+* PCi_ja matrix will often then be orthogonal, i.e. unity, or describing a
+* pure rotation, axis permutation, or reflection, or a combination thereof.
+*
+* The decomposition is based on normalizing the length in the transformed
+* system (i.e. intermediate pixel coordinates) of the orthonormal basis
+* vectors of the pixel coordinate system.  This deviates slightly from the
+* prescription given by Eq. (4) of WCS Paper I, namely Sum(j=1,N)(PCi_ja)² = 1,
+* in replacing the sum over j with the sum over i.  Consequently, the columns
+* of PCi_ja will consist of unit vectors.  In practice, especially in cubes
+* and higher dimensional images, at least some pairs of these unit vectors, if
+* not all, will often be orthogonal or close to orthogonal.
+*
+* The sign of CDELTia is chosen to make the PCi_ja matrix as close to the,
+* possibly permuted, unit matrix as possible, except that where the coordinate
+* description contains a pair of celestial axes, the sign of CDELTia is set
+* negative for the longitude axis and positive for the latitude axis.
+*
+* Optionally, rows of the PCi_ja matrix may also be permuted to diagonalize
+* it as far as possible, thus undoing any transposition of axes in the
+* intermdiate pixel coordinate system.
+*
+* If the coordinate description contains a celestial plane, then the angle of
+* rotation of each of the basis vectors associated with the celestial axes is
+* returned.  For a pure rotation the two angles should be identical.  Any
+* difference between them is a measure of axis skewness.
+*
+* The decomposition is not performed for axes involving a sequent distortion
+* function that is defined in terms of CDi_ja, such as TPV, TNX, or ZPX, which
+* always are.  The independent variables of the polynomial are therefore
+* intermediate world coordinates rather than intermediate pixel coordinates.
+* Because sequent distortions are always applied before CDELTia, if CDi_ja was
+* translated to PCi_ja plus CDELTia, then the distortion would be altered
+* unless the polynomial coefficients were also adjusted to account for the
+* change of scale.
+*
+* wcspcx() requires the wcsprm struct to have been set up by wcsset(), and
+* will invoke it if necessary.  The wcsprm struct is reset on return with an
+* explicit call to wcsset().
+*
+* Given and returned:
+*   wcs       struct wcsprm*
+*                       Coordinate transformation parameters.
+*
+* Given:
+*   dopc      int       If 1, then PCi_ja and CDELTia, as given, will be
+*                       recomposed according to the above prescription.  If 0,
+*                       the operation is restricted to decomposing CDi_ja.
+*
+*   permute   int       If 1, then after decomposition (or recomposition),
+*                       permute rows of PCi_ja to make the axes of the
+*                       intermediate pixel coordinate system match as closely
+*                       as possible those of the pixel coordinates.  That is,
+*                       make it as close to a diagonal matrix as possible.
+*                       However, celestial axes are special in always being
+*                       paired, with the longitude axis preceding the latitude
+*                       axis.
+*
+*                       All WCS entities indexed by i, such as CTYPEia,
+*                       CRVALia, CDELTia, etc., including coordinate lookup
+*                       tables, will also be permuted as necessary to account
+*                       for the change to PCi_ja.  This does not apply to
+*                       CRPIXja, nor prior distortion functions.  These
+*                       operate on pixel coordinates, which are not affected
+*                       by the permutation.
+*
+* Returned:
+*   rotn      double[2] Rotation angle [deg] of each basis vector associated
+*                       with the celestial axes.  For a pure rotation the two
+*                       angles should be identical.  Any difference between
+*                       them is a measure of axis skewness.
+*
+*                       May be set to the NULL pointer if this information is
+*                       not required.
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Success.
+*                         1: Null wcsprm pointer passed.
+*                         2: Memory allocation failed.
+*                         5: CDi_j matrix not used.
+*                         6: Sequent distortion function present.
+*
+*
 * Global variable: const char *wcsfix_errmsg[] - Status return messages
 * ---------------------------------------------------------------------
 * Error messages to match the status value returned from each function.
@@ -465,29 +604,27 @@ extern const char *wcsfix_errmsg[];
 #define cylfix_errmsg wcsfix_errmsg
 
 enum wcsfix_errmsg_enum {
-  FIXERR_OBSGEO_FIX       = -5, /* Observatory coordinates amended. */
-  FIXERR_DATE_FIX         = -4, /* Date string reformatted. */
-  FIXERR_SPC_UPDATE       = -3, /* Spectral axis type modified. */
-  FIXERR_UNITS_ALIAS      = -2,	/* Units alias translation. */
-  FIXERR_NO_CHANGE        = -1,	/* No change. */
-  FIXERR_SUCCESS          =  0,	/* Success. */
-  FIXERR_NULL_POINTER     =  1,	/* Null wcsprm pointer passed. */
-  FIXERR_MEMORY           =  2,	/* Memory allocation failed. */
-  FIXERR_SINGULAR_MTX     =  3,	/* Linear transformation matrix is
-				   singular. */
-  FIXERR_BAD_CTYPE        =  4,	/* Inconsistent or unrecognized coordinate
-				   axis types. */
-  FIXERR_BAD_PARAM        =  5,	/* Invalid parameter value. */
-  FIXERR_BAD_COORD_TRANS  =  6,	/* Invalid coordinate transformation
-				   parameters. */
-  FIXERR_ILL_COORD_TRANS  =  7,	/* Ill-conditioned coordinate transformation
-				   parameters. */
-  FIXERR_BAD_CORNER_PIX   =  8,	/* All of the corner pixel coordinates are
-				   invalid. */
-  FIXERR_NO_REF_PIX_COORD =  9,	/* Could not determine reference pixel
-				   coordinate. */
-  FIXERR_NO_REF_PIX_VAL   = 10	/* Could not determine reference pixel
-				   value. */
+  FIXERR_OBSGEO_FIX       = -5, // Observatory coordinates amended.
+  FIXERR_DATE_FIX         = -4, // Date string reformatted.
+  FIXERR_SPC_UPDATE       = -3, // Spectral axis type modified.
+  FIXERR_UNITS_ALIAS      = -2,	// Units alias translation.
+  FIXERR_NO_CHANGE        = -1,	// No change.
+  FIXERR_SUCCESS          =  0,	// Success.
+  FIXERR_NULL_POINTER     =  1,	// Null wcsprm pointer passed.
+  FIXERR_MEMORY           =  2,	// Memory allocation failed.
+  FIXERR_SINGULAR_MTX     =  3,	// Linear transformation matrix is singular.
+  FIXERR_BAD_CTYPE        =  4,	// Inconsistent or unrecognized coordinate
+				// axis types.
+  FIXERR_BAD_PARAM        =  5,	// Invalid parameter value.
+  FIXERR_BAD_COORD_TRANS  =  6,	// Invalid coordinate transformation
+				// parameters.
+  FIXERR_ILL_COORD_TRANS  =  7,	// Ill-conditioned coordinate transformation
+				// parameters.
+  FIXERR_BAD_CORNER_PIX   =  8,	// All of the corner pixel coordinates are
+				// invalid.
+  FIXERR_NO_REF_PIX_COORD =  9,	// Could not determine reference pixel
+				// coordinate.
+  FIXERR_NO_REF_PIX_VAL   = 10	// Could not determine reference pixel value.
 };
 
 int wcsfix(int ctrl, const int naxis[], struct wcsprm *wcs, int stat[]);
@@ -509,9 +646,11 @@ int celfix(struct wcsprm *wcs);
 
 int cylfix(const int naxis[], struct wcsprm *wcs);
 
+int wcspcx(struct wcsprm *wcs, int dopc, int permute, double rotn[2]);
+
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* WCSLIB_WCSFIX */
+#endif // WCSLIB_WCSFIX
Index: astropy-4.2.1/cextern/wcslib/C/wcshdr.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcshdr.c
+++ astropy-4.2.1/cextern/wcslib/C/wcshdr.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcshdr.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcshdr.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <ctype.h>
@@ -44,7 +41,7 @@ extern const int WCSSET;
 
 extern const int DIS_DOTPD;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *wcshdr_errmsg[] = {
   "Success",
   "Null wcsprm pointer passed",
@@ -53,27 +50,27 @@ const char *wcshdr_errmsg[] = {
   "Fatal error returned by Flex parser",
   "Invalid tabular parameters"};
 
-/* Map error returns for lower-level routines. */
+// Map error returns for lower-level routines.
 const int wcshdr_taberr[] = {
-  WCSHDRERR_SUCCESS,		/*  0: TABERR_SUCCESS         */
-  WCSHDRERR_NULL_POINTER,	/*  1: TABERR_NULL_POINTER    */
-  WCSHDRERR_MEMORY,		/*  2: TABERR_MEMORY          */
-  WCSHDRERR_BAD_TABULAR_PARAMS	/*  3: TABERR_BAD_PARAMS      */
-				/*  4: TABERR_BAD_X           */
-				/*  5: TABERR_BAD_WORLD       */
+  WCSHDRERR_SUCCESS,		//  0: TABERR_SUCCESS
+  WCSHDRERR_NULL_POINTER,	//  1: TABERR_NULL_POINTER
+  WCSHDRERR_MEMORY,		//  2: TABERR_MEMORY
+  WCSHDRERR_BAD_TABULAR_PARAMS	//  3: TABERR_BAD_PARAMS
+				//  4: TABERR_BAD_X
+				//  5: TABERR_BAD_WORLD
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define WCSHDR_ERRMSG(status) WCSERR_SET(status), wcshdr_errmsg[status]
 
-/* Internal helper functions, not for general use. */
+// Internal helper functions, not for general use.
 static void wcshdo_format(int, int, const double [], char *);
 static void wcshdo_tpdterm(int, int, char *);
 static void wcshdo_util(int, const char [], const char [], int, const char [],
   int, int, int, char, int, int [], char [], const char [], int *, char **,
   int *);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcstab(struct wcsprm *wcs)
 
@@ -90,7 +87,7 @@ int wcstab(struct wcsprm *wcs)
   if (wcs == 0x0) return WCSHDRERR_NULL_POINTER;
   err = &(wcs->err);
 
-  /* Free memory previously allocated by wcstab(). */
+  // Free memory previously allocated by wcstab().
   if (wcs->flag != -1 && wcs->m_flag == WCSSET) {
     if (wcs->wtb == wcs->m_wtb) wcs->wtb = 0x0;
     if (wcs->tab == wcs->m_tab) wcs->tab = 0x0;
@@ -111,7 +108,7 @@ int wcstab(struct wcsprm *wcs)
   wcs->tab  = 0x0;
 
 
-  /* Determine the number of -TAB axes. */
+  // Determine the number of -TAB axes.
   naxis = wcs->naxis;
   if (!(tabax = calloc(naxis, sizeof(int)))) {
     return wcserr_set(WCSHDR_ERRMSG(WCSHDRERR_MEMORY));
@@ -119,7 +116,7 @@ int wcstab(struct wcsprm *wcs)
 
   ntabax = 0;
   for (i = 0; i < naxis; i++) {
-    /* Null fill. */
+    // Null fill.
     wcsutil_null_fill(72, wcs->ctype[i]);
 
     if (!strcmp(wcs->ctype[i]+4, "-TAB")) {
@@ -130,13 +127,13 @@ int wcstab(struct wcsprm *wcs)
   }
 
   if (ntabax == 0) {
-    /* No lookup tables. */
+    // No lookup tables.
     status = 0;
     goto cleanup;
   }
 
 
-  /* Collect information from the PSi_ma and PVi_ma keyvalues. */
+  // Collect information from the PSi_ma and PVi_ma keyvalues.
   if (!((PSi_0a = calloc(ntabax, sizeof(char[72]))) &&
         (PVi_1a = calloc(ntabax, sizeof(int)))      &&
         (PVi_2a = calloc(ntabax, sizeof(int)))      &&
@@ -149,7 +146,7 @@ int wcstab(struct wcsprm *wcs)
   }
 
   for (itabax = 0; itabax < ntabax; itabax++) {
-    /* Remember that calloc() zeroes allocated memory. */
+    // Remember that calloc() zeroes allocated memory.
     PVi_1a[itabax] = 1;
     PVi_2a[itabax] = 1;
     PVi_3a[itabax] = 1;
@@ -160,17 +157,17 @@ int wcstab(struct wcsprm *wcs)
     if (itabax >= 0) {
       switch (wcs->ps[ip].m) {
       case 0:
-        /* EXTNAME. */
+        // EXTNAME.
         strcpy(PSi_0a[itabax], wcs->ps[ip].value);
         wcsutil_null_fill(72, PSi_0a[itabax]);
         break;
       case 1:
-        /* TTYPEn for coordinate array. */
+        // TTYPEn for coordinate array.
         strcpy(PSi_1a[itabax], wcs->ps[ip].value);
         wcsutil_null_fill(72, PSi_1a[itabax]);
         break;
       case 2:
-        /* TTYPEn for index vector. */
+        // TTYPEn for index vector.
         strcpy(PSi_2a[itabax], wcs->ps[ip].value);
         wcsutil_null_fill(72, PSi_2a[itabax]);
         break;
@@ -183,15 +180,15 @@ int wcstab(struct wcsprm *wcs)
     if (itabax >= 0) {
       switch (wcs->pv[ip].m) {
       case 1:
-        /* EXTVER. */
+        // EXTVER.
         PVi_1a[itabax] = (int)(wcs->pv[ip].value + 0.5);
         break;
       case 2:
-        /* EXTLEVEL. */
+        // EXTLEVEL.
         PVi_2a[itabax] = (int)(wcs->pv[ip].value + 0.5);
         break;
       case 3:
-        /* Table axis number. */
+        // Table axis number.
         PVi_3a[itabax] = (int)(wcs->pv[ip].value + 0.5);
         break;
       }
@@ -199,9 +196,9 @@ int wcstab(struct wcsprm *wcs)
   }
 
 
-  /* Determine the number of independent tables. */
+  // Determine the number of independent tables.
   for (itabax = 0; itabax < ntabax; itabax++) {
-    /* These have no defaults. */
+    // These have no defaults.
     if (!PSi_0a[itabax][0] || !PSi_1a[itabax][0]) {
       status = wcserr_set(WCSERR_SET(WCSHDRERR_BAD_TABULAR_PARAMS),
         "Invalid tabular parameters: PSi_0a and PSi_1a must be specified");
@@ -210,8 +207,8 @@ int wcstab(struct wcsprm *wcs)
 
     tabidx[itabax] = -1;
     for (jtabax = 0; jtabax < i; jtabax++) {
-      /* EXTNAME, EXTVER, EXTLEVEL, and TTYPEn for the coordinate array */
-      /* must match for each axis of a multi-dimensional lookup table.  */
+      // EXTNAME, EXTVER, EXTLEVEL, and TTYPEn for the coordinate array
+      // must match for each axis of a multi-dimensional lookup table.
       if (strcmp(PSi_0a[itabax], PSi_0a[jtabax]) == 0 &&
           strcmp(PSi_1a[itabax], PSi_1a[jtabax]) == 0 &&
           PVi_1a[itabax] == PVi_1a[jtabax] &&
@@ -233,11 +230,11 @@ int wcstab(struct wcsprm *wcs)
   }
   wcs->m_tab = wcs->tab;
 
-  /* Table dimensionality; find the largest axis number. */
+  // Table dimensionality; find the largest axis number.
   for (itabax = 0; itabax < ntabax; itabax++) {
     tabp = wcs->tab + tabidx[itabax];
 
-    /* PVi_3a records the 1-relative table axis number. */
+    // PVi_3a records the 1-relative table axis number.
     if (PVi_3a[itabax] > tabp->M) {
       tabp->M = PVi_3a[itabax];
     }
@@ -251,14 +248,14 @@ int wcstab(struct wcsprm *wcs)
   }
 
 
-  /* Copy parameters into the tabprm structs. */
+  // Copy parameters into the tabprm structs.
   for (i = 0; i < naxis; i++) {
     if ((itabax = tabax[i]) < 0) {
-      /* Not a -TAB axis. */
+      // Not a -TAB axis.
       continue;
     }
 
-    /* PVi_3a records the 1-relative table axis number. */
+    // PVi_3a records the 1-relative table axis number.
     m = PVi_3a[itabax] - 1;
 
     tabp = wcs->tab + tabidx[itabax];
@@ -266,7 +263,7 @@ int wcstab(struct wcsprm *wcs)
     tabp->crval[m] = wcs->crval[i];
   }
 
-  /* Check for completeness. */
+  // Check for completeness.
   for (itab = 0; itab < wcs->ntab; itab++) {
     for (m = 0; m < wcs->tab[itab].M; m++) {
       if (wcs->tab[itab].map[m] < 0) {
@@ -278,18 +275,18 @@ int wcstab(struct wcsprm *wcs)
   }
 
 
-  /* Set up for reading the arrays; how many arrays are there? */
+  // Set up for reading the arrays; how many arrays are there?
   for (itabax = 0; itabax < ntabax; itabax++) {
-    /* Does this -TAB axis have a non-degenerate index array? */
+    // Does this -TAB axis have a non-degenerate index array?
     if (PSi_2a[itabax][0]) {
       wcs->nwtb++;
     }
   }
 
-  /* Add one coordinate array for each table. */
+  // Add one coordinate array for each table.
   wcs->nwtb += wcs->ntab;
 
-  /* Allocate memory for structs to be returned. */
+  // Allocate memory for structs to be returned.
   if (!(wcs->wtb = calloc(wcs->nwtb, sizeof(struct wtbarr)))) {
     wcs->nwtb = 0;
 
@@ -298,7 +295,7 @@ int wcstab(struct wcsprm *wcs)
   }
   wcs->m_wtb = wcs->wtb;
 
-  /* Set pointers for the index and coordinate arrays. */
+  // Set pointers for the index and coordinate arrays.
   wtbp = wcs->wtb;
   for (itab = 0; itab < wcs->ntab; itab++) {
     getcrd = 1;
@@ -306,7 +303,7 @@ int wcstab(struct wcsprm *wcs)
       if (tabidx[itabax] != itab) continue;
 
       if (getcrd) {
-        /* Coordinate array. */
+        // Coordinate array.
         wtbp->i = itabax + 1;
         wtbp->m = PVi_3a[itabax];
         wtbp->kind = 'c';
@@ -320,7 +317,7 @@ int wcstab(struct wcsprm *wcs)
         wtbp->dimlen = wcs->tab[itab].K;
         wtbp->arrayp = &(wcs->tab[itab].coord);
 
-        /* Signal for tabset() to take this memory. */
+        // Signal for tabset() to take this memory.
         wcs->tab[itab].m_coord = (double *)0x1;
 
         wtbp++;
@@ -328,7 +325,7 @@ int wcstab(struct wcsprm *wcs)
       }
 
       if (PSi_2a[itabax][0]) {
-        /* Index array. */
+        // Index array.
         wtbp->i = itabax + 1;
         wtbp->m = PVi_3a[itabax];
         wtbp->kind = 'i';
@@ -343,7 +340,7 @@ int wcstab(struct wcsprm *wcs)
         wtbp->dimlen = wcs->tab[itab].K + m;
         wtbp->arrayp = wcs->tab[itab].index + m;
 
-        /* Signal for tabset() to take this memory. */
+        // Signal for tabset() to take this memory.
         wcs->tab[itab].m_indxs[m] = (double *)0x1;
 
         wtbp++;
@@ -371,7 +368,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsidx(int nwcs, struct wcsprm **wcs, int alts[27])
 
@@ -403,7 +400,7 @@ int wcsidx(int nwcs, struct wcsprm **wcs
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsbdx(int nwcs, struct wcsprm **wcs, int type, short alts[1000][28])
 
@@ -433,7 +430,7 @@ int wcsbdx(int nwcs, struct wcsprm **wcs
     }
 
     if (type) {
-      /* Pixel list. */
+      // Pixel list.
       if (wcsp->colax[0]) {
         for (i = 0; i < wcsp->naxis; i++) {
           alts[wcsp->colax[i]][a]  = iwcs;
@@ -445,7 +442,7 @@ int wcsbdx(int nwcs, struct wcsprm **wcs
       }
 
     } else {
-      /* Binary table image array. */
+      // Binary table image array.
       if (wcsp->colnum) {
         alts[wcsp->colnum][a] = iwcs;
         alts[wcsp->colnum][27]++;
@@ -459,7 +456,7 @@ int wcsbdx(int nwcs, struct wcsprm **wcs
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsvfree(int *nwcs, struct wcsprm **wcs)
 
@@ -484,19 +481,19 @@ int wcsvfree(int *nwcs, struct wcsprm **
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
-#define I_DTYPE   0	/* Distortion type code.                            */
-#define I_NIPARM  1	/* Full (allocated) length of iparm[].              */
-#define I_NDPARM  2	/* No. of parameters in dparm[], excl. work space.  */
-#define I_DOCORR  3	/* True if distortion func computes a correction.   */
-#define I_TPDNCO  4	/* No. of TPD coefficients, forward...              */
-#define I_TPDINV  5	/* ...and inverse.                                  */
-#define I_TPDAUX  6	/* True if auxiliary variables are used.            */
-#define I_TPDRAD  7	/* True if the radial variable is used.             */
+//----------------------------------------------------------------------------
+// Matching the definitions in dis.c.
+#define I_DTYPE   0	// Distortion type code.
+#define I_NIPARM  1	// Full (allocated) length of iparm[].
+#define I_NDPARM  2	// No. of parameters in dparm[], excl. work space.
+#define I_TPDNCO  3	// No. of TPD coefficients, forward...
+#define I_TPDINV  4	// ...and inverse.
+#define I_TPDAUX  5	// True if auxiliary variables are used.
+#define I_TPDRAD  6	// True if the radial variable is used.
 
 int wcshdo(int ctrl, struct wcsprm *wcs, int *nkeyrec, char **header)
 
-/* ::: CUBEFACE and STOKES handling? */
+// ::: CUBEFACE and STOKES handling?
 
 {
   static const char *function = "wcshdo";
@@ -532,7 +529,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   }
 
 
-  /* These are mainly for convenience. */
+  // These are mainly for convenience.
   alt = wcs->alt[0];
   if (alt == ' ') alt = '\0';
   colnum = wcs->colnum;
@@ -550,7 +547,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   }
 
 
-  /* Initialize floating point format control. */
+  // Initialize floating point format control.
   *format = '\0';
   if (ctrl & WCSHDO_P17) {
     strcpy(format, "% 20.17G");
@@ -577,14 +574,14 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   dofmt = (*format == '\0');
 
 
-  /* WCS dimension. */
+  // WCS dimension.
   if (!pixlist) {
     sprintf(keyvalue, "%20d", naxis);
     wcshdo_util(ctrl, "WCSAXES", "WCAX", 0, 0x0, 0, 0, 0, alt, colnum, colax,
       keyvalue, "Number of coordinate axes", nkeyrec, header, &status);
   }
 
-  /* Reference pixel coordinates. */
+  // Reference pixel coordinates.
   if (dofmt) wcshdo_format('G', naxis, wcs->crpix, format);
   for (j = 0; j < naxis; j++) {
     wcsutil_double2str(keyvalue, format, wcs->crpix[j]);
@@ -593,7 +590,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       header, &status);
   }
 
-  /* Linear transformation matrix. */
+  // Linear transformation matrix.
   if (dofmt) wcshdo_format('G', naxis*naxis, wcs->pc, format);
   k = 0;
   for (i = 0; i < naxis; i++) {
@@ -612,7 +609,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Coordinate increment at reference point. */
+  // Coordinate increment at reference point.
   if (dofmt) wcshdo_format('G', naxis, wcs->cdelt, format);
   for (i = 0; i < naxis; i++) {
     wcsutil_double2str(keyvalue, format, wcs->cdelt[i]);
@@ -623,7 +620,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       colnum, colax, keyvalue, comment, nkeyrec, header, &status);
   }
 
-  /* Units of coordinate increment and reference value. */
+  // Units of coordinate increment and reference value.
   for (i = 0; i < naxis; i++) {
     if (wcs->cunit[i][0] == '\0') continue;
 
@@ -633,9 +630,9 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* May need to alter ctype for particular distortions so do basic checks */
-  /* now.  Note that SIP, TPV, DSS, TNX, and ZPX are restricted to exactly */
-  /* two axes and cannot coexist with other distortion types.              */
+  // May need to alter ctype for particular distortions so do basic checks
+  // now.  Note that SIP, TPV, DSS, TNX, and ZPX are restricted to exactly
+  // two axes and cannot coexist with other distortion types.
   dosip = 0;
   dotpv = 0;
   dotpd = 0;
@@ -643,8 +640,8 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   if ((dis = wcs->lin.dispre)) {
     for (i = 0; i < naxis; i++) {
       if (strcmp(dis->dtype[i], "SIP") == 0) {
-        /* Simple Imaging Polynomial (SIP).  Write it in its native form  */
-        /* if possible, unless specifically requested to write it as TPD. */
+        // Simple Imaging Polynomial (SIP).  Write it in its native form
+        // if possible, unless specifically requested to write it as TPD.
         dotpd = (dis->iparm[i][I_DTYPE] & DIS_DOTPD);
 
         if (!dotpd) {;
@@ -663,13 +660,13 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
               dis->scale[0][1]  != 1.0 ||
               dis->scale[1][0]  != 1.0 ||
               dis->scale[1][1]  != 1.0) {
-            /* Must have been read as a 'SIP' distortion, CPDISja = 'SIP'. */
-            /* Cannot be written as native SIP so write it as TPD.         */
+            // Must have been read as a 'SIP' distortion, CPDISja = 'SIP'.
+            // Cannot be written as native SIP so write it as TPD.
             dotpd = DIS_DOTPD;
           } else if (strncmp(wcs->ctype[0], "RA---TAN", 8) ||
                      strncmp(wcs->ctype[1], "DEC--TAN", 8)) {
-            /* Must have been permuted by wcssub(). */
-            /* Native SIP doesn't have axis mapping so write it as TPD. */
+            // Must have been permuted by wcssub().
+            // Native SIP doesn't have axis mapping so write it as TPD.
             dotpd = DIS_DOTPD;
           }
 
@@ -688,8 +685,8 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   if ((dis = wcs->lin.disseq)) {
     for (i = 0; i < naxis; i++) {
       if (strcmp(dis->dtype[i], "TPV") == 0) {
-        /* TPV "projection".  Write it in its native form if possible, */
-        /* unless specifically requested to write it as TPD.           */
+        // TPV "projection".  Write it in its native form if possible,
+        // unless specifically requested to write it as TPD.
         dotpd = (dis->iparm[i][I_DTYPE] & DIS_DOTPD);
 
         if (!dotpd) {;
@@ -705,8 +702,8 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
               dis->scale[wcs->lng][wcs->lat]  != 1.0 ||
               dis->scale[wcs->lat][wcs->lng]  != 1.0 ||
               dis->scale[wcs->lat][wcs->lat]  != 1.0) {
-            /* Must have been read as a 'TPV' distortion, CPDISja = 'TPV'. */
-            /* Cannot be written as native TPV so write it as TPD.         */
+            // Must have been read as a 'TPV' distortion, CPDISja = 'TPV'.
+            // Cannot be written as native TPV so write it as TPD.
             dotpd = DIS_DOTPD;
           }
 
@@ -720,12 +717,12 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
         break;
 
       } else if (strcmp(dis->dtype[i], "DSS") == 0) {
-        /* Always written as TPD. */
+        // Always written as TPD.
         dotpd = DIS_DOTPD;
         strcpy(tpdsrc, dis->dtype[i]);
 
       } else if (strncmp(dis->dtype[i], "WAT", 3) == 0) {
-        /* Always written as TPD. */
+        // Always written as TPD.
         dotpd = DIS_DOTPD;
         strcpy(tpdsrc, dis->dtype[i]+4);
 
@@ -740,7 +737,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Coordinate type. */
+  // Coordinate type.
   for (i = 0; i < naxis; i++) {
     if (wcs->ctype[i][0] == '\0') continue;
 
@@ -749,12 +746,12 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
 
     ctypei = keyvalue + 1;
     if (i == wcs->lng || i == wcs->lat) {
-      /* Alter ctype for particular distortions. */
+      // Alter ctype for particular distortions.
       if (dosip) {
-        /* It could have come in as CPDISja = 'SIP'. */
+        // It could have come in as CPDISja = 'SIP'.
         strcpy(ctypei+8, "-SIP'");
       } else if (dotpv) {
-        /* Reinstate projection code edited by wcsset(). */
+        // Reinstate projection code edited by wcsset().
         strcpy(ctypei+4, "-TPV'");
       }
 
@@ -824,7 +821,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       colnum, colax, keyvalue, comment, nkeyrec, header, &status);
   }
 
-  /* Coordinate value at reference point. */
+  // Coordinate value at reference point.
   for (i = 0; i < naxis; i++) {
     if (dofmt) wcshdo_format('G', 1, wcs->crval+i, format);
     wcsutil_double2str(keyvalue, format, wcs->crval[i]);
@@ -835,7 +832,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       colnum, colax, keyvalue, comment, nkeyrec, header, &status);
   }
 
-  /* Parameter values. */
+  // Parameter values.
   if (dofmt) strcpy(format, "%20.12G");
   for (k = 0; k < wcs->npv; k++) {
     wcsutil_double2str(keyvalue, format, (wcs->pv[k]).value);
@@ -887,7 +884,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* Celestial and spectral transformation parameters. */
+  // Celestial and spectral transformation parameters.
   if (!undefined(wcs->lonpole)) {
     wcsutil_double2str(keyvalue, format, wcs->lonpole);
     wcshdo_util(ctrl, "LONPOLE", "LONP", 0, 0x0, 0, 0, 0, alt,
@@ -916,10 +913,10 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* - - - - - - - - - - - - - - - - Auxiliary coordinate axis information. */
+  // - - - - - - - - - - - - - - - - -  Auxiliary coordinate axis information.
   sprintf(timeunit, "%.15s", wcs->timeunit[0] ? wcs->timeunit : "s");
 
-  /* Coordinate axis title. */
+  // Coordinate axis title.
   if (wcs->cname) {
     for (i = 0; i < naxis; i++) {
       if (wcs->cname[i][0] == '\0') continue;
@@ -931,7 +928,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Random error in coordinate. */
+  // Random error in coordinate.
   if (wcs->crder) {
     for (i = 0; i < naxis; i++) {
       if (undefined(wcs->crder[i])) continue;
@@ -945,7 +942,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Systematic error in coordinate. */
+  // Systematic error in coordinate.
   if (wcs->csyer) {
     for (i = 0; i < naxis; i++) {
       if (undefined(wcs->csyer[i])) continue;
@@ -959,7 +956,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Time at zero point of phase axis. */
+  // Time at zero point of phase axis.
   if (wcs->czphs) {
     for (i = 0; i < naxis; i++) {
       if (undefined(wcs->czphs[i])) continue;
@@ -971,7 +968,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Period of phase axis. */
+  // Period of phase axis.
   if (wcs->cperi) {
     for (i = 0; i < naxis; i++) {
       if (undefined(wcs->cperi[i])) continue;
@@ -983,9 +980,9 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* - - - - - - - - - - - - - - - - - - - - - -  Coordinate system title.  */
+  // - - - - - - - - - - - - - - - - - - - - - - - -  Coordinate system title.
 
-  /* Coordinate system title. */
+  // Coordinate system title.
   if (wcs->wcsname[0]) {
     sprintf(keyvalue, "'%s'", wcs->wcsname);
     if (bintab) {
@@ -993,59 +990,59 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
         colnum, colax, keyvalue, "Coordinate system title",
         nkeyrec, header, &status);
     } else {
-      /* TWCS was a mistake. */
+      // TWCS was a mistake.
       wcshdo_util(ctrl, "WCSNAME", "TWCS", WCSHDO_WCSNna, "WCSN", 0, 0, 0,
         alt, colnum, colax, keyvalue, "Coordinate system title",
         nkeyrec, header, &status);
     }
   }
 
-  /* - - - - - - - - - - - - - - - - Time reference system and measurement. */
+  // - - - - - - - - - - - - - - - - -  Time reference system and measurement.
 
-  /* Time scale. */
+  // Time scale.
   if (wcs->timesys[0]) {
     sprintf(keyvalue, "'%s'", wcs->timesys);
     wcshdo_util(ctrl, "TIMESYS", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Time scale", nkeyrec, header, &status);
   }
 
-  /* Time reference position. */
+  // Time reference position.
   if (wcs->trefpos[0]) {
     sprintf(keyvalue, "'%s'", wcs->trefpos);
     wcshdo_util(ctrl, "TREFPOS", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Time reference position", nkeyrec, header, &status);
   }
 
-  /* Time reference direction. */
+  // Time reference direction.
   if (wcs->trefdir[0]) {
     sprintf(keyvalue, "'%s'", wcs->trefdir);
     wcshdo_util(ctrl, "TREFDIR", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Time reference direction", nkeyrec, header, &status);
   }
 
-  /* Ephemerides used for pathlength delay calculation. */
+  // Ephemerides used for pathlength delay calculation.
   if (wcs->plephem[0]) {
     sprintf(keyvalue, "'%s'", wcs->plephem);
     wcshdo_util(ctrl, "PLEPHEM", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Ephemerides used for pathlength delays", nkeyrec, header, &status);
   }
 
-  /* Time units. */
+  // Time units.
   if (wcs->timeunit[0]) {
     sprintf(keyvalue, "'%s'", wcs->timeunit);
     wcshdo_util(ctrl, "TIMEUNIT", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Time units", nkeyrec, header, &status);
   }
 
-  /* Fiducial (reference) time. */
+  // Fiducial (reference) time.
   if (wcs->mjdref[0] == 0.0 && wcs->mjdref[1] == 0.0) {
-    /* MJD of fiducial time (simplified if it takes its default value). */
+    // MJD of fiducial time (simplified if it takes its default value).
     wcsutil_double2str(keyvalue, format, 0.0);
     wcshdo_util(ctrl, "MJDREF", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "[d] MJD of fiducial time", nkeyrec, header, &status);
 
   } else {
-    /* ISO-8601 fiducial time. */
+    // ISO-8601 fiducial time.
     if (wcs->dateref[0]) {
       sprintf(keyvalue, "'%s'", wcs->dateref);
       wcshdo_util(ctrl, "DATEREF", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0,
@@ -1053,7 +1050,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
 
     if (wcs->mjdref[1] == 0.0) {
-      /* MJD of fiducial time (no fractional part). */
+      // MJD of fiducial time (no fractional part).
       if (!undefined(wcs->mjdref[0])) {
         wcsutil_double2str(keyvalue, format, wcs->mjdref[0]);
         wcshdo_util(ctrl, "MJDREF", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0,
@@ -1061,7 +1058,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       }
 
     } else {
-      /* MJD of fiducial time, integer part. */
+      // MJD of fiducial time, integer part.
       if (!undefined(wcs->mjdref[0])) {
         wcsutil_double2str(keyvalue, format, wcs->mjdref[0]);
         wcshdo_util(ctrl, "MJDREFI", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0,
@@ -1069,7 +1066,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           header, &status);
       }
 
-      /* MJD of fiducial time, fractional part. */
+      // MJD of fiducial time, fractional part.
       if (!undefined(wcs->mjdref[1])) {
         wcsutil_double2str(keyvalue, format, wcs->mjdref[1]);
         wcshdo_util(ctrl, "MJDREFF", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0,
@@ -1079,7 +1076,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Clock correction. */
+  // Clock correction.
   if (!undefined(wcs->timeoffs)) {
     wcsutil_double2str(keyvalue, format, wcs->timeoffs);
     sprintf(comment, "[%s] Clock correction", timeunit);
@@ -1087,25 +1084,25 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* - - - - - - - - - - - - - - - - - - - - Data timestamps and durations. */
+  // - - - - - - - - - - - - - - - - - - - - -  Data timestamps and durations.
 
-  /* ISO-8601 time of observation. */
+  // ISO-8601 time of observation.
   if (wcs->dateobs[0]) {
     sprintf(keyvalue, "'%s'", wcs->dateobs);
     strcpy(comment, "ISO-8601 time of observation");
 
     if (ctrl & 1) {
-      /* Allow DOBSn. */
+      // Allow DOBSn.
       wcshdo_util(ctrl, "DATE-OBS", "DOBS", WCSHDO_DOBSn, 0x0, 0, 0, 0, ' ',
         colnum, colax, keyvalue, comment, nkeyrec, header, &status);
     } else {
-      /* Force DATE-OBS. */
+      // Force DATE-OBS.
       wcshdo_util(ctrl, "DATE-OBS", 0x0, 0, 0x0, 0, 0, 0, ' ',
         0, 0x0, keyvalue, comment, nkeyrec, header, &status);
     }
   }
 
-  /* MJD of observation. */
+  // MJD of observation.
   if (!undefined(wcs->mjdobs)) {
     wcsutil_double2str(keyvalue, format, wcs->mjdobs);
     wcshdo_util(ctrl, "MJD-OBS", "MJDOB", 0, 0x0, 0, 0, 0, ' ',
@@ -1113,35 +1110,35 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* Julian epoch of observation. */
+  // Julian epoch of observation.
   if (!undefined(wcs->jepoch)) {
     wcsutil_double2str(keyvalue, format, wcs->jepoch);
     wcshdo_util(ctrl, "JEPOCH", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "[a] Julian epoch of observation", nkeyrec, header, &status);
   }
 
-  /* Besselian epoch of observation. */
+  // Besselian epoch of observation.
   if (!undefined(wcs->bepoch)) {
     wcsutil_double2str(keyvalue, format, wcs->bepoch);
     wcshdo_util(ctrl, "BEPOCH", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "[a] Besselian epoch of observation", nkeyrec, header, &status);
   }
 
-  /* ISO-8601 time at start of observation. */
+  // ISO-8601 time at start of observation.
   if (wcs->datebeg[0]) {
     sprintf(keyvalue, "'%s'", wcs->datebeg);
     wcshdo_util(ctrl, "DATE-BEG", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "ISO-8601 time at start of observation", nkeyrec, header, &status);
   }
 
-  /* MJD at start of observation. */
+  // MJD at start of observation.
   if (!undefined(wcs->mjdbeg)) {
     wcsutil_double2str(keyvalue, format, wcs->mjdbeg);
     wcshdo_util(ctrl, "MJD-BEG", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "[d] MJD at start of observation", nkeyrec, header, &status);
   }
 
-  /* Time elapsed at start since fiducial time. */
+  // Time elapsed at start since fiducial time.
   if (!undefined(wcs->tstart)) {
     wcsutil_double2str(keyvalue, format, wcs->tstart);
     sprintf(comment, "[%s] Time elapsed since fiducial time at start",
@@ -1150,7 +1147,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* ISO-8601 time at midpoint of observation. */
+  // ISO-8601 time at midpoint of observation.
   if (wcs->dateavg[0]) {
     sprintf(keyvalue, "'%s'", wcs->dateavg);
     wcshdo_util(ctrl, "DATE-AVG", "DAVG", 0, 0x0, 0, 0, 0, ' ',
@@ -1158,7 +1155,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* MJD at midpoint of observation. */
+  // MJD at midpoint of observation.
   if (!undefined(wcs->mjdavg)) {
     wcsutil_double2str(keyvalue, format, wcs->mjdavg);
     wcshdo_util(ctrl, "MJD-AVG", "MJDA", 0, 0x0, 0, 0, 0, ' ',
@@ -1166,21 +1163,21 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* ISO-8601 time at end of observation. */
+  // ISO-8601 time at end of observation.
   if (wcs->dateend[0]) {
     sprintf(keyvalue, "'%s'", wcs->dateend);
     wcshdo_util(ctrl, "DATE-END", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "ISO-8601 time at end of observation", nkeyrec, header, &status);
   }
 
-  /* MJD at end of observation. */
+  // MJD at end of observation.
   if (!undefined(wcs->mjdend)) {
     wcsutil_double2str(keyvalue, format, wcs->mjdend);
     wcshdo_util(ctrl, "MJD-END", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "[d] MJD at end of observation", nkeyrec, header, &status);
   }
 
-  /* Time elapsed at end since fiducial time. */
+  // Time elapsed at end since fiducial time.
   if (!undefined(wcs->tstop)) {
     wcsutil_double2str(keyvalue, format, wcs->tstop);
     sprintf(comment, "[%s] Time elapsed since fiducial time at end",
@@ -1189,7 +1186,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* Exposure (integration) time. */
+  // Exposure (integration) time.
   if (!undefined(wcs->xposure)) {
     wcsutil_double2str(keyvalue, format, wcs->xposure);
     sprintf(comment, "[%s] Exposure (integration) time", timeunit);
@@ -1197,7 +1194,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* Elapsed time (start to stop). */
+  // Elapsed time (start to stop).
   if (!undefined(wcs->telapse)) {
     wcsutil_double2str(keyvalue, format, wcs->telapse);
     sprintf(comment, "[%s] Elapsed time (start to stop)", timeunit);
@@ -1205,9 +1202,9 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - Timing accuracy. */
+  // - - - - - - - - - - - - - - - - - - - - - - - - - - - -  Timing accuracy.
 
-  /* Systematic error in time measurements. */
+  // Systematic error in time measurements.
   if (!undefined(wcs->timsyer)) {
     wcsutil_double2str(keyvalue, format, wcs->timsyer);
     sprintf(comment, "[%s] Systematic error in time measurements", timeunit);
@@ -1215,7 +1212,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* Relative error in time measurements. */
+  // Relative error in time measurements.
   if (!undefined(wcs->timrder)) {
     wcsutil_double2str(keyvalue, format, wcs->timrder);
     sprintf(comment, "[%s] Relative error in time measurements", timeunit);
@@ -1223,7 +1220,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* Time resolution. */
+  // Time resolution.
   if (!undefined(wcs->timedel)) {
     wcsutil_double2str(keyvalue, format, wcs->timedel);
     sprintf(comment, "[%s] Time resolution", timeunit);
@@ -1231,7 +1228,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* Reference position of timestamp in binned data. */
+  // Reference position of timestamp in binned data.
   if (!undefined(wcs->timepixr)) {
     wcsutil_double2str(keyvalue, format, wcs->timepixr);
     wcshdo_util(ctrl, "TIMEPIXR", "", 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
@@ -1239,9 +1236,9 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       &status);
   }
 
-  /* - - - - - - - - - - - - - - - - - Spatial & celestial reference frame. */
+  // - - - - - - - - - - - - - - - - - -  Spatial & celestial reference frame.
 
-  /* Observatory coordinates. */
+  // Observatory coordinates.
   if (!undefined(wcs->obsgeo[0]) &&
       !undefined(wcs->obsgeo[1]) &&
       !undefined(wcs->obsgeo[2])) {
@@ -1273,21 +1270,21 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       "[m]   IAU(1976) observatory height", nkeyrec, header, &status);
   }
 
-  /* Spacecraft orbit ephemeris file. */
+  // Spacecraft orbit ephemeris file.
   if (wcs->obsorbit[0]) {
     sprintf(keyvalue, "'%s'", wcs->obsorbit);
     wcshdo_util(ctrl, "OBSORBIT", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Spacecraft orbit ephemeris file", nkeyrec, header, &status);
   }
 
-  /* Equatorial coordinate system type. */
+  // Equatorial coordinate system type.
   if (wcs->radesys[0]) {
     sprintf(keyvalue, "'%s'", wcs->radesys);
     wcshdo_util(ctrl, "RADESYS", "RADE", 0, 0x0, 0, 0, 0, alt, colnum, colax,
       keyvalue, "Equatorial coordinate system", nkeyrec, header, &status);
   }
 
-  /* Equinox of equatorial coordinate system. */
+  // Equinox of equatorial coordinate system.
   if (!undefined(wcs->equinox)) {
     wcsutil_double2str(keyvalue, format, wcs->equinox);
     wcshdo_util(ctrl, "EQUINOX", "EQUI", 0, 0x0, 0, 0, 0, alt, colnum, colax,
@@ -1295,7 +1292,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       &status);
   }
 
-  /* Reference frame of spectral coordinates. */
+  // Reference frame of spectral coordinates.
   if (wcs->specsys[0]) {
     sprintf(keyvalue, "'%s'", wcs->specsys);
     wcshdo_util(ctrl, "SPECSYS", "SPEC", 0, 0x0, 0, 0, 0, alt, colnum, colax,
@@ -1303,7 +1300,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       &status);
   }
 
-  /* Reference frame of spectral observation. */
+  // Reference frame of spectral observation.
   if (wcs->ssysobs[0]) {
     sprintf(keyvalue, "'%s'", wcs->ssysobs);
     wcshdo_util(ctrl, "SSYSOBS", "SOBS", 0, 0x0, 0, 0, 0, alt, colnum, colax,
@@ -1311,21 +1308,21 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       &status);
   }
 
-  /* Observer's velocity towards source. */
+  // Observer's velocity towards source.
   if (!undefined(wcs->velosys)) {
     wcsutil_double2str(keyvalue, format, wcs->velosys);
     wcshdo_util(ctrl, "VELOSYS", "VSYS", 0, 0x0, 0, 0, 0, alt, colnum, colax,
       keyvalue, "[m/s] Velocity towards source", nkeyrec, header, &status);
   }
 
-  /* Redshift of the source. */
+  // Redshift of the source.
   if (!undefined(wcs->zsource)) {
     wcsutil_double2str(keyvalue, format, wcs->zsource);
     wcshdo_util(ctrl, "ZSOURCE", "ZSOU", 0, 0x0, 0, 0, 0, alt, colnum, colax,
       keyvalue, "Redshift of the source", nkeyrec, header, &status);
   }
 
-  /* Reference frame of source redshift. */
+  // Reference frame of source redshift.
   if (wcs->ssyssrc[0]) {
     sprintf(keyvalue, "'%s'", wcs->ssyssrc);
     wcshdo_util(ctrl, "SSYSSRC", "SSRC", 0, 0x0, 0, 0, 0, alt, colnum, colax,
@@ -1333,14 +1330,14 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       &status);
   }
 
-  /* Velocity orientation angle. */
+  // Velocity orientation angle.
   if (!undefined(wcs->velangl)) {
     wcsutil_double2str(keyvalue, format, wcs->velangl);
     wcshdo_util(ctrl, "VELANGL", "VANG", 0, 0x0, 0, 0, 0, alt, colnum, colax,
       keyvalue, "[deg] Velocity orientation angle", nkeyrec, header, &status);
   }
 
-  /* - - - - - - - - - - - - - - - - - - - Additional auxiliary parameters. */
+  // - - - - - - - - - - - - - - - - - - - -  Additional auxiliary parameters.
 
   if ((aux = wcs->aux)) {
     if (!undefined(aux->rsun_ref)) {
@@ -1385,13 +1382,13 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* - - - - - - - - - - - - - - - - - - - Distortion function parameters.  */
+  // - - - - - - - - - - - - - - - - - - - - - Distortion function parameters.
 
   if (dosip) {
-    /* Simple Imaging Polynomial (SIP) is handled by translating its dpkey */
-    /* records.  Determine a suitable numerical precision for the          */
-    /* polynomial coefficients to avoid trailing zeroes common to all of   */
-    /* them.                                                               */
+    // Simple Imaging Polynomial (SIP) is handled by translating its dpkey
+    // records.  Determine a suitable numerical precision for the
+    // polynomial coefficients to avoid trailing zeroes common to all of
+    // them.
     dis = wcs->lin.dispre;
     if (dofmt) {
       keyp = dis->dp;
@@ -1412,9 +1409,9 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       sprintf(format, "%%20.%dE", precision);
     }
 
-    /* Ensure the coefficients are written in a human-readable sequence. */
+    // Ensure the coefficients are written in a human-readable sequence.
     for (j = 0; j <= 1; j++) {
-      /* Distortion function polynomial coefficients. */
+      // Distortion function polynomial coefficients.
       wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
         nkeyrec, header, &status);
 
@@ -1463,7 +1460,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           header, &status);
       }
 
-      /* Inverse distortion function polynomial coefficients. */
+      // Inverse distortion function polynomial coefficients.
       if (dis->disx2p == 0x0) continue;
 
       wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
@@ -1518,20 +1515,20 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       iparm = dis->iparm[j];
       dparm = dis->dparm[j];
 
-      /* Identify the distortion type. */
+      // Identify the distortion type.
       if (dotpv) {
-        /* TPV "projection" is handled by translating its dpkey records, */
-        /* which were originally translated from PVi_ma by wcsset(), or  */
-        /* possibly input directly as a CQDISia = 'TPV' distortion type. */
-        /* Determine a suitable numerical precision for the polynomial   */
-        /* coefficients to avoid trailing zeroes common to all of them.  */
+        // TPV "projection" is handled by translating its dpkey records,
+        // which were originally translated from PVi_ma by wcsset(), or
+        // possibly input directly as a CQDISia = 'TPV' distortion type.
+        // Determine a suitable numerical precision for the polynomial
+        // coefficients to avoid trailing zeroes common to all of them.
         if (dofmt) wcshdo_format('E', iparm[I_NDPARM], dparm, format);
         sprintf(fmt01, "%.3ss", format);
 
         wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
           nkeyrec, header, &status);
 
-        /* Distortion function polynomial coefficients. */
+        // Distortion function polynomial coefficients.
         sprintf(keyword, "PV%d_", j+1);
         kp = keyword + strlen(keyword);
 
@@ -1544,7 +1541,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           if (strncmp(cp, "TPV.", 4) != 0) continue;
           strcpy(kp, cp+4);
 
-          /* Identify the term of the TPV polynomial for human readers. */
+          // Identify the term of the TPV polynomial for human readers.
           sscanf(cp+4, "%d", &m);
           wcshdo_tpdterm(m, j == wcs->lng, term);
           sprintf(comment, "TPV coefficient: %s", term);
@@ -1561,15 +1558,15 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       } else if (strcmp(dis->dtype[j], "TPD") == 0 || dotpd ||
                  strcmp(dis->dtype[j], "Polynomial")  == 0 ||
                  strcmp(dis->dtype[j], "Polynomial*") == 0) {
-        /* One of the Paper IV type polynomial distortions. */
+        // One of the Paper IV type polynomial distortions.
         wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
           nkeyrec, header, &status);
 
         if (strcmp(dis->dtype[j], "TPD") == 0) {
-          /* Pure TPD. */
+          // Pure TPD.
           dotpd = 1;
         } else if (strncmp(dis->dtype[j], "Polynomial", 10) == 0) {
-          /* Polynomial distortion.  Write it as TPD by request? */
+          // Polynomial distortion.  Write it as TPD by request?
           dotpd = (iparm[I_DTYPE] & DIS_DOTPD);
           strcpy(tpdsrc, "Polynomial distortion");
         }
@@ -1577,7 +1574,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
         pq = idis ? 'Q' : 'P';
         Nhat = dis->Nhat[j];
 
-        /* CPDISja/CQDISia */
+        // CPDISja/CQDISia
         sprintf(keyword, "C%cDIS%d", pq, j+1);
         if (idis == 0) {
           strcpy(comment, "P = prior, ");
@@ -1589,18 +1586,18 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           strcpy(keyvalue, "'TPD'");
           strcat(comment, "Template Polynomial Distortion");
 
-          /* For identifying terms of the TPD polynomial. */
+          // For identifying terms of the TPD polynomial.
           axmap  = dis->axmap[j];
           direct = 1;
           doaux  = iparm[I_TPDAUX];
           if (Nhat == 2) {
-            /* Associate x with longitude, y with latitude. */
+            // Associate x with longitude, y with latitude.
             if (axmap[0] == wcs->lng && axmap[1] == wcs->lat) {
               direct = 1;
             } else if (axmap[0] == wcs->lat && axmap[1] == wcs->lng) {
               direct = 0;
             } else {
-              /* Non-celestial. */
+              // Non-celestial.
               direct = (axmap[0] < axmap[1]);
             }
           }
@@ -1612,7 +1609,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
         wcshdo_util(ctrl, keyword, "", 0, 0x0, 0, 0, 0, alt, 0, 0,
           keyvalue, comment, nkeyrec, header, &status);
 
-        /* NAXES. */
+        // NAXES.
         sprintf(keyword,  "D%c%d", pq, j+1);
         sprintf(keyvalue, "'NAXES:  %d'", Nhat);
         if (Nhat == 1) {
@@ -1625,7 +1622,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
         wcshdo_util(ctrl, keyword, "", 0, 0x0, 0, 0, 0, alt, 0, 0,
           keyvalue, comment, nkeyrec, header, &status);
 
-        /* AXIS.jhat */
+        // AXIS.jhat
         for (jhat = 0; jhat < Nhat; jhat++) {
           axmap = dis->axmap[j];
           sprintf(keyvalue, "'AXIS.%d: %d'", jhat+1, axmap[jhat]+1);
@@ -1642,7 +1639,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           sprintf(comment+strlen(comment), " independent variable: axis %d",
             axmap[jhat]+1);
           if (dotpd) {
-            /* axid is "xyxuvu". */
+            // axid is "xyxuvu".
             cp = axid;
             if (!direct) cp++;
             if (doaux) cp += 3;
@@ -1653,7 +1650,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
             keyvalue, comment, nkeyrec, header, &status);
         }
 
-        /* OFFSET.jhat */
+        // OFFSET.jhat
         if (dofmt) wcshdo_format('f', Nhat, dis->offset[j], format);
         for (jhat = 0; jhat < Nhat; jhat++) {
           if (dis->offset[j][jhat] == 0.0) continue;
@@ -1666,7 +1663,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
             keyvalue, comment, nkeyrec, header, &status);
         }
 
-        /* SCALE.jhat */
+        // SCALE.jhat
         if (dofmt) wcshdo_format('f', Nhat, dis->scale[j], format);
         for (jhat = 0; jhat < Nhat; jhat++) {
           if (dis->scale[j][jhat] == 1.0) continue;
@@ -1679,22 +1676,26 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
             keyvalue, comment, nkeyrec, header, &status);
         }
 
-        /* Does the distortion function compute a correction? */
-        if (iparm[I_DOCORR]) {
+        // Does the distortion function compute a correction?
+        if (dis->docorr[j]) {
           wcshdo_util(ctrl, keyword, "", 0, 0x0, 0, 0, 0, alt, 0, 0,
             "'DOCORR: 1'", "Distortion function computes a correction",
             nkeyrec, header, &status);
+        } else {
+          wcshdo_util(ctrl, keyword, "", 0, 0x0, 0, 0, 0, alt, 0, 0,
+            "'DOCORR: 0'", "Distortion function computes coordinates",
+            nkeyrec, header, &status);
         }
 
         if (dotpd) {
-          /* Template Polynomial Distortion (TPD).  As it may have been */
-          /* translated from SIP, TPV, DSS, TNX, ZPX, or perhaps        */
-          /* Polynomial, the dpkey records may not relate to TPD.       */
-          /* Output is therefore handled via dparm.                     */
+          // Template Polynomial Distortion (TPD).  As it may have been
+          // translated from SIP, TPV, DSS, TNX, ZPX, or perhaps
+          // Polynomial, the dpkey records may not relate to TPD.
+          // Output is therefore handled via dparm.
           if (dofmt) wcshdo_format('E', iparm[I_NDPARM], dparm, format);
           sprintf(fmt01, "%.3ss", format);
 
-          /* AUX.jhat.COEFF.m */
+          // AUX.jhat.COEFF.m
           if (doaux) {
             for (idp = 0; idp < 6; idp++) {
               if (dparm[idp] == 0.0) {
@@ -1721,7 +1722,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
             dparm += 6;
           }
 
-          /* TPD.FWD.m */
+          // TPD.FWD.m
           for (idp = 0; idp < iparm[I_TPDNCO]; idp++) {
             if (dparm[idp] == 0.0) continue;
 
@@ -1740,7 +1741,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
               keyvalue, comment, nkeyrec, header, &status);
           }
 
-          /* CPERRja/CQERRia */
+          // CPERRja/CQERRia
           if (dis->maxdis[j] != 0.0) {
             sprintf(keyword,  "C%cERR%d", pq, j+1);
             sprintf(keyvalue, "%20.2f", dis->maxdis[j]);
@@ -1750,13 +1751,13 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
               keyvalue, comment, nkeyrec, header, &status);
           }
 
-          /* Inverse distortion function polynomial coefficients. */
+          // Inverse distortion function polynomial coefficients.
           if (dis->disx2p[j] == 0x0) continue;
 
           wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
             nkeyrec, header, &status);
 
-          /* TPD.REV.m */
+          // TPD.REV.m
           sprintf(keyword,  "D%c%d", pq, j+1);
           for (idp = iparm[I_TPDNCO]; idp < iparm[I_NDPARM]; idp++) {
             if (dparm[idp] == 0.0) continue;
@@ -1772,10 +1773,10 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           }
 
         } else {
-          /* General polynomial distortion, handled via its dpkey records */
-          /* since iparm and dparm may hold a translation to TPD.         */
+          // General polynomial distortion, handled via its dpkey records
+          // since iparm and dparm may hold a translation to TPD.
 
-          /* Do auxiliary variables first. */
+          // Do auxiliary variables first.
           keyp = dis->dp;
           for (idp = 0; idp < dis->ndp; idp++, keyp++) {
             if (keyp->j != j+1) continue;
@@ -1834,7 +1835,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
             break;
           }
 
-          /* Do polynomial terms. */
+          // Do polynomial terms.
           keyp = dis->dp;
           for (idp = 0; idp < dis->ndp; idp++, keyp++) {
             if (keyp->j != j+1) continue;
@@ -1886,7 +1887,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
               keyvalue, comment, nkeyrec, header, &status);
           }
 
-          /* CPERRja/CQERRia */
+          // CPERRja/CQERRia
           if (dis->maxdis[j] != 0.0) {
             sprintf(keyword,  "C%cERR%d", pq, j+1);
             sprintf(keyvalue, "%20.2f", dis->maxdis[j]);
@@ -1899,7 +1900,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       }
     }
 
-    /* DVERRa */
+    // DVERRa
     if (dis->totdis != 0.0) {
       sprintf(keyvalue, "%20.2f", dis->totdis);
       sprintf(comment, "Maximum combined distortion");
@@ -1909,12 +1910,12 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   }
 
 
-  /* Add identification. */
+  // Add identification.
   wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
     nkeyrec, header, &status);
 
   if (dotpd == DIS_DOTPD) {
-    /* TPD by translation. */
+    // TPD by translation.
     sprintf(comment, "Translated from %s to TPD by WCSLIB %s", tpdsrc,
       wcslib_version(0x0));
   } else {
@@ -1932,8 +1933,8 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
-/* Determine a suitable floating point format for a set of parameters.      */
+//----------------------------------------------------------------------------
+// Determine a suitable floating point format for a set of parameters.
 
 void wcshdo_format(
   int fmt,
@@ -1942,45 +1943,51 @@ void wcshdo_format(
   char *format)
 
 {
-  char cval[24];
-  int  cp0, cpi, i, expmax, expon, nsig, precision;
-
-  if (fmt == 'G') {
-    fmt = 'f';
-    for (i = 0; i < nval; i++) {
-      if (fabs(val[i]) < 1e-4 || 1e12 < val[i]) {
-        fmt = 'E';
-        break;
-      }
-    }
-  }
-
-  cp0 = 2;
-  expmax = -999;
+  int emax = -999;
+  int emin = +999;
+  int precision = 0;
+  int i;
   for (i = 0; i < nval; i++) {
-    /* Double precision has at least 15 significant digits, and up to 17:  */
-    /* http://en.wikipedia.org/wiki/Double-precision_floating-point_format */
+    // Double precision has at least 15 significant digits, and up to 17:
+    // http://en.wikipedia.org/wiki/Double-precision_floating-point_format
+    char cval[24];
     wcsutil_double2str(cval, "%21.14E", val[i]);
 
-    cpi = 16;
-    while (cp0 < cpi && cval[cpi] == '0') cpi--;
-    cp0 = cpi;
+    int cpi = 16;
+    while (2 < cpi && cval[cpi] == '0') cpi--;
+
+    // Precision for 'E' format.
+    cpi -= 2;
+    if (precision < cpi) precision = cpi;
 
+    // Range of significant digits for 'f' format.
+    int expon;
     sscanf(cval+18, "%d", &expon);
-    if (expmax < expon) expmax = expon;
+
+    if (emax < expon) emax = expon;
+    expon -= cpi;
+    if (expon < emin) emin = expon;
   }
 
-  nsig = cp0 - 1;
 
+  if (fmt == 'G') {
+    // Because e.g. writing 1e4 as 10000 requires an extra digit.
+    emax++;
+
+    if (emin < -15 || 15 < emax || 15 < (emax - emin)) {
+      fmt = 'E';
+    } else {
+      fmt = 'f';
+    }
+  }
 
   if (fmt == 'f') {
-    precision = nsig - (expmax + 1);
+    precision = -emin;
     if (precision < 1)  precision = 1;
     if (17 < precision) precision = 17;
     sprintf(format, "%%20.%df", precision);
 
   } else {
-    precision = nsig - 1;
     if (precision < 1)  precision = 1;
     if (14 < precision) precision = 14;
     if (precision < 14) {
@@ -1991,8 +1998,8 @@ void wcshdo_format(
   }
 }
 
-/*--------------------------------------------------------------------------*/
-/* Construct a string that identifies the term of a TPD or TPV polynomial.  */
+//----------------------------------------------------------------------------
+// Construct a string that identifies the term of a TPD or TPV polynomial.
 
 void wcshdo_tpdterm(
   int m,
@@ -2028,8 +2035,8 @@ void wcshdo_tpdterm(
   }
 }
 
-/*--------------------------------------------------------------------------*/
-/* Construct a keyrecord from the components given.                         */
+//----------------------------------------------------------------------------
+// Construct a keyrecord from the components given.
 
 void wcshdo_util(
   int relax,
@@ -2055,7 +2062,7 @@ void wcshdo_util(
 
   if (*status) return;
 
-  /* Reallocate memory in blocks of 2880 bytes. */
+  // Reallocate memory in blocks of 2880 bytes.
   if ((*nkeyrec)%32 == 0) {
     nbyte = ((*nkeyrec)/32 + 1) * 2880;
     if (!(hptr = realloc(*header, nbyte))) {
@@ -2066,10 +2073,10 @@ void wcshdo_util(
     *header = hptr;
   }
 
-  /* Construct the keyword. */
+  // Construct the keyword.
   if (alt == ' ') alt = '\0';
   if (btcol) {
-    /* Binary table image array. */
+    // Binary table image array.
     if (i > 0 && j) {
       if (j > 0) {
         sprintf(keyword, "%d%d%s%d%c", i, j, tbkey, btcol, alt);
@@ -2085,7 +2092,7 @@ void wcshdo_util(
     }
 
     if ((strlen(keyword) < 8) && tlkey && (relax & level)) {
-      /* Use the long form. */
+      // Use the long form.
       if (i > 0 && j) {
         if (j > 0) {
           sprintf(keyword, "%d%d%s%d%c", i, j, tlkey, btcol, alt);
@@ -2102,7 +2109,7 @@ void wcshdo_util(
     }
 
   } else if (plcol && plcol[0]) {
-    /* Pixel list. */
+    // Pixel list.
     if (i > 0 && j) {
       if (j > 0) {
         sprintf(keyword, "T%s%d_%d%c", tbkey, plcol[i-1], plcol[j-1], alt);
@@ -2118,7 +2125,7 @@ void wcshdo_util(
     }
 
     if ((strlen(keyword) < 8) && tlkey && (relax & level)) {
-      /* Use the long form. */
+      // Use the long form.
       if (i > 0 && j) {
         if (j > 0) {
           sprintf(keyword, "T%s%d_%d%c", tlkey, plcol[i-1], plcol[j-1], alt);
@@ -2149,7 +2156,7 @@ void wcshdo_util(
     }
   }
 
-  /* Double-up single-quotes in string keyvalues. */
+  // Double-up single-quotes in string keyvalues.
   if (*keyvalue == '\'') {
     hptr = keyvalue + 1;
     while (*hptr) {
@@ -2170,23 +2177,23 @@ void wcshdo_util(
       hptr++;
     }
 
-    /* Check length. */
+    // Check length.
     if (strlen(keyvalue) > 70) {
-      /* Truncate. */
+      // Truncate.
       keyvalue[69] = '\'';
       keyvalue[70] = '\0';
     }
 
   } else {
-    /* Check length. */
+    // Check length.
     if (strlen(keyvalue) > 70) {
-      /* Truncate. */
+      // Truncate.
       keyvalue[70] = '\0';
     }
   }
 
   if ((nv = strlen(keyvalue) > 20)) {
-    /* Rob the keycomment to make space for the keyvalue. */
+    // Rob the keycomment to make space for the keyvalue.
     nc -= (nv - 20);
   }
 
Index: astropy-4.2.1/cextern/wcslib/C/wcshdr.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcshdr.h
+++ astropy-4.2.1/cextern/wcslib/C/wcshdr.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcshdr.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcshdr.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -227,7 +224,7 @@
 *                         4: Fatal error returned by Flex parser.
 *
 * Notes:
-*   Refer to wcsbth() notes 1, 2, 3, 5, 7, and 8.
+*   1: Refer to wcsbth() notes 1, 2, 3, 5, 7, and 8.
 *
 *
 * wcsbth() - FITS WCS parser routine for binary table and image headers
@@ -1177,91 +1174,96 @@
 *                       wcsprm::err if enabled, see wcserr_enable().
 *
 * Notes:
-*   wcshdo() interprets the "relax" argument as a vector of flag bits to
-*   provide fine-grained control over what non-standard WCS keywords to write.
-*   The flag bits are subject to change in future and should be set by using
-*   the preprocessor macros (see below) for the purpose.
+*   1: wcshdo() interprets the "relax" argument as a vector of flag bits to
+*      provide fine-grained control over what non-standard WCS keywords to
+*      write.  The flag bits are subject to change in future and should be set
+*      by using the preprocessor macros (see below) for the purpose.
 *
-*   - WCSHDO_none: Don't use any extensions.
+*      - WCSHDO_none: Don't use any extensions.
 *
-*   - WCSHDO_all: Write all recognized extensions, equivalent to setting each
-*           flag bit.
+*      - WCSHDO_all: Write all recognized extensions, equivalent to setting
+*              each flag bit.
 *
-*   - WCSHDO_safe: Write all extensions that are considered to be safe and
-*           recommended.
+*      - WCSHDO_safe: Write all extensions that are considered to be safe and
+*              recommended.
 *
-*   - WCSHDO_DOBSn: Write DOBSn, the column-specific analogue of DATE-OBS for
-*           use in binary tables and pixel lists.  WCS Paper III introduced
-*           DATE-AVG and DAVGn but by an oversight DOBSn (the obvious analogy)
-*           was never formally defined by the standard.  The alternative to
-*           using DOBSn is to write DATE-OBS which applies to the whole table.
-*           This usage is considered to be safe and is recommended.
+*      - WCSHDO_DOBSn: Write DOBSn, the column-specific analogue of DATE-OBS
+*              for use in binary tables and pixel lists.  WCS Paper III
+*              introduced DATE-AVG and DAVGn but by an oversight DOBSn (the
+*              obvious analogy) was never formally defined by the standard.
+*              The alternative to using DOBSn is to write DATE-OBS which
+*              applies to the whole table.  This usage is considered to be
+*              safe and is recommended.
 *
-*   - WCSHDO_TPCn_ka: WCS Paper I defined
+*      - WCSHDO_TPCn_ka: WCS Paper I defined
 *
-*           - TPn_ka and TCn_ka for pixel lists
+*              - TPn_ka and TCn_ka for pixel lists
 *
-*           but WCS Paper II uses TPCn_ka in one example and subsequently the
-*           errata for the WCS papers legitimized the use of
+*              but WCS Paper II uses TPCn_ka in one example and subsequently
+*              the errata for the WCS papers legitimized the use of
 *
-*           - TPCn_ka and TCDn_ka for pixel lists
+*              - TPCn_ka and TCDn_ka for pixel lists
 *
-*           provided that the keyword does not exceed eight characters.  This
-*           usage is considered to be safe and is recommended because of the
-*           non-mnemonic terseness of the shorter forms.
+*              provided that the keyword does not exceed eight characters.
+*              This usage is considered to be safe and is recommended because
+*              of the non-mnemonic terseness of the shorter forms.
 *
-*   - WCSHDO_PVn_ma: WCS Paper I defined
+*      - WCSHDO_PVn_ma: WCS Paper I defined
 *
-*           - iVn_ma and iSn_ma for bintables and
-*           - TVn_ma and TSn_ma for pixel lists
+*              - iVn_ma and iSn_ma for bintables and
+*              - TVn_ma and TSn_ma for pixel lists
 *
-*           but WCS Paper II uses iPVn_ma and TPVn_ma in the examples and
-*           subsequently the errata for the WCS papers legitimized the use of
+*              but WCS Paper II uses iPVn_ma and TPVn_ma in the examples and
+*              subsequently the errata for the WCS papers legitimized the use
+*              of
 *
-*           - iPVn_ma and iPSn_ma for bintables and
-*           - TPVn_ma and TPSn_ma for pixel lists
+*              - iPVn_ma and iPSn_ma for bintables and
+*              - TPVn_ma and TPSn_ma for pixel lists
 *
-*           provided that the keyword does not exceed eight characters.  This
-*           usage is considered to be safe and is recommended because of the
-*           non-mnemonic terseness of the shorter forms.
+*              provided that the keyword does not exceed eight characters.
+*              This usage is considered to be safe and is recommended because
+*              of the non-mnemonic terseness of the shorter forms.
 *
-*   - WCSHDO_CRPXna: For historical reasons WCS Paper I defined
+*      - WCSHDO_CRPXna: For historical reasons WCS Paper I defined
 *
-*           - jCRPXn, iCDLTn, iCUNIn, iCTYPn, and iCRVLn for bintables and
-*           - TCRPXn, TCDLTn, TCUNIn, TCTYPn, and TCRVLn for pixel lists
+*              - jCRPXn, iCDLTn, iCUNIn, iCTYPn, and iCRVLn for bintables and
+*              - TCRPXn, TCDLTn, TCUNIn, TCTYPn, and TCRVLn for pixel lists
 *
-*           for use without an alternate version specifier.  However, because
-*           of the eight-character keyword constraint, in order to accommodate
-*           column numbers greater than 99 WCS Paper I also defined
+*              for use without an alternate version specifier.  However,
+*              because of the eight-character keyword constraint, in order to
+*              accommodate column numbers greater than 99 WCS Paper I also
+*              defined
 *
-*           - jCRPna, iCDEna, iCUNna, iCTYna and iCRVna for bintables and
-*           - TCRPna, TCDEna, TCUNna, TCTYna and TCRVna for pixel lists
+*              - jCRPna, iCDEna, iCUNna, iCTYna and iCRVna for bintables and
+*              - TCRPna, TCDEna, TCUNna, TCTYna and TCRVna for pixel lists
 *
-*           for use with an alternate version specifier (the "a").  Like the
-*           PC, CD, PV, and PS keywords there is an obvious tendency to
-*           confuse these two forms for column numbers up to 99.  It is very
-*           unlikely that any parser would reject keywords in the first set
-*           with a non-blank alternate version specifier so this usage is
-*           considered to be safe and is recommended.
+*              for use with an alternate version specifier (the "a").  Like
+*              the PC, CD, PV, and PS keywords there is an obvious tendency to
+*              confuse these two forms for column numbers up to 99.  It is
+*              very unlikely that any parser would reject keywords in the
+*              first set with a non-blank alternate version specifier so this
+*              usage is considered to be safe and is recommended.
 *
-*   - WCSHDO_CNAMna: WCS Papers I and III defined
+*      - WCSHDO_CNAMna: WCS Papers I and III defined
 *
-*           - iCNAna,  iCRDna,  and iCSYna  for bintables and
-*           - TCNAna,  TCRDna,  and TCSYna  for pixel lists
+*              - iCNAna,  iCRDna,  and iCSYna  for bintables and
+*              - TCNAna,  TCRDna,  and TCSYna  for pixel lists
 *
-*           By analogy with the above, the long forms would be
+*              By analogy with the above, the long forms would be
 *
-*           - iCNAMna, iCRDEna, and iCSYEna for bintables and
-*           - TCNAMna, TCRDEna, and TCSYEna for pixel lists
+*              - iCNAMna, iCRDEna, and iCSYEna for bintables and
+*              - TCNAMna, TCRDEna, and TCSYEna for pixel lists
 *
-*           Note that these keywords provide auxiliary information only, none
-*           of them are needed to compute world coordinates.  This usage is
-*           potentially unsafe and is not recommended at this time.
+*              Note that these keywords provide auxiliary information only,
+*              none of them are needed to compute world coordinates.  This
+*              usage is potentially unsafe and is not recommended at this
+*              time.
 *
-*   - WCSHDO_WCSNna: In light of wcsbth() note 4, write WCSNna instead of
-*           TWCSna for pixel lists.  While wcsbth() treats WCSNna and TWCSna
-*           as equivalent, other parsers may not.  Consequently, this usage
-*           is potentially unsafe and is not recommended at this time.
+*      - WCSHDO_WCSNna: In light of wcsbth() note 4, write WCSNna instead of
+*              TWCSna for pixel lists.  While wcsbth() treats WCSNna and
+*              TWCSna as equivalent, other parsers may not.  Consequently,
+*              this usage is potentially unsafe and is not recommended at this
+*              time.
 *
 *
 * Global variable: const char *wcshdr_errmsg[] - Status return messages
@@ -1330,13 +1332,13 @@ extern "C" {
 extern const char *wcshdr_errmsg[];
 
 enum wcshdr_errmsg_enum {
-  WCSHDRERR_SUCCESS            = 0,	/* Success. */
-  WCSHDRERR_NULL_POINTER       = 1,	/* Null wcsprm pointer passed. */
-  WCSHDRERR_MEMORY             = 2,	/* Memory allocation failed. */
-  WCSHDRERR_BAD_COLUMN         = 3,	/* Invalid column selection. */
-  WCSHDRERR_PARSER             = 4,	/* Fatal error returned by Flex
-					   parser. */
-  WCSHDRERR_BAD_TABULAR_PARAMS = 5 	/* Invalid tabular parameters. */
+  WCSHDRERR_SUCCESS            = 0,	// Success.
+  WCSHDRERR_NULL_POINTER       = 1,	// Null wcsprm pointer passed.
+  WCSHDRERR_MEMORY             = 2,	// Memory allocation failed.
+  WCSHDRERR_BAD_COLUMN         = 3,	// Invalid column selection.
+  WCSHDRERR_PARSER             = 4,	// Fatal error returned by Flex
+					// parser.
+  WCSHDRERR_BAD_TABULAR_PARAMS = 5 	// Invalid tabular parameters.
 };
 
 int wcspih(char *header, int nkeyrec, int relax, int ctrl, int *nreject,
@@ -1360,4 +1362,4 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
 }
 #endif
 
-#endif /* WCSLIB_WCSHDR */
+#endif // WCSLIB_WCSHDR
Index: astropy-4.2.1/cextern/wcslib/C/wcslib.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcslib.h
+++ astropy-4.2.1/cextern/wcslib/C/wcslib.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcslib.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcslib.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -60,4 +57,4 @@
 #include "wcsutil.h"
 #include "wtbarr.h"
 
-#endif /* WCSLIB_WCSLIB */
+#endif // WCSLIB_WCSLIB
Index: astropy-4.2.1/cextern/wcslib/C/wcsmath.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsmath.h
+++ astropy-4.2.1/cextern/wcslib/C/wcsmath.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsmath.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsmath.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -72,4 +69,4 @@
 #define UNDEFINED 987654321.0e99
 #define undefined(value) (value == UNDEFINED)
 
-#endif /* WCSLIB_WCSMATH */
+#endif // WCSLIB_WCSMATH
Index: astropy-4.2.1/cextern/wcslib/C/wcspih.l
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcspih.l
+++ astropy-4.2.1/cextern/wcslib/C/wcspih.l
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcspih.l,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcspih.l,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
 * wcspih.l is a Flex description file containing the definition of a lexical
@@ -73,6 +70,7 @@
 %option outfile="wcspih.c"
 %option prefix="wcspih"
 %option reentrant
+%option extra-type="struct wcspih_extra *"
 
 /* Indices for parameterized keywords. */
 Z1	[0-9]
@@ -137,58 +135,37 @@ INLINE " "*(\/.*)?
 #define DSS     2
 #define WAT     3
 
-static int wcspih_scanner(char *header, int nkeyrec, int relax, int ctrl,
-                          int *nreject, int *nwcs, struct wcsprm **wcs,
-                          yyscan_t yyscanner);
-
-/*--------------------------------------------------------------------------*/
-
-int wcspih(
-  char *header,
-  int nkeyrec,
-  int relax,
-  int ctrl,
-  int *nreject,
-  int *nwcs,
-  struct wcsprm **wcs)
-
-{
-  int status;
-  yyscan_t yyscanner;
-  int yylex_init(yyscan_t *yyscanner);
-  int yylex_destroy(yyscan_t yyscanner);
-
-  yylex_init(&yyscanner);
-  status = wcspih_scanner(header, nkeyrec, relax, ctrl, nreject, nwcs, wcs,
-                          yyscanner);
-  yylex_destroy(yyscanner);
-
-  return status;
-}
-
-/*--------------------------------------------------------------------------*/
+// User data associated with yyscanner.
+struct wcspih_extra {
+  // Values passed to YY_INPUT.
+  char *hdr;
+  int  nkeyrec;
+
+  // Used in preempting the call to exit() by yy_fatal_error().
+  jmp_buf abort_jmp_env;
+};
 
 #define YY_DECL int wcspih_scanner(char *header, int nkeyrec, int relax, \
  int ctrl, int *nreject, int *nwcs, struct wcsprm **wcs, yyscan_t yyscanner)
 
 #define YY_INPUT(inbuff, count, bufsize) \
 	{ \
-	  if (wcspih_nkeyrec) { \
-	    strncpy(inbuff, wcspih_hdr, 80); \
+	  if (yyextra->nkeyrec) { \
+	    strncpy(inbuff, yyextra->hdr, 80); \
 	    inbuff[80] = '\n'; \
-	    wcspih_hdr += 80; \
-	    wcspih_nkeyrec--; \
+	    yyextra->hdr += 80; \
+	    yyextra->nkeyrec--; \
 	    count = 81; \
 	  } else { \
 	    count = YY_NULL; \
 	  } \
 	}
 
-/* These global variables are required by YY_INPUT. */
-static char *wcspih_hdr;
-static int  wcspih_nkeyrec;
+// Preempt the call to exit() by yy_fatal_error().
+#define exit(status) longjmp(yyextra->abort_jmp_env, status);
 
-/* Internal helper functions. */
+// Internal helper functions.
+static YY_DECL;
 static int wcspih_final(int ndp[], int ndq[], int distran, double dsstmp[],
              char *wat[], int *nwcs, struct wcsprm **wcs);
 static int wcspih_init1(int naxis, int alts[], int dpq[], int npv[],
@@ -205,34 +182,20 @@ static int wcspih_vsource(double *wptr,
 
 static int wcspih_timepixr(double timepixr);
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
-jmp_buf wcspih_abort_jmp_env;
-#define exit(status) longjmp(wcspih_abort_jmp_env, status)
-
 %}
 
 %%
-	/* Keyword indices, as used in the WCS papers, e.g. PCi_ja, PVi_ma. */
-	char a;
-	int  i, j, m, p, q;
-	
-	char *cptr, *errmsg, errtxt[80], *hptr, *keep, *keyname, *keyrec,
-	     keyword[16], strtmp[80], *wat[2], *watstr;
-	int  altlin, alts[27], auxprm, distran, distype, dpq[27], dssflag,
-	     gotone, ialt, inttmp, ipass, ipx, ix, jx, naux, naxis,
-	     ndp[27], ndq[27], nother, *npptr, nps[27], npass, npv[27],
-	     nvalid, rectype, sipflag, status, valtype, watflag, watn;
-	ptrdiff_t voff;
+	int  p, q;
+	char *errmsg, errtxt[80], *keyname, strtmp[80], *wat[2], *watstr;
+	int  alts[27], dpq[27], inttmp, ndp[27], ndq[27], nps[27], npv[27],
+	     rectype;
 	double dbltmp, dbl2tmp[2], dsstmp[20];
-	void *vptr, *wptr;
-	struct auxprm *auxp, auxtem;
-	struct disprm *disp, distem;
-	struct wcsprm *wcsp, wcstem;
-	int (*chekval)(double);
-	int (*special)(double *, const double *);
+	struct auxprm auxtem;
+	struct disprm distem;
+	struct wcsprm wcstem;
 	
-	naxis = 0;
-	for (ialt = 0; ialt < 27; ialt++) {
+	int naxis = 0;
+	for (int ialt = 0; ialt < 27; ialt++) {
 	  alts[ialt] = 0;
 	  dpq[ialt]  = 0;
 	  npv[ialt]  = 0;
@@ -241,57 +204,58 @@ jmp_buf wcspih_abort_jmp_env;
 	  ndq[ialt]  = 0;
 	}
 	
-	/* Parameters used to implement YY_INPUT. */
-	wcspih_hdr = header;
-	wcspih_nkeyrec = nkeyrec;
-	
-	/* Our handle on the input stream. */
-	keyrec = header;
-	hptr = header;
-	keep = 0x0;
+	// Our handle on the input stream.
+	char *keyrec = header;
+	char *hptr = header;
+	char *keep = 0x0;
 	
-	/* For keeping tallies of keywords found. */
+	// For keeping tallies of keywords found.
 	*nreject = 0;
-	nvalid = 0;
-	nother = 0;
+	int nvalid = 0;
+	int nother = 0;
 	
-	/* If strict, then also reject. */
+	// If strict, then also reject.
 	if (relax & WCSHDR_strict) relax |= WCSHDR_reject;
 	
-	/* Keyword parameters. */
-	i = j = 0;
-	m = 0;
-	a = ' ';
-	
-	/* For decoding the keyvalue. */
-	valtype = -1;
-	distype =  0;
-	vptr    = 0x0;
-	
-	/* For keywords that require special handling. */
-	altlin  = 0;
-	npptr   = 0x0;
-	chekval = 0x0;
-	special = 0x0;
-	auxprm  = 0;
-	naux    = 0;
-	distran = 0;
-	sipflag = 0;
-	dssflag = 0;
-	watflag = 0;
-	watn    = 0;
+	// Keyword indices, as used in the WCS papers, e.g. PCi_ja, PVi_ma.
+	int i = 0;
+	int j = 0;
+	int m = 0;
+	char a = ' ';
+	
+	// For decoding the keyvalue.
+	int valtype = -1;
+	int distype =  0;
+	void *vptr  = 0x0;
+	
+	// For keywords that require special handling.
+	int altlin  = 0;
+	int *npptr  = 0x0;
+	int (*chekval)(double) = 0x0;
+	int (*special)(double *, const double *) = 0x0;
+	int auxprm  = 0;
+	int naux    = 0;
+	int distran = 0;
+	int sipflag = 0;
+	int dssflag = 0;
+	int watflag = 0;
+	int watn    = 0;
 	
-	/* The data structures produced. */
+	// The data structures produced.
 	*nwcs = 0;
 	*wcs  = 0x0;
 	
-	/* Control variables. */
-	ipass = 1;
-	npass = 2;
-	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
-	if (setjmp(wcspih_abort_jmp_env)) {
-	  return 3;
+	// Control variables.
+	int ipass = 1;
+	int npass = 2;
+	
+	// User data associated with yyscanner.
+	yyextra->hdr = header;
+	yyextra->nkeyrec = nkeyrec;
+	
+	// Return here via longjmp() invoked by yy_fatal_error().
+	if (setjmp(yyextra->abort_jmp_env)) {
+	  return WCSHDRERR_PARSER;
 	}
 	
 	BEGIN(INITIAL);
@@ -627,7 +591,7 @@ jmp_buf wcspih_abort_jmp_env;
 ^MJDREFI" " |
 ^MJD-REFI {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	
@@ -683,7 +647,7 @@ jmp_buf wcspih_abort_jmp_env;
 ^JDREFI"  " |
 ^JD-REFI {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	    special = wcspih_jdrefi;
@@ -1193,7 +1157,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^A_ORDER" " {
-	  /* SIP: axis 1 polynomial degree (not stored). */
+	  // SIP: axis 1 polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -1206,7 +1170,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^B_ORDER" " {
-	  /* SIP: axis 2 polynomial degree (not stored). */
+	  // SIP: axis 2 polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -1219,7 +1183,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^AP_ORDER {
-	  /* SIP: axis 1 inverse polynomial degree (not stored). */
+	  // SIP: axis 1 inverse polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -1232,7 +1196,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^BP_ORDER {
-	  /* SIP: axis 2 inverse polynomial degree (not stored). */
+	  // SIP: axis 2 inverse polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -1245,7 +1209,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^A_DMAX"  " {
-	  /* SIP: axis 1 maximum distortion. */
+	  // SIP: axis 1 maximum distortion.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.maxdis);
@@ -1258,7 +1222,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^B_DMAX"  " {
-	  /* SIP: axis 2 maximum distortion. */
+	  // SIP: axis 2 maximum distortion.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.maxdis);
@@ -1271,7 +1235,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^A_	{
-	  /* SIP: axis 1 polynomial coefficient. */
+	  // SIP: axis 1 polynomial coefficient.
 	  i = 1;
 	  sipflag = 2;
 	
@@ -1280,7 +1244,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^B_	{
-	  /* SIP: axis 2 polynomial coefficient. */
+	  // SIP: axis 2 polynomial coefficient.
 	  i = 2;
 	  sipflag = 2;
 	
@@ -1289,7 +1253,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^AP_	{
-	  /* SIP: axis 1 inverse polynomial coefficient. */
+	  // SIP: axis 1 inverse polynomial coefficient.
 	  i = 1;
 	  sipflag = 3;
 	
@@ -1298,7 +1262,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^BP_	{
-	  /* SIP: axis 2 inverse polynomial coefficient. */
+	  // SIP: axis 2 inverse polynomial coefficient.
 	  i = 2;
 	  sipflag = 3;
 	
@@ -1307,7 +1271,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^CNPIX1"  " {
-	  /* DSS: LLH corner pixel coordinate 1. */
+	  // DSS: LLH corner pixel coordinate 1.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp;
@@ -1319,7 +1283,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^CNPIX2"  " {
-	  /* DSS: LLH corner pixel coordinate 2. */
+	  // DSS: LLH corner pixel coordinate 2.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+1;
@@ -1331,7 +1295,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PPO3"    " {
-	  /* DSS: plate centre x-coordinate in micron. */
+	  // DSS: plate centre x-coordinate in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+2;
@@ -1343,7 +1307,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PPO6"    " {
-	  /* DSS: plate centre y-coordinate in micron. */
+	  // DSS: plate centre y-coordinate in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+3;
@@ -1355,7 +1319,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^XPIXELSZ {
-	  /* DSS: pixel x-dimension in micron. */
+	  // DSS: pixel x-dimension in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+4;
@@ -1367,7 +1331,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^YPIXELSZ {
-	  /* DSS: pixel y-dimension in micron. */
+	  // DSS: pixel y-dimension in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+5;
@@ -1379,7 +1343,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTRAH"  " {
-	  /* DSS: plate centre, right ascension - hours. */
+	  // DSS: plate centre, right ascension - hours.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+6;
@@ -1391,7 +1355,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTRAM"  " {
-	  /* DSS: plate centre, right ascension - minutes. */
+	  // DSS: plate centre, right ascension - minutes.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+7;
@@ -1403,7 +1367,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTRAS"  " {
-	  /* DSS: plate centre, right ascension - seconds. */
+	  // DSS: plate centre, right ascension - seconds.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+8;
@@ -1415,7 +1379,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTDECSN {
-	  /* DSS: plate centre, declination - sign. */
+	  // DSS: plate centre, declination - sign.
 	  valtype = STRING;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+9;
@@ -1427,7 +1391,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTDECD" " {
-	  /* DSS: plate centre, declination - degrees. */
+	  // DSS: plate centre, declination - degrees.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+10;
@@ -1439,7 +1403,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTDECM" " {
-	  /* DSS: plate centre, declination - arcmin. */
+	  // DSS: plate centre, declination - arcmin.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+11;
@@ -1451,7 +1415,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTDECS" " {
-	  /* DSS: plate centre, declination - arcsec. */
+	  // DSS: plate centre, declination - arcsec.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+12;
@@ -1463,7 +1427,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLATEID" " {
-	  /* DSS: plate identification (insufficient to trigger DSS). */
+	  // DSS: plate identification (insufficient to trigger DSS).
 	  valtype = STRING;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+13;
@@ -1475,7 +1439,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^AMDX	{
-	  /* DSS: axis 1 polynomial coefficient. */
+	  // DSS: axis 1 polynomial coefficient.
 	  i = 1;
 	  dssflag = 3;
 	
@@ -1484,7 +1448,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^AMDY	{
-	  /* DSS: axis 2 polynomial coefficient. */
+	  // DSS: axis 2 polynomial coefficient.
 	  i = 2;
 	  dssflag = 3;
 	
@@ -1493,7 +1457,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^WAT[12]_{Z3} {
-	  /* TNX or ZPX: string-encoded data array. */
+	  // TNX or ZPX: string-encoded data array.
 	  sscanf(yytext, "WAT%d_%d", &i, &m);
 	  if (watn < m) watn = m;
 	  watflag = 1;
@@ -1510,8 +1474,8 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^END" "{77} {
-	  if (wcspih_nkeyrec) {
-	    wcspih_nkeyrec = 0;
+	  if (yyextra->nkeyrec) {
+	    yyextra->nkeyrec = 0;
 	    errmsg = "keyrecords following the END keyrecord were ignored";
 	    BEGIN(ERROR);
 	  } else {
@@ -1539,13 +1503,13 @@ jmp_buf wcspih_abort_jmp_env;
 <CCCCCia>0{I1}{ALT}      |
 <CCCCCia>0{Z1}{I1} {
 	  if (relax & WCSHDR_reject) {
-	    /* Violates the basic FITS standard. */
+	    // Violates the basic FITS standard.
 	    errmsg = "indices in parameterized keywords must not have "
 	             "leading zeroes";
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1559,27 +1523,27 @@ jmp_buf wcspih_abort_jmp_env;
 <CCCCCia>{Z1}{ALT}" " |
 <CCCCCia>{Z2}{ALT}    |
 <CCCCCia>{Z3} {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
 
 <CCia>. {
-	  /* Let it go. */
+	  // Let it go.
 	  BEGIN(DISCARD);
 	}
 
 <CCCCCia>. {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "keyword looks very much like %s but isn't",
 	      keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Let it go. */
+	    // Let it go.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1625,7 +1589,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1640,8 +1604,8 @@ jmp_buf wcspih_abort_jmp_env;
 <CCi_ja>{Z3}_{Z2} |
 <CCi_ja>{Z2}_{Z3} |
 <CCi_ja>{Z1}_{Z4} {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
@@ -1663,7 +1627,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 <CCi_ja>{Z2}{I1}{Z2}{I1} {
-	  /* This covers the defunct forms CD00i00j and PC00i00j. */
+	  // This covers the defunct forms CD00i00j and PC00i00j.
 	  if (((altlin == 1) && (relax & WCSHDR_PC00i00j)) ||
 	      ((altlin == 2) && (relax & WCSHDR_CD00i00j))) {
 	    sscanf(yytext, "%3d%3d", &i, &j);
@@ -1678,7 +1642,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1701,14 +1665,14 @@ jmp_buf wcspih_abort_jmp_env;
 
 <CCCCCCCa>. {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "invalid alternate code, keyword resembles %s "
 	      "but isn't", keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1753,7 +1717,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1768,8 +1732,8 @@ jmp_buf wcspih_abort_jmp_env;
 <CCi_ma>{Z3}_{Z2} |
 <CCi_ma>{Z2}_{Z3} |
 <CCi_ma>{Z1}_{Z4} {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
@@ -1813,7 +1777,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1856,7 +1820,7 @@ jmp_buf wcspih_abort_jmp_env;
 
 <SIP2>{Z1}_{Z1}"   " |
 <SIP3>{Z1}_{Z1}"  " {
-	  /* SIP keywords. */
+	  // SIP keywords.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.dp);
@@ -1876,7 +1840,7 @@ jmp_buf wcspih_abort_jmp_env;
 
 <DSSAMDXY>{I1}"   " |
 <DSSAMDXY>{I2}"  " {
-	  /* DSS keywords. */
+	  // DSS keywords.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = &(distem.dp);
@@ -1894,9 +1858,9 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 <PLTDECSN>=" "+{STRING} {
-	  /* Special handling for this iconic DSS keyword. */
+	  // Special handling for this iconic DSS keyword.
 	  if (1 < ipass) {
-	    /* Look for a minus sign. */
+	    // Look for a minus sign.
 	    sscanf(yytext, "= '%s", strtmp);
 	    dbltmp = strcmp(strtmp, "-") ? 1.0 : -1.0;
 	  }
@@ -1909,7 +1873,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 <VALUE>=" "+ {
-	  /* Do checks on i, j & m. */
+	  // Do checks on i, j & m.
 	  if (99 < i || 99 < j || 99 < m) {
 	    if (relax & WCSHDR_reject) {
 	      if (99 < i || 99 < j) {
@@ -1920,7 +1884,7 @@ jmp_buf wcspih_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -1954,7 +1918,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    sscanf(yytext, "%d", &inttmp);
 	
 	    BEGIN(COMMENT);
@@ -1971,7 +1935,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    wcsutil_str2double(yytext, &dbltmp);
 
 	    if (chekval && chekval(dbltmp)) {
@@ -1993,7 +1957,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue as integer and fractional parts. */
+	    // Read the keyvalue as integer and fractional parts.
 	    wcsutil_str2double2(yytext, dbl2tmp);
 	
 	    BEGIN(COMMENT);
@@ -2010,12 +1974,12 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    strcpy(strtmp, yytext+1);
 	
-	    /* Squeeze out repeated quotes. */
-	    ix = 0;
-	    for (jx = 0; jx < 72; jx++) {
+	    // Squeeze out repeated quotes.
+	    int ix = 0;
+	    for (int jx = 0; jx < 72; jx++) {
 	      if (ix < jx) {
 	        strtmp[ix] = strtmp[jx];
 	      }
@@ -2097,16 +2061,16 @@ jmp_buf wcspih_abort_jmp_env;
 
 <COMMENT>{INLINE}$ {
 	  if (ipass == 1) {
-	    /* Do first-pass bookkeeping. */
+	    // Do first-pass bookkeeping.
 	    wcspih_pass1(naxis, i, j, a, distype, alts, dpq, npptr);
 	    BEGIN(FLUSH);
 	
 	  } else if (*wcs) {
-	    /* Store the value now that the keyrecord has been validated. */
-	    gotone = 0;
-	    for (ialt = 0; ialt < *nwcs; ialt++) {
-	      /* The loop here is for keywords that apply */
-	      /* to every alternate; these have a == 0. */
+	    // Store the value now that the keyrecord has been validated.
+	    int gotone = 0;
+	    for (int ialt = 0; ialt < *nwcs; ialt++) {
+	      // The loop here is for keywords that apply
+	      // to every alternate; these have a == 0.
 	      if (a >= 'A') {
 	        ialt = alts[a-'A'+1];
 	        if (ialt < 0) break;
@@ -2115,11 +2079,12 @@ jmp_buf wcspih_abort_jmp_env;
 	
 	      if (vptr) {
 	        if (sipflag) {
-	          /* Translate a SIP keyword into DPja. */
-	          disp = (*wcs)->lin.dispre;
-	          ipx = (disp->ndp)++;
+	          // Translate a SIP keyword into DPja.
+	          struct disprm *disp = (*wcs)->lin.dispre;
+	          int ipx = (disp->ndp)++;
 	
-	          /* SIP doesn't have alternates. */
+	          // SIP doesn't have alternates.
+		  char keyword[16];
 	          sprintf(keyword, "DP%d", i);
 	          sprintf(strtmp, "SIP.%s.%d_%d", (sipflag==2)?"FWD":"REV",
 	                  p, q);
@@ -2130,27 +2095,28 @@ jmp_buf wcspih_abort_jmp_env;
 	          }
 	
 	        } else if (dssflag) {
-	          /* All DSS keywords require special handling. */
+	          // All DSS keywords require special handling.
 	          if (dssflag == 1) {
-	            /* Temporary parameter for DSS used by wcspih_final(). */
+	            // Temporary parameter for DSS used by wcspih_final().
 	            *((double *)vptr) = dbltmp;
 	
 	          } else if (dssflag == 2) {
-	            /* Temporary parameter for DSS used by wcspih_final(). */
+	            // Temporary parameter for DSS used by wcspih_final().
 	            strcpy((char *)vptr, strtmp);
 	
 	          } else {
-	            /* Translate a DSS keyword into DQia. */
+	            // Translate a DSS keyword into DQia.
 	            if (m <= 13 || dbltmp != 0.0) {
-	              disp = (*wcs)->lin.disseq;
-	              ipx = (disp->ndp)++;
+	              struct disprm *disp = (*wcs)->lin.disseq;
+	              int ipx = (disp->ndp)++;
 	
-	              /* DSS doesn't have alternates. */
+	              // DSS doesn't have alternates.
+		      char keyword[16];
 	              sprintf(keyword, "DQ%d", i);
 	              sprintf(strtmp, "DSS.AMD.%d", m);
 	              dpfill(disp->dp+ipx, keyword, strtmp, i, 1, 0, dbltmp);
 	
-	              /* Also required by wcspih_final(). */
+	              // Also required by wcspih_final().
 	              if (m <= 3) {
 	                dsstmp[13+(i-1)*3+m] = dbltmp;
 	              }
@@ -2158,32 +2124,35 @@ jmp_buf wcspih_abort_jmp_env;
 	          }
 	
 	        } else if (watflag) {
-	          /* String array for TNX and ZPX used by wcspih_final(). */
+	          // String array for TNX and ZPX used by wcspih_final().
 	          strcpy((char *)vptr, strtmp);
 	
 	        } else {
-	          /* An "ordinary" keyword. */
-	          wcsp = *wcs + ialt;
+	          // An "ordinary" keyword.
+	          struct wcsprm *wcsp = *wcs + ialt;
+		  struct disprm *disp;
+	          void *wptr;
+	          ptrdiff_t voff;
 	          if (auxprm) {
-	            /* Additional auxiliary parameter. */
-	            auxp = wcsp->aux;
+	            // Additional auxiliary parameter.
+	            struct auxprm *auxp = wcsp->aux;
 	            voff = (char *)vptr - (char *)(&auxtem);
 	            wptr = (void *)((char *)auxp + voff);
 	
 	          } else if (distype) {
-	            /* Distortion parameter of some kind. */
+	            // Distortion parameter of some kind.
 	            if (distype == PRIOR) {
-	              /* Prior distortion. */
+	              // Prior distortion.
 	              disp = wcsp->lin.dispre;
 	            } else {
-	              /* Sequent distortion. */
+	              // Sequent distortion.
 	              disp = wcsp->lin.disseq;
 	            }
 	            voff = (char *)vptr - (char *)(&distem);
 	            wptr = (void *)((char *)disp + voff);
 	
 	          } else {
-	            /* A parameter that lives directly in wcsprm. */
+	            // A parameter that lives directly in wcsprm.
 	            voff = (char *)vptr - (char *)(&wcstem);
 	            wptr = (void *)((char *)wcsp + voff);
 	          }
@@ -2192,9 +2161,9 @@ jmp_buf wcspih_abort_jmp_env;
 	            *((int *)wptr) = inttmp;
 	
 	          } else if (valtype == FLOAT) {
-	            /* Apply keyword parameterization. */
+	            // Apply keyword parameterization.
 	            if (npptr == npv) {
-	              ipx = (wcsp->npv)++;
+	              int ipx = (wcsp->npv)++;
 	              wcsp->pv[ipx].i = i;
 	              wcsp->pv[ipx].m = m;
 	              wptr = &(wcsp->pv[ipx].value);
@@ -2213,14 +2182,14 @@ jmp_buf wcspih_abort_jmp_env;
 	              *((double *)wptr) = dbltmp;
 	            }
 	
-	            /* Flag presence of PCi_ja, or CDi_ja and/or CROTAia. */
+	            // Flag presence of PCi_ja, or CDi_ja and/or CROTAia.
 	            if (altlin) {
 	              wcsp->altlin |= altlin;
 	              altlin = 0;
 	            }
 	
 	          } else if (valtype == FLOAT2) {
-	            /* Split MJDREF and JDREF into integer and fraction.*/
+	            // Split MJDREF and JDREF into integer and fraction.
 	            if (special) {
 	              special(wptr, dbl2tmp);
 	            } else {
@@ -2229,9 +2198,9 @@ jmp_buf wcspih_abort_jmp_env;
 	            }
 	
 	          } else if (valtype == STRING) {
-	            /* Apply keyword parameterization. */
+	            // Apply keyword parameterization.
 	            if (npptr == nps) {
-	              ipx = (wcsp->nps)++;
+	              int ipx = (wcsp->nps)++;
 	              wcsp->ps[ipx].i = i;
 	              wcsp->ps[ipx].m = m;
 	              wptr = wcsp->ps[ipx].value;
@@ -2244,12 +2213,13 @@ jmp_buf wcspih_abort_jmp_env;
 	              wptr = *((char (**)[72])wptr) + (i - 1);
 	            }
 	
-	            cptr = (char *)wptr;
+	            char *cptr = (char *)wptr;
 	            strcpy(cptr, strtmp);
 	
 	          } else if (valtype == RECORD) {
-	            ipx = (disp->ndp)++;
+	            int ipx = (disp->ndp)++;
 	
+		    char keyword[16];
 	            if (a == ' ') {
 	              sprintf(keyword, "%.2s%d", keyname, i);
 	            } else {
@@ -2270,7 +2240,7 @@ jmp_buf wcspih_abort_jmp_env;
 	      if (ctrl == 4) {
 	        if (distran || dssflag) {
 	          wcsfprintf(stderr, "%.80s\n  Accepted (%d) as a "
-	            "recognised WCS convention.\n", keyrec, nvalid);
+	            "recognized WCS convention.\n", keyrec, nvalid);
 	        } else {
 	          wcsfprintf(stderr, "%.80s\n  Accepted (%d) as a "
 	            "valid WCS keyrecord.\n", keyrec, nvalid);
@@ -2312,7 +2282,7 @@ jmp_buf wcspih_abort_jmp_env;
 <DISCARD>.*$ {
 	  if (ipass == npass) {
 	    if (ctrl < 0) {
-	      /* Preserve discards. */
+	      // Preserve discards.
 	      keep = keyrec;
 	
 	    } else if (2 < ctrl) {
@@ -2329,7 +2299,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    (*nreject)++;
 	
 	    if (ctrl%10 == -1) {
-	      /* Preserve rejects. */
+	      // Preserve rejects.
 	      keep = keyrec;
 	    }
 	
@@ -2351,7 +2321,7 @@ jmp_buf wcspih_abort_jmp_env;
 	
 	  naux += auxprm;
 	
-	  /* Throw away the rest of the line and reset for the next one. */
+	  // Throw away the rest of the line and reset for the next one.
 	  i = j = 0;
 	  m = 0;
 	  a = ' ';
@@ -2376,7 +2346,8 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 <<EOF>>	 {
-	  /* End-of-input. */
+	  // End-of-input.
+	  int status;
 	  if (ipass == 1) {
 	    if ((status = wcspih_init1(naxis, alts, dpq, npv, nps, ndp, ndq,
 	                               naux, distran, nwcs, wcs)) ||
@@ -2401,8 +2372,8 @@ jmp_buf wcspih_abort_jmp_env;
 	  }
 	
 	  if (ipass++ < npass) {
-	    wcspih_hdr = header;
-	    wcspih_nkeyrec = nkeyrec;
+	    yyextra->hdr = header;
+	    yyextra->nkeyrec = nkeyrec;
 	    keyrec = header;
 	    *nreject = 0;
 	
@@ -2451,6 +2422,35 @@ jmp_buf wcspih_abort_jmp_env;
 %%
 
 /*----------------------------------------------------------------------------
+* External interface to the scanner.
+*---------------------------------------------------------------------------*/
+
+int wcspih(
+  char *header,
+  int nkeyrec,
+  int relax,
+  int ctrl,
+  int *nreject,
+  int *nwcs,
+  struct wcsprm **wcs)
+
+{
+  // Function prototypes.
+  int yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *yyscanner);
+  int yylex_destroy(yyscan_t yyscanner);
+
+  struct wcspih_extra extra;
+  yyscan_t yyscanner;
+  yylex_init_extra(&extra, &yyscanner);
+  int status = wcspih_scanner(header, nkeyrec, relax, ctrl, nreject, nwcs,
+                              wcs, yyscanner);
+  yylex_destroy(yyscanner);
+
+  return status;
+}
+
+
+/*----------------------------------------------------------------------------
 * Determine the number of coordinate representations (up to 27) and the
 * number of coordinate axes in each, which distortions are present, and the
 * number of PVi_ma, PSi_ma, DPja, and DQia keywords in each representation.
@@ -2467,26 +2467,24 @@ void wcspih_pass1(
   int *npptr)
 
 {
-  /* On the first pass alts[] is used to determine the number of axes */
-  /* for each of the 27 possible alternate coordinate descriptions.   */
-  int ialt, *ip;
-
+  // On the first pass alts[] is used to determine the number of axes
+  // for each of the 27 possible alternate coordinate descriptions.
   if (a == 0) {
     return;
   }
 
-  ialt = 0;
+  int ialt = 0;
   if (a != ' ') {
     ialt = a - 'A' + 1;
   }
 
-  ip = alts + ialt;
+  int *ip = alts + ialt;
 
   if (*ip < naxis) {
     *ip = naxis;
   }
 
-  /* i or j can be greater than naxis. */
+  // i or j can be greater than naxis.
   if (*ip < i) {
     *ip = i;
   }
@@ -2495,10 +2493,10 @@ void wcspih_pass1(
     *ip = j;
   }
 
-  /* Type of distortions present. */
+  // Type of distortions present.
   dpq[ialt] |= distype;
 
-  /* Count PVi_ma, PSi_ma, DPja, or DQia keywords. */
+  // Count PVi_ma, PSi_ma, DPja, or DQia keywords.
   if (npptr) {
     npptr[ialt]++;
   }
@@ -2524,115 +2522,115 @@ int wcspih_init1(
   struct wcsprm **wcs)
 
 {
-  int ialt, defaults, ndis, ndpmax, npsmax, npvmax, status = 0;
-  struct wcsprm *wcsp;
-  struct disprm *dis;
+  int status = 0;
 
-  /* Find the number of coordinate descriptions. */
+  // Find the number of coordinate descriptions.
   *nwcs = 0;
-  for (ialt = 0; ialt < 27; ialt++) {
+  for (int ialt = 0; ialt < 27; ialt++) {
     if (alts[ialt]) (*nwcs)++;
   }
 
+  int defaults;
   if ((defaults = !(*nwcs) && naxis)) {
-    /* NAXIS is non-zero but there were no WCS keywords with an alternate
-       version code; create a default WCS with blank alternate version. */
+    // NAXIS is non-zero but there were no WCS keywords with an alternate
+    // version code; create a default WCS with blank alternate version.
     wcspih_pass1(naxis, 0, 0, ' ', 0, alts, dpq, 0x0);
     *nwcs = 1;
   }
 
   if (*nwcs) {
-    /* Allocate memory for the required number of wcsprm structs. */
+    // Allocate memory for the required number of wcsprm structs.
     if ((*wcs = calloc(*nwcs, sizeof(struct wcsprm))) == 0x0) {
       return WCSHDRERR_MEMORY;
     }
 
-    ndis = 0;
+    int ndis = 0;
     if (distran == SIP) {
-      /* DPja.NAXES and DPja.OFFSET.j to be added for SIP (see below and
-         wcspih_final()). */
+      // DPja.NAXES and DPja.OFFSET.j to be added for SIP (see below and
+      // wcspih_final()).
       ndp[0] += 6;
 
     } else if (distran == DSS) {
-      /* DPja.NAXES to be added for DSS (see below and wcspih_final()). */
+      // DPja.NAXES to be added for DSS (see below and wcspih_final()).
       ndq[0] += 2;
     }
 
-    /* Initialize each wcsprm struct. */
-    wcsp = *wcs;
+    // Initialize each wcsprm struct.
+    struct wcsprm *wcsp = *wcs;
     *nwcs = 0;
-    for (ialt = 0; ialt < 27; ialt++) {
+    for (int ialt = 0; ialt < 27; ialt++) {
       if (alts[ialt]) {
         wcsp->flag = -1;
-        npvmax = npv[ialt];
-        npsmax = nps[ialt];
+        int npvmax = npv[ialt];
+        int npsmax = nps[ialt];
         if ((status = wcsinit(1, alts[ialt], wcsp, npvmax, npsmax, -1))) {
           wcsvfree(nwcs, wcs);
           break;
         }
 
-        /* Record the alternate version code. */
+        // Record the alternate version code.
         if (ialt) {
           wcsp->alt[0] = 'A' + ialt - 1;
         }
 
-        /* Record in wcsname whether this is a default description. */
+        // Record in wcsname whether this is a default description.
         if (defaults) {
           strcpy(wcsp->wcsname, "DEFAULTS");
         }
 
-        /* Any additional auxiliary keywords present? */
+        // Any additional auxiliary keywords present?
         if (naux) {
           if (wcsauxi(1, wcsp)) {
             return WCSHDRERR_MEMORY;
           }
         }
 
-        /* Any distortions present? */
+        // Any distortions present?
+        struct disprm *disp;
         if (dpq[ialt] & 1) {
-          if ((dis = calloc(1, sizeof(struct disprm))) == 0x0) {
+          if ((disp = calloc(1, sizeof(struct disprm))) == 0x0) {
             return WCSHDRERR_MEMORY;
           }
 
-          /* Attach it to linprm.  Also inits it. */
+          // Attach it to linprm.  Also inits it.
           ndis++;
-          ndpmax = ndp[ialt];
-          dis->flag = -1;
-          lindist(1, &(wcsp->lin), dis, ndpmax);
+          int ndpmax = ndp[ialt];
+          disp->flag = -1;
+          lindist(1, &(wcsp->lin), disp, ndpmax);
         }
 
         if (dpq[ialt] & 2) {
-          if ((dis = calloc(1, sizeof(struct disprm))) == 0x0) {
+          if ((disp = calloc(1, sizeof(struct disprm))) == 0x0) {
             return WCSHDRERR_MEMORY;
           }
 
-          /* Attach it to linprm.  Also inits it. */
+          // Attach it to linprm.  Also inits it.
           ndis++;
-          ndpmax = ndq[ialt];
-          dis->flag = -1;
-          lindist(2, &(wcsp->lin), dis, ndpmax);
+          int ndpmax = ndq[ialt];
+          disp->flag = -1;
+          lindist(2, &(wcsp->lin), disp, ndpmax);
         }
 
-        /* On the second pass alts[] indexes the array of wcsprm structs. */
+        // On the second pass alts[] indexes the array of wcsprm structs.
         alts[ialt] = (*nwcs)++;
 
         wcsp++;
 
       } else {
-        /* Signal that there is no wcsprm for this alt. */
+        // Signal that there is no wcsprm for this alt.
         alts[ialt] = -1;
       }
     }
 
 
-    /* Translated distortion?  Neither SIP nor DSS have alternates, so the */
-    /* presence of keywords for either (not both together), as flagged by  */
-    /* distran, necessarily refers to the primary representation.          */
+    // Translated distortion?  Neither SIP nor DSS have alternates, so the
+    // presence of keywords for either (not both together), as flagged by
+    // distran, necessarily refers to the primary representation.
     if (distran == SIP) {
       strcpy((*wcs)->lin.dispre->dtype[0], "SIP");
       strcpy((*wcs)->lin.dispre->dtype[1], "SIP");
 
-      /* SIP doesn't have axis mapping. */
+      // SIP doesn't have axis mapping.
       (*wcs)->lin.dispre->ndp = 6;
       dpfill((*wcs)->lin.dispre->dp,   "DP1", "NAXES",  0, 0, 2, 0.0);
       dpfill((*wcs)->lin.dispre->dp+3, "DP2", "NAXES",  0, 0, 2, 0.0);
@@ -2641,7 +2639,7 @@ int wcspih_init1(
       strcpy((*wcs)->lin.disseq->dtype[0], "DSS");
       strcpy((*wcs)->lin.disseq->dtype[1], "DSS");
 
-      /* The Paper IV translation of DSS doesn't require an axis mapping. */
+      // The Paper IV translation of DSS doesn't require an axis mapping.
       (*wcs)->lin.disseq->ndp = 2;
       dpfill((*wcs)->lin.disseq->dp,   "DQ1", "NAXES",  0, 0, 2, 0.0);
       dpfill((*wcs)->lin.disseq->dp+1, "DQ2", "NAXES",  0, 0, 2, 0.0);
@@ -2659,7 +2657,7 @@ int wcspih_init1(
 int wcspih_jdref(double *mjdref, const double *jdref)
 
 {
-  /* Set MJDREF from JDREF. */
+  // Set MJDREF from JDREF.
   if (undefined(mjdref[0] && undefined(mjdref[1]))) {
     mjdref[0] = jdref[0] - 2400000.0;
     mjdref[1] = jdref[1] - 0.5;
@@ -2676,7 +2674,7 @@ int wcspih_jdref(double *mjdref, const d
 int wcspih_jdrefi(double *mjdref, const double *jdrefi)
 
 {
-  /* Set the integer part of MJDREF from JDREFI. */
+  // Set the integer part of MJDREF from JDREFI.
   if (undefined(mjdref[0])) {
     mjdref[0] = *jdrefi - 2400000.5;
   }
@@ -2688,7 +2686,7 @@ int wcspih_jdrefi(double *mjdref, const
 int wcspih_jdreff(double *mjdref, const double *jdreff)
 
 {
-  /* Set the fractional part of MJDREF from JDREFF. */
+  // Set the fractional part of MJDREF from JDREFF.
   if (undefined(mjdref[1])) {
     mjdref[1] = *jdreff;
   }
@@ -2704,7 +2702,7 @@ int wcspih_jdreff(double *mjdref, const
 int wcspih_epoch(double *equinox, const double *epoch)
 
 {
-  /* If EQUINOXa is currently undefined then set it from EPOCHa. */
+  // If EQUINOXa is currently undefined then set it from EPOCHa.
   if (undefined(*equinox)) {
     *equinox = *epoch;
   }
@@ -2720,12 +2718,12 @@ int wcspih_epoch(double *equinox, const
 int wcspih_vsource(double *zsource, const double *vsource)
 
 {
-  double beta, c = 299792458.0;
+  const double c = 299792458.0;
 
-  /* If ZSOURCEa is currently undefined then set it from VSOURCEa. */
+  // If ZSOURCEa is currently undefined then set it from VSOURCEa.
   if (undefined(*zsource)) {
-    /* Convert relativistic Doppler velocity to redshift. */
-    beta = *vsource/c;
+    // Convert relativistic Doppler velocity to redshift.
+    double beta = *vsource/c;
     *zsource = (1.0 + beta)/sqrt(1.0 - beta*beta) - 1.0;
   }
 
@@ -2758,58 +2756,52 @@ int wcspih_final(
   struct wcsprm **wcs)
 
 {
-  char   field[32], *wp, wpoly[12], wtype[8];
-  int    i, ialt, idp, ipv, m, npv, n, nterms, omax, omin, status, wctrl[4];
-  double A1, A2, A3, B1, B2, B3, CNPIX1, CNPIX2, *crval, Rx, Ry, S, wval,
-         X0, Y0, Xc, Yc;
-  struct disprm *disp;
-  struct wcsprm *wcsp;
-
-  for (ialt = 0; ialt < *nwcs; ialt++) {
-    /* Interpret -TAB header keywords. */
+  for (int ialt = 0; ialt < *nwcs; ialt++) {
+    // Interpret -TAB header keywords.
+    int status;
     if ((status = wcstab(*wcs+ialt))) {
        wcsvfree(nwcs, wcs);
        return status;
     }
 
     if (ndp[ialt] && ndq[ialt]) {
-      /* Prior and sequent distortions co-exist in this representation;
-         ensure the latter gets DVERRa. */
+      // Prior and sequent distortions co-exist in this representation;
+      // ensure the latter gets DVERRa.
       (*wcs+ialt)->lin.disseq->totdis = (*wcs+ialt)->lin.dispre->totdis;
     }
   }
 
-  /* Translated distortion functions; apply only to the primary WCS. */
-  wcsp = *wcs;
+  // Translated distortion functions; apply only to the primary WCS.
+  struct wcsprm *wcsp = *wcs;
   if (distran == SIP) {
-    /* SIP doesn't have alternates, nor axis mapping. */
-    disp = wcsp->lin.dispre;
+    // SIP doesn't have alternates, nor axis mapping.
+    struct disprm *disp = wcsp->lin.dispre;
     dpfill(disp->dp+1, "DP1", "OFFSET.1",  0, 1, 0, wcsp->crpix[0]);
     dpfill(disp->dp+2, "DP1", "OFFSET.2",  0, 1, 0, wcsp->crpix[1]);
     dpfill(disp->dp+4, "DP2", "OFFSET.1",  0, 1, 0, wcsp->crpix[0]);
     dpfill(disp->dp+5, "DP2", "OFFSET.2",  0, 1, 0, wcsp->crpix[1]);
 
   } else if (distran == DSS) {
-    /* DSS doesn't have alternates, nor axis mapping.  This translation */
-    /* follows Paper IV, Sect. 5.2 using the same variable names.       */
-    CNPIX1 = dsstmp[0];
-    CNPIX2 = dsstmp[1];
-
-    Xc = dsstmp[2]/1000.0;
-    Yc = dsstmp[3]/1000.0;
-    Rx = dsstmp[4]/1000.0;
-    Ry = dsstmp[5]/1000.0;
-
-    A1 = dsstmp[14];
-    A2 = dsstmp[15];
-    A3 = dsstmp[16];
-    B1 = dsstmp[17];
-    B2 = dsstmp[18];
-    B3 = dsstmp[19];
-    S  = sqrt(fabs(A1*B1 - A2*B2));
+    // DSS doesn't have alternates, nor axis mapping.  This translation
+    // follows Paper IV, Sect. 5.2 using the same variable names.
+    double CNPIX1 = dsstmp[0];
+    double CNPIX2 = dsstmp[1];
+
+    double Xc = dsstmp[2]/1000.0;
+    double Yc = dsstmp[3]/1000.0;
+    double Rx = dsstmp[4]/1000.0;
+    double Ry = dsstmp[5]/1000.0;
+
+    double A1 = dsstmp[14];
+    double A2 = dsstmp[15];
+    double A3 = dsstmp[16];
+    double B1 = dsstmp[17];
+    double B2 = dsstmp[18];
+    double B3 = dsstmp[19];
+    double S  = sqrt(fabs(A1*B1 - A2*B2));
 
-    X0 = (A2*B3 - A3*B1) / (A1*B1 - A2*B2);
-    Y0 = (A3*B2 - A1*B3) / (A1*B1 - A2*B2);
+    double X0 = (A2*B3 - A3*B1) / (A1*B1 - A2*B2);
+    double Y0 = (A3*B2 - A1*B3) / (A1*B1 - A2*B2);
 
     wcsp->crpix[0] = (Xc - X0)/Rx - (CNPIX1 - 0.5);
     wcsp->crpix[1] = (Yc + Y0)/Ry - (CNPIX2 - 0.5);
@@ -2823,7 +2815,7 @@ int wcspih_final(
     wcsp->cdelt[0] = -S/3600.0;
     wcsp->cdelt[1] =  S/3600.0;
 
-    crval = wcsp->crval;
+    double *crval = wcsp->crval;
     crval[0] = (dsstmp[6]  + (dsstmp[7]  + dsstmp[8] /60.0)/60.0)*15.0;
     crval[1] =  dsstmp[10] + (dsstmp[11] + dsstmp[12]/60.0)/60.0;
     if (dsstmp[9] == -1.0) crval[1] *= -1.0;
@@ -2833,19 +2825,23 @@ int wcspih_final(
 
     sprintf(wcsp->wcsname, "DSS PLATEID %.4s", (char *)(dsstmp+13));
 
-    /* Erase the approximate WCS provided in modern DSS headers. */
+    // Erase the approximate WCS provided in modern DSS headers.
     wcsp->cd[0] = 0.0;
     wcsp->cd[1] = 0.0;
     wcsp->cd[2] = 0.0;
     wcsp->cd[3] = 0.0;
 
   } else if (distran == WAT) {
-    /* TNX and ZPX don't have alternates, nor axis mapping. */
-    disp = wcsp->lin.disseq;
+    // TNX and ZPX don't have alternates, nor axis mapping.
+    char *wp;
+    int  omax, omin, wctrl[4];
+    double wval;
+    struct disprm *disp = wcsp->lin.disseq;
 
-    /* Disassemble the core dump stored in the WATi_m strings. */
-    nterms = 0;
+    // Disassemble the core dump stored in the WATi_m strings.
+    int i, nterms = 0;
     for (i = 0; i < 2; i++) {
+      char wtype[8];
       sscanf(wat[i], "wtype=%s", wtype);
 
       if (strcmp(wtype, "tnx") == 0) {
@@ -2853,22 +2849,23 @@ int wcspih_final(
       } else if (strcmp(wtype, "zpx") == 0) {
         strcpy(disp->dtype[i], "WAT-ZPX");
       } else {
-        /* Could contain "tan" or something else to be ignored. */
+        // Could contain "tan" or something else to be ignored.
         lindist(2, &(wcsp->lin), 0x0, 0);
         return 0;
       }
 
-      /* The PROJPn parameters are duplicated on each ZPX axis. */
+      // The PROJPn parameters are duplicated on each ZPX axis.
       if (i == 1 && strcmp(wtype, "zpx") == 0) {
-        /* Take those on the second (latitude) axis ignoring the other. */
-        /* First we have to count them and allocate space in wcsprm.    */
-        wp  = wat[i];
+        // Take those on the second (latitude) axis ignoring the other.
+        // First we have to count them and allocate space in wcsprm.
+        wp = wat[i];
+	int npv;
         for (npv = 0; npv < 30; npv++) {
           if ((wp = strstr(wp, "projp")) == 0x0) break;
           wp += 5;
         }
 
-        /* Allocate space. */
+        // Allocate space.
         if (npv) {
           wcsp->npvmax += npv;
           wcsp->pv = realloc(wcsp->pv, wcsp->npvmax*sizeof(struct pvcard));
@@ -2879,11 +2876,12 @@ int wcspih_final(
           wcsp->m_pv = wcsp->pv;
         }
 
-        /* Copy the values. */
+        // Copy the values.
         wp = wat[i];
-        for (ipv = wcsp->npv; ipv < wcsp->npvmax; ipv++) {
+        for (int ipv = wcsp->npv; ipv < wcsp->npvmax; ipv++) {
           if ((wp = strstr(wp, "projp")) == 0x0) break;
 
+          int m;
           sscanf(wp, "projp%d=%lf", &m, &wval);
           wcsp->pv[ipv].i = 2;
           wcsp->pv[ipv].m = m;
@@ -2895,13 +2893,13 @@ int wcspih_final(
         wcsp->npv += npv;
       }
 
-      /* Read the control parameters. */
+      // Read the control parameters.
       if ((wp = strchr(wat[i], '"')) == 0x0) {
         return WCSHDRERR_PARSER;
       }
       wp++;
 
-      for (m = 0; m < 4; m++) {
+      for (int m = 0; m < 4; m++) {
         sscanf(wp, "%d", wctrl+m);
         if ((wp = strchr(wp, ' ')) == 0x0) {
           return WCSHDRERR_PARSER;
@@ -2909,24 +2907,24 @@ int wcspih_final(
         wp++;
       }
 
-      /* How many coefficients are we expecting? */
+      // How many coefficients are we expecting?
       omin = (wctrl[1] < wctrl[2]) ? wctrl[1] : wctrl[2];
       omax = (wctrl[1] < wctrl[2]) ? wctrl[2] : wctrl[1];
       if (wctrl[3] == 0) {
-        /* No cross terms. */
+        // No cross terms.
         nterms += omin + omax;
 
       } else if (wctrl[3] == 1) {
-        /* Full cross terms. */
+        // Full cross terms.
         nterms += omin*omax;
 
       } else if (wctrl[3] == 2) {
-        /* Half cross terms. */
+        // Half cross terms.
         nterms += omin*omax - omin*(omin-1)/2;
       }
     }
 
-    /* Allocate memory for dpkeys. */
+    // Allocate memory for dpkeys.
     ndq[0] += 2*(1 + 1 + 4) + nterms;
 
     disp->ndpmax += ndq[0];
@@ -2938,18 +2936,18 @@ int wcspih_final(
     disp->m_dp = disp->dp;
 
 
-    /* Populate dpkeys. */
-    idp = disp->ndp;
+    // Populate dpkeys.
+    int idp = disp->ndp;
     for (i = 0; i < 2; i++) {
       dpfill(disp->dp+(idp++), "DQ", "NAXES", i+1, 0, 2, 0.0);
 
-      /* Read the control parameters. */
+      // Read the control parameters.
       if ((wp = strchr(wat[i], '"')) == 0x0) {
         return WCSHDRERR_PARSER;
       }
       wp++;
 
-      for (m = 0; m < 4; m++) {
+      for (int m = 0; m < 4; m++) {
         sscanf(wp, "%d", wctrl+m);
         if ((wp = strchr(wp, ' ')) == 0x0) {
           return WCSHDRERR_PARSER;
@@ -2957,24 +2955,26 @@ int wcspih_final(
         wp++;
       }
 
-      /* Polynomial type. */
+      // Polynomial type.
+      char wpoly[12];
       dpfill(disp->dp+(idp++), "DQ", "WAT.POLY", i+1, 0, wctrl[0], 0.0);
       if (wctrl[0] == 1) {
-        /* Chebyshev polynomial. */
+        // Chebyshev polynomial.
         strcpy(wpoly, "CHBY");
       } else if (wctrl[0] == 2) {
-        /* Legendre polynomial. */
+        // Legendre polynomial.
         strcpy(wpoly, "LEGR");
       } else if (wctrl[0] == 3) {
-        /* Polynomial is the sum of monomials. */
+        // Polynomial is the sum of monomials.
         strcpy(wpoly, "MONO");
       } else {
-        /* Unknown code. */
+        // Unknown code.
         strcpy(wpoly, "UNKN");
       }
 
-      /* Read the scaling parameters. */
-      for (m = 0; m < 4; m++) {
+      // Read the scaling parameters.
+      char field[40];
+      for (int m = 0; m < 4; m++) {
         sscanf(wp, "%lf", &wval);
         sprintf(field, "WAT.%c%s", (m<2)?'X':'Y', (m%2)?"MAX":"MIN");
         dpfill(disp->dp+(idp++), "DQ", field, i+1, 1, 0, wval);
@@ -2985,9 +2985,9 @@ int wcspih_final(
         wp++;
       }
 
-      /* Read the coefficients. */
-      for (n = 0; n < wctrl[2]; n++) {
-        for (m = 0; m < wctrl[1]; m++) {
+      // Read the coefficients.
+      for (int n = 0; n < wctrl[2]; n++) {
+        for (int m = 0; m < wctrl[1]; m++) {
           if (wctrl[3] == 0) {
             if (m && n) continue;
           } else if (wctrl[3] == 2) {
Index: astropy-4.2.1/cextern/wcslib/C/wcsprintf.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsprintf.c
+++ astropy-4.2.1/cextern/wcslib/C/wcsprintf.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsprintf.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsprintf.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <stdarg.h>
@@ -36,27 +33,27 @@ static char  *wcsprintf_buff = 0x0;
 static char  *wcsprintf_bufp = 0x0;
 static size_t wcsprintf_size = 0;
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsprintf_set(FILE *wcsout)
 
 {
   if (wcsout != 0x0) {
-    /* Output to file. */
+    // Output to file.
     wcsprintf_file = wcsout;
 
     if (wcsprintf_buff != 0x0) {
-      /* Release the buffer. */
+      // Release the buffer.
       free(wcsprintf_buff);
       wcsprintf_buff = 0x0;
     }
 
   } else {
-    /* Output to buffer. */
+    // Output to buffer.
     wcsprintf_file = 0x0;
 
     if (wcsprintf_buff == 0x0) {
-      /* Allocate a buffer. */
+      // Allocate a buffer.
       wcsprintf_buff = malloc(1024);
       if (wcsprintf_buff == NULL) {
         return 1;
@@ -64,7 +61,7 @@ int wcsprintf_set(FILE *wcsout)
       wcsprintf_size = 1024;
     }
 
-    /* Reset pointer to the start of the buffer. */
+    // Reset pointer to the start of the buffer.
     wcsprintf_bufp = wcsprintf_buff;
     *wcsprintf_bufp = '\0';
   }
@@ -72,7 +69,7 @@ int wcsprintf_set(FILE *wcsout)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 const char *wcsprintf_buf(void)
 
@@ -80,7 +77,7 @@ const char *wcsprintf_buf(void)
   return wcsprintf_buff;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsprintf(const char *format, ...)
 
@@ -91,21 +88,21 @@ int wcsprintf(const char *format, ...)
   va_list arg_list;
 
   if (wcsprintf_buff == 0x0 && wcsprintf_file == 0x0) {
-    /* Send output to stdout if wcsprintf_set() hasn't been called. */
+    // Send output to stdout if wcsprintf_set() hasn't been called.
     wcsprintf_file = stdout;
   }
 
   va_start(arg_list, format);
 
   if (wcsprintf_file) {
-    /* Output to file. */
+    // Output to file.
     nbytes = vfprintf(wcsprintf_file, format, arg_list);
 
   } else {
-    /* Output to buffer. */
+    // Output to buffer.
     used = wcsprintf_bufp - wcsprintf_buff;
     if (wcsprintf_size - used < 128) {
-      /* Expand the buffer. */
+      // Expand the buffer.
       wcsprintf_size += 1024;
       realloc_buff = realloc(wcsprintf_buff, wcsprintf_size);
       if (realloc_buff == NULL) {
@@ -126,7 +123,7 @@ int wcsprintf(const char *format, ...)
   return nbytes;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsfprintf(FILE *stream, const char *format, ...)
 
@@ -137,21 +134,21 @@ int wcsfprintf(FILE *stream, const char
   va_list arg_list;
 
   if (wcsprintf_buff == 0x0 && wcsprintf_file == 0x0) {
-    /* Send output to stream if wcsprintf_set() hasn't been called. */
+    // Send output to stream if wcsprintf_set() hasn't been called.
     wcsprintf_file = stream;
   }
 
   va_start(arg_list, format);
 
   if (wcsprintf_file) {
-    /* Output to file. */
+    // Output to file.
     nbytes = vfprintf(wcsprintf_file, format, arg_list);
 
   } else {
-    /* Output to buffer. */
+    // Output to buffer.
     used = wcsprintf_bufp - wcsprintf_buff;
     if (wcsprintf_size - used < 128) {
-      /* Expand the buffer. */
+      // Expand the buffer.
       wcsprintf_size += 1024;
       realloc_buff = realloc(wcsprintf_buff, wcsprintf_size);
       if (realloc_buff == NULL) {
Index: astropy-4.2.1/cextern/wcslib/C/wcsprintf.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsprintf.h
+++ astropy-4.2.1/cextern/wcslib/C/wcsprintf.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsprintf.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsprintf.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -150,4 +147,4 @@ const char *wcsprintf_buf(void);
 }
 #endif
 
-#endif /* WCSLIB_WCSPRINTF */
+#endif // WCSLIB_WCSPRINTF
Index: astropy-4.2.1/cextern/wcslib/C/wcstrig.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcstrig.c
+++ astropy-4.2.1/cextern/wcslib/C/wcstrig.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcstrig.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcstrig.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -52,7 +49,7 @@ double cosd(double angle)
   return cos(angle*D2R);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double sind(double angle)
 
@@ -76,7 +73,7 @@ double sind(double angle)
   return sin(angle*D2R);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void sincosd(double angle, double *s, double *c)
 
@@ -115,7 +112,7 @@ void sincosd(double angle, double *s, do
   return;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double tand(double angle)
 
@@ -134,7 +131,7 @@ double tand(double angle)
   return tan(angle*D2R);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double acosd(double v)
 
@@ -150,7 +147,7 @@ double acosd(double v)
   return acos(v)*R2D;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double asind(double v)
 
@@ -166,7 +163,7 @@ double asind(double v)
   return asin(v)*R2D;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double atand(double v)
 
@@ -182,7 +179,7 @@ double atand(double v)
   return atan(v)*R2D;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double atan2d(double y, double x)
 
Index: astropy-4.2.1/cextern/wcslib/C/wcstrig.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcstrig.h
+++ astropy-4.2.1/cextern/wcslib/C/wcstrig.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcstrig.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcstrig.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -175,7 +172,7 @@ extern "C" {
 
 #ifdef WCSTRIG_MACRO
 
-/* Macro implementation of the trigd functions. */
+// Macro implementation of the trigd functions.
 #include "wcsmath.h"
 
 #define cosd(X) cos((X)*D2R)
@@ -193,7 +190,7 @@ extern "C" {
 
 #else
 
-/* Use WCSLIB wrappers or native trigd functions. */
+// Use WCSLIB wrappers or native trigd functions.
 
 double cosd(double angle);
 double sind(double angle);
@@ -204,14 +201,14 @@ double asind(double y);
 double atand(double s);
 double atan2d(double y, double x);
 
-/* Domain tolerance for asin() and acos() functions. */
+// Domain tolerance for asin() and acos() functions.
 #define WCSTRIG_TOL 1e-10
 
-#endif /* WCSTRIG_MACRO */
+#endif // WCSTRIG_MACRO
 
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* WCSLIB_WCSTRIG */
+#endif // WCSLIB_WCSTRIG
Index: astropy-4.2.1/cextern/wcslib/C/wcsulex.l
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsulex.l
+++ astropy-4.2.1/cextern/wcslib/C/wcsulex.l
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsulex.l,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsulex.l,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
 * wcsulex.l is a Flex description file containing the definition of a
@@ -44,6 +41,7 @@
 %option outfile="wcsulex.c"
 %option prefix="wcsulex"
 %option reentrant
+%option extra-type="struct wcsulex_extra *"
 
 /* Exponents. */
 INTEGER	  [+-]?[1-9][0-9]*
@@ -94,81 +92,64 @@ ADD_UNIT  {ADD_ALL}|{ADD_SUP}|{ADD_SUB}|
 #include "wcsunits.h"
 #include "wcsutil.h"
 
-static int wcsulex_scanner(const char unitstr[], int *func, double *scale,
-                           double units[WCSUNITS_NTYPE], struct wcserr **err,
-                           yyscan_t yyscanner);
-
-/*--------------------------------------------------------------------------*/
-
-int wcsulexe(
-  const char unitstr[],
-  int *func,
-  double *scale,
-  double units[WCSUNITS_NTYPE],
-  struct wcserr **err)
-
-{
-  int status;
-  yyscan_t yyscanner;
-  int yylex_init(yyscan_t *yyscanner);
-  int yylex_destroy(yyscan_t yyscanner);
-
-  yylex_init(&yyscanner);
-  status = wcsulex_scanner(unitstr, func, scale, units, err, yyscanner);
-  yylex_destroy(yyscanner);
-
-  return status;
-}
+// User data associated with yyscanner.
+struct wcsulex_extra {
+  // Used in preempting the call to exit() by yy_fatal_error().
+  jmp_buf abort_jmp_env;
+};
 
-/*--------------------------------------------------------------------------*/
-
-#define YY_DECL int wcsulex_scanner(const char unitstr[], int *func, \
+#define YY_DECL int wcsulexe_scanner(const char unitstr[], int *func, \
  double *scale, double units[WCSUNITS_NTYPE], struct wcserr **err, \
  yyscan_t yyscanner)
 
-/* Dummy definition to circumvent compiler warnings. */
+// Dummy definition to circumvent compiler warnings.
 #define YY_INPUT(inbuff, count, bufsize) { count = YY_NULL; }
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
-jmp_buf wcsulex_abort_jmp_env;
-#define exit(status) longjmp(wcsulex_abort_jmp_env, status)
+// Preempt the call to exit() by yy_fatal_error().
+#define exit(status) longjmp(yyextra->abort_jmp_env, status);
+
+// Internal helper functions.
+static YY_DECL;
 
 %}
 
 %%
-	static const char *function = "wcsulexe";
+	static const char *function = "wcsulexe_scanner";
 	
-	char ctmp[72];
-	int bracket  = 0;
-	int operator = 0;
-	int paren    = 0;
-	int status   = 0;
-	int func_r, i, j;
-	double dexp, expon, factor, factor_r, types[WCSUNITS_NTYPE];
-	YY_BUFFER_STATE buf;
 	void add(double *factor, double types[], double *expon, double *scale,
 	    double units[]);
 	
-	if (err) *err = 0x0;
+	// Initialise returned values.
+	*func  = 0;
+	*scale = 1.0;
 	
-	*func = 0;
-	for (i = 0; i < WCSUNITS_NTYPE; i++) {
+	for (int i = 0; i < WCSUNITS_NTYPE; i++) {
 	  units[i] = 0.0;
+	}
+	
+	if (err) *err = 0x0;
+	
+	double types[WCSUNITS_NTYPE];
+	for (int i = 0; i < WCSUNITS_NTYPE; i++) {
 	  types[i] = 0.0;
 	}
-	expon  = 1.0;
-	factor = 1.0;
-	*scale = 1.0;
+	double expon  = 1.0;
+	double factor = 1.0;
+	
+	int bracket  = 0;
+	int operator = 0;
+	int paren    = 0;
+	int status   = 0;
 	
-	/* Avert a flex-induced memory leak. */
+	// Avert a flex-induced memory leak.
 	if (YY_CURRENT_BUFFER && YY_CURRENT_BUFFER->yy_input_file == stdin) {
 	  yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
 	}
 	
 	yy_scan_string(unitstr, yyscanner);
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
-	if (setjmp(wcsulex_abort_jmp_env)) {
+	// Return here via longjmp() invoked by yy_fatal_error().
+	if (setjmp(yyextra->abort_jmp_env)) {
 	  return wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
 	}
@@ -180,7 +161,7 @@ jmp_buf wcsulex_abort_jmp_env;
 	#endif
 
 ^" "+	{
-	  /* Pretend initial whitespace doesn't exist. */
+	  // Pretend initial whitespace doesn't exist.
 	  yy_set_bol(1);
 	}
 
@@ -222,13 +203,13 @@ jmp_buf wcsulex_abort_jmp_env;
 	}
 
 ^[*.]	{
-	  /* Leading binary multiply. */
+	  // Leading binary multiply.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_DANGLING_BINOP),
 	    "Dangling binary operator in '%s'", unitstr);
 	  BEGIN(FLUSH);
 	}
 
-" "+	  /* Discard whitespace in INITIAL context. */
+" "+	  // Discard whitespace in INITIAL context.
 
 sqrt" "*"(" {
 	  expon /= 2.0;
@@ -237,7 +218,7 @@ sqrt" "*"(" {
 	}
 
 "("	{
-	  /* Gather terms in parentheses. */
+	  // Gather terms in parentheses.
 	  yyless(0);
 	  BEGIN(PAREN);
 	}
@@ -291,15 +272,18 @@ sqrt" "*"(" {
 <PAREN>")" {
 	  paren--;
 	  if (paren) {
-	    /* Not balanced yet. */
+	    // Not balanced yet.
 	    yymore();
 	
 	  } else {
-	    /* Balanced; strip off the outer parentheses and recurse. */
+	    // Balanced; strip off the outer parentheses and recurse.
 	    yytext[yyleng-1] = '\0';
 	
-	    buf = YY_CURRENT_BUFFER;
+	    int func_r;
+	    double factor_r;
 	    status = wcsulexe(yytext+1, &func_r, &factor_r, types, err);
+	
+	    YY_BUFFER_STATE buf = YY_CURRENT_BUFFER;
 	    yy_switch_to_buffer(buf, yyscanner);
 	
 	    if (func_r) {
@@ -421,125 +405,125 @@ sqrt" "*"(" {
 	}
 
 <PREFIX>. {
-	  /* Internal parser error. */
+	  // Internal parser error.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
 	  BEGIN(FLUSH);
 	}
 
 <UNITS>A {
-	  /* Ampere. */
+	  // Ampere.
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  types[WCSUNITS_TIME]   -= 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>a|yr {
-	  /* Julian year (annum). */
+	  // Julian year (annum).
 	  factor *= 31557600.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>adu {
-	  /* Analogue-to-digital converter units. */
+	  // Analogue-to-digital converter units.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>[Aa]ngstrom {
-	  /* Angstrom. */
+	  // Angstrom.
 	  factor *= 1e-10;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>arcmin {
-	  /* Minute of arc. */
+	  // Minute of arc.
 	  factor /= 60.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>arcsec {
-	  /* Second of arc. */
+	  // Second of arc.
 	  factor /= 3600.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>AU {
-	  /* Astronomical unit. */
+	  // Astronomical unit.
 	  factor *= 1.49598e+11;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>barn {
-	  /* Barn. */
+	  // Barn.
 	  factor *= 1e-28;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>beam {
-	  /* Beam, as in Jy/beam. */
+	  // Beam, as in Jy/beam.
 	  types[WCSUNITS_BEAM] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>bin {
-	  /* Bin (e.g. histogram). */
+	  // Bin (e.g. histogram).
 	  types[WCSUNITS_BIN] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>bit {
-	  /* Bit. */
+	  // Bit.
 	  types[WCSUNITS_BIT] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>[bB]yte {
-	  /* Byte. */
+	  // Byte.
 	  factor *= 8.0;
 	  types[WCSUNITS_BIT] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>C {
-	  /* Coulomb. */
+	  // Coulomb.
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>cd {
-	  /* Candela. */
+	  // Candela.
 	  types[WCSUNITS_LUMINTEN] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>chan {
-	  /* Channel. */
+	  // Channel.
 	  types[WCSUNITS_BIN] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>count|ct {
-	  /* Count. */
+	  // Count.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>cy {
-	  /* Julian century. */
+	  // Julian century.
 	  factor *= 3155760000.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>D {
-	  /* Debye. */
+	  // Debye.
 	  factor *= 1e-29 / 3.0;
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
@@ -547,20 +531,20 @@ sqrt" "*"(" {
 	}
 
 <UNITS>d {
-	  /* Day. */
+	  // Day.
 	  factor *= 86400.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>deg {
-	  /* Degree. */
+	  // Degree.
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>erg {
-	  /* Erg. */
+	  // Erg.
 	  factor *= 1e-7;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -569,7 +553,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>eV {
-	  /* Electron volt. */
+	  // Electron volt.
 	  factor *= 1.6021765e-19;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -578,7 +562,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>F {
-	  /* Farad. */
+	  // Farad.
 	  types[WCSUNITS_MASS]   -= 1.0;
 	  types[WCSUNITS_LENGTH] -= 2.0;
 	  types[WCSUNITS_TIME]   += 3.0;
@@ -587,7 +571,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>G {
-	  /* Gauss. */
+	  // Gauss.
 	  factor *= 1e-4;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -596,14 +580,14 @@ sqrt" "*"(" {
 	}
 
 <UNITS>g {
-	  /* Gram. */
+	  // Gram.
 	  factor *= 1e-3;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>H {
-	  /* Henry. */
+	  // Henry.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   += 2.0;
@@ -612,20 +596,20 @@ sqrt" "*"(" {
 	}
 
 <UNITS>h {
-	  /* Hour. */
+	  // Hour.
 	  factor *= 3600.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>Hz {
-	  /* Hertz. */
+	  // Hertz.
 	  types[WCSUNITS_TIME] -= 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>J {
-	  /* Joule. */
+	  // Joule.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -633,7 +617,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>Jy {
-	  /* Jansky. */
+	  // Jansky.
 	  factor *= 1e-26;
 	  types[WCSUNITS_MASS] += 1.0;
 	  types[WCSUNITS_TIME] -= 2.0;
@@ -641,20 +625,20 @@ sqrt" "*"(" {
 	}
 
 <UNITS>K {
-	  /* Kelvin. */
+	  // Kelvin.
 	  types[WCSUNITS_TEMPERATURE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>lm {
-	  /* Lumen. */
+	  // Lumen.
 	  types[WCSUNITS_LUMINTEN]    += 1.0;
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>lx {
-	  /* Lux. */
+	  // Lux.
 	  types[WCSUNITS_LUMINTEN]    += 1.0;
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  types[WCSUNITS_LENGTH]      -= 2.0;
@@ -662,46 +646,46 @@ sqrt" "*"(" {
 	}
 
 <UNITS>lyr {
-	  /* Light year. */
+	  // Light year.
 	  factor *= 2.99792458e8 * 31557600.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>m {
-	  /* Metre. */
+	  // Metre.
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>mag {
-	  /* Stellar magnitude. */
+	  // Stellar magnitude.
 	  types[WCSUNITS_MAGNITUDE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>mas {
-	  /* Milli-arcsec. */
+	  // Milli-arcsec.
 	  factor /= 3600e+3;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>min {
-	  /* Minute. */
+	  // Minute.
 	  factor *= 60.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>mol {
-	  /* Mole. */
+	  // Mole.
 	  types[WCSUNITS_MOLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>N {
-	  /* Newton. */
+	  // Newton.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -709,7 +693,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>[Oo]hm {
-	  /* Ohm. */
+	  // Ohm.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 1.0;
@@ -718,7 +702,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>Pa {
-	  /* Pascal. */
+	  // Pascal.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] -= 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -726,26 +710,26 @@ sqrt" "*"(" {
 	}
 
 <UNITS>pc {
-	  /* Parsec. */
+	  // Parsec.
 	  factor *= 3.0857e16;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>photon|ph {
-	  /* Photon. */
+	  // Photon.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>pixel|pix {
-	  /* Pixel. */
+	  // Pixel.
 	  types[WCSUNITS_PIXEL] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>R {
-	  /* Rayleigh. */
+	  // Rayleigh.
 	  factor *= 1e10 / (4.0 * PI);
 	  types[WCSUNITS_LENGTH]      -= 2.0;
 	  types[WCSUNITS_TIME]        -= 1.0;
@@ -754,14 +738,14 @@ sqrt" "*"(" {
 	}
 
 <UNITS>rad {
-	  /* Radian. */
+	  // Radian.
 	  factor *= 180.0 / PI;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>Ry {
-	  /* Rydberg. */
+	  // Rydberg.
 	  factor *= 13.605692 * 1.6021765e-19;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -770,7 +754,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>S {
-	  /* Siemen. */
+	  // Siemen.
 	  types[WCSUNITS_MASS]   -= 1.0;
 	  types[WCSUNITS_LENGTH] -= 2.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -779,13 +763,13 @@ sqrt" "*"(" {
 	}
 
 <UNITS>s {
-	  /* Second. */
+	  // Second.
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>solLum {
-	  /* Solar luminosity. */
+	  // Solar luminosity.
 	  factor *= 3.8268e26;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -794,33 +778,33 @@ sqrt" "*"(" {
 	}
 
 <UNITS>solMass {
-	  /* Solar mass. */
+	  // Solar mass.
 	  factor *= 1.9891e30;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>solRad {
-	  /* Solar radius. */
+	  // Solar radius.
 	  factor *= 6.9599e8;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>sr {
-	  /* Steradian. */
+	  // Steradian.
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>Sun {
-	  /* Sun (with respect to). */
+	  // Sun (with respect to).
 	  types[WCSUNITS_SOLRATIO] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>T {
-	  /* Tesla. */
+	  // Tesla.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_TIME]   += 1.0;
 	  types[WCSUNITS_CHARGE] -= 1.0;
@@ -828,21 +812,21 @@ sqrt" "*"(" {
 	}
 
 <UNITS>turn {
-	  /* Turn. */
+	  // Turn.
 	  factor *= 360.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>u {
-	  /* Unified atomic mass unit. */
+	  // Unified atomic mass unit.
 	  factor *= 1.6605387e-27;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>V {
-	  /* Volt. */
+	  // Volt.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -851,13 +835,13 @@ sqrt" "*"(" {
 	}
 
 <UNITS>voxel {
-	  /* Voxel. */
+	  // Voxel.
 	  types[WCSUNITS_VOXEL] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>W {
-	  /* Watt. */
+	  // Watt.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 3.0;
@@ -865,7 +849,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>Wb {
-	  /* Weber. */
+	  // Weber.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -874,20 +858,21 @@ sqrt" "*"(" {
 	}
 
 <UNITS>. {
-	  /* Internal parser error. */
+	  // Internal parser error.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
 	  BEGIN(FLUSH);
 	}
 
 <EXPON>" "*("**"|^) {
-	  /* Exponentiation. */
+	  // Exponentiation.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  }
 	}
 
 <EXPON>" "*{INTEGER} {
+	  int i;
 	  sscanf(yytext, " %d", &i);
 	  expon *= (double)i;
 	  add(&factor, types, &expon, scale, units);
@@ -896,6 +881,7 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "*"("" "*{INTEGER}" "*")" {
+	  int i;
 	  sscanf(yytext, " (%d)", &i);
 	  expon *= (double)i;
 	  add(&factor, types, &expon, scale, units);
@@ -904,6 +890,7 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "*"("" "*{FRAC}" "*")" {
+	  int i, j;
 	  sscanf(yytext, " (%d/%d)", &i, &j);
 	  expon *= (double)i / (double)j;
 	  add(&factor, types, &expon, scale, units);
@@ -912,7 +899,9 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "*"("" "*{FLOAT}" "*")" {
+	  char ctmp[72];
 	  sscanf(yytext, " (%s)", ctmp);
+	  double dexp;
 	  wcsutil_str2double(ctmp, &dexp);
 	  expon *= dexp;
 	  add(&factor, types, &expon, scale, units);
@@ -921,7 +910,7 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "*[.*]" "* {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -931,7 +920,7 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "*"(" {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -942,7 +931,7 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "+ {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -952,7 +941,7 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "*"/"" "* {
-	  /* Divide. */
+	  // Divide.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -975,11 +964,11 @@ sqrt" "*"(" {
 	}
 
 <FLUSH>.* {
-	  /* Discard any remaining input. */
+	  // Discard any remaining input.
 	}
 
 <<EOF>>	{
-	  /* End-of-string. */
+	  // End-of-string.
 	  if (YY_START == EXPON) {
 	    add(&factor, types, &expon, scale, units);
 	  }
@@ -1003,7 +992,7 @@ sqrt" "*"(" {
 	  }
 	
 	  if (status) {
-	    for (i = 0; i < WCSUNITS_NTYPE; i++) {
+	    for (int i = 0; i < WCSUNITS_NTYPE; i++) {
 	      units[i] = 0.0;
 	      *scale = 0.0;
 	    }
@@ -1015,6 +1004,34 @@ sqrt" "*"(" {
 %%
 
 /*----------------------------------------------------------------------------
+* External interface to the scanner.
+*---------------------------------------------------------------------------*/
+
+int wcsulexe(
+  const char unitstr[],
+  int *func,
+  double *scale,
+  double units[WCSUNITS_NTYPE],
+  struct wcserr **err)
+
+{
+  static const char *function = "wcsulexe";
+
+  // Function prototypes.
+  int yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *yyscanner);
+  int yylex_destroy(yyscan_t yyscanner);
+
+  struct wcsulex_extra extra;
+  yyscan_t yyscanner;
+  yylex_init_extra(&extra, &yyscanner);
+  int status = wcsulexe_scanner(unitstr, func, scale, units, err, yyscanner);
+  yylex_destroy(yyscanner);
+
+  return status;
+}
+
+
+/*----------------------------------------------------------------------------
 * Accumulate a term in a units specification and reset work variables.
 *---------------------------------------------------------------------------*/
 
@@ -1026,11 +1043,9 @@ void add(
   double units[])
 
 {
-  int i;
-
   *scale *= pow(*factor, *expon);
 
-  for (i = 0; i < WCSUNITS_NTYPE; i++) {
+  for (int i = 0; i < WCSUNITS_NTYPE; i++) {
     units[i] += *expon * types[i];
     types[i] = 0.0;
   }
Index: astropy-4.2.1/cextern/wcslib/C/wcsunits.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsunits.c
+++ astropy-4.2.1/cextern/wcslib/C/wcsunits.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,18 +17,16 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsunits.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsunits.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
 
 #include "wcsunits.h"
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *wcsunits_errmsg[] = {
   "Success",
   "Invalid numeric multiplier",
@@ -46,7 +43,7 @@ const char *wcsunits_errmsg[] = {
   "Potentially unsafe translation"};
 
 
-/* Unit types. */
+// Unit types.
 const char *wcsunits_types[] = {
   "plane angle",
   "solid angle",
@@ -84,7 +81,7 @@ const char *wcsunits_funcs[] = {
   "ln",
   "exp"};
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsunits(
   const char have[],
@@ -97,7 +94,7 @@ int wcsunits(
   return wcsunitse(have, want, scale, offset, power, 0x0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsunitse(
   const char have[],
@@ -121,7 +118,7 @@ int wcsunitse(
     return status;
   }
 
-  /* Check conformance. */
+  // Check conformance.
   for (i = 0; i < WCSUNITS_NTYPE; i++) {
     if (units1[i] != units2[i]) {
       return wcserr_set(WCSERR_SET(UNITSERR_BAD_UNIT_SPEC),
@@ -136,7 +133,7 @@ int wcsunitse(
 
   switch (func1) {
   case 0:
-    /* No function. */
+    // No function.
     if (func2) {
       return wcserr_set(WCSERR_SET(UNITSERR_BAD_FUNCS),
         "Mismatched unit functions: have '%s' (%s), want '%s' (%s)",
@@ -147,14 +144,14 @@ int wcsunitse(
     break;
 
   case 1:
-    /* log(). */
+    // log().
     if (func2 == 1) {
-      /* log(). */
+      // log().
       *scale  = 1.0;
       *offset = log10(scale1 / scale2);
 
     } else if (func2 == 2) {
-      /* ln(). */
+      // ln().
       *scale  = log(10.0);
       *offset = log(scale1 / scale2);
 
@@ -167,14 +164,14 @@ int wcsunitse(
     break;
 
   case 2:
-    /* ln(). */
+    // ln().
     if (func2 == 1) {
-      /* log(). */
+      // log().
       *scale  = 1.0 / log(10.0);
       *offset = log(scale1 / scale2);
 
     } else if (func2 == 2) {
-      /* ln(). */
+      // ln().
       *scale  = 1.0;
       *offset = log(scale1 / scale2);
 
@@ -187,7 +184,7 @@ int wcsunitse(
     break;
 
   case 3:
-    /* exp(). */
+    // exp().
     if (func2 != 3) {
       return wcserr_set(WCSERR_SET(UNITSERR_BAD_FUNCS),
         "Mismatched unit functions: have '%s' (%s), want '%s' (%s)",
@@ -199,7 +196,7 @@ int wcsunitse(
     break;
 
   default:
-    /* Internal parser error. */
+    // Internal parser error.
     return wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
       "Internal units parser error");
   }
@@ -207,7 +204,7 @@ int wcsunitse(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsutrn(int ctrl, char unitstr[])
 
@@ -215,7 +212,7 @@ int wcsutrn(int ctrl, char unitstr[])
   return wcsutrne(ctrl, unitstr, 0x0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsulex(const char unitstr[], int *func, double *scale, double units[])
 
Index: astropy-4.2.1/cextern/wcslib/C/wcsunits.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsunits.h
+++ astropy-4.2.1/cextern/wcslib/C/wcsunits.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsunits.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsunits.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -162,42 +159,44 @@
 *                            or not (see notes).
 *
 * Notes:
-*   Translation of non-standard unit specifications: apart from leading and
-*   trailing blanks, a case-sensitive match is required for the aliases listed
-*   below, in particular the only recognized aliases with metric prefixes are
-*   "KM", "KHZ", "MHZ", and "GHZ".  Potentially unsafe translations of "D",
-*   "H", and "S", shown in parentheses, are optional.
-*
-=     Unit       Recognized aliases
-=     ----       -------------------------------------------------------------
-=     Angstrom   angstrom
-=     arcmin     arcmins, ARCMIN, ARCMINS
-=     arcsec     arcsecs, ARCSEC, ARCSECS
-=     beam       BEAM
-=     byte       Byte
-=     d          day, days, (D), DAY, DAYS
-=     deg        degree, degrees, Deg, Degree, Degrees, DEG, DEGREE, DEGREES
-=     GHz        GHZ
-=     h          hr, (H), HR
-=     Hz         hz, HZ
-=     kHz        KHZ
-=     Jy         JY
-=     K          kelvin, kelvins, Kelvin, Kelvins, KELVIN, KELVINS
-=     km         KM
-=     m          metre, meter, metres, meters, M, METRE, METER, METRES, METERS
-=     min        MIN
-=     MHz        MHZ
-=     Ohm        ohm
-=     Pa         pascal, pascals, Pascal, Pascals, PASCAL, PASCALS
-=     pixel      pixels, PIXEL, PIXELS
-=     rad        radian, radians, RAD, RADIAN, RADIANS
-=     s          sec, second, seconds, (S), SEC, SECOND, SECONDS
-=     V          volt, volts, Volt, Volts, VOLT, VOLTS
-=     yr         year, years, YR, YEAR, YEARS
-*
-*   The aliases "angstrom", "ohm", and "Byte" for (Angstrom, Ohm, and byte)
-*   are recognized by wcsulexe() itself as an unofficial extension of the
-*   standard, but they are converted to the standard form here.
+*   1: Translation of non-standard unit specifications: apart from leading and
+*      trailing blanks, a case-sensitive match is required for the aliases
+*      listed below, in particular the only recognized aliases with metric
+*      prefixes are "KM", "KHZ", "MHZ", and "GHZ".  Potentially unsafe
+*      translations of "D", "H", and "S", shown in parentheses, are optional.
+*
+=        Unit       Recognized aliases
+=        ----       ----------------------------------------------------------
+=        Angstrom   Angstroms angstrom angstroms
+=        arcmin     arcmins, ARCMIN, ARCMINS
+=        arcsec     arcsecs, ARCSEC, ARCSECS
+=        beam       BEAM
+=        byte       Byte
+=        d          day, days, (D), DAY, DAYS
+=        deg        degree, degrees, Deg, Degree, Degrees, DEG, DEGREE,
+=                   DEGREES
+=        GHz        GHZ
+=        h          hr, (H), HR
+=        Hz         hz, HZ
+=        kHz        KHZ
+=        Jy         JY
+=        K          kelvin, kelvins, Kelvin, Kelvins, KELVIN, KELVINS
+=        km         KM
+=        m          metre, meter, metres, meters, M, METRE, METER, METRES,
+=                   METERS
+=        min        MIN
+=        MHz        MHZ
+=        Ohm        ohm
+=        Pa         pascal, pascals, Pascal, Pascals, PASCAL, PASCALS
+=        pixel      pixels, PIXEL, PIXELS
+=        rad        radian, radians, RAD, RADIAN, RADIANS
+=        s          sec, second, seconds, (S), SEC, SECOND, SECONDS
+=        V          volt, volts, Volt, Volts, VOLT, VOLTS
+=        yr         year, years, YR, YEAR, YEARS
+*
+*      The aliases "angstrom", "ohm", and "Byte" for (Angstrom, Ohm, and byte)
+*      are recognized by wcsulexe() itself as an unofficial extension of the
+*      standard, but they are converted to the standard form here.
 *
 *
 * wcsulexe() - FITS units specification parser
@@ -348,21 +347,19 @@ extern "C" {
 extern const char *wcsunits_errmsg[];
 
 enum wcsunits_errmsg_enum {
-  UNITSERR_SUCCESS            =  0,	/* Success. */
-  UNITSERR_BAD_NUM_MULTIPLIER =  1,	/* Invalid numeric multiplier. */
-  UNITSERR_DANGLING_BINOP     =  2,	/* Dangling binary operator. */
-  UNITSERR_BAD_INITIAL_SYMBOL =  3,	/* Invalid symbol in INITIAL
-					   context. */
-  UNITSERR_FUNCTION_CONTEXT   =  4,	/* Function in invalid context. */
-  UNITSERR_BAD_EXPON_SYMBOL   =  5,	/* Invalid symbol in EXPON context. */
-  UNITSERR_UNBAL_BRACKET      =  6,	/* Unbalanced bracket. */
-  UNITSERR_UNBAL_PAREN        =  7,	/* Unbalanced parenthesis. */
-  UNITSERR_CONSEC_BINOPS      =  8,	/* Consecutive binary operators. */
-  UNITSERR_PARSER_ERROR       =  9,	/* Internal parser error. */
-  UNITSERR_BAD_UNIT_SPEC      = 10,	/* Non-conformant unit
-					   specifications. */
-  UNITSERR_BAD_FUNCS          = 11,	/* Non-conformant functions. */
-  UNITSERR_UNSAFE_TRANS       = 12	/* Potentially unsafe translation. */
+  UNITSERR_SUCCESS            =  0,	// Success.
+  UNITSERR_BAD_NUM_MULTIPLIER =  1,	// Invalid numeric multiplier.
+  UNITSERR_DANGLING_BINOP     =  2,	// Dangling binary operator.
+  UNITSERR_BAD_INITIAL_SYMBOL =  3,	// Invalid symbol in INITIAL context.
+  UNITSERR_FUNCTION_CONTEXT   =  4,	// Function in invalid context.
+  UNITSERR_BAD_EXPON_SYMBOL   =  5,	// Invalid symbol in EXPON context.
+  UNITSERR_UNBAL_BRACKET      =  6,	// Unbalanced bracket.
+  UNITSERR_UNBAL_PAREN        =  7,	// Unbalanced parenthesis.
+  UNITSERR_CONSEC_BINOPS      =  8,	// Consecutive binary operators.
+  UNITSERR_PARSER_ERROR       =  9,	// Internal parser error.
+  UNITSERR_BAD_UNIT_SPEC      = 10,	// Non-conformant unit specifications.
+  UNITSERR_BAD_FUNCS          = 11,	// Non-conformant functions.
+  UNITSERR_UNSAFE_TRANS       = 12	// Potentially unsafe translation.
 };
 
 extern const char *wcsunits_types[];
@@ -397,7 +394,7 @@ int wcsutrne(int ctrl, char unitstr[], s
 int wcsulexe(const char unitstr[], int *func, double *scale,
              double units[WCSUNITS_NTYPE], struct wcserr **err);
 
-/* Deprecated. */
+// Deprecated.
 int wcsunits(const char have[], const char want[], double *scale,
              double *offset, double *power);
 int wcsutrn(int ctrl, char unitstr[]);
@@ -408,4 +405,4 @@ int wcsulex(const char unitstr[], int *f
 }
 #endif
 
-#endif /* WCSLIB_WCSUNITS */
+#endif // WCSLIB_WCSUNITS
Index: astropy-4.2.1/cextern/wcslib/C/wcsutil.c
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsutil.c
+++ astropy-4.2.1/cextern/wcslib/C/wcsutil.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsutil.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsutil.c,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *===========================================================================*/
 
 #include <ctype.h>
@@ -35,7 +32,7 @@
 #include "wcsutil.h"
 #include "wcsmath.h"
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsdealloc(void *ptr)
 
@@ -45,74 +42,71 @@ void wcsdealloc(void *ptr)
   return;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
-void wcsutil_strcvt(int n, char c, const char src[], char dst[])
+void wcsutil_strcvt(int n, char c, int nt, const char src[], char dst[])
 
 {
-  int j;
-
   if (n <= 0) return;
 
   if (c != '\0') c = ' ';
 
   if (src == 0x0) {
     if (dst) {
-       memset(dst, c, n);
+      memset(dst, c, n);
     }
 
-    return;
-  }
-
-  /* Copy to the first NULL character. */
-  for (j = 0; j < n; j++) {
-    if ((dst[j] = src[j]) == '\0') {
-      break;
+  } else {
+    // Copy to the first NULL character.
+    int j;
+    for (j = 0; j < n; j++) {
+      if ((dst[j] = src[j]) == '\0') {
+        break;
+      }
     }
-  }
-
-  if (j < n) {
-    /* The given string is null-terminated. */
-    memset(dst+j, c, n-j);
 
-  } else {
-    /* The given string is not null-terminated. */
-    if (c == '\0') {
-      j = n - 1;
-      dst[j] = '\0';
-
-      j--;
-
-      /* Work backwards, looking for the first non-blank. */
-      for (; j >= 0; j--) {
-        if (dst[j] != ' ') {
-          break;
+    if (j < n) {
+      // The given string is null-terminated.
+      memset(dst+j, c, n-j);
+
+    } else {
+      // The given string is not null-terminated.
+      if (c == '\0') {
+        // Work backwards, looking for the first non-blank.
+        for (j = n - 1; j >= 0; j--) {
+          if (dst[j] != ' ') {
+            break;
+          }
         }
-      }
 
-      j++;
-      memset(dst+j, '\0', n-j);
+        j++;
+	if (j == n && !nt) {
+	  dst[n-1] = '\0';
+	} else {
+          memset(dst+j, '\0', n-j);
+	}
+      }
     }
   }
 
+  if (nt) dst[n] = '\0';
+
   return;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_blank_fill(int n, char c[])
 
 {
-  int j;
-
   if (n <= 0) return;
 
   if (c == 0x0) {
     return;
   }
 
-  /* Replace the terminating null and all successive characters. */
-  for (j = 0; j < n; j++) {
+  // Replace the terminating null and all successive characters.
+  for (int j = 0; j < n; j++) {
     if (c[j] == '\0') {
       memset(c+j, ' ', n-j);
       break;
@@ -122,33 +116,32 @@ void wcsutil_blank_fill(int n, char c[])
   return;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_null_fill(int n, char c[])
 
 {
-  int j;
-
   if (n <= 0) return;
 
   if (c == 0x0) {
     return;
   }
 
-  /* Find the first NULL character. */
+  // Find the first NULL character.
+  int j;
   for (j = 0; j < n; j++) {
     if (c[j] == '\0') {
       break;
     }
   }
 
-  /* Ensure null-termination. */
+  // Ensure null-termination.
   if (j == n) {
     j = n - 1;
     c[j] = '\0';
   }
 
-  /* Work backwards, looking for the first non-blank. */
+  // Work backwards, looking for the first non-blank.
   j--;
   for (; j > 0; j--) {
     if (c[j] != ' ') {
@@ -163,174 +156,211 @@ void wcsutil_null_fill(int n, char c[])
   return;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
-int wcsutil_allEq(int nvec, int nelem, const double *first)
+int wcsutil_all_ival(int nelem, int ival, const int iarr[])
+
+{
+  for (int i = 0; i < nelem; i++) {
+    if (iarr[i] != ival) return 0;
+  }
+
+  return 1;
+}
+
+//----------------------------------------------------------------------------
+
+int wcsutil_all_dval(int nelem, double dval, const double darr[])
+
+{
+  for (int i = 0; i < nelem; i++) {
+    if (darr[i] != dval) return 0;
+  }
+
+  return 1;
+}
+
+//----------------------------------------------------------------------------
+
+int wcsutil_all_sval(int nelem, const char *sval, const char (*sarr)[72])
 
 {
-  double v0;
-  const double *vp;
+  for (int i = 0; i < nelem; i++) {
+    if (strncmp(sarr[i], sval, 72)) return 0;
+  }
 
+  return 1;
+}
+
+//----------------------------------------------------------------------------
+
+int wcsutil_allEq(int nvec, int nelem, const double *first)
+
+{
   if (nvec <= 0 || nelem <= 0) return 0;
 
-  v0 = *first;
-  for (vp = first+nelem; vp < first + nvec*nelem; vp += nelem) {
+  double v0 = *first;
+  for (const double *vp = first+nelem; vp < first + nvec*nelem; vp += nelem) {
     if (*vp != v0) return 0;
   }
 
   return 1;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
-int wcsutil_Eq(int nelem, double tol, const double *arr1, const double *arr2)
+int wcsutil_dblEq(
+  int nelem,
+  double tol,
+  const double *darr1,
+  const double *darr2)
 
 {
-  int i;
-
   if (nelem == 0) return 1;
   if (nelem  < 0) return 0;
 
-  if (arr1 == 0x0 && arr2 == 0x0) return 1;
-  if (arr1 == 0x0 || arr2 == 0x0) return 0;
+  if (darr1 == 0x0 && darr2 == 0x0) return 1;
 
   if (tol == 0.0) {
-    /* Handled separately for speed of execution. */
-    for (i = 0; i < nelem; i++, arr1++, arr2++) {
-      if (*arr1 != *arr2) return 0;
+    // Handled separately for speed of execution.
+    for (int i = 0; i < nelem; i++) {
+      double dval1 = (darr1 ? darr1[i] : UNDEFINED);
+      double dval2 = (darr2 ? darr2[i] : UNDEFINED);
+
+      // Undefined values must match exactly.
+      if (dval1 == UNDEFINED && dval2 != UNDEFINED) return 0;
+      if (dval1 != UNDEFINED && dval2 == UNDEFINED) return 0;
+
+      if (dval1 != dval2) return 0;
     }
 
   } else {
-    for (i = 0; i < nelem; i++, arr1++, arr2++) {
-      /* Undefined values must match exactly. */
-      if (*arr1 == UNDEFINED && *arr2 != UNDEFINED) return 0;
-      if (*arr1 != UNDEFINED && *arr2 == UNDEFINED) return 0;
+    for (int i = 0; i < nelem; i++) {
+      double dval1 = (darr1 ? darr1[i] : UNDEFINED);
+      double dval2 = (darr2 ? darr2[i] : UNDEFINED);
+
+      // Undefined values must match exactly.
+      if (dval1 == UNDEFINED && dval2 != UNDEFINED) return 0;
+      if (dval1 != UNDEFINED && dval2 == UNDEFINED) return 0;
 
-      /* Otherwise, compare within the specified tolerance. */
-      if (fabs(*arr1 - *arr2) > 0.5*tol) return 0;
+      // Otherwise, compare within the specified tolerance.
+      if (fabs(dval1 - dval2) > 0.5*tol) return 0;
     }
   }
 
   return 1;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
-int wcsutil_intEq(int nelem, const int *arr1, const int *arr2)
+int wcsutil_intEq(int nelem, const int *iarr1, const int *iarr2)
 
 {
-  int i;
-
   if (nelem == 0) return 1;
   if (nelem  < 0) return 0;
 
-  if (arr1 == 0x0 && arr2 == 0x0) return 1;
-  if (arr1 == 0x0 || arr2 == 0x0) return 0;
+  if (iarr1 == 0x0 && iarr2 == 0x0) return 1;
+
+  for (int i = 0; i < nelem; i++) {
+    int ival1 = (iarr1 ?  iarr1[i] : 0);
+    int ival2 = (iarr2 ?  iarr2[i] : 0);
 
-  for (i = 0; i < nelem; i++, arr1++, arr2++) {
-    if (*arr1 != *arr2) return 0;
+    if (ival1 != ival2) return 0;
   }
 
   return 1;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
-int wcsutil_strEq(int nelem, char (*arr1)[72], char (*arr2)[72])
+int wcsutil_strEq(int nelem, char (*sarr1)[72], char (*sarr2)[72])
 
 {
-  int i;
-
   if (nelem == 0) return 1;
   if (nelem  < 0) return 0;
 
-  if (arr1 == 0x0 && arr2 == 0x0) return 1;
-  if (arr1 == 0x0 || arr2 == 0x0) return 0;
+  if (sarr1 == 0x0 && sarr2 == 0x0) return 1;
+
+  for (int i = 0; i < nelem; i++) {
+    char *sval1 = (sarr1 ?  sarr1[i] : "");
+    char *sval2 = (sarr2 ?  sarr2[i] : "");
 
-  for (i = 0; i < nelem; i++, arr1++, arr2++) {
-    if (strncmp(*arr1, *arr2, 72)) return 0;
+    if (strncmp(sval1, sval2, 72)) return 0;
   }
 
   return 1;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_setAll(int nvec, int nelem, double *first)
 
 {
-  double v0, *vp;
-
   if (nvec <= 0 || nelem <= 0) return;
 
-  v0 = *first;
-  for (vp = first+nelem; vp < first + nvec*nelem; vp += nelem) {
+  double v0 = *first;
+  for (double *vp = first+nelem; vp < first + nvec*nelem; vp += nelem) {
     *vp = v0;
   }
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_setAli(int nvec, int nelem, int *first)
 
 {
-  int v0, *vp;
-
   if (nvec <= 0 || nelem <= 0) return;
 
-  v0 = *first;
-  for (vp = first+nelem; vp < first + nvec*nelem; vp += nelem) {
+  int v0 = *first;
+  for (int *vp = first+nelem; vp < first + nvec*nelem; vp += nelem) {
     *vp = v0;
   }
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_setBit(int nelem, const int *sel, int bits, int *array)
 
 {
-  int *arrp;
-
   if (bits == 0 || nelem <= 0) return;
 
   if (sel == 0x0) {
-    /* All elements selected. */
-    for (arrp = array; arrp < array + nelem; arrp++) {
+    // All elements selected.
+    for (int *arrp = array; arrp < array + nelem; arrp++) {
       *arrp |= bits;
     }
 
   } else {
-    /* Some elements selected. */
-    for (arrp = array; arrp < array + nelem; arrp++) {
+    // Some elements selected.
+    for (int *arrp = array; arrp < array + nelem; arrp++) {
       if (*(sel++)) *arrp |= bits;
     }
   }
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 char *wcsutil_fptr2str(void (*fptr)(void), char hext[19])
 
 {
-  unsigned char *p = (unsigned char *)(&fptr);
-  char *t = hext;
-  unsigned int i;
-  int *(ip[2]), j[2], le = 1, gotone = 0;
-
-  /* Test for little-endian addresses. */
+  // Test for little-endian addresses.
+  int *(ip[2]), j[2], le = 1;
   ip[0] = j;
   ip[1] = j + 1;
+  unsigned char *p = (unsigned char *)(&fptr);
   if ((unsigned char *)ip[0] < (unsigned char *)ip[1]) {
-    /* Little-endian, reverse it. */
+    // Little-endian, reverse it.
     p += sizeof(fptr) - 1;
     le = -1;
   }
 
+  char *t = hext;
   sprintf(t, "0x0");
   t += 2;
 
-  for (i = 0; i < sizeof(fptr); i++) {
-    /* Skip leading zeroes. */
+  for (size_t i = 0; i < sizeof(fptr); i++) {
+    // Skip leading zeroes.
+    int gotone = 0;
     if (*p) gotone = 1;
 
     if (gotone) {
@@ -344,7 +374,7 @@ char *wcsutil_fptr2str(void (*fptr)(void
   return hext;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 static void wcsutil_locale_to_dot(char *buf)
 
@@ -374,13 +404,11 @@ static void wcsutil_locale_to_dot(char *
 void wcsutil_double2str(char *buf, const char *format, double value)
 
 {
-  char *bp, *cp;
-
   sprintf(buf, format, value);
   wcsutil_locale_to_dot(buf);
 
-  /* Look for a decimal point or exponent. */
-  bp = buf;
+  // Look for a decimal point or exponent.
+  char *bp = buf;
   while (*bp) {
     if (*bp != ' ') {
       if (*bp == '.') return;
@@ -390,10 +418,10 @@ void wcsutil_double2str(char *buf, const
     bp++;
   }
 
-  /* Not found, add a fractional part. */
+  // Not found, add a fractional part.
   bp = buf;
   if (*bp == ' ') {
-    cp = buf + 1;
+    char *cp = buf + 1;
     if (*cp == ' ') cp++;
 
     while (*cp) {
@@ -408,7 +436,7 @@ void wcsutil_double2str(char *buf, const
   }
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 static const char *wcsutil_dot_to_locale(const char *inbuf, char *outbuf)
 
@@ -449,24 +477,24 @@ int wcsutil_str2double(const char *buf,
 int wcsutil_str2double2(const char *buf, double *value)
 
 {
-  char   *cptr, ctmp[72], *dptr, *eptr, ltmp[72];
-  int    exp = 0;
-
   value[0] = 0.0;
   value[1] = 0.0;
 
-  /* Get the integer part. */
+  // Get the integer part.
+  char ltmp[72];
   if (sscanf(wcsutil_dot_to_locale(buf, ltmp), "%lf", value) < 1) {
     return 1;
   }
   value[0] = floor(value[0]);
 
+  char ctmp[72];
   strcpy(ctmp, buf);
 
-  /* Look for a decimal point. */
-  dptr = strchr(ctmp, '.');
+  // Look for a decimal point.
+  char *dptr = strchr(ctmp, '.');
 
-  /* Look for an exponent. */
+  // Look for an exponent.
+  char *eptr;
   if ((eptr = strchr(ctmp, 'E')) == NULL) {
     if ((eptr = strchr(ctmp, 'D')) == NULL) {
       if ((eptr = strchr(ctmp, 'e')) == NULL) {
@@ -475,8 +503,9 @@ int wcsutil_str2double2(const char *buf,
     }
   }
 
+  int exp = 0;
   if (eptr) {
-    /* Get the exponent. */
+    // Get the exponent.
     if (sscanf(eptr+1, "%d", &exp) < 1) {
       return 1;
     }
@@ -487,17 +516,17 @@ int wcsutil_str2double2(const char *buf,
     }
 
     if (dptr+exp <= ctmp) {
-      /* There is only a fractional part. */
+      // There is only a fractional part.
       return sscanf(wcsutil_dot_to_locale(buf, ctmp), "%lf", value+1) < 1;
     } else if (eptr <= dptr+exp+1) {
-      /* There is no fractional part. */
+      // There is no fractional part.
       return 0;
     }
   }
 
-  /* Get the fractional part. */
+  // Get the fractional part.
   if (dptr) {
-    cptr = ctmp;
+    char *cptr = ctmp;
     while (cptr <= dptr+exp) {
       if ('0' < *cptr && *cptr <= '9') *cptr = '0';
       cptr++;
Index: astropy-4.2.1/cextern/wcslib/C/wcsutil.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsutil.h
+++ astropy-4.2.1/cextern/wcslib/C/wcsutil.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsutil.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsutil.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -67,9 +64,10 @@
 * wcsutil_strcvt() copies one character string to another up to the specified
 * maximum number of characters.
 *
-* If the given string is null-terminated, then the terminating NULL character,
-* and all characters following it up to the specified maximum, are replaced
-* with the specified substitute character, either blank or NULL.
+* If the given string is null-terminated, then the NULL character copied to
+* the returned string, and all characters following it up to the specified
+* maximum, are replaced with the specified substitute character, either blank
+* or NULL.
 *
 * If the source string is not null-terminated and the substitute character is
 * blank, then copy the maximum number of characters and do nothing further.
@@ -85,9 +83,11 @@
 *   c         char      Substitute character, either NULL or blank (anything
 *                       other than NULL).
 *
-*   src       const char[]
-*                       Character string to be copied.  Need not be
-*                       null-terminated.
+*   nt        int       If true, then dst is of length n+1, with the last
+*                       character always set to NULL.
+*
+*   src       char[]    Character string to be copied.  If null-terminated,
+*                       then need not be of length n, otherwise it must be.
 *
 * Returned:
 *   dst       char[]    Destination character string, which must be long
@@ -142,6 +142,69 @@
 *             void
 *
 *
+* wcsutil_all_ival() - Test if all elements an int array have a given value
+* -------------------------------------------------------------------------
+* INTERNAL USE ONLY.
+*
+* wcsutil_all_ival() tests whether all elements of an array of type int all
+* have the specified value.
+*
+* Given:
+*   nelem     int       The length of the array.
+*
+*   ival      int       Value to be tested.
+*
+*   iarr      const int[]
+*                       Pointer to the first element of the array.
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Not all equal.
+*                         1: All equal.
+*
+*
+* wcsutil_all_dval() - Test if all elements a double array have a given value
+* ---------------------------------------------------------------------------
+* INTERNAL USE ONLY.
+*
+* wcsutil_all_dval() tests whether all elements of an array of type double all
+* have the specified value.
+*
+* Given:
+*   nelem     int       The length of the array.
+*
+*   dval      int       Value to be tested.
+*
+*   darr      const double[]
+*                       Pointer to the first element of the array.
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Not all equal.
+*                         1: All equal.
+*
+*
+* wcsutil_all_sval() - Test if all elements a string array have a given value
+* ---------------------------------------------------------------------------
+* INTERNAL USE ONLY.
+*
+* wcsutil_all_sval() tests whether all elements of an array of type
+* char (*)[72] all have the specified value.
+*
+* Given:
+*   nelem     int       The length of the array.
+*
+*   sval      char *    String to be tested.
+*
+*   sarr      const (*char)[72]
+*                       Pointer to the first element of the array.
+*
+* Function return value:
+*             int       Status return value:
+*                         0: Not all equal.
+*                         1: All equal.
+*
+*
 * wcsutil_allEq() - Test for equality of a particular vector element
 * ------------------------------------------------------------------
 * INTERNAL USE ONLY.
@@ -173,11 +236,11 @@
 *                         1: All equal.
 *
 *
-* wcsutil_Eq() - Test for equality of two double arrays
-* -----------------------------------------------------
+* wcsutil_dblEq() - Test for equality of two arrays of type double
+* ----------------------------------------------------------------
 * INTERNAL USE ONLY.
 *
-* wcsutil_Eq() tests for equality of two double-precision arrays.
+* wcsutil_dblEq() tests for equality of two double-precision arrays.
 *
 * Given:
 *   nelem     int       The number of elements in each array.
@@ -199,8 +262,8 @@
 *                         1: Equal.
 *
 *
-* wcsutil_intEq() - Test for equality of two int arrays
-* -----------------------------------------------------
+* wcsutil_intEq() - Test for equality of two arrays of type int
+* -------------------------------------------------------------
 * INTERNAL USE ONLY.
 *
 * wcsutil_intEq() tests for equality of two int arrays.
@@ -245,7 +308,8 @@
 * --------------------------------------------------
 * INTERNAL USE ONLY.
 *
-* wcsutil_setAll() sets the value of a particular element in a set of vectors.
+* wcsutil_setAll() sets the value of a particular element in a set of vectors
+* of type double.
 *
 * Given:
 *   nvec      int       The number of vectors.
@@ -273,7 +337,8 @@
 * --------------------------------------------------
 * INTERNAL USE ONLY.
 *
-* wcsutil_setAli() sets the value of a particular element in a set of vectors.
+* wcsutil_setAli() sets the value of a particular element in a set of vectors
+* of type int.
 *
 * Given:
 *   nvec      int       The number of vectors.
@@ -406,14 +471,18 @@ extern "C" {
 
 void wcsdealloc(void *ptr);
 
-void wcsutil_strcvt(int n, char c, const char src[], char dst[]);
+void wcsutil_strcvt(int n, char c, int nt, const char src[], char dst[]);
 
 void wcsutil_blank_fill(int n, char c[]);
 void wcsutil_null_fill (int n, char c[]);
 
+int  wcsutil_all_ival(int nelem, int ival, const int iarr[]);
+int  wcsutil_all_dval(int nelem, double dval, const double darr[]);
+int  wcsutil_all_sval(int nelem, const char *sval, const char (*sarr)[72]);
 int  wcsutil_allEq (int nvec, int nelem, const double *first);
-int  wcsutil_Eq(int nelem, double tol, const double *arr1,
-                const double *arr2);
+
+int  wcsutil_dblEq(int nelem, double tol, const double *arr1,
+                   const double *arr2);
 int  wcsutil_intEq(int nelem, const int *arr1, const int *arr2);
 int  wcsutil_strEq(int nelem, char (*arr1)[72], char (*arr2)[72]);
 void wcsutil_setAll(int nvec, int nelem, double *first);
@@ -428,4 +497,4 @@ int  wcsutil_str2double2(const char *buf
 }
 #endif
 
-#endif /* WCSLIB_WCSUTIL */
+#endif // WCSLIB_WCSUTIL
Index: astropy-4.2.1/cextern/wcslib/C/wcsutrn.l
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wcsutrn.l
+++ astropy-4.2.1/cextern/wcslib/C/wcsutrn.l
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsutrn.l,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsutrn.l,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
 * wcsutrn.l is a Flex description file containing the definition of a lexical
@@ -43,6 +40,7 @@
 %option outfile="wcsutrn.c"
 %option prefix="wcsutrn"
 %option reentrant
+%option extra-type="struct wcsutrn_extra *"
 
 /* Exclusive start states. */
 %x NEXT FLUSH
@@ -56,64 +54,47 @@
 #include "wcserr.h"
 #include "wcsunits.h"
 
-static int wcsutrne_scanner(int ctrl, char unitstr[], struct wcserr **err,
-                            yyscan_t yyscanner);
-
-/*--------------------------------------------------------------------------*/
-
-int wcsutrne(
-  int ctrl,
-  char unitstr[],
-  struct wcserr **err)
-
-{
-  int status;
-  yyscan_t yyscanner;
-  int yylex_init(yyscan_t *yyscanner);
-  int yylex_destroy(yyscan_t yyscanner);
-
-  yylex_init(&yyscanner);
-  status = wcsutrne_scanner(ctrl, unitstr, err, yyscanner);
-  yylex_destroy(yyscanner);
-
-  return status;
-}
-
-/*--------------------------------------------------------------------------*/
+// User data associated with yyscanner.
+struct wcsutrn_extra {
+  // Used in preempting the call to exit() by yy_fatal_error().
+  jmp_buf abort_jmp_env;
+};
 
 #define YY_DECL int wcsutrne_scanner(int ctrl, char unitstr[], \
  struct wcserr **err, yyscan_t yyscanner)
 
-/* Dummy definition to circumvent compiler warnings. */
+// Dummy definition to circumvent compiler warnings.
 #define YY_INPUT(inbuff, count, bufsize) { count = YY_NULL; }
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
-jmp_buf wcsutrn_abort_jmp_env;
-#define exit(status) longjmp(wcsutrn_abort_jmp_env, status)
+// Preempt the call to exit() by yy_fatal_error().
+#define exit(status) longjmp(yyextra->abort_jmp_env, status);
+
+// Internal helper functions.
+static YY_DECL;
 
 %}
 
 %%
-	static const char *function = "wcsutrne";
-	
-	char orig[80], subs[80];
-	int bracket = 0;
-	int unsafe  = 0;
-	int status  = -1;
+	static const char *function = "wcsutrne_scanner";
 	
 	if (err) *err = 0x0;
 	
+	char orig[80], subs[80];
 	*orig = '\0';
 	*subs = '\0';
 	
+	int bracket = 0;
+	int unsafe  = 0;
+	int status  = -1;
+	
 	yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
 	yy_scan_string(unitstr, yyscanner);
 	*unitstr = '\0';
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
-	if (setjmp(wcsutrn_abort_jmp_env)) {
+	// Return here via longjmp() invoked by yy_fatal_error().
+	if (setjmp(yyextra->abort_jmp_env)) {
 	  return wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
-	    "Internal units translator error parsing '%s'", unitstr);
+	    "Internal units translator error");
 	}
 	
 	BEGIN(INITIAL);
@@ -123,22 +104,22 @@ jmp_buf wcsutrn_abort_jmp_env;
 	#endif
 
 ^" "*"[" {
-	  /* Looks like a keycomment. */
+	  // Looks like a keycomment.
 	  strcat(unitstr, "[");
 	  bracket = 1;
 	}
 
-" "+	  /* Discard leading whitespace. */
+" "+	  // Discard leading whitespace.
 
 [^A-Za-z] {
-	  /* Non-alphabetic character. */
+	  // Non-alphabetic character.
 	  strcat(unitstr, yytext);
 	  if (bracket && *yytext == ']') {
 	    BEGIN(FLUSH);
 	  }
 	}
 
-angstrom {
+Angstroms|angstroms? {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "Angstrom");
 	  BEGIN(NEXT);
@@ -304,25 +285,25 @@ years?|YR|YEARS? {
 	}
 
 [A-Za-z]+ {
-	  /* Not a recognized alias. */
+	  // Not a recognized alias.
 	  strcpy(orig, yytext);
 	  strcpy(subs, orig);
 	  BEGIN(NEXT);
 	}
 
 <NEXT>[A-Za-z]+ {
-	  /* Reject the alias match. */
+	  // Reject the alias match.
 	  strcat(orig, yytext);
 	  strcpy(subs, orig);
 	}
 
 <NEXT>" "+[^A-Za-z] {
-	  /* Discard separating whitespace. */
+	  // Discard separating whitespace.
 	  unput(yytext[yyleng-1]);
 	}
 
 <NEXT>" "+[A-Za-z] {
-	  /* Compress separating whitespace. */
+	  // Compress separating whitespace.
 	  strcat(unitstr, subs);
 	  strcat(unitstr, " ");
 	  if (strcmp(orig, subs)) status = 0;
@@ -332,7 +313,7 @@ years?|YR|YEARS? {
 	}
 
 <NEXT>.	{
-	  /* Copy anything else unchanged. */
+	  // Copy anything else unchanged.
 	  strcat(unitstr, subs);
 	  if (strcmp(orig, subs)) status = 0;
 	  unput(*yytext);
@@ -341,12 +322,12 @@ years?|YR|YEARS? {
 	}
 
 <FLUSH>.* {
-	  /* Copy out remaining input. */
+	  // Copy out remaining input.
 	  strcat(unitstr, yytext);
 	}
 
 <<EOF>>	{
-	  /* End-of-string. */
+	  // End-of-string.
 	  if (*subs) {
 	    strcat(unitstr, subs);
 	    if (strcmp(orig, subs)) status = 0;
@@ -360,3 +341,28 @@ years?|YR|YEARS? {
 	}
 
 %%
+
+/*----------------------------------------------------------------------------
+* External interface to the scanner.
+*---------------------------------------------------------------------------*/
+
+int wcsutrne(
+  int ctrl,
+  char unitstr[],
+  struct wcserr **err)
+
+{
+  static const char *function = "wcsutrne";
+
+  // Function prototypes.
+  int yylex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *yyscanner);
+  int yylex_destroy(yyscan_t yyscanner);
+
+  struct wcsutrn_extra extra;
+  yyscan_t yyscanner;
+  yylex_init_extra(&extra, &yyscanner);
+  int status = wcsutrne_scanner(ctrl, unitstr, err, yyscanner);
+  yylex_destroy(yyscanner);
+
+  return status;
+}
Index: astropy-4.2.1/cextern/wcslib/C/wtbarr.h
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/C/wtbarr.h
+++ astropy-4.2.1/cextern/wcslib/C/wtbarr.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wtbarr.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wtbarr.h,v 7.6 2021/04/13 12:57:01 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.6 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -95,24 +92,24 @@
 
 #ifdef __cplusplus
 extern "C" {
-#define wtbarr wtbarr_s		/* See prologue above.                      */
+#define wtbarr wtbarr_s		// See prologue above.
 #endif
-				/* For extracting wcstab arrays.  Matches   */
-				/* the wtbarr typedef defined in CFITSIO    */
-				/* header fitsio.h.                         */
+				// For extracting wcstab arrays.  Matches
+				// the wtbarr typedef defined in CFITSIO
+				// header fitsio.h.
 struct wtbarr {
-  int  i;			/* Image axis number.                       */
-  int  m;			/* Array axis number for index vectors.     */
-  int  kind;			/* wcstab array type.                       */
-  char extnam[72];		/* EXTNAME of binary table extension.       */
-  int  extver;			/* EXTVER  of binary table extension.       */
-  int  extlev;			/* EXTLEV  of binary table extension.       */
-  char ttype[72];		/* TTYPEn of column containing the array.   */
-  long row;			/* Table row number.                        */
-  int  ndim;			/* Expected wcstab array dimensionality.    */
-  int  *dimlen;			/* Where to write the array axis lengths.   */
-  double **arrayp;		/* Where to write the address of the array  */
-				/* allocated to store the wcstab array.     */
+  int  i;			// Image axis number.
+  int  m;			// Array axis number for index vectors.
+  int  kind;			// wcstab array type.
+  char extnam[72];		// EXTNAME of binary table extension.
+  int  extver;			// EXTVER  of binary table extension.
+  int  extlev;			// EXTLEV  of binary table extension.
+  char ttype[72];		// TTYPEn of column containing the array.
+  long row;			// Table row number.
+  int  ndim;			// Expected wcstab array dimensionality.
+  int  *dimlen;			// Where to write the array axis lengths.
+  double **arrayp;		// Where to write the address of the array
+				// allocated to store the wcstab array.
 };
 
 #ifdef __cplusplus
@@ -120,4 +117,4 @@ struct wtbarr {
 }
 #endif
 
-#endif /* WCSLIB_WTBARR */
+#endif // WCSLIB_WTBARR
Index: astropy-4.2.1/cextern/wcslib/CHANGES
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/CHANGES
+++ astropy-4.2.1/cextern/wcslib/CHANGES
@@ -1,3 +1,186 @@
+WCSLIB version 7.6 (2021/04/13)
+-------------------------------
+
+* C library
+
+  - Bug fix in tabs2x() triggered for 1-dimensional coordinate lookup
+    tables on axes > 1.  Reported by Mihai Cara.
+
+  - In datfix(), don't return status 0 if no change was made (fix for
+    change made at release 7.4).  Reported by Derek Homeier.
+
+  - New function wcspcx() in the wcsfix suite regularizes the linear
+    transformation component of a coordinate description to make it more
+    human-readable.  It decomposes CDi_ja into PCi_ja and CDELTia in
+    such a way that CDELTia forms meaningful scaling parameters, often
+    leaving an orthogonal or near-orthogonal matrix.  Optionally, it can
+    then permute rows of this matrix to unscramble axis permutations.
+
+    A test header may be generated from wcspcx.keyrec for input to
+    wcsware (not exercised as part of the standard test suite).
+
+  - New function wcstrim() frees memory allocated by wcsinit() for
+    arrays in a wcsprm struct that remain unused after the struct has
+    been set up.
+
+  - New functions wcssize(), auxsize(), tabsize(), linsize(), dissize(),
+    celsize(), prjsize(), spcsize(), and wcserr_size() compute the total
+    size of the relevant structs, including allocated memory.
+
+  - In the C test suite, inserted a brief pause in tprj2 and tspc, which
+    otherwise have now become a blur.
+
+* Fortran wrappers
+
+  - Added wrappers for wcspcx(), wcstrim(), wcssize(), auxsize(),
+    tabsize(), linsize(), dissize(), celsize(), prjsize(), spcsize(),
+    and wcserr_size().
+
+* Utilities
+
+  - Added -c, -cp, -C, and -Cp options to wcsware to apply wcspcx()
+    in a variety of ways, -m to apply wcstrim(), and -z to report the
+    total size of the wcsprm struct with a breakdown of the sizes of
+    its constituent structs.
+
+  - Fixed compiler warnings for sundazel (portability issue).
+
+* Installation
+
+  - Upped the required version of Flex to 2.6.0 (was 2.5.9).  Problems
+    with Flex 2.5.39 reported by Derek Homeier.
+
+    Also added '--disable-flex' as a new configure option to force the
+    use of the pre-generated Flex sources.
+
+
+WCSLIB version 7.5 (2021/03/20)
+-------------------------------
+
+The C code in WCSLIB is moving piecemeal to the C99 standard.  In fact,
+various indispensible C99 constructs have been used in WCSLIB for many
+years: the long long int data type (in fitshdr() only); stdint.h,
+inttypes.h, and the use of PRI formatting control (in wcsprintf(), which
+is widely used by the library); and the C99-extended library function
+vsnprintf() (used by wcserr for a decade).  Flex-generated C code also
+uses C99 extensions, though with workarounds if they are not available.
+
+Except in the header prologues, which are formatted in a special way for
+generating the user manual, comments were changed en masse to C99 style
+in release 7.3.1, and variable declarations in code that I have occasion
+to modify will transition to the more general placement allowed by C99.
+However, I have no plans to use any of the more esoteric features of
+C99.
+
+* C library
+
+  - New function, wcsccs(), changes the celestial coordinate system of a
+    wcsprm struct, for example, from equatorial to galactic coordinates.
+    The parameters that define the spherical coordinate transformation
+    must be provided.  This allows WCSLIB to provide this functionality
+    without needing to know anything about specific celestial coordinate
+    systems, and has the advantage of making the routine completely
+    general.  Requested by Mohammad Akhlaghi.
+
+    Modified test program twcsfix also to test wcsccs().
+
+  - Fixed a problem common to all of the Flex code (fitshdr, wcsbth,
+    wcspih, wcsulex, and wcsutrn) that made it thread-unsafe.  Reported
+    by Cyril Richard.
+
+    Added a new test program, tpthreads, to test thread safety.  It is
+    only used for code development, and not exercised as part of the
+    standard test suite.
+
+  - In fitshdr(), fixed a problem that potentially could arise on
+    systems where sizeof(long long int) is greater than 8 (64 bits).
+
+* Fortran wrappers
+
+  - Match changes to the C library: added a wrapper for wcsccs(), and
+    modified twcsfix.f.
+
+  - Because null addresses cannot be passed to functions in Fortran,
+    wcssub_() now interprets *nsub == -1 && *axes == -1 as a signal to
+    do a deep copy of one wcsprm struct to another.
+
+* Utilities
+
+  - New utility, sundazel, computes the local time of the Sun's passage
+    through the specified apparent longitude or latitude in a user-
+    defined coordinate system.  It can also perform several other Solar
+    related calculations.  (It is unrelated to FITS WCS, and does not
+    use WCSLIB.)
+
+* Installation
+
+  - Added an 'uninstall' rule to the makefiles.  Suggested by
+    Cyril Richard.
+
+
+WCSLIB version 7.4 (2021/01/31)
+-------------------------------
+
+* C library
+
+  - In wcshdo(), fixed a bug introduced in release 5.9 that potentially
+    caused loss of numerical precision in the sprintf() formatting of
+    floating point keyvalues.  This was triggered when a large range of
+    CRPIXja, PCi_ja, or CDELTia values (as three separate groups) were
+    formatted using an 'f' format descriptor, the range not being so
+    large that it would have forced wcshdo() to revert to 'E' format.
+    Reported by Mohammad Akhlaghi.
+
+    Also in wcshdo(), fixed a bug introduced in release 7.1 that caused
+    the coefficients of the TPD distortion function not to be written to
+    the header.  TPD and Polynomial distortion function headers will now
+    always include the DPja.DOCORR keyword.  Reported by Derek Homeier
+    with patch.
+
+  - In wcsset(), fixed a segv generated in attempting to report a non-
+    standard units string with wcserr message reporting disabled.
+    Reported by Mohammad Akhlaghi.
+
+    In wcsutrne(), allow 'Angstroms' and 'angstroms' as additional
+    synonyms for 'Angstrom'.
+
+  - In datfix(), ensure that 0 is returned if an informational message
+    is set in wcsprm::err.  Consequent on feedback independently from
+    Mihai Cara and Bruce Merry.
+
+    Clarified that informational messages may be set in wcsprm::err
+    for returns of 0 from datfix(), obsfix(), unitfix(), and spcfix().
+
+* User manual
+
+  - Added cautions about translating CDi_ja to PCi_ja plus CDELTia for
+    those historical distortion functions (TPV, TNX, ZPX) that expect to
+    operate on intermediate world coordinates, rather than intermediate
+    pixel coordinates.  Consequent on feedback from Mohammad Akhlaghi.
+
+  - Documentation generation moved to doxygen 1.9.1 (was 1.8.19).
+
+
+WCSLIB version 7.3.1 (2020/08/17)
+---------------------------------
+
+There are no functional changes in this release.
+
+* C library
+* Fortran wrappers
+* PGSBOX
+* Utilities
+
+  - Changed all C code, including within the flex sources, Fortran and
+    PGSBOX wrappers, and test suite, to use C99 style commenting (i.e.
+    using //), excluding the header prologues used to generate the user
+    manual.
+
+* User manual
+
+  - Documentation generation moved to doxygen 1.8.19 (was 1.8.18).
+
+
 WCSLIB version 7.3 (2020/06/03)
 -------------------------------
 
@@ -3030,4 +3213,4 @@ WCSLIB version 1.0 (1995/01/31)
   Initial release.
 
 ------------------------------------------------------------------------
-$Id: CHANGES,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+$Id: CHANGES,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
Index: astropy-4.2.1/cextern/wcslib/GNUmakefile
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/GNUmakefile
+++ astropy-4.2.1/cextern/wcslib/GNUmakefile
@@ -1,5 +1,5 @@
 #-----------------------------------------------------------------------------
-# GNU makefile for building WCSLIB 7.3
+# GNU makefile for building WCSLIB 7.6
 #
 # Summary of the main targets
 # ---------------------------
@@ -8,6 +8,8 @@
 #   tests:     Do 'make tests' in each subdirectory (compile test programs but
 #              don't run them).
 #   install:   Do 'make install' in each subdirectory.
+#   uninstall: Deletes installed files (this release only), including the
+#              sharable library.
 #   clean:     Recursively delete intermediate files produced as part of the
 #              build, e.g. object modules, core dumps, etc.
 #   cleaner:   Recursively clean, and also delete test executables, test
@@ -32,7 +34,7 @@
 #
 # Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 # http://www.atnf.csiro.au/people/Mark.Calabretta
-# $Id: GNUmakefile,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+# $Id: GNUmakefile,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
 #-----------------------------------------------------------------------------
 # Get configure settings.
 SUBDIR := .
@@ -43,7 +45,7 @@ ifeq "$(CHECK)" "nopgplot"
 endif
 
 .PHONY : build check chmod clean cleaner cleanest distclean install \
-         realclean show tests writable
+         realclean show tests uninstall writable
 
 build :
 	-@ for DIR in $(SUBDIRS) ; do \
@@ -81,6 +83,10 @@ install :
 	 @ for DIR in $(INSTDIR) ; do \
 	     $(MAKE) -k -C $$DIR $@ ; \
 	   done
+	   if [ ! -d "$(LIBDIR)/pkgconfig" ] ; then \
+	     $(INSTALL) -d -m 775 $(LIBDIR)/pkgconfig ; \
+	   fi
+	   $(INSTALL) -m 444 wcslib.pc $(LIBDIR)/pkgconfig/wcslib.pc
 	   $(INSTALL) -m 444 wcsconfig.h wcsconfig_f77.h $(INCDIR)
 	-  if [ ! -d "$(DOCDIR)" ] ; then \
 	     $(INSTALL) -d -m 775 $(DOCDIR) ; \
@@ -98,10 +104,17 @@ install :
 	     $(INSTALL) -d -m 775 $(HTMLDIR)/html ; \
 	   fi
 	   $(INSTALL) -m 444 html/* $(HTMLDIR)/html
-	   if [ ! -d "$(LIBDIR)/pkgconfig" ] ; then \
-	     $(INSTALL) -d -m 775 $(LIBDIR)/pkgconfig ; \
-	   fi
-	   $(INSTALL) -m 444 wcslib.pc $(LIBDIR)/pkgconfig/wcslib.pc
+
+uninstall :
+	 @ for DIR in $(INSTDIR) ; do \
+	     $(MAKE) -k -C $$DIR $@ ; \
+	   done
+	-  cd $(LIBDIR) && $(RM) pkgconfig/wcslib.pc
+	-  cd $(INCDIR) && $(RM) wcsconfig*.h
+	-  $(RM) $(DOCLINK)
+	-  $(RM) $(DOCDIR)
+	-  $(RM) $(PDFDIR)
+	-  $(RM) $(HTMLDIR)
 
 clean cleaner :
 	   for DIR in $(SUBDIRS) doxygen ; do \
Index: astropy-4.2.1/cextern/wcslib/INSTALL
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/INSTALL
+++ astropy-4.2.1/cextern/wcslib/INSTALL
@@ -1,5 +1,5 @@
 ------------------------------------------------------------------------------
-WCSLIB 7.3 and PGSBOX 7.3 INSTALLATION
+WCSLIB 7.6 and PGSBOX 7.6 INSTALLATION
 --------------------------------------
 
 WCSLIB requires an ANSI C compiler with standard ANSI C environment, that is,
@@ -9,8 +9,8 @@ Ritchie, 2nd ed.
 If you are running a typical Linux distro and have installed WCSLIB before,
 then all you should need to do is
 
-  tar pxvf wcslib-7.3.tar.bz2
-  cd wcslib-7.3
+  tar pxvf wcslib-7.6.tar.bz2
+  cd wcslib-7.6
   make install
 
 Otherwise, read on.
@@ -19,8 +19,8 @@ Installation of WCSLIB is handled by GNU
 as 'gmake') must be used.  The WCSLIB distribution also includes PGSBOX (refer
 to the README file).  To unpack the tar file, type
 
-  bzcat wcslib-7.3.tar.bz2 | tar pvxf -
-  cd wcslib-7.3
+  bzcat wcslib-7.6.tar.bz2 | tar pvxf -
+  cd wcslib-7.6
 
 then if you do not need to specify any configuration options, simply run
 
@@ -102,7 +102,7 @@ The INSTALL file provided with GNU autoc
 
 Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 http://www.atnf.csiro.au/people/Mark.Calabretta
-$Id: INSTALL,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+$Id: INSTALL,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
 
 ==============================================================================
 
Index: astropy-4.2.1/cextern/wcslib/README
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/README
+++ astropy-4.2.1/cextern/wcslib/README
@@ -1,8 +1,8 @@
 ------------------------------------------------------------------------------
-                         WCSLIB 7.3 and PGSBOX 7.3
+                         WCSLIB 7.6 and PGSBOX 7.6
 ------------------------------------------------------------------------------
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.6 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -19,11 +19,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: README,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+  $Id: README,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
 ------------------------------------------------------------------------------
 
 Please refer to
Index: astropy-4.2.1/cextern/wcslib/THANKS
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/THANKS
+++ astropy-4.2.1/cextern/wcslib/THANKS
@@ -2,7 +2,7 @@ I would like to acknowledge the followin
 to WCSLIB and/or PGSBOX in some way since 1995 - via bug reports,
 patches, suggestions for improvements, positive feedback, etc.
 
-Mohammad Aghlaghi (IAC & GNUastro)
+Mohammad Akhlaghi (IAC & GNUastro)
 James Allen (U. Sydney)
 James M. Anderson (MPIfR)
 Robbie Auld (Cardiff U.)
@@ -16,7 +16,7 @@ Erik M. Bray (STScI)
 Jeremy Brewer (U. Pittsburgh)
 Wim Brouw (ATNF/CSIRO)
 Peter Bunclark (IoA, U. Cambridge)
-Mihai Cara (STScI)
+Mihai Cara (STScI/Astropy)
 Rodrigo Tobar Carrizo (ICRAR/UWA)
 Pan Chai (GSFC/NASA)
 Charles Copley
@@ -24,7 +24,7 @@ Simon Conseil (CRAL)
 Neil Crighton
 Cesar Enrique Garcia Dabo (ESO)
 Lindsey Davis (NOAO)
-Nadezhda (Nadia) Dencheva (STScI)
+Nadezhda (Nadia) Dencheva (STScI/Astropy)
 Ger van Diepen (ASTRON)
 Patrick Dowler (CADC/NRC)
 Michael Droettboom (STScI)
@@ -39,6 +39,7 @@ Eric Greisen (NRAO)
 Michael Halle (AM/Harvard)
 Booth Hartley (IPAC/NASA)
 Phil Hodge (STScI)
+Derek Homeier (Astropy)
 Bryan Irby (GSFC/NASA)
 Justin Jonas (Rhodes U.)
 Yves Jung (ESO)
@@ -65,6 +66,7 @@ Tom Marsh (U. Warwick)
 Sean Mattingly (IPAC/NASA)
 Dave McConnell (ATNF/CSIRO)
 Thomas A. McGlynn (GSFC/NASA)
+Bruce Merry (SARAO)
 Michelle Miller (NOAO)
 Jessica Mink (CfA)
 David Motl (var.astro.cz)
@@ -80,13 +82,14 @@ Ray Plante (NCSA/UIUC)
 Paul Price (Princeton U.)
 Niruj Mohan Ramanujam (Leiden Obs)
 Harold Ravlin (U. Illinois)
+Cyril Richard (CNRS)
 Thomas Robitaille (MPIA, STScI)
 Boud Roukema (TCfA)
 Keith A. Scollick (GSFC/NASA)
 Arno Schoenmakers (ASTRON)
 Pim Schellart (Princeton U.)
 Corentin Schreiber (Oxford U.)
-Michael Seifert (astropy)
+Michael Seifert (Astropy)
 Colin Slater (LSST)
 Hanno Spreeuw (ASTRON)
 Ole Streicher (Debian maintainer)
@@ -108,4 +111,4 @@ Daren Scot Wilson (NRAO)
 Tony Wong (ATNF/CSIRO)
 
 
-$Id: THANKS,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+$Id: THANKS,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
Index: astropy-4.2.1/cextern/wcslib/VALIDATION
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/VALIDATION
+++ astropy-4.2.1/cextern/wcslib/VALIDATION
@@ -1,5 +1,45 @@
 Platforms on which the installation procedures and test suite were exercised.
 
+WCSLIB version 7.6 (2021/04/13)
+-------------------------------
+
+* Dell Latitude E6530 (Intel Core i7-3740QM, 4 cores, 8 processors, x86_64)
+  KDE Neon User Edition 5.21 (over Kubuntu 20.04, (focal))
+  uname -r (kernel version): 5.4.0-67-generic
+  gcc --version: gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
+  gfortran --version: GNU Fortran (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
+
+
+WCSLIB version 7.5 (2021/03/20)
+-------------------------------
+
+* Dell Latitude XPS 15 9560 (Intel Core i7-7700HQ, 4 cores, 8 CPUs, x86_64)
+  KDE Neon User Edition 5.20 (over Kubuntu 20.04, (focal))
+  uname -r (kernel version): 5.4.0-62-generic
+  gcc --version: gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
+  gfortran --version: GNU Fortran (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
+
+
+WCSLIB version 7.4 (2021/01/31)
+-------------------------------
+
+* Dell Latitude XPS 15 9560 (Intel Core i7-7700HQ, 4 cores, 8 CPUs, x86_64)
+  KDE Neon User Edition 5.20 (over Kubuntu 20.04, (focal))
+  uname -r (kernel version): 5.4.0-62-generic
+  gcc --version: gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
+  gfortran --version: GNU Fortran (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
+
+
+WCSLIB version 7.3.1 (2020/08/17)
+---------------------------------
+
+* Dell Latitude XPS 15 9560 (Intel Core i7-7700HQ, 4 cores, 8 CPUs, x86_64)
+  KDE Neon User Edition 5.19 (over Kubuntu 18.04, (bionic))
+  uname -r (kernel version): 4.15.0-112-generic
+  gcc --version: gcc (GCC) 9.2.0 (local build)
+  gfortran --version: GNU Fortran (GCC) 9.2.0 (local build)
+
+
 WCSLIB version 7.3 (2020/06/03)
 -------------------------------
 
@@ -626,4 +666,4 @@ WCSLIB version 4.4 (2009/08/06)
           2004/04/23
 
 ------------------------------------------------------------------------------
-$Id: VALIDATION,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+$Id: VALIDATION,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
Index: astropy-4.2.1/cextern/wcslib/configure
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/configure
+++ astropy-4.2.1/cextern/wcslib/configure
@@ -1,7 +1,7 @@
 #! /bin/sh
-# From configure.ac Revision: 7.3 .
+# From configure.ac Revision: 7.6 .
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for WCSLIB 7.3.
+# Generated by GNU Autoconf 2.69 for WCSLIB 7.6.
 #
 # Report bugs to <mark@calabretta.id.au>.
 #
@@ -580,9 +580,9 @@ MAKEFLAGS=
 
 # Identity of this package.
 PACKAGE_NAME='WCSLIB'
-PACKAGE_TARNAME='wcslib-7.3'
-PACKAGE_VERSION='7.3'
-PACKAGE_STRING='WCSLIB 7.3'
+PACKAGE_TARNAME='wcslib-7.6'
+PACKAGE_VERSION='7.6'
+PACKAGE_STRING='WCSLIB 7.6'
 PACKAGE_BUGREPORT='mark@calabretta.id.au'
 PACKAGE_URL=''
 
@@ -625,6 +625,9 @@ ac_includes_default="\
 
 ac_subst_vars='LTLIBOBJS
 FLAVOUR
+OBSTZ
+OBSLAT
+OBSLNG
 INSTDIR
 TSTDIRS
 SUBDIRS
@@ -716,6 +719,7 @@ SHELL'
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
+enable_flex
 enable_fortran
 enable_shared
 enable_largefile
@@ -1290,7 +1294,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures WCSLIB 7.3 to adapt to many kinds of systems.
+\`configure' configures WCSLIB 7.6 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1339,7 +1343,7 @@ Fine tuning of the installation director
   --infodir=DIR           info documentation [DATAROOTDIR/info]
   --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
   --mandir=DIR            man documentation [DATAROOTDIR/man]
-  --docdir=DIR            documentation root [DATAROOTDIR/doc/wcslib-7.3]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/wcslib-7.6]
   --htmldir=DIR           html documentation [DOCDIR]
   --dvidir=DIR            dvi documentation [DOCDIR]
   --pdfdir=DIR            pdf documentation [DOCDIR]
@@ -1360,7 +1364,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of WCSLIB 7.3:";;
+     short | recursive ) echo "Configuration of WCSLIB 7.6:";;
    esac
   cat <<\_ACEOF
 
@@ -1368,6 +1372,7 @@ Optional Features:
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --disable-flex          don't apply flex (use pre-generated sources)
   --enable-fortran=ARG    Fortran compiler to use
   --disable-fortran       don't build the Fortran wrappers or PGSBOX
   --disable-shared        don't build the WCS shared libraries
@@ -1464,7 +1469,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-WCSLIB configure 7.3
+WCSLIB configure 7.6
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
@@ -2238,7 +2243,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by WCSLIB $as_me 7.3, which was
+It was created by WCSLIB $as_me 7.6, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
@@ -2707,7 +2712,20 @@ ARCH="${host_cpu}-$host_os"
 
 
 # Look for Flex.
-# Extract the first word of "flex", so it can be a program name with args.
+# Check whether --enable-flex was given.
+if test "${enable_flex+set}" = set; then :
+  enableval=$enable_flex;
+fi
+
+if test "x$enable_flex" = xno ; then
+  FLEX=
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Generation of flex sources disabled by request, using
+           pre-generated sources." >&5
+$as_echo "$as_me: WARNING: Generation of flex sources disabled by request, using
+           pre-generated sources." >&2;}
+
+else
+  # Extract the first word of "flex", so it can be a program name with args.
 set dummy flex; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
@@ -2744,25 +2762,26 @@ $as_echo "no" >&6; }
 fi
 
 
-if test "x$FLEX" = xflex ; then
-  # Version 2.5.9 or later is required.
-  V=`flex --version | awk '{print $2}'`
-  W=`echo $V | awk -F. '{if ((($1*100 + $2)*100 + $3) < 20509) print "no"}'`
-  if test "x$W" != x ; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: Flex version $V is too old, ignored." >&5
-$as_echo "$as_me: Flex version $V is too old, ignored." >&6;}
-    FLEX=
-  else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: Using Flex version $V." >&5
+  if test "x$FLEX" = xflex ; then
+    # Version 2.6.0 or later is required.
+    V=`flex --version | awk '{print $2}'`
+    W=`echo $V | awk -F. '{if ((($1*100 + $2)*100 + $3) < 20600) print "no"}'`
+    if test "x$W" != x ; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Flex version $V is too old, ignored." >&5
+$as_echo "$as_me: WARNING: Flex version $V is too old, ignored." >&2;}
+      FLEX=
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: Using Flex version $V." >&5
 $as_echo "$as_me: Using Flex version $V." >&6;}
+    fi
   fi
-fi
 
-if test "x$FLEX" = x ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Flex version 2.5.9 or later does not appear to be
+  if test "x$FLEX" = x ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Flex version 2.6.0 or later does not appear to be
            available, will use pre-generated sources." >&5
-$as_echo "$as_me: WARNING: Flex version 2.5.9 or later does not appear to be
+$as_echo "$as_me: WARNING: Flex version 2.6.0 or later does not appear to be
            available, will use pre-generated sources." >&2;}
+  fi
 fi
 
 
@@ -5771,8 +5790,8 @@ fi
 if test "x$F77" = xno ; then
   F77=
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Compilation of Fortran wrappers and PGSBOX disabled" >&5
-$as_echo "$as_me: WARNING: Compilation of Fortran wrappers and PGSBOX disabled" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Compilation of Fortran wrappers and PGSBOX disabled." >&5
+$as_echo "$as_me: WARNING: Compilation of Fortran wrappers and PGSBOX disabled." >&2;}
 
 else
   if test "x$F77" = x ; then
@@ -6937,8 +6956,8 @@ SHRLN=
 
 if test "x$ac_cv_c_compiler_gnu" = xyes ; then
   if test "x$enable_shared" = xno ; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Generation of WCS shared libraries disabled" >&5
-$as_echo "$as_me: WARNING: Generation of WCS shared libraries disabled" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Generation of WCS shared libraries disabled." >&5
+$as_echo "$as_me: WARNING: Generation of WCS shared libraries disabled." >&2;}
 
   else
     SHVER=`echo "$LIBVER" | sed -e 's/\..*$//'`
@@ -7453,8 +7472,8 @@ if test "${with_cfitsio+set}" = set; the
 fi
 
 if test "x$with_cfitsio" = xno ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: CFITSIO disabled" >&5
-$as_echo "$as_me: WARNING: CFITSIO disabled" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: CFITSIO disabled." >&5
+$as_echo "$as_me: WARNING: CFITSIO disabled." >&2;}
 else
 
 # Check whether --with-cfitsiolib was given.
@@ -7492,8 +7511,8 @@ if test "${with_pgplot+set}" = set; then
 fi
 
 if test "x$with_pgplot" = xno ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: PGPLOT disabled" >&5
-$as_echo "$as_me: WARNING: PGPLOT disabled" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: PGPLOT disabled." >&5
+$as_echo "$as_me: WARNING: PGPLOT disabled." >&2;}
 else
 
 # Check whether --with-pgplotlib was given.
@@ -8521,13 +8540,28 @@ if test "${enable_utils+set}" = set; the
 fi
 
 if test "x$enable_utils" = xno ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Compilation of WCS utilities disabled" >&5
-$as_echo "$as_me: WARNING: Compilation of WCS utilities disabled" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Compilation of WCS utilities disabled." >&5
+$as_echo "$as_me: WARNING: Compilation of WCS utilities disabled." >&2;}
 else
   SUBDIRS="$SUBDIRS utils"
   INSTDIR="$INSTDIR utils"
 fi
 
+# Default observer coordinates for sundazel.
+if test -f "$HOME/.sundazelrc"; then
+  . "$HOME/.sundazelrc"
+fi
+
+if test "x$OBSLNG" = x; then
+  OBSLNG=0.0
+  OBSLAT=0.0
+  OBSTZ=0.0
+fi
+
+
+
+
+
 
 
 
@@ -9061,7 +9095,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_wri
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by WCSLIB $as_me 7.3, which was
+This file was extended by WCSLIB $as_me 7.6, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -9123,7 +9157,7 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-WCSLIB config.status 7.3
+WCSLIB config.status 7.6
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
Index: astropy-4.2.1/cextern/wcslib/configure.ac
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/configure.ac
+++ astropy-4.2.1/cextern/wcslib/configure.ac
@@ -3,12 +3,12 @@
 #-----------------------------------------------------------------------------
 # Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 # http://www.atnf.csiro.au/people/Mark.Calabretta
-# $Id: configure.ac,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+# $Id: configure.ac,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
 #-----------------------------------------------------------------------------
 
-AC_INIT([WCSLIB], [7.3], [mark@calabretta.id.au], [wcslib-7.3])
+AC_INIT([WCSLIB], [7.6], [mark@calabretta.id.au], [wcslib-7.6])
 AC_PREREQ([2.53])
-AC_REVISION([$Revision: 7.3 $])
+AC_REVISION([$Revision: 7.6 $])
 AC_SUBST([PACKAGE_VERSION])
 AC_DEFINE_UNQUOTED([WCSLIB_VERSION], [$PACKAGE_VERSION], [Define wcslib version])
 
@@ -26,22 +26,31 @@ AC_SUBST([ARCH])
 
 
 # Look for Flex.
-AC_CHECK_PROG([FLEX], [flex], [flex], [], [], [])
-if test "x$FLEX" = xflex ; then
-  # Version 2.5.9 or later is required.
-  V=`flex --version | awk '{print $2}'`
-  W=`echo $V | awk -F. '{if ((($1*100 + $2)*100 + $3) < 20509) print "no"}'`
-  if test "x$W" != x ; then
-    AC_MSG_NOTICE([Flex version $V is too old, ignored.])
-    FLEX=
-  else
-    AC_MSG_NOTICE([Using Flex version $V.])
+AC_ARG_ENABLE([flex], [AS_HELP_STRING([--disable-flex],
+            [don't apply flex (use pre-generated sources)])], [])
+if test "x$enable_flex" = xno ; then
+  FLEX=
+  AC_MSG_WARN([Generation of flex sources disabled by request, using
+           pre-generated sources.])
+
+else
+  AC_CHECK_PROG([FLEX], [flex], [flex], [], [], [])
+  if test "x$FLEX" = xflex ; then
+    # Version 2.6.0 or later is required.
+    V=`flex --version | awk '{print $2}'`
+    W=`echo $V | awk -F. '{if ((($1*100 + $2)*100 + $3) < 20600) print "no"}'`
+    if test "x$W" != x ; then
+      AC_MSG_WARN([Flex version $V is too old, ignored.])
+      FLEX=
+    else
+      AC_MSG_NOTICE([Using Flex version $V.])
+    fi
   fi
-fi
 
-if test "x$FLEX" = x ; then
-  AC_MSG_WARN([Flex version 2.5.9 or later does not appear to be
+  if test "x$FLEX" = x ; then
+    AC_MSG_WARN([Flex version 2.6.0 or later does not appear to be
            available, will use pre-generated sources.])
+  fi
 fi
 
 
@@ -176,7 +185,7 @@ fi
 if test "x$F77" = xno ; then
   F77=
 
-  AC_MSG_WARN([Compilation of Fortran wrappers and PGSBOX disabled])
+  AC_MSG_WARN([Compilation of Fortran wrappers and PGSBOX disabled.])
 
 else
   if test "x$F77" = x ; then
@@ -280,7 +289,7 @@ SHRLN=
 
 if test "x$ac_cv_c_compiler_gnu" = xyes ; then
   if test "x$enable_shared" = xno ; then
-    AC_MSG_WARN([Generation of WCS shared libraries disabled])
+    AC_MSG_WARN([Generation of WCS shared libraries disabled.])
 
   else
     SHVER=`echo "$LIBVER" | sed -e 's/\..*$//'`
@@ -353,7 +362,7 @@ LIBDIRS=
 AC_ARG_WITH([cfitsio], [AS_HELP_STRING([--without-cfitsio],
             [eschew CFITSIO])], [])
 if test "x$with_cfitsio" = xno ; then
-  AC_MSG_WARN([CFITSIO disabled])
+  AC_MSG_WARN([CFITSIO disabled.])
 else
   AC_ARG_WITH([cfitsiolib], [AS_HELP_STRING([--with-cfitsiolib=DIR],
               [directory containing cfitsio library])], [])
@@ -379,7 +388,7 @@ fi
 AC_ARG_WITH([pgplot], [AS_HELP_STRING([--without-pgplot],
             [eschew PGPLOT])], [])
 if test "x$with_pgplot" = xno ; then
-  AC_MSG_WARN([PGPLOT disabled])
+  AC_MSG_WARN([PGPLOT disabled.])
 else
   AC_ARG_WITH([pgplotlib], [AS_HELP_STRING([--with-pgplotlib=DIR],
               [directory containing pgplot library])], [])
@@ -538,12 +547,23 @@ fi
 AC_ARG_ENABLE([utils], [AS_HELP_STRING([--disable-utils],
             [don't build the WCS utilities])], [])
 if test "x$enable_utils" = xno ; then
-  AC_MSG_WARN([Compilation of WCS utilities disabled])
+  AC_MSG_WARN([Compilation of WCS utilities disabled.])
 else
   SUBDIRS="$SUBDIRS utils"
   INSTDIR="$INSTDIR utils"
 fi
 
+# Default observer coordinates for sundazel.
+if test -f "$HOME/.sundazelrc"; then
+  . "$HOME/.sundazelrc"
+fi
+
+if test "x$OBSLNG" = x; then
+  OBSLNG=0.0
+  OBSLAT=0.0
+  OBSTZ=0.0
+fi
+
 
 AC_SUBST([CFITSIOINC])
 AC_SUBST([CFITSIOLIB])
@@ -556,6 +576,10 @@ AC_SUBST([SUBDIRS])
 AC_SUBST([TSTDIRS])
 AC_SUBST([INSTDIR])
 
+AC_SUBST([OBSLNG])
+AC_SUBST([OBSLAT])
+AC_SUBST([OBSTZ])
+
 AC_MSG_NOTICE([End of auxiliary configuration.
 ])
 
Index: astropy-4.2.1/cextern/wcslib/flavours
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/flavours
+++ astropy-4.2.1/cextern/wcslib/flavours
@@ -12,7 +12,7 @@
 #
 # Reminder: add '-d' to FLFLAGS for debugging.
 #
-# $Id: flavours,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+# $Id: flavours,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
 #-----------------------------------------------------------------------------
 
 # The list of FLAVOURs can be set on the command line.
Index: astropy-4.2.1/cextern/wcslib/makedefs.in
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/makedefs.in
+++ astropy-4.2.1/cextern/wcslib/makedefs.in
@@ -1,5 +1,5 @@
 #-----------------------------------------------------------------------------
-# GNU makefile definitions for building WCSLIB 7.3
+# GNU makefile definitions for building WCSLIB 7.6
 #
 # makedefs is generated from makedefs.in by configure.  It contains variable
 # definitions and some general-purpose rules for building WCSLIB.
@@ -39,11 +39,11 @@
 #      compiled separately without this option.
 #
 #      The shared library will be installed with version number, e.g. as
-#      libwcs.so.7.3 or libwcs.7.3.dylib with or without the symlink
+#      libwcs.so.7.6 or libwcs.7.6.dylib with or without the symlink
 #      required to make it visible to the linker (controlled by the SHRLN
 #      variable).  On Macs it is deliberately not created because its very
 #      existence precludes static linking with the cctools linker.  You can
-#      still link dynamically by using -lwcs.7.3.
+#      still link dynamically by using -lwcs.7.6.
 #
 #   4) PGPLOT is Tim Pearson's Fortran graphics library with separate C
 #      interface available from astro.caltech.edu.  It is only required by
@@ -74,7 +74,7 @@
 #
 # Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 # http://www.atnf.csiro.au/people/Mark.Calabretta
-# $Id: makedefs.in,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+# $Id: makedefs.in,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
 #-----------------------------------------------------------------------------
 # Version.
   LIBVER    := @LIBVER@
@@ -168,6 +168,12 @@
 # Libraries required by WCSLIB itself.
   LIBS := @LIBS@
 
+# Default observer coordinates for sundazel.  May be set as environment
+# variables, either generally or in $HOME/.sundazelrc, which is read by
+# configure.
+  OBSLNG := @OBSLNG@
+  OBSLAT := @OBSLAT@
+  OBSTZ  := @OBSTZ@
 
 #-----------------------------------------------------------------------------
 # You shouldn't need to change anything below here.
@@ -245,6 +251,11 @@ show :: wcsconfig.h
 	-@ echo '  FLIBS       := $(FLIBS)'
 	-@ echo '  LIBS        := $(LIBS)'
 	-@ echo ''
+	-@ echo 'Default observer coordinates for sundazel...'
+	-@ echo '  OBSLNG      := $(OBSLNG)'
+	-@ echo '  OBSLAT      := $(OBSLAT)'
+	-@ echo '  OBSTZ       := $(OBSTZ)'
+	-@ echo ''
 
 # Code development overrides, for use in the code subdirectories.
 FLAVOUR := @FLAVOUR@
Index: astropy-4.2.1/cextern/wcslib/wcsconfig.h.in
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/wcsconfig.h.in
+++ astropy-4.2.1/cextern/wcslib/wcsconfig.h.in
@@ -1,11 +1,11 @@
 /*============================================================================
 *
 * wcsconfig.h is generated from wcsconfig.h.in by 'configure'.  It contains
-* C preprocessor macro definitions for compiling WCSLIB 7.3
+* C preprocessor macro definitions for compiling WCSLIB 7.6
 *
 * Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 * http://www.atnf.csiro.au/people/Mark.Calabretta
-* $Id: wcsconfig.h.in,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+* $Id: wcsconfig.h.in,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
 *===========================================================================*/
 
 /* wcslib_version() is available (as of 5.0). */
Index: astropy-4.2.1/cextern/wcslib/wcsconfig_f77.h.in
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/wcsconfig_f77.h.in
+++ astropy-4.2.1/cextern/wcslib/wcsconfig_f77.h.in
@@ -1,12 +1,12 @@
 /*============================================================================
 *
 * wcsconfig_f77.h is generated from wcsconfig_f77.h.in by 'configure'.  It
-* contains C preprocessor definitions for building the WCSLIB 7.3 Fortran
+* contains C preprocessor definitions for building the WCSLIB 7.6 Fortran
 * wrappers.
 *
 * Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 * http://www.atnf.csiro.au/people/Mark.Calabretta
-* $Id: wcsconfig_f77.h.in,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+* $Id: wcsconfig_f77.h.in,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
 *===========================================================================*/
 
 /* Integer array type large enough to hold an address.  Set here to int[2] for
Index: astropy-4.2.1/cextern/wcslib/wcsconfig_tests.h.in
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/wcsconfig_tests.h.in
+++ astropy-4.2.1/cextern/wcslib/wcsconfig_tests.h.in
@@ -1,12 +1,12 @@
 /*============================================================================
 *
 * wcsconfig_test.h is generated from wcsconfig_test.h.in by 'configure'.  It
-* contains C preprocessor definitions for compiling the WCSLIB 7.3 test/demo
+* contains C preprocessor definitions for compiling the WCSLIB 7.6 test/demo
 * programs.
 *
 * Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 * http://www.atnf.csiro.au/people/Mark.Calabretta
-* $Id: wcsconfig_tests.h.in,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+* $Id: wcsconfig_tests.h.in,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
 *===========================================================================*/
 
 #include <wcsconfig.h>
Index: astropy-4.2.1/cextern/wcslib/wcsconfig_utils.h.in
===================================================================
--- astropy-4.2.1.orig/cextern/wcslib/wcsconfig_utils.h.in
+++ astropy-4.2.1/cextern/wcslib/wcsconfig_utils.h.in
@@ -1,12 +1,12 @@
 /*============================================================================
 *
 * wcsconfig_utils.h is generated from wcsconfig_utils.h.in by 'configure'.
-* It contains C preprocessor macro definitions for compiling the WCSLIB 7.3
+* It contains C preprocessor macro definitions for compiling the WCSLIB 7.6
 * utilities.
 *
 * Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 * http://www.atnf.csiro.au/people/Mark.Calabretta
-* $Id: wcsconfig_utils.h.in,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+* $Id: wcsconfig_utils.h.in,v 7.6 2021/04/13 12:57:02 mcalabre Exp $
 *===========================================================================*/
 
 #include <wcsconfig.h>
Index: astropy-4.2.1/CHANGES.rst
===================================================================
--- astropy-4.2.1.orig/CHANGES.rst
+++ astropy-4.2.1/CHANGES.rst
@@ -399,6 +399,10 @@ Other Changes and Additions
 - When importing astropy without first building the extension modules first,
   raise an error directly instead of trying to auto-build. [#10883]
 
+- Updated bundled version of ``WCSLIB`` to v7.4, fixing a bug that caused
+  the coefficients of the TPD distortion function to not be written to the
+  header. [#11260]
+
 
 
 4.1 (2020-10-21)
Index: astropy-4.2.1/astropy/wcs/tests/data/validate.7.4.txt
===================================================================
--- /dev/null
+++ astropy-4.2.1/astropy/wcs/tests/data/validate.7.4.txt
@@ -0,0 +1,20 @@
+HDU 1:
+  WCS key ' ':
+    - RADECSYS= 'ICRS ' / Astrometric system
+      the RADECSYS keyword is deprecated, use RADESYSa.
+    - The WCS transformation has more axes (2) than the image it is
+      associated with (0)
+    - Removed redundant SCAMP distortion parameters because SIP
+      parameters are also present
+    - 'datfix' made the change 'Set MJD-OBS to 55007.362083 from DATE-
+      OBS'.
+
+HDU 2:
+  WCS key ' ':
+    - The WCS transformation has more axes (3) than the image it is
+      associated with (0)
+    - 'datfix' made the change 'Success'.
+    - 'unitfix' made the change 'Changed units:
+        'HZ' -> 'Hz'.
+    - 'celfix' made the change 'In CUNIT3 : Mismatched units type
+      'length': have 'Hz', want 'm''.
Index: astropy-4.2.1/astropy/wcs/tests/test_wcs.py
===================================================================
--- astropy-4.2.1.orig/astropy/wcs/tests/test_wcs.py
+++ astropy-4.2.1/astropy/wcs/tests/test_wcs.py
@@ -22,6 +22,7 @@ from astropy.utils.exceptions import (
 from astropy.tests.helper import assert_quantity_allclose
 from astropy.io import fits
 from astropy.coordinates import SkyCoord
+from astropy.nddata import Cutout2D
 
 
 _WCSLIB_VER = Version(_wcs.__version__)
@@ -104,7 +105,16 @@ class TestSpectra:
             header = get_pkg_data_contents(
                 os.path.join("data", "spectra", filename), encoding='binary')
             # finally run the test.
-            all_wcs = wcs.find_all_wcs(header)
+            with pytest.warns(None) as w:
+                all_wcs = wcs.find_all_wcs(header)
+
+            if _WCSLIB_VER >= Version('7.4'):
+                assert len(w) == 9
+                m = str(w.pop().message)
+                assert "'datfix' made the change 'Set MJD-OBS to 53925.853472 from DATE-OBS'." in m
+            else:
+                assert len(w) == 0
+
             assert len(all_wcs) == 9
 
 
@@ -117,11 +127,15 @@ def test_fixes():
     with pytest.raises(wcs.InvalidTransformError), pytest.warns(wcs.FITSFixedWarning) as w:
         wcs.WCS(header, translate_units='dhs')
 
-    assert len(w) == 2
+    if Version('7.4') <=_WCSLIB_VER < Version('7.6'):
+        assert len(w) == 3
+        assert "'datfix' made the change 'Success'." in str(w.pop().message)
+    else:
+        assert len(w) == 2
 
     first_wmsg = str(w[0].message)
     assert 'unitfix' in first_wmsg and 'Hz' in first_wmsg and 'M/S' in first_wmsg
-    assert 'm/s' in str(w[1].message)
+    assert 'plane angle' in str(w[1].message) and 'm/s' in str(w[1].message)
 
 
 # Ignore "PV2_2 = 0.209028857410973 invalid keyvalue" warning seen on Windows.
@@ -145,6 +159,7 @@ def test_pix2world():
     """
     # TODO: write this to test the expected output behavior of pix2world,
     # currently this just makes sure it doesn't error out in unexpected ways
+    # (and compares `wcs.pc` and `result` values?)
     filename = get_pkg_data_filename('data/sip2.fits')
     with pytest.warns(wcs.FITSFixedWarning) as caught_warnings:
         # this raises a warning unimportant for this testing the pix2world
@@ -153,7 +168,10 @@ def test_pix2world():
         ww = wcs.WCS(filename)
 
     # might as well monitor for changing behavior
-    assert len(caught_warnings) == 1
+    if Version('7.4') <=_WCSLIB_VER < Version('7.6'):
+        assert len(caught_warnings) == 2
+    else:
+        assert len(caught_warnings) == 1
 
     n = 3
     pixels = (np.arange(n) * np.ones((2, n))).T
@@ -162,18 +180,17 @@ def test_pix2world():
     # Catch #2791
     ww.wcs_pix2world(pixels[..., 0], pixels[..., 1], 0, ra_dec_order=True)
 
-    close_enough = 1e-8
     # assuming that the data of sip2.fits doesn't change
     answer = np.array([[0.00024976, 0.00023018],
                        [0.00023043, -0.00024997]])
 
-    assert np.all(np.abs(ww.wcs.pc - answer) < close_enough)
+    assert np.allclose(ww.wcs.pc, answer, atol=1.e-8)
 
     answer = np.array([[202.39265216, 47.17756518],
                        [202.39335826, 47.17754619],
                        [202.39406436, 47.1775272]])
 
-    assert np.all(np.abs(result - answer) < close_enough)
+    assert np.allclose(result, answer, atol=1.e-8, rtol=1.e-10)
 
 
 def test_load_fits_path():
@@ -213,7 +230,15 @@ def test_dict_init():
     if _WCSLIB_VER >= Version('7.1'):
         hdr['DATEREF'] = '1858-11-17'
 
-    w = wcs.WCS(hdr)
+    with pytest.warns(None) as wrng:
+        w = wcs.WCS(hdr)
+
+    if _WCSLIB_VER >= Version('7.4'):
+        assert len(wrng) == 1
+        msg = str(wrng[0].message)
+        assert "'datfix' made the change 'Set MJDREF to 0.000000 from DATEREF'." in msg
+    else:
+        assert len(wrng) == 0
 
     xp, yp = w.wcs_world2pix(41., 2., 0)
 
@@ -319,13 +344,19 @@ def test_invalid_shape():
 
 def test_warning_about_defunct_keywords():
     header = get_pkg_data_contents('data/defunct_keywords.hdr', encoding='binary')
+    if Version('7.4') <=_WCSLIB_VER < Version('7.6'):
+        n_warn = 5
+    else:
+        n_warn = 4
+
     # Make sure the warnings come out every time...
     for _ in range(2):
         with pytest.warns(wcs.FITSFixedWarning) as w:
             wcs.WCS(header)
 
-        assert len(w) == 4
-        for item in w:
+        assert len(w) == n_warn
+        # 7.4 adds a fifth warning "'datfix' made the change 'Success'."
+        for item in w[:4]:
             assert 'PCi_ja' in str(item.message)
 
 
@@ -431,14 +462,16 @@ def test_find_all_wcs_crash():
 def test_validate():
     results = wcs.validate(get_pkg_data_filename("data/validate.fits"))
     results_txt = sorted(set([x.strip() for x in repr(results).splitlines()]))
-    version = wcs._wcs.__version__
-    if version[0] in ['6', '7']:
+    if _WCSLIB_VER >= Version('7.6'):
+        filename = 'data/validate.7.6.txt'
+    elif _WCSLIB_VER >= Version('7.4'):
+        filename = 'data/validate.7.4.txt'
+    elif _WCSLIB_VER >= Version('6.0'):
         filename = 'data/validate.6.txt'
-    elif version[0] == '5':
-        if version >= '5.13':
-            filename = 'data/validate.5.13.txt'
-        else:
-            filename = 'data/validate.5.0.txt'
+    elif _WCSLIB_VER >= Version('5.13'):
+        filename = 'data/validate.5.13.txt'
+    elif _WCSLIB_VER >= Version('5.0'):
+        filename = 'data/validate.5.0.txt'
     else:
         filename = 'data/validate.txt'
     with open(get_pkg_data_filename(filename), "r") as fd:
@@ -1457,3 +1490,47 @@ def test_no_pixel_area():
 
     # Pixel scales still possible
     assert_quantity_allclose(w.proj_plane_pixel_scales(), 1)
+
+
+def test_distortion_header(tmpdir):
+    """
+    Test that plate distortion model is correctly described by `wcs.to_header()`
+    and preserved when creating a Cutout2D from the image, writing it to FITS,
+    and reading it back from the file.
+    """
+    path = get_pkg_data_filename("data/dss.14.29.56-62.41.05.fits.gz")
+    cen = np.array((50, 50))
+    siz = np.array((20, 20))
+
+    with fits.open(path) as hdulist:
+        with pytest.warns(wcs.FITSFixedWarning):
+            w = wcs.WCS(hdulist[0].header)
+        cut = Cutout2D(hdulist[0].data, position=cen, size=siz, wcs=w)
+
+    # This converts the DSS plate solution model with AMD[XY]n coefficients into a
+    # Template Polynomial Distortion model (TPD.FWD.n coefficients);
+    # not testing explicitly for the header keywords here.
+
+    if _WCSLIB_VER < Version("7.4"):
+        with pytest.warns(AstropyWarning, match="WCS contains a TPD distortion model in CQDIS"):
+            w0 = wcs.WCS(w.to_header_string())
+        with pytest.warns(AstropyWarning, match="WCS contains a TPD distortion model in CQDIS"):
+            w1 = wcs.WCS(cut.wcs.to_header_string())
+        if _WCSLIB_VER >= Version("7.1"):
+            pytest.xfail("TPD coefficients incomplete with WCSLIB >= 7.1 < 7.4")
+    else:
+        w0 = wcs.WCS(w.to_header_string())
+        w1 = wcs.WCS(cut.wcs.to_header_string())
+
+    assert w.pixel_to_world(0, 0).separation(w0.pixel_to_world(0, 0)) < 1.e-3 * u.mas
+    assert w.pixel_to_world(*cen).separation(w0.pixel_to_world(*cen)) < 1.e-3 * u.mas
+
+    assert w.pixel_to_world(*cen).separation(w1.pixel_to_world(*(siz / 2))) < 1.e-3 * u.mas
+
+    cutfile = str(tmpdir.join('cutout.fits'))
+    fits.writeto(cutfile, cut.data, cut.wcs.to_header())
+
+    with fits.open(cutfile) as hdulist:
+        w2 = wcs.WCS(hdulist[0].header)
+
+    assert w.pixel_to_world(*cen).separation(w2.pixel_to_world(*(siz / 2))) < 1.e-3 * u.mas
Index: astropy-4.2.1/astropy/wcs/tests/test_wcsprm.py
===================================================================
--- astropy-4.2.1.orig/astropy/wcs/tests/test_wcsprm.py
+++ astropy-4.2.1/astropy/wcs/tests/test_wcsprm.py
@@ -409,11 +409,17 @@ def test_fix():
         'unitfix': 'No change',
         'celfix': 'No change',
         'obsfix': 'No change'}
+
     version = wcs._wcs.__version__
     if Version(version) <= Version('5'):
         del fix_ref['obsfix']
+
     if Version(version) >= Version('7.1'):
         w.dateref = '1858-11-17'
+
+    if Version('7.4') <= Version(version) < Version('7.6'):
+        fix_ref['datfix'] = 'Success'
+
     assert w.fix() == fix_ref
 
 
Index: astropy-4.2.1/setup.cfg
===================================================================
--- astropy-4.2.1.orig/setup.cfg
+++ astropy-4.2.1/setup.cfg
@@ -135,6 +135,7 @@ filterwarnings =
 	ignore:the imp module is deprecated:DeprecationWarning
 	ignore:The toolz.compatibility module is no longer needed:DeprecationWarning
 	ignore:parallel reading does not currently work, so falling back to serial
+        ignore:'datfix' made the change:astropy.wcs.wcs.FITSFixedWarning
 doctest_norecursedirs = 
 	*/setup_package.py
 doctest_subpackage_requires = 
Index: astropy-4.2.1/astropy/wcs/wcs.py
===================================================================
--- astropy-4.2.1.orig/astropy/wcs/wcs.py
+++ astropy-4.2.1/astropy/wcs/wcs.py
@@ -2671,6 +2671,22 @@ reduce these to 2 dimensions using the n
             for kw in keys_to_remove:
                 if kw in header:
                     del header[kw]
+            # Check if we can handle TPD distortion correctly
+            if int(_parsed_version[0]) * 10 + int(_parsed_version[1]) < 71:
+                for kw, val in header.items():
+                    if kw[:5] in ('CPDIS', 'CQDIS') and val == 'TPD':
+                        warnings.warn(
+                            f"WCS contains a TPD distortion model in {kw}. WCSLIB "
+                            f"{_wcs.__version__} is writing this in a format incompatible with "
+                            f"current versions - please update to 7.4 or use the bundled WCSLIB.",
+                            AstropyWarning)
+            elif int(_parsed_version[0]) * 10 + int(_parsed_version[1]) < 74:
+                for kw, val in header.items():
+                    if kw[:5] in ('CPDIS', 'CQDIS') and val == 'TPD':
+                        warnings.warn(
+                            f"WCS contains a TPD distortion model in {kw}, which requires WCSLIB "
+                            f"7.4 or later to store in a FITS header (having {_wcs.__version__}).",
+                            AstropyWarning)
         else:
             header = fits.Header()
 
Index: astropy-4.2.1/docs/changes/wcs/11549.feature.rst
===================================================================
--- /dev/null
+++ astropy-4.2.1/docs/changes/wcs/11549.feature.rst
@@ -0,0 +1,3 @@
+Updated bundled version of WCSLIB to version 7.6. See
+https://www.atnf.csiro.au/people/mcalabre/WCS/CHANGES for a list of
+included changes.
Index: astropy-4.2.1/astropy/wcs/tests/data/validate.7.6.txt
===================================================================
--- /dev/null
+++ astropy-4.2.1/astropy/wcs/tests/data/validate.7.6.txt
@@ -0,0 +1,19 @@
+HDU 1:
+  WCS key ' ':
+    - RADECSYS= 'ICRS ' / Astrometric system
+      the RADECSYS keyword is deprecated, use RADESYSa.
+    - The WCS transformation has more axes (2) than the image it is
+      associated with (0)
+    - Removed redundant SCAMP distortion parameters because SIP
+      parameters are also present
+    - 'datfix' made the change 'Set MJD-OBS to 55007.362083 from DATE-
+      OBS'.
+
+HDU 2:
+  WCS key ' ':
+    - The WCS transformation has more axes (3) than the image it is
+      associated with (0)
+    - 'unitfix' made the change 'Changed units:
+        'HZ' -> 'Hz'.
+    - 'celfix' made the change 'In CUNIT3 : Mismatched units type
+      'length': have 'Hz', want 'm''.
\ No newline at end of file
Index: astropy-4.2.1/astropy/wcs/tests/test_tab.py
===================================================================
--- astropy-4.2.1.orig/astropy/wcs/tests/test_tab.py
+++ astropy-4.2.1/astropy/wcs/tests/test_tab.py
@@ -1,14 +1,20 @@
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 
-import pytest
-
 import numpy as np
 
+import pytest
+from packaging.version import Version
 from astropy import wcs
+from astropy.wcs import _wcs  # noqa
+from astropy.io import fits
+from astropy.utils.data import get_pkg_data_filename
 
 from . helper import SimModelTAB
 
 
+_WCSLIB_VER = Version(_wcs.__version__)
+
+
 def test_2d_spatial_tab_roundtrip(tab_wcs_2di):
     nx, ny = tab_wcs_2di.pixel_shape
     # generate "random" test coordinates:
@@ -37,3 +43,19 @@ def test_2d_spatial_tab_vs_model():
     rd = w.wcs_pix2world(xy, 1)
     rd_model = model.fwd_eval(xy)
     assert np.allclose(rd, rd_model, rtol=0, atol=1e-7)
+
+
+@pytest.mark.skipif(
+    _WCSLIB_VER < Version('7.6'),
+    reason="Only in WCSLIB 7.6 a 1D -TAB axis roundtrips unless first axis"
+)
+def test_mixed_celest_and_1d_tab_roundtrip():
+    # Tests WCS roundtripping for the case when there is one -TAB axis and
+    # this axis is not the first axis. This tests a bug fixed in WCSLIB 7.6.
+    filename = get_pkg_data_filename('data/tab-time-last-axis.fits')
+    hdul = fits.open(filename)
+    w = wcs.WCS(hdul[0].header, hdul)
+    hdul.close()
+
+    pts = np.random.random((10, 3)) * [[2047, 2047, 127]]
+    assert np.allclose(pts, w.wcs_world2pix(w.wcs_pix2world(pts, 0), 0))
Index: astropy-4.2.1/astropy/wcs/tests/test_utils.py
===================================================================
--- astropy-4.2.1.orig/astropy/wcs/tests/test_utils.py
+++ astropy-4.2.1/astropy/wcs/tests/test_utils.py
@@ -5,6 +5,7 @@ import pytest
 from io import StringIO
 from itertools import product
 
+from packaging.version import Version
 import numpy as np
 from numpy.testing import assert_almost_equal, assert_equal, assert_allclose
 
@@ -17,6 +18,7 @@ from astropy.coordinates import SkyCoord
 from astropy.units import Quantity
 from astropy.io import fits
 
+from astropy.wcs import _wcs  # noqa
 from astropy.wcs.wcs import (WCS, Sip, WCSSUB_LONGITUDE, WCSSUB_LATITUDE,
                              FITSFixedWarning)
 from astropy.wcs.wcsapi.fitswcs import SlicedFITSWCS
@@ -1267,16 +1269,25 @@ def test_issue10991():
 @pytest.mark.parametrize('x_in,y_in', [[0, 0], [np.arange(5), np.arange(5)]])
 def test_pixel_to_world_itrs(x_in, y_in):
     """Regression test for https://github.com/astropy/astropy/pull/9609"""
-    wcs = WCS({'NAXIS': 2,
-               'CTYPE1': 'TLON-CAR',
-               'CTYPE2': 'TLAT-CAR',
-               'RADESYS': 'ITRS ',
-               'DATE-OBS': '2017-08-17T12:41:04.444'})
+    with pytest.warns(None) as w:
+        wcs = WCS({'NAXIS': 2,
+                   'CTYPE1': 'TLON-CAR',
+                   'CTYPE2': 'TLAT-CAR',
+                   'RADESYS': 'ITRS ',
+                   'DATE-OBS': '2017-08-17T12:41:04.444'})
+
+    if Version(_wcs.__version__) >= Version('7.4'):
+        assert len(w) == 1
+        msg = str(w[0].message)
+        assert "'datfix' made the change 'Set MJD-OBS to 57982.528524 from DATE-OBS'." in msg
+    else:
+        assert len(w) == 0
 
     # This shouldn't raise an exception.
     coord = wcs.pixel_to_world(x_in, y_in)
 
     # Check round trip transformation.
     x, y = wcs.world_to_pixel(coord)
+
     np.testing.assert_almost_equal(x, x_in)
     np.testing.assert_almost_equal(y, y_in)
