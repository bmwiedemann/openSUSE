From 6c485869cbee373282c8081d110bbf1ea25b3982 Mon Sep 17 00:00:00 2001
From: Derek Homeier <dhomeie@gwdg.de>
Date: Mon, 1 Feb 2021 00:00:32 +0100
Subject: [PATCH 1/3] Updated bundled WCSLIB to 7.4 with wcshdo() fix

WCSLIB version 7.4 was released on 2021/01/31 by Mark Calabretta.

It contains a number of important bug fixes, particularly for wcshdo(),
and enhancements, as per the change log appended below.

-------------------------------

* C library

 - In wcshdo(), fixed a bug introduced in release 5.9 that potentially
   caused loss of numerical precision in the sprintf() formatting of
   floating point keyvalues.  This was triggered when a large range of
   CRPIXja, PCi_ja, or CDELTia values (as three separate groups) were
   formatted using an 'f' format descriptor, the range not being so
   large that it would have forced wcshdo() to revert to 'E' format.
   Reported by Mohammad Akhlaghi.

   Also in wcshdo(), fixed a bug introduced in release 7.1 that caused
   the coefficients of the TPD distortion function not to be written to
   the header.  TPD and Polynomial distortion function headers will now
   always include the DPja.DOCORR keyword.  Reported by Derek Homeier
   with patch.

 - In wcsset(), fixed a segv generated in attempting to report a non-
   standard units string with wcserr message reporting disabled.
   Reported by Mohammad Akhlaghi.

   In wcsutrne(), allow 'Angstroms' and 'angstroms' as additional
   synonyms for 'Angstrom'.

 - In datfix(), ensure that 0 is returned if an informational message
   is set in wcsprm::err.  Consequent on feedback independently from
   Mihai Cara and Bruce Merry.

   Clarified that informational messages may be set in wcsprm::err
   for returns of 0 from datfix(), obsfix(), unitfix(), and spcfix().

* User manual

 - Added cautions about translating CDi_ja to PCi_ja plus CDELTia for
   those historical distortion functions (TPV, TNX, ZPX) that expect to
   operate on intermediate world coordinates, rather than intermediate
   pixel coordinates.  Consequent on feedback from Mohammad Akhlaghi.

 - Documentation generation moved to doxygen 1.9.1 (was 1.8.19).
---
 astropy/wcs/setup_package.py        |    2 +-
 cextern/wcslib/C/GNUmakefile        |    4 +-
 cextern/wcslib/C/cel.c              |   93 +-
 cextern/wcslib/C/cel.h              |   89 +-
 cextern/wcslib/C/dis.c              |  778 ++++++++---------
 cextern/wcslib/C/dis.h              |  138 +--
 cextern/wcslib/C/fitshdr.h          |   67 +-
 cextern/wcslib/C/fitshdr.l          |  103 ++-
 cextern/wcslib/C/flexed/README      |    2 +-
 cextern/wcslib/C/flexed/fitshdr.c   |  183 ++--
 cextern/wcslib/C/flexed/wcsbth.c    | 1223 +++++++++++++--------------
 cextern/wcslib/C/flexed/wcspih.c    |  929 ++++++++++----------
 cextern/wcslib/C/flexed/wcsulex.c   |  433 +++++-----
 cextern/wcslib/C/flexed/wcsutrn.c   | 1012 ++++++++++++----------
 cextern/wcslib/C/getwcstab.c        |   37 +-
 cextern/wcslib/C/getwcstab.h        |  107 ++-
 cextern/wcslib/C/lin.c              |  227 +++--
 cextern/wcslib/C/lin.h              |   83 +-
 cextern/wcslib/C/log.c              |   15 +-
 cextern/wcslib/C/log.h              |   27 +-
 cextern/wcslib/C/prj.c              |  751 ++++++++--------
 cextern/wcslib/C/prj.h              |  105 ++-
 cextern/wcslib/C/spc.c              |  271 +++---
 cextern/wcslib/C/spc.h              |  121 ++-
 cextern/wcslib/C/sph.c              |   85 +-
 cextern/wcslib/C/sph.h              |   93 +-
 cextern/wcslib/C/spx.c              |   83 +-
 cextern/wcslib/C/spx.h              |  109 ++-
 cextern/wcslib/C/tab.c              |  325 ++++---
 cextern/wcslib/C/tab.h              |  111 ++-
 cextern/wcslib/C/wcs.c              |  714 ++++++++--------
 cextern/wcslib/C/wcs.h              |  362 ++++----
 cextern/wcslib/C/wcsbth.l           |  349 ++++----
 cextern/wcslib/C/wcserr.c           |   25 +-
 cextern/wcslib/C/wcserr.h           |   29 +-
 cextern/wcslib/C/wcsfix.c           |  281 +++---
 cextern/wcslib/C/wcsfix.h           |  118 +--
 cextern/wcslib/C/wcshdr.c           |  482 +++++------
 cextern/wcslib/C/wcshdr.h           |  154 ++--
 cextern/wcslib/C/wcslib.h           |   13 +-
 cextern/wcslib/C/wcsmath.h          |   13 +-
 cextern/wcslib/C/wcspih.l           |  337 ++++----
 cextern/wcslib/C/wcsprintf.c        |   43 +-
 cextern/wcslib/C/wcsprintf.h        |   13 +-
 cextern/wcslib/C/wcstrig.c          |   23 +-
 cextern/wcslib/C/wcstrig.h          |   21 +-
 cextern/wcslib/C/wcsulex.l          |  175 ++--
 cextern/wcslib/C/wcsunits.c         |   41 +-
 cextern/wcslib/C/wcsunits.h         |  117 ++-
 cextern/wcslib/C/wcsutil.c          |   87 +-
 cextern/wcslib/C/wcsutil.h          |   13 +-
 cextern/wcslib/C/wcsutrn.l          |   41 +-
 cextern/wcslib/C/wtbarr.h           |   45 +-
 cextern/wcslib/CHANGES              |   65 +-
 cextern/wcslib/GNUmakefile          |    4 +-
 cextern/wcslib/INSTALL              |   12 +-
 cextern/wcslib/README               |   10 +-
 cextern/wcslib/THANKS               |   12 +-
 cextern/wcslib/VALIDATION           |   22 +-
 cextern/wcslib/configure            |   24 +-
 cextern/wcslib/configure.ac         |    6 +-
 cextern/wcslib/flavours             |    2 +-
 cextern/wcslib/makedefs.in          |    8 +-
 cextern/wcslib/wcsconfig.h.in       |    4 +-
 cextern/wcslib/wcsconfig_f77.h.in   |    4 +-
 cextern/wcslib/wcsconfig_tests.h.in |    4 +-
 cextern/wcslib/wcsconfig_utils.h.in |    4 +-
 67 files changed, 5703 insertions(+), 5580 deletions(-)

Index: astropy-4.2/astropy/wcs/setup_package.py
===================================================================
--- astropy-4.2.orig/astropy/wcs/setup_package.py
+++ astropy-4.2/astropy/wcs/setup_package.py
@@ -16,7 +16,7 @@ import numpy
 from extension_helpers import import_file, write_if_different, get_compiler, pkg_config
 
 WCSROOT = os.path.relpath(os.path.dirname(__file__))
-WCSVERSION = "7.3.0"
+WCSVERSION = "7.4"
 
 
 def b(s):
Index: astropy-4.2/cextern/wcslib/C/GNUmakefile
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/GNUmakefile
+++ astropy-4.2/cextern/wcslib/C/GNUmakefile
@@ -1,5 +1,5 @@
 #-----------------------------------------------------------------------------
-# GNU makefile for building WCSLIB 7.3 and its test suite.
+# GNU makefile for building WCSLIB 7.4 and its test suite.
 #
 # Summary of the main targets
 # ---------------------------
@@ -31,7 +31,7 @@
 #
 # Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 # http://www.atnf.csiro.au/people/Mark.Calabretta
-# $Id: GNUmakefile,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+# $Id: GNUmakefile,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 #-----------------------------------------------------------------------------
 # Get configure settings.
 SUBDIR := C
Index: astropy-4.2/cextern/wcslib/C/cel.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/cel.c
+++ astropy-4.2/cextern/wcslib/C/cel.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: cel.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: cel.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -38,7 +35,7 @@
 
 const int CELSET = 137;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *cel_errmsg[] = {
   "Success",
   "Null celprm pointer passed",
@@ -48,19 +45,19 @@ const char *cel_errmsg[] = {
   "One or more of the (x,y) coordinates were invalid",
   "One or more of the (lng,lat) coordinates were invalid"};
 
-/* Map error returns for lower-level routines. */
+// Map error returns for lower-level routines.
 const int cel_prjerr[] = {
-  CELERR_SUCCESS,		/*  0: PRJERR_SUCCESS         */
-  CELERR_NULL_POINTER,		/*  1: PRJERR_NULL_POINTER    */
-  CELERR_BAD_PARAM,		/*  2: PRJERR_BAD_PARAM       */
-  CELERR_BAD_PIX,		/*  3: PRJERR_BAD_PIX         */
-  CELERR_BAD_WORLD		/*  4: PRJERR_BAD_WORLD       */
+  CELERR_SUCCESS,		//  0: PRJERR_SUCCESS
+  CELERR_NULL_POINTER,		//  1: PRJERR_NULL_POINTER
+  CELERR_BAD_PARAM,		//  2: PRJERR_BAD_PARAM
+  CELERR_BAD_PIX,		//  3: PRJERR_BAD_PIX
+  CELERR_BAD_WORLD		//  4: PRJERR_BAD_WORLD
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define CEL_ERRMSG(status) WCSERR_SET(status), cel_errmsg[status]
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celini(struct celprm *cel)
 
@@ -87,7 +84,7 @@ int celini(struct celprm *cel)
   return cel_prjerr[prjini(&(cel->prj))];
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celfree(struct celprm *cel)
 
@@ -99,7 +96,7 @@ int celfree(struct celprm *cel)
   return cel_prjerr[prjfree(&(cel->prj))];
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celprt(const struct celprm *cel)
 
@@ -156,7 +153,7 @@ int celprt(const struct celprm *cel)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celperr(const struct celprm *cel, const char *prefix)
 
@@ -171,7 +168,7 @@ int celperr(const struct celprm *cel, co
 }
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celset(struct celprm *cel)
 
@@ -189,13 +186,13 @@ int celset(struct celprm *cel)
   if (cel == 0x0) return CELERR_NULL_POINTER;
   err = &(cel->err);
 
-  /* Initialize the projection driver routines. */
+  // Initialize the projection driver routines.
   celprj = &(cel->prj);
   if (cel->offset) {
     celprj->phi0   = cel->phi0;
     celprj->theta0 = cel->theta0;
   } else {
-    /* Ensure that these are undefined - no fiducial offset. */
+    // Ensure that these are undefined - no fiducial offset.
     celprj->phi0   = UNDEFINED;
     celprj->theta0 = UNDEFINED;
   }
@@ -204,7 +201,7 @@ int celset(struct celprm *cel)
     return wcserr_set(CEL_ERRMSG(cel_prjerr[status]));
   }
 
-  /* Defaults set by the projection routines. */
+  // Defaults set by the projection routines.
   if (undefined(cel->phi0)) {
     cel->phi0 = celprj->phi0;
   }
@@ -231,7 +228,7 @@ int celset(struct celprm *cel)
   phip = cel->ref[2];
   latp = cel->ref[3];
 
-  /* Set default for native longitude of the celestial pole? */
+  // Set default for native longitude of the celestial pole?
   if (undefined(phip) || phip == 999.0) {
     phip = (lat0 < cel->theta0) ? 180.0 : 0.0;
     phip += cel->phi0;
@@ -246,15 +243,15 @@ int celset(struct celprm *cel)
   }
 
 
-  /* Compute celestial coordinates of the native pole. */
+  // Compute celestial coordinates of the native pole.
   cel->latpreq = 0;
   if (cel->theta0 == 90.0) {
-    /* Fiducial point at the native pole. */
+    // Fiducial point at the native pole.
     lngp = lng0;
     latp = lat0;
 
   } else {
-    /* Fiducial point away from the native pole. */
+    // Fiducial point away from the native pole.
     sincosd(lat0, &slat0, &clat0);
     sincosd(cel->theta0, &sthe0, &cthe0);
 
@@ -278,7 +275,7 @@ int celset(struct celprm *cel)
             "lat0 == 0 is required for |phip - phi0| = 90 and theta0 == 0");
         }
 
-        /* latp determined solely by LATPOLEa in this case. */
+        // latp determined solely by LATPOLEa in this case.
         cel->latpreq = 2;
         if (latp > 90.0) {
           latp = 90.0;
@@ -286,7 +283,7 @@ int celset(struct celprm *cel)
           latp = -90.0;
         }
 
-        /* Avert a spurious compiler warning. */
+        // Avert a spurious compiler warning.
 	u = v = 0.0;
 
       } else {
@@ -327,7 +324,7 @@ int celset(struct celprm *cel)
 
       if (fabs(latp1) < 90.0+tol &&
           fabs(latp2) < 90.0+tol) {
-        /* There are two valid solutions for latp. */
+        // There are two valid solutions for latp.
         cel->latpreq = 1;
       }
 
@@ -345,7 +342,7 @@ int celset(struct celprm *cel)
         }
       }
 
-      /* Account for rounding error. */
+      // Account for rounding error.
       if (fabs(latp) < 90.0+tol) {
         if (latp > 90.0) {
           latp =  90.0;
@@ -358,15 +355,15 @@ int celset(struct celprm *cel)
     z = cosd(latp)*clat0;
     if (fabs(z) < tol) {
       if (fabs(clat0) < tol) {
-        /* Celestial pole at the fiducial point. */
+        // Celestial pole at the fiducial point.
         lngp = lng0;
 
       } else if (latp > 0.0) {
-        /* Celestial north pole at the native pole.*/
+        // Celestial north pole at the native pole.
         lngp = lng0 + phip - cel->phi0 - 180.0;
 
       } else {
-        /* Celestial south pole at the native pole. */
+        // Celestial south pole at the native pole.
         lngp = lng0 - phip + cel->phi0;
       }
 
@@ -374,15 +371,15 @@ int celset(struct celprm *cel)
       x = (sthe0 - sind(latp)*slat0)/z;
       y =  sphip*cthe0/clat0;
       if (x == 0.0 && y == 0.0) {
-        /* Sanity check (shouldn't be possible). */
+        // Sanity check (shouldn't be possible).
         return wcserr_set(WCSERR_SET(CELERR_BAD_COORD_TRANS),
           "Invalid coordinate transformation parameters, internal error");
       }
       lngp = lng0 - atan2d(y,x);
     }
 
-    /* Make celestial longitude of the native pole the same sign as at the
-       fiducial point. */
+    // Make celestial longitude of the native pole the same sign as at the
+    // fiducial point.
     if (lng0 >= 0.0) {
       if (lngp < 0.0) {
         lngp += 360.0;
@@ -398,10 +395,10 @@ int celset(struct celprm *cel)
     }
   }
 
-  /* Reset LATPOLEa. */
+  // Reset LATPOLEa.
   cel->ref[3] = latp;
 
-  /* Set the Euler angles. */
+  // Set the Euler angles.
   cel->euler[0] = lngp;
   cel->euler[1] = 90.0 - latp;
   cel->euler[2] = phip;
@@ -409,7 +406,7 @@ int celset(struct celprm *cel)
   cel->isolat = (cel->euler[4] == 0.0);
   cel->flag = CELSET;
 
-  /* Check for ill-conditioned parameters. */
+  // Check for ill-conditioned parameters.
   if (fabs(latp) > 90.0+tol) {
     return wcserr_set(WCSERR_SET(CELERR_ILL_COORD_TRANS),
       "Ill-conditioned coordinate transformation parameters\nNo valid "
@@ -419,7 +416,7 @@ int celset(struct celprm *cel)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celx2s(
   struct celprm *cel,
@@ -442,7 +439,7 @@ int celx2s(
   struct prjprm *celprj;
   struct wcserr **err;
 
-  /* Initialize. */
+  // Initialize.
   if (cel == 0x0) return CELERR_NULL_POINTER;
   err = &(cel->err);
 
@@ -450,7 +447,7 @@ int celx2s(
     if ((status = celset(cel))) return status;
   }
 
-  /* Apply spherical deprojection. */
+  // Apply spherical deprojection.
   celprj = &(cel->prj);
   if ((istat = celprj->prjx2s(celprj, nx, ny, sxy, 1, x, y, phi, theta,
                                stat))) {
@@ -464,13 +461,13 @@ int celx2s(
 
   nphi = (ny > 0) ? (nx*ny) : nx;
 
-  /* Compute celestial coordinates. */
+  // Compute celestial coordinates.
   sphx2s(cel->euler, nphi, 0, 1, sll, phi, theta, lng, lat);
 
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cels2x(
   struct celprm *cel,
@@ -493,7 +490,7 @@ int cels2x(
   struct prjprm *celprj;
   struct wcserr **err;
 
-  /* Initialize. */
+  // Initialize.
   if (cel == 0x0) return CELERR_NULL_POINTER;
   err = &(cel->err);
 
@@ -501,11 +498,11 @@ int cels2x(
     if ((status = celset(cel))) return status;
   }
 
-  /* Compute native coordinates. */
+  // Compute native coordinates.
   sphs2x(cel->euler, nlng, nlat, sll, 1, lng, lat, phi, theta);
 
   if (cel->isolat) {
-    /* Constant celestial latitude -> constant native latitude. */
+    // Constant celestial latitude -> constant native latitude.
     nphi   = nlng;
     ntheta = nlat;
   } else {
@@ -513,7 +510,7 @@ int cels2x(
     ntheta = 0;
   }
 
-  /* Apply the spherical projection. */
+  // Apply the spherical projection.
   celprj = &(cel->prj);
   if ((istat = celprj->prjs2x(celprj, nphi, ntheta, 1, sxy, phi, theta, x, y,
                                stat))) {
Index: astropy-4.2/cextern/wcslib/C/cel.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/cel.h
+++ astropy-4.2/cextern/wcslib/C/cel.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: cel.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: cel.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -382,50 +379,50 @@ extern "C" {
 extern const char *cel_errmsg[];
 
 enum cel_errmsg_enum {
-  CELERR_SUCCESS         = 0,	/* Success. */
-  CELERR_NULL_POINTER    = 1,	/* Null celprm pointer passed. */
-  CELERR_BAD_PARAM       = 2,	/* Invalid projection parameters. */
-  CELERR_BAD_COORD_TRANS = 3,	/* Invalid coordinate transformation
-				   parameters. */
-  CELERR_ILL_COORD_TRANS = 4,	/* Ill-conditioned coordinated transformation
-				   parameters. */
-  CELERR_BAD_PIX         = 5,	/* One or more of the (x,y) coordinates were
-				   invalid. */
-  CELERR_BAD_WORLD       = 6 	/* One or more of the (lng,lat) coordinates
-				   were invalid. */
+  CELERR_SUCCESS         = 0,	// Success.
+  CELERR_NULL_POINTER    = 1,	// Null celprm pointer passed.
+  CELERR_BAD_PARAM       = 2,	// Invalid projection parameters.
+  CELERR_BAD_COORD_TRANS = 3,	// Invalid coordinate transformation
+				// parameters.
+  CELERR_ILL_COORD_TRANS = 4,	// Ill-conditioned coordinated transformation
+				// parameters.
+  CELERR_BAD_PIX         = 5,	// One or more of the (x,y) coordinates were
+				// invalid.
+  CELERR_BAD_WORLD       = 6 	// One or more of the (lng,lat) coordinates
+				// were invalid.
 };
 
 struct celprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int    flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  int    offset;		/* Force (x,y) = (0,0) at (phi_0,theta_0).  */
-  double phi0, theta0;		/* Native coordinates of fiducial point.    */
-  double ref[4];		/* Celestial coordinates of fiducial        */
-                                /* point and native coordinates of          */
-                                /* celestial pole.                          */
-
-  struct prjprm prj;		/* Projection parameters (see prj.h).       */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  double euler[5];		/* Euler angles and functions thereof.      */
-  int    latpreq;		/* LATPOLEa requirement.                    */
-  int    isolat;		/* True if |latitude| is preserved.         */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    offset;		// Force (x,y) = (0,0) at (phi_0,theta_0).
+  double phi0, theta0;		// Native coordinates of fiducial point.
+  double ref[4];		// Celestial coordinates of fiducial
+                                // point and native coordinates of
+                                // celestial pole.
+
+  struct prjprm prj;		// Projection parameters (see prj.h).
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  double euler[5];		// Euler angles and functions thereof.
+  int    latpreq;		// LATPOLEa requirement.
+  int    isolat;		// True if |latitude| is preserved.
 
-  /* Error handling                                                         */
-  /*------------------------------------------------------------------------*/
+  // Error handling
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private                                                                */
-  /*------------------------------------------------------------------------*/
-  void   *padding;		/* (Dummy inserted for alignment purposes.) */
+  // Private
+  //--------------------------------------------------------------------------
+  void   *padding;		// (Dummy inserted for alignment purposes.)
 };
 
-/* Size of the celprm struct in int units, used by the Fortran wrappers. */
+// Size of the celprm struct in int units, used by the Fortran wrappers.
 #define CELLEN (sizeof(struct celprm)/sizeof(int))
 
 
@@ -450,7 +447,7 @@ int cels2x(struct celprm *cel, int nlng,
            int stat[]);
 
 
-/* Deprecated. */
+// Deprecated.
 #define celini_errmsg cel_errmsg
 #define celprt_errmsg cel_errmsg
 #define celset_errmsg cel_errmsg
@@ -461,4 +458,4 @@ int cels2x(struct celprm *cel, int nlng,
 }
 #endif
 
-#endif /* WCSLIB_CEL */
+#endif // WCSLIB_CEL
Index: astropy-4.2/cextern/wcslib/C/dis.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/dis.c
+++ astropy-4.2/cextern/wcslib/C/dis.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: dis.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: dis.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -41,10 +38,10 @@ const int DIS_TPD        =    1;
 const int DIS_POLYNOMIAL =    2;
 const int DIS_DOTPD      = 1024;
 
-/* Maximum number of DPja or DQia keywords. */
+// Maximum number of DPja or DQia keywords.
 int NDPMAX = 256;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *dis_errmsg[] = {
   "Success",
   "Null disprm pointer passed",
@@ -53,10 +50,10 @@ const char *dis_errmsg[] = {
   "Distort error",
   "De-distort error"};
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define DIS_ERRMSG(status) WCSERR_SET(status), dis_errmsg[status]
 
-/* Internal helper functions, not for general use. */
+// Internal helper functions, not for general use.
 static int polyset(int j, struct disprm *dis);
 static int tpdset(int j, struct disprm *dis);
 
@@ -78,17 +75,17 @@ static int tpd7(DISP2X_ARGS);
 static int tpd8(DISP2X_ARGS);
 static int tpd9(DISP2X_ARGS);
 
-/* The first three iparm indices have meanings common to all distortion     */
-/* functions.  They are used by disp2x(), disx2p(), disprt(), and dishdo(). */
-#define I_DTYPE   0	/* Distortion type code.                            */
-#define I_NIPARM  1	/* Full (allocated) length of iparm[].              */
-#define I_NDPARM  2	/* No. of parameters in dparm[], excl. work space.  */
+// The first three iparm indices have meanings common to all distortion
+// functions.  They are used by disp2x(), disx2p(), disprt(), and dishdo().
+#define I_DTYPE   0	// Distortion type code.
+#define I_NIPARM  1	// Full (allocated) length of iparm[].
+#define I_NDPARM  2	// No. of parameters in dparm[], excl. work space.
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disndp(int ndpmax) { if (ndpmax >= 0) NDPMAX = ndpmax; return NDPMAX; }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int dpfill(
   struct dpkey *dp,
@@ -105,11 +102,11 @@ int dpfill(
   if (keyword) {
     if (field) {
       if (j && 2 <= strlen(keyword)) {
-        /* Fill in the axis number from the value given. */
+        // Fill in the axis number from the value given.
         if (keyword[2] == '\0') {
           sprintf(dp->field, "%s%d.%s", keyword, j, field);
         } else {
-          /* Take care not to overwrite any alternate code. */
+          // Take care not to overwrite any alternate code.
           sprintf(dp->field, "%s.%s", keyword, field);
           sprintf(axno, "%d", j);
           dp->field[2] = axno[0];
@@ -128,7 +125,7 @@ int dpfill(
   if (j) {
     dp->j = j;
   } else {
-    /* The field name must either be given or preset. */
+    // The field name must either be given or preset.
     if ((cp = strpbrk(dp->field, "0123456789")) != 0x0) {
       sscanf(cp, "%d.", &(dp->j));
     }
@@ -143,7 +140,7 @@ int dpfill(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int dpkeyi(const struct dpkey *dp)
 
@@ -155,7 +152,7 @@ int dpkeyi(const struct dpkey *dp)
   return dp->value.i;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double dpkeyd(const struct dpkey *dp)
 
@@ -167,7 +164,7 @@ double dpkeyd(const struct dpkey *dp)
   return dp->value.f;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disini(int alloc, int naxis, struct disprm *dis)
 
@@ -175,7 +172,7 @@ int disini(int alloc, int naxis, struct
   return disinit(alloc, naxis, dis, -1);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disinit(int alloc, int naxis, struct disprm *dis, int ndpmax)
 
@@ -184,13 +181,13 @@ int disinit(int alloc, int naxis, struct
 
   struct wcserr **err;
 
-  /* Check inputs. */
+  // Check inputs.
   if (dis == 0x0) return DISERR_NULL_POINTER;
 
   if (ndpmax < 0) ndpmax = disndp(-1);
 
 
-  /* Initialize error message handling. */
+  // Initialize error message handling.
   if (dis->flag == -1) {
     dis->err = 0x0;
   }
@@ -198,7 +195,7 @@ int disinit(int alloc, int naxis, struct
   wcserr_clear(err);
 
 
-  /* Initialize pointers. */
+  // Initialize pointers.
   if (dis->flag == -1 || dis->m_flag != DISSET) {
     if (dis->flag == -1) {
       dis->docorr = 0x0;
@@ -217,7 +214,7 @@ int disinit(int alloc, int naxis, struct
       dis->i_naxis = 0;
     }
 
-    /* Initialize memory management. */
+    // Initialize memory management.
     dis->m_flag   = 0;
     dis->m_naxis  = 0;
     dis->m_dtype  = 0x0;
@@ -231,23 +228,23 @@ int disinit(int alloc, int naxis, struct
   }
 
 
-  /* Allocate memory for arrays if required. */
+  // Allocate memory for arrays if required.
   if (alloc ||
       dis->dtype  == 0x0 ||
       (ndpmax && dis->dp == 0x0) ||
       dis->maxdis == 0x0) {
 
-    /* Was sufficient allocated previously? */
+    // Was sufficient allocated previously?
     if (dis->m_flag == DISSET &&
        (dis->m_naxis < naxis  ||
         dis->ndpmax  < ndpmax)) {
-      /* No, free it. */
+      // No, free it.
       disfree(dis);
     }
 
     if (alloc || dis->dtype == 0x0) {
       if (dis->m_dtype) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         dis->dtype = dis->m_dtype;
 
       } else {
@@ -264,7 +261,7 @@ int disinit(int alloc, int naxis, struct
 
     if (alloc || dis->dp == 0x0) {
       if (dis->m_dp) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         dis->dp = dis->m_dp;
 
       } else {
@@ -287,7 +284,7 @@ int disinit(int alloc, int naxis, struct
 
     if (alloc || dis->maxdis == 0x0) {
       if (dis->m_maxdis) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         dis->maxdis = dis->m_maxdis;
 
       } else {
@@ -304,7 +301,7 @@ int disinit(int alloc, int naxis, struct
   }
 
 
-  /* Set defaults. */
+  // Set defaults.
   dis->flag  = 0;
   dis->naxis = naxis;
 
@@ -326,7 +323,7 @@ int disinit(int alloc, int naxis, struct
 }
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int discpy(int alloc, const struct disprm *dissrc, struct disprm *disdst)
 
@@ -361,7 +358,7 @@ int discpy(int alloc, const struct dispr
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disfree(struct disprm *dis)
 
@@ -371,7 +368,7 @@ int disfree(struct disprm *dis)
   if (dis == 0x0) return DISERR_NULL_POINTER;
 
   if (dis->flag != -1) {
-    /* Optionally allocated by disinit() for given parameters. */
+    // Optionally allocated by disinit() for given parameters.
     if (dis->m_flag == DISSET) {
       if (dis->dtype  == dis->m_dtype)  dis->dtype  = 0x0;
       if (dis->dp     == dis->m_dp)     dis->dp     = 0x0;
@@ -382,11 +379,11 @@ int disfree(struct disprm *dis)
       if (dis->m_maxdis) free(dis->m_maxdis);
     }
 
-    /* The remainder were allocated by disset(). */
+    // The remainder were allocated by disset().
     if (dis->docorr) free(dis->docorr);
     if (dis->Nhat)   free(dis->Nhat);
 
-    /* Recall that axmap, offset, and scale were allocated in bulk. */
+    // Recall that axmap, offset, and scale were allocated in bulk.
     if (dis->axmap  && dis->axmap[0])  free(dis->axmap[0]);
     if (dis->offset && dis->offset[0]) free(dis->offset[0]);
     if (dis->scale  && dis->scale[0])  free(dis->scale[0]);
@@ -430,7 +427,7 @@ int disfree(struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disprt(const struct disprm *dis)
 
@@ -450,7 +447,7 @@ int disprt(const struct disprm *dis)
 
   wcsprintf("       flag: %d\n", dis->flag);
 
-  /* Parameters supplied. */
+  // Parameters supplied.
   wcsprintf("      naxis: %d\n", naxis);
 
   WCSPRINTF_PTR("      dtype: ", dis->dtype, "\n");
@@ -480,7 +477,7 @@ int disprt(const struct disprm *dis)
 
   wcsprintf("     totdis:  %#- 11.5g\n", dis->totdis);
 
-  /* Derived values. */
+  // Derived values.
   WCSPRINTF_PTR("     docorr: ", dis->docorr, "\n");
   wcsprintf("            ");
   for (j = 0; j < naxis; j++) {
@@ -559,13 +556,13 @@ int disprt(const struct disprm *dis)
   wcsprintf("    i_naxis: %d\n", dis->i_naxis);
   wcsprintf("       ndis: %d\n", dis->ndis);
 
-  /* Error handling. */
+  // Error handling.
   WCSPRINTF_PTR("        err: ", dis->err, "\n");
   if (dis->err) {
     wcserr_prt(dis->err, "             ");
   }
 
-  /* Work arrays. */
+  // Work arrays.
   WCSPRINTF_PTR("     disp2x: ", dis->disp2x, "\n");
   for (j = 0; j < naxis; j++) {
     wcsprintf("  disp2x[%d]: %s", j,
@@ -601,7 +598,7 @@ int disprt(const struct disprm *dis)
   }
   WCSPRINTF_PTR("     tmpmem: ", dis->tmpmem, "\n");
 
-  /* Memory management. */
+  // Memory management.
   wcsprintf("     m_flag: %d\n", dis->m_flag);
   wcsprintf("    m_naxis: %d\n", dis->m_naxis);
   WCSPRINTF_PTR("    m_dtype: ", dis->m_dtype, "");
@@ -617,7 +614,7 @@ int disprt(const struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disperr(const struct disprm *dis, const char *prefix)
 
@@ -631,7 +628,7 @@ int disperr(const struct disprm *dis, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int dishdo(struct disprm *dis)
 
@@ -648,13 +645,13 @@ int dishdo(struct disprm *dis)
   for (j = 0; j < dis->naxis; j++) {
     if (dis->iparm[j][I_DTYPE]) {
       if (dis->iparm[j][I_DTYPE] == DIS_TPD) {
-        /* Implemented as TPD... */
+        // Implemented as TPD...
         if (strcmp(dis->dtype[j], "TPD") != 0) {
-          /* ... but isn't TPD. */
+          // ... but isn't TPD.
           dis->iparm[j][I_DTYPE] |= DIS_DOTPD;
         }
       } else {
-        /* Must be a Polynomial that can't be implemented as TPD. */
+        // Must be a Polynomial that can't be implemented as TPD.
         status = wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
           "Translation of %s to TPD is not possible", dis->dtype[j]);
       }
@@ -664,7 +661,7 @@ int dishdo(struct disprm *dis)
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disset(struct disprm *dis)
 
@@ -682,7 +679,7 @@ int disset(struct disprm *dis)
   naxis = dis->naxis;
 
 
-  /* Do basic checks. */
+  // Do basic checks.
   if (dis->ndp < 0) {
     return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
       "disprm::ndp is negative (%d)", dis->ndp);
@@ -697,7 +694,7 @@ int disset(struct disprm *dis)
   }
 
   if (dis->ndp) {
-    /* Is it prior or sequent? */
+    // Is it prior or sequent?
     if (dis->dp[0].field[1] == 'P') {
       dpq = "DPja";
     } else if (dis->dp[0].field[1] == 'Q') {
@@ -714,26 +711,26 @@ int disset(struct disprm *dis)
         "distortion");
     }
 
-    /* A Clayton's distortion.  Avert compiler warnings about possible use of
-       uninitialized variables. */
+    // A Clayton's distortion.  Avert compiler warnings about possible use of
+    // uninitialized variables.
     dpq = 0x0;
   }
 
 
-  /* Free memory allocated separately for each axis. */
+  // Free memory allocated separately for each axis.
   for (j = 0; j < dis->i_naxis; j++) {
     if (dis->iparm[j]) free(dis->iparm[j]);
     if (dis->dparm[j]) free(dis->dparm[j]);
   }
 
-  /* Allocate or reallocate memory, if necessary, for derived parameter and
-     work arrays sized according to the number of axes. */
+  // Allocate or reallocate memory, if necessary, for derived parameter and
+  // work arrays sized according to the number of axes.
   if (dis->i_naxis < naxis) {
     if (dis->i_naxis) {
       free(dis->docorr);
       free(dis->Nhat);
 
-      /* Noting that axmap, offset, and scale are allocated in bulk. */
+      // Noting that axmap, offset, and scale are allocated in bulk.
       free(dis->axmap[0]);
       free(dis->axmap);
       free(dis->offset[0]);
@@ -760,7 +757,7 @@ int disset(struct disprm *dis)
       return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
     }
 
-    /* Allocate axmap[][] in bulk and then carve it up. */
+    // Allocate axmap[][] in bulk and then carve it up.
     if ((dis->axmap = calloc(naxis, sizeof(int *))) == 0x0) {
       disfree(dis);
       return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -775,7 +772,7 @@ int disset(struct disprm *dis)
       dis->axmap[j] = dis->axmap[j-1] + naxis;
     }
 
-    /* Allocate offset[][] in bulk and then carve it up. */
+    // Allocate offset[][] in bulk and then carve it up.
     if ((dis->offset = calloc(naxis, sizeof(double *))) == 0x0) {
       disfree(dis);
       return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -790,7 +787,7 @@ int disset(struct disprm *dis)
       dis->offset[j] = dis->offset[j-1] + naxis;
     }
 
-    /* Allocate scale[][] in bulk and then carve it up. */
+    // Allocate scale[][] in bulk and then carve it up.
     if ((dis->scale = calloc(naxis, sizeof(double *))) == 0x0) {
       disfree(dis);
       return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -833,7 +830,7 @@ int disset(struct disprm *dis)
     dis->i_naxis = naxis;
   }
 
-  /* Start with a clean slate. */
+  // Start with a clean slate.
   for (j = 0; j < naxis; j++) {
     dis->docorr[j] = 1;
   }
@@ -850,7 +847,7 @@ int disset(struct disprm *dis)
     dis->scale[0][jhat] = 1.0;
   }
 
-  /* polyset() etc. must look after iparm[][] and dparm[][]. */
+  // polyset() etc. must look after iparm[][] and dparm[][].
 
   dis->i_naxis = naxis;
   dis->ndis    = 0;
@@ -860,10 +857,10 @@ int disset(struct disprm *dis)
   memset(dis->tmpmem, 0, naxis*sizeof(double));
 
 
-  /* Handle DPja or DQia keywords common to all distortions. */
+  // Handle DPja or DQia keywords common to all distortions.
   keyp = dis->dp;
   for (idp = 0; idp < dis->ndp; idp++, keyp++) {
-    /* Check that they're all one kind or the other. */
+    // Check that they're all one kind or the other.
     if (keyp->field[1] != dpq[1]) {
       return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
         "disprm::dp appears to contain a mix of DPja and DQia keys");
@@ -882,7 +879,7 @@ int disset(struct disprm *dis)
     }
     fp++;
 
-    /* Convert to 0-relative axis number. */
+    // Convert to 0-relative axis number.
     j--;
 
     if (strncmp(fp, "DOCORR", 7) == 0) {
@@ -908,7 +905,7 @@ int disset(struct disprm *dis)
           dis->dtype[j], keyp->field, jhat);
       }
 
-      /* N.B. axis numbers in the map are 0-relative. */
+      // N.B. axis numbers in the map are 0-relative.
       dis->axmap[j][jhat-1] = dpkeyi(keyp) - 1;
 
     } else if (strncmp(fp, "OFFSET.", 7) == 0) {
@@ -921,10 +918,10 @@ int disset(struct disprm *dis)
     }
   }
 
-  /* Set defaults and do sanity checks on axmap[][].  */
+  // Set defaults and do sanity checks on axmap[][].
   for (j = 0; j < naxis; j++) {
     if (strlen(dis->dtype[j]) == 0) {
-      /* No distortion on this axis, check that there are no parameters. */
+      // No distortion on this axis, check that there are no parameters.
       keyp = dis->dp;
       for (idp = 0; idp < dis->ndp; idp++, keyp++) {
         if (keyp->j == j+1) {
@@ -937,14 +934,14 @@ int disset(struct disprm *dis)
       continue;
     }
 
-    /* N.B. NAXES (Nhat) has no default value. */
+    // N.B. NAXES (Nhat) has no default value.
     if (dis->Nhat[j] <= 0) {
       return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
         "%s.NAXES was not set (or bad) for %s distortion on axis %d",
         dpq, dis->dtype[j], j+1);
     }
 
-    /* Set defaults for axmap[][]. */
+    // Set defaults for axmap[][].
     Nhat = dis->Nhat[j];
     for (jhat = 0; jhat < Nhat; jhat++) {
       if (dis->axmap[j][jhat] == -1) {
@@ -952,7 +949,7 @@ int disset(struct disprm *dis)
       }
     }
 
-    /* Sanity check on the length of the axis map. */
+    // Sanity check on the length of the axis map.
     Nhat = 0;
     for (jhat = 0; jhat < naxis; jhat++) {
       if (dis->axmap[j][jhat] != -1) Nhat = jhat+1;
@@ -964,7 +961,7 @@ int disset(struct disprm *dis)
         dis->dtype[j], j+1);
     }
 
-    /* Check uniqueness of entries in the axis map. */
+    // Check uniqueness of entries in the axis map.
     for (jhat = 0; jhat < Nhat; jhat++) {
       for (k = 0; k < jhat; k++) {
         if (dis->axmap[j][jhat] == dis->axmap[j][k]) {
@@ -977,11 +974,11 @@ int disset(struct disprm *dis)
   }
 
 
-  /* Identify the distortion functions. */
+  // Identify the distortion functions.
   ndis = 0;
   for (j = 0; j < naxis; j++) {
     if (strlen(dis->dtype[j]) == 0) {
-      /* No distortion on this axis. */
+      // No distortion on this axis.
       continue;
     }
 
@@ -990,47 +987,47 @@ int disset(struct disprm *dis)
         "Empty axis map for %s distortion on axis %d", dis->dtype[j], j+1);
     }
 
-    /* Invoke the specific setup functions for each distortion. */
+    // Invoke the specific setup functions for each distortion.
     if (strcmp(dis->dtype[j], "TPD") == 0) {
-      /* Template Polynomial Distortion. */
+      // Template Polynomial Distortion.
       if ((status = tpdset(j, dis))) {
-        /* (Preserve the error message set by tpdset().) */
+        // (Preserve the error message set by tpdset().)
         return status;
       }
 
     } else if (strcmp(dis->dtype[j], "TPV") == 0) {
-      /* TPV "projection". */
+      // TPV "projection".
       if ((status = tpvset(j, dis))) {
-        /* (Preserve the error message set by tpvset().) */
+        // (Preserve the error message set by tpvset().)
         return status;
       }
 
     } else if (strcmp(dis->dtype[j], "SIP") == 0) {
-      /* Simple Imaging Polynomial (SIP). */
+      // Simple Imaging Polynomial (SIP).
       if ((status = sipset(j, dis))) {
-        /* (Preserve the error message set by sipset().) */
+        // (Preserve the error message set by sipset().)
         return status;
       }
 
     } else if (strcmp(dis->dtype[j], "DSS") == 0) {
-      /* Digitized Sky Survey (DSS). */
+      // Digitized Sky Survey (DSS).
       if ((status = dssset(j, dis))) {
-        /* (Preserve the error message set by dssset().) */
+        // (Preserve the error message set by dssset().)
         return status;
       }
 
     } else if (strncmp(dis->dtype[j], "WAT", 3) == 0) {
-      /* WAT (TNX or ZPX "projections"). */
+      // WAT (TNX or ZPX "projections").
       if ((status = watset(j, dis))) {
-        /* (Preserve the error message set by watset().) */
+        // (Preserve the error message set by watset().)
         return status;
       }
 
     } else if (strcmp(dis->dtype[j], "Polynomial")  == 0 ||
                strcmp(dis->dtype[j], "Polynomial*") == 0) {
-      /* General polynomial distortion. */
+      // General polynomial distortion.
       if ((status = polyset(j, dis))) {
-        /* (Preserve the error message set by polyset().) */
+        // (Preserve the error message set by polyset().)
         return status;
       }
 
@@ -1048,7 +1045,7 @@ int disset(struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disp2x(
   struct disprm *dis,
@@ -1063,7 +1060,7 @@ int disp2x(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
@@ -1074,7 +1071,7 @@ int disp2x(
   naxis = dis->naxis;
 
 
-  /* Invoke the distortion functions for each axis. */
+  // Invoke the distortion functions for each axis.
   tmpcrd = dis->tmpmem;
   for (j = 0; j < naxis; j++) {
     if (dis->disp2x[j]) {
@@ -1093,10 +1090,10 @@ int disp2x(
       }
 
       if (dis->docorr[j]) {
-        /* Distortion function computes a correction to be applied. */
+        // Distortion function computes a correction to be applied.
         discrd[j] = rawcrd[j] + dtmp;
       } else {
-        /* Distortion function computes corrected coordinates. */
+        // Distortion function computes corrected coordinates directly.
         discrd[j] = dtmp;
       }
 
@@ -1108,9 +1105,9 @@ int disp2x(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
-/* This function is intended for debugging purposes only.                   */
-/* No documentation or prototype is provided in dis.h.                      */
+//----------------------------------------------------------------------------
+// This function is intended for debugging purposes only.
+// No documentation or prototype is provided in dis.h.
 
 int disitermax(int itermax)
 
@@ -1124,7 +1121,7 @@ int disitermax(int itermax)
   return ITERMAX;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int disx2p(
   struct disprm *dis,
@@ -1142,28 +1139,28 @@ int disx2p(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
   naxis = dis->naxis;
 
-  /* Carve up working memory, noting that disp2x() gets to it first. */
+  // Carve up working memory, noting that disp2x() gets to it first.
   dcrd0 = dis->tmpmem + naxis;
   dcrd1 = dcrd0 + naxis;
   rcrd1 = dcrd1 + naxis;
   delta = rcrd1 + naxis;
 
 
-  /* Zeroth approximation.  The assumption here and below is that the     */
-  /* distortion is small so that, to first order in the neighbourhood of  */
-  /* the solution, discrd[j] ~= a + b*rawcrd[j], i.e. independent of      */
-  /* rawcrd[i], where i != j.  This is effectively equivalent to assuming */
-  /* that the distortion functions are separable to first order.          */
-  /* Furthermore, a is assumed to be small, and b close to unity.         */
+  // Zeroth approximation.  The assumption here and below is that the
+  // distortion is small so that, to first order in the neighbourhood of
+  // the solution, discrd[j] ~= a + b*rawcrd[j], i.e. independent of
+  // rawcrd[i], where i != j.  This is effectively equivalent to assuming
+  // that the distortion functions are separable to first order.
+  // Furthermore, a is assumed to be small, and b close to unity.
   memcpy(rawcrd, discrd, naxis*sizeof(double));
 
-  /* If available, use disprm::disx2p to improve the zeroth approximation. */
+  // If available, use disprm::disx2p to improve the zeroth approximation.
   for (j = 0; j < naxis; j++) {
     if (dis->disx2p[j]) {
       offset = dis->offset[j];
@@ -1182,28 +1179,28 @@ int disx2p(
       }
 
       if (dis->docorr[j]) {
-        /* Inverse distortion function computes a correction to be applied. */
+        // Inverse distortion function computes a correction to be applied.
         rawcrd[j] = discrd[j] + rtmp;
       } else {
-        /* Inverse distortion function computes corrected coordinates. */
+        // Inverse distortion function computes corrected coordinates directly.
         rawcrd[j] = rtmp;
       }
     }
   }
 
-  /* Quick return debugging hook, assumes inverse functions were defined. */
+  // Quick return debugging hook, assumes inverse functions were defined.
   if ((itermax = disitermax(-1)) == 0) {
     return 0;
   }
 
 
-  /* Iteratively invert the (well-behaved!) distortion function. */
+  // Iteratively invert the (well-behaved!) distortion function.
   for (iter = 0; iter < itermax; iter++) {
     if ((status = disp2x(dis, rawcrd, dcrd0))) {
       return wcserr_set(DIS_ERRMSG(status));
     }
 
-    /* Check for convergence. */
+    // Check for convergence.
     convergence = 1;
     for (j = 0; j < naxis; j++) {
       delta[j] = discrd[j] - dcrd0[j];
@@ -1211,22 +1208,22 @@ int disx2p(
       if (fabs(discrd[j]) < 1.0) {
         dd = delta[j];
       } else {
-        /* TOL may be below the precision achievable from floating point */
-        /* subtraction, so switch to a fractional tolerance.             */
+        // TOL may be below the precision achievable from floating point
+        // subtraction, so switch to a fractional tolerance.
         dd = delta[j] / discrd[j];
       }
 
       if (TOL < fabs(dd)) {
-        /* No convergence yet on this axis. */
+        // No convergence yet on this axis.
         convergence = 0;
       }
     }
 
     if (convergence) break;
 
-    /* Determine a suitable test point for computing the gradient. */
+    // Determine a suitable test point for computing the gradient.
     for (j = 0; j < naxis; j++) {
-      /* Constrain the displacement. */
+      // Constrain the displacement.
       delta[j] /= 2.0;
       if (fabs(delta[j]) < 1.0e-6) {
         if (delta[j] < 0.0) {
@@ -1244,40 +1241,40 @@ int disx2p(
     }
 
     if (iter < itermax/2) {
-      /* With the assumption of small distortions (as above), the gradient */
-      /* of discrd[j] should be dominated by the partial derivative with   */
-      /* respect to rawcrd[j], and we can neglect partials with respect    */
-      /* to rawcrd[i], where i != j.  Thus only one test point is needed,  */
-      /* not one for each axis.                                            */
+      // With the assumption of small distortions (as above), the gradient
+      // of discrd[j] should be dominated by the partial derivative with
+      // respect to rawcrd[j], and we can neglect partials with respect
+      // to rawcrd[i], where i != j.  Thus only one test point is needed,
+      // not one for each axis.
       for (j = 0; j < naxis; j++) {
         rcrd1[j] = rawcrd[j] + delta[j];
       }
 
-      /* Compute discrd[] at the test point. */
+      // Compute discrd[] at the test point.
       if ((status = disp2x(dis, rcrd1, dcrd1))) {
         return wcserr_set(DIS_ERRMSG(status));
       }
 
-      /* Compute the next approximation. */
+      // Compute the next approximation.
       for (j = 0; j < naxis; j++) {
         rawcrd[j] += (discrd[j] - dcrd0[j]) *
                         (delta[j]/(dcrd1[j] - dcrd0[j]));
       }
 
     } else {
-      /* Convergence should not take more than seven or so iterations.  As */
-      /* it is slow, try computing the gradient in full.                   */
+      // Convergence should not take more than seven or so iterations.  As
+      // it is slow, try computing the gradient in full.
       memcpy(rcrd1, rawcrd, naxis*sizeof(double));
 
       for (j = 0; j < naxis; j++) {
         rcrd1[j] += delta[j];
 
-        /* Compute discrd[] at the test point. */
+        // Compute discrd[] at the test point.
         if ((status = disp2x(dis, rcrd1, dcrd1))) {
           return wcserr_set(DIS_ERRMSG(status));
         }
 
-        /* Compute the next approximation. */
+        // Compute the next approximation.
         rawcrd[j] += (discrd[j] - dcrd0[j]) *
                        (delta[j]/(dcrd1[j] - dcrd0[j]));
 
@@ -1304,7 +1301,7 @@ int disx2p(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int diswarp(
   struct disprm *dis,
@@ -1328,7 +1325,7 @@ int diswarp(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
@@ -1344,16 +1341,16 @@ int diswarp(
   if (avgtot) *avgtot = 0.0;
   if (rmstot) *rmstot = 0.0;
 
-  /* Quick return if no distortions. */
+  // Quick return if no distortions.
   if (dis->ndis == 0) return 0;
 
-  /* Carve up working memory, noting that disp2x() gets to it first. */
+  // Carve up working memory, noting that disp2x() gets to it first.
   pixinc = dis->tmpmem + naxis;
   pixend = pixinc + naxis;
   sumdis = pixend + naxis;
   ssqdis = sumdis + naxis;
 
-  /* Work out increments on each axis. */
+  // Work out increments on each axis.
   for (j = 0; j < naxis; j++) {
     pixspan = pixtrc[j] - (pixblc ? pixblc[j] : 1.0);
 
@@ -1370,7 +1367,7 @@ int diswarp(
     }
   }
 
-  /* Get some more memory for coordinate vectors. */
+  // Get some more memory for coordinate vectors.
   if ((pix0 = calloc(2*naxis, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -1378,13 +1375,13 @@ int diswarp(
   pix1 = pix0 + naxis;
 
 
-  /* Set up the array of pixel coordinates. */
+  // Set up the array of pixel coordinates.
   for (j = 0; j < naxis; j++) {
     pix0[j] = pixblc ? pixblc[j] : 1.0;
     pixend[j] = pixtrc[j] + 0.5*pixinc[j];
   }
 
-  /* Initialize accumulators. */
+  // Initialize accumulators.
   for (j = 0; j < naxis; j++) {
     sumdis[j] = 0.0;
     ssqdis[j] = 0.0;
@@ -1393,15 +1390,15 @@ int diswarp(
   ssqtot = 0.0;
 
 
-  /* Loop over N dimensions. */
+  // Loop over N dimensions.
   carry = 0;
   while (carry == 0) {
     if ((status = disp2x(dis, pix0, pix1))) {
-      /* (Preserve the error message set by disp2x().) */
+      // (Preserve the error message set by disp2x().)
       goto cleanup;
     }
 
-    /* Accumulate statistics. */
+    // Accumulate statistics.
     (*nsamp)++;
 
     dssq = 0.0;
@@ -1427,7 +1424,7 @@ int diswarp(
       *maxtot = totdis;
     }
 
-    /* Next pixel. */
+    // Next pixel.
     for (j = 0; j < naxis; j++) {
       pix0[j] += pixinc[j];
       if (pix0[j] < pixend[j]) {
@@ -1441,7 +1438,7 @@ int diswarp(
   }
 
 
-  /* Compute the means and RMSs. */
+  // Compute the means and RMSs.
   for (j = 0; j < naxis; j++) {
     ssqdis[j] /= *nsamp;
     sumdis[j] /= *nsamp;
@@ -1461,7 +1458,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int polyset(int j, struct disprm *dis)
 
@@ -1476,7 +1473,7 @@ int polyset(int j, struct disprm *dis)
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
@@ -1484,7 +1481,7 @@ int polyset(int j, struct disprm *dis)
   sprintf(id, "Polynomial on axis %d", j+1);
 
 
-  /* Find the number of auxiliary variables and terms. */
+  // Find the number of auxiliary variables and terms.
   K = 0;
   M = 0;
   keyp = dis->dp;
@@ -1520,31 +1517,31 @@ int polyset(int j, struct disprm *dis)
   nTparm = 1 + nVar;
   ndparm = K*nKparm + M*nTparm;
 
-/* These iparm indices are specific to Polynomial.                          */
-#define I_NIDX    3	/* No. of indexes in iparm[].                       */
-#define I_LENDP   4	/* Full (allocated) length of dparm[].              */
-#define I_K       5	/* No. of auxiliary variables.                      */
-#define I_M       6	/* No. of terms in the polynomial.                  */
-#define I_NKPARM  7	/* No. of parameters used to define each auxiliary. */
-#define I_NTPARM  8	/* No. of parameters used to define each term.      */
-#define I_NVAR    9	/* No. of independent + auxiliary variables.        */
-#define I_MNVAR  10	/* No. of powers (exponents) in the polynomial.     */
-#define I_DPOLY  11	/* dparm offset for polynomial coefficients.        */
-#define I_DAUX   12	/* dparm offset for auxiliary coefficients.         */
-#define I_DVPOW  13	/* dparm offset for integral powers of variables.   */
-#define I_MAXPOW 14	/* iparm offset for max powers.                     */
-#define I_DPOFF  15	/* iparm offset for dparm offsets.                  */
-#define I_FLAGS  16	/* iparm offset for flags.                          */
-#define I_IPOW   17	/* iparm offset for integral powers.                */
+// These iparm indices are specific to Polynomial.
+#define I_NIDX    3	// No. of indexes in iparm[].
+#define I_LENDP   4	// Full (allocated) length of dparm[].
+#define I_K       5	// No. of auxiliary variables.
+#define I_M       6	// No. of terms in the polynomial.
+#define I_NKPARM  7	// No. of parameters used to define each auxiliary.
+#define I_NTPARM  8	// No. of parameters used to define each term.
+#define I_NVAR    9	// No. of independent + auxiliary variables.
+#define I_MNVAR  10	// No. of powers (exponents) in the polynomial.
+#define I_DPOLY  11	// dparm offset for polynomial coefficients.
+#define I_DAUX   12	// dparm offset for auxiliary coefficients.
+#define I_DVPOW  13	// dparm offset for integral powers of variables.
+#define I_MAXPOW 14	// iparm offset for max powers.
+#define I_DPOFF  15	// iparm offset for dparm offsets.
+#define I_FLAGS  16	// iparm offset for flags.
+#define I_IPOW   17	// iparm offset for integral powers.
 #define I_NPOLY  18
 
-  /* Add extra for handling integer exponents.  See "Optimization" below. */
+  // Add extra for handling integer exponents.  See "Optimization" below.
   niparm = I_NPOLY + (2 + 2*M)*nVar;
 
-  /* Add extra memory for temporaries. */
+  // Add extra memory for temporaries.
   lendp = ndparm + K;
 
-  /* Allocate memory for the indexes and parameter array. */
+  // Allocate memory for the indexes and parameter array.
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -1553,12 +1550,12 @@ int polyset(int j, struct disprm *dis)
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
 
-  /* These help a bit to stop the code from turning into hieroglyphics. */
+  // These help a bit to stop the code from turning into hieroglyphics.
   iparm = dis->iparm[j];
   dparm = dis->dparm[j];
 
 
-  /* Record the indexing parameters.  The first three are more widely used. */
+  // Record the indexing parameters.  The first three are more widely used.
   iparm[I_DTYPE]  = DIS_POLYNOMIAL;
   iparm[I_NIPARM] = niparm;
   iparm[I_NDPARM] = ndparm;
@@ -1579,7 +1576,7 @@ int polyset(int j, struct disprm *dis)
   iparm[I_FLAGS]  = iparm[I_DPOFF]  + nVar;
   iparm[I_IPOW]   = iparm[I_FLAGS]  + M*nVar;
 
-  /* Set default values of POWER for the auxiliary variables. */
+  // Set default values of POWER for the auxiliary variables.
   dptr = dparm + (1 + Nhat);
   for (k = 0; k < K; k++) {
     for (jhat = 0; jhat <= Nhat; jhat++) {
@@ -1588,24 +1585,24 @@ int polyset(int j, struct disprm *dis)
     dptr += nKparm;
   }
 
-  /* Set default values of COEFF for the independent variables. */
+  // Set default values of COEFF for the independent variables.
   dptr = dparm + iparm[I_DPOLY];
   for (m = 0; m < M; m++) {
     *dptr = 1.0;
     dptr += nTparm;
   }
 
-  /* Extract parameter values from DPja or DQia. */
+  // Extract parameter values from DPja or DQia.
   k = m = 0;
   keyp = dis->dp;
   for (idp = 0; idp < dis->ndp; idp++, keyp++) {
-    /* N.B. keyp->j is 1-relative, but j is 0-relative. */
+    // N.B. keyp->j is 1-relative, but j is 0-relative.
     if (keyp->j-1 != j) continue;
 
     fp = strchr(keyp->field, '.') + 1;
 
     if (strncmp(fp, "AUX.", 4) == 0) {
-      /* N.B. k here is 1-relative. */
+      // N.B. k here is 1-relative.
       fp += 4;
       sscanf(fp, "%d", &k);
       if (k < 1 || K < k) {
@@ -1633,7 +1630,7 @@ int polyset(int j, struct disprm *dis)
       fp += 6;
       sscanf(fp, "%d", &jhat);
       if (jhat < 0 || naxis < jhat) {
-        /* N.B. jhat == 0 is ok. */
+        // N.B. jhat == 0 is ok.
         return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
         "Invalid axis number (%d) for %s: %s", jhat, id, keyp->field);
       }
@@ -1642,7 +1639,7 @@ int polyset(int j, struct disprm *dis)
       dparm[i] = dpkeyd(keyp);
 
     } else if (strncmp(fp, "TERM.", 5) == 0) {
-      /* N.B. m here is 1-relative. */
+      // N.B. m here is 1-relative.
       fp += 5;
       sscanf(fp, "%d", &m);
       if (m < 1 || M < m) {
@@ -1661,7 +1658,7 @@ int polyset(int j, struct disprm *dis)
         dparm[i] = dpkeyd(keyp);
 
       } else if (strncmp(fp, "VAR.", 4) == 0) {
-        /* N.B. jhat here is 1-relative. */
+        // N.B. jhat here is 1-relative.
         fp += 4;
         sscanf(fp, "%d", &jhat);
         if (jhat < 1 || naxis < jhat) {
@@ -1674,7 +1671,7 @@ int polyset(int j, struct disprm *dis)
         dparm[i] = power;
 
       } else if (strncmp(fp, "AUX.", 4) == 0) {
-        /* N.B. k here is 1-relative. */
+        // N.B. k here is 1-relative.
         fp += 4;
         sscanf(fp, "%d", &k);
         if (k < 1 || K < k) {
@@ -1704,16 +1701,16 @@ int polyset(int j, struct disprm *dis)
   }
 
 
-  /* Optimization: when the power is integral, it is faster to multiply     */
-  /* ------------  repeatedly than call pow().  iparm[] is constructed as   */
-  /*               follows:                                                 */
-  /*  I_NPOLY indexing parameters, as above,                                */
-  /*     nVar elements record the largest integral power for each variable, */
-  /*     nVar elements record offsets into dparm for each variable,         */
-  /*   M*nVar flags to signal whether the power is integral,                */
-  /*   M*nVar integral powers.                                              */
+  // Optimization: when the power is integral, it is faster to multiply
+  // ------------  repeatedly than call pow().  iparm[] is constructed as
+  //               follows:
+  //  I_NPOLY indexing parameters, as above,
+  //     nVar elements record the largest integral power for each variable,
+  //     nVar elements record offsets into dparm for each variable,
+  //   M*nVar flags to signal whether the power is integral,
+  //   M*nVar integral powers.
   for (ivar = 0; ivar < nVar; ivar++) {
-    /* Want at least the first degree power for all variables. */
+    // Want at least the first degree power for all variables.
     i = iparm[I_MAXPOW] + ivar;
     iparm[i] = 1;
   }
@@ -1723,10 +1720,10 @@ int polyset(int j, struct disprm *dis)
       i = iparm[I_DPOLY] + m*nTparm + 1 + ivar;
       power = dparm[i];
 
-      /* Is it integral?  (Positive, negative, or zero.) */
+      // Is it integral?  (Positive, negative, or zero.)
       ipow = (int)power;
       if (power == (double)ipow) {
-        /* Signal that the power is integral. */
+        // Signal that the power is integral.
         i = iparm[I_FLAGS] + m*nVar + ivar;
         if (ipow == 0) {
           iparm[i] = 3;
@@ -1734,12 +1731,12 @@ int polyset(int j, struct disprm *dis)
           iparm[i] = 1;
         }
 
-        /* The integral power itself. */
+        // The integral power itself.
         i = iparm[I_IPOW] + m*nVar + ivar;
         iparm[i] = ipow;
       }
 
-      /* Record the largest integral power for each variable. */
+      // Record the largest integral power for each variable.
       i = iparm[I_MAXPOW] + ivar;
       if (iparm[i] < abs(ipow)) {
         iparm[i] = abs(ipow);
@@ -1747,10 +1744,10 @@ int polyset(int j, struct disprm *dis)
     }
   }
 
-  /* How many of all powers of each variable will there be? */
+  // How many of all powers of each variable will there be?
   npow = 0;
   for (ivar = 0; ivar < nVar; ivar++) {
-    /* Offset into dparm. */
+    // Offset into dparm.
     i = iparm[I_DPOFF] + ivar;
     iparm[i] = lendp + npow;
 
@@ -1758,7 +1755,7 @@ int polyset(int j, struct disprm *dis)
     npow += iparm[i];
   }
 
-  /* Expand dparm to store the extra powers. */
+  // Expand dparm to store the extra powers.
   if (npow) {
     lendp += npow;
     iparm[I_LENDP] = lendp;
@@ -1767,12 +1764,12 @@ int polyset(int j, struct disprm *dis)
     }
   }
 
-  /* No specialist de-distortions. */
+  // No specialist de-distortions.
   dis->disp2x[j] = dispoly;
   dis->disx2p[j] = 0x0;
 
-  /* Translate Polynomial to TPD if possible, it's much faster.  */
-  /* However don't do it if the name was given as "Polynomial*". */
+  // Translate Polynomial to TPD if possible, it's much faster.
+  // However don't do it if the name was given as "Polynomial*".
   if (strcmp(dis->dtype[j], "Polynomial") == 0) {
     pol2tpd(j, dis);
   }
@@ -1780,7 +1777,7 @@ int polyset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpdset(int j, struct disprm *dis)
 
@@ -1799,14 +1796,14 @@ int tpdset(int j, struct disprm *dis)
   sprintf(id, "TPD on axis %d", j+1);
 
 
-  /* TPD distortion. */
+  // TPD distortion.
   if (dis->Nhat[j] < 1 || 2 < dis->Nhat[j]) {
     return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
       "Axis map for %s must contain 1 or 2 entries, not %d", id,
       dis->Nhat[j]);
   }
 
-  /* Find the number of parameters. */
+  // Find the number of parameters.
   ncoeff[0] = 0;
   ncoeff[1] = 0;
   doaux     = 0;
@@ -1823,7 +1820,7 @@ int tpdset(int j, struct disprm *dis)
         idis = 0;
 
       } else if (strncmp(fp, "REV.", 4) == 0) {
-        /* TPD may provide a polynomial approximation for the inverse. */
+        // TPD may provide a polynomial approximation for the inverse.
         idis = 1;
 
       } else {
@@ -1835,7 +1832,7 @@ int tpdset(int j, struct disprm *dis)
       if (0 <= k && k <= 59) {
         if (ncoeff[idis] < k+1) ncoeff[idis] = k+1;
 
-        /* Any radial terms? */
+        // Any radial terms?
         if (k == 3 || k == 11 || k == 23 || k == 39 || k == 59) {
           doradial = 1;
         }
@@ -1846,7 +1843,7 @@ int tpdset(int j, struct disprm *dis)
       }
 
     } else if (strncmp(fp, "AUX.", 4) == 0) {
-      /* Flag usage of auxiliary variables. */
+      // Flag usage of auxiliary variables.
       doaux = 1;
 
     } else if (strcmp(fp, "DOCORR") &&
@@ -1864,43 +1861,43 @@ int tpdset(int j, struct disprm *dis)
   for (idis = 0; idis < 2; idis++) {
     if (ncoeff[idis] <= 4) {
       if (idis) {
-        /* No inverse polynomial. */
+        // No inverse polynomial.
         break;
       }
 
-      /* First degree. */
+      // First degree.
       ncoeff[idis] = 4;
       distpd[idis] = tpd1;
     } else if (ncoeff[idis] <= 7) {
-      /* Second degree. */
+      // Second degree.
       ncoeff[idis] = 7;
       distpd[idis] = tpd2;
     } else if (ncoeff[idis] <= 12) {
-      /* Third degree. */
+      // Third degree.
       ncoeff[idis] = 12;
       distpd[idis] = tpd3;
     } else if (ncoeff[idis] <= 17) {
-      /* Fourth degree. */
+      // Fourth degree.
       ncoeff[idis] = 17;
       distpd[idis] = tpd4;
     } else if (ncoeff[idis] <= 24) {
-      /* Fifth degree. */
+      // Fifth degree.
       ncoeff[idis] = 24;
       distpd[idis] = tpd5;
     } else if (ncoeff[idis] <= 31) {
-      /* Sixth degree. */
+      // Sixth degree.
       ncoeff[idis] = 31;
       distpd[idis] = tpd6;
     } else if (ncoeff[idis] <= 40) {
-      /* Seventh degree. */
+      // Seventh degree.
       ncoeff[idis] = 40;
       distpd[idis] = tpd7;
     } else if (ncoeff[idis] <= 49) {
-      /* Eighth degree. */
+      // Eighth degree.
       ncoeff[idis] = 49;
       distpd[idis] = tpd8;
     } else if (ncoeff[idis] <= 60) {
-      /* Ninth degree. */
+      // Ninth degree.
       ncoeff[idis] = 60;
       distpd[idis] = tpd9;
     } else {
@@ -1909,20 +1906,20 @@ int tpdset(int j, struct disprm *dis)
     }
   }
 
-  /* disx2p() only uses the inverse TPD, if present, to provide a better */
-  /* zeroth approximation. */
+  // disx2p() only uses the inverse TPD, if present, to provide a better
+  // zeroth approximation.
   dis->disp2x[j] = distpd[0];
   dis->disx2p[j] = distpd[1];
 
 
-/* These iparm indices are specific to TPD.                      */
-#define I_TPDNCO  3	/* No. of TPD coefficients, forward...   */
-#define I_TPDINV  4	/* ...and inverse.                       */
-#define I_TPDAUX  5	/* True if auxiliary variables are used. */
-#define I_TPDRAD  6	/* True if the radial variable is used.  */
+// These iparm indices are specific to TPD (matching definitions in wcshdr.c).
+#define I_TPDNCO  3	// No. of TPD coefficients, forward...
+#define I_TPDINV  4	// ...and inverse.
+#define I_TPDAUX  5	// True if auxiliary variables are used.
+#define I_TPDRAD  6	// True if the radial variable is used.
 #define I_NTPD    7
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -1930,28 +1927,28 @@ int tpdset(int j, struct disprm *dis)
 
   ndparm = (doaux?6:0) + ncoeff[0] + ncoeff[1];
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   dis->iparm[j][I_DTYPE]  = DIS_TPD;
   dis->iparm[j][I_NIPARM] = niparm;
   dis->iparm[j][I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   dis->iparm[j][I_TPDNCO] = ncoeff[0];
   dis->iparm[j][I_TPDINV] = ncoeff[1];
 
-  /* Flag for presence of auxiliary variables. */
+  // Flag for presence of auxiliary variables.
   dis->iparm[j][I_TPDAUX] = doaux;
 
-  /* Flag for presence of radial terms. */
+  // Flag for presence of radial terms.
   dis->iparm[j][I_TPDRAD] = doradial;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((dis->dparm[j] = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
 
-  /* Set default auxiliary coefficients. */
+  // Set default auxiliary coefficients.
   if (doaux) {
     dis->dparm[j][1] = 1.0;
     dis->dparm[j][5] = 1.0;
@@ -1964,7 +1961,7 @@ int tpdset(int j, struct disprm *dis)
     fp = strchr(keyp->field, '.') + 1;
 
     if (strncmp(fp, "AUX.", 4) == 0) {
-      /* Auxiliary variables. */
+      // Auxiliary variables.
       fp += 4;
       sscanf(fp, "%d", &k);
       if (k < 1 || 2 < k) {
@@ -2008,7 +2005,7 @@ int tpdset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int pol2tpd(int j, struct disprm *dis)
 
@@ -2031,7 +2028,7 @@ int pol2tpd(int j, struct disprm *dis)
   double *dparm, *dpolp, *tpd_dparm;
   struct wcserr **err;
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
@@ -2039,15 +2036,15 @@ int pol2tpd(int j, struct disprm *dis)
   dparm = dis->dparm[j];
 
 
-  /* Check the number of independent variables, no more than two. */
+  // Check the number of independent variables, no more than two.
   Nhat = dis->Nhat[j];
   if (2 < Nhat) return -1;
 
-  /* Check auxiliaries: only one is allowed... */
+  // Check auxiliaries: only one is allowed...
   K = iparm[I_K];
   if (1 < K) return -1;
   if (K) {
-    /* ...and it must be radial. */
+    // ...and it must be radial.
     if (dparm[0] != 0.0) return -1;
     if (dparm[1] != 1.0) return -1;
     if (dparm[2] != 1.0) return -1;
@@ -2056,14 +2053,14 @@ int pol2tpd(int j, struct disprm *dis)
     if (dparm[5] != 2.0) return -1;
   }
 
-  /* Check powers... */
+  // Check powers...
   iflgp = iparm + iparm[I_FLAGS];
   ipowp = iparm + iparm[I_IPOW];
   degree = 0;
   for (m = 0; m < iparm[I_M]; m++) {
     deg = 0;
     for (jhat = 0; jhat < Nhat; jhat++) {
-      /* ...they must be positive integral. */
+      // ...they must be positive integral.
       if (*iflgp == 0)  return -1;
       if (*ipowp < 0)   return -1;
       deg += *ipowp;
@@ -2071,20 +2068,20 @@ int pol2tpd(int j, struct disprm *dis)
       ipowp++;
     }
 
-    /* The polynomial degree can't be greater than 9. */
+    // The polynomial degree can't be greater than 9.
     if (9 < deg) return -1;
 
     if (K) {
-      /* Likewise for the radial variable. */
+      // Likewise for the radial variable.
       if (*iflgp == 0)  return -1;
       if (*ipowp) {
         if (*ipowp < 0) return -1;
         if (9 < *ipowp) return -1;
 
-        /* Can't mix the radial and other terms. */
+        // Can't mix the radial and other terms.
         if (deg)        return -1;
 
-        /* Can't have even powers of the radial variable. */
+        // Can't have even powers of the radial variable.
         deg = *ipowp;
         if (!(deg%2))   return -1;
       }
@@ -2096,7 +2093,7 @@ int pol2tpd(int j, struct disprm *dis)
   }
 
 
-  /* OK, it ticks all the boxes.  Now translate it. */
+  // OK, it ticks all the boxes.  Now translate it.
   ndparm = 0;
   if (degree == 1) {
     ndparm = 4;
@@ -2127,32 +2124,32 @@ int pol2tpd(int j, struct disprm *dis)
     dis->disp2x[j] = tpd9;
   }
 
-  /* No specialist de-distortions. */
+  // No specialist de-distortions.
   dis->disx2p[j] = 0x0;
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((tpd_iparm = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   tpd_iparm[I_DTYPE]  = DIS_TPD;
   tpd_iparm[I_NIPARM] = niparm;
   tpd_iparm[I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   tpd_iparm[I_TPDNCO] = ndparm;
   tpd_iparm[I_TPDINV] = 0;
 
-  /* No auxiliary variables yet. */
+  // No auxiliary variables yet.
   tpd_iparm[I_TPDAUX] = 0;
 
-  /* Flag for presence of radial terms. */
+  // Flag for presence of radial terms.
   tpd_iparm[I_TPDRAD] = K;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((tpd_dparm = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -2161,7 +2158,7 @@ int pol2tpd(int j, struct disprm *dis)
   dpolp = dparm + iparm[I_DPOLY];
   for (m = 0; m < iparm[I_M]; m++) {
     if (K && ipowp[Nhat]) {
-      /* The radial variable. */
+      // The radial variable.
       switch (ipowp[Nhat]) {
       case 1:
         tpd_dparm[3]  = *dpolp;
@@ -2181,7 +2178,7 @@ int pol2tpd(int j, struct disprm *dis)
       }
 
     } else {
-      /* The independent variables. */
+      // The independent variables.
       p[0] = p[1] = 0;
       for (jhat = 0; jhat < Nhat; jhat++) {
         p[jhat] = ipowp[jhat];
@@ -2197,7 +2194,7 @@ int pol2tpd(int j, struct disprm *dis)
   }
 
 
-  /* Switch from Polynomial to TPD. */
+  // Switch from Polynomial to TPD.
   free(iparm);
   free(dparm);
   dis->iparm[j] = tpd_iparm;
@@ -2206,7 +2203,7 @@ int pol2tpd(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpvset(int j, struct disprm *dis)
 
@@ -2219,14 +2216,15 @@ int tpvset(int j, struct disprm *dis)
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
-  /* TPV "projection". */
+  // TPV "projection".
   sprintf(id, "TPV on axis %d", j+1);
 
-  /* TPV computes corrected coordinates. */
+  // TPV is a sequent distortion, applied to intermediate world coordinates
+  // (normally used with CDi_ja).  It computes corrected coordinates directly.
   dis->docorr[j] = 0;
 
   if (dis->Nhat[j] != 2) {
@@ -2234,7 +2232,7 @@ int tpvset(int j, struct disprm *dis)
       "Axis map for %s must contain 2 entries, not %d", id, dis->Nhat[j]);
   }
 
-  /* Find the number of parameters. */
+  // Find the number of parameters.
   ndparm   = 0;
   doradial = 0;
   keyp = dis->dp;
@@ -2248,7 +2246,7 @@ int tpvset(int j, struct disprm *dis)
       if (0 <= k && k <= 39) {
         if (ndparm < k+1) ndparm = k+1;
 
-        /* Any radial terms? */
+        // Any radial terms?
         if (k == 3 || k == 11 || k == 23 || k == 39 || k == 59) {
           doradial = 1;
         }
@@ -2267,67 +2265,67 @@ int tpvset(int j, struct disprm *dis)
     }
   }
 
-  /* TPD is going to do the dirty work. */
+  // TPD is going to do the dirty work.
   if (ndparm <= 4) {
-    /* First degree. */
+    // First degree.
     ndparm = 4;
     dis->disp2x[j] = tpd1;
   } else if (ndparm <= 7) {
-    /* Second degree. */
+    // Second degree.
     ndparm = 7;
     dis->disp2x[j] = tpd2;
   } else if (ndparm <= 12) {
-    /* Third degree. */
+    // Third degree.
     ndparm = 12;
     dis->disp2x[j] = tpd3;
   } else if (ndparm <= 17) {
-    /* Fourth degree. */
+    // Fourth degree.
     ndparm = 17;
     dis->disp2x[j] = tpd4;
   } else if (ndparm <= 24) {
-    /* Fifth degree. */
+    // Fifth degree.
     ndparm = 24;
     dis->disp2x[j] = tpd5;
   } else if (ndparm <= 31) {
-    /* Sixth degree. */
+    // Sixth degree.
     ndparm = 31;
     dis->disp2x[j] = tpd6;
   } else if (ndparm <= 40) {
-    /* Seventh degree. */
+    // Seventh degree.
     ndparm = 40;
     dis->disp2x[j] = tpd7;
   } else {
-    /* Could go to ninth degree, but that wouldn't be legit. */
+    // Could go to ninth degree, but that wouldn't be legit.
     return wcserr_set(WCSERR_SET(DISERR_BAD_PARAM),
       "Invalid number of parameters (%d) for %s", ndparm, id);
   }
 
-  /* No specialist de-distortions. */
+  // No specialist de-distortions.
   dis->disx2p[j] = 0x0;
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   dis->iparm[j][I_DTYPE]  = DIS_TPD;
   dis->iparm[j][I_NIPARM] = niparm;
   dis->iparm[j][I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   dis->iparm[j][I_TPDNCO] = ndparm;
   dis->iparm[j][I_TPDINV] = 0;
 
-  /* TPV never needs auxiliary variables. */
+  // TPV never needs auxiliary variables.
   dis->iparm[j][I_TPDAUX] = 0;
 
-  /* Flag for presence of radial terms. */
+  // Flag for presence of radial terms.
   dis->iparm[j][I_TPDRAD] = doradial;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((dis->dparm[j] = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -2338,7 +2336,7 @@ int tpvset(int j, struct disprm *dis)
 
     fp = strchr(keyp->field, '.') + 1;
 
-    /* One-to-one correspondence between TPV and TPD coefficients. */
+    // One-to-one correspondence between TPV and TPD coefficients.
     if (strncmp(fp, "TPV.", 4) == 0) {
       sscanf(fp+4, "%d", &k);
       dis->dparm[j][k] = dpkeyd(keyp);
@@ -2348,7 +2346,7 @@ int tpvset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sipset(int j, struct disprm *dis)
 
@@ -2373,15 +2371,15 @@ int sipset(int j, struct disprm *dis)
   int (*(distpd[2]))(DISP2X_ARGS);
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
-  /* Simple Imaging Polynomial. */
+  // Simple Imaging Polynomial.
   sprintf(id, "SIP on axis %d", j+1);
 
 
-  /* SIP computes an additive correction. */
+  // SIP is a prior distortion that computes an additive correction.
   dis->docorr[j] = 1;
 
   if (dis->Nhat[j] != 2) {
@@ -2389,7 +2387,7 @@ int sipset(int j, struct disprm *dis)
       "Axis map for %s must contain 2 entries, not %d", id, dis->Nhat[j]);
   }
 
-  /* Find the polynomial degree, at least 1 for the forward function. */
+  // Find the polynomial degree, at least 1 for the forward function.
   degree[0] =  1;
   degree[1] = -1;
   keyp = dis->dp;
@@ -2404,7 +2402,7 @@ int sipset(int j, struct disprm *dis)
         idis = 0;
 
       } else if (strncmp(fp, "REV.", 4) == 0) {
-        /* SIP uses a polynomial approximation for the inverse. */
+        // SIP uses a polynomial approximation for the inverse.
         idis = 1;
 
       } else {
@@ -2433,7 +2431,7 @@ int sipset(int j, struct disprm *dis)
 
   if (degree[1] == 0 ) degree[1] = 1;
 
-  /* TPD is going to do the dirty work. */
+  // TPD is going to do the dirty work.
   distpd[0] = 0x0;
   distpd[1] = 0x0;
   for (idis = 0; idis < 2; idis++) {
@@ -2468,13 +2466,13 @@ int sipset(int j, struct disprm *dis)
     }
   }
 
-  /* SIP uses a polynomial approximation to the inverse.  It's not very    */
-  /* accurate but may provide disx2p() with a better zeroth approximation. */
+  // SIP uses a polynomial approximation to the inverse.  It's not very
+  // accurate but may provide disx2p() with a better zeroth approximation.
   dis->disp2x[j] = distpd[0];
   dis->disx2p[j] = distpd[1];
 
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -2482,23 +2480,23 @@ int sipset(int j, struct disprm *dis)
 
   ndparm = ncoeff[0] + ncoeff[1];
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   dis->iparm[j][I_DTYPE]  = DIS_TPD;
   dis->iparm[j][I_NIPARM] = niparm;
   dis->iparm[j][I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   dis->iparm[j][I_TPDNCO] = ncoeff[0];
   dis->iparm[j][I_TPDINV] = ncoeff[1];
 
-  /* SIP never needs auxiliary variables. */
+  // SIP never needs auxiliary variables.
   dis->iparm[j][I_TPDAUX] = 0;
 
-  /* SIP never needs the radial terms. */
+  // SIP never needs the radial terms.
   dis->iparm[j][I_TPDRAD] = 0;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((dis->dparm[j] = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -2519,7 +2517,7 @@ int sipset(int j, struct disprm *dis)
 
       sscanf(fp+4, "%d_%d", &p, &q);
 
-      /* Map to TPD coefficient number. */
+      // Map to TPD coefficient number.
       idis += map[p][q];
 
       dis->dparm[j][idis] = dpkeyd(keyp);
@@ -2530,7 +2528,7 @@ int sipset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int dssset(int j, struct disprm *dis)
 
@@ -2544,15 +2542,16 @@ int dssset(int j, struct disprm *dis)
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
-  /* Digitized Sky Survey. */
+  // Digitized Sky Survey.
   sprintf(id, "DSS on axis %d", j+1);
 
 
-  /* DSS computes corrected coordinates. */
+  // DSS is translated into a sequent distortion, applied to intermediate
+  // pixel coordinates.  It computes corrected coordinates directly.
   dis->docorr[j] = 0;
 
   if (dis->Nhat[j] != 2) {
@@ -2560,15 +2559,15 @@ int dssset(int j, struct disprm *dis)
       "Axis map for %s must contain 2 entries, not %d", id, dis->Nhat[j]);
   }
 
-  /* Safe to assume the polynomial degree is 5 (or less). */
+  // Safe to assume the polynomial degree is 5 (or less).
   ncoeff = 24;
   dis->disp2x[j] = tpd5;
 
-  /* No specialist de-distortions. */
+  // No specialist de-distortions.
   dis->disx2p[j] = 0x0;
 
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -2576,29 +2575,29 @@ int dssset(int j, struct disprm *dis)
 
   ndparm = 6 + ncoeff;
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   dis->iparm[j][I_DTYPE]  = DIS_TPD;
   dis->iparm[j][I_NIPARM] = niparm;
   dis->iparm[j][I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   dis->iparm[j][I_TPDNCO] = ncoeff;
   dis->iparm[j][I_TPDINV] = 0;
 
-  /* DSS always needs auxiliary variables. */
+  // DSS always needs auxiliary variables.
   dis->iparm[j][I_TPDAUX] = 1;
 
-  /* DSS never needs the radial terms. */
+  // DSS never needs the radial terms.
   dis->iparm[j][I_TPDRAD] = 0;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((dis->dparm[j] = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
 
-  /* This translation follows WCS Paper IV, Sect. 5.2 using the same */
-  /* variable names.  Find A1, A2, A3, B1, B2, and B3.               */
+  // This translation follows WCS Paper IV, Sect. 5.2 using the same
+  // variable names.  Find A1, A2, A3, B1, B2, and B3.
   A1 = A2 = A3 = 0.0;
   B1 = B2 = B3 = 0.0;
   keyp = dis->dp;
@@ -2639,7 +2638,7 @@ int dssset(int j, struct disprm *dis)
       "Coefficient scale for %s is zero.", id);
   }
 
-  /* Coefficients for the auxiliary variables. */
+  // Coefficients for the auxiliary variables.
   dparm = dis->dparm[j];
   if (j == 0) {
     dparm[0] =  X0;
@@ -2649,7 +2648,7 @@ int dssset(int j, struct disprm *dis)
     dparm[4] =  B2/S;
     dparm[5] =  A1/S;
 
-    /* Change the sign of S for scaling the A coefficients. */
+    // Change the sign of S for scaling the A coefficients.
     S *= -1.0;
 
   } else {
@@ -2661,7 +2660,7 @@ int dssset(int j, struct disprm *dis)
     dparm[5] = -A2/S;
   }
 
-  /* Translate DSS coefficients to TPD. */
+  // Translate DSS coefficients to TPD.
   dparm += 6;
   degree = 3;
   keyp = dis->dp;
@@ -2671,13 +2670,13 @@ int dssset(int j, struct disprm *dis)
     fp = strchr(keyp->field, '.') + 1;
 
     if (strncmp(fp, "DSS.AMD.", 8) == 0) {
-      /* Skip zero coefficients. */
+      // Skip zero coefficients.
       if ((coeff = dpkeyd(keyp)) == 0.0) continue;
 
       fp += 8;
       sscanf(fp, "%d", &m);
 
-      /* Apply the coefficient scale factor. */
+      // Apply the coefficient scale factor.
       coeff /= S;
 
       if (m == 1) {
@@ -2725,8 +2724,8 @@ int dssset(int j, struct disprm *dis)
     }
   }
 
-  /* The DSS polynomial doesn't have 4th degree terms, and the 5th degree
-     coefficient is often zero. */
+  // The DSS polynomial doesn't have 4th degree terms, and the 5th degree
+  // coefficient is often zero.
   if (degree == 3) {
     dis->iparm[j][I_TPDNCO] = 12;
     dis->disp2x[j] = tpd3;
@@ -2735,7 +2734,7 @@ int dssset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define CHEBYSHEV 1
 #define LEGENDRE  2
@@ -2766,15 +2765,16 @@ int watset(int j, struct disprm *dis)
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (dis == 0x0) return DISERR_NULL_POINTER;
   err = &(dis->err);
 
-  /* WAT (TNX or ZPX) Polynomial. */
+  // WAT (TNX or ZPX) Polynomial.
   sprintf(id, "WAT (%s) on axis %d", dis->dtype[0]+4, j+1);
 
 
-  /* WAT computes an additive correction. */
+  // WAT is a sequent distortion, applied to intermediate world coordinates
+  // (normally used with CDi_ja).  It computes an additive correction.
   dis->docorr[j] = 1;
 
   if (dis->Nhat[j] != 2) {
@@ -2782,7 +2782,7 @@ int watset(int j, struct disprm *dis)
       "Axis map for %s must contain 2 entries, not %d", id, dis->Nhat[j]);
   }
 
-  /* Find the polynomial degree (at least 1), kind, and domain. */
+  // Find the polynomial degree (at least 1), kind, and domain.
   degree = 1;
   kind = 0;
   xmin = xmax = 0.0;
@@ -2836,51 +2836,51 @@ int watset(int j, struct disprm *dis)
 
   doaux = (kind == 1 || kind == 2);
 
-  /* TPD is going to do the dirty work. */
+  // TPD is going to do the dirty work.
   ncoeff = 0;
   if (degree == 1) {
-    /* First degree. */
+    // First degree.
     ncoeff = 4;
     dis->disp2x[j] = tpd1;
   } else if (degree == 2) {
-    /* Second degree. */
+    // Second degree.
     ncoeff = 7;
     dis->disp2x[j] = tpd2;
   } else if (degree == 3) {
-    /* Third degree. */
+    // Third degree.
     ncoeff = 12;
     dis->disp2x[j] = tpd3;
   } else if (degree == 4) {
-    /* Fourth degree. */
+    // Fourth degree.
     ncoeff = 17;
     dis->disp2x[j] = tpd4;
   } else if (degree == 5) {
-    /* Fifth degree. */
+    // Fifth degree.
     ncoeff = 24;
     dis->disp2x[j] = tpd5;
   } else if (degree == 6) {
-    /* Sixth degree. */
+    // Sixth degree.
     ncoeff = 31;
     dis->disp2x[j] = tpd6;
   } else if (degree == 7) {
-    /* Seventh degree. */
+    // Seventh degree.
     ncoeff = 40;
     dis->disp2x[j] = tpd7;
   } else if (degree == 8) {
-    /* Eighth degree. */
+    // Eighth degree.
     ncoeff = 49;
     dis->disp2x[j] = tpd8;
   } else if (degree == 9) {
-    /* Ninth degree. */
+    // Ninth degree.
     ncoeff = 60;
     dis->disp2x[j] = tpd9;
   }
 
-  /* No specialist de-distortions. */
+  // No specialist de-distortions.
   dis->disx2p[j] = 0x0;
 
 
-  /* Record indexing parameters. */
+  // Record indexing parameters.
   niparm = I_NTPD;
   if ((dis->iparm[j] = calloc(niparm, sizeof(int))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
@@ -2890,23 +2890,23 @@ int watset(int j, struct disprm *dis)
 
   ndparm = 6 + ncoeff;
 
-  /* The first three are more widely used. */
+  // The first three are more widely used.
   iparm[I_DTYPE]  = DIS_TPD;
   iparm[I_NIPARM] = niparm;
   iparm[I_NDPARM] = ndparm;
 
-  /* Number of TPD coefficients. */
+  // Number of TPD coefficients.
   iparm[I_TPDNCO] = ncoeff;
   iparm[I_TPDINV] = 0;
 
-  /* The Chebyshev and Legendre polynomials use auxiliary variables. */
+  // The Chebyshev and Legendre polynomials use auxiliary variables.
   iparm[I_TPDAUX] = doaux;
 
-  /* WAT never needs the radial terms. */
+  // WAT never needs the radial terms.
   iparm[I_TPDRAD] = 0;
 
 
-  /* Allocate memory for the polynomial coefficients and fill it. */
+  // Allocate memory for the polynomial coefficients and fill it.
   if ((dis->dparm[j] = calloc(ndparm, sizeof(double))) == 0x0) {
     return wcserr_set(DIS_ERRMSG(DISERR_MEMORY));
   }
@@ -2914,7 +2914,7 @@ int watset(int j, struct disprm *dis)
   dparm = dis->dparm[j];
 
 
-  /* Coefficients for the auxiliary variables. */
+  // Coefficients for the auxiliary variables.
   if (doaux) {
     x0 = (xmax + xmin)/2.0;
     dx = (xmax - xmin)/2.0;
@@ -2942,7 +2942,7 @@ int watset(int j, struct disprm *dis)
   }
 
 
-  /* Unpack the polynomial coefficients. */
+  // Unpack the polynomial coefficients.
   keyp = dis->dp;
   for (idp = 0; idp < dis->ndp; idp++, keyp++) {
     if (keyp->j-1 != j) continue;
@@ -2957,13 +2957,13 @@ int watset(int j, struct disprm *dis)
       sscanf(fp, "%d_%d", &m, &n);
 
       if (kind == MONOMIAL) {
-        /* Monomial coefficient, maps simply to TPD coefficient number. */
+        // Monomial coefficient, maps simply to TPD coefficient number.
         idis = map[m][n];
         dparm[idis] = dpkeyd(keyp);
 
       } else {
-        /* Coefficient of the product of two Chebyshev or two Legendre */
-        /* polynomials.  Find the corresponding monomial coefficients. */
+        // Coefficient of the product of two Chebyshev or two Legendre
+        // polynomials.  Find the corresponding monomial coefficients.
         coeff = dpkeyd(keyp);
 
         cheleg(kind, m, n, coeffm, coeffn);
@@ -2984,9 +2984,9 @@ int watset(int j, struct disprm *dis)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
-/* Compute the coefficients of Chebyshev or Legendre polynomials of degree  */
-/* m and n.                                                                 */
+//----------------------------------------------------------------------------
+// Compute the coefficients of Chebyshev or Legendre polynomials of degree
+// m and n.
 
 int cheleg(int kind, int m, int n, double coeffm[], double coeffn[])
 
@@ -2996,7 +2996,7 @@ int cheleg(int kind, int m, int n, doubl
 
   N = (m > n) ? m : n;
 
-  /* Allocate work arrays. */
+  // Allocate work arrays.
   coeff[0] = calloc(3*(N+1), sizeof(double));
   coeff[1] = coeff[0] + (N+1);
   coeff[2] = coeff[1] + (N+1);
@@ -3011,7 +3011,7 @@ int cheleg(int kind, int m, int n, doubl
       coeff[1][1] = 1.0;
 
     } else {
-      /* Cyclic buffer indices. */
+      // Cyclic buffer indices.
       j1 = (j-1)%3;
       j2 = (j-2)%3;
 
@@ -3038,7 +3038,7 @@ int cheleg(int kind, int m, int n, doubl
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int dispoly(
   int dummy,
@@ -3054,10 +3054,10 @@ int dispoly(
   const double *cptr, *dpolp, *pptr;
   double *aux, auxp0, *dvarpow, *dpowp, term, var;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
-  /* Check for zeroes. */
+  // Check for zeroes.
   for (jhat = 0; jhat < Nhat; jhat++) {
     if (rawcrd[jhat] == 0.0) {
       *discrd = 0.0;
@@ -3065,10 +3065,10 @@ int dispoly(
     }
   }
 
-  /* Working memory for auxiliaries &c. was allocated at the end of p[]. */
+  // Working memory for auxiliaries &c. was allocated at the end of p[].
   aux = (double *)(dparm + iparm[I_DAUX]);
 
-  /* Compute the auxiliary variables. */
+  // Compute the auxiliary variables.
   for (k = 0; k < iparm[I_K]; k++) {
     cptr = dparm + k*iparm[I_NKPARM];
     pptr = cptr + (1+Nhat);
@@ -3082,7 +3082,7 @@ int dispoly(
 
     aux[k] = pow(aux[k], auxp0);
 
-    /* Check for zeroes. */
+    // Check for zeroes.
     if (aux[k] == 0.0) {
       *discrd = 0.0;
       return 0;
@@ -3090,7 +3090,7 @@ int dispoly(
   }
 
 
-  /* Compute all required integral powers of the variables. */
+  // Compute all required integral powers of the variables.
   imaxpow = iparm + iparm[I_MAXPOW];
   dvarpow = (double *)(dparm + iparm[I_DVPOW]);
 
@@ -3112,7 +3112,7 @@ int dispoly(
     }
   }
 
-  /* Loop for each term of the polynomial. */
+  // Loop for each term of the polynomial.
   *discrd = 0.0;
   iflgp = iparm + iparm[I_FLAGS];
   ipowp = iparm + iparm[I_IPOW];
@@ -3120,25 +3120,25 @@ int dispoly(
   for (m = 0; m < iparm[I_M]; m++) {
     term = *(dpolp++);
 
-    /* Loop over all variables. */
+    // Loop over all variables.
     imaxp = imaxpow;
     dpowp = dvarpow - 1;
     for (ivar = 0; ivar < iparm[I_NVAR]; ivar++) {
       if (*iflgp & 2) {
-        /* Nothing (zero power). */
+        // Nothing (zero power).
 
       } else if (*iflgp) {
-        /* Integral power. */
+        // Integral power.
         if (*ipowp < 0) {
-          /* Negative. */
+          // Negative.
           term /= dpowp[*ipowp];
         } else {
-          /* Positive. */
+          // Positive.
           term *= dpowp[*ipowp];
         }
 
       } else {
-        /* Fractional power. */
+        // Fractional power.
         term *= pow(dpowp[0], *dpolp);
       }
 
@@ -3156,7 +3156,7 @@ int dispoly(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd1(
   int inverse,
@@ -3176,7 +3176,7 @@ int tpd1(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3186,14 +3186,14 @@ int tpd1(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* First degree. */
+  // First degree.
   *discrd = p[0] + u*p[1];
 
   if (Nhat == 1) return 0;
 
   *discrd += v*p[2];
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3204,7 +3204,7 @@ int tpd1(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd2(
   int inverse,
@@ -3224,7 +3224,7 @@ int tpd2(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3234,7 +3234,7 @@ int tpd2(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Second degree. */
+  // Second degree.
   *discrd = p[0] + u*(p[1] + u*(p[4]));
 
   if (Nhat == 1) return 0;
@@ -3243,7 +3243,7 @@ int tpd2(
       v*(p[2]  + v*(p[6]))
     + u*(p[5])*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3254,7 +3254,7 @@ int tpd2(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd3(
   int inverse,
@@ -3274,7 +3274,7 @@ int tpd3(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3284,7 +3284,7 @@ int tpd3(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Third degree. */
+  // Third degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7])));
 
   if (Nhat == 1) return 0;
@@ -3294,7 +3294,7 @@ int tpd3(
     + u*(p[5]  + v*(p[9])
     + u*(p[8]))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3305,7 +3305,7 @@ int tpd3(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd4(
   int inverse,
@@ -3325,7 +3325,7 @@ int tpd4(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3335,7 +3335,7 @@ int tpd4(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Fourth degree. */
+  // Fourth degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12]))));
 
   if (Nhat == 1) return 0;
@@ -3346,7 +3346,7 @@ int tpd4(
     + u*(p[8]  + v*(p[14])
     + u*(p[13])))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3357,7 +3357,7 @@ int tpd4(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd5(
   int inverse,
@@ -3377,7 +3377,7 @@ int tpd5(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3387,7 +3387,7 @@ int tpd5(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Fifth degree. */
+  // Fifth degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12] + u*(p[17])))));
 
   if (Nhat == 1) return 0;
@@ -3399,7 +3399,7 @@ int tpd5(
     + u*(p[13] + v*(p[19])
     + u*(p[18]))))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3410,7 +3410,7 @@ int tpd5(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd6(
   int inverse,
@@ -3430,7 +3430,7 @@ int tpd6(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3440,7 +3440,7 @@ int tpd6(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Sixth degree. */
+  // Sixth degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12] + u*(p[17] + u*(p[24]))))));
 
   if (Nhat == 1) return 0;
@@ -3453,7 +3453,7 @@ int tpd6(
     + u*(p[18] + v*(p[26])
     + u*(p[25])))))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3464,7 +3464,7 @@ int tpd6(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd7(
   int inverse,
@@ -3484,7 +3484,7 @@ int tpd7(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3494,7 +3494,7 @@ int tpd7(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Seventh degree. */
+  // Seventh degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12] + u*(p[17] + u*(p[24] + u*(p[31])))))));
 
   if (Nhat == 1) return 0;
@@ -3508,7 +3508,7 @@ int tpd7(
     + u*(p[25] + v*(p[33])
     + u*(p[32]))))))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3519,7 +3519,7 @@ int tpd7(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd8(
   int inverse,
@@ -3539,7 +3539,7 @@ int tpd8(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3549,7 +3549,7 @@ int tpd8(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Eighth degree. */
+  // Eighth degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12] + u*(p[17] + u*(p[24] + u*(p[31] + u*(p[40]))))))));
 
   if (Nhat == 1) return 0;
@@ -3564,7 +3564,7 @@ int tpd8(
     + u*(p[32] + v*(p[42])
     + u*(p[41])))))))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
@@ -3575,7 +3575,7 @@ int tpd8(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tpd9(
   int inverse,
@@ -3595,7 +3595,7 @@ int tpd9(
   u = rawcrd[0];
   v = rawcrd[1];
 
-  /* Auxiliary variables? */
+  // Auxiliary variables?
   if (i[I_TPDAUX]) {
     r = p[0] + p[1]*u + p[2]*v;
     v = p[3] + p[4]*u + p[5]*v;
@@ -3605,7 +3605,7 @@ int tpd9(
 
   if (inverse) p += i[I_TPDNCO];
 
-  /* Ninth degree. */
+  // Ninth degree.
   *discrd = p[0] + u*(p[1] + u*(p[4] + u*(p[7] + u*(p[12] + u*(p[17] + u*(p[24] + u*(p[31] + u*(p[40] + u*(p[49])))))))));
 
   if (Nhat == 1) return 0;
@@ -3621,7 +3621,7 @@ int tpd9(
     + u*(p[41] + v*(p[51])
     + u*(p[50]))))))))*v;
 
-  /* Radial terms? */
+  // Radial terms?
   if (i[I_TPDRAD]) {
     s = u*u + v*v;
     r = sqrt(s);
Index: astropy-4.2/cextern/wcslib/C/dis.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/dis.h
+++ astropy-4.2/cextern/wcslib/C/dis.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: dis.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: dis.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -92,6 +89,10 @@
 * WCSLIB would handle a FITS header containing these keywords, along with
 * CQDISia = 'TPV' and the required DQia.NAXES and DQia.AXIS.ihat keywords.
 *
+* Note that, as defined, TPV assumes that CDi_ja is used to define the linear
+* transformation.  The section on historical idiosyncrasies (below) cautions
+* about translating CDi_ja to PCi_ja plus CDELTia in this case.
+*
 * SIP - Simple Imaging Polynomial:
 * --------------------------------
 * These routines also support the Simple Imaging Polynomial (SIP), whose
@@ -166,6 +167,10 @@
 * the ZPN projection parameters are also encoded in WATi_n, and wcspih()
 * translates these to standard PVi_ma.
 *
+* Note that, as defined, TNX and ZPX assume that CDi_ja is used to define the
+* linear transformation.  The section on historical idiosyncrasies (below)
+* cautions about translating CDi_ja to PCi_ja plus CDELTia in this case.
+*
 * TPD - Template Polynomial Distortion:
 * -------------------------------------
 * The "Template Polynomial Distortion" (TPD) is a superset of the TPV, SIP,
@@ -246,6 +251,12 @@
 * where r = sqrt(xx + yy).  Note that even powers of r are excluded since they
 * can be accomodated by powers of (xx + yy).
 *
+* Note here that "x" refers to the axis to which the distortion function is
+* attached, with "y" being the complementary axis.  So, for example, with
+* longitude on axis 1 and latitude on axis 2, for TPD attached to axis 1, "x"
+* refers to axis 1 and "y" to axis 2.  For TPD attached to axis 2, "x" refers
+* to axis 2, and "y" to axis 1.
+*
 * TPV uses all terms up to 39.  The m in its PVi_ma keywords translates
 * directly to the TPD coefficient number.
 *
@@ -307,6 +318,13 @@
 *
 * where the value corresponds to CRPIXja.
 *
+* Likewise, because TPV, TNX, and ZPX are defined in terms of CDi_ja, the
+* independent variables of the polynomial are intermediate world coordinates
+* rather than intermediate pixel coordinates.  Because sequent distortions
+* are always applied before CDELTia, if CDi_ja is translated to PCi_ja plus
+* CDELTia, then either CDELTia must be unity, or the distortion polynomial
+* coefficients must be adjusted to account for the change of scale.
+*
 * Summary of the dis routines:
 * ----------------------------
 * These routines apply the distortion functions defined by the extension to
@@ -1010,88 +1028,88 @@ extern "C" {
 extern const char *dis_errmsg[];
 
 enum dis_errmsg_enum {
-  DISERR_SUCCESS      = 0,	/* Success. */
-  DISERR_NULL_POINTER = 1,	/* Null disprm pointer passed. */
-  DISERR_MEMORY       = 2,	/* Memory allocation failed. */
-  DISERR_BAD_PARAM    = 3,	/* Invalid parameter value. */
-  DISERR_DISTORT      = 4,	/* Distortion error. */
-  DISERR_DEDISTORT    = 5	/* De-distortion error. */
+  DISERR_SUCCESS      = 0,	// Success.
+  DISERR_NULL_POINTER = 1,	// Null disprm pointer passed.
+  DISERR_MEMORY       = 2,	// Memory allocation failed.
+  DISERR_BAD_PARAM    = 3,	// Invalid parameter value.
+  DISERR_DISTORT      = 4,	// Distortion error.
+  DISERR_DEDISTORT    = 5	// De-distortion error.
 };
 
-/* For use in declaring distortion function prototypes (= DISX2P_ARGS). */
+// For use in declaring distortion function prototypes (= DISX2P_ARGS).
 #define DISP2X_ARGS int inverse, const int iparm[], const double dparm[], \
 int ncrd, const double rawcrd[], double *discrd
 
-/* For use in declaring de-distortion function prototypes (= DISP2X_ARGS). */
+// For use in declaring de-distortion function prototypes (= DISP2X_ARGS).
 #define DISX2P_ARGS int inverse, const int iparm[], const double dparm[], \
 int ncrd, const double discrd[], double *rawcrd
 
 
-/* Struct used for storing DPja and DQia keyvalues. */
+// Struct used for storing DPja and DQia keyvalues.
 struct dpkey {
-  char field[72];		/* Full record field name (no colon).       */
-  int j;			/* Axis number, as in DPja (1-relative).    */
-  int type;			/* Data type of value.                      */
+  char field[72];		// Full record field name (no colon).
+  int j;			// Axis number, as in DPja (1-relative).
+  int type;			// Data type of value.
   union {
-    int    i;			/* Integer record value.                    */
-    double f;			/* Floating point record value.             */
-  } value;			/* Record value.                            */
+    int    i;			// Integer record value.
+    double f;			// Floating point record value.
+  } value;			// Record value.
 };
 
-/* Size of the dpkey struct in int units, used by the Fortran wrappers. */
+// Size of the dpkey struct in int units, used by the Fortran wrappers.
 #define DPLEN (sizeof(struct dpkey)/sizeof(int))
 
 
 struct disprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  int naxis;			/* The number of pixel coordinate elements, */
-				/* given by NAXIS.                          */
-  char   (*dtype)[72];		/* For each axis, the distortion type.      */
-  int    ndp;			/* Number of DPja or DQia keywords, and the */
-  int    ndpmax;		/* number for which space was allocated.    */
-  struct dpkey *dp;		/* DPja or DQia keyvalues (not both).       */
-  double *maxdis;		/* For each axis, the maximum distortion.   */
-  double totdis;		/* The maximum combined distortion.         */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  int    *docorr;		/* For each axis, the mode of correction.   */
-  int    *Nhat;			/* For each axis, the number of coordinate  */
-				/* axes that form the independent variables */
-				/* of the distortion function.              */
-  int    **axmap;		/* For each axis, the axis mapping array.   */
-  double **offset;		/* For each axis, renormalization offsets.  */
-  double **scale;		/* For each axis, renormalization scales.   */
-  int    **iparm;		/* For each axis, the array of integer      */
-				/* distortion parameters.                   */
-  double **dparm;		/* For each axis, the array of floating     */
-				/* point distortion parameters.             */
-  int    i_naxis;		/* Dimension of the internal arrays.        */
-  int    ndis;			/* The number of distortion functions.      */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  int naxis;			// The number of pixel coordinate elements,
+				// given by NAXIS.
+  char   (*dtype)[72];		// For each axis, the distortion type.
+  int    ndp;			// Number of DPja or DQia keywords, and the
+  int    ndpmax;		// number for which space was allocated.
+  struct dpkey *dp;		// DPja or DQia keyvalues (not both).
+  double *maxdis;		// For each axis, the maximum distortion.
+  double totdis;		// The maximum combined distortion.
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  int    *docorr;		// For each axis, the mode of correction.
+  int    *Nhat;			// For each axis, the number of coordinate
+				// axes that form the independent variables
+				// of the distortion function.
+  int    **axmap;		// For each axis, the axis mapping array.
+  double **offset;		// For each axis, renormalization offsets.
+  double **scale;		// For each axis, renormalization scales.
+  int    **iparm;		// For each axis, the array of integer
+				// distortion parameters.
+  double **dparm;		// For each axis, the array of floating
+				// point distortion parameters.
+  int    i_naxis;		// Dimension of the internal arrays.
+  int    ndis;			// The number of distortion functions.
 
-  /* Error handling, if enabled.                                            */
-  /*------------------------------------------------------------------------*/
+  // Error handling, if enabled.
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private - the remainder are for internal use.                          */
-  /*------------------------------------------------------------------------*/
-  int (**disp2x)(DISP2X_ARGS);	/* For each axis, pointers to the           */
-  int (**disx2p)(DISX2P_ARGS);	/* distortion function and its inverse.     */
+  // Private - the remainder are for internal use.
+  //--------------------------------------------------------------------------
+  int (**disp2x)(DISP2X_ARGS);	// For each axis, pointers to the
+  int (**disx2p)(DISX2P_ARGS);	// distortion function and its inverse.
 
   double *tmpmem;
 
-  int    m_flag, m_naxis;	/* The remainder are for memory management. */
+  int    m_flag, m_naxis;	// The remainder are for memory management.
   char   (*m_dtype)[72];
   struct dpkey *m_dp;
   double *m_maxdis;
 };
 
-/* Size of the disprm struct in int units, used by the Fortran wrappers. */
+// Size of the disprm struct in int units, used by the Fortran wrappers.
 #define DISLEN (sizeof(struct disprm)/sizeof(int))
 
 
@@ -1134,4 +1152,4 @@ int diswarp(struct disprm *dis, const do
 }
 #endif
 
-#endif /* WCSLIB_DIS */
+#endif // WCSLIB_DIS
Index: astropy-4.2/cextern/wcslib/C/fitshdr.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/fitshdr.h
+++ astropy-4.2/cextern/wcslib/C/fitshdr.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: fitshdr.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: fitshdr.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -384,17 +381,17 @@ extern "C" {
 #define FITSHDR_KEYVALUE 0x02
 #define FITSHDR_COMMENT  0x04
 #define FITSHDR_KEYREC   0x08
-#define FITSHDR_CARD     0x08	/* Alias for backwards compatibility. */
+#define FITSHDR_CARD     0x08	// Alias for backwards compatibility.
 #define FITSHDR_TRAILER  0x10
 
 
 extern const char *fitshdr_errmsg[];
 
 enum fitshdr_errmsg_enum {
-  FITSHDRERR_SUCCESS      = 0,	/* Success.                                 */
-  FITSHDRERR_NULL_POINTER = 1,	/* Null fitskey pointer passed.             */
-  FITSHDRERR_MEMORY       = 2,	/* Memory allocation failed.                */
-  FITSHDRERR_FLEX_PARSER  = 3	/* Fatal error returned by Flex parser.     */
+  FITSHDRERR_SUCCESS      = 0,	// Success.
+  FITSHDRERR_NULL_POINTER = 1,	// Null fitskey pointer passed.
+  FITSHDRERR_MEMORY       = 2,	// Memory allocation failed.
+  FITSHDRERR_FLEX_PARSER  = 3	// Fatal error returned by Flex parser.
 };
 
 #ifdef WCSLIB_INT64
@@ -404,38 +401,38 @@ enum fitshdr_errmsg_enum {
 #endif
 
 
-/* Struct used for indexing the keywords. */
+// Struct used for indexing the keywords.
 struct fitskeyid {
-  char name[12];		/* Keyword name, null-terminated.           */
-  int  count;			/* Number of occurrences of keyword.        */
-  int  idx[2];			/* Indices into fitskey array.              */
+  char name[12];		// Keyword name, null-terminated.
+  int  count;			// Number of occurrences of keyword.
+  int  idx[2];			// Indices into fitskey array.
 };
 
-/* Size of the fitskeyid struct in int units, used by the Fortran wrappers. */
+// Size of the fitskeyid struct in int units, used by the Fortran wrappers.
 #define KEYIDLEN (sizeof(struct fitskeyid)/sizeof(int))
 
 
-/* Struct used for storing FITS keywords. */
+// Struct used for storing FITS keywords.
 struct fitskey {
-  int  keyno;			/* Header keyrecord sequence number (1-rel).*/
-  int  keyid;			/* Index into fitskeyid[].                  */
-  int  status;			/* Header keyrecord status bit flags.       */
-  char keyword[12];		/* Keyword name, null-filled.               */
-  int  type;			/* Keyvalue type (see above).               */
-  int  padding;			/* (Dummy inserted for alignment purposes.) */
+  int  keyno;			// Header keyrecord sequence number (1-rel).
+  int  keyid;			// Index into fitskeyid[].
+  int  status;			// Header keyrecord status bit flags.
+  char keyword[12];		// Keyword name, null-filled.
+  int  type;			// Keyvalue type (see above).
+  int  padding;			// (Dummy inserted for alignment purposes.)
   union {
-    int    i;			/* 32-bit integer and logical values.       */
-    int64  k;			/* 64-bit integer values.                   */
-    int    l[8];		/* Very long signed integer values.         */
-    double f;			/* Floating point values.                   */
-    double c[2];		/* Complex values.                          */
-    char   s[72];		/* String values, null-terminated.          */
-  } keyvalue;			/* Keyvalue.                                */
-  int  ulen;			/* Length of units string.                  */
-  char comment[84];		/* Comment (or keyrecord), null-terminated. */
+    int    i;			// 32-bit integer and logical values.
+    int64  k;			// 64-bit integer values.
+    int    l[8];		// Very long signed integer values.
+    double f;			// Floating point values.
+    double c[2];		// Complex values.
+    char   s[72];		// String values, null-terminated.
+  } keyvalue;			// Keyvalue.
+  int  ulen;			// Length of units string.
+  char comment[84];		// Comment (or keyrecord), null-terminated.
 };
 
-/* Size of the fitskey struct in int units, used by the Fortran wrappers. */
+// Size of the fitskey struct in int units, used by the Fortran wrappers.
 #define KEYLEN (sizeof(struct fitskey)/sizeof(int))
 
 
@@ -447,4 +444,4 @@ int fitshdr(const char header[], int nke
 }
 #endif
 
-#endif /* WCSLIB_FITSHDR */
+#endif // WCSLIB_FITSHDR
Index: astropy-4.2/cextern/wcslib/C/fitshdr.l
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/fitshdr.l
+++ astropy-4.2/cextern/wcslib/C/fitshdr.l
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: fitshdr.l,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: fitshdr.l,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
 * fitshdr.l is a Flex description file containing a lexical scanner
@@ -88,7 +85,7 @@ static int fitshdr_scanner(const char he
                            struct fitskeyid keyids[], int *nreject, \
                            struct fitskey **keys, yyscan_t yyscanner);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int fitshdr(
   const char header[],
@@ -112,7 +109,7 @@ int fitshdr(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define YY_DECL int fitshdr_scanner(const char header[], int nkeyrec, \
   int nkeyids, struct fitskeyid keyids[], int *nreject, \
@@ -131,15 +128,15 @@ int fitshdr(
 	  } \
 	}
 
-/* These global variables are required by YY_INPUT. */
+// These global variables are required by YY_INPUT.
 const char *fitshdr_hdr;
 int  fitshdr_nkeyrec;
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
+// Used in preempting the call to exit() by yy_fatal_error().
 jmp_buf fitshdr_abort_jmp_env;
 #define exit(status) longjmp(fitshdr_abort_jmp_env, status)
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *fitshdr_errmsg[] = {
    "Success",
    "Null fitskey pointer-pointer passed",
@@ -166,13 +163,13 @@ const char *fitshdr_errmsg[] = {
 	  return 1;
 	}
 	
-	/* Allocate memory for the required number of fitskey structs. */
-	/* Recall that calloc() initializes allocated memory to zero.  */
+	// Allocate memory for the required number of fitskey structs.
+	// Recall that calloc() initializes allocated memory to zero.
 	if (!(kptr = *keys = calloc(nkeyrec, sizeof(struct fitskey)))) {
 	  return 2;
 	}
 	
-	/* Initialize keyids[]. */
+	// Initialize keyids[].
 	iptr = keyids;
 	for (j = 0; j < nkeyids; j++, iptr++) {
 	  iptr->count  = 0;
@@ -184,7 +181,7 @@ const char *fitshdr_errmsg[] = {
 	continuation = 0;
 	end = 0;
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
+	// Return here via longjmp() invoked by yy_fatal_error().
 	if (setjmp(fitshdr_abort_jmp_env)) {
 	  return 3;
 	}
@@ -192,7 +189,7 @@ const char *fitshdr_errmsg[] = {
 	BEGIN(INITIAL);
 
 ^" "{80} {
-	  /* A completely blank keyrecord. */
+	  // A completely blank keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  yyless(0);
 	  blank = 1;
@@ -211,14 +208,14 @@ const char *fitshdr_errmsg[] = {
 	}
 
 ^END" "{5}=" "+ {
-	  /* Illegal END keyrecord. */
+	  // Illegal END keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYREC;
 	  BEGIN(VALUE);
 	}
 
 ^END" "{5} {
-	  /* Illegal END keyrecord. */
+	  // Illegal END keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYREC;
 	  BEGIN(COMMENT);
@@ -230,57 +227,57 @@ const char *fitshdr_errmsg[] = {
 	}
 
 ^CONTINUE"  "+{STRING} {
-	  /* Continued string keyvalue. */
+	  // Continued string keyvalue.
 	  strncpy(kptr->keyword, yytext, 8);
 	
 	  if (keyno > 0 && (kptr-1)->type%10 == 8) {
-	    /* Put back the string keyvalue. */
+	    // Put back the string keyvalue.
 	    for (k = 10; yytext[k] != '\''; k++);
 	    yyless(k);
 	    continuation = 1;
 	    BEGIN(VALUE);
 	
 	  } else {
-	    /* Not a valid continuation. */
+	    // Not a valid continuation.
 	    yyless(8);
 	    BEGIN(COMMENT);
 	  }
 	}
 
 ^{KEYWORD} {
-	  /* Keyword without value. */
+	  // Keyword without value.
 	  strncpy(kptr->keyword, yytext, 8);
 	  BEGIN(COMMENT);
 	}
 
 ^.{8}=" "+ {
-	  /* Illegal keyword, carry on regardless. */
+	  // Illegal keyword, carry on regardless.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYWORD;
 	  BEGIN(VALUE);
 	}
 
 ^.{8}	{
-	  /* Illegal keyword, carry on regardless. */
+	  // Illegal keyword, carry on regardless.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYWORD;
 	  BEGIN(COMMENT);
 	}
 
 <VALUE>" "*/\/ {
-	  /* Null keyvalue. */
+	  // Null keyvalue.
 	  BEGIN(INLINE);
 	}
 
 <VALUE>{LOGICAL} {
-	  /* Logical keyvalue. */
+	  // Logical keyvalue.
 	  kptr->type = 1;
 	  kptr->keyvalue.i = (*yytext == 'T');
 	  BEGIN(INLINE);
 	}
 
 <VALUE>{INT32} {
-	  /* 32-bit signed integer keyvalue. */
+	  // 32-bit signed integer keyvalue.
 	  kptr->type = 2;
 	  if (sscanf(yytext, "%d", &(kptr->keyvalue.i)) < 1) {
 	    kptr->status |= FITSHDR_KEYVALUE;
@@ -291,13 +288,13 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{INT64} {
-	  /* 64-bit signed integer keyvalue (up to 18 digits). */
+	  // 64-bit signed integer keyvalue (up to 18 digits).
 	  if (wcsutil_str2double(yytext, &dtmp)) {
 	    kptr->status |= FITSHDR_KEYVALUE;
 	    BEGIN(ERROR);
 	
 	  } else if (INT_MIN <= dtmp && dtmp <= INT_MAX) {
-	    /* Can be accomodated as a 32-bit signed integer. */
+	    // Can be accomodated as a 32-bit signed integer.
 	    kptr->type = 2;
 	    if (sscanf(yytext, "%d", &(kptr->keyvalue.i)) < 1) {
 	      kptr->status |= FITSHDR_KEYVALUE;
@@ -305,16 +302,16 @@ const char *fitshdr_errmsg[] = {
 	    }
 	
 	  } else {
-	    /* 64-bit signed integer. */
+	    // 64-bit signed integer.
 	    kptr->type = 3;
 	    #ifdef WCSLIB_INT64
-	      /* Native 64-bit integer is available. */
+	      // Native 64-bit integer is available.
 	      if (sscanf(yytext, "%lld", &(kptr->keyvalue.k)) < 1) {
 	        kptr->status |= FITSHDR_KEYVALUE;
 	        BEGIN(ERROR);
 	      }
 	    #else
-	      /* 64-bit integer (up to 18 digits) implemented as int[3]. */
+	      // 64-bit integer (up to 18 digits) implemented as int[3].
 	      kptr->keyvalue.k[2] = 0;
 	
 	      sprintf(ctmp, "%%%dd%%9d", yyleng-9);
@@ -332,12 +329,12 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{INTVL} {
-	  /* Very long integer keyvalue (and 19-digit int64). */
+	  // Very long integer keyvalue (and 19-digit int64).
 	  kptr->type = 4;
 	  strcpy(ctmp, yytext);
 	  k = yyleng;
 	  for (j = 0; j < 8; j++) {
-	    /* Read it backwards. */
+	    // Read it backwards.
 	    k -= 9;
 	    if (k < 0) k = 0;
 	    if (sscanf(ctmp+k, "%d", kptr->keyvalue.l+j) < 1) {
@@ -352,7 +349,7 @@ const char *fitshdr_errmsg[] = {
 	    ctmp[k] = '\0';
 	  }
 	
-	  /* Can it be accomodated as a 64-bit signed integer? */
+	  // Can it be accomodated as a 64-bit signed integer?
 	  if (j == 2 && abs(kptr->keyvalue.l[2]) <=  9 &&
 	                abs(kptr->keyvalue.l[1]) <=  223372036 &&
 	                    kptr->keyvalue.l[0]  <=  854775807 &&
@@ -360,7 +357,7 @@ const char *fitshdr_errmsg[] = {
 	    kptr->type = 3;
 	
 	    #ifdef WCSLIB_INT64
-	      /* Native 64-bit integer is available. */
+	      // Native 64-bit integer is available.
 	      kptr->keyvalue.l[2] = 0;
 	      if (sscanf(yytext, "%lld", &(kptr->keyvalue.k)) < 1) {
 	        kptr->status |= FITSHDR_KEYVALUE;
@@ -373,7 +370,7 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{FLOAT} {
-	  /* Float keyvalue. */
+	  // Float keyvalue.
 	  kptr->type = 5;
 	  if (wcsutil_str2double(yytext, &(kptr->keyvalue.f))) {
 	    kptr->status |= FITSHDR_KEYVALUE;
@@ -384,7 +381,7 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{ICOMPLX} {
-	  /* Integer complex keyvalue. */
+	  // Integer complex keyvalue.
 	  kptr->type = 6;
 	  if (sscanf(yytext, "(%lf,%lf)", kptr->keyvalue.c,
 	      kptr->keyvalue.c+1) < 2) {
@@ -396,7 +393,7 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{FCOMPLX} {
-	  /* Floating point complex keyvalue. */
+	  // Floating point complex keyvalue.
 	  kptr->type = 7;
 	
 	  for (cptr = ctmp, k = 1; yytext[k] != ','; cptr++, k++) {
@@ -423,12 +420,12 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <VALUE>{STRING} {
-	  /* String keyvalue. */
+	  // String keyvalue.
 	  kptr->type = 8;
 	  cptr = kptr->keyvalue.s;
 	  strcpy(cptr, yytext+1);
 	
-	  /* Squeeze out repeated quotes. */
+	  // Squeeze out repeated quotes.
 	  k = 0;
 	  for (j = 0; j < 72; j++) {
 	    if (k < j) {
@@ -446,7 +443,7 @@ const char *fitshdr_errmsg[] = {
 	  }
 	
 	  if (*cptr) {
-	    /* Retain the initial blank in all-blank strings. */
+	    // Retain the initial blank in all-blank strings.
 	    nullfill(cptr+1, 71);
 	  } else {
 	    nullfill(cptr, 72);
@@ -478,7 +475,7 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <INLINE>. {
-	  /* Keyvalue parsing must now also be suspect. */
+	  // Keyvalue parsing must now also be suspect.
 	  kptr->status |= FITSHDR_COMMENT;
 	  kptr->type = 0;
 	  BEGIN(ERROR);
@@ -512,14 +509,14 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <FLUSH>.*\n {
-	  /* Discard the rest of the input line. */
+	  // Discard the rest of the input line.
 	  kptr->keyno = ++keyno;
 	
-	  /* Null-fill the keyword. */
+	  // Null-fill the keyword.
 	  kptr->keyword[8] = '\0';
 	  nullfill(kptr->keyword, 12);
 	
-	  /* Do indexing. */
+	  // Do indexing.
 	  iptr = keyids;
 	  kptr->keyid = -1;
 	  for (j = 0; j < nkeyids; j++, iptr++) {
@@ -531,7 +528,7 @@ const char *fitshdr_errmsg[] = {
 	    }
 	
 	    if (k == 8) {
-	      /* Found a match. */
+	      // Found a match.
 	      iptr->count++;
 	      if (iptr->idx[0] == -1) {
 	        iptr->idx[0] = keyno-1;
@@ -544,9 +541,9 @@ const char *fitshdr_errmsg[] = {
 	    }
 	  }
 	
-	  /* Deal with continued strings. */
+	  // Deal with continued strings.
 	  if (continuation) {
-	    /* Tidy up the previous string keyvalue. */
+	    // Tidy up the previous string keyvalue.
 	    if ((kptr-1)->type == 8) (kptr-1)->type += 10;
 	    cptr = (kptr-1)->keyvalue.s;
 	    if (cptr[strlen(cptr)-1] == '&') cptr[strlen(cptr)-1] = '\0';
@@ -554,7 +551,7 @@ const char *fitshdr_errmsg[] = {
 	    kptr->type = (kptr-1)->type + 10;
 	  }
 	
-	  /* Check for keyrecords following the END keyrecord. */
+	  // Check for keyrecords following the END keyrecord.
 	  if (end && (end++ > 1) && !blank) {
 	    kptr->status |= FITSHDR_TRAILER;
 	  }
@@ -568,20 +565,20 @@ const char *fitshdr_errmsg[] = {
 	}
 
 <<EOF>>	{
-	  /* End-of-input. */
+	  // End-of-input.
 	  return 0;
 	}
 
 %%
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void nullfill(char cptr[], int len)
 
 {
   int j, k;
 
-  /* Null-fill the string. */
+  // Null-fill the string.
   for (j = 0; j < len; j++) {
     if (cptr[j] == '\0') {
       for (k = j+1; k < len; k++) {
Index: astropy-4.2/cextern/wcslib/C/flexed/README
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/flexed/README
+++ astropy-4.2/cextern/wcslib/C/flexed/README
@@ -1,5 +1,5 @@
 This directory contains C code generated by flex 2.6.4 under KDE Neon User
-Edition 5.17 (Kubuntu 18.04) from the Flex description files (*.l) in the
+Edition 5.19 (Kubuntu 18.04) from the Flex description files (*.l) in the
 parent directory.
 
 These pre-generated source files may be used during installation if
Index: astropy-4.2/cextern/wcslib/C/flexed/fitshdr.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/flexed/fitshdr.c
+++ astropy-4.2/cextern/wcslib/C/flexed/fitshdr.c
@@ -10233,9 +10233,8 @@ static const yy_state_type yy_NUL_trans[
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "fitshdr.l"
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -10252,11 +10251,9 @@ static const yy_state_type yy_NUL_trans[
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: fitshdr.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: fitshdr.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
 * fitshdr.l is a Flex description file containing a lexical scanner
@@ -10275,7 +10272,7 @@ static const yy_state_type yy_NUL_trans[
 /* Characters forming standard unit strings (jwBIQX are not used). */
 /* Exclusive start states. */
 
-#line 78 "fitshdr.l"
+#line 75 "fitshdr.l"
 #include <math.h>
 #include <limits.h>
 #include <setjmp.h>
@@ -10289,7 +10286,7 @@ static int fitshdr_scanner(const char he
                            struct fitskeyid keyids[], int *nreject, \
                            struct fitskey **keys, yyscan_t yyscanner);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int fitshdr(
   const char header[],
@@ -10313,7 +10310,7 @@ int fitshdr(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define YY_DECL int fitshdr_scanner(const char header[], int nkeyrec, \
   int nkeyids, struct fitskeyid keyids[], int *nreject, \
@@ -10332,23 +10329,23 @@ int fitshdr(
 	  } \
 	}
 
-/* These global variables are required by YY_INPUT. */
+// These global variables are required by YY_INPUT.
 const char *fitshdr_hdr;
 int  fitshdr_nkeyrec;
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
+// Used in preempting the call to exit() by yy_fatal_error().
 jmp_buf fitshdr_abort_jmp_env;
 #define exit(status) longjmp(fitshdr_abort_jmp_env, status)
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *fitshdr_errmsg[] = {
    "Success",
    "Null fitskey pointer-pointer passed",
    "Memory allocation failed",
    "Fatal error returned by Flex parser"};
 
-#line 10351 "fitshdr.c"
-#line 10352 "fitshdr.c"
+#line 10348 "fitshdr.c"
+#line 10349 "fitshdr.c"
 
 #define INITIAL 0
 #define VALUE 1
@@ -10599,9 +10596,9 @@ YY_DECL
 		}
 
 	{
-#line 151 "fitshdr.l"
+#line 148 "fitshdr.l"
 
-#line 153 "fitshdr.l"
+#line 150 "fitshdr.l"
 	char *cptr, ctmp[72];
 	int  blank, continuation, end, j, k, keyno;
 	double dtmp;
@@ -10619,13 +10616,13 @@ YY_DECL
 	  return 1;
 	}
 	
-	/* Allocate memory for the required number of fitskey structs. */
-	/* Recall that calloc() initializes allocated memory to zero.  */
+	// Allocate memory for the required number of fitskey structs.
+	// Recall that calloc() initializes allocated memory to zero.
 	if (!(kptr = *keys = calloc(nkeyrec, sizeof(struct fitskey)))) {
 	  return 2;
 	}
 	
-	/* Initialize keyids[]. */
+	// Initialize keyids[].
 	iptr = keyids;
 	for (j = 0; j < nkeyids; j++, iptr++) {
 	  iptr->count  = 0;
@@ -10637,14 +10634,14 @@ YY_DECL
 	continuation = 0;
 	end = 0;
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
+	// Return here via longjmp() invoked by yy_fatal_error().
 	if (setjmp(fitshdr_abort_jmp_env)) {
 	  return 3;
 	}
 	
 	BEGIN(INITIAL);
 
-#line 10648 "fitshdr.c"
+#line 10645 "fitshdr.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -10698,9 +10695,9 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 195 "fitshdr.l"
+#line 192 "fitshdr.l"
 {
-	  /* A completely blank keyrecord. */
+	  // A completely blank keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  yyless(0);
 	  blank = 1;
@@ -10709,7 +10706,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 203 "fitshdr.l"
+#line 200 "fitshdr.l"
 {
 	  strncpy(kptr->keyword, yytext, 8);
 	  BEGIN(COMMENT);
@@ -10717,7 +10714,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 208 "fitshdr.l"
+#line 205 "fitshdr.l"
 {
 	  strncpy(kptr->keyword, yytext, 8);
 	  end = 1;
@@ -10726,9 +10723,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 214 "fitshdr.l"
+#line 211 "fitshdr.l"
 {
-	  /* Illegal END keyrecord. */
+	  // Illegal END keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYREC;
 	  BEGIN(VALUE);
@@ -10736,9 +10733,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 221 "fitshdr.l"
+#line 218 "fitshdr.l"
 {
-	  /* Illegal END keyrecord. */
+	  // Illegal END keyrecord.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYREC;
 	  BEGIN(COMMENT);
@@ -10746,7 +10743,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 228 "fitshdr.l"
+#line 225 "fitshdr.l"
 {
 	  strncpy(kptr->keyword, yytext, 8);
 	  BEGIN(VALUE);
@@ -10755,20 +10752,20 @@ YY_RULE_SETUP
 case 7:
 /* rule 7 can match eol */
 YY_RULE_SETUP
-#line 233 "fitshdr.l"
+#line 230 "fitshdr.l"
 {
-	  /* Continued string keyvalue. */
+	  // Continued string keyvalue.
 	  strncpy(kptr->keyword, yytext, 8);
 	
 	  if (keyno > 0 && (kptr-1)->type%10 == 8) {
-	    /* Put back the string keyvalue. */
+	    // Put back the string keyvalue.
 	    for (k = 10; yytext[k] != '\''; k++);
 	    yyless(k);
 	    continuation = 1;
 	    BEGIN(VALUE);
 	
 	  } else {
-	    /* Not a valid continuation. */
+	    // Not a valid continuation.
 	    yyless(8);
 	    BEGIN(COMMENT);
 	  }
@@ -10776,18 +10773,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 251 "fitshdr.l"
+#line 248 "fitshdr.l"
 {
-	  /* Keyword without value. */
+	  // Keyword without value.
 	  strncpy(kptr->keyword, yytext, 8);
 	  BEGIN(COMMENT);
 	}
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 257 "fitshdr.l"
+#line 254 "fitshdr.l"
 {
-	  /* Illegal keyword, carry on regardless. */
+	  // Illegal keyword, carry on regardless.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYWORD;
 	  BEGIN(VALUE);
@@ -10795,9 +10792,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 264 "fitshdr.l"
+#line 261 "fitshdr.l"
 {
-	  /* Illegal keyword, carry on regardless. */
+	  // Illegal keyword, carry on regardless.
 	  strncpy(kptr->keyword, yytext, 8);
 	  kptr->status |= FITSHDR_KEYWORD;
 	  BEGIN(COMMENT);
@@ -10808,17 +10805,17 @@ case 11:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 271 "fitshdr.l"
+#line 268 "fitshdr.l"
 {
-	  /* Null keyvalue. */
+	  // Null keyvalue.
 	  BEGIN(INLINE);
 	}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 276 "fitshdr.l"
+#line 273 "fitshdr.l"
 {
-	  /* Logical keyvalue. */
+	  // Logical keyvalue.
 	  kptr->type = 1;
 	  kptr->keyvalue.i = (*yytext == 'T');
 	  BEGIN(INLINE);
@@ -10826,9 +10823,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 283 "fitshdr.l"
+#line 280 "fitshdr.l"
 {
-	  /* 32-bit signed integer keyvalue. */
+	  // 32-bit signed integer keyvalue.
 	  kptr->type = 2;
 	  if (sscanf(yytext, "%d", &(kptr->keyvalue.i)) < 1) {
 	    kptr->status |= FITSHDR_KEYVALUE;
@@ -10840,15 +10837,15 @@ YY_RULE_SETUP
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 294 "fitshdr.l"
+#line 291 "fitshdr.l"
 {
-	  /* 64-bit signed integer keyvalue (up to 18 digits). */
+	  // 64-bit signed integer keyvalue (up to 18 digits).
 	  if (wcsutil_str2double(yytext, &dtmp)) {
 	    kptr->status |= FITSHDR_KEYVALUE;
 	    BEGIN(ERROR);
 	
 	  } else if (INT_MIN <= dtmp && dtmp <= INT_MAX) {
-	    /* Can be accomodated as a 32-bit signed integer. */
+	    // Can be accomodated as a 32-bit signed integer.
 	    kptr->type = 2;
 	    if (sscanf(yytext, "%d", &(kptr->keyvalue.i)) < 1) {
 	      kptr->status |= FITSHDR_KEYVALUE;
@@ -10856,16 +10853,16 @@ YY_RULE_SETUP
 	    }
 	
 	  } else {
-	    /* 64-bit signed integer. */
+	    // 64-bit signed integer.
 	    kptr->type = 3;
 #ifdef WCSLIB_INT64
-	      /* Native 64-bit integer is available. */
+	      // Native 64-bit integer is available.
 	      if (sscanf(yytext, "%lld", &(kptr->keyvalue.k)) < 1) {
 	        kptr->status |= FITSHDR_KEYVALUE;
 	        BEGIN(ERROR);
 	      }
 #else
-	      /* 64-bit integer (up to 18 digits) implemented as int[3]. */
+	      // 64-bit integer (up to 18 digits) implemented as int[3].
 	      kptr->keyvalue.k[2] = 0;
 	
 	      sprintf(ctmp, "%%%dd%%9d", yyleng-9);
@@ -10884,14 +10881,14 @@ YY_RULE_SETUP
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 335 "fitshdr.l"
+#line 332 "fitshdr.l"
 {
-	  /* Very long integer keyvalue (and 19-digit int64). */
+	  // Very long integer keyvalue (and 19-digit int64).
 	  kptr->type = 4;
 	  strcpy(ctmp, yytext);
 	  k = yyleng;
 	  for (j = 0; j < 8; j++) {
-	    /* Read it backwards. */
+	    // Read it backwards.
 	    k -= 9;
 	    if (k < 0) k = 0;
 	    if (sscanf(ctmp+k, "%d", kptr->keyvalue.l+j) < 1) {
@@ -10906,7 +10903,7 @@ YY_RULE_SETUP
 	    ctmp[k] = '\0';
 	  }
 	
-	  /* Can it be accomodated as a 64-bit signed integer? */
+	  // Can it be accomodated as a 64-bit signed integer?
 	  if (j == 2 && abs(kptr->keyvalue.l[2]) <=  9 &&
 	                abs(kptr->keyvalue.l[1]) <=  223372036 &&
 	                    kptr->keyvalue.l[0]  <=  854775807 &&
@@ -10914,7 +10911,7 @@ YY_RULE_SETUP
 	    kptr->type = 3;
 	
 #ifdef WCSLIB_INT64
-	      /* Native 64-bit integer is available. */
+	      // Native 64-bit integer is available.
 	      kptr->keyvalue.l[2] = 0;
 	      if (sscanf(yytext, "%lld", &(kptr->keyvalue.k)) < 1) {
 	        kptr->status |= FITSHDR_KEYVALUE;
@@ -10928,9 +10925,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 376 "fitshdr.l"
+#line 373 "fitshdr.l"
 {
-	  /* Float keyvalue. */
+	  // Float keyvalue.
 	  kptr->type = 5;
 	  if (wcsutil_str2double(yytext, &(kptr->keyvalue.f))) {
 	    kptr->status |= FITSHDR_KEYVALUE;
@@ -10942,9 +10939,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 387 "fitshdr.l"
+#line 384 "fitshdr.l"
 {
-	  /* Integer complex keyvalue. */
+	  // Integer complex keyvalue.
 	  kptr->type = 6;
 	  if (sscanf(yytext, "(%lf,%lf)", kptr->keyvalue.c,
 	      kptr->keyvalue.c+1) < 2) {
@@ -10957,9 +10954,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 399 "fitshdr.l"
+#line 396 "fitshdr.l"
 {
-	  /* Floating point complex keyvalue. */
+	  // Floating point complex keyvalue.
 	  kptr->type = 7;
 	
 	  for (cptr = ctmp, k = 1; yytext[k] != ','; cptr++, k++) {
@@ -10988,14 +10985,14 @@ YY_RULE_SETUP
 case 19:
 /* rule 19 can match eol */
 YY_RULE_SETUP
-#line 426 "fitshdr.l"
+#line 423 "fitshdr.l"
 {
-	  /* String keyvalue. */
+	  // String keyvalue.
 	  kptr->type = 8;
 	  cptr = kptr->keyvalue.s;
 	  strcpy(cptr, yytext+1);
 	
-	  /* Squeeze out repeated quotes. */
+	  // Squeeze out repeated quotes.
 	  k = 0;
 	  for (j = 0; j < 72; j++) {
 	    if (k < j) {
@@ -11013,7 +11010,7 @@ YY_RULE_SETUP
 	  }
 	
 	  if (*cptr) {
-	    /* Retain the initial blank in all-blank strings. */
+	    // Retain the initial blank in all-blank strings.
 	    nullfill(cptr+1, 71);
 	  } else {
 	    nullfill(cptr, 72);
@@ -11024,7 +11021,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 459 "fitshdr.l"
+#line 456 "fitshdr.l"
 {
 	  kptr->status |= FITSHDR_KEYVALUE;
 	  BEGIN(ERROR);
@@ -11035,7 +11032,7 @@ case 21:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 464 "fitshdr.l"
+#line 461 "fitshdr.l"
 {
 	  BEGIN(FLUSH);
 	}
@@ -11045,21 +11042,21 @@ case 22:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 468 "fitshdr.l"
+#line 465 "fitshdr.l"
 {
 	  BEGIN(FLUSH);
 	}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 472 "fitshdr.l"
+#line 469 "fitshdr.l"
 {
 	  BEGIN(UNITS);
 	}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 476 "fitshdr.l"
+#line 473 "fitshdr.l"
 {
 	  kptr->status |= FITSHDR_COMMENT;
 	  BEGIN(ERROR);
@@ -11067,9 +11064,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 481 "fitshdr.l"
+#line 478 "fitshdr.l"
 {
-	  /* Keyvalue parsing must now also be suspect. */
+	  // Keyvalue parsing must now also be suspect.
 	  kptr->status |= FITSHDR_COMMENT;
 	  kptr->type = 0;
 	  BEGIN(ERROR);
@@ -11077,7 +11074,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 488 "fitshdr.l"
+#line 485 "fitshdr.l"
 {
 	  kptr->ulen = yyleng;
 	  yymore();
@@ -11086,7 +11083,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 494 "fitshdr.l"
+#line 491 "fitshdr.l"
 {
 	  yymore();
 	  BEGIN(COMMENT);
@@ -11094,7 +11091,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 499 "fitshdr.l"
+#line 496 "fitshdr.l"
 {
 	  strcpy(kptr->comment, yytext);
 	  nullfill(kptr->comment, 84);
@@ -11103,7 +11100,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 505 "fitshdr.l"
+#line 502 "fitshdr.l"
 {
 	  if (!continuation) kptr->type = -abs(kptr->type);
 	
@@ -11117,16 +11114,16 @@ YY_RULE_SETUP
 case 30:
 /* rule 30 can match eol */
 YY_RULE_SETUP
-#line 515 "fitshdr.l"
+#line 512 "fitshdr.l"
 {
-	  /* Discard the rest of the input line. */
+	  // Discard the rest of the input line.
 	  kptr->keyno = ++keyno;
 	
-	  /* Null-fill the keyword. */
+	  // Null-fill the keyword.
 	  kptr->keyword[8] = '\0';
 	  nullfill(kptr->keyword, 12);
 	
-	  /* Do indexing. */
+	  // Do indexing.
 	  iptr = keyids;
 	  kptr->keyid = -1;
 	  for (j = 0; j < nkeyids; j++, iptr++) {
@@ -11138,7 +11135,7 @@ YY_RULE_SETUP
 	    }
 	
 	    if (k == 8) {
-	      /* Found a match. */
+	      // Found a match.
 	      iptr->count++;
 	      if (iptr->idx[0] == -1) {
 	        iptr->idx[0] = keyno-1;
@@ -11151,9 +11148,9 @@ YY_RULE_SETUP
 	    }
 	  }
 	
-	  /* Deal with continued strings. */
+	  // Deal with continued strings.
 	  if (continuation) {
-	    /* Tidy up the previous string keyvalue. */
+	    // Tidy up the previous string keyvalue.
 	    if ((kptr-1)->type == 8) (kptr-1)->type += 10;
 	    cptr = (kptr-1)->keyvalue.s;
 	    if (cptr[strlen(cptr)-1] == '&') cptr[strlen(cptr)-1] = '\0';
@@ -11161,7 +11158,7 @@ YY_RULE_SETUP
 	    kptr->type = (kptr-1)->type + 10;
 	  }
 	
-	  /* Check for keyrecords following the END keyrecord. */
+	  // Check for keyrecords following the END keyrecord.
 	  if (end && (end++ > 1) && !blank) {
 	    kptr->status |= FITSHDR_TRAILER;
 	  }
@@ -11181,18 +11178,18 @@ case YY_STATE_EOF(UNITS):
 case YY_STATE_EOF(COMMENT):
 case YY_STATE_EOF(ERROR):
 case YY_STATE_EOF(FLUSH):
-#line 571 "fitshdr.l"
+#line 568 "fitshdr.l"
 {
-	  /* End-of-input. */
+	  // End-of-input.
 	  return 0;
 	}
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 576 "fitshdr.l"
+#line 573 "fitshdr.l"
 ECHO;
 	YY_BREAK
-#line 11196 "fitshdr.c"
+#line 11193 "fitshdr.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -12319,17 +12316,17 @@ void yyfree (void * ptr , yyscan_t yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 576 "fitshdr.l"
+#line 573 "fitshdr.l"
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void nullfill(char cptr[], int len)
 
 {
   int j, k;
 
-  /* Null-fill the string. */
+  // Null-fill the string.
   for (j = 0; j < len; j++) {
     if (cptr[j] == '\0') {
       for (k = j+1; k < len; k++) {
Index: astropy-4.2/cextern/wcslib/C/flexed/wcsbth.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/flexed/wcsbth.c
+++ astropy-4.2/cextern/wcslib/C/flexed/wcsbth.c
@@ -25388,9 +25388,8 @@ static const yy_state_type yy_NUL_trans[
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "wcsbth.l"
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -25407,11 +25406,9 @@ static const yy_state_type yy_NUL_trans[
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsbth.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsbth.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
 * wcsbth.l is a Flex description file containing the definition of a lexical
@@ -25473,7 +25470,7 @@ static const yy_state_type yy_NUL_trans[
 
 
 
-#line 115 "wcsbth.l"
+#line 112 "wcsbth.l"
 #include <math.h>
 #include <setjmp.h>
 #include <stddef.h>
@@ -25487,30 +25484,30 @@ static const yy_state_type yy_NUL_trans[
 #include "wcsprintf.h"
 #include "wcsutil.h"
 
-			/* Codes used for keyvalue data types. */
+			// Codes used for keyvalue data types.
 #define INTEGER 0
 #define FLOAT   1
 #define FLOAT2  2
 #define STRING  3
 
-			/* Bit masks used for keyword types:        */
-#define IMGAUX  0x1	/* Auxiliary image header, e.g. LONPOLEa or */
-			/* DATE-OBS.                                */
-#define IMGAXIS 0x2	/* Image header with axis number, e.g.      */
-			/* CTYPEia.                                 */
-#define IMGHEAD 0x3	/* IMGAUX | IMGAXIS, i.e. image header of   */
-			/* either type.                             */
-#define BIMGARR 0x4	/* Binary table image array, e.g. iCTYna.   */
-#define PIXLIST 0x8	/* Pixel list, e.g. TCTYna.                 */
-#define BINTAB  0xC	/* BIMGARR | PIXLIST, i.e. binary table     */
-			/* image array (without axis number) or     */
-			/* pixel list, e.g. LONPna or OBSGXn.       */
+			// Bit masks used for keyword types:
+#define IMGAUX  0x1	// Auxiliary image header, e.g. LONPOLEa or
+			// DATE-OBS.
+#define IMGAXIS 0x2	// Image header with axis number, e.g.
+			// CTYPEia.
+#define IMGHEAD 0x3	// IMGAUX | IMGAXIS, i.e. image header of
+			// either type.
+#define BIMGARR 0x4	// Binary table image array, e.g. iCTYna.
+#define PIXLIST 0x8	// Pixel list, e.g. TCTYna.
+#define BINTAB  0xC	// BIMGARR | PIXLIST, i.e. binary table
+			// image array (without axis number) or
+			// pixel list, e.g. LONPna or OBSGXn.
 
 static int wcsbth_scanner(char *header, int nkeyrec, int relax, int ctrl,
                           int keysel, int *colsel, int *nreject, int *nwcs,
                           struct wcsprm **wcs, yyscan_t yyscanner);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsbth(
   char *header,
@@ -25537,7 +25534,7 @@ int wcsbth(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define YY_DECL int wcsbth_scanner(char *header, int nkeyrec, int relax, \
  int ctrl, int keysel, int *colsel, int *nreject, int *nwcs, \
@@ -25556,18 +25553,18 @@ int wcsbth(
 	  } \
 	}
 
-/* A convenience macro to get around incompatibilities between unput() and
-   yyless(): put yytext followed by a blank back onto the input stream. */
+// A convenience macro to get around incompatibilities between unput() and
+// yyless(): put yytext followed by a blank back onto the input stream.
 #define WCSBTH_PUTBACK \
   sprintf(strtmp, "%s ", yytext); \
   iz = strlen(strtmp); \
   while (iz) unput(strtmp[--iz]);
 
-/* These global variables are required by YY_INPUT. */
+// These global variables are required by YY_INPUT.
 static char *wcsbth_hdr;
 static int  wcsbth_nkeyrec;
 
-/* Struct used internally for header bookkeeping. */
+// Struct used internally for header bookkeeping.
 struct wcsbth_alts {
   int ncol, ialt, icol, imgherit;
   short int (*arridx)[27];
@@ -25582,7 +25579,7 @@ struct wcsbth_alts {
   unsigned char pad2[2];
 };
 
-/* Internal helper functions. */
+// Internal helper functions.
 static int wcsbth_colax(struct wcsprm *wcs, struct wcsbth_alts *alts, int k,
         char a);
 static int wcsbth_final(struct wcsbth_alts *alts, int *nwcs,
@@ -25594,22 +25591,22 @@ static int wcsbth_init1(struct wcsbth_al
 static int wcsbth_pass1(int keytype, int i, int j, int n, int k, char a,
         char ptype, struct wcsbth_alts *alts);
 
-/* Helper functions for keywords that require special handling. */
+// Helper functions for keywords that require special handling.
 static int wcsbth_jdref(double *wptr,   const double *jdref);
 static int wcsbth_jdrefi(double *wptr,  const double *jdrefi);
 static int wcsbth_jdreff(double *wptr,  const double *jdreff);
 static int wcsbth_epoch(double *wptr,   const double *epoch);
 static int wcsbth_vsource(double *wptr, const double *vsource);
 
-/* Helper functions for keyvalue validity checking. */
+// Helper functions for keyvalue validity checking.
 static int wcsbth_timepixr(double timepixr);
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
+// Used in preempting the call to exit() by yy_fatal_error().
 jmp_buf wcsbth_abort_jmp_env;
 #define exit(status) longjmp(wcsbth_abort_jmp_env, status)
 
-#line 25612 "wcsbth.c"
-#line 25613 "wcsbth.c"
+#line 25609 "wcsbth.c"
+#line 25610 "wcsbth.c"
 
 #define INITIAL 0
 #define CCCCCia 1
@@ -25889,10 +25886,10 @@ YY_DECL
 		}
 
 	{
-#line 251 "wcsbth.l"
+#line 248 "wcsbth.l"
 
-#line 253 "wcsbth.l"
-	/* Keyword indices, as used in the WCS papers, e.g. iVn_ma, TPn_ka. */
+#line 250 "wcsbth.l"
+	// Keyword indices, as used in the WCS papers, e.g. iVn_ma, TPn_ka.
 	char a;
 	int  i, j, k, m, n;
 	
@@ -25911,37 +25908,37 @@ YY_DECL
 	int (*chekval)(double);
 	int (*special)(double *, const double *);
 	
-	/* The data structures produced. */
+	// The data structures produced.
 	*nwcs = 0;
 	*wcs  = 0x0;
 	
-	/* Parameters used to implement YY_INPUT. */
+	// Parameters used to implement YY_INPUT.
 	wcsbth_hdr = header;
 	wcsbth_nkeyrec = nkeyrec;
 	
-	/* Our handle on the input stream. */
+	// Our handle on the input stream.
 	keyrec = header;
 	hptr = header;
 	keep = 0x0;
 	
-	/* For keeping tallies of keywords found. */
+	// For keeping tallies of keywords found.
 	*nreject = 0;
 	nvalid = 0;
 	nother = 0;
 	
-	/* Used to flag image header keywords that are always inherited. */
+	// Used to flag image header keywords that are always inherited.
 	imherit = 1;
 	
-	/* If strict, then also reject. */
+	// If strict, then also reject.
 	if (relax & WCSHDR_strict) relax |= WCSHDR_reject;
 	
-	/* Keyword parameters. */
+	// Keyword parameters.
 	i = j = 0;
 	n = k = 0;
 	m = 0;
 	a = ' ';
 	
-	/* Header bookkeeping. */
+	// Header bookkeeping.
 	alts.ncol = 0;
 	alts.arridx  = 0x0;
 	alts.pixlist = 0x0;
@@ -25954,12 +25951,12 @@ YY_DECL
 	  alts.pixnps[ialt] = 0;
 	}
 	
-	/* For decoding the keyvalue. */
+	// For decoding the keyvalue.
 	keytype =  0;
 	valtype = -1;
 	vptr    = 0x0;
 	
-	/* For keywords that require special handling. */
+	// For keywords that require special handling.
 	altlin  = 0;
 	ptype   = ' ';
 	chekval = 0x0;
@@ -25967,7 +25964,7 @@ YY_DECL
 	auxprm  = 0;
 	naux    = 0;
 	
-	/* Selection by column number. */
+	// Selection by column number.
 	nsel = colsel ? colsel[0] : 0;
 	incl = (nsel > 0);
 	for (icol = 0; icol < 1000; icol++) {
@@ -25981,7 +25978,7 @@ YY_DECL
 	}
 	exclude[0] = 0;
 	
-	/* Selection by keyword type. */
+	// Selection by keyword type.
 	itmp = keysel;
 	keysel = 0;
 	if (itmp) {
@@ -25993,11 +25990,11 @@ YY_DECL
 	  keysel = IMGHEAD | BINTAB;
 	}
 	
-	/* Control variables. */
+	// Control variables.
 	ipass = 1;
 	npass = 2;
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
+	// Return here via longjmp() invoked by yy_fatal_error().
 	if (setjmp(wcsbth_abort_jmp_env)) {
 	  return 4;
 	}
@@ -26005,7 +26002,7 @@ YY_DECL
 	BEGIN(INITIAL);
 
 
-#line 26009 "wcsbth.c"
+#line 26006 "wcsbth.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -26053,7 +26050,7 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 366 "wcsbth.l"
+#line 363 "wcsbth.l"
 {
 	  if (ipass == 1) {
 	    if (alts.ncol == 0) {
@@ -26071,10 +26068,10 @@ YY_RULE_SETUP
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 381 "wcsbth.l"
+#line 378 "wcsbth.l"
 {
 	  if (!(keysel & IMGAXIS)) {
-	    /* Ignore this key type. */
+	    // Ignore this key type.
 	    BEGIN(DISCARD);
 	
 	  } else {
@@ -26099,28 +26096,28 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	  }
 	}
 	YY_BREAK
 case 3:
-#line 415 "wcsbth.l"
+#line 412 "wcsbth.l"
 case 4:
-#line 416 "wcsbth.l"
+#line 413 "wcsbth.l"
 case 5:
 YY_RULE_SETUP
-#line 416 "wcsbth.l"
+#line 413 "wcsbth.l"
 {
 	  keyname = "WCAXna";
 	
-	  /* Note that a blank in the sscanf() format string matches zero or
-	     more of them in the input. */
+	  // Note that a blank in the sscanf() format string matches zero or
+	  // more of them in the input.
 	  sscanf(yytext, "WCAX%d%c = %d", &n, &a, &i);
 	
 	  if (!(keysel & BIMGARR) || exclude[n]) {
-	    /* Ignore this key type or column. */
+	    // Ignore this key type or column.
 	    BEGIN(DISCARD);
 	
 	  } else if (i < 0) {
@@ -26139,16 +26136,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 6:
 /* rule 6 can match eol */
-#line 442 "wcsbth.l"
+#line 439 "wcsbth.l"
 case 7:
 /* rule 7 can match eol */
-#line 443 "wcsbth.l"
+#line 440 "wcsbth.l"
 case 8:
 /* rule 8 can match eol */
 YY_RULE_SETUP
-#line 443 "wcsbth.l"
+#line 440 "wcsbth.l"
 {
-	  /* Cross-reference supplier. */
+	  // Cross-reference supplier.
 	  keyname = "WCSTna";
 	  errmsg = "cross-references are not implemented";
 	  BEGIN(ERROR);
@@ -26156,16 +26153,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 9:
 /* rule 9 can match eol */
-#line 451 "wcsbth.l"
+#line 448 "wcsbth.l"
 case 10:
 /* rule 10 can match eol */
-#line 452 "wcsbth.l"
+#line 449 "wcsbth.l"
 case 11:
 /* rule 11 can match eol */
 YY_RULE_SETUP
-#line 452 "wcsbth.l"
+#line 449 "wcsbth.l"
 {
-	  /* Cross-reference consumer. */
+	  // Cross-reference consumer.
 	  keyname = "WCSXna";
 	  errmsg = "cross-references are not implemented";
 	  BEGIN(ERROR);
@@ -26173,7 +26170,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 459 "wcsbth.l"
+#line 456 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crpix);
@@ -26183,10 +26180,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 13:
-#line 468 "wcsbth.l"
+#line 465 "wcsbth.l"
 case 14:
 YY_RULE_SETUP
-#line 468 "wcsbth.l"
+#line 465 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crpix);
@@ -26203,10 +26200,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 15:
-#line 484 "wcsbth.l"
+#line 481 "wcsbth.l"
 case 16:
 YY_RULE_SETUP
-#line 484 "wcsbth.l"
+#line 481 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crpix);
@@ -26222,7 +26219,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 497 "wcsbth.l"
+#line 494 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pc);
@@ -26234,7 +26231,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 506 "wcsbth.l"
+#line 503 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pc);
@@ -26247,10 +26244,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 19:
-#line 518 "wcsbth.l"
+#line 515 "wcsbth.l"
 case 20:
 YY_RULE_SETUP
-#line 518 "wcsbth.l"
+#line 515 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pc);
@@ -26267,7 +26264,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 532 "wcsbth.l"
+#line 529 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cd);
@@ -26279,7 +26276,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 541 "wcsbth.l"
+#line 538 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cd);
@@ -26292,10 +26289,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 23:
-#line 553 "wcsbth.l"
+#line 550 "wcsbth.l"
 case 24:
 YY_RULE_SETUP
-#line 553 "wcsbth.l"
+#line 550 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cd);
@@ -26312,7 +26309,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 567 "wcsbth.l"
+#line 564 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cdelt);
@@ -26322,10 +26319,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 26:
-#line 576 "wcsbth.l"
+#line 573 "wcsbth.l"
 case 27:
 YY_RULE_SETUP
-#line 576 "wcsbth.l"
+#line 573 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cdelt);
@@ -26342,10 +26339,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 28:
-#line 592 "wcsbth.l"
+#line 589 "wcsbth.l"
 case 29:
 YY_RULE_SETUP
-#line 592 "wcsbth.l"
+#line 589 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cdelt);
@@ -26361,7 +26358,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 605 "wcsbth.l"
+#line 602 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crota);
@@ -26373,7 +26370,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 614 "wcsbth.l"
+#line 611 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crota);
@@ -26387,7 +26384,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 625 "wcsbth.l"
+#line 622 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crota);
@@ -26399,7 +26396,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 634 "wcsbth.l"
+#line 631 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cunit);
@@ -26409,10 +26406,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 34:
-#line 643 "wcsbth.l"
+#line 640 "wcsbth.l"
 case 35:
 YY_RULE_SETUP
-#line 643 "wcsbth.l"
+#line 640 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cunit);
@@ -26429,10 +26426,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 36:
-#line 659 "wcsbth.l"
+#line 656 "wcsbth.l"
 case 37:
 YY_RULE_SETUP
-#line 659 "wcsbth.l"
+#line 656 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cunit);
@@ -26448,7 +26445,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 672 "wcsbth.l"
+#line 669 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ctype);
@@ -26458,10 +26455,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 39:
-#line 681 "wcsbth.l"
+#line 678 "wcsbth.l"
 case 40:
 YY_RULE_SETUP
-#line 681 "wcsbth.l"
+#line 678 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ctype);
@@ -26478,10 +26475,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 41:
-#line 697 "wcsbth.l"
+#line 694 "wcsbth.l"
 case 42:
 YY_RULE_SETUP
-#line 697 "wcsbth.l"
+#line 694 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ctype);
@@ -26497,7 +26494,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 710 "wcsbth.l"
+#line 707 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crval);
@@ -26507,10 +26504,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 44:
-#line 719 "wcsbth.l"
+#line 716 "wcsbth.l"
 case 45:
 YY_RULE_SETUP
-#line 719 "wcsbth.l"
+#line 716 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crval);
@@ -26527,10 +26524,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 46:
-#line 735 "wcsbth.l"
+#line 732 "wcsbth.l"
 case 47:
 YY_RULE_SETUP
-#line 735 "wcsbth.l"
+#line 732 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crval);
@@ -26545,10 +26542,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 48:
-#line 749 "wcsbth.l"
+#line 746 "wcsbth.l"
 case 49:
 YY_RULE_SETUP
-#line 749 "wcsbth.l"
+#line 746 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.lonpole);
@@ -26564,10 +26561,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 50:
-#line 764 "wcsbth.l"
+#line 761 "wcsbth.l"
 case 51:
 YY_RULE_SETUP
-#line 764 "wcsbth.l"
+#line 761 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.latpole);
@@ -26583,12 +26580,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 52:
-#line 779 "wcsbth.l"
+#line 776 "wcsbth.l"
 case 53:
-#line 780 "wcsbth.l"
+#line 777 "wcsbth.l"
 case 54:
 YY_RULE_SETUP
-#line 780 "wcsbth.l"
+#line 777 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.restfrq);
@@ -26616,10 +26613,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 55:
-#line 807 "wcsbth.l"
+#line 804 "wcsbth.l"
 case 56:
 YY_RULE_SETUP
-#line 807 "wcsbth.l"
+#line 804 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.restwav);
@@ -26635,7 +26632,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 820 "wcsbth.l"
+#line 817 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -26646,10 +26643,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 58:
-#line 830 "wcsbth.l"
+#line 827 "wcsbth.l"
 case 59:
 YY_RULE_SETUP
-#line 830 "wcsbth.l"
+#line 827 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -26667,10 +26664,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 60:
-#line 847 "wcsbth.l"
+#line 844 "wcsbth.l"
 case 61:
 YY_RULE_SETUP
-#line 847 "wcsbth.l"
+#line 844 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -26687,7 +26684,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 861 "wcsbth.l"
+#line 858 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -26699,7 +26696,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 870 "wcsbth.l"
+#line 867 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ps);
@@ -26710,10 +26707,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 64:
-#line 880 "wcsbth.l"
+#line 877 "wcsbth.l"
 case 65:
 YY_RULE_SETUP
-#line 880 "wcsbth.l"
+#line 877 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ps);
@@ -26731,10 +26728,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 66:
-#line 897 "wcsbth.l"
+#line 894 "wcsbth.l"
 case 67:
 YY_RULE_SETUP
-#line 897 "wcsbth.l"
+#line 894 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ps);
@@ -26751,7 +26748,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 911 "wcsbth.l"
+#line 908 "wcsbth.l"
 {
 	  sscanf(yytext, "VELREF%c", &a);
 	
@@ -26780,7 +26777,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 937 "wcsbth.l"
+#line 934 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cname);
@@ -26790,10 +26787,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 70:
-#line 946 "wcsbth.l"
+#line 943 "wcsbth.l"
 case 71:
 YY_RULE_SETUP
-#line 946 "wcsbth.l"
+#line 943 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cname);
@@ -26811,10 +26808,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 72:
-#line 963 "wcsbth.l"
+#line 960 "wcsbth.l"
 case 73:
 YY_RULE_SETUP
-#line 963 "wcsbth.l"
+#line 960 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cname);
@@ -26831,7 +26828,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 977 "wcsbth.l"
+#line 974 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crder);
@@ -26841,10 +26838,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 75:
-#line 986 "wcsbth.l"
+#line 983 "wcsbth.l"
 case 76:
 YY_RULE_SETUP
-#line 986 "wcsbth.l"
+#line 983 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crder);
@@ -26862,10 +26859,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 77:
-#line 1003 "wcsbth.l"
+#line 1000 "wcsbth.l"
 case 78:
 YY_RULE_SETUP
-#line 1003 "wcsbth.l"
+#line 1000 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crder);
@@ -26882,7 +26879,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 1017 "wcsbth.l"
+#line 1014 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.csyer);
@@ -26892,10 +26889,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 80:
-#line 1026 "wcsbth.l"
+#line 1023 "wcsbth.l"
 case 81:
 YY_RULE_SETUP
-#line 1026 "wcsbth.l"
+#line 1023 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.csyer);
@@ -26913,10 +26910,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 82:
-#line 1043 "wcsbth.l"
+#line 1040 "wcsbth.l"
 case 83:
 YY_RULE_SETUP
-#line 1043 "wcsbth.l"
+#line 1040 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.csyer);
@@ -26933,7 +26930,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 1057 "wcsbth.l"
+#line 1054 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.czphs);
@@ -26943,10 +26940,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 85:
-#line 1066 "wcsbth.l"
+#line 1063 "wcsbth.l"
 case 86:
 YY_RULE_SETUP
-#line 1066 "wcsbth.l"
+#line 1063 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.czphs);
@@ -26964,10 +26961,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 87:
-#line 1083 "wcsbth.l"
+#line 1080 "wcsbth.l"
 case 88:
 YY_RULE_SETUP
-#line 1083 "wcsbth.l"
+#line 1080 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.czphs);
@@ -26984,7 +26981,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 1097 "wcsbth.l"
+#line 1094 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cperi);
@@ -26994,10 +26991,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 90:
-#line 1106 "wcsbth.l"
+#line 1103 "wcsbth.l"
 case 91:
 YY_RULE_SETUP
-#line 1106 "wcsbth.l"
+#line 1103 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cperi);
@@ -27015,10 +27012,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 92:
-#line 1123 "wcsbth.l"
+#line 1120 "wcsbth.l"
 case 93:
 YY_RULE_SETUP
-#line 1123 "wcsbth.l"
+#line 1120 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cperi);
@@ -27034,12 +27031,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 94:
-#line 1138 "wcsbth.l"
+#line 1135 "wcsbth.l"
 case 95:
-#line 1139 "wcsbth.l"
+#line 1136 "wcsbth.l"
 case 96:
 YY_RULE_SETUP
-#line 1139 "wcsbth.l"
+#line 1136 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.wcsname;
@@ -27061,7 +27058,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 1158 "wcsbth.l"
+#line 1155 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.timesys;
@@ -27071,10 +27068,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 98:
-#line 1167 "wcsbth.l"
+#line 1164 "wcsbth.l"
 case 99:
 YY_RULE_SETUP
-#line 1167 "wcsbth.l"
+#line 1164 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.trefpos;
@@ -27090,10 +27087,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 100:
-#line 1182 "wcsbth.l"
+#line 1179 "wcsbth.l"
 case 101:
 YY_RULE_SETUP
-#line 1182 "wcsbth.l"
+#line 1179 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.trefdir;
@@ -27110,7 +27107,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 1196 "wcsbth.l"
+#line 1193 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.plephem;
@@ -27121,7 +27118,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 1204 "wcsbth.l"
+#line 1201 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.timeunit;
@@ -27131,10 +27128,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 104:
-#line 1213 "wcsbth.l"
+#line 1210 "wcsbth.l"
 case 105:
 YY_RULE_SETUP
-#line 1213 "wcsbth.l"
+#line 1210 "wcsbth.l"
 {
 	  if ((yytext[4] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = STRING;
@@ -27153,10 +27150,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 106:
-#line 1231 "wcsbth.l"
+#line 1228 "wcsbth.l"
 case 107:
 YY_RULE_SETUP
-#line 1231 "wcsbth.l"
+#line 1228 "wcsbth.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT2;
@@ -27175,13 +27172,13 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 108:
-#line 1249 "wcsbth.l"
+#line 1246 "wcsbth.l"
 case 109:
 YY_RULE_SETUP
-#line 1249 "wcsbth.l"
+#line 1246 "wcsbth.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	
@@ -27198,10 +27195,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 110:
-#line 1268 "wcsbth.l"
+#line 1265 "wcsbth.l"
 case 111:
 YY_RULE_SETUP
-#line 1268 "wcsbth.l"
+#line 1265 "wcsbth.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT;
@@ -27220,10 +27217,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 112:
-#line 1286 "wcsbth.l"
+#line 1283 "wcsbth.l"
 case 113:
 YY_RULE_SETUP
-#line 1286 "wcsbth.l"
+#line 1283 "wcsbth.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT2;
@@ -27243,13 +27240,13 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 114:
-#line 1305 "wcsbth.l"
+#line 1302 "wcsbth.l"
 case 115:
 YY_RULE_SETUP
-#line 1305 "wcsbth.l"
+#line 1302 "wcsbth.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	    special = wcsbth_jdrefi;
@@ -27267,10 +27264,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 116:
-#line 1325 "wcsbth.l"
+#line 1322 "wcsbth.l"
 case 117:
 YY_RULE_SETUP
-#line 1325 "wcsbth.l"
+#line 1322 "wcsbth.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT;
@@ -27291,7 +27288,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 1343 "wcsbth.l"
+#line 1340 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timeoffs);
@@ -27302,7 +27299,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 1351 "wcsbth.l"
+#line 1348 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateobs;
@@ -27314,12 +27311,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 120:
-#line 1362 "wcsbth.l"
+#line 1359 "wcsbth.l"
 case 121:
-#line 1363 "wcsbth.l"
+#line 1360 "wcsbth.l"
 case 122:
 YY_RULE_SETUP
-#line 1363 "wcsbth.l"
+#line 1360 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateobs;
@@ -27341,7 +27338,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-#line 1382 "wcsbth.l"
+#line 1379 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.datebeg;
@@ -27352,10 +27349,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 124:
-#line 1392 "wcsbth.l"
+#line 1389 "wcsbth.l"
 case 125:
 YY_RULE_SETUP
-#line 1392 "wcsbth.l"
+#line 1389 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateavg;
@@ -27372,7 +27369,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 126:
 YY_RULE_SETUP
-#line 1406 "wcsbth.l"
+#line 1403 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateend;
@@ -27383,10 +27380,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 127:
-#line 1416 "wcsbth.l"
+#line 1413 "wcsbth.l"
 case 128:
 YY_RULE_SETUP
-#line 1416 "wcsbth.l"
+#line 1413 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdobs);
@@ -27404,7 +27401,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 129:
 YY_RULE_SETUP
-#line 1431 "wcsbth.l"
+#line 1428 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdbeg);
@@ -27415,10 +27412,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 130:
-#line 1441 "wcsbth.l"
+#line 1438 "wcsbth.l"
 case 131:
 YY_RULE_SETUP
-#line 1441 "wcsbth.l"
+#line 1438 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdavg);
@@ -27435,7 +27432,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 132:
 YY_RULE_SETUP
-#line 1455 "wcsbth.l"
+#line 1452 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdend);
@@ -27447,7 +27444,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 133:
 YY_RULE_SETUP
-#line 1464 "wcsbth.l"
+#line 1461 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.jepoch);
@@ -27459,7 +27456,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 134:
 YY_RULE_SETUP
-#line 1473 "wcsbth.l"
+#line 1470 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.bepoch);
@@ -27471,7 +27468,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 135:
 YY_RULE_SETUP
-#line 1482 "wcsbth.l"
+#line 1479 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.tstart);
@@ -27483,7 +27480,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 136:
 YY_RULE_SETUP
-#line 1491 "wcsbth.l"
+#line 1488 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.tstop);
@@ -27495,7 +27492,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 137:
 YY_RULE_SETUP
-#line 1500 "wcsbth.l"
+#line 1497 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.xposure);
@@ -27507,7 +27504,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 138:
 YY_RULE_SETUP
-#line 1509 "wcsbth.l"
+#line 1506 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.telapse);
@@ -27519,7 +27516,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 139:
 YY_RULE_SETUP
-#line 1518 "wcsbth.l"
+#line 1515 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timsyer);
@@ -27531,7 +27528,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 140:
 YY_RULE_SETUP
-#line 1527 "wcsbth.l"
+#line 1524 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timrder);
@@ -27543,7 +27540,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 141:
 YY_RULE_SETUP
-#line 1536 "wcsbth.l"
+#line 1533 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timedel);
@@ -27555,7 +27552,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 142:
 YY_RULE_SETUP
-#line 1545 "wcsbth.l"
+#line 1542 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timepixr);
@@ -27567,10 +27564,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 143:
-#line 1556 "wcsbth.l"
+#line 1553 "wcsbth.l"
 case 144:
 YY_RULE_SETUP
-#line 1556 "wcsbth.l"
+#line 1553 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo;
@@ -27586,10 +27583,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 145:
-#line 1571 "wcsbth.l"
+#line 1568 "wcsbth.l"
 case 146:
 YY_RULE_SETUP
-#line 1571 "wcsbth.l"
+#line 1568 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 1;
@@ -27605,10 +27602,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 147:
-#line 1586 "wcsbth.l"
+#line 1583 "wcsbth.l"
 case 148:
 YY_RULE_SETUP
-#line 1586 "wcsbth.l"
+#line 1583 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 2;
@@ -27625,7 +27622,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 149:
 YY_RULE_SETUP
-#line 1600 "wcsbth.l"
+#line 1597 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 3;
@@ -27636,12 +27633,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 150:
-#line 1610 "wcsbth.l"
+#line 1607 "wcsbth.l"
 case 151:
-#line 1611 "wcsbth.l"
+#line 1608 "wcsbth.l"
 case 152:
 YY_RULE_SETUP
-#line 1611 "wcsbth.l"
+#line 1608 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.obsgeo + 3;
@@ -27663,7 +27660,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 153:
 YY_RULE_SETUP
-#line 1630 "wcsbth.l"
+#line 1627 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 4;
@@ -27674,12 +27671,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 154:
-#line 1640 "wcsbth.l"
+#line 1637 "wcsbth.l"
 case 155:
-#line 1641 "wcsbth.l"
+#line 1638 "wcsbth.l"
 case 156:
 YY_RULE_SETUP
-#line 1641 "wcsbth.l"
+#line 1638 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.obsgeo + 3;
@@ -27701,7 +27698,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 157:
 YY_RULE_SETUP
-#line 1660 "wcsbth.l"
+#line 1657 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 5;
@@ -27712,12 +27709,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 158:
-#line 1670 "wcsbth.l"
+#line 1667 "wcsbth.l"
 case 159:
-#line 1671 "wcsbth.l"
+#line 1668 "wcsbth.l"
 case 160:
 YY_RULE_SETUP
-#line 1671 "wcsbth.l"
+#line 1668 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.obsgeo + 3;
@@ -27739,7 +27736,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 161:
 YY_RULE_SETUP
-#line 1690 "wcsbth.l"
+#line 1687 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.obsorbit;
@@ -27749,10 +27746,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 162:
-#line 1699 "wcsbth.l"
+#line 1696 "wcsbth.l"
 case 163:
 YY_RULE_SETUP
-#line 1699 "wcsbth.l"
+#line 1696 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.radesys;
@@ -27769,7 +27766,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 164:
 YY_RULE_SETUP
-#line 1713 "wcsbth.l"
+#line 1710 "wcsbth.l"
 {
 	  if (relax & WCSHDR_RADECSYS) {
 	    valtype = STRING;
@@ -27792,7 +27789,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 165:
 YY_RULE_SETUP
-#line 1733 "wcsbth.l"
+#line 1730 "wcsbth.l"
 {
 	  sscanf(yytext, "EPOCH%c", &a);
 	
@@ -27821,10 +27818,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 166:
-#line 1761 "wcsbth.l"
+#line 1758 "wcsbth.l"
 case 167:
 YY_RULE_SETUP
-#line 1761 "wcsbth.l"
+#line 1758 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.equinox);
@@ -27840,10 +27837,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 168:
-#line 1776 "wcsbth.l"
+#line 1773 "wcsbth.l"
 case 169:
 YY_RULE_SETUP
-#line 1776 "wcsbth.l"
+#line 1773 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.specsys;
@@ -27858,10 +27855,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 170:
-#line 1790 "wcsbth.l"
+#line 1787 "wcsbth.l"
 case 171:
 YY_RULE_SETUP
-#line 1790 "wcsbth.l"
+#line 1787 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.ssysobs;
@@ -27876,10 +27873,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 172:
-#line 1804 "wcsbth.l"
+#line 1801 "wcsbth.l"
 case 173:
 YY_RULE_SETUP
-#line 1804 "wcsbth.l"
+#line 1801 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.velosys);
@@ -27895,7 +27892,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 174:
 YY_RULE_SETUP
-#line 1817 "wcsbth.l"
+#line 1814 "wcsbth.l"
 {
 	  if (relax & WCSHDR_VSOURCE) {
 	    valtype = FLOAT;
@@ -27917,12 +27914,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 175:
-#line 1838 "wcsbth.l"
+#line 1835 "wcsbth.l"
 case 176:
-#line 1839 "wcsbth.l"
+#line 1836 "wcsbth.l"
 case 177:
 YY_RULE_SETUP
-#line 1839 "wcsbth.l"
+#line 1836 "wcsbth.l"
 {
 	  if (relax & WCSHDR_VSOURCE) {
 	    valtype = FLOAT;
@@ -27938,16 +27935,16 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 178:
-#line 1860 "wcsbth.l"
+#line 1857 "wcsbth.l"
 case 179:
 YY_RULE_SETUP
-#line 1860 "wcsbth.l"
+#line 1857 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.zsource);
@@ -27962,10 +27959,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 180:
-#line 1874 "wcsbth.l"
+#line 1871 "wcsbth.l"
 case 181:
 YY_RULE_SETUP
-#line 1874 "wcsbth.l"
+#line 1871 "wcsbth.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.ssyssrc;
@@ -27980,10 +27977,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 182:
-#line 1888 "wcsbth.l"
+#line 1885 "wcsbth.l"
 case 183:
 YY_RULE_SETUP
-#line 1888 "wcsbth.l"
+#line 1885 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.velangl);
@@ -27999,7 +27996,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 184:
 YY_RULE_SETUP
-#line 1901 "wcsbth.l"
+#line 1898 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -28011,7 +28008,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 185:
 YY_RULE_SETUP
-#line 1910 "wcsbth.l"
+#line 1907 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -28023,7 +28020,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 186:
 YY_RULE_SETUP
-#line 1919 "wcsbth.l"
+#line 1916 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -28035,7 +28032,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 187:
 YY_RULE_SETUP
-#line 1928 "wcsbth.l"
+#line 1925 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -28046,10 +28043,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 188:
-#line 1938 "wcsbth.l"
+#line 1935 "wcsbth.l"
 case 189:
 YY_RULE_SETUP
-#line 1938 "wcsbth.l"
+#line 1935 "wcsbth.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -28061,7 +28058,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 190:
 YY_RULE_SETUP
-#line 1947 "wcsbth.l"
+#line 1944 "wcsbth.l"
 {
 	  if (wcsbth_nkeyrec) {
 	    wcsbth_nkeyrec = 0;
@@ -28074,16 +28071,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 191:
 YY_RULE_SETUP
-#line 1957 "wcsbth.l"
+#line 1954 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 192:
-#line 1962 "wcsbth.l"
+#line 1959 "wcsbth.l"
 case 193:
 YY_RULE_SETUP
-#line 1962 "wcsbth.l"
+#line 1959 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    sscanf(yytext, "%d%c", &i, &a);
@@ -28097,26 +28094,26 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 194:
-#line 1981 "wcsbth.l"
+#line 1978 "wcsbth.l"
 case 195:
 YY_RULE_SETUP
-#line 1981 "wcsbth.l"
+#line 1978 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (relax & WCSHDR_reject) {
-	      /* Violates the basic FITS standard. */
+	      // Violates the basic FITS standard.
 	      errmsg = "indices in parameterized keywords must not have "
 	               "leading zeroes";
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -28127,21 +28124,21 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 196:
-#line 2007 "wcsbth.l"
+#line 2004 "wcsbth.l"
 case 197:
-#line 2008 "wcsbth.l"
+#line 2005 "wcsbth.l"
 case 198:
 YY_RULE_SETUP
-#line 2008 "wcsbth.l"
+#line 2005 "wcsbth.l"
 {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  if (relax & WCSHDR_ALLIMG) {
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
@@ -28153,41 +28150,41 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 199:
 YY_RULE_SETUP
-#line 2027 "wcsbth.l"
+#line 2024 "wcsbth.l"
 {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "keyword looks very much like %s but isn't",
 	      keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 200:
-#line 2042 "wcsbth.l"
+#line 2039 "wcsbth.l"
 case 201:
-#line 2043 "wcsbth.l"
+#line 2040 "wcsbth.l"
 case 202:
-#line 2044 "wcsbth.l"
+#line 2041 "wcsbth.l"
 case 203:
-#line 2045 "wcsbth.l"
+#line 2042 "wcsbth.l"
 case 204:
-#line 2046 "wcsbth.l"
+#line 2043 "wcsbth.l"
 case 205:
 YY_RULE_SETUP
-#line 2046 "wcsbth.l"
+#line 2043 "wcsbth.l"
 {
 	  if (vptr) {
 	    WCSBTH_PUTBACK;
@@ -28204,14 +28201,14 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 206:
-#line 2062 "wcsbth.l"
+#line 2059 "wcsbth.l"
 case 207:
-#line 2063 "wcsbth.l"
+#line 2060 "wcsbth.l"
 case 208:
-#line 2064 "wcsbth.l"
+#line 2061 "wcsbth.l"
 case 209:
 YY_RULE_SETUP
-#line 2064 "wcsbth.l"
+#line 2061 "wcsbth.l"
 {
 	  if (vptr && (relax & WCSHDR_LONGKEY)) {
 	    WCSBTH_PUTBACK;
@@ -28228,33 +28225,33 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 210:
-#line 2086 "wcsbth.l"
+#line 2083 "wcsbth.l"
 case 211:
 YY_RULE_SETUP
-#line 2086 "wcsbth.l"
+#line 2083 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 212:
-#line 2091 "wcsbth.l"
+#line 2088 "wcsbth.l"
 case 213:
-#line 2092 "wcsbth.l"
+#line 2089 "wcsbth.l"
 case 214:
-#line 2093 "wcsbth.l"
+#line 2090 "wcsbth.l"
 case 215:
-#line 2094 "wcsbth.l"
+#line 2091 "wcsbth.l"
 case 216:
-#line 2095 "wcsbth.l"
+#line 2092 "wcsbth.l"
 case 217:
 YY_RULE_SETUP
-#line 2095 "wcsbth.l"
+#line 2092 "wcsbth.l"
 {
 	  sscanf(yytext, "%d%c", &n, &a);
 	  if (YY_START == TCCCna) i = wcsbth_colax(*wcs, &alts, n, a);
@@ -28263,23 +28260,23 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 218:
-#line 2103 "wcsbth.l"
+#line 2100 "wcsbth.l"
 case 219:
 YY_RULE_SETUP
-#line 2103 "wcsbth.l"
+#line 2100 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 220:
-#line 2108 "wcsbth.l"
+#line 2105 "wcsbth.l"
 case 221:
-#line 2109 "wcsbth.l"
+#line 2106 "wcsbth.l"
 case 222:
-#line 2110 "wcsbth.l"
+#line 2107 "wcsbth.l"
 case 223:
 YY_RULE_SETUP
-#line 2110 "wcsbth.l"
+#line 2107 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    sscanf(yytext, "%d_%d%c", &i, &j, &a);
@@ -28293,54 +28290,54 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 224:
-#line 2129 "wcsbth.l"
+#line 2126 "wcsbth.l"
 case 225:
-#line 2130 "wcsbth.l"
+#line 2127 "wcsbth.l"
 case 226:
-#line 2131 "wcsbth.l"
+#line 2128 "wcsbth.l"
 case 227:
-#line 2132 "wcsbth.l"
+#line 2129 "wcsbth.l"
 case 228:
-#line 2133 "wcsbth.l"
+#line 2130 "wcsbth.l"
 case 229:
-#line 2134 "wcsbth.l"
+#line 2131 "wcsbth.l"
 case 230:
-#line 2135 "wcsbth.l"
+#line 2132 "wcsbth.l"
 case 231:
-#line 2136 "wcsbth.l"
+#line 2133 "wcsbth.l"
 case 232:
-#line 2137 "wcsbth.l"
+#line 2134 "wcsbth.l"
 case 233:
-#line 2138 "wcsbth.l"
+#line 2135 "wcsbth.l"
 case 234:
-#line 2139 "wcsbth.l"
+#line 2136 "wcsbth.l"
 case 235:
-#line 2140 "wcsbth.l"
+#line 2137 "wcsbth.l"
 case 236:
-#line 2141 "wcsbth.l"
+#line 2138 "wcsbth.l"
 case 237:
-#line 2142 "wcsbth.l"
+#line 2139 "wcsbth.l"
 case 238:
-#line 2143 "wcsbth.l"
+#line 2140 "wcsbth.l"
 case 239:
-#line 2144 "wcsbth.l"
+#line 2141 "wcsbth.l"
 case 240:
-#line 2145 "wcsbth.l"
+#line 2142 "wcsbth.l"
 case 241:
-#line 2146 "wcsbth.l"
+#line 2143 "wcsbth.l"
 case 242:
-#line 2147 "wcsbth.l"
+#line 2144 "wcsbth.l"
 case 243:
-#line 2148 "wcsbth.l"
+#line 2145 "wcsbth.l"
 case 244:
 YY_RULE_SETUP
-#line 2148 "wcsbth.l"
+#line 2145 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (((altlin == 1) && (relax & WCSHDR_PC0i_0ja)) ||
@@ -28355,7 +28352,7 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -28366,35 +28363,35 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 245:
-#line 2179 "wcsbth.l"
+#line 2176 "wcsbth.l"
 case 246:
-#line 2180 "wcsbth.l"
+#line 2177 "wcsbth.l"
 case 247:
-#line 2181 "wcsbth.l"
+#line 2178 "wcsbth.l"
 case 248:
-#line 2182 "wcsbth.l"
+#line 2179 "wcsbth.l"
 case 249:
-#line 2183 "wcsbth.l"
+#line 2180 "wcsbth.l"
 case 250:
-#line 2184 "wcsbth.l"
+#line 2181 "wcsbth.l"
 case 251:
-#line 2185 "wcsbth.l"
+#line 2182 "wcsbth.l"
 case 252:
-#line 2186 "wcsbth.l"
+#line 2183 "wcsbth.l"
 case 253:
-#line 2187 "wcsbth.l"
+#line 2184 "wcsbth.l"
 case 254:
 YY_RULE_SETUP
-#line 2187 "wcsbth.l"
+#line 2184 "wcsbth.l"
 {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  if (relax & WCSHDR_ALLIMG) {
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
@@ -28406,32 +28403,32 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 255:
-#line 2207 "wcsbth.l"
+#line 2204 "wcsbth.l"
 case 256:
-#line 2208 "wcsbth.l"
+#line 2205 "wcsbth.l"
 case 257:
-#line 2209 "wcsbth.l"
+#line 2206 "wcsbth.l"
 case 258:
-#line 2210 "wcsbth.l"
+#line 2207 "wcsbth.l"
 case 259:
-#line 2211 "wcsbth.l"
+#line 2208 "wcsbth.l"
 case 260:
-#line 2212 "wcsbth.l"
+#line 2209 "wcsbth.l"
 case 261:
-#line 2213 "wcsbth.l"
+#line 2210 "wcsbth.l"
 case 262:
-#line 2214 "wcsbth.l"
+#line 2211 "wcsbth.l"
 case 263:
-#line 2215 "wcsbth.l"
+#line 2212 "wcsbth.l"
 case 264:
 YY_RULE_SETUP
-#line 2215 "wcsbth.l"
+#line 2212 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    errmsg = errtxt;
@@ -28446,16 +28443,16 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 265:
 YY_RULE_SETUP
-#line 2234 "wcsbth.l"
+#line 2231 "wcsbth.l"
 {
-	  /* This covers the defunct forms CD00i00j and PC00i00j. */
+	  // This covers the defunct forms CD00i00j and PC00i00j.
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (((altlin == 1) && (relax & WCSHDR_PC00i00j)) ||
 	        ((altlin == 2) && (relax & WCSHDR_CD00i00j))) {
@@ -28472,7 +28469,7 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -28483,25 +28480,25 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 266:
 YY_RULE_SETUP
-#line 2268 "wcsbth.l"
+#line 2265 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 267:
-#line 2273 "wcsbth.l"
+#line 2270 "wcsbth.l"
 case 268:
-#line 2274 "wcsbth.l"
+#line 2271 "wcsbth.l"
 case 269:
 YY_RULE_SETUP
-#line 2274 "wcsbth.l"
+#line 2271 "wcsbth.l"
 {
 	  sscanf(yytext, "%d%c", &n, &a);
 	  keytype = BIMGARR;
@@ -28509,18 +28506,18 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 270:
-#line 2281 "wcsbth.l"
+#line 2278 "wcsbth.l"
 case 271:
-#line 2282 "wcsbth.l"
+#line 2279 "wcsbth.l"
 case 272:
-#line 2283 "wcsbth.l"
+#line 2280 "wcsbth.l"
 case 273:
-#line 2284 "wcsbth.l"
+#line 2281 "wcsbth.l"
 case 274:
-#line 2285 "wcsbth.l"
+#line 2282 "wcsbth.l"
 case 275:
 YY_RULE_SETUP
-#line 2285 "wcsbth.l"
+#line 2282 "wcsbth.l"
 {
 	  if (relax & WCSHDR_LONGKEY) {
 	    WCSBTH_PUTBACK;
@@ -28532,31 +28529,31 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 276:
 YY_RULE_SETUP
-#line 2301 "wcsbth.l"
+#line 2298 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 277:
-#line 2306 "wcsbth.l"
+#line 2303 "wcsbth.l"
 case 278:
-#line 2307 "wcsbth.l"
+#line 2304 "wcsbth.l"
 case 279:
-#line 2308 "wcsbth.l"
+#line 2305 "wcsbth.l"
 case 280:
-#line 2309 "wcsbth.l"
+#line 2306 "wcsbth.l"
 case 281:
-#line 2310 "wcsbth.l"
+#line 2307 "wcsbth.l"
 case 282:
 YY_RULE_SETUP
-#line 2310 "wcsbth.l"
+#line 2307 "wcsbth.l"
 {
 	  sscanf(yytext, "%d_%d%c", &n, &k, &a);
 	  i = wcsbth_colax(*wcs, &alts, n, a);
@@ -28566,14 +28563,14 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 283:
-#line 2319 "wcsbth.l"
+#line 2316 "wcsbth.l"
 case 284:
-#line 2320 "wcsbth.l"
+#line 2317 "wcsbth.l"
 case 285:
-#line 2321 "wcsbth.l"
+#line 2318 "wcsbth.l"
 case 286:
 YY_RULE_SETUP
-#line 2321 "wcsbth.l"
+#line 2318 "wcsbth.l"
 {
 	  sscanf(yytext, "%d_%d", &n, &k);
 	  a = ' ';
@@ -28585,18 +28582,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 287:
 YY_RULE_SETUP
-#line 2330 "wcsbth.l"
+#line 2327 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 288:
-#line 2335 "wcsbth.l"
+#line 2332 "wcsbth.l"
 case 289:
-#line 2336 "wcsbth.l"
+#line 2333 "wcsbth.l"
 case 290:
 YY_RULE_SETUP
-#line 2336 "wcsbth.l"
+#line 2333 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    a = ' ';
@@ -28615,7 +28612,7 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -28626,51 +28623,51 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 291:
 YY_RULE_SETUP
-#line 2370 "wcsbth.l"
+#line 2367 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    yyless(0);
 	    BEGIN(CCCCCia);
 	  } else {
-	    /* Let it go. */
+	    // Let it go.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 292:
-#line 2381 "wcsbth.l"
+#line 2378 "wcsbth.l"
 case 293:
-#line 2382 "wcsbth.l"
+#line 2379 "wcsbth.l"
 case 294:
-#line 2383 "wcsbth.l"
+#line 2380 "wcsbth.l"
 case 295:
-#line 2384 "wcsbth.l"
+#line 2381 "wcsbth.l"
 case 296:
-#line 2385 "wcsbth.l"
+#line 2382 "wcsbth.l"
 case 297:
 YY_RULE_SETUP
-#line 2385 "wcsbth.l"
+#line 2382 "wcsbth.l"
 {
 	  WCSBTH_PUTBACK;
 	  BEGIN((YY_START == iCROTn) ? iCCCna : TCCCna);
 	}
 	YY_BREAK
 case 298:
-#line 2391 "wcsbth.l"
+#line 2388 "wcsbth.l"
 case 299:
-#line 2392 "wcsbth.l"
+#line 2389 "wcsbth.l"
 case 300:
-#line 2393 "wcsbth.l"
+#line 2390 "wcsbth.l"
 case 301:
 YY_RULE_SETUP
-#line 2393 "wcsbth.l"
+#line 2390 "wcsbth.l"
 {
 	  if (relax & WCSHDR_CROTAia) {
 	    WCSBTH_PUTBACK;
@@ -28683,27 +28680,27 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 302:
-#line 2411 "wcsbth.l"
+#line 2408 "wcsbth.l"
 case 303:
 YY_RULE_SETUP
-#line 2411 "wcsbth.l"
+#line 2408 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 304:
-#line 2416 "wcsbth.l"
+#line 2413 "wcsbth.l"
 case 305:
 YY_RULE_SETUP
-#line 2416 "wcsbth.l"
+#line 2413 "wcsbth.l"
 {
-	  /* Image-header keyword. */
+	  // Image-header keyword.
 	  if (imherit || (relax & (WCSHDR_AUXIMG | WCSHDR_ALLIMG))) {
 	    if (YY_START == CCCCCCCa) {
 	      sscanf(yytext, "%c", &a);
@@ -28721,39 +28718,39 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 306:
 YY_RULE_SETUP
-#line 2440 "wcsbth.l"
+#line 2437 "wcsbth.l"
 {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "invalid alternate code, keyword resembles %s "
 	      "but isn't", keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 307:
-#line 2455 "wcsbth.l"
+#line 2452 "wcsbth.l"
 case 308:
-#line 2456 "wcsbth.l"
+#line 2453 "wcsbth.l"
 case 309:
-#line 2457 "wcsbth.l"
+#line 2454 "wcsbth.l"
 case 310:
-#line 2458 "wcsbth.l"
+#line 2455 "wcsbth.l"
 case 311:
 YY_RULE_SETUP
-#line 2458 "wcsbth.l"
+#line 2455 "wcsbth.l"
 {
 	  sscanf(yytext, "%d%c", &n, &a);
 	  keytype = BINTAB;
@@ -28762,7 +28759,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 312:
 YY_RULE_SETUP
-#line 2464 "wcsbth.l"
+#line 2461 "wcsbth.l"
 {
 	  sscanf(yytext, "%d", &n);
 	  a = ' ';
@@ -28771,29 +28768,29 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 313:
-#line 2472 "wcsbth.l"
+#line 2469 "wcsbth.l"
 case 314:
 YY_RULE_SETUP
-#line 2472 "wcsbth.l"
+#line 2469 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 315:
-#line 2477 "wcsbth.l"
+#line 2474 "wcsbth.l"
 case 316:
-#line 2478 "wcsbth.l"
+#line 2475 "wcsbth.l"
 case 317:
-#line 2479 "wcsbth.l"
+#line 2476 "wcsbth.l"
 case 318:
-#line 2480 "wcsbth.l"
+#line 2477 "wcsbth.l"
 case 319:
-#line 2481 "wcsbth.l"
+#line 2478 "wcsbth.l"
 case 320:
-#line 2482 "wcsbth.l"
+#line 2479 "wcsbth.l"
 case 321:
 YY_RULE_SETUP
-#line 2482 "wcsbth.l"
+#line 2479 "wcsbth.l"
 {
 	  sscanf(yytext, "%d", &n);
 	  a = 0;
@@ -28802,25 +28799,25 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 322:
-#line 2490 "wcsbth.l"
+#line 2487 "wcsbth.l"
 case 323:
 YY_RULE_SETUP
-#line 2490 "wcsbth.l"
+#line 2487 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 324:
-#line 2495 "wcsbth.l"
+#line 2492 "wcsbth.l"
 case 325:
-#line 2496 "wcsbth.l"
+#line 2493 "wcsbth.l"
 case 326:
-#line 2497 "wcsbth.l"
+#line 2494 "wcsbth.l"
 case 327:
 YY_RULE_SETUP
-#line 2497 "wcsbth.l"
+#line 2494 "wcsbth.l"
 {
-	  /* Image-header keyword. */
+	  // Image-header keyword.
 	  if (relax & WCSHDR_ALLIMG) {
 	    sscanf(yytext, "%d_%d%c", &i, &m, &a);
 	    keytype = IMGAXIS;
@@ -28833,54 +28830,54 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 328:
-#line 2517 "wcsbth.l"
+#line 2514 "wcsbth.l"
 case 329:
-#line 2518 "wcsbth.l"
+#line 2515 "wcsbth.l"
 case 330:
-#line 2519 "wcsbth.l"
+#line 2516 "wcsbth.l"
 case 331:
-#line 2520 "wcsbth.l"
+#line 2517 "wcsbth.l"
 case 332:
-#line 2521 "wcsbth.l"
+#line 2518 "wcsbth.l"
 case 333:
-#line 2522 "wcsbth.l"
+#line 2519 "wcsbth.l"
 case 334:
-#line 2523 "wcsbth.l"
+#line 2520 "wcsbth.l"
 case 335:
-#line 2524 "wcsbth.l"
+#line 2521 "wcsbth.l"
 case 336:
-#line 2525 "wcsbth.l"
+#line 2522 "wcsbth.l"
 case 337:
-#line 2526 "wcsbth.l"
+#line 2523 "wcsbth.l"
 case 338:
-#line 2527 "wcsbth.l"
+#line 2524 "wcsbth.l"
 case 339:
-#line 2528 "wcsbth.l"
+#line 2525 "wcsbth.l"
 case 340:
-#line 2529 "wcsbth.l"
+#line 2526 "wcsbth.l"
 case 341:
-#line 2530 "wcsbth.l"
+#line 2527 "wcsbth.l"
 case 342:
-#line 2531 "wcsbth.l"
+#line 2528 "wcsbth.l"
 case 343:
-#line 2532 "wcsbth.l"
+#line 2529 "wcsbth.l"
 case 344:
-#line 2533 "wcsbth.l"
+#line 2530 "wcsbth.l"
 case 345:
-#line 2534 "wcsbth.l"
+#line 2531 "wcsbth.l"
 case 346:
-#line 2535 "wcsbth.l"
+#line 2532 "wcsbth.l"
 case 347:
-#line 2536 "wcsbth.l"
+#line 2533 "wcsbth.l"
 case 348:
 YY_RULE_SETUP
-#line 2536 "wcsbth.l"
+#line 2533 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (((valtype == FLOAT)  && (relax & WCSHDR_PV0i_0ma)) ||
@@ -28895,7 +28892,7 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -28906,36 +28903,36 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 349:
-#line 2567 "wcsbth.l"
+#line 2564 "wcsbth.l"
 case 350:
-#line 2568 "wcsbth.l"
+#line 2565 "wcsbth.l"
 case 351:
-#line 2569 "wcsbth.l"
+#line 2566 "wcsbth.l"
 case 352:
-#line 2570 "wcsbth.l"
+#line 2567 "wcsbth.l"
 case 353:
-#line 2571 "wcsbth.l"
+#line 2568 "wcsbth.l"
 case 354:
-#line 2572 "wcsbth.l"
+#line 2569 "wcsbth.l"
 case 355:
-#line 2573 "wcsbth.l"
+#line 2570 "wcsbth.l"
 case 356:
-#line 2574 "wcsbth.l"
+#line 2571 "wcsbth.l"
 case 357:
-#line 2575 "wcsbth.l"
+#line 2572 "wcsbth.l"
 case 358:
 YY_RULE_SETUP
-#line 2575 "wcsbth.l"
+#line 2572 "wcsbth.l"
 {
 	  if (relax & WCSHDR_ALLIMG) {
-	    /* Anything that has fallen through to this point must contain */
-	    /* an invalid parameter. */
+	    // Anything that has fallen through to this point must contain
+	    // an invalid parameter.
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
 	
@@ -28946,32 +28943,32 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 359:
-#line 2595 "wcsbth.l"
+#line 2592 "wcsbth.l"
 case 360:
-#line 2596 "wcsbth.l"
+#line 2593 "wcsbth.l"
 case 361:
-#line 2597 "wcsbth.l"
+#line 2594 "wcsbth.l"
 case 362:
-#line 2598 "wcsbth.l"
+#line 2595 "wcsbth.l"
 case 363:
-#line 2599 "wcsbth.l"
+#line 2596 "wcsbth.l"
 case 364:
-#line 2600 "wcsbth.l"
+#line 2597 "wcsbth.l"
 case 365:
-#line 2601 "wcsbth.l"
+#line 2598 "wcsbth.l"
 case 366:
-#line 2602 "wcsbth.l"
+#line 2599 "wcsbth.l"
 case 367:
-#line 2603 "wcsbth.l"
+#line 2600 "wcsbth.l"
 case 368:
 YY_RULE_SETUP
-#line 2603 "wcsbth.l"
+#line 2600 "wcsbth.l"
 {
 	  errmsg = errtxt;
 	  sprintf(errmsg, "%s keyword must use an underscore, not a dash",
@@ -28981,36 +28978,36 @@ YY_RULE_SETUP
 	YY_BREAK
 case 369:
 YY_RULE_SETUP
-#line 2610 "wcsbth.l"
+#line 2607 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 370:
-#line 2615 "wcsbth.l"
+#line 2612 "wcsbth.l"
 case 371:
-#line 2616 "wcsbth.l"
+#line 2613 "wcsbth.l"
 case 372:
-#line 2617 "wcsbth.l"
+#line 2614 "wcsbth.l"
 case 373:
-#line 2618 "wcsbth.l"
+#line 2615 "wcsbth.l"
 case 374:
-#line 2619 "wcsbth.l"
+#line 2616 "wcsbth.l"
 case 375:
-#line 2620 "wcsbth.l"
+#line 2617 "wcsbth.l"
 case 376:
-#line 2621 "wcsbth.l"
+#line 2618 "wcsbth.l"
 case 377:
-#line 2622 "wcsbth.l"
+#line 2619 "wcsbth.l"
 case 378:
-#line 2623 "wcsbth.l"
+#line 2620 "wcsbth.l"
 case 379:
-#line 2624 "wcsbth.l"
+#line 2621 "wcsbth.l"
 case 380:
-#line 2625 "wcsbth.l"
+#line 2622 "wcsbth.l"
 case 381:
 YY_RULE_SETUP
-#line 2625 "wcsbth.l"
+#line 2622 "wcsbth.l"
 {
 	  if (relax & WCSHDR_LONGKEY) {
 	    WCSBTH_PUTBACK;
@@ -29022,45 +29019,45 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 382:
-#line 2642 "wcsbth.l"
+#line 2639 "wcsbth.l"
 case 383:
 YY_RULE_SETUP
-#line 2642 "wcsbth.l"
+#line 2639 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 384:
-#line 2647 "wcsbth.l"
+#line 2644 "wcsbth.l"
 case 385:
-#line 2648 "wcsbth.l"
+#line 2645 "wcsbth.l"
 case 386:
-#line 2649 "wcsbth.l"
+#line 2646 "wcsbth.l"
 case 387:
-#line 2650 "wcsbth.l"
+#line 2647 "wcsbth.l"
 case 388:
-#line 2651 "wcsbth.l"
+#line 2648 "wcsbth.l"
 case 389:
-#line 2652 "wcsbth.l"
+#line 2649 "wcsbth.l"
 case 390:
-#line 2653 "wcsbth.l"
+#line 2650 "wcsbth.l"
 case 391:
-#line 2654 "wcsbth.l"
+#line 2651 "wcsbth.l"
 case 392:
-#line 2655 "wcsbth.l"
+#line 2652 "wcsbth.l"
 case 393:
-#line 2656 "wcsbth.l"
+#line 2653 "wcsbth.l"
 case 394:
-#line 2657 "wcsbth.l"
+#line 2654 "wcsbth.l"
 case 395:
 YY_RULE_SETUP
-#line 2657 "wcsbth.l"
+#line 2654 "wcsbth.l"
 {
 	  sscanf(yytext, "%d_%d%c", &n, &m, &a);
 	  if (YY_START == TCn_ma) i = wcsbth_colax(*wcs, &alts, n, a);
@@ -29069,24 +29066,24 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 396:
-#line 2665 "wcsbth.l"
+#line 2662 "wcsbth.l"
 case 397:
-#line 2666 "wcsbth.l"
+#line 2663 "wcsbth.l"
 case 398:
-#line 2667 "wcsbth.l"
+#line 2664 "wcsbth.l"
 case 399:
-#line 2668 "wcsbth.l"
+#line 2665 "wcsbth.l"
 case 400:
-#line 2669 "wcsbth.l"
+#line 2666 "wcsbth.l"
 case 401:
-#line 2670 "wcsbth.l"
+#line 2667 "wcsbth.l"
 case 402:
-#line 2671 "wcsbth.l"
+#line 2668 "wcsbth.l"
 case 403:
 YY_RULE_SETUP
-#line 2671 "wcsbth.l"
+#line 2668 "wcsbth.l"
 {
-	  /* Invalid combinations will be flagged by <VALUE>. */
+	  // Invalid combinations will be flagged by <VALUE>.
 	  sscanf(yytext, "%d_%d", &n, &m);
 	  a = ' ';
 	  if (YY_START == TCn_ma) i = wcsbth_colax(*wcs, &alts, n, a);
@@ -29095,17 +29092,17 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 404:
-#line 2681 "wcsbth.l"
+#line 2678 "wcsbth.l"
 case 405:
 YY_RULE_SETUP
-#line 2681 "wcsbth.l"
+#line 2678 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 406:
 YY_RULE_SETUP
-#line 2685 "wcsbth.l"
+#line 2682 "wcsbth.l"
 {
 	  if (relax & WCSHDR_PROJPn) {
 	    sscanf(yytext, "%d", &m);
@@ -29119,16 +29116,16 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 407:
-#line 2704 "wcsbth.l"
+#line 2701 "wcsbth.l"
 case 408:
 YY_RULE_SETUP
-#line 2704 "wcsbth.l"
+#line 2701 "wcsbth.l"
 {
 	  if (relax & (WCSHDR_PROJPn | WCSHDR_reject)) {
 	    errmsg = "invalid PROJPn keyword";
@@ -29141,25 +29138,25 @@ YY_RULE_SETUP
 	YY_BREAK
 case 409:
 YY_RULE_SETUP
-#line 2714 "wcsbth.l"
+#line 2711 "wcsbth.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 410:
 YY_RULE_SETUP
-#line 2718 "wcsbth.l"
+#line 2715 "wcsbth.l"
 {
-	  /* Do checks on i, j, m, n, k. */
+	  // Do checks on i, j, m, n, k.
 	  if (!(keytype & keysel)) {
-	    /* Selection by keyword type. */
+	    // Selection by keyword type.
 	    BEGIN(DISCARD);
 	
 	  } else if (exclude[n] || exclude[k]) {
-	    /* One or other column is not selected. */
+	    // One or other column is not selected.
 	    if (k && (exclude[n] != exclude[k])) {
-	      /* For keywords such as TCn_ka, both columns must be excluded.
-	         User error, so return immediately. */
+	      // For keywords such as TCn_ka, both columns must be excluded.
+	      // User error, so return immediately.
 	      return 3;
 	
 	    } else {
@@ -29179,18 +29176,18 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
 	  } else if (ipass == 2 && npass == 3 && (keytype & BINTAB)) {
-	    /* Skip keyvalues that won't be inherited. */
+	    // Skip keyvalues that won't be inherited.
 	    BEGIN(FLUSH);
 	
 	  } else {
 	    if (ipass == 3 && (keytype & IMGHEAD)) {
-	      /* IMGHEAD keytypes are always dealt with on the second pass. */
-	      /* However, they must be re-parsed in order to report errors. */
+	      // IMGHEAD keytypes are always dealt with on the second pass.
+	      // However, they must be re-parsed in order to report errors.
 	      vptr = 0x0;
 	    }
 	
@@ -29213,7 +29210,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 411:
 YY_RULE_SETUP
-#line 2780 "wcsbth.l"
+#line 2777 "wcsbth.l"
 {
 	  errmsg = "invalid KEYWORD = VALUE syntax";
 	  BEGIN(ERROR);
@@ -29221,13 +29218,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 412:
 YY_RULE_SETUP
-#line 2785 "wcsbth.l"
+#line 2782 "wcsbth.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    sscanf(yytext, "%d", &inttmp);
 	
 	    BEGIN(COMMENT);
@@ -29236,7 +29233,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 413:
 YY_RULE_SETUP
-#line 2797 "wcsbth.l"
+#line 2794 "wcsbth.l"
 {
 	  errmsg = "an integer value was expected";
 	  BEGIN(ERROR);
@@ -29244,13 +29241,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 414:
 YY_RULE_SETUP
-#line 2802 "wcsbth.l"
+#line 2799 "wcsbth.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    wcsutil_str2double(yytext, &dbltmp);
 	
 	    if (chekval && chekval(dbltmp)) {
@@ -29264,7 +29261,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 415:
 YY_RULE_SETUP
-#line 2819 "wcsbth.l"
+#line 2816 "wcsbth.l"
 {
 	  errmsg = "a floating-point value was expected";
 	  BEGIN(ERROR);
@@ -29272,13 +29269,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 416:
 YY_RULE_SETUP
-#line 2824 "wcsbth.l"
+#line 2821 "wcsbth.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue as integer and fractional parts. */
+	    // Read the keyvalue as integer and fractional parts.
 	    wcsutil_str2double2(yytext, dbl2tmp);
 	
 	    BEGIN(COMMENT);
@@ -29287,7 +29284,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 417:
 YY_RULE_SETUP
-#line 2836 "wcsbth.l"
+#line 2833 "wcsbth.l"
 {
 	  errmsg = "a floating-point value was expected";
 	  BEGIN(ERROR);
@@ -29296,16 +29293,16 @@ YY_RULE_SETUP
 case 418:
 /* rule 418 can match eol */
 YY_RULE_SETUP
-#line 2841 "wcsbth.l"
+#line 2838 "wcsbth.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	      strcpy(strtmp, yytext+1);
 	
-	    /* Squeeze out repeated quotes. */
+	    // Squeeze out repeated quotes.
 	    ix = 0;
 	    for (jx = 0; jx < 72; jx++) {
 	      if (ix < jx) {
@@ -29328,7 +29325,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 419:
 YY_RULE_SETUP
-#line 2870 "wcsbth.l"
+#line 2867 "wcsbth.l"
 {
 	  errmsg = "a string value was expected";
 	  BEGIN(ERROR);
@@ -29339,31 +29336,31 @@ case 420:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2875 "wcsbth.l"
+#line 2872 "wcsbth.l"
 {
 	  if (ipass == 1) {
-	    /* Do first-pass bookkeeping. */
+	    // Do first-pass bookkeeping.
 	    wcsbth_pass1(keytype, i, j, n, k, a, ptype, &alts);
 	    BEGIN(FLUSH);
 	
 	  } else if (*wcs) {
-	    /* Store the value now that the keyrecord has been validated. */
+	    // Store the value now that the keyrecord has been validated.
 	    alts.icol = 0;
 	    alts.ialt = 0;
 	
-	    /* Update each coordinate representation. */
+	    // Update each coordinate representation.
 	    gotone = 0;
 	    while ((wcsp = wcsbth_idx(*wcs, &alts, keytype, n, a))) {
 	      gotone = 1;
 	
 	      if (vptr) {
 	        if (auxprm) {
-	          /* Additional auxiliary parameter. */
+	          // Additional auxiliary parameter.
 	          auxp = wcsp->aux;
 	          voff = (char *)vptr - (char *)(&auxtem);
 	          wptr = (void *)((char *)auxp + voff);
 	        } else {
-	          /* A parameter that lives directly in wcsprm. */
+	          // A parameter that lives directly in wcsprm.
 	          voff = (char *)vptr - (char *)(&wcstem);
 	          wptr = (void *)((char *)wcsp + voff);
 	        }
@@ -29372,7 +29369,7 @@ YY_RULE_SETUP
 	          *((int *)wptr) = inttmp;
 	
 	        } else if (valtype == FLOAT) {
-	          /* Apply keyword parameterization. */
+	          // Apply keyword parameterization.
 	          if (ptype == 'v') {
 	            ipx = (wcsp->npv)++;
 	            wcsp->pv[ipx].i = i;
@@ -29393,14 +29390,14 @@ YY_RULE_SETUP
 	            *((double *)wptr) = dbltmp;
 	          }
 	
-	          /* Flag the presence of PCi_ja, or CDi_ja and/or CROTAia. */
+	          // Flag the presence of PCi_ja, or CDi_ja and/or CROTAia.
 	          if (altlin) {
 	            wcsp->altlin |= altlin;
 	            altlin = 0;
 	          }
 	
 	          } else if (valtype == FLOAT2) {
-	            /* Split MJDREF and JDREF into integer and fraction.*/
+	            // Split MJDREF and JDREF into integer and fraction.
 	            if (special) {
 	              special(wptr, dbl2tmp);
 	            } else {
@@ -29409,7 +29406,7 @@ YY_RULE_SETUP
 	            }
 	
 	        } else if (valtype == STRING) {
-	          /* Apply keyword parameterization. */
+	          // Apply keyword parameterization.
 	          if (ptype == 's') {
 	            ipx = wcsp->nps++;
 	            wcsp->ps[ipx].i = i;
@@ -29460,7 +29457,7 @@ case 421:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2990 "wcsbth.l"
+#line 2987 "wcsbth.l"
 {
 	  errmsg = "invalid keyvalue";
 	  BEGIN(ERROR);
@@ -29471,7 +29468,7 @@ case 422:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2995 "wcsbth.l"
+#line 2992 "wcsbth.l"
 {
 	  errmsg = "invalid keyvalue";
 	  BEGIN(ERROR);
@@ -29482,7 +29479,7 @@ case 423:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 3000 "wcsbth.l"
+#line 2997 "wcsbth.l"
 {
 	  errmsg = "invalid keyvalue or malformed keycomment";
 	  BEGIN(ERROR);
@@ -29493,7 +29490,7 @@ case 424:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 3005 "wcsbth.l"
+#line 3002 "wcsbth.l"
 {
 	  errmsg = "malformed keycomment";
 	  BEGIN(ERROR);
@@ -29504,11 +29501,11 @@ case 425:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 3010 "wcsbth.l"
+#line 3007 "wcsbth.l"
 {
 	  if (ipass == npass) {
 	    if (ctrl < 0) {
-	      /* Preserve discards. */
+	      // Preserve discards.
 	      keep = keyrec;
 	
 	    } else if (2 < ctrl) {
@@ -29525,7 +29522,7 @@ case 426:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 3025 "wcsbth.l"
+#line 3022 "wcsbth.l"
 {
 	  if (ipass == npass) {
 	    (*nreject)++;
@@ -29545,7 +29542,7 @@ YY_RULE_SETUP
 case 427:
 /* rule 427 can match eol */
 YY_RULE_SETUP
-#line 3041 "wcsbth.l"
+#line 3038 "wcsbth.l"
 {
 	  if (ipass == npass && keep) {
 	    if (hptr < keep) {
@@ -29556,7 +29553,7 @@ YY_RULE_SETUP
 	
 	  naux += auxprm;
 	
-	  /* Throw away the rest of the line and reset for the next one. */
+	  // Throw away the rest of the line and reset for the next one.
 	  i = j = 0;
 	  n = k = 0;
 	  m = 0;
@@ -29611,9 +29608,9 @@ case YY_STATE_EOF(COMMENT):
 case YY_STATE_EOF(DISCARD):
 case YY_STATE_EOF(ERROR):
 case YY_STATE_EOF(FLUSH):
-#line 3072 "wcsbth.l"
+#line 3069 "wcsbth.l"
 {
-	  /* End-of-input. */
+	  // End-of-input.
 	  if (ipass == 1) {
 	    if ((status = wcsbth_init1(&alts, naux, nwcs, wcs)) ||
 	        (*nwcs == 0 && ctrl == 0)) {
@@ -29682,10 +29679,10 @@ case YY_STATE_EOF(FLUSH):
 	YY_BREAK
 case 428:
 YY_RULE_SETUP
-#line 3140 "wcsbth.l"
+#line 3137 "wcsbth.l"
 ECHO;
 	YY_BREAK
-#line 29689 "wcsbth.c"
+#line 29686 "wcsbth.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -30850,7 +30847,7 @@ void yyfree (void * ptr , yyscan_t yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 3140 "wcsbth.l"
+#line 3137 "wcsbth.l"
 
 
 /*----------------------------------------------------------------------------
@@ -30893,20 +30890,20 @@ int wcsbth_pass1(
   int ialt, icol, mask, ncol;
 
   if (a == 0) {
-    /* Keywords such as DATE-OBS go along for the ride. */
+    // Keywords such as DATE-OBS go along for the ride.
     return 0;
   }
 
   ncol = alts->ncol;
 
-  /* Do we need to allocate memory for alts? */
+  // Do we need to allocate memory for alts?
   if (alts->arridx == 0x0) {
     if (ncol == 0) {
-      /* Can only happen if TFIELDS is missing or out-of-sequence.  If n and
-         k are both zero then we may be processing an image header so leave
-         ncol alone - the array will be realloc'd later if required. */
+      // Can only happen if TFIELDS is missing or out-of-sequence.  If n and
+      // k are both zero then we may be processing an image header so leave
+      // ncol alone - the array will be realloc'd later if required.
       if (n || k) {
-        /* The header is mangled, assume the worst. */
+        // The header is mangled, assume the worst.
         ncol = 999;
       }
     }
@@ -30925,7 +30922,7 @@ int wcsbth_pass1(
     alts->ncol = ncol;
 
   } else if (n > ncol || k > ncol) {
-    /* Can only happen if TFIELDS or the WCS keyword is wrong; carry on. */
+    // Can only happen if TFIELDS or the WCS keyword is wrong; carry on.
     ncol = 999;
     if (!(alts->arridx  = realloc(alts->arridx,
                                     27*(1 + ncol)*sizeof(short int))) ||
@@ -30942,7 +30939,7 @@ int wcsbth_pass1(
       return 2;
     }
 
-    /* Since realloc() doesn't initialize the extra memory. */
+    // Since realloc() doesn't initialize the extra memory.
     for (icol = (1 + alts->ncol); icol < (1 + ncol); icol++) {
       for (ialt = 0; ialt < 27; ialt++) {
         alts->arridx[icol][ialt] = 0;
@@ -30960,18 +30957,18 @@ int wcsbth_pass1(
     ialt = a - 'A' + 1;
   }
 
-  /* A BINTAB keytype such as LONPna, in conjunction with an IMGAXIS keytype
-     causes a table column to be recognized as an image array. */
+  // A BINTAB keytype such as LONPna, in conjunction with an IMGAXIS keytype
+  // causes a table column to be recognized as an image array.
   if (keytype & IMGHEAD || keytype & BIMGARR) {
-    /* n == 0 is expected for IMGHEAD keywords. */
+    // n == 0 is expected for IMGHEAD keywords.
     if (i == 0 && j == 0) {
       if (alts->arridx[n][ialt] == 0) {
-        /* Flag that an auxiliary keyword was seen. */
+        // Flag that an auxiliary keyword was seen.
         alts->arridx[n][ialt] = -1;
       }
 
     } else {
-      /* Record the maximum axis number found. */
+      // Record the maximum axis number found.
       if (alts->arridx[n][ialt] < i) {
         alts->arridx[n][ialt] = i;
       }
@@ -30988,17 +30985,17 @@ int wcsbth_pass1(
     }
   }
 
-  /* BINTAB keytypes, which apply both to pixel lists as well as binary table
-     image arrays, never contribute to recognizing a table column as a pixel
-     list axis.  A PIXLIST keytype is required for that. */
+  // BINTAB keytypes, which apply both to pixel lists as well as binary table
+  // image arrays, never contribute to recognizing a table column as a pixel
+  // list axis.  A PIXLIST keytype is required for that.
   if (keytype == PIXLIST) {
     mask = 1 << ialt;
 
-    /* n > 0 for PIXLIST keytypes. */
+    // n > 0 for PIXLIST keytypes.
     alts->pixlist[n] |= mask;
     if (k) alts->pixlist[k] |= mask;
 
-    /* Used as a flag over all columns. */
+    // Used as a flag over all columns.
     alts->pixlist[0] |= mask;
 
     if (ptype == 'v') {
@@ -31035,7 +31032,7 @@ int wcsbth_init1(
     return 0;
   }
 
-  /* Determine the number of axes in each pixel list representation. */
+  // Determine the number of axes in each pixel list representation.
   ncol = alts->ncol;
   for (ialt = 0, mask = 1; ialt < 27; ialt++, mask <<= 1) {
     alts->pixidx[ialt] = 0;
@@ -31049,7 +31046,7 @@ int wcsbth_init1(
     }
   }
 
-  /* Find the total number of coordinate representations. */
+  // Find the total number of coordinate representations.
   *nwcs = 0;
   alts->imgherit = 0;
   for (ialt = 0; ialt < 27; ialt++) {
@@ -31057,10 +31054,10 @@ int wcsbth_init1(
 
     for (icol = 1; icol <= ncol; icol++) {
       if (alts->arridx[icol][ialt] < 0) {
-        /* No BIMGARR keytype but there's at least one BINTAB. */
+        // No BIMGARR keytype but there's at least one BINTAB.
         if (alts->arridx[0][ialt] > 0) {
-          /* There is an IMGAXIS keytype that we will inherit, so count this
-             representation. */
+          // There is an IMGAXIS keytype that we will inherit, so count this
+          // representation.
           alts->arridx[icol][ialt] = alts->arridx[0][ialt];
         } else {
           alts->arridx[icol][ialt] = 0;
@@ -31069,11 +31066,11 @@ int wcsbth_init1(
 
       if (alts->arridx[icol][ialt]) {
         if (alts->arridx[0][ialt]) {
-          /* All IMGHEAD keywords are inherited for this ialt. */
+          // All IMGHEAD keywords are inherited for this ialt.
           inherit[ialt] = 1;
 
           if (alts->arridx[icol][ialt] < alts->arridx[0][ialt]) {
-            /* The extra axes are also inherited. */
+            // The extra axes are also inherited.
             alts->arridx[icol][ialt] = alts->arridx[0][ialt];
           }
         }
@@ -31082,10 +31079,10 @@ int wcsbth_init1(
       }
     }
 
-    /* Count every "a" found in any IMGHEAD keyword... */
+    // Count every "a" found in any IMGHEAD keyword...
     if (alts->arridx[0][ialt]) {
       if (inherit[ialt]) {
-        /* ...but not if the IMGHEAD keywords will be inherited. */
+        // ...but not if the IMGHEAD keywords will be inherited.
         alts->arridx[0][ialt] = 0;
         alts->imgherit = 1;
       } else if (alts->arridx[0][ialt] > 0) {
@@ -31093,7 +31090,7 @@ int wcsbth_init1(
       }
     }
 
-    /* We need a struct for every "a" found in a PIXLIST keyword. */
+    // We need a struct for every "a" found in a PIXLIST keyword.
     if (alts->pixidx[ialt]) {
       (*nwcs)++;
     }
@@ -31101,19 +31098,19 @@ int wcsbth_init1(
 
 
   if (*nwcs) {
-    /* Allocate memory for the required number of wcsprm structs. */
+    // Allocate memory for the required number of wcsprm structs.
     if (!(*wcs = calloc(*nwcs, sizeof(struct wcsprm)))) {
       return 2;
     }
 
-    /* Initialize each wcsprm struct. */
+    // Initialize each wcsprm struct.
     wcsp = *wcs;
     *nwcs = 0;
     for (icol = 0; icol <= ncol; icol++) {
       for (ialt = 0; ialt < 27; ialt++) {
         if (alts->arridx[icol][ialt] > 0) {
-          /* Image-header representations that are not for inheritance
-             (icol == 0) or binary table image array representations. */
+          // Image-header representations that are not for inheritance
+          // (icol == 0) or binary table image array representations.
           wcsp->flag = -1;
           npvmax = alts->npv[icol][ialt];
           npsmax = alts->nps[icol][ialt];
@@ -31123,29 +31120,29 @@ int wcsbth_init1(
             break;
           }
 
-          /* Record the alternate version code. */
+          // Record the alternate version code.
           if (ialt) {
             wcsp->alt[0] = 'A' + ialt - 1;
           }
 
-          /* Any additional auxiliary keywords present? */
+          // Any additional auxiliary keywords present?
           if (naux) {
             if (wcsauxi(1, wcsp)) {
               return WCSHDRERR_MEMORY;
             }
           }
 
-          /* Record the table column number. */
+          // Record the table column number.
           wcsp->colnum = icol;
 
-          /* On the second pass alts->arridx[icol][27] indexes the array of
-             wcsprm structs. */
+          // On the second pass alts->arridx[icol][27] indexes the array of
+          // wcsprm structs.
           alts->arridx[icol][ialt] = (*nwcs)++;
 
           wcsp++;
 
         } else {
-          /* Signal that this column has no WCS for this "a". */
+          // Signal that this column has no WCS for this "a".
           alts->arridx[icol][ialt] = -1;
         }
       }
@@ -31153,7 +31150,7 @@ int wcsbth_init1(
 
     for (ialt = 0; ialt < 27; ialt++) {
       if (alts->pixidx[ialt]) {
-        /* Pixel lists representations. */
+        // Pixel lists representations.
         wcsp->flag = -1;
         npvmax = alts->pixnpv[ialt];
         npsmax = alts->pixnps[ialt];
@@ -31163,19 +31160,19 @@ int wcsbth_init1(
           break;
         }
 
-        /* Record the alternate version code. */
+        // Record the alternate version code.
         if (ialt) {
           wcsp->alt[0] = 'A' + ialt - 1;
         }
 
-        /* Any additional auxiliary keywords present? */
+        // Any additional auxiliary keywords present?
         if (naux) {
           if (wcsauxi(1, wcsp)) {
             return WCSHDRERR_MEMORY;
           }
         }
 
-        /* Record the pixel list column numbers. */
+        // Record the pixel list column numbers.
         mask = (1 << ialt);
         for (icol = 1, ix = 0; icol <= ncol; icol++) {
           if (alts->pixlist[icol] & mask) {
@@ -31183,13 +31180,13 @@ int wcsbth_init1(
           }
         }
 
-        /* alts->pixidx[] indexes the array of wcsprm structs. */
+        // alts->pixidx[] indexes the array of wcsprm structs.
         alts->pixidx[ialt] = (*nwcs)++;
 
         wcsp++;
 
       } else {
-        /* Signal that this column is not a pixel list axis for this "a". */
+        // Signal that this column is not a pixel list axis for this "a".
         alts->pixidx[ialt] = -1;
       }
     }
@@ -31219,22 +31216,22 @@ struct wcsprm *wcsbth_idx(
 
   iwcs = -1;
   for (; iwcs < 0 && alts->ialt < 27; alts->ialt++) {
-    /* Note that a == 0 applies to every alternate, otherwise this
-       loop simply determines the appropriate value of alts->ialt. */
+    // Note that a == 0 applies to every alternate, otherwise this
+    // loop simply determines the appropriate value of alts->ialt.
     if (a && a != as[alts->ialt]) continue;
 
     if (keytype & (IMGHEAD | BIMGARR)) {
       for (; iwcs < 0 && alts->icol <= alts->ncol; alts->icol++) {
-        /* Image header keywords, n == 0, apply to all columns, otherwise this
-           loop simply determines the appropriate value of alts->icol. */
+        // Image header keywords, n == 0, apply to all columns, otherwise this
+        // loop simply determines the appropriate value of alts->icol.
         if (n && n != alts->icol) continue;
         iwcs = alts->arridx[alts->icol][alts->ialt];
       }
 
-      /* Break out of the loop to stop alts->ialt from being incremented. */
+      // Break out of the loop to stop alts->ialt from being incremented.
       if (iwcs >= 0) break;
 
-      /* Start from scratch for the next alts->ialt. */
+      // Start from scratch for the next alts->ialt.
       alts->icol = 0;
     }
 
@@ -31286,7 +31283,7 @@ int wcsbth_colax(
 int wcsbth_jdref(double *mjdref, const double *jdref)
 
 {
-  /* Set MJDREF from JDREF. */
+  // Set MJDREF from JDREF.
   if (undefined(mjdref[0] && undefined(mjdref[1]))) {
     mjdref[0] = jdref[0] - 2400000.0;
     mjdref[1] = jdref[1] - 0.5;
@@ -31303,7 +31300,7 @@ int wcsbth_jdref(double *mjdref, const d
 int wcsbth_jdrefi(double *mjdref, const double *jdrefi)
 
 {
-  /* Set the integer part of MJDREF from JDREFI. */
+  // Set the integer part of MJDREF from JDREFI.
   if (undefined(mjdref[0])) {
     mjdref[0] = *jdrefi - 2400000.5;
   }
@@ -31315,7 +31312,7 @@ int wcsbth_jdrefi(double *mjdref, const
 int wcsbth_jdreff(double *mjdref, const double *jdreff)
 
 {
-  /* Set the fractional part of MJDREF from JDREFF. */
+  // Set the fractional part of MJDREF from JDREFF.
   if (undefined(mjdref[1])) {
     mjdref[1] = *jdreff;
   }
@@ -31331,7 +31328,7 @@ int wcsbth_jdreff(double *mjdref, const
 int wcsbth_epoch(double *equinox, const double *epoch)
 
 {
-  /* If EQUINOXa is currently undefined then set it from EPOCHa. */
+  // If EQUINOXa is currently undefined then set it from EPOCHa.
   if (undefined(*equinox)) {
     *equinox = *epoch;
   }
@@ -31349,9 +31346,9 @@ int wcsbth_vsource(double *zsource, cons
 {
   double beta, c = 299792458.0;
 
-  /* If ZSOURCEa is currently undefined then set it from VSOURCEa. */
+  // If ZSOURCEa is currently undefined then set it from VSOURCEa.
   if (undefined(*zsource)) {
-    /* Convert relativistic Doppler velocity to redshift. */
+    // Convert relativistic Doppler velocity to redshift.
     beta = *vsource/c;
     *zsource = (1.0 + beta)/sqrt(1.0 - beta*beta) - 1.0;
   }
@@ -31389,7 +31386,7 @@ int wcsbth_final(
   if (alts->pixlist) free(alts->pixlist);
 
   for (ialt = 0; ialt < *nwcs; ialt++) {
-    /* Interpret -TAB header keywords. */
+    // Interpret -TAB header keywords.
     if ((status = wcstab(*wcs+ialt))) {
        wcsvfree(nwcs, wcs);
        return status;
Index: astropy-4.2/cextern/wcslib/C/flexed/wcspih.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/flexed/wcspih.c
+++ astropy-4.2/cextern/wcslib/C/flexed/wcspih.c
@@ -20763,9 +20763,8 @@ static const yy_state_type yy_NUL_trans[
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "wcspih.l"
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -20782,11 +20781,9 @@ static const yy_state_type yy_NUL_trans[
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcspih.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcspih.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
 * wcspih.l is a Flex description file containing the definition of a lexical
@@ -20841,7 +20838,7 @@ static const yy_state_type yy_NUL_trans[
 
 
 
-#line 112 "wcspih.l"
+#line 109 "wcspih.l"
 #include <math.h>
 #include <setjmp.h>
 #include <stddef.h>
@@ -20874,7 +20871,7 @@ static int wcspih_scanner(char *header,
                           int *nreject, int *nwcs, struct wcsprm **wcs,
                           yyscan_t yyscanner);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcspih(
   char *header,
@@ -20899,7 +20896,7 @@ int wcspih(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define YY_DECL int wcspih_scanner(char *header, int nkeyrec, int relax, \
  int ctrl, int *nreject, int *nwcs, struct wcsprm **wcs, yyscan_t yyscanner)
@@ -20917,11 +20914,11 @@ int wcspih(
 	  } \
 	}
 
-/* These global variables are required by YY_INPUT. */
+// These global variables are required by YY_INPUT.
 static char *wcspih_hdr;
 static int  wcspih_nkeyrec;
 
-/* Internal helper functions. */
+// Internal helper functions.
 static int wcspih_final(int ndp[], int ndq[], int distran, double dsstmp[],
              char *wat[], int *nwcs, struct wcsprm **wcs);
 static int wcspih_init1(int naxis, int alts[], int dpq[], int npv[],
@@ -20938,12 +20935,12 @@ static int wcspih_vsource(double *wptr,
 
 static int wcspih_timepixr(double timepixr);
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
+// Used in preempting the call to exit() by yy_fatal_error().
 jmp_buf wcspih_abort_jmp_env;
 #define exit(status) longjmp(wcspih_abort_jmp_env, status)
 
-#line 20946 "wcspih.c"
-#line 20947 "wcspih.c"
+#line 20943 "wcspih.c"
+#line 20944 "wcspih.c"
 
 #define INITIAL 0
 #define CCia 1
@@ -21216,10 +21213,10 @@ YY_DECL
 		}
 
 	{
-#line 214 "wcspih.l"
+#line 211 "wcspih.l"
 
-#line 216 "wcspih.l"
-	/* Keyword indices, as used in the WCS papers, e.g. PCi_ja, PVi_ma. */
+#line 213 "wcspih.l"
+	// Keyword indices, as used in the WCS papers, e.g. PCi_ja, PVi_ma.
 	char a;
 	int  i, j, m, p, q;
 	
@@ -21248,34 +21245,34 @@ YY_DECL
 	  ndq[ialt]  = 0;
 	}
 	
-	/* Parameters used to implement YY_INPUT. */
+	// Parameters used to implement YY_INPUT.
 	wcspih_hdr = header;
 	wcspih_nkeyrec = nkeyrec;
 	
-	/* Our handle on the input stream. */
+	// Our handle on the input stream.
 	keyrec = header;
 	hptr = header;
 	keep = 0x0;
 	
-	/* For keeping tallies of keywords found. */
+	// For keeping tallies of keywords found.
 	*nreject = 0;
 	nvalid = 0;
 	nother = 0;
 	
-	/* If strict, then also reject. */
+	// If strict, then also reject.
 	if (relax & WCSHDR_strict) relax |= WCSHDR_reject;
 	
-	/* Keyword parameters. */
+	// Keyword parameters.
 	i = j = 0;
 	m = 0;
 	a = ' ';
 	
-	/* For decoding the keyvalue. */
+	// For decoding the keyvalue.
 	valtype = -1;
 	distype =  0;
 	vptr    = 0x0;
 	
-	/* For keywords that require special handling. */
+	// For keywords that require special handling.
 	altlin  = 0;
 	npptr   = 0x0;
 	chekval = 0x0;
@@ -21288,15 +21285,15 @@ YY_DECL
 	watflag = 0;
 	watn    = 0;
 	
-	/* The data structures produced. */
+	// The data structures produced.
 	*nwcs = 0;
 	*wcs  = 0x0;
 	
-	/* Control variables. */
+	// Control variables.
 	ipass = 1;
 	npass = 2;
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
+	// Return here via longjmp() invoked by yy_fatal_error().
 	if (setjmp(wcspih_abort_jmp_env)) {
 	  return 3;
 	}
@@ -21304,7 +21301,7 @@ YY_DECL
 	BEGIN(INITIAL);
 
 
-#line 21308 "wcspih.c"
+#line 21305 "wcspih.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -21352,7 +21349,7 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 301 "wcspih.l"
+#line 298 "wcspih.l"
 {
 	  keyname = "NAXISn";
 	
@@ -21375,7 +21372,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 321 "wcspih.l"
+#line 318 "wcspih.l"
 {
 	  sscanf(yytext, "WCSAXES%c= %d", &a, &i);
 	
@@ -21394,7 +21391,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 337 "wcspih.l"
+#line 334 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crpix);
@@ -21405,7 +21402,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 345 "wcspih.l"
+#line 342 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pc);
@@ -21417,7 +21414,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 354 "wcspih.l"
+#line 351 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cd);
@@ -21429,7 +21426,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 363 "wcspih.l"
+#line 360 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cdelt);
@@ -21440,7 +21437,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 371 "wcspih.l"
+#line 368 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crota);
@@ -21452,7 +21449,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 380 "wcspih.l"
+#line 377 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cunit);
@@ -21463,7 +21460,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 388 "wcspih.l"
+#line 385 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ctype);
@@ -21474,7 +21471,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 396 "wcspih.l"
+#line 393 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crval);
@@ -21485,7 +21482,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 404 "wcspih.l"
+#line 401 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.lonpole);
@@ -21496,7 +21493,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 412 "wcspih.l"
+#line 409 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.latpole);
@@ -21507,7 +21504,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 420 "wcspih.l"
+#line 417 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.restfrq);
@@ -21518,7 +21515,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 428 "wcspih.l"
+#line 425 "wcspih.l"
 {
 	  if (relax & WCSHDR_strict) {
 	    errmsg = "the RESTFREQ keyword is deprecated, use RESTFRQa";
@@ -21537,7 +21534,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 444 "wcspih.l"
+#line 441 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.restwav);
@@ -21548,7 +21545,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 452 "wcspih.l"
+#line 449 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -21560,7 +21557,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 461 "wcspih.l"
+#line 458 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.pv);
@@ -21572,7 +21569,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 470 "wcspih.l"
+#line 467 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.ps);
@@ -21584,7 +21581,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 479 "wcspih.l"
+#line 476 "wcspih.l"
 {
 	  sscanf(yytext, "VELREF%c", &a);
 	
@@ -21612,7 +21609,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 504 "wcspih.l"
+#line 501 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = &(wcstem.cname);
@@ -21623,7 +21620,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 512 "wcspih.l"
+#line 509 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.crder);
@@ -21634,7 +21631,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 520 "wcspih.l"
+#line 517 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.csyer);
@@ -21645,7 +21642,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 528 "wcspih.l"
+#line 525 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.czphs);
@@ -21656,7 +21653,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 536 "wcspih.l"
+#line 533 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.cperi);
@@ -21667,7 +21664,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 544 "wcspih.l"
+#line 541 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.wcsname;
@@ -21678,7 +21675,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 552 "wcspih.l"
+#line 549 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.timesys;
@@ -21689,7 +21686,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 560 "wcspih.l"
+#line 557 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.trefpos;
@@ -21700,7 +21697,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 568 "wcspih.l"
+#line 565 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.trefdir;
@@ -21711,7 +21708,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 576 "wcspih.l"
+#line 573 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.plephem;
@@ -21722,7 +21719,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 584 "wcspih.l"
+#line 581 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.timeunit;
@@ -21732,10 +21729,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 31:
-#line 593 "wcspih.l"
+#line 590 "wcspih.l"
 case 32:
 YY_RULE_SETUP
-#line 593 "wcspih.l"
+#line 590 "wcspih.l"
 {
 	  if ((yytext[4] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = STRING;
@@ -21754,10 +21751,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 33:
-#line 611 "wcspih.l"
+#line 608 "wcspih.l"
 case 34:
 YY_RULE_SETUP
-#line 611 "wcspih.l"
+#line 608 "wcspih.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT2;
@@ -21776,13 +21773,13 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 35:
-#line 629 "wcspih.l"
+#line 626 "wcspih.l"
 case 36:
 YY_RULE_SETUP
-#line 629 "wcspih.l"
+#line 626 "wcspih.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	
@@ -21799,10 +21796,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 37:
-#line 648 "wcspih.l"
+#line 645 "wcspih.l"
 case 38:
 YY_RULE_SETUP
-#line 648 "wcspih.l"
+#line 645 "wcspih.l"
 {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT;
@@ -21821,10 +21818,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 39:
-#line 666 "wcspih.l"
+#line 663 "wcspih.l"
 case 40:
 YY_RULE_SETUP
-#line 666 "wcspih.l"
+#line 663 "wcspih.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT2;
@@ -21844,13 +21841,13 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 41:
-#line 685 "wcspih.l"
+#line 682 "wcspih.l"
 case 42:
 YY_RULE_SETUP
-#line 685 "wcspih.l"
+#line 682 "wcspih.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	    special = wcspih_jdrefi;
@@ -21868,10 +21865,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 43:
-#line 705 "wcspih.l"
+#line 702 "wcspih.l"
 case 44:
 YY_RULE_SETUP
-#line 705 "wcspih.l"
+#line 702 "wcspih.l"
 {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
 	    valtype = FLOAT;
@@ -21892,7 +21889,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 723 "wcspih.l"
+#line 720 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timeoffs);
@@ -21903,7 +21900,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 731 "wcspih.l"
+#line 728 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateobs;
@@ -21915,7 +21912,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 740 "wcspih.l"
+#line 737 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.datebeg;
@@ -21927,7 +21924,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 749 "wcspih.l"
+#line 746 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateavg;
@@ -21939,7 +21936,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 758 "wcspih.l"
+#line 755 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.dateend;
@@ -21951,7 +21948,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 767 "wcspih.l"
+#line 764 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdobs);
@@ -21963,7 +21960,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 776 "wcspih.l"
+#line 773 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdbeg);
@@ -21975,7 +21972,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 785 "wcspih.l"
+#line 782 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdavg);
@@ -21987,7 +21984,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 794 "wcspih.l"
+#line 791 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.mjdend);
@@ -21999,7 +21996,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 803 "wcspih.l"
+#line 800 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.jepoch);
@@ -22011,7 +22008,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 812 "wcspih.l"
+#line 809 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.bepoch);
@@ -22023,7 +22020,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 821 "wcspih.l"
+#line 818 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.tstart);
@@ -22035,7 +22032,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 830 "wcspih.l"
+#line 827 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.tstop);
@@ -22047,7 +22044,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 839 "wcspih.l"
+#line 836 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.xposure);
@@ -22059,7 +22056,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 848 "wcspih.l"
+#line 845 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.telapse);
@@ -22071,7 +22068,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 857 "wcspih.l"
+#line 854 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timsyer);
@@ -22083,7 +22080,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 866 "wcspih.l"
+#line 863 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timrder);
@@ -22095,7 +22092,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 875 "wcspih.l"
+#line 872 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timedel);
@@ -22107,7 +22104,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 884 "wcspih.l"
+#line 881 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.timepixr);
@@ -22120,7 +22117,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 894 "wcspih.l"
+#line 891 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo;
@@ -22132,7 +22129,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 903 "wcspih.l"
+#line 900 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 1;
@@ -22144,7 +22141,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 912 "wcspih.l"
+#line 909 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 2;
@@ -22156,7 +22153,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 921 "wcspih.l"
+#line 918 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 3;
@@ -22168,7 +22165,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 930 "wcspih.l"
+#line 927 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 4;
@@ -22180,7 +22177,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 939 "wcspih.l"
+#line 936 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = wcstem.obsgeo + 5;
@@ -22192,7 +22189,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 948 "wcspih.l"
+#line 945 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.obsorbit;
@@ -22203,7 +22200,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 956 "wcspih.l"
+#line 953 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.radesys;
@@ -22214,7 +22211,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 964 "wcspih.l"
+#line 961 "wcspih.l"
 {
 	  if (relax & WCSHDR_RADECSYS) {
 	    valtype = STRING;
@@ -22236,7 +22233,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 983 "wcspih.l"
+#line 980 "wcspih.l"
 {
 	  sscanf(yytext, "EPOCH%c", &a);
 	
@@ -22265,7 +22262,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 1009 "wcspih.l"
+#line 1006 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.equinox);
@@ -22276,7 +22273,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 1017 "wcspih.l"
+#line 1014 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.specsys;
@@ -22287,7 +22284,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 1025 "wcspih.l"
+#line 1022 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.ssysobs;
@@ -22298,7 +22295,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 1033 "wcspih.l"
+#line 1030 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.velosys);
@@ -22309,7 +22306,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 1041 "wcspih.l"
+#line 1038 "wcspih.l"
 {
 	  if (relax & WCSHDR_VSOURCE) {
 	    valtype = FLOAT;
@@ -22332,7 +22329,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 1061 "wcspih.l"
+#line 1058 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.zsource);
@@ -22343,7 +22340,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 1069 "wcspih.l"
+#line 1066 "wcspih.l"
 {
 	  valtype = STRING;
 	  vptr    = wcstem.ssyssrc;
@@ -22354,7 +22351,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 1077 "wcspih.l"
+#line 1074 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  vptr    = &(wcstem.velangl);
@@ -22365,7 +22362,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 1085 "wcspih.l"
+#line 1082 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -22377,7 +22374,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 1094 "wcspih.l"
+#line 1091 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -22389,7 +22386,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 1103 "wcspih.l"
+#line 1100 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -22401,7 +22398,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 1112 "wcspih.l"
+#line 1109 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -22412,10 +22409,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 86:
-#line 1122 "wcspih.l"
+#line 1119 "wcspih.l"
 case 87:
 YY_RULE_SETUP
-#line 1122 "wcspih.l"
+#line 1119 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  auxprm  = 1;
@@ -22427,7 +22424,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 1131 "wcspih.l"
+#line 1128 "wcspih.l"
 {
 	  valtype = STRING;
 	  distype = PRIOR;
@@ -22439,7 +22436,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 1140 "wcspih.l"
+#line 1137 "wcspih.l"
 {
 	  valtype = STRING;
 	  distype = SEQUENT;
@@ -22451,7 +22448,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 1149 "wcspih.l"
+#line 1146 "wcspih.l"
 {
 	  valtype = RECORD;
 	  distype = PRIOR;
@@ -22464,7 +22461,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
-#line 1159 "wcspih.l"
+#line 1156 "wcspih.l"
 {
 	  valtype = RECORD;
 	  distype = SEQUENT;
@@ -22477,7 +22474,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-#line 1169 "wcspih.l"
+#line 1166 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  distype = PRIOR;
@@ -22489,7 +22486,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 1178 "wcspih.l"
+#line 1175 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  distype = SEQUENT;
@@ -22501,7 +22498,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-#line 1187 "wcspih.l"
+#line 1184 "wcspih.l"
 {
 	  valtype = FLOAT;
 	  distype = PRIOR;
@@ -22513,9 +22510,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
-#line 1196 "wcspih.l"
+#line 1193 "wcspih.l"
 {
-	  /* SIP: axis 1 polynomial degree (not stored). */
+	  // SIP: axis 1 polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -22529,9 +22526,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 1209 "wcspih.l"
+#line 1206 "wcspih.l"
 {
-	  /* SIP: axis 2 polynomial degree (not stored). */
+	  // SIP: axis 2 polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -22545,9 +22542,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 1222 "wcspih.l"
+#line 1219 "wcspih.l"
 {
-	  /* SIP: axis 1 inverse polynomial degree (not stored). */
+	  // SIP: axis 1 inverse polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -22561,9 +22558,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-#line 1235 "wcspih.l"
+#line 1232 "wcspih.l"
 {
-	  /* SIP: axis 2 inverse polynomial degree (not stored). */
+	  // SIP: axis 2 inverse polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -22577,9 +22574,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-#line 1248 "wcspih.l"
+#line 1245 "wcspih.l"
 {
-	  /* SIP: axis 1 maximum distortion. */
+	  // SIP: axis 1 maximum distortion.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.maxdis);
@@ -22593,9 +22590,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-#line 1261 "wcspih.l"
+#line 1258 "wcspih.l"
 {
-	  /* SIP: axis 2 maximum distortion. */
+	  // SIP: axis 2 maximum distortion.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.maxdis);
@@ -22609,9 +22606,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-#line 1274 "wcspih.l"
+#line 1271 "wcspih.l"
 {
-	  /* SIP: axis 1 polynomial coefficient. */
+	  // SIP: axis 1 polynomial coefficient.
 	  i = 1;
 	  sipflag = 2;
 	
@@ -22621,9 +22618,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 1283 "wcspih.l"
+#line 1280 "wcspih.l"
 {
-	  /* SIP: axis 2 polynomial coefficient. */
+	  // SIP: axis 2 polynomial coefficient.
 	  i = 2;
 	  sipflag = 2;
 	
@@ -22633,9 +22630,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 1292 "wcspih.l"
+#line 1289 "wcspih.l"
 {
-	  /* SIP: axis 1 inverse polynomial coefficient. */
+	  // SIP: axis 1 inverse polynomial coefficient.
 	  i = 1;
 	  sipflag = 3;
 	
@@ -22645,9 +22642,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
-#line 1301 "wcspih.l"
+#line 1298 "wcspih.l"
 {
-	  /* SIP: axis 2 inverse polynomial coefficient. */
+	  // SIP: axis 2 inverse polynomial coefficient.
 	  i = 2;
 	  sipflag = 3;
 	
@@ -22657,9 +22654,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-#line 1310 "wcspih.l"
+#line 1307 "wcspih.l"
 {
-	  /* DSS: LLH corner pixel coordinate 1. */
+	  // DSS: LLH corner pixel coordinate 1.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp;
@@ -22672,9 +22669,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-#line 1322 "wcspih.l"
+#line 1319 "wcspih.l"
 {
-	  /* DSS: LLH corner pixel coordinate 2. */
+	  // DSS: LLH corner pixel coordinate 2.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+1;
@@ -22687,9 +22684,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-#line 1334 "wcspih.l"
+#line 1331 "wcspih.l"
 {
-	  /* DSS: plate centre x-coordinate in micron. */
+	  // DSS: plate centre x-coordinate in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+2;
@@ -22702,9 +22699,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-#line 1346 "wcspih.l"
+#line 1343 "wcspih.l"
 {
-	  /* DSS: plate centre y-coordinate in micron. */
+	  // DSS: plate centre y-coordinate in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+3;
@@ -22717,9 +22714,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
-#line 1358 "wcspih.l"
+#line 1355 "wcspih.l"
 {
-	  /* DSS: pixel x-dimension in micron. */
+	  // DSS: pixel x-dimension in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+4;
@@ -22732,9 +22729,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-#line 1370 "wcspih.l"
+#line 1367 "wcspih.l"
 {
-	  /* DSS: pixel y-dimension in micron. */
+	  // DSS: pixel y-dimension in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+5;
@@ -22747,9 +22744,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
-#line 1382 "wcspih.l"
+#line 1379 "wcspih.l"
 {
-	  /* DSS: plate centre, right ascension - hours. */
+	  // DSS: plate centre, right ascension - hours.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+6;
@@ -22762,9 +22759,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-#line 1394 "wcspih.l"
+#line 1391 "wcspih.l"
 {
-	  /* DSS: plate centre, right ascension - minutes. */
+	  // DSS: plate centre, right ascension - minutes.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+7;
@@ -22777,9 +22774,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-#line 1406 "wcspih.l"
+#line 1403 "wcspih.l"
 {
-	  /* DSS: plate centre, right ascension - seconds. */
+	  // DSS: plate centre, right ascension - seconds.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+8;
@@ -22792,9 +22789,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 114:
 YY_RULE_SETUP
-#line 1418 "wcspih.l"
+#line 1415 "wcspih.l"
 {
-	  /* DSS: plate centre, declination - sign. */
+	  // DSS: plate centre, declination - sign.
 	  valtype = STRING;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+9;
@@ -22807,9 +22804,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
-#line 1430 "wcspih.l"
+#line 1427 "wcspih.l"
 {
-	  /* DSS: plate centre, declination - degrees. */
+	  // DSS: plate centre, declination - degrees.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+10;
@@ -22822,9 +22819,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-#line 1442 "wcspih.l"
+#line 1439 "wcspih.l"
 {
-	  /* DSS: plate centre, declination - arcmin. */
+	  // DSS: plate centre, declination - arcmin.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+11;
@@ -22837,9 +22834,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-#line 1454 "wcspih.l"
+#line 1451 "wcspih.l"
 {
-	  /* DSS: plate centre, declination - arcsec. */
+	  // DSS: plate centre, declination - arcsec.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+12;
@@ -22852,9 +22849,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 1466 "wcspih.l"
+#line 1463 "wcspih.l"
 {
-	  /* DSS: plate identification (insufficient to trigger DSS). */
+	  // DSS: plate identification (insufficient to trigger DSS).
 	  valtype = STRING;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+13;
@@ -22867,9 +22864,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 1478 "wcspih.l"
+#line 1475 "wcspih.l"
 {
-	  /* DSS: axis 1 polynomial coefficient. */
+	  // DSS: axis 1 polynomial coefficient.
 	  i = 1;
 	  dssflag = 3;
 	
@@ -22879,9 +22876,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-#line 1487 "wcspih.l"
+#line 1484 "wcspih.l"
 {
-	  /* DSS: axis 2 polynomial coefficient. */
+	  // DSS: axis 2 polynomial coefficient.
 	  i = 2;
 	  dssflag = 3;
 	
@@ -22891,9 +22888,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 121:
 YY_RULE_SETUP
-#line 1496 "wcspih.l"
+#line 1493 "wcspih.l"
 {
-	  /* TNX or ZPX: string-encoded data array. */
+	  // TNX or ZPX: string-encoded data array.
 	  sscanf(yytext, "WAT%d_%d", &i, &m);
 	  if (watn < m) watn = m;
 	  watflag = 1;
@@ -22911,7 +22908,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 122:
 YY_RULE_SETUP
-#line 1513 "wcspih.l"
+#line 1510 "wcspih.l"
 {
 	  if (wcspih_nkeyrec) {
 	    wcspih_nkeyrec = 0;
@@ -22924,161 +22921,161 @@ YY_RULE_SETUP
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-#line 1523 "wcspih.l"
+#line 1520 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 124:
-#line 1528 "wcspih.l"
+#line 1525 "wcspih.l"
 case 125:
-#line 1529 "wcspih.l"
+#line 1526 "wcspih.l"
 case 126:
-#line 1530 "wcspih.l"
+#line 1527 "wcspih.l"
 case 127:
 YY_RULE_SETUP
-#line 1530 "wcspih.l"
+#line 1527 "wcspih.l"
 {
 	  sscanf(yytext, "%d%c", &i, &a);
 	  BEGIN(VALUE);
 	}
 	YY_BREAK
 case 128:
-#line 1536 "wcspih.l"
+#line 1533 "wcspih.l"
 case 129:
-#line 1537 "wcspih.l"
+#line 1534 "wcspih.l"
 case 130:
-#line 1538 "wcspih.l"
+#line 1535 "wcspih.l"
 case 131:
-#line 1539 "wcspih.l"
+#line 1536 "wcspih.l"
 case 132:
-#line 1540 "wcspih.l"
+#line 1537 "wcspih.l"
 case 133:
-#line 1541 "wcspih.l"
+#line 1538 "wcspih.l"
 case 134:
 YY_RULE_SETUP
-#line 1541 "wcspih.l"
+#line 1538 "wcspih.l"
 {
 	  if (relax & WCSHDR_reject) {
-	    /* Violates the basic FITS standard. */
+	    // Violates the basic FITS standard.
 	    errmsg = "indices in parameterized keywords must not have "
 	             "leading zeroes";
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 135:
-#line 1555 "wcspih.l"
+#line 1552 "wcspih.l"
 case 136:
-#line 1556 "wcspih.l"
+#line 1553 "wcspih.l"
 case 137:
-#line 1557 "wcspih.l"
+#line 1554 "wcspih.l"
 case 138:
-#line 1558 "wcspih.l"
+#line 1555 "wcspih.l"
 case 139:
-#line 1559 "wcspih.l"
+#line 1556 "wcspih.l"
 case 140:
-#line 1560 "wcspih.l"
+#line 1557 "wcspih.l"
 case 141:
-#line 1561 "wcspih.l"
+#line 1558 "wcspih.l"
 case 142:
-#line 1562 "wcspih.l"
+#line 1559 "wcspih.l"
 case 143:
 YY_RULE_SETUP
-#line 1562 "wcspih.l"
+#line 1559 "wcspih.l"
 {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
 	YY_BREAK
 case 144:
 YY_RULE_SETUP
-#line 1569 "wcspih.l"
+#line 1566 "wcspih.l"
 {
-	  /* Let it go. */
+	  // Let it go.
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 145:
 YY_RULE_SETUP
-#line 1574 "wcspih.l"
+#line 1571 "wcspih.l"
 {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "keyword looks very much like %s but isn't",
 	      keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Let it go. */
+	    // Let it go.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 146:
-#line 1589 "wcspih.l"
+#line 1586 "wcspih.l"
 case 147:
-#line 1590 "wcspih.l"
+#line 1587 "wcspih.l"
 case 148:
-#line 1591 "wcspih.l"
+#line 1588 "wcspih.l"
 case 149:
 YY_RULE_SETUP
-#line 1591 "wcspih.l"
+#line 1588 "wcspih.l"
 {
 	  sscanf(yytext, "%d_%d%c", &i, &j, &a);
 	  BEGIN(VALUE);
 	}
 	YY_BREAK
 case 150:
-#line 1598 "wcspih.l"
+#line 1595 "wcspih.l"
 case 151:
-#line 1599 "wcspih.l"
+#line 1596 "wcspih.l"
 case 152:
-#line 1600 "wcspih.l"
+#line 1597 "wcspih.l"
 case 153:
-#line 1601 "wcspih.l"
+#line 1598 "wcspih.l"
 case 154:
-#line 1602 "wcspih.l"
+#line 1599 "wcspih.l"
 case 155:
-#line 1603 "wcspih.l"
+#line 1600 "wcspih.l"
 case 156:
-#line 1604 "wcspih.l"
+#line 1601 "wcspih.l"
 case 157:
-#line 1605 "wcspih.l"
+#line 1602 "wcspih.l"
 case 158:
-#line 1606 "wcspih.l"
+#line 1603 "wcspih.l"
 case 159:
-#line 1607 "wcspih.l"
+#line 1604 "wcspih.l"
 case 160:
-#line 1608 "wcspih.l"
+#line 1605 "wcspih.l"
 case 161:
-#line 1609 "wcspih.l"
+#line 1606 "wcspih.l"
 case 162:
-#line 1610 "wcspih.l"
+#line 1607 "wcspih.l"
 case 163:
-#line 1611 "wcspih.l"
+#line 1608 "wcspih.l"
 case 164:
-#line 1612 "wcspih.l"
+#line 1609 "wcspih.l"
 case 165:
-#line 1613 "wcspih.l"
+#line 1610 "wcspih.l"
 case 166:
-#line 1614 "wcspih.l"
+#line 1611 "wcspih.l"
 case 167:
-#line 1615 "wcspih.l"
+#line 1612 "wcspih.l"
 case 168:
-#line 1616 "wcspih.l"
+#line 1613 "wcspih.l"
 case 169:
-#line 1617 "wcspih.l"
+#line 1614 "wcspih.l"
 case 170:
 YY_RULE_SETUP
-#line 1617 "wcspih.l"
+#line 1614 "wcspih.l"
 {
 	  if (((altlin == 1) && (relax & WCSHDR_PC0i_0ja)) ||
 	      ((altlin == 2) && (relax & WCSHDR_CD0i_0ja))) {
@@ -23091,60 +23088,60 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 171:
-#line 1635 "wcspih.l"
+#line 1632 "wcspih.l"
 case 172:
-#line 1636 "wcspih.l"
+#line 1633 "wcspih.l"
 case 173:
-#line 1637 "wcspih.l"
+#line 1634 "wcspih.l"
 case 174:
-#line 1638 "wcspih.l"
+#line 1635 "wcspih.l"
 case 175:
-#line 1639 "wcspih.l"
+#line 1636 "wcspih.l"
 case 176:
-#line 1640 "wcspih.l"
+#line 1637 "wcspih.l"
 case 177:
-#line 1641 "wcspih.l"
+#line 1638 "wcspih.l"
 case 178:
-#line 1642 "wcspih.l"
+#line 1639 "wcspih.l"
 case 179:
-#line 1643 "wcspih.l"
+#line 1640 "wcspih.l"
 case 180:
 YY_RULE_SETUP
-#line 1643 "wcspih.l"
+#line 1640 "wcspih.l"
 {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
 	YY_BREAK
 case 181:
-#line 1651 "wcspih.l"
+#line 1648 "wcspih.l"
 case 182:
-#line 1652 "wcspih.l"
+#line 1649 "wcspih.l"
 case 183:
-#line 1653 "wcspih.l"
+#line 1650 "wcspih.l"
 case 184:
-#line 1654 "wcspih.l"
+#line 1651 "wcspih.l"
 case 185:
-#line 1655 "wcspih.l"
+#line 1652 "wcspih.l"
 case 186:
-#line 1656 "wcspih.l"
+#line 1653 "wcspih.l"
 case 187:
-#line 1657 "wcspih.l"
+#line 1654 "wcspih.l"
 case 188:
-#line 1658 "wcspih.l"
+#line 1655 "wcspih.l"
 case 189:
-#line 1659 "wcspih.l"
+#line 1656 "wcspih.l"
 case 190:
 YY_RULE_SETUP
-#line 1659 "wcspih.l"
+#line 1656 "wcspih.l"
 {
 	  errmsg = errtxt;
 	  sprintf(errmsg, "%s keyword must use an underscore, not a dash",
@@ -23154,9 +23151,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 191:
 YY_RULE_SETUP
-#line 1666 "wcspih.l"
+#line 1663 "wcspih.l"
 {
-	  /* This covers the defunct forms CD00i00j and PC00i00j. */
+	  // This covers the defunct forms CD00i00j and PC00i00j.
 	  if (((altlin == 1) && (relax & WCSHDR_PC00i00j)) ||
 	      ((altlin == 2) && (relax & WCSHDR_CD00i00j))) {
 	    sscanf(yytext, "%3d%3d", &i, &j);
@@ -23171,23 +23168,23 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 192:
 YY_RULE_SETUP
-#line 1687 "wcspih.l"
+#line 1684 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 193:
-#line 1692 "wcspih.l"
+#line 1689 "wcspih.l"
 case 194:
 YY_RULE_SETUP
-#line 1692 "wcspih.l"
+#line 1689 "wcspih.l"
 {
 	  if (YY_START == CCCCCCCa) {
 	    sscanf(yytext, "%c", &a);
@@ -23201,78 +23198,78 @@ YY_RULE_SETUP
 	YY_BREAK
 case 195:
 YY_RULE_SETUP
-#line 1703 "wcspih.l"
+#line 1700 "wcspih.l"
 {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "invalid alternate code, keyword resembles %s "
 	      "but isn't", keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 196:
-#line 1718 "wcspih.l"
+#line 1715 "wcspih.l"
 case 197:
-#line 1719 "wcspih.l"
+#line 1716 "wcspih.l"
 case 198:
-#line 1720 "wcspih.l"
+#line 1717 "wcspih.l"
 case 199:
 YY_RULE_SETUP
-#line 1720 "wcspih.l"
+#line 1717 "wcspih.l"
 {
 	  sscanf(yytext, "%d_%d%c", &i, &m, &a);
 	  BEGIN(VALUE);
 	}
 	YY_BREAK
 case 200:
-#line 1726 "wcspih.l"
+#line 1723 "wcspih.l"
 case 201:
-#line 1727 "wcspih.l"
+#line 1724 "wcspih.l"
 case 202:
-#line 1728 "wcspih.l"
+#line 1725 "wcspih.l"
 case 203:
-#line 1729 "wcspih.l"
+#line 1726 "wcspih.l"
 case 204:
-#line 1730 "wcspih.l"
+#line 1727 "wcspih.l"
 case 205:
-#line 1731 "wcspih.l"
+#line 1728 "wcspih.l"
 case 206:
-#line 1732 "wcspih.l"
+#line 1729 "wcspih.l"
 case 207:
-#line 1733 "wcspih.l"
+#line 1730 "wcspih.l"
 case 208:
-#line 1734 "wcspih.l"
+#line 1731 "wcspih.l"
 case 209:
-#line 1735 "wcspih.l"
+#line 1732 "wcspih.l"
 case 210:
-#line 1736 "wcspih.l"
+#line 1733 "wcspih.l"
 case 211:
-#line 1737 "wcspih.l"
+#line 1734 "wcspih.l"
 case 212:
-#line 1738 "wcspih.l"
+#line 1735 "wcspih.l"
 case 213:
-#line 1739 "wcspih.l"
+#line 1736 "wcspih.l"
 case 214:
-#line 1740 "wcspih.l"
+#line 1737 "wcspih.l"
 case 215:
-#line 1741 "wcspih.l"
+#line 1738 "wcspih.l"
 case 216:
-#line 1742 "wcspih.l"
+#line 1739 "wcspih.l"
 case 217:
-#line 1743 "wcspih.l"
+#line 1740 "wcspih.l"
 case 218:
-#line 1744 "wcspih.l"
+#line 1741 "wcspih.l"
 case 219:
-#line 1745 "wcspih.l"
+#line 1742 "wcspih.l"
 case 220:
 YY_RULE_SETUP
-#line 1745 "wcspih.l"
+#line 1742 "wcspih.l"
 {
 	  if (((valtype == FLOAT)  && (relax & WCSHDR_PV0i_0ma)) ||
 	      ((valtype == STRING) && (relax & WCSHDR_PS0i_0ma))) {
@@ -23285,60 +23282,60 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 221:
-#line 1763 "wcspih.l"
+#line 1760 "wcspih.l"
 case 222:
-#line 1764 "wcspih.l"
+#line 1761 "wcspih.l"
 case 223:
-#line 1765 "wcspih.l"
+#line 1762 "wcspih.l"
 case 224:
-#line 1766 "wcspih.l"
+#line 1763 "wcspih.l"
 case 225:
-#line 1767 "wcspih.l"
+#line 1764 "wcspih.l"
 case 226:
-#line 1768 "wcspih.l"
+#line 1765 "wcspih.l"
 case 227:
-#line 1769 "wcspih.l"
+#line 1766 "wcspih.l"
 case 228:
-#line 1770 "wcspih.l"
+#line 1767 "wcspih.l"
 case 229:
-#line 1771 "wcspih.l"
+#line 1768 "wcspih.l"
 case 230:
 YY_RULE_SETUP
-#line 1771 "wcspih.l"
+#line 1768 "wcspih.l"
 {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
 	YY_BREAK
 case 231:
-#line 1779 "wcspih.l"
+#line 1776 "wcspih.l"
 case 232:
-#line 1780 "wcspih.l"
+#line 1777 "wcspih.l"
 case 233:
-#line 1781 "wcspih.l"
+#line 1778 "wcspih.l"
 case 234:
-#line 1782 "wcspih.l"
+#line 1779 "wcspih.l"
 case 235:
-#line 1783 "wcspih.l"
+#line 1780 "wcspih.l"
 case 236:
-#line 1784 "wcspih.l"
+#line 1781 "wcspih.l"
 case 237:
-#line 1785 "wcspih.l"
+#line 1782 "wcspih.l"
 case 238:
-#line 1786 "wcspih.l"
+#line 1783 "wcspih.l"
 case 239:
-#line 1787 "wcspih.l"
+#line 1784 "wcspih.l"
 case 240:
 YY_RULE_SETUP
-#line 1787 "wcspih.l"
+#line 1784 "wcspih.l"
 {
 	  errmsg = errtxt;
 	  sprintf(errmsg, "%s keyword must use an underscore, not a dash",
@@ -23348,18 +23345,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 241:
 YY_RULE_SETUP
-#line 1794 "wcspih.l"
+#line 1791 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 242:
-#line 1799 "wcspih.l"
+#line 1796 "wcspih.l"
 case 243:
-#line 1800 "wcspih.l"
+#line 1797 "wcspih.l"
 case 244:
 YY_RULE_SETUP
-#line 1800 "wcspih.l"
+#line 1797 "wcspih.l"
 {
 	  a = ' ';
 	  sscanf(yytext, "%d%c", &i, &a);
@@ -23377,14 +23374,14 @@ YY_RULE_SETUP
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 	YY_BREAK
 case 245:
 YY_RULE_SETUP
-#line 1822 "wcspih.l"
+#line 1819 "wcspih.l"
 {
 	  yyless(0);
 	  BEGIN(CCCCCia);
@@ -23392,7 +23389,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 246:
 YY_RULE_SETUP
-#line 1827 "wcspih.l"
+#line 1824 "wcspih.l"
 {
 	  if (relax & WCSHDR_PROJPn) {
 	    sscanf(yytext, "%d", &m);
@@ -23410,10 +23407,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 247:
-#line 1844 "wcspih.l"
+#line 1841 "wcspih.l"
 case 248:
 YY_RULE_SETUP
-#line 1844 "wcspih.l"
+#line 1841 "wcspih.l"
 {
 	  if (relax & (WCSHDR_PROJPn | WCSHDR_reject)) {
 	    errmsg = "invalid PROJPn keyword";
@@ -23426,18 +23423,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 249:
 YY_RULE_SETUP
-#line 1854 "wcspih.l"
+#line 1851 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 250:
-#line 1859 "wcspih.l"
+#line 1856 "wcspih.l"
 case 251:
 YY_RULE_SETUP
-#line 1859 "wcspih.l"
+#line 1856 "wcspih.l"
 {
-	  /* SIP keywords. */
+	  // SIP keywords.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.dp);
@@ -23451,21 +23448,21 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 252:
-#line 1874 "wcspih.l"
+#line 1871 "wcspih.l"
 case 253:
 YY_RULE_SETUP
-#line 1874 "wcspih.l"
+#line 1871 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 254:
-#line 1879 "wcspih.l"
+#line 1876 "wcspih.l"
 case 255:
 YY_RULE_SETUP
-#line 1879 "wcspih.l"
+#line 1876 "wcspih.l"
 {
-	  /* DSS keywords. */
+	  // DSS keywords.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = &(distem.dp);
@@ -23480,7 +23477,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 256:
 YY_RULE_SETUP
-#line 1893 "wcspih.l"
+#line 1890 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
@@ -23488,11 +23485,11 @@ YY_RULE_SETUP
 case 257:
 /* rule 257 can match eol */
 YY_RULE_SETUP
-#line 1897 "wcspih.l"
+#line 1894 "wcspih.l"
 {
-	  /* Special handling for this iconic DSS keyword. */
+	  // Special handling for this iconic DSS keyword.
 	  if (1 < ipass) {
-	    /* Look for a minus sign. */
+	    // Look for a minus sign.
 	    sscanf(yytext, "= '%s", strtmp);
 	    dbltmp = strcmp(strtmp, "-") ? 1.0 : -1.0;
 	  }
@@ -23502,16 +23499,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 258:
 YY_RULE_SETUP
-#line 1908 "wcspih.l"
+#line 1905 "wcspih.l"
 {
 	  BEGIN(DISCARD);
 	}
 	YY_BREAK
 case 259:
 YY_RULE_SETUP
-#line 1912 "wcspih.l"
+#line 1909 "wcspih.l"
 {
-	  /* Do checks on i, j & m. */
+	  // Do checks on i, j & m.
 	  if (99 < i || 99 < j || 99 < m) {
 	    if (relax & WCSHDR_reject) {
 	      if (99 < i || 99 < j) {
@@ -23522,7 +23519,7 @@ YY_RULE_SETUP
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -23548,7 +23545,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 260:
 YY_RULE_SETUP
-#line 1948 "wcspih.l"
+#line 1945 "wcspih.l"
 {
 	  errmsg = "invalid KEYWORD = VALUE syntax";
 	  BEGIN(ERROR);
@@ -23556,13 +23553,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 261:
 YY_RULE_SETUP
-#line 1953 "wcspih.l"
+#line 1950 "wcspih.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    sscanf(yytext, "%d", &inttmp);
 	
 	    BEGIN(COMMENT);
@@ -23571,7 +23568,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 262:
 YY_RULE_SETUP
-#line 1965 "wcspih.l"
+#line 1962 "wcspih.l"
 {
 	  errmsg = "an integer value was expected";
 	  BEGIN(ERROR);
@@ -23579,13 +23576,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 263:
 YY_RULE_SETUP
-#line 1970 "wcspih.l"
+#line 1967 "wcspih.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    wcsutil_str2double(yytext, &dbltmp);
 
 	    if (chekval && chekval(dbltmp)) {
@@ -23599,7 +23596,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 264:
 YY_RULE_SETUP
-#line 1987 "wcspih.l"
+#line 1984 "wcspih.l"
 {
 	  errmsg = "a floating-point value was expected";
 	  BEGIN(ERROR);
@@ -23607,13 +23604,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 265:
 YY_RULE_SETUP
-#line 1992 "wcspih.l"
+#line 1989 "wcspih.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue as integer and fractional parts. */
+	    // Read the keyvalue as integer and fractional parts.
 	    wcsutil_str2double2(yytext, dbl2tmp);
 	
 	    BEGIN(COMMENT);
@@ -23622,7 +23619,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 266:
 YY_RULE_SETUP
-#line 2004 "wcspih.l"
+#line 2001 "wcspih.l"
 {
 	  errmsg = "a floating-point value was expected";
 	  BEGIN(ERROR);
@@ -23631,16 +23628,16 @@ YY_RULE_SETUP
 case 267:
 /* rule 267 can match eol */
 YY_RULE_SETUP
-#line 2009 "wcspih.l"
+#line 2006 "wcspih.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    strcpy(strtmp, yytext+1);
 	
-	    /* Squeeze out repeated quotes. */
+	    // Squeeze out repeated quotes.
 	    ix = 0;
 	    for (jx = 0; jx < 72; jx++) {
 	      if (ix < jx) {
@@ -23663,7 +23660,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 268:
 YY_RULE_SETUP
-#line 2038 "wcspih.l"
+#line 2035 "wcspih.l"
 {
 	  errmsg = "a string value was expected";
 	  BEGIN(ERROR);
@@ -23672,7 +23669,7 @@ YY_RULE_SETUP
 case 269:
 /* rule 269 can match eol */
 YY_RULE_SETUP
-#line 2043 "wcspih.l"
+#line 2040 "wcspih.l"
 {
 	  if (ipass == 1) {
 	    BEGIN(COMMENT);
@@ -23686,7 +23683,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 270:
 YY_RULE_SETUP
-#line 2054 "wcspih.l"
+#line 2051 "wcspih.l"
 {
 	  errmsg = "a record was expected";
 	  BEGIN(ERROR);
@@ -23694,7 +23691,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 271:
 YY_RULE_SETUP
-#line 2059 "wcspih.l"
+#line 2056 "wcspih.l"
 {
 	  strcpy(strtmp, yytext);
 	  BEGIN(RECCOLON);
@@ -23702,7 +23699,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 272:
 YY_RULE_SETUP
-#line 2064 "wcspih.l"
+#line 2061 "wcspih.l"
 {
 	  errmsg = "invalid record field";
 	  BEGIN(ERROR);
@@ -23710,14 +23707,14 @@ YY_RULE_SETUP
 	YY_BREAK
 case 273:
 YY_RULE_SETUP
-#line 2069 "wcspih.l"
+#line 2066 "wcspih.l"
 {
 	  BEGIN(RECVALUE);
 	}
 	YY_BREAK
 case 274:
 YY_RULE_SETUP
-#line 2073 "wcspih.l"
+#line 2070 "wcspih.l"
 {
 	  errmsg = "invalid record syntax";
 	  BEGIN(ERROR);
@@ -23725,7 +23722,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 275:
 YY_RULE_SETUP
-#line 2078 "wcspih.l"
+#line 2075 "wcspih.l"
 {
 	  rectype = 0;
 	  sscanf(yytext, "%d", &inttmp);
@@ -23734,7 +23731,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 276:
 YY_RULE_SETUP
-#line 2084 "wcspih.l"
+#line 2081 "wcspih.l"
 {
 	  rectype = 1;
 	  wcsutil_str2double(yytext, &dbltmp);
@@ -23743,7 +23740,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 277:
 YY_RULE_SETUP
-#line 2090 "wcspih.l"
+#line 2087 "wcspih.l"
 {
 	  errmsg = "invalid record value";
 	  BEGIN(ERROR);
@@ -23751,7 +23748,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 278:
 YY_RULE_SETUP
-#line 2095 "wcspih.l"
+#line 2092 "wcspih.l"
 {
 	  BEGIN(COMMENT);
 	}
@@ -23761,19 +23758,19 @@ case 279:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2099 "wcspih.l"
+#line 2096 "wcspih.l"
 {
 	  if (ipass == 1) {
-	    /* Do first-pass bookkeeping. */
+	    // Do first-pass bookkeeping.
 	    wcspih_pass1(naxis, i, j, a, distype, alts, dpq, npptr);
 	    BEGIN(FLUSH);
 	
 	  } else if (*wcs) {
-	    /* Store the value now that the keyrecord has been validated. */
+	    // Store the value now that the keyrecord has been validated.
 	    gotone = 0;
 	    for (ialt = 0; ialt < *nwcs; ialt++) {
-	      /* The loop here is for keywords that apply */
-	      /* to every alternate; these have a == 0. */
+	      // The loop here is for keywords that apply
+	      // to every alternate; these have a == 0.
 	      if (a >= 'A') {
 	        ialt = alts[a-'A'+1];
 	        if (ialt < 0) break;
@@ -23782,11 +23779,11 @@ YY_RULE_SETUP
 	
 	      if (vptr) {
 	        if (sipflag) {
-	          /* Translate a SIP keyword into DPja. */
+	          // Translate a SIP keyword into DPja.
 	          disp = (*wcs)->lin.dispre;
 	          ipx = (disp->ndp)++;
 	
-	          /* SIP doesn't have alternates. */
+	          // SIP doesn't have alternates.
 	          sprintf(keyword, "DP%d", i);
 	          sprintf(strtmp, "SIP.%s.%d_%d", (sipflag==2)?"FWD":"REV",
 	                  p, q);
@@ -23797,27 +23794,27 @@ YY_RULE_SETUP
 	          }
 	
 	        } else if (dssflag) {
-	          /* All DSS keywords require special handling. */
+	          // All DSS keywords require special handling.
 	          if (dssflag == 1) {
-	            /* Temporary parameter for DSS used by wcspih_final(). */
+	            // Temporary parameter for DSS used by wcspih_final().
 	            *((double *)vptr) = dbltmp;
 	
 	          } else if (dssflag == 2) {
-	            /* Temporary parameter for DSS used by wcspih_final(). */
+	            // Temporary parameter for DSS used by wcspih_final().
 	            strcpy((char *)vptr, strtmp);
 	
 	          } else {
-	            /* Translate a DSS keyword into DQia. */
+	            // Translate a DSS keyword into DQia.
 	            if (m <= 13 || dbltmp != 0.0) {
 	              disp = (*wcs)->lin.disseq;
 	              ipx = (disp->ndp)++;
 	
-	              /* DSS doesn't have alternates. */
+	              // DSS doesn't have alternates.
 	              sprintf(keyword, "DQ%d", i);
 	              sprintf(strtmp, "DSS.AMD.%d", m);
 	              dpfill(disp->dp+ipx, keyword, strtmp, i, 1, 0, dbltmp);
 	
-	              /* Also required by wcspih_final(). */
+	              // Also required by wcspih_final().
 	              if (m <= 3) {
 	                dsstmp[13+(i-1)*3+m] = dbltmp;
 	              }
@@ -23825,32 +23822,32 @@ YY_RULE_SETUP
 	          }
 	
 	        } else if (watflag) {
-	          /* String array for TNX and ZPX used by wcspih_final(). */
+	          // String array for TNX and ZPX used by wcspih_final().
 	          strcpy((char *)vptr, strtmp);
 	
 	        } else {
-	          /* An "ordinary" keyword. */
+	          // An "ordinary" keyword.
 	          wcsp = *wcs + ialt;
 	          if (auxprm) {
-	            /* Additional auxiliary parameter. */
+	            // Additional auxiliary parameter.
 	            auxp = wcsp->aux;
 	            voff = (char *)vptr - (char *)(&auxtem);
 	            wptr = (void *)((char *)auxp + voff);
 	
 	          } else if (distype) {
-	            /* Distortion parameter of some kind. */
+	            // Distortion parameter of some kind.
 	            if (distype == PRIOR) {
-	              /* Prior distortion. */
+	              // Prior distortion.
 	              disp = wcsp->lin.dispre;
 	            } else {
-	              /* Sequent distortion. */
+	              // Sequent distortion.
 	              disp = wcsp->lin.disseq;
 	            }
 	            voff = (char *)vptr - (char *)(&distem);
 	            wptr = (void *)((char *)disp + voff);
 	
 	          } else {
-	            /* A parameter that lives directly in wcsprm. */
+	            // A parameter that lives directly in wcsprm.
 	            voff = (char *)vptr - (char *)(&wcstem);
 	            wptr = (void *)((char *)wcsp + voff);
 	          }
@@ -23859,7 +23856,7 @@ YY_RULE_SETUP
 	            *((int *)wptr) = inttmp;
 	
 	          } else if (valtype == FLOAT) {
-	            /* Apply keyword parameterization. */
+	            // Apply keyword parameterization.
 	            if (npptr == npv) {
 	              ipx = (wcsp->npv)++;
 	              wcsp->pv[ipx].i = i;
@@ -23880,14 +23877,14 @@ YY_RULE_SETUP
 	              *((double *)wptr) = dbltmp;
 	            }
 	
-	            /* Flag presence of PCi_ja, or CDi_ja and/or CROTAia. */
+	            // Flag presence of PCi_ja, or CDi_ja and/or CROTAia.
 	            if (altlin) {
 	              wcsp->altlin |= altlin;
 	              altlin = 0;
 	            }
 	
 	          } else if (valtype == FLOAT2) {
-	            /* Split MJDREF and JDREF into integer and fraction.*/
+	            // Split MJDREF and JDREF into integer and fraction.
 	            if (special) {
 	              special(wptr, dbl2tmp);
 	            } else {
@@ -23896,7 +23893,7 @@ YY_RULE_SETUP
 	            }
 	
 	          } else if (valtype == STRING) {
-	            /* Apply keyword parameterization. */
+	            // Apply keyword parameterization.
 	            if (npptr == nps) {
 	              ipx = (wcsp->nps)++;
 	              wcsp->ps[ipx].i = i;
@@ -23961,7 +23958,7 @@ case 280:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2293 "wcspih.l"
+#line 2290 "wcspih.l"
 {
 	  errmsg = "invalid keyvalue";
 	  BEGIN(ERROR);
@@ -23972,7 +23969,7 @@ case 281:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2298 "wcspih.l"
+#line 2295 "wcspih.l"
 {
 	  errmsg = "invalid keyvalue";
 	  BEGIN(ERROR);
@@ -23983,7 +23980,7 @@ case 282:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2303 "wcspih.l"
+#line 2300 "wcspih.l"
 {
 	  errmsg = "invalid keyvalue or malformed keycomment";
 	  BEGIN(ERROR);
@@ -23994,7 +23991,7 @@ case 283:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2308 "wcspih.l"
+#line 2305 "wcspih.l"
 {
 	  errmsg = "malformed keycomment";
 	  BEGIN(ERROR);
@@ -24005,11 +24002,11 @@ case 284:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2313 "wcspih.l"
+#line 2310 "wcspih.l"
 {
 	  if (ipass == npass) {
 	    if (ctrl < 0) {
-	      /* Preserve discards. */
+	      // Preserve discards.
 	      keep = keyrec;
 	
 	    } else if (2 < ctrl) {
@@ -24026,13 +24023,13 @@ case 285:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 2328 "wcspih.l"
+#line 2325 "wcspih.l"
 {
 	  if (ipass == npass) {
 	    (*nreject)++;
 	
 	    if (ctrl%10 == -1) {
-	      /* Preserve rejects. */
+	      // Preserve rejects.
 	      keep = keyrec;
 	    }
 	
@@ -24047,7 +24044,7 @@ YY_RULE_SETUP
 case 286:
 /* rule 286 can match eol */
 YY_RULE_SETUP
-#line 2345 "wcspih.l"
+#line 2342 "wcspih.l"
 {
 	  if (ipass == npass && keep) {
 	    if (hptr < keep) {
@@ -24058,7 +24055,7 @@ YY_RULE_SETUP
 	
 	  naux += auxprm;
 	
-	  /* Throw away the rest of the line and reset for the next one. */
+	  // Throw away the rest of the line and reset for the next one.
 	  i = j = 0;
 	  m = 0;
 	  a = ' ';
@@ -24109,9 +24106,9 @@ case YY_STATE_EOF(COMMENT):
 case YY_STATE_EOF(DISCARD):
 case YY_STATE_EOF(ERROR):
 case YY_STATE_EOF(FLUSH):
-#line 2379 "wcspih.l"
+#line 2376 "wcspih.l"
 {
-	  /* End-of-input. */
+	  // End-of-input.
 	  if (ipass == 1) {
 	    if ((status = wcspih_init1(naxis, alts, dpq, npv, nps, ndp, ndq,
 	                               naux, distran, nwcs, wcs)) ||
@@ -24185,10 +24182,10 @@ case YY_STATE_EOF(FLUSH):
 	YY_BREAK
 case 287:
 YY_RULE_SETUP
-#line 2452 "wcspih.l"
+#line 2449 "wcspih.l"
 ECHO;
 	YY_BREAK
-#line 24192 "wcspih.c"
+#line 24189 "wcspih.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -25353,7 +25350,7 @@ void yyfree (void * ptr , yyscan_t yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 2452 "wcspih.l"
+#line 2449 "wcspih.l"
 
 
 /*----------------------------------------------------------------------------
@@ -25373,8 +25370,8 @@ void wcspih_pass1(
   int *npptr)
 
 {
-  /* On the first pass alts[] is used to determine the number of axes */
-  /* for each of the 27 possible alternate coordinate descriptions.   */
+  // On the first pass alts[] is used to determine the number of axes
+  // for each of the 27 possible alternate coordinate descriptions.
   int ialt, *ip;
 
   if (a == 0) {
@@ -25392,7 +25389,7 @@ void wcspih_pass1(
     *ip = naxis;
   }
 
-  /* i or j can be greater than naxis. */
+  // i or j can be greater than naxis.
   if (*ip < i) {
     *ip = i;
   }
@@ -25401,10 +25398,10 @@ void wcspih_pass1(
     *ip = j;
   }
 
-  /* Type of distortions present. */
+  // Type of distortions present.
   dpq[ialt] |= distype;
 
-  /* Count PVi_ma, PSi_ma, DPja, or DQia keywords. */
+  // Count PVi_ma, PSi_ma, DPja, or DQia keywords.
   if (npptr) {
     npptr[ialt]++;
   }
@@ -25434,37 +25431,37 @@ int wcspih_init1(
   struct wcsprm *wcsp;
   struct disprm *dis;
 
-  /* Find the number of coordinate descriptions. */
+  // Find the number of coordinate descriptions.
   *nwcs = 0;
   for (ialt = 0; ialt < 27; ialt++) {
     if (alts[ialt]) (*nwcs)++;
   }
 
   if ((defaults = !(*nwcs) && naxis)) {
-    /* NAXIS is non-zero but there were no WCS keywords with an alternate
-       version code; create a default WCS with blank alternate version. */
+    // NAXIS is non-zero but there were no WCS keywords with an alternate
+    // version code; create a default WCS with blank alternate version.
     wcspih_pass1(naxis, 0, 0, ' ', 0, alts, dpq, 0x0);
     *nwcs = 1;
   }
 
   if (*nwcs) {
-    /* Allocate memory for the required number of wcsprm structs. */
+    // Allocate memory for the required number of wcsprm structs.
     if ((*wcs = calloc(*nwcs, sizeof(struct wcsprm))) == 0x0) {
       return WCSHDRERR_MEMORY;
     }
 
     ndis = 0;
     if (distran == SIP) {
-      /* DPja.NAXES and DPja.OFFSET.j to be added for SIP (see below and
-         wcspih_final()). */
+      // DPja.NAXES and DPja.OFFSET.j to be added for SIP (see below and
+      // wcspih_final()).
       ndp[0] += 6;
 
     } else if (distran == DSS) {
-      /* DPja.NAXES to be added for DSS (see below and wcspih_final()). */
+      // DPja.NAXES to be added for DSS (see below and wcspih_final()).
       ndq[0] += 2;
     }
 
-    /* Initialize each wcsprm struct. */
+    // Initialize each wcsprm struct.
     wcsp = *wcs;
     *nwcs = 0;
     for (ialt = 0; ialt < 27; ialt++) {
@@ -25477,30 +25474,30 @@ int wcspih_init1(
           break;
         }
 
-        /* Record the alternate version code. */
+        // Record the alternate version code.
         if (ialt) {
           wcsp->alt[0] = 'A' + ialt - 1;
         }
 
-        /* Record in wcsname whether this is a default description. */
+        // Record in wcsname whether this is a default description.
         if (defaults) {
           strcpy(wcsp->wcsname, "DEFAULTS");
         }
 
-        /* Any additional auxiliary keywords present? */
+        // Any additional auxiliary keywords present?
         if (naux) {
           if (wcsauxi(1, wcsp)) {
             return WCSHDRERR_MEMORY;
           }
         }
 
-        /* Any distortions present? */
+        // Any distortions present?
         if (dpq[ialt] & 1) {
           if ((dis = calloc(1, sizeof(struct disprm))) == 0x0) {
             return WCSHDRERR_MEMORY;
           }
 
-          /* Attach it to linprm.  Also inits it. */
+          // Attach it to linprm.  Also inits it.
           ndis++;
           ndpmax = ndp[ialt];
           dis->flag = -1;
@@ -25512,33 +25509,33 @@ int wcspih_init1(
             return WCSHDRERR_MEMORY;
           }
 
-          /* Attach it to linprm.  Also inits it. */
+          // Attach it to linprm.  Also inits it.
           ndis++;
           ndpmax = ndq[ialt];
           dis->flag = -1;
           lindist(2, &(wcsp->lin), dis, ndpmax);
         }
 
-        /* On the second pass alts[] indexes the array of wcsprm structs. */
+        // On the second pass alts[] indexes the array of wcsprm structs.
         alts[ialt] = (*nwcs)++;
 
         wcsp++;
 
       } else {
-        /* Signal that there is no wcsprm for this alt. */
+        // Signal that there is no wcsprm for this alt.
         alts[ialt] = -1;
       }
     }
 
 
-    /* Translated distortion?  Neither SIP nor DSS have alternates, so the */
-    /* presence of keywords for either (not both together), as flagged by  */
-    /* distran, necessarily refers to the primary representation.          */
+    // Translated distortion?  Neither SIP nor DSS have alternates, so the
+    // presence of keywords for either (not both together), as flagged by
+    // distran, necessarily refers to the primary representation.
     if (distran == SIP) {
       strcpy((*wcs)->lin.dispre->dtype[0], "SIP");
       strcpy((*wcs)->lin.dispre->dtype[1], "SIP");
 
-      /* SIP doesn't have axis mapping. */
+      // SIP doesn't have axis mapping.
       (*wcs)->lin.dispre->ndp = 6;
       dpfill((*wcs)->lin.dispre->dp,   "DP1", "NAXES",  0, 0, 2, 0.0);
       dpfill((*wcs)->lin.dispre->dp+3, "DP2", "NAXES",  0, 0, 2, 0.0);
@@ -25547,7 +25544,7 @@ int wcspih_init1(
       strcpy((*wcs)->lin.disseq->dtype[0], "DSS");
       strcpy((*wcs)->lin.disseq->dtype[1], "DSS");
 
-      /* The Paper IV translation of DSS doesn't require an axis mapping. */
+      // The Paper IV translation of DSS doesn't require an axis mapping.
       (*wcs)->lin.disseq->ndp = 2;
       dpfill((*wcs)->lin.disseq->dp,   "DQ1", "NAXES",  0, 0, 2, 0.0);
       dpfill((*wcs)->lin.disseq->dp+1, "DQ2", "NAXES",  0, 0, 2, 0.0);
@@ -25565,7 +25562,7 @@ int wcspih_init1(
 int wcspih_jdref(double *mjdref, const double *jdref)
 
 {
-  /* Set MJDREF from JDREF. */
+  // Set MJDREF from JDREF.
   if (undefined(mjdref[0] && undefined(mjdref[1]))) {
     mjdref[0] = jdref[0] - 2400000.0;
     mjdref[1] = jdref[1] - 0.5;
@@ -25582,7 +25579,7 @@ int wcspih_jdref(double *mjdref, const d
 int wcspih_jdrefi(double *mjdref, const double *jdrefi)
 
 {
-  /* Set the integer part of MJDREF from JDREFI. */
+  // Set the integer part of MJDREF from JDREFI.
   if (undefined(mjdref[0])) {
     mjdref[0] = *jdrefi - 2400000.5;
   }
@@ -25594,7 +25591,7 @@ int wcspih_jdrefi(double *mjdref, const
 int wcspih_jdreff(double *mjdref, const double *jdreff)
 
 {
-  /* Set the fractional part of MJDREF from JDREFF. */
+  // Set the fractional part of MJDREF from JDREFF.
   if (undefined(mjdref[1])) {
     mjdref[1] = *jdreff;
   }
@@ -25610,7 +25607,7 @@ int wcspih_jdreff(double *mjdref, const
 int wcspih_epoch(double *equinox, const double *epoch)
 
 {
-  /* If EQUINOXa is currently undefined then set it from EPOCHa. */
+  // If EQUINOXa is currently undefined then set it from EPOCHa.
   if (undefined(*equinox)) {
     *equinox = *epoch;
   }
@@ -25628,9 +25625,9 @@ int wcspih_vsource(double *zsource, cons
 {
   double beta, c = 299792458.0;
 
-  /* If ZSOURCEa is currently undefined then set it from VSOURCEa. */
+  // If ZSOURCEa is currently undefined then set it from VSOURCEa.
   if (undefined(*zsource)) {
-    /* Convert relativistic Doppler velocity to redshift. */
+    // Convert relativistic Doppler velocity to redshift.
     beta = *vsource/c;
     *zsource = (1.0 + beta)/sqrt(1.0 - beta*beta) - 1.0;
   }
@@ -25672,23 +25669,23 @@ int wcspih_final(
   struct wcsprm *wcsp;
 
   for (ialt = 0; ialt < *nwcs; ialt++) {
-    /* Interpret -TAB header keywords. */
+    // Interpret -TAB header keywords.
     if ((status = wcstab(*wcs+ialt))) {
        wcsvfree(nwcs, wcs);
        return status;
     }
 
     if (ndp[ialt] && ndq[ialt]) {
-      /* Prior and sequent distortions co-exist in this representation;
-         ensure the latter gets DVERRa. */
+      // Prior and sequent distortions co-exist in this representation;
+      // ensure the latter gets DVERRa.
       (*wcs+ialt)->lin.disseq->totdis = (*wcs+ialt)->lin.dispre->totdis;
     }
   }
 
-  /* Translated distortion functions; apply only to the primary WCS. */
+  // Translated distortion functions; apply only to the primary WCS.
   wcsp = *wcs;
   if (distran == SIP) {
-    /* SIP doesn't have alternates, nor axis mapping. */
+    // SIP doesn't have alternates, nor axis mapping.
     disp = wcsp->lin.dispre;
     dpfill(disp->dp+1, "DP1", "OFFSET.1",  0, 1, 0, wcsp->crpix[0]);
     dpfill(disp->dp+2, "DP1", "OFFSET.2",  0, 1, 0, wcsp->crpix[1]);
@@ -25696,8 +25693,8 @@ int wcspih_final(
     dpfill(disp->dp+5, "DP2", "OFFSET.2",  0, 1, 0, wcsp->crpix[1]);
 
   } else if (distran == DSS) {
-    /* DSS doesn't have alternates, nor axis mapping.  This translation */
-    /* follows Paper IV, Sect. 5.2 using the same variable names.       */
+    // DSS doesn't have alternates, nor axis mapping.  This translation
+    // follows Paper IV, Sect. 5.2 using the same variable names.
     CNPIX1 = dsstmp[0];
     CNPIX2 = dsstmp[1];
 
@@ -25739,17 +25736,17 @@ int wcspih_final(
 
     sprintf(wcsp->wcsname, "DSS PLATEID %.4s", (char *)(dsstmp+13));
 
-    /* Erase the approximate WCS provided in modern DSS headers. */
+    // Erase the approximate WCS provided in modern DSS headers.
     wcsp->cd[0] = 0.0;
     wcsp->cd[1] = 0.0;
     wcsp->cd[2] = 0.0;
     wcsp->cd[3] = 0.0;
 
   } else if (distran == WAT) {
-    /* TNX and ZPX don't have alternates, nor axis mapping. */
+    // TNX and ZPX don't have alternates, nor axis mapping.
     disp = wcsp->lin.disseq;
 
-    /* Disassemble the core dump stored in the WATi_m strings. */
+    // Disassemble the core dump stored in the WATi_m strings.
     nterms = 0;
     for (i = 0; i < 2; i++) {
       sscanf(wat[i], "wtype=%s", wtype);
@@ -25759,22 +25756,22 @@ int wcspih_final(
       } else if (strcmp(wtype, "zpx") == 0) {
         strcpy(disp->dtype[i], "WAT-ZPX");
       } else {
-        /* Could contain "tan" or something else to be ignored. */
+        // Could contain "tan" or something else to be ignored.
         lindist(2, &(wcsp->lin), 0x0, 0);
         return 0;
       }
 
-      /* The PROJPn parameters are duplicated on each ZPX axis. */
+      // The PROJPn parameters are duplicated on each ZPX axis.
       if (i == 1 && strcmp(wtype, "zpx") == 0) {
-        /* Take those on the second (latitude) axis ignoring the other. */
-        /* First we have to count them and allocate space in wcsprm.    */
+        // Take those on the second (latitude) axis ignoring the other.
+        // First we have to count them and allocate space in wcsprm.
         wp  = wat[i];
         for (npv = 0; npv < 30; npv++) {
           if ((wp = strstr(wp, "projp")) == 0x0) break;
           wp += 5;
         }
 
-        /* Allocate space. */
+        // Allocate space.
         if (npv) {
           wcsp->npvmax += npv;
           wcsp->pv = realloc(wcsp->pv, wcsp->npvmax*sizeof(struct pvcard));
@@ -25785,7 +25782,7 @@ int wcspih_final(
           wcsp->m_pv = wcsp->pv;
         }
 
-        /* Copy the values. */
+        // Copy the values.
         wp = wat[i];
         for (ipv = wcsp->npv; ipv < wcsp->npvmax; ipv++) {
           if ((wp = strstr(wp, "projp")) == 0x0) break;
@@ -25801,7 +25798,7 @@ int wcspih_final(
         wcsp->npv += npv;
       }
 
-      /* Read the control parameters. */
+      // Read the control parameters.
       if ((wp = strchr(wat[i], '"')) == 0x0) {
         return WCSHDRERR_PARSER;
       }
@@ -25815,24 +25812,24 @@ int wcspih_final(
         wp++;
       }
 
-      /* How many coefficients are we expecting? */
+      // How many coefficients are we expecting?
       omin = (wctrl[1] < wctrl[2]) ? wctrl[1] : wctrl[2];
       omax = (wctrl[1] < wctrl[2]) ? wctrl[2] : wctrl[1];
       if (wctrl[3] == 0) {
-        /* No cross terms. */
+        // No cross terms.
         nterms += omin + omax;
 
       } else if (wctrl[3] == 1) {
-        /* Full cross terms. */
+        // Full cross terms.
         nterms += omin*omax;
 
       } else if (wctrl[3] == 2) {
-        /* Half cross terms. */
+        // Half cross terms.
         nterms += omin*omax - omin*(omin-1)/2;
       }
     }
 
-    /* Allocate memory for dpkeys. */
+    // Allocate memory for dpkeys.
     ndq[0] += 2*(1 + 1 + 4) + nterms;
 
     disp->ndpmax += ndq[0];
@@ -25844,12 +25841,12 @@ int wcspih_final(
     disp->m_dp = disp->dp;
 
 
-    /* Populate dpkeys. */
+    // Populate dpkeys.
     idp = disp->ndp;
     for (i = 0; i < 2; i++) {
       dpfill(disp->dp+(idp++), "DQ", "NAXES", i+1, 0, 2, 0.0);
 
-      /* Read the control parameters. */
+      // Read the control parameters.
       if ((wp = strchr(wat[i], '"')) == 0x0) {
         return WCSHDRERR_PARSER;
       }
@@ -25863,23 +25860,23 @@ int wcspih_final(
         wp++;
       }
 
-      /* Polynomial type. */
+      // Polynomial type.
       dpfill(disp->dp+(idp++), "DQ", "WAT.POLY", i+1, 0, wctrl[0], 0.0);
       if (wctrl[0] == 1) {
-        /* Chebyshev polynomial. */
+        // Chebyshev polynomial.
         strcpy(wpoly, "CHBY");
       } else if (wctrl[0] == 2) {
-        /* Legendre polynomial. */
+        // Legendre polynomial.
         strcpy(wpoly, "LEGR");
       } else if (wctrl[0] == 3) {
-        /* Polynomial is the sum of monomials. */
+        // Polynomial is the sum of monomials.
         strcpy(wpoly, "MONO");
       } else {
-        /* Unknown code. */
+        // Unknown code.
         strcpy(wpoly, "UNKN");
       }
 
-      /* Read the scaling parameters. */
+      // Read the scaling parameters.
       for (m = 0; m < 4; m++) {
         sscanf(wp, "%lf", &wval);
         sprintf(field, "WAT.%c%s", (m<2)?'X':'Y', (m%2)?"MAX":"MIN");
@@ -25891,7 +25888,7 @@ int wcspih_final(
         wp++;
       }
 
-      /* Read the coefficients. */
+      // Read the coefficients.
       for (n = 0; n < wctrl[2]; n++) {
         for (m = 0; m < wctrl[1]; m++) {
           if (wctrl[3] == 0) {
Index: astropy-4.2/cextern/wcslib/C/flexed/wcsulex.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/flexed/wcsulex.c
+++ astropy-4.2/cextern/wcslib/C/flexed/wcsulex.c
@@ -7150,9 +7150,8 @@ static const yy_state_type yy_NUL_trans[
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "wcsulex.l"
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -7169,11 +7168,9 @@ static const yy_state_type yy_NUL_trans[
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsulex.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsulex.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
 * wcsulex.l is a Flex description file containing the definition of a
@@ -7198,7 +7195,7 @@ static const yy_state_type yy_NUL_trans[
 /* All additional recognized units. */
 /* Exclusive start states. */
 
-#line 87 "wcsulex.l"
+#line 84 "wcsulex.l"
 #include <math.h>
 #include <setjmp.h>
 #include <stdio.h>
@@ -7213,7 +7210,7 @@ static int wcsulex_scanner(const char un
                            double units[WCSUNITS_NTYPE], struct wcserr **err,
                            yyscan_t yyscanner);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsulexe(
   const char unitstr[],
@@ -7235,21 +7232,21 @@ int wcsulexe(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define YY_DECL int wcsulex_scanner(const char unitstr[], int *func, \
  double *scale, double units[WCSUNITS_NTYPE], struct wcserr **err, \
  yyscan_t yyscanner)
 
-/* Dummy definition to circumvent compiler warnings. */
+// Dummy definition to circumvent compiler warnings.
 #define YY_INPUT(inbuff, count, bufsize) { count = YY_NULL; }
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
+// Used in preempting the call to exit() by yy_fatal_error().
 jmp_buf wcsulex_abort_jmp_env;
 #define exit(status) longjmp(wcsulex_abort_jmp_env, status)
 
-#line 7252 "wcsulex.c"
-#line 7253 "wcsulex.c"
+#line 7249 "wcsulex.c"
+#line 7250 "wcsulex.c"
 
 #define INITIAL 0
 #define PAREN 1
@@ -7501,9 +7498,9 @@ YY_DECL
 		}
 
 	{
-#line 138 "wcsulex.l"
+#line 135 "wcsulex.l"
 
-#line 140 "wcsulex.l"
+#line 137 "wcsulex.l"
 	static const char *function = "wcsulexe";
 	
 	char ctmp[72];
@@ -7528,14 +7525,14 @@ YY_DECL
 	factor = 1.0;
 	*scale = 1.0;
 	
-	/* Avert a flex-induced memory leak. */
+	// Avert a flex-induced memory leak.
 	if (YY_CURRENT_BUFFER && YY_CURRENT_BUFFER->yy_input_file == stdin) {
 	  yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
 	}
 	
 	yy_scan_string(unitstr, yyscanner);
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
+	// Return here via longjmp() invoked by yy_fatal_error().
 	if (setjmp(wcsulex_abort_jmp_env)) {
 	  return wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
@@ -7547,7 +7544,7 @@ YY_DECL
 	fprintf(stderr, "\n%s ->\n", unitstr);
 #endif
 
-#line 7551 "wcsulex.c"
+#line 7548 "wcsulex.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -7601,15 +7598,15 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 183 "wcsulex.l"
+#line 180 "wcsulex.l"
 {
-	  /* Pretend initial whitespace doesn't exist. */
+	  // Pretend initial whitespace doesn't exist.
 	  yy_set_bol(1);
 	}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 188 "wcsulex.l"
+#line 185 "wcsulex.l"
 {
 	  if (bracket++) {
 	    BEGIN(FLUSH);
@@ -7620,7 +7617,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 196 "wcsulex.l"
+#line 193 "wcsulex.l"
 {
 	  status = wcserr_set(WCSERR_SET(UNITSERR_BAD_NUM_MULTIPLIER),
 	    "Invalid exponent in '%s'", unitstr);
@@ -7629,7 +7626,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 202 "wcsulex.l"
+#line 199 "wcsulex.l"
 {
 	  factor = 10.0;
 	  BEGIN(EXPON);
@@ -7637,7 +7634,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 207 "wcsulex.l"
+#line 204 "wcsulex.l"
 {
 	  *func = 1;
 	  unput('(');
@@ -7646,7 +7643,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 213 "wcsulex.l"
+#line 210 "wcsulex.l"
 {
 	  *func = 2;
 	  unput('(');
@@ -7655,7 +7652,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 219 "wcsulex.l"
+#line 216 "wcsulex.l"
 {
 	  *func = 3;
 	  unput('(');
@@ -7664,9 +7661,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 225 "wcsulex.l"
+#line 222 "wcsulex.l"
 {
-	  /* Leading binary multiply. */
+	  // Leading binary multiply.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_DANGLING_BINOP),
 	    "Dangling binary operator in '%s'", unitstr);
 	  BEGIN(FLUSH);
@@ -7674,12 +7671,12 @@ YY_RULE_SETUP
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 232 "wcsulex.l"
-/* Discard whitespace in INITIAL context. */
+#line 229 "wcsulex.l"
+// Discard whitespace in INITIAL context.
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 234 "wcsulex.l"
+#line 231 "wcsulex.l"
 {
 	  expon /= 2.0;
 	  unput('(');
@@ -7688,16 +7685,16 @@ YY_RULE_SETUP
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 240 "wcsulex.l"
+#line 237 "wcsulex.l"
 {
-	  /* Gather terms in parentheses. */
+	  // Gather terms in parentheses.
 	  yyless(0);
 	  BEGIN(PAREN);
 	}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 246 "wcsulex.l"
+#line 243 "wcsulex.l"
 {
 	  if (operator++) {
 	    BEGIN(FLUSH);
@@ -7705,10 +7702,10 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 13:
-#line 253 "wcsulex.l"
+#line 250 "wcsulex.l"
 case 14:
 YY_RULE_SETUP
-#line 253 "wcsulex.l"
+#line 250 "wcsulex.l"
 {
 	  if (operator++) {
 	    BEGIN(FLUSH);
@@ -7719,7 +7716,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 261 "wcsulex.l"
+#line 258 "wcsulex.l"
 {
 	  operator = 0;
 	  yyless(0);
@@ -7727,12 +7724,12 @@ YY_RULE_SETUP
 	}
 	YY_BREAK
 case 16:
-#line 268 "wcsulex.l"
+#line 265 "wcsulex.l"
 case 17:
-#line 269 "wcsulex.l"
+#line 266 "wcsulex.l"
 case 18:
 YY_RULE_SETUP
-#line 269 "wcsulex.l"
+#line 266 "wcsulex.l"
 {
 	  operator = 0;
 	  yyless(0);
@@ -7741,7 +7738,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 275 "wcsulex.l"
+#line 272 "wcsulex.l"
 {
 	  bracket = !bracket;
 	  BEGIN(FLUSH);
@@ -7749,7 +7746,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 280 "wcsulex.l"
+#line 277 "wcsulex.l"
 {
 	  status = wcserr_set(WCSERR_SET(UNITSERR_BAD_INITIAL_SYMBOL),
 	    "Invalid symbol in INITIAL context in '%s'", unitstr);
@@ -7758,7 +7755,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 286 "wcsulex.l"
+#line 283 "wcsulex.l"
 {
 	  paren++;
 	  operator = 0;
@@ -7767,15 +7764,15 @@ YY_RULE_SETUP
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 292 "wcsulex.l"
+#line 289 "wcsulex.l"
 {
 	  paren--;
 	  if (paren) {
-	    /* Not balanced yet. */
+	    // Not balanced yet.
 	    yymore();
 	
 	  } else {
-	    /* Balanced; strip off the outer parentheses and recurse. */
+	    // Balanced; strip off the outer parentheses and recurse.
 	    yytext[yyleng-1] = '\0';
 	
 	    buf = YY_CURRENT_BUFFER;
@@ -7799,14 +7796,14 @@ YY_RULE_SETUP
 case 23:
 /* rule 23 can match eol */
 YY_RULE_SETUP
-#line 320 "wcsulex.l"
+#line 317 "wcsulex.l"
 {
 	  yymore();
 	}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 324 "wcsulex.l"
+#line 321 "wcsulex.l"
 {
 	  factor = 1e-1;
 	  BEGIN(UNITS);
@@ -7814,7 +7811,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 329 "wcsulex.l"
+#line 326 "wcsulex.l"
 {
 	  factor = 1e-2;
 	  BEGIN(UNITS);
@@ -7822,7 +7819,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 334 "wcsulex.l"
+#line 331 "wcsulex.l"
 {
 	  factor = 1e-3;
 	  BEGIN(UNITS);
@@ -7830,7 +7827,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 339 "wcsulex.l"
+#line 336 "wcsulex.l"
 {
 	  factor = 1e-6;
 	  BEGIN(UNITS);
@@ -7838,7 +7835,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 344 "wcsulex.l"
+#line 341 "wcsulex.l"
 {
 	  factor = 1e-9;
 	  BEGIN(UNITS);
@@ -7846,7 +7843,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 349 "wcsulex.l"
+#line 346 "wcsulex.l"
 {
 	  factor = 1e-12;
 	  BEGIN(UNITS);
@@ -7854,7 +7851,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 354 "wcsulex.l"
+#line 351 "wcsulex.l"
 {
 	  factor = 1e-15;
 	  BEGIN(UNITS);
@@ -7862,7 +7859,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 359 "wcsulex.l"
+#line 356 "wcsulex.l"
 {
 	  factor = 1e-18;
 	  BEGIN(UNITS);
@@ -7870,7 +7867,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 364 "wcsulex.l"
+#line 361 "wcsulex.l"
 {
 	  factor = 1e-21;
 	  BEGIN(UNITS);
@@ -7878,7 +7875,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 369 "wcsulex.l"
+#line 366 "wcsulex.l"
 {
 	  factor = 1e-24;
 	  BEGIN(UNITS);
@@ -7886,7 +7883,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 374 "wcsulex.l"
+#line 371 "wcsulex.l"
 {
 	  factor = 1e+1;
 	  BEGIN(UNITS);
@@ -7894,7 +7891,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 379 "wcsulex.l"
+#line 376 "wcsulex.l"
 {
 	  factor = 1e+2;
 	  BEGIN(UNITS);
@@ -7902,7 +7899,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 384 "wcsulex.l"
+#line 381 "wcsulex.l"
 {
 	  factor = 1e+3;
 	  BEGIN(UNITS);
@@ -7910,7 +7907,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 389 "wcsulex.l"
+#line 386 "wcsulex.l"
 {
 	  factor = 1e+6;
 	  BEGIN(UNITS);
@@ -7918,7 +7915,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 394 "wcsulex.l"
+#line 391 "wcsulex.l"
 {
 	  factor = 1e+9;
 	  BEGIN(UNITS);
@@ -7926,7 +7923,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 399 "wcsulex.l"
+#line 396 "wcsulex.l"
 {
 	  factor = 1e+12;
 	  BEGIN(UNITS);
@@ -7934,7 +7931,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 404 "wcsulex.l"
+#line 401 "wcsulex.l"
 {
 	  factor = 1e+15;
 	  BEGIN(UNITS);
@@ -7942,7 +7939,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 409 "wcsulex.l"
+#line 406 "wcsulex.l"
 {
 	  factor = 1e+18;
 	  BEGIN(UNITS);
@@ -7950,7 +7947,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 414 "wcsulex.l"
+#line 411 "wcsulex.l"
 {
 	  factor = 1e+21;
 	  BEGIN(UNITS);
@@ -7958,7 +7955,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 419 "wcsulex.l"
+#line 416 "wcsulex.l"
 {
 	  factor = 1e+24;
 	  BEGIN(UNITS);
@@ -7966,9 +7963,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 424 "wcsulex.l"
+#line 421 "wcsulex.l"
 {
-	  /* Internal parser error. */
+	  // Internal parser error.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
 	  BEGIN(FLUSH);
@@ -7976,9 +7973,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 431 "wcsulex.l"
+#line 428 "wcsulex.l"
 {
-	  /* Ampere. */
+	  // Ampere.
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  types[WCSUNITS_TIME]   -= 1.0;
 	  BEGIN(EXPON);
@@ -7986,9 +7983,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 438 "wcsulex.l"
+#line 435 "wcsulex.l"
 {
-	  /* Julian year (annum). */
+	  // Julian year (annum).
 	  factor *= 31557600.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
@@ -7996,18 +7993,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 445 "wcsulex.l"
+#line 442 "wcsulex.l"
 {
-	  /* Analogue-to-digital converter units. */
+	  // Analogue-to-digital converter units.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 451 "wcsulex.l"
+#line 448 "wcsulex.l"
 {
-	  /* Angstrom. */
+	  // Angstrom.
 	  factor *= 1e-10;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
@@ -8015,9 +8012,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 458 "wcsulex.l"
+#line 455 "wcsulex.l"
 {
-	  /* Minute of arc. */
+	  // Minute of arc.
 	  factor /= 60.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8025,9 +8022,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 465 "wcsulex.l"
+#line 462 "wcsulex.l"
 {
-	  /* Second of arc. */
+	  // Second of arc.
 	  factor /= 3600.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8035,9 +8032,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 472 "wcsulex.l"
+#line 469 "wcsulex.l"
 {
-	  /* Astronomical unit. */
+	  // Astronomical unit.
 	  factor *= 1.49598e+11;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
@@ -8045,9 +8042,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 479 "wcsulex.l"
+#line 476 "wcsulex.l"
 {
-	  /* Barn. */
+	  // Barn.
 	  factor *= 1e-28;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  BEGIN(EXPON);
@@ -8055,36 +8052,36 @@ YY_RULE_SETUP
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 486 "wcsulex.l"
+#line 483 "wcsulex.l"
 {
-	  /* Beam, as in Jy/beam. */
+	  // Beam, as in Jy/beam.
 	  types[WCSUNITS_BEAM] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 492 "wcsulex.l"
+#line 489 "wcsulex.l"
 {
-	  /* Bin (e.g. histogram). */
+	  // Bin (e.g. histogram).
 	  types[WCSUNITS_BIN] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 498 "wcsulex.l"
+#line 495 "wcsulex.l"
 {
-	  /* Bit. */
+	  // Bit.
 	  types[WCSUNITS_BIT] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 504 "wcsulex.l"
+#line 501 "wcsulex.l"
 {
-	  /* Byte. */
+	  // Byte.
 	  factor *= 8.0;
 	  types[WCSUNITS_BIT] += 1.0;
 	  BEGIN(EXPON);
@@ -8092,45 +8089,45 @@ YY_RULE_SETUP
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 511 "wcsulex.l"
+#line 508 "wcsulex.l"
 {
-	  /* Coulomb. */
+	  // Coulomb.
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 517 "wcsulex.l"
+#line 514 "wcsulex.l"
 {
-	  /* Candela. */
+	  // Candela.
 	  types[WCSUNITS_LUMINTEN] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 523 "wcsulex.l"
+#line 520 "wcsulex.l"
 {
-	  /* Channel. */
+	  // Channel.
 	  types[WCSUNITS_BIN] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 529 "wcsulex.l"
+#line 526 "wcsulex.l"
 {
-	  /* Count. */
+	  // Count.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 535 "wcsulex.l"
+#line 532 "wcsulex.l"
 {
-	  /* Julian century. */
+	  // Julian century.
 	  factor *= 3155760000.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
@@ -8138,9 +8135,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 542 "wcsulex.l"
+#line 539 "wcsulex.l"
 {
-	  /* Debye. */
+	  // Debye.
 	  factor *= 1e-29 / 3.0;
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
@@ -8149,9 +8146,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 550 "wcsulex.l"
+#line 547 "wcsulex.l"
 {
-	  /* Day. */
+	  // Day.
 	  factor *= 86400.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
@@ -8159,18 +8156,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 557 "wcsulex.l"
+#line 554 "wcsulex.l"
 {
-	  /* Degree. */
+	  // Degree.
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 563 "wcsulex.l"
+#line 560 "wcsulex.l"
 {
-	  /* Erg. */
+	  // Erg.
 	  factor *= 1e-7;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -8180,9 +8177,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 572 "wcsulex.l"
+#line 569 "wcsulex.l"
 {
-	  /* Electron volt. */
+	  // Electron volt.
 	  factor *= 1.6021765e-19;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -8192,9 +8189,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 581 "wcsulex.l"
+#line 578 "wcsulex.l"
 {
-	  /* Farad. */
+	  // Farad.
 	  types[WCSUNITS_MASS]   -= 1.0;
 	  types[WCSUNITS_LENGTH] -= 2.0;
 	  types[WCSUNITS_TIME]   += 3.0;
@@ -8204,9 +8201,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 590 "wcsulex.l"
+#line 587 "wcsulex.l"
 {
-	  /* Gauss. */
+	  // Gauss.
 	  factor *= 1e-4;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -8216,9 +8213,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 599 "wcsulex.l"
+#line 596 "wcsulex.l"
 {
-	  /* Gram. */
+	  // Gram.
 	  factor *= 1e-3;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
@@ -8226,9 +8223,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 606 "wcsulex.l"
+#line 603 "wcsulex.l"
 {
-	  /* Henry. */
+	  // Henry.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   += 2.0;
@@ -8238,9 +8235,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 615 "wcsulex.l"
+#line 612 "wcsulex.l"
 {
-	  /* Hour. */
+	  // Hour.
 	  factor *= 3600.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
@@ -8248,18 +8245,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 622 "wcsulex.l"
+#line 619 "wcsulex.l"
 {
-	  /* Hertz. */
+	  // Hertz.
 	  types[WCSUNITS_TIME] -= 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 628 "wcsulex.l"
+#line 625 "wcsulex.l"
 {
-	  /* Joule. */
+	  // Joule.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -8268,9 +8265,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 636 "wcsulex.l"
+#line 633 "wcsulex.l"
 {
-	  /* Jansky. */
+	  // Jansky.
 	  factor *= 1e-26;
 	  types[WCSUNITS_MASS] += 1.0;
 	  types[WCSUNITS_TIME] -= 2.0;
@@ -8279,18 +8276,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 644 "wcsulex.l"
+#line 641 "wcsulex.l"
 {
-	  /* Kelvin. */
+	  // Kelvin.
 	  types[WCSUNITS_TEMPERATURE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 650 "wcsulex.l"
+#line 647 "wcsulex.l"
 {
-	  /* Lumen. */
+	  // Lumen.
 	  types[WCSUNITS_LUMINTEN]    += 1.0;
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8298,9 +8295,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 657 "wcsulex.l"
+#line 654 "wcsulex.l"
 {
-	  /* Lux. */
+	  // Lux.
 	  types[WCSUNITS_LUMINTEN]    += 1.0;
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  types[WCSUNITS_LENGTH]      -= 2.0;
@@ -8309,9 +8306,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 665 "wcsulex.l"
+#line 662 "wcsulex.l"
 {
-	  /* Light year. */
+	  // Light year.
 	  factor *= 2.99792458e8 * 31557600.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
@@ -8319,27 +8316,27 @@ YY_RULE_SETUP
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 672 "wcsulex.l"
+#line 669 "wcsulex.l"
 {
-	  /* Metre. */
+	  // Metre.
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 678 "wcsulex.l"
+#line 675 "wcsulex.l"
 {
-	  /* Stellar magnitude. */
+	  // Stellar magnitude.
 	  types[WCSUNITS_MAGNITUDE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 684 "wcsulex.l"
+#line 681 "wcsulex.l"
 {
-	  /* Milli-arcsec. */
+	  // Milli-arcsec.
 	  factor /= 3600e+3;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8347,9 +8344,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 691 "wcsulex.l"
+#line 688 "wcsulex.l"
 {
-	  /* Minute. */
+	  // Minute.
 	  factor *= 60.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
@@ -8357,18 +8354,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 698 "wcsulex.l"
+#line 695 "wcsulex.l"
 {
-	  /* Mole. */
+	  // Mole.
 	  types[WCSUNITS_MOLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 704 "wcsulex.l"
+#line 701 "wcsulex.l"
 {
-	  /* Newton. */
+	  // Newton.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -8377,9 +8374,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 712 "wcsulex.l"
+#line 709 "wcsulex.l"
 {
-	  /* Ohm. */
+	  // Ohm.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 1.0;
@@ -8389,9 +8386,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
-#line 721 "wcsulex.l"
+#line 718 "wcsulex.l"
 {
-	  /* Pascal. */
+	  // Pascal.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] -= 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -8400,9 +8397,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
-#line 729 "wcsulex.l"
+#line 726 "wcsulex.l"
 {
-	  /* Parsec. */
+	  // Parsec.
 	  factor *= 3.0857e16;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
@@ -8410,27 +8407,27 @@ YY_RULE_SETUP
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 736 "wcsulex.l"
+#line 733 "wcsulex.l"
 {
-	  /* Photon. */
+	  // Photon.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 742 "wcsulex.l"
+#line 739 "wcsulex.l"
 {
-	  /* Pixel. */
+	  // Pixel.
 	  types[WCSUNITS_PIXEL] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 748 "wcsulex.l"
+#line 745 "wcsulex.l"
 {
-	  /* Rayleigh. */
+	  // Rayleigh.
 	  factor *= 1e10 / (4.0 * PI);
 	  types[WCSUNITS_LENGTH]      -= 2.0;
 	  types[WCSUNITS_TIME]        -= 1.0;
@@ -8440,9 +8437,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
-#line 757 "wcsulex.l"
+#line 754 "wcsulex.l"
 {
-	  /* Radian. */
+	  // Radian.
 	  factor *= 180.0 / PI;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8450,9 +8447,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-#line 764 "wcsulex.l"
+#line 761 "wcsulex.l"
 {
-	  /* Rydberg. */
+	  // Rydberg.
 	  factor *= 13.605692 * 1.6021765e-19;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -8462,9 +8459,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 773 "wcsulex.l"
+#line 770 "wcsulex.l"
 {
-	  /* Siemen. */
+	  // Siemen.
 	  types[WCSUNITS_MASS]   -= 1.0;
 	  types[WCSUNITS_LENGTH] -= 2.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -8474,18 +8471,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-#line 782 "wcsulex.l"
+#line 779 "wcsulex.l"
 {
-	  /* Second. */
+	  // Second.
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
-#line 788 "wcsulex.l"
+#line 785 "wcsulex.l"
 {
-	  /* Solar luminosity. */
+	  // Solar luminosity.
 	  factor *= 3.8268e26;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -8495,9 +8492,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 797 "wcsulex.l"
+#line 794 "wcsulex.l"
 {
-	  /* Solar mass. */
+	  // Solar mass.
 	  factor *= 1.9891e30;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
@@ -8505,9 +8502,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 804 "wcsulex.l"
+#line 801 "wcsulex.l"
 {
-	  /* Solar radius. */
+	  // Solar radius.
 	  factor *= 6.9599e8;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
@@ -8515,27 +8512,27 @@ YY_RULE_SETUP
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-#line 811 "wcsulex.l"
+#line 808 "wcsulex.l"
 {
-	  /* Steradian. */
+	  // Steradian.
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-#line 817 "wcsulex.l"
+#line 814 "wcsulex.l"
 {
-	  /* Sun (with respect to). */
+	  // Sun (with respect to).
 	  types[WCSUNITS_SOLRATIO] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-#line 823 "wcsulex.l"
+#line 820 "wcsulex.l"
 {
-	  /* Tesla. */
+	  // Tesla.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_TIME]   += 1.0;
 	  types[WCSUNITS_CHARGE] -= 1.0;
@@ -8544,9 +8541,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-#line 831 "wcsulex.l"
+#line 828 "wcsulex.l"
 {
-	  /* Turn. */
+	  // Turn.
 	  factor *= 360.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
@@ -8554,9 +8551,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 838 "wcsulex.l"
+#line 835 "wcsulex.l"
 {
-	  /* Unified atomic mass unit. */
+	  // Unified atomic mass unit.
 	  factor *= 1.6605387e-27;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
@@ -8564,9 +8561,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 845 "wcsulex.l"
+#line 842 "wcsulex.l"
 {
-	  /* Volt. */
+	  // Volt.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -8576,18 +8573,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
-#line 854 "wcsulex.l"
+#line 851 "wcsulex.l"
 {
-	  /* Voxel. */
+	  // Voxel.
 	  types[WCSUNITS_VOXEL] += 1.0;
 	  BEGIN(EXPON);
 	}
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-#line 860 "wcsulex.l"
+#line 857 "wcsulex.l"
 {
-	  /* Watt. */
+	  // Watt.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 3.0;
@@ -8596,9 +8593,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-#line 868 "wcsulex.l"
+#line 865 "wcsulex.l"
 {
-	  /* Weber. */
+	  // Weber.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -8608,9 +8605,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-#line 877 "wcsulex.l"
+#line 874 "wcsulex.l"
 {
-	  /* Internal parser error. */
+	  // Internal parser error.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
 	  BEGIN(FLUSH);
@@ -8618,9 +8615,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-#line 884 "wcsulex.l"
+#line 881 "wcsulex.l"
 {
-	  /* Exponentiation. */
+	  // Exponentiation.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  }
@@ -8628,7 +8625,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
-#line 891 "wcsulex.l"
+#line 888 "wcsulex.l"
 {
 	  sscanf(yytext, " %d", &i);
 	  expon *= (double)i;
@@ -8639,7 +8636,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-#line 899 "wcsulex.l"
+#line 896 "wcsulex.l"
 {
 	  sscanf(yytext, " (%d)", &i);
 	  expon *= (double)i;
@@ -8650,7 +8647,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
-#line 907 "wcsulex.l"
+#line 904 "wcsulex.l"
 {
 	  sscanf(yytext, " (%d/%d)", &i, &j);
 	  expon *= (double)i / (double)j;
@@ -8661,7 +8658,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-#line 915 "wcsulex.l"
+#line 912 "wcsulex.l"
 {
 	  sscanf(yytext, " (%s)", ctmp);
 	  wcsutil_str2double(ctmp, &dexp);
@@ -8673,9 +8670,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-#line 924 "wcsulex.l"
+#line 921 "wcsulex.l"
 {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -8686,9 +8683,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 114:
 YY_RULE_SETUP
-#line 934 "wcsulex.l"
+#line 931 "wcsulex.l"
 {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -8700,9 +8697,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
-#line 945 "wcsulex.l"
+#line 942 "wcsulex.l"
 {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -8713,9 +8710,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-#line 955 "wcsulex.l"
+#line 952 "wcsulex.l"
 {
-	  /* Divide. */
+	  // Divide.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -8727,7 +8724,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-#line 966 "wcsulex.l"
+#line 963 "wcsulex.l"
 {
 	  add(&factor, types, &expon, scale, units);
 	  bracket = !bracket;
@@ -8736,7 +8733,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 972 "wcsulex.l"
+#line 969 "wcsulex.l"
 {
 	  status = wcserr_set(WCSERR_SET(UNITSERR_BAD_EXPON_SYMBOL),
 	    "Invalid symbol in EXPON context in '%s'", unitstr);
@@ -8745,9 +8742,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 978 "wcsulex.l"
+#line 975 "wcsulex.l"
 {
-	  /* Discard any remaining input. */
+	  // Discard any remaining input.
 	}
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
@@ -8756,9 +8753,9 @@ case YY_STATE_EOF(PREFIX):
 case YY_STATE_EOF(UNITS):
 case YY_STATE_EOF(EXPON):
 case YY_STATE_EOF(FLUSH):
-#line 982 "wcsulex.l"
+#line 979 "wcsulex.l"
 {
-	  /* End-of-string. */
+	  // End-of-string.
 	  if (YY_START == EXPON) {
 	    add(&factor, types, &expon, scale, units);
 	  }
@@ -8793,10 +8790,10 @@ case YY_STATE_EOF(FLUSH):
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-#line 1016 "wcsulex.l"
+#line 1013 "wcsulex.l"
 ECHO;
 	YY_BREAK
-#line 8800 "wcsulex.c"
+#line 8797 "wcsulex.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -9961,7 +9958,7 @@ void yyfree (void * ptr , yyscan_t yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 1016 "wcsulex.l"
+#line 1013 "wcsulex.l"
 
 
 /*----------------------------------------------------------------------------
Index: astropy-4.2/cextern/wcslib/C/flexed/wcsutrn.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/flexed/wcsutrn.c
+++ astropy-4.2/cextern/wcslib/C/flexed/wcsutrn.c
@@ -724,7 +724,7 @@ static const flex_int16_t yy_nxt[][128]
        43,  -10,  -10,  -10,  -10,  -10,  -10,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       45,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -10,  -10,  -10,  -10,  -10
     },
 
@@ -735,14 +735,14 @@ static const flex_int16_t yy_nxt[][128]
       -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
       -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
       -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
-      -11,  -11,  -11,  -11,  -11,   43,   43,   43,   43,   45,
+      -11,  -11,  -11,  -11,  -11,   43,   43,   43,   43,   46,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -11,  -11,  -11,  -11,  -11,  -11,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   46,   43,  -11,  -11,  -11,  -11,  -11
+       43,   47,   43,  -11,  -11,  -11,  -11,  -11
     },
 
     {
@@ -770,11 +770,11 @@ static const flex_int16_t yy_nxt[][128]
       -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
       -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
       -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
-      -13,  -13,  -13,  -13,  -13,   47,   43,   43,   43,   48,
+      -13,  -13,  -13,  -13,  -13,   48,   43,   43,   43,   49,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -13,  -13,  -13,  -13,  -13,  -13,   43,   43,   43,
-       43,   49,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   50,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -13,  -13,  -13,  -13,  -13
@@ -788,7 +788,7 @@ static const flex_int16_t yy_nxt[][128]
       -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
       -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
       -14,  -14,  -14,  -14,  -14,   43,   43,   43,   43,   43,
-       43,   43,   50,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   51,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -14,  -14,  -14,  -14,  -14,  -14,   43,   43,   43,
@@ -807,8 +807,8 @@ static const flex_int16_t yy_nxt[][128]
       -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
       -15,  -15,  -15,  -15,  -15,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   51,   43,   43,   43,   43,   43,   43,   43,
-       52,  -15,  -15,  -15,  -15,  -15,  -15,   43,   43,   43,
+       43,   43,   52,   43,   43,   43,   43,   43,   43,   43,
+       53,  -15,  -15,  -15,  -15,  -15,  -15,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -15,  -15,  -15,  -15,  -15
@@ -824,7 +824,7 @@ static const flex_int16_t yy_nxt[][128]
       -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
       -16,  -16,  -16,  -16,  -16,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   53,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   54,
        43,  -16,  -16,  -16,  -16,  -16,  -16,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -839,12 +839,12 @@ static const flex_int16_t yy_nxt[][128]
       -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
       -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
       -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
-      -17,  -17,  -17,  -17,  -17,   43,   43,   43,   43,   54,
-       43,   43,   55,   43,   43,   43,   43,   56,   43,   43,
+      -17,  -17,  -17,  -17,  -17,   43,   43,   43,   43,   55,
+       43,   43,   56,   43,   43,   43,   43,   57,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -17,  -17,  -17,  -17,  -17,  -17,   43,   43,   43,
-       43,   57,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   58,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -17,  -17,  -17,  -17,  -17
     },
@@ -857,8 +857,8 @@ static const flex_int16_t yy_nxt[][128]
       -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
       -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
 
-      -18,  -18,  -18,  -18,  -18,   43,   43,   43,   43,   58,
-       43,   43,   59,   60,   43,   43,   43,   43,   43,   43,
+      -18,  -18,  -18,  -18,  -18,   43,   43,   43,   43,   59,
+       43,   43,   60,   61,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -18,  -18,  -18,  -18,  -18,  -18,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -878,7 +878,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -19,  -19,  -19,  -19,  -19,  -19,   43,   43,   43,
-       43,   43,   43,   43,   61,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   62,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -19,  -19,  -19,  -19,  -19
 
@@ -891,10 +891,10 @@ static const flex_int16_t yy_nxt[][128]
       -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
       -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
       -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
-      -20,  -20,  -20,  -20,  -20,   62,   43,   43,   43,   43,
-       43,   43,   43,   63,   43,   43,   43,   43,   43,   43,
+      -20,  -20,  -20,  -20,  -20,   63,   43,   43,   43,   43,
+       43,   43,   43,   64,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -20,  -20,  -20,  -20,  -20,  -20,   64,   43,   43,
+       43,  -20,  -20,  -20,  -20,  -20,  -20,   65,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -908,7 +908,7 @@ static const flex_int16_t yy_nxt[][128]
       -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
       -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
       -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
-      -21,  -21,  -21,  -21,  -21,   65,   43,   43,   43,   43,
+      -21,  -21,  -21,  -21,  -21,   66,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -926,7 +926,7 @@ static const flex_int16_t yy_nxt[][128]
 
       -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
       -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
-      -22,  -22,  -22,  -22,  -22,   43,   43,   43,   43,   66,
+      -22,  -22,  -22,  -22,  -22,   43,   43,   43,   43,   67,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -22,  -22,  -22,  -22,  -22,  -22,   43,   43,   43,
@@ -944,12 +944,12 @@ static const flex_int16_t yy_nxt[][128]
       -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
       -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
       -23,  -23,  -23,  -23,  -23,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   67,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   68,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -23,  -23,  -23,  -23,  -23,  -23,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   68,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   69,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -23,  -23,  -23,  -23,  -23
     },
 
@@ -960,10 +960,10 @@ static const flex_int16_t yy_nxt[][128]
       -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
       -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
       -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
-      -24,  -24,  -24,  -24,  -24,   43,   43,   43,   43,   69,
+      -24,  -24,  -24,  -24,  -24,   43,   43,   43,   43,   70,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   70,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   71,   43,   43,   43,   43,   43,   43,   43,
        43,  -24,  -24,  -24,  -24,  -24,  -24,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -983,7 +983,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -25,  -25,  -25,  -25,  -25,  -25,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       71,   43,   43,   43,   72,   43,   43,   43,   43,   43,
+       72,   43,   43,   43,   73,   43,   43,   43,   43,   43,
        43,   43,   43,  -25,  -25,  -25,  -25,  -25
     },
 
@@ -998,8 +998,8 @@ static const flex_int16_t yy_nxt[][128]
       -26,  -26,  -26,  -26,  -26,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -26,  -26,  -26,  -26,  -26,  -26,   73,   43,   43,
-       43,   74,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -26,  -26,  -26,  -26,  -26,  -26,   74,   43,   43,
+       43,   75,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,  -26,  -26,  -26,  -26,  -26
@@ -1018,8 +1018,8 @@ static const flex_int16_t yy_nxt[][128]
 
        43,  -27,  -27,  -27,  -27,  -27,  -27,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   51,   43,   43,   43,   43,   43,
-       43,   43,   52,  -27,  -27,  -27,  -27,  -27
+       43,   43,   43,   43,   52,   43,   43,   43,   43,   43,
+       43,   43,   53,  -27,  -27,  -27,  -27,  -27
     },
 
     {
@@ -1034,7 +1034,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -28,  -28,  -28,  -28,  -28,  -28,   43,   43,   43,
-       43,   57,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   58,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -28,  -28,  -28,  -28,  -28
     },
@@ -1051,7 +1051,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -29,  -29,  -29,  -29,  -29,  -29,   43,   43,   43,
-       43,   75,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   76,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -29,  -29,  -29,  -29,  -29
 
@@ -1067,9 +1067,9 @@ static const flex_int16_t yy_nxt[][128]
       -30,  -30,  -30,  -30,  -30,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -30,  -30,  -30,  -30,  -30,  -30,   64,   43,   43,
+       43,  -30,  -30,  -30,  -30,  -30,  -30,   65,   43,   43,
 
-       43,   43,   43,   43,   43,   76,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   77,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -30,  -30,  -30,  -30,  -30
     },
@@ -1085,7 +1085,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -31,  -31,  -31,  -31,  -31,  -31,   77,   43,   43,
+       43,  -31,  -31,  -31,  -31,  -31,  -31,   78,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -31,  -31,  -31,  -31,  -31
@@ -1103,7 +1103,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -32,  -32,  -32,  -32,  -32,  -32,   43,   43,   43,
-       43,   78,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   79,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -32,  -32,  -32,  -32,  -32
     },
@@ -1122,7 +1122,7 @@ static const flex_int16_t yy_nxt[][128]
        43,  -33,  -33,  -33,  -33,  -33,  -33,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   68,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   69,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -33,  -33,  -33,  -33,  -33
     },
 
@@ -1138,7 +1138,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -34,  -34,  -34,  -34,  -34,  -34,   43,   43,   43,
-       43,   79,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   80,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -34,  -34,  -34,  -34,  -34
     },
@@ -1147,14 +1147,14 @@ static const flex_int16_t yy_nxt[][128]
         7,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
-      -35,  -35,   80,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,   81,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
 
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
-      -35,   81,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   82,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35
@@ -1213,20 +1213,20 @@ static const flex_int16_t yy_nxt[][128]
     },
 
     {
-        7,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-
-       82,   82,   83,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   82,   82,   82,   82,   82,   82,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   82,   82,   82,   82,   82
+        7,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+
+       83,   83,   84,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   83,   83,   83,   83,   83,   83,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   83,   83,   83,   83,   83
 
     },
 
@@ -1237,31 +1237,31 @@ static const flex_int16_t yy_nxt[][128]
       -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
       -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
       -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
-      -40,  -40,  -40,  -40,  -40,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,  -40,  -40,  -40,  -40,  -40,  -40,   85,   85,   85,
-
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,  -40,  -40,  -40,  -40,  -40
-    },
-
-    {
-        7,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-      -41,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+      -40,  -40,  -40,  -40,  -40,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,  -40,  -40,  -40,  -40,  -40,  -40,   86,   86,   86,
 
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86
+       86,   86,   86,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+        7,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+      -41,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87
     },
 
     {
@@ -1306,7 +1306,7 @@ static const flex_int16_t yy_nxt[][128]
       -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
       -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
       -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
-      -44,  -44,  -44,  -44,  -44,   43,   43,   87,   43,   43,
+      -44,  -44,  -44,  -44,  -44,   43,   43,   88,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -1324,11 +1324,11 @@ static const flex_int16_t yy_nxt[][128]
       -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
 
       -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
-      -45,  -45,  -45,  -45,  -45,   88,   43,   43,   43,   43,
+      -45,  -45,  -45,  -45,  -45,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -45,  -45,  -45,  -45,  -45,  -45,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   89,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -45,  -45,  -45,  -45,  -45
     },
@@ -1341,12 +1341,12 @@ static const flex_int16_t yy_nxt[][128]
       -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
       -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
       -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
-      -46,  -46,  -46,  -46,  -46,   43,   43,   43,   43,   43,
+      -46,  -46,  -46,  -46,  -46,   90,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -46,  -46,  -46,  -46,  -46,  -46,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   89,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,  -46,  -46,  -46,  -46,  -46
     },
@@ -1360,11 +1360,11 @@ static const flex_int16_t yy_nxt[][128]
       -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
       -47,  -47,  -47,  -47,  -47,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   90,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -47,  -47,  -47,  -47,  -47,  -47,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   91,   43,   43,   43,
        43,   43,   43,  -47,  -47,  -47,  -47,  -47
     },
 
@@ -1377,8 +1377,8 @@ static const flex_int16_t yy_nxt[][128]
       -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
 
       -48,  -48,  -48,  -48,  -48,   43,   43,   43,   43,   43,
-       43,   91,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   92,
        43,  -48,  -48,  -48,  -48,  -48,  -48,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -1394,10 +1394,10 @@ static const flex_int16_t yy_nxt[][128]
       -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
       -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
       -49,  -49,  -49,  -49,  -49,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   93,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -49,  -49,  -49,  -49,  -49,  -49,   43,   43,   43,
-       43,   43,   43,   92,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -49,  -49,  -49,  -49,  -49
 
@@ -1413,9 +1413,9 @@ static const flex_int16_t yy_nxt[][128]
       -50,  -50,  -50,  -50,  -50,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       93,  -50,  -50,  -50,  -50,  -50,  -50,   43,   43,   43,
+       43,  -50,  -50,  -50,  -50,  -50,  -50,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   94,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -50,  -50,  -50,  -50,  -50
     },
@@ -1431,7 +1431,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -51,  -51,  -51,  -51,  -51,  -51,   43,   43,   43,
+       95,  -51,  -51,  -51,  -51,  -51,  -51,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -51,  -51,  -51,  -51,  -51
@@ -1480,7 +1480,7 @@ static const flex_int16_t yy_nxt[][128]
       -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
       -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
       -54,  -54,  -54,  -54,  -54,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   94,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -54,  -54,  -54,  -54,  -54,  -54,   43,   43,   43,
@@ -1498,9 +1498,9 @@ static const flex_int16_t yy_nxt[][128]
 
       -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
       -55,  -55,  -55,  -55,  -55,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   96,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       95,  -55,  -55,  -55,  -55,  -55,  -55,   43,   43,   43,
+       43,  -55,  -55,  -55,  -55,  -55,  -55,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -55,  -55,  -55,  -55,  -55
@@ -1517,7 +1517,7 @@ static const flex_int16_t yy_nxt[][128]
       -56,  -56,  -56,  -56,  -56,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -56,  -56,  -56,  -56,  -56,  -56,   43,   43,   43,
+       97,  -56,  -56,  -56,  -56,  -56,  -56,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
@@ -1536,7 +1536,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -57,  -57,  -57,  -57,  -57,  -57,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   96,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -57,  -57,  -57,  -57,  -57
     },
@@ -1551,9 +1551,9 @@ static const flex_int16_t yy_nxt[][128]
 
       -58,  -58,  -58,  -58,  -58,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   97,   43,   43,   43,   43,   43,
-       43,  -58,  -58,  -58,  -58,  -58,  -58,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -58,  -58,  -58,  -58,  -58,  -58,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   98,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -58,  -58,  -58,  -58,  -58
     },
@@ -1568,8 +1568,8 @@ static const flex_int16_t yy_nxt[][128]
       -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
       -59,  -59,  -59,  -59,  -59,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       98,  -59,  -59,  -59,  -59,  -59,  -59,   43,   43,   43,
+       43,   43,   43,   43,   99,   43,   43,   43,   43,   43,
+       43,  -59,  -59,  -59,  -59,  -59,  -59,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -59,  -59,  -59,  -59,  -59
@@ -1584,9 +1584,9 @@ static const flex_int16_t yy_nxt[][128]
       -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
       -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
       -60,  -60,  -60,  -60,  -60,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   99,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -60,  -60,  -60,  -60,  -60,  -60,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      100,  -60,  -60,  -60,  -60,  -60,  -60,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -1602,10 +1602,10 @@ static const flex_int16_t yy_nxt[][128]
       -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
       -61,  -61,  -61,  -61,  -61,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  101,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -61,  -61,  -61,  -61,  -61,  -61,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,  100,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -61,  -61,  -61,  -61,  -61
     },
@@ -1620,9 +1620,9 @@ static const flex_int16_t yy_nxt[][128]
       -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
       -62,  -62,  -62,  -62,  -62,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  101,   43,   43,   43,   43,   43,   43,
-       43,  -62,  -62,  -62,  -62,  -62,  -62,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -62,  -62,  -62,  -62,  -62,  -62,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,  102,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -62,  -62,  -62,  -62,  -62
     },
@@ -1637,7 +1637,7 @@ static const flex_int16_t yy_nxt[][128]
       -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,
       -63,  -63,  -63,  -63,  -63,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  102,   43,
+       43,   43,   43,  103,   43,   43,   43,   43,   43,   43,
        43,  -63,  -63,  -63,  -63,  -63,  -63,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
@@ -1655,10 +1655,10 @@ static const flex_int16_t yy_nxt[][128]
       -64,  -64,  -64,  -64,  -64,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  104,   43,
        43,  -64,  -64,  -64,  -64,  -64,  -64,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  103,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -64,  -64,  -64,  -64,  -64
     },
 
@@ -1670,12 +1670,12 @@ static const flex_int16_t yy_nxt[][128]
       -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,
 
       -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,
-      -65,  -65,  -65,  -65,  -65,   43,   43,   43,  104,   43,
+      -65,  -65,  -65,  -65,  -65,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -65,  -65,  -65,  -65,  -65,  -65,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  105,   43,   43,   43,   43,
        43,   43,   43,  -65,  -65,  -65,  -65,  -65
     },
 
@@ -1687,7 +1687,7 @@ static const flex_int16_t yy_nxt[][128]
       -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
       -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
       -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
-      -66,  -66,  -66,  -66,  -66,   43,   43,  105,   43,   43,
+      -66,  -66,  -66,  -66,  -66,   43,   43,   43,  106,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -66,  -66,  -66,  -66,  -66,  -66,   43,   43,   43,
@@ -1704,8 +1704,8 @@ static const flex_int16_t yy_nxt[][128]
       -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
       -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
       -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
-      -67,  -67,  -67,  -67,  -67,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  106,   43,   43,   43,
+      -67,  -67,  -67,  -67,  -67,   43,   43,  107,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -67,  -67,  -67,  -67,  -67,  -67,   43,   43,   43,
@@ -1723,10 +1723,10 @@ static const flex_int16_t yy_nxt[][128]
       -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,
 
       -68,  -68,  -68,  -68,  -68,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  108,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -68,  -68,  -68,  -68,  -68,  -68,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  107,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -68,  -68,  -68,  -68,  -68
     },
@@ -1739,11 +1739,11 @@ static const flex_int16_t yy_nxt[][128]
       -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
       -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
       -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
-      -69,  -69,  -69,  -69,  -69,  108,   43,   43,   43,   43,
+      -69,  -69,  -69,  -69,  -69,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -69,  -69,  -69,  -69,  -69,  -69,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  109,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -69,  -69,  -69,  -69,  -69
 
@@ -1756,7 +1756,7 @@ static const flex_int16_t yy_nxt[][128]
       -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,
       -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,
       -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,
-      -70,  -70,  -70,  -70,  -70,   43,   43,   43,   43,   43,
+      -70,  -70,  -70,  -70,  -70,  110,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -70,  -70,  -70,  -70,  -70,  -70,   43,   43,   43,
@@ -1778,7 +1778,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -71,  -71,  -71,  -71,  -71,  -71,   43,   43,   43,
-       43,   43,   43,  109,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -71,  -71,  -71,  -71,  -71
     },
@@ -1794,8 +1794,8 @@ static const flex_int16_t yy_nxt[][128]
       -72,  -72,  -72,  -72,  -72,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -72,  -72,  -72,  -72,  -72,  -72,   43,   43,  110,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -72,  -72,  -72,  -72,  -72,  -72,   43,   43,   43,
+       43,   43,   43,  111,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -72,  -72,  -72,  -72,  -72
     },
@@ -1811,11 +1811,11 @@ static const flex_int16_t yy_nxt[][128]
       -73,  -73,  -73,  -73,  -73,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -73,  -73,  -73,  -73,  -73,  -73,   43,   43,   43,
+       43,  -73,  -73,  -73,  -73,  -73,  -73,   43,   43,  112,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  111,   43,  -73,  -73,  -73,  -73,  -73
+       43,   43,   43,  -73,  -73,  -73,  -73,  -73
     },
 
     {
@@ -1830,9 +1830,9 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -74,  -74,  -74,  -74,  -74,  -74,   43,   43,   43,
-       43,   43,   43,  112,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  -74,  -74,  -74,  -74,  -74
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  113,   43,  -74,  -74,  -74,  -74,  -74
     },
 
     {
@@ -1847,8 +1847,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -75,  -75,  -75,  -75,  -75,  -75,   43,   43,   43,
+       43,   43,   43,  114,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  113,   43,   43,   43,
        43,   43,   43,  -75,  -75,  -75,  -75,  -75
     },
 
@@ -1865,9 +1865,9 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -76,  -76,  -76,  -76,  -76,  -76,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  115,   43,   43,   43,
 
-      114,   43,   43,  -76,  -76,  -76,  -76,  -76
+       43,   43,   43,  -76,  -76,  -76,  -76,  -76
     },
 
     {
@@ -1882,9 +1882,9 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -77,  -77,  -77,  -77,  -77,  -77,   43,   43,   43,
-      115,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  -77,  -77,  -77,  -77,  -77
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      116,   43,   43,  -77,  -77,  -77,  -77,  -77
     },
 
     {
@@ -1898,8 +1898,8 @@ static const flex_int16_t yy_nxt[][128]
       -78,  -78,  -78,  -78,  -78,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -78,  -78,  -78,  -78,  -78,  -78,   43,   43,  116,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -78,  -78,  -78,  -78,  -78,  -78,   43,   43,   43,
+      117,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -78,  -78,  -78,  -78,  -78
     },
@@ -1915,7 +1915,7 @@ static const flex_int16_t yy_nxt[][128]
       -79,  -79,  -79,  -79,  -79,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  -79,  -79,  -79,  -79,  -79,  -79,  117,   43,   43,
+       43,  -79,  -79,  -79,  -79,  -79,  -79,   43,   43,  118,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -79,  -79,  -79,  -79,  -79
@@ -1926,31 +1926,31 @@ static const flex_int16_t yy_nxt[][128]
         7,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,   80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,   81,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -80,  -80,  -80,  -80,  -80,  -80,  119,   43,   43,
 
-      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  -80,  -80,  -80,  -80,  -80
     },
 
     {
         7,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
-      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,   81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
 
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
-      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,   82,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
       -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81
@@ -1974,38 +1974,38 @@ static const flex_int16_t yy_nxt[][128]
     },
 
     {
-        7,   82,   82,   82,   82,   82,   82,   82,   82,   82,
+        7,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
 
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   83,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   82,   82,   82,   82,   82,   82,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   82,   82,   82,   82,   82
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83
     },
 
     {
-        7,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84
+        7,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   84,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   83,   83,   83,   83,   83,   83,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
+       85,   85,   85,   83,   83,   83,   83,   83
     },
 
     {
@@ -2016,48 +2016,48 @@ static const flex_int16_t yy_nxt[][128]
       -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
 
       -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
-      -85,  -85,  -85,  -85,  -85,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,  -85,  -85,  -85,  -85,  -85,  -85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
-       85,   85,   85,  -85,  -85,  -85,  -85,  -85
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85
     },
 
     {
-        7,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-      -86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+        7,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
 
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,  -86,  -86,  -86,  -86,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,  -86,  -86,  -86,  -86,  -86,  -86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
        86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
 
-       86,   86,   86,   86,   86,   86,   86,   86
+       86,   86,   86,  -86,  -86,  -86,  -86,  -86
     },
 
     {
-        7,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,  118,   43,   43,
-       43,   43,   43,  119,   43,   43,   43,   43,   43,   43,
-
-       43,  -87,  -87,  -87,  -87,  -87,  -87,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  -87,  -87,  -87,  -87,  -87
+        7,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+      -87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87
     },
 
     {
@@ -2070,7 +2070,7 @@ static const flex_int16_t yy_nxt[][128]
 
       -88,  -88,  -88,  -88,  -88,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,  120,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  121,   43,   43,   43,   43,   43,   43,
        43,  -88,  -88,  -88,  -88,  -88,  -88,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2089,8 +2089,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -89,  -89,  -89,  -89,  -89,  -89,   43,   43,   43,
-       43,  121,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  122,   43,   43,   43,   43,
        43,   43,   43,  -89,  -89,  -89,  -89,  -89
 
     },
@@ -2103,8 +2103,8 @@ static const flex_int16_t yy_nxt[][128]
       -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
       -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
       -90,  -90,  -90,  -90,  -90,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,  123,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  122,   43,   43,   43,   43,   43,   43,
        43,  -90,  -90,  -90,  -90,  -90,  -90,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2122,9 +2122,9 @@ static const flex_int16_t yy_nxt[][128]
       -91,  -91,  -91,  -91,  -91,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,  123,   43,   43,   43,   43,   43,   43,   43,
-       43,  -91,  -91,  -91,  -91,  -91,  -91,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -91,  -91,  -91,  -91,  -91,  -91,   43,   43,   43,
+       43,  124,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -91,  -91,  -91,  -91,  -91
     },
@@ -2139,10 +2139,10 @@ static const flex_int16_t yy_nxt[][128]
       -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,
       -92,  -92,  -92,  -92,  -92,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  125,   43,   43,   43,   43,   43,   43,
        43,  -92,  -92,  -92,  -92,  -92,  -92,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  124,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,  -92,  -92,  -92,  -92,  -92
     },
 
@@ -2156,7 +2156,7 @@ static const flex_int16_t yy_nxt[][128]
       -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
       -93,  -93,  -93,  -93,  -93,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,  126,   43,   43,   43,   43,   43,   43,   43,
        43,  -93,  -93,  -93,  -93,  -93,  -93,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
@@ -2174,10 +2174,10 @@ static const flex_int16_t yy_nxt[][128]
       -94,  -94,  -94,  -94,  -94,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,  125,   43,   43,   43,
-       43,  -94,  -94,  -94,  -94,  -94,  -94,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  -94,  -94,  -94,  -94,  -94,  -94,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  127,   43,   43,   43,   43,   43,
        43,   43,   43,  -94,  -94,  -94,  -94,  -94
     },
 
@@ -2208,10 +2208,10 @@ static const flex_int16_t yy_nxt[][128]
       -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,
       -96,  -96,  -96,  -96,  -96,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  128,   43,   43,   43,
        43,  -96,  -96,  -96,  -96,  -96,  -96,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  126,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,  -96,  -96,  -96,  -96,  -96
     },
@@ -2223,9 +2223,9 @@ static const flex_int16_t yy_nxt[][128]
       -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,
       -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,
       -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,
-      -97,  -97,  -97,  -97,  -97,   43,   43,   43,   43,  127,
+      -97,  -97,  -97,  -97,  -97,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,  128,   43,   43,   43,   43,   43,   43,   43,
 
        43,  -97,  -97,  -97,  -97,  -97,  -97,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2246,7 +2246,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,  -98,  -98,  -98,  -98,  -98,  -98,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  129,   43,
        43,   43,   43,  -98,  -98,  -98,  -98,  -98
     },
 
@@ -2258,9 +2258,9 @@ static const flex_int16_t yy_nxt[][128]
       -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
       -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
       -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
-      -99,  -99,  -99,  -99,  -99,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      -99,  -99,  -99,  -99,  -99,   43,   43,   43,   43,  130,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,  131,   43,   43,   43,   43,   43,   43,   43,
        43,  -99,  -99,  -99,  -99,  -99,  -99,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2292,7 +2292,7 @@ static const flex_int16_t yy_nxt[][128]
      -101, -101, -101, -101, -101, -101, -101, -101, -101, -101,
      -101, -101, -101, -101, -101, -101, -101, -101, -101, -101,
      -101, -101, -101, -101, -101, -101, -101, -101, -101, -101,
-     -101, -101, -101, -101, -101,   43,   43,  129,   43,   43,
+     -101, -101, -101, -101, -101,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2310,7 +2310,7 @@ static const flex_int16_t yy_nxt[][128]
 
      -102, -102, -102, -102, -102, -102, -102, -102, -102, -102,
      -102, -102, -102, -102, -102, -102, -102, -102, -102, -102,
-     -102, -102, -102, -102, -102,   43,   43,   43,   43,  130,
+     -102, -102, -102, -102, -102,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -102, -102, -102, -102, -102, -102,   43,   43,   43,
@@ -2327,10 +2327,10 @@ static const flex_int16_t yy_nxt[][128]
      -103, -103, -103, -103, -103, -103, -103, -103, -103, -103,
      -103, -103, -103, -103, -103, -103, -103, -103, -103, -103,
      -103, -103, -103, -103, -103, -103, -103, -103, -103, -103,
-     -103, -103, -103, -103, -103,   43,   43,   43,   43,   43,
+     -103, -103, -103, -103, -103,   43,   43,  132,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -103, -103, -103, -103, -103, -103,   43,   43,  131,
+       43, -103, -103, -103, -103, -103, -103,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2344,8 +2344,8 @@ static const flex_int16_t yy_nxt[][128]
      -104, -104, -104, -104, -104, -104, -104, -104, -104, -104,
      -104, -104, -104, -104, -104, -104, -104, -104, -104, -104,
      -104, -104, -104, -104, -104, -104, -104, -104, -104, -104,
-     -104, -104, -104, -104, -104,   43,   43,   43,   43,   43,
-       43,   43,   43,  132,   43,   43,   43,   43,   43,   43,
+     -104, -104, -104, -104, -104,   43,   43,   43,   43,  133,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -104, -104, -104, -104, -104, -104,   43,   43,   43,
@@ -2363,9 +2363,9 @@ static const flex_int16_t yy_nxt[][128]
 
      -105, -105, -105, -105, -105, -105, -105, -105, -105, -105,
      -105, -105, -105, -105, -105,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,  133,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -105, -105, -105, -105, -105, -105,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -105, -105, -105, -105, -105, -105,   43,   43,  134,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -105, -105, -105, -105, -105
@@ -2380,8 +2380,8 @@ static const flex_int16_t yy_nxt[][128]
      -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
      -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
      -106, -106, -106, -106, -106,   43,   43,   43,   43,   43,
+       43,   43,   43,  135,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  134,   43,   43,   43,   43,   43,
        43, -106, -106, -106, -106, -106, -106,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2397,12 +2397,12 @@ static const flex_int16_t yy_nxt[][128]
      -107, -107, -107, -107, -107, -107, -107, -107, -107, -107,
      -107, -107, -107, -107, -107, -107, -107, -107, -107, -107,
      -107, -107, -107, -107, -107,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,  136,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -107, -107, -107, -107, -107, -107,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  135,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -107, -107, -107, -107, -107
     },
 
@@ -2416,7 +2416,7 @@ static const flex_int16_t yy_nxt[][128]
 
      -108, -108, -108, -108, -108,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,  136,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  137,   43,   43,   43,   43,   43,
        43, -108, -108, -108, -108, -108, -108,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2436,7 +2436,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -109, -109, -109, -109, -109, -109,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  137,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  138,   43,   43,   43,
        43,   43,   43, -109, -109, -109, -109, -109
 
     },
@@ -2450,11 +2450,11 @@ static const flex_int16_t yy_nxt[][128]
      -110, -110, -110, -110, -110, -110, -110, -110, -110, -110,
      -110, -110, -110, -110, -110,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,  139,   43,   43,   43,   43,   43,   43,   43,
        43, -110, -110, -110, -110, -110, -110,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,  138,
-       43,   43,   43,   43,   43,  139,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -110, -110, -110, -110, -110
     },
 
@@ -2487,8 +2487,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -112, -112, -112, -112, -112, -112,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  141,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,  141,
+       43,   43,   43,   43,   43,  142,   43,   43,   43,   43,
        43,   43,   43, -112, -112, -112, -112, -112
     },
 
@@ -2504,9 +2504,9 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -113, -113, -113, -113, -113, -113,   43,   43,   43,
-       43,  142,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,  143,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  143,   43,   43,   43,   43,
        43,   43,   43, -113, -113, -113, -113, -113
     },
 
@@ -2522,8 +2522,8 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -114, -114, -114, -114, -114, -114,   43,   43,   43,
-       43,  144,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  144,   43,   43,   43,   43,   43,
        43,   43,   43, -114, -114, -114, -114, -114
     },
 
@@ -2539,8 +2539,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -115, -115, -115, -115, -115, -115,   43,   43,   43,
-       43,   43,   43,   43,   43,  145,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  145,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  146,   43,   43,   43,   43,   43,
        43,   43,   43, -115, -115, -115, -115, -115
     },
 
@@ -2556,8 +2556,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -116, -116, -116, -116, -116, -116,   43,   43,   43,
+       43,  147,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  146,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43, -116, -116, -116, -116, -116
     },
@@ -2574,8 +2574,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -117, -117, -117, -117, -117, -117,   43,   43,   43,
+       43,   43,   43,   43,   43,  148,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  147,   43,   43,   43,   43,   43,
        43,   43,   43, -117, -117, -117, -117, -117
     },
 
@@ -2588,11 +2588,11 @@ static const flex_int16_t yy_nxt[][128]
      -118, -118, -118, -118, -118, -118, -118, -118, -118, -118,
 
      -118, -118, -118, -118, -118,   43,   43,   43,   43,   43,
-       43,   43,   43,  148,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -118, -118, -118, -118, -118, -118,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -118, -118, -118, -118, -118, -118,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  149,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -118, -118, -118, -118, -118
     },
 
@@ -2604,12 +2604,12 @@ static const flex_int16_t yy_nxt[][128]
      -119, -119, -119, -119, -119, -119, -119, -119, -119, -119,
      -119, -119, -119, -119, -119, -119, -119, -119, -119, -119,
      -119, -119, -119, -119, -119, -119, -119, -119, -119, -119,
-     -119, -119, -119, -119, -119,   43,   43,   43,   43,  149,
+     -119, -119, -119, -119, -119,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -119, -119, -119, -119, -119, -119,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  150,   43,   43,   43,   43,   43,
        43,   43,   43, -119, -119, -119, -119, -119
 
     },
@@ -2622,7 +2622,7 @@ static const flex_int16_t yy_nxt[][128]
      -120, -120, -120, -120, -120, -120, -120, -120, -120, -120,
      -120, -120, -120, -120, -120, -120, -120, -120, -120, -120,
      -120, -120, -120, -120, -120,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  151,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -120, -120, -120, -120, -120, -120,   43,   43,   43,
 
@@ -2638,7 +2638,7 @@ static const flex_int16_t yy_nxt[][128]
      -121, -121, -121, -121, -121, -121, -121, -121, -121, -121,
      -121, -121, -121, -121, -121, -121, -121, -121, -121, -121,
      -121, -121, -121, -121, -121, -121, -121, -121, -121, -121,
-     -121, -121, -121, -121, -121,   43,   43,   43,   43,   43,
+     -121, -121, -121, -121, -121,   43,   43,   43,   43,  152,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2661,7 +2661,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -122, -122, -122, -122, -122, -122,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  153,   43,   43,   43,
        43,   43,   43, -122, -122, -122, -122, -122
     },
 
@@ -2673,7 +2673,7 @@ static const flex_int16_t yy_nxt[][128]
      -123, -123, -123, -123, -123, -123, -123, -123, -123, -123,
      -123, -123, -123, -123, -123, -123, -123, -123, -123, -123,
      -123, -123, -123, -123, -123, -123, -123, -123, -123, -123,
-     -123, -123, -123, -123, -123,   43,   43,   43,   43,  150,
+     -123, -123, -123, -123, -123,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -123, -123, -123, -123, -123, -123,   43,   43,   43,
@@ -2695,7 +2695,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -124, -124, -124, -124, -124, -124,   43,   43,   43,
-       43,  151,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -124, -124, -124, -124, -124
     },
@@ -2709,7 +2709,7 @@ static const flex_int16_t yy_nxt[][128]
 
      -125, -125, -125, -125, -125, -125, -125, -125, -125, -125,
      -125, -125, -125, -125, -125,   43,   43,   43,   43,   43,
-       43,   43,   43,  152,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -125, -125, -125, -125, -125, -125,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2725,11 +2725,11 @@ static const flex_int16_t yy_nxt[][128]
      -126, -126, -126, -126, -126, -126, -126, -126, -126, -126,
      -126, -126, -126, -126, -126, -126, -126, -126, -126, -126,
      -126, -126, -126, -126, -126, -126, -126, -126, -126, -126,
-     -126, -126, -126, -126, -126,   43,   43,   43,   43,   43,
+     -126, -126, -126, -126, -126,   43,   43,   43,   43,  154,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -126, -126, -126, -126, -126, -126,   43,   43,   43,
-       43,   43,   43,   43,   43,  153,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43, -126, -126, -126, -126, -126
@@ -2744,10 +2744,10 @@ static const flex_int16_t yy_nxt[][128]
      -127, -127, -127, -127, -127, -127, -127, -127, -127, -127,
      -127, -127, -127, -127, -127,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,  154,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -127, -127, -127, -127, -127, -127,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  155,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -127, -127, -127, -127, -127
     },
@@ -2760,8 +2760,8 @@ static const flex_int16_t yy_nxt[][128]
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
 
-     -128, -128, -128, -128, -128,   43,   43,   43,   43,  155,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+     -128, -128, -128, -128, -128,   43,   43,   43,   43,   43,
+       43,   43,   43,  156,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -128, -128, -128, -128, -128, -128,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2777,11 +2777,11 @@ static const flex_int16_t yy_nxt[][128]
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
-     -129, -129, -129, -129, -129,  156,   43,   43,   43,   43,
+     -129, -129, -129, -129, -129,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -129, -129, -129, -129, -129, -129,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  157,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -129, -129, -129, -129, -129
 
@@ -2795,8 +2795,8 @@ static const flex_int16_t yy_nxt[][128]
      -130, -130, -130, -130, -130, -130, -130, -130, -130, -130,
      -130, -130, -130, -130, -130, -130, -130, -130, -130, -130,
      -130, -130, -130, -130, -130,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  157,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,  158,   43,   43,   43,   43,   43,   43,   43,
        43, -130, -130, -130, -130, -130, -130,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2811,11 +2811,11 @@ static const flex_int16_t yy_nxt[][128]
      -131, -131, -131, -131, -131, -131, -131, -131, -131, -131,
      -131, -131, -131, -131, -131, -131, -131, -131, -131, -131,
      -131, -131, -131, -131, -131, -131, -131, -131, -131, -131,
-     -131, -131, -131, -131, -131,   43,   43,   43,   43,   43,
+     -131, -131, -131, -131, -131,   43,   43,   43,   43,  159,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -131, -131, -131, -131, -131, -131,  158,   43,   43,
+       43, -131, -131, -131, -131, -131, -131,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -131, -131, -131, -131, -131
@@ -2829,7 +2829,7 @@ static const flex_int16_t yy_nxt[][128]
 
      -132, -132, -132, -132, -132, -132, -132, -132, -132, -132,
      -132, -132, -132, -132, -132, -132, -132, -132, -132, -132,
-     -132, -132, -132, -132, -132,  159,   43,   43,   43,   43,
+     -132, -132, -132, -132, -132,  160,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -132, -132, -132, -132, -132, -132,   43,   43,   43,
@@ -2847,7 +2847,7 @@ static const flex_int16_t yy_nxt[][128]
      -133, -133, -133, -133, -133, -133, -133, -133, -133, -133,
      -133, -133, -133, -133, -133, -133, -133, -133, -133, -133,
      -133, -133, -133, -133, -133,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  160,   43,
+       43,   43,   43,   43,   43,   43,  161,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -133, -133, -133, -133, -133, -133,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2866,8 +2866,8 @@ static const flex_int16_t yy_nxt[][128]
      -134, -134, -134, -134, -134,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,  161,   43,   43,   43,   43,   43,   43,
-       43, -134, -134, -134, -134, -134, -134,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -134, -134, -134, -134, -134, -134,  162,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -134, -134, -134, -134, -134
@@ -2881,12 +2881,12 @@ static const flex_int16_t yy_nxt[][128]
      -135, -135, -135, -135, -135, -135, -135, -135, -135, -135,
 
      -135, -135, -135, -135, -135, -135, -135, -135, -135, -135,
-     -135, -135, -135, -135, -135,   43,   43,   43,   43,   43,
+     -135, -135, -135, -135, -135,  163,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -135, -135, -135, -135, -135, -135,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  162,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -135, -135, -135, -135, -135
     },
 
@@ -2899,8 +2899,8 @@ static const flex_int16_t yy_nxt[][128]
      -136, -136, -136, -136, -136, -136, -136, -136, -136, -136,
      -136, -136, -136, -136, -136, -136, -136, -136, -136, -136,
      -136, -136, -136, -136, -136,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  164,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  163,   43,   43,   43,   43,   43,   43,
        43, -136, -136, -136, -136, -136, -136,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -2917,11 +2917,11 @@ static const flex_int16_t yy_nxt[][128]
      -137, -137, -137, -137, -137, -137, -137, -137, -137, -137,
      -137, -137, -137, -137, -137,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  165,   43,   43,   43,   43,   43,   43,
 
        43, -137, -137, -137, -137, -137, -137,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  164,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -137, -137, -137, -137, -137
     },
 
@@ -2937,8 +2937,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -138, -138, -138, -138, -138, -138,   43,   43,   43,
-       43,   43,   43,   43,   43,  165,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  166,   43,   43,   43,   43,
        43,   43,   43, -138, -138, -138, -138, -138
     },
 
@@ -2952,9 +2952,9 @@ static const flex_int16_t yy_nxt[][128]
      -139, -139, -139, -139, -139, -139, -139, -139, -139, -139,
      -139, -139, -139, -139, -139,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  167,   43,   43,   43,   43,   43,   43,
        43, -139, -139, -139, -139, -139, -139,   43,   43,   43,
-       43,  166,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -139, -139, -139, -139, -139
 
@@ -2973,7 +2973,7 @@ static const flex_int16_t yy_nxt[][128]
        43, -140, -140, -140, -140, -140, -140,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  168,   43,   43,   43,
        43,   43,   43, -140, -140, -140, -140, -140
     },
 
@@ -2989,7 +2989,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -141, -141, -141, -141, -141, -141,   43,   43,   43,
-       43,  167,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  169,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -141, -141, -141, -141, -141
     },
@@ -3006,8 +3006,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -142, -142, -142, -142, -142, -142,   43,   43,   43,
+       43,  170,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  168,   43,   43,   43,   43,   43,
        43,   43,   43, -142, -142, -142, -142, -142
     },
 
@@ -3023,7 +3023,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -143, -143, -143, -143, -143, -143,   43,   43,   43,
-       43,  169,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -143, -143, -143, -143, -143
@@ -3041,7 +3041,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -144, -144, -144, -144, -144, -144,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  170,   43,
+       43,  171,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -144, -144, -144, -144, -144
     },
@@ -3057,9 +3057,9 @@ static const flex_int16_t yy_nxt[][128]
      -145, -145, -145, -145, -145,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -145, -145, -145, -145, -145, -145,  171,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -145, -145, -145, -145, -145, -145,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  172,   43,   43,   43,   43,   43,
        43,   43,   43, -145, -145, -145, -145, -145
     },
 
@@ -3075,8 +3075,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -146, -146, -146, -146, -146, -146,   43,   43,   43,
+       43,  173,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-      172,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43, -146, -146, -146, -146, -146
     },
@@ -3093,8 +3093,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -147, -147, -147, -147, -147, -147,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  174,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   70,   43,   43,   43,   43,
        43,   43,   43, -147, -147, -147, -147, -147
     },
 
@@ -3107,9 +3107,9 @@ static const flex_int16_t yy_nxt[][128]
      -148, -148, -148, -148, -148, -148, -148, -148, -148, -148,
 
      -148, -148, -148, -148, -148,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  173,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -148, -148, -148, -148, -148, -148,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -148, -148, -148, -148, -148, -148,  175,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -148, -148, -148, -148, -148
@@ -3123,12 +3123,12 @@ static const flex_int16_t yy_nxt[][128]
      -149, -149, -149, -149, -149, -149, -149, -149, -149, -149,
      -149, -149, -149, -149, -149, -149, -149, -149, -149, -149,
      -149, -149, -149, -149, -149, -149, -149, -149, -149, -149,
-     -149, -149, -149, -149, -149,   43,   43,  174,   43,   43,
+     -149, -149, -149, -149, -149,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -149, -149, -149, -149, -149, -149,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      176,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -149, -149, -149, -149, -149
 
     },
@@ -3140,13 +3140,13 @@ static const flex_int16_t yy_nxt[][128]
      -150, -150, -150, -150, -150, -150, -150, -150, -150, -150,
      -150, -150, -150, -150, -150, -150, -150, -150, -150, -150,
      -150, -150, -150, -150, -150, -150, -150, -150, -150, -150,
-     -150, -150, -150, -150, -150,   43,   43,   43,   43,  175,
+     -150, -150, -150, -150, -150,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -150, -150, -150, -150, -150, -150,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   71,   43,   43,   43,   43,
        43,   43,   43, -150, -150, -150, -150, -150
     },
 
@@ -3159,10 +3159,10 @@ static const flex_int16_t yy_nxt[][128]
      -151, -151, -151, -151, -151, -151, -151, -151, -151, -151,
      -151, -151, -151, -151, -151,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  177,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -151, -151, -151, -151, -151, -151,   43,   43,   43,
-       43,  176,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -151, -151, -151, -151, -151
     },
@@ -3175,8 +3175,8 @@ static const flex_int16_t yy_nxt[][128]
 
      -152, -152, -152, -152, -152, -152, -152, -152, -152, -152,
      -152, -152, -152, -152, -152, -152, -152, -152, -152, -152,
-     -152, -152, -152, -152, -152,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  177,   43,
+     -152, -152, -152, -152, -152,   43,   43,  178,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -152, -152, -152, -152, -152, -152,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3198,7 +3198,7 @@ static const flex_int16_t yy_nxt[][128]
        43, -153, -153, -153, -153, -153, -153,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-      178,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,  179,   43,   43,   43,   43,   43,
        43,   43,   43, -153, -153, -153, -153, -153
     },
 
@@ -3209,10 +3209,10 @@ static const flex_int16_t yy_nxt[][128]
      -154, -154, -154, -154, -154, -154, -154, -154, -154, -154,
      -154, -154, -154, -154, -154, -154, -154, -154, -154, -154,
      -154, -154, -154, -154, -154, -154, -154, -154, -154, -154,
-     -154, -154, -154, -154, -154,   43,   43,   43,   43,   43,
+     -154, -154, -154, -154, -154,   43,   43,   43,   43,  180,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,  179,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -154, -154, -154, -154, -154, -154,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3229,9 +3229,9 @@ static const flex_int16_t yy_nxt[][128]
      -155, -155, -155, -155, -155, -155, -155, -155, -155, -155,
      -155, -155, -155, -155, -155,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  180,   43,   43,   43,   43,   43,   43,
-       43, -155, -155, -155, -155, -155, -155,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -155, -155, -155, -155, -155, -155,   43,   43,   43,
+       43,  181,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -155, -155, -155, -155, -155
     },
@@ -3245,7 +3245,7 @@ static const flex_int16_t yy_nxt[][128]
      -156, -156, -156, -156, -156, -156, -156, -156, -156, -156,
      -156, -156, -156, -156, -156, -156, -156, -156, -156, -156,
      -156, -156, -156, -156, -156,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,  181,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  182,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -156, -156, -156, -156, -156, -156,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3263,11 +3263,11 @@ static const flex_int16_t yy_nxt[][128]
      -157, -157, -157, -157, -157, -157, -157, -157, -157, -157,
      -157, -157, -157, -157, -157,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  182,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -157, -157, -157, -157, -157, -157,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      183,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -157, -157, -157, -157, -157
     },
 
@@ -3281,9 +3281,9 @@ static const flex_int16_t yy_nxt[][128]
 
      -158, -158, -158, -158, -158,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  184,   43,   43,   43,   43,   43,   43,
        43, -158, -158, -158, -158, -158, -158,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  183,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -158, -158, -158, -158, -158
     },
@@ -3297,8 +3297,8 @@ static const flex_int16_t yy_nxt[][128]
      -159, -159, -159, -159, -159, -159, -159, -159, -159, -159,
      -159, -159, -159, -159, -159, -159, -159, -159, -159, -159,
      -159, -159, -159, -159, -159,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,  184,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  185,   43,   43,   43,   43,   43,   43,
        43, -159, -159, -159, -159, -159, -159,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3313,8 +3313,8 @@ static const flex_int16_t yy_nxt[][128]
      -160, -160, -160, -160, -160, -160, -160, -160, -160, -160,
      -160, -160, -160, -160, -160, -160, -160, -160, -160, -160,
      -160, -160, -160, -160, -160, -160, -160, -160, -160, -160,
-     -160, -160, -160, -160, -160,   43,   43,   43,  185,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+     -160, -160, -160, -160, -160,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,  186,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -160, -160, -160, -160, -160, -160,   43,   43,   43,
 
@@ -3333,7 +3333,7 @@ static const flex_int16_t yy_nxt[][128]
      -161, -161, -161, -161, -161,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  187,   43,   43,   43,   43,   43,   43,
        43, -161, -161, -161, -161, -161, -161,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3352,7 +3352,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -162, -162, -162, -162, -162, -162,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  188,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -162, -162, -162, -162, -162
     },
@@ -3366,7 +3366,7 @@ static const flex_int16_t yy_nxt[][128]
      -163, -163, -163, -163, -163, -163, -163, -163, -163, -163,
      -163, -163, -163, -163, -163, -163, -163, -163, -163, -163,
      -163, -163, -163, -163, -163,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,  189,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -163, -163, -163, -163, -163, -163,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3382,13 +3382,13 @@ static const flex_int16_t yy_nxt[][128]
      -164, -164, -164, -164, -164, -164, -164, -164, -164, -164,
      -164, -164, -164, -164, -164, -164, -164, -164, -164, -164,
      -164, -164, -164, -164, -164, -164, -164, -164, -164, -164,
-     -164, -164, -164, -164, -164,   43,   43,   43,   43,   43,
+     -164, -164, -164, -164, -164,   43,   43,   43,  190,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -164, -164, -164, -164, -164, -164,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,  186,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -164, -164, -164, -164, -164
     },
 
@@ -3405,7 +3405,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -165, -165, -165, -165, -165, -165,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-      187,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -165, -165, -165, -165, -165
     },
 
@@ -3420,7 +3420,7 @@ static const flex_int16_t yy_nxt[][128]
      -166, -166, -166, -166, -166,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -166, -166, -166, -166, -166, -166,   43,   43,  188,
+       43, -166, -166, -166, -166, -166, -166,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
@@ -3439,7 +3439,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43, -167, -167, -167, -167, -167, -167,   43,   43,   43,
-       43,  189,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -167, -167, -167, -167, -167
     },
@@ -3457,7 +3457,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -168, -168, -168, -168, -168, -168,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  190,   43,   43,   43,   43,
+       43,   43,   43,   43,  191,   43,   43,   43,   43,   43,
        43,   43,   43, -168, -168, -168, -168, -168
     },
 
@@ -3474,7 +3474,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -169, -169, -169, -169, -169, -169,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  191,   43,   43,   43,   43,
+      192,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -169, -169, -169, -169, -169
 
     },
@@ -3489,10 +3489,10 @@ static const flex_int16_t yy_nxt[][128]
      -170, -170, -170, -170, -170,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43, -170, -170, -170, -170, -170, -170,   43,   43,   43,
+       43, -170, -170, -170, -170, -170, -170,   43,   43,  193,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  182,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -170, -170, -170, -170, -170
     },
 
@@ -3508,8 +3508,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -171, -171, -171, -171, -171, -171,   43,   43,   43,
+       43,  194,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-      192,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -171, -171, -171, -171, -171
     },
 
@@ -3525,8 +3525,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -172, -172, -172, -172, -172, -172,   43,   43,   43,
-      193,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  195,   43,   43,   43,   43,
        43,   43,   43, -172, -172, -172, -172, -172
     },
 
@@ -3540,11 +3540,11 @@ static const flex_int16_t yy_nxt[][128]
      -173, -173, -173, -173, -173, -173, -173, -173, -173, -173,
      -173, -173, -173, -173, -173,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  194,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -173, -173, -173, -173, -173, -173,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  196,   43,   43,   43,   43,
        43,   43,   43, -173, -173, -173, -173, -173
     },
 
@@ -3558,10 +3558,10 @@ static const flex_int16_t yy_nxt[][128]
      -174, -174, -174, -174, -174,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,  195,   43,   43,   43,   43,   43,   43,
-       43, -174, -174, -174, -174, -174, -174,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -174, -174, -174, -174, -174, -174,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  187,   43,   43,   43,   43,
        43,   43,   43, -174, -174, -174, -174, -174
     },
 
@@ -3575,10 +3575,10 @@ static const flex_int16_t yy_nxt[][128]
      -175, -175, -175, -175, -175, -175, -175, -175, -175, -175,
      -175, -175, -175, -175, -175,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  196,   43,   43,   43,   43,   43,   43,
-       43, -175, -175, -175, -175, -175, -175,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -175, -175, -175, -175, -175, -175,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+      197,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -175, -175, -175, -175, -175
     },
 
@@ -3594,8 +3594,8 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -176, -176, -176, -176, -176, -176,   43,   43,   43,
+      198,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  197,   43,   43,   43,   43,
 
        43,   43,   43, -176, -176, -176, -176, -176
     },
@@ -3609,7 +3609,7 @@ static const flex_int16_t yy_nxt[][128]
      -177, -177, -177, -177, -177, -177, -177, -177, -177, -177,
      -177, -177, -177, -177, -177,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  198,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  199,   43,   43,   43,   43,   43,   43,
 
        43, -177, -177, -177, -177, -177, -177,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3627,10 +3627,10 @@ static const flex_int16_t yy_nxt[][128]
 
      -178, -178, -178, -178, -178,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  200,   43,   43,   43,   43,   43,   43,
        43, -178, -178, -178, -178, -178, -178,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  199,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -178, -178, -178, -178, -178
     },
 
@@ -3647,7 +3647,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -179, -179, -179, -179, -179, -179,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  201,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -179, -179, -179, -179, -179
 
     },
@@ -3661,7 +3661,7 @@ static const flex_int16_t yy_nxt[][128]
      -180, -180, -180, -180, -180, -180, -180, -180, -180, -180,
      -180, -180, -180, -180, -180,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  202,   43,   43,   43,   43,   43,   43,
        43, -180, -180, -180, -180, -180, -180,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3679,10 +3679,10 @@ static const flex_int16_t yy_nxt[][128]
      -181, -181, -181, -181, -181,   43,   43,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  200,   43,   43,   43,   43,   43,   43,
-       43, -181, -181, -181, -181, -181, -181,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -181, -181, -181, -181, -181, -181,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  203,   43,   43,   43,   43,
        43,   43,   43, -181, -181, -181, -181, -181
     },
 
@@ -3696,7 +3696,7 @@ static const flex_int16_t yy_nxt[][128]
      -182, -182, -182, -182, -182, -182, -182, -182, -182, -182,
      -182, -182, -182, -182, -182,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  204,   43,   43,   43,   43,   43,   43,
        43, -182, -182, -182, -182, -182, -182,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3717,7 +3717,7 @@ static const flex_int16_t yy_nxt[][128]
        43, -183, -183, -183, -183, -183, -183,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,  201,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  205,   43,   43,   43,   43,
        43,   43,   43, -183, -183, -183, -183, -183
     },
 
@@ -3731,7 +3731,7 @@ static const flex_int16_t yy_nxt[][128]
      -184, -184, -184, -184, -184,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,  202,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -184, -184, -184, -184, -184, -184,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3748,7 +3748,7 @@ static const flex_int16_t yy_nxt[][128]
      -185, -185, -185, -185, -185, -185, -185, -185, -185, -185,
      -185, -185, -185, -185, -185,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,  203,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -185, -185, -185, -185, -185, -185,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3765,10 +3765,10 @@ static const flex_int16_t yy_nxt[][128]
      -186, -186, -186, -186, -186, -186, -186, -186, -186, -186,
      -186, -186, -186, -186, -186,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  206,   43,   43,   43,   43,   43,   43,
        43, -186, -186, -186, -186, -186, -186,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,  204,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
        43,   43,   43, -186, -186, -186, -186, -186
     },
@@ -3786,7 +3786,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43, -187, -187, -187, -187, -187, -187,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  194,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -187, -187, -187, -187, -187
     },
 
@@ -3803,7 +3803,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -188, -188, -188, -188, -188, -188,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  195,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  207,   43,   43,   43,   43,
        43,   43,   43, -188, -188, -188, -188, -188
     },
 
@@ -3817,10 +3817,10 @@ static const flex_int16_t yy_nxt[][128]
      -189, -189, -189, -189, -189, -189, -189, -189, -189, -189,
      -189, -189, -189, -189, -189,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  208,   43,   43,   43,   43,   43,   43,
        43, -189, -189, -189, -189, -189, -189,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  205,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -189, -189, -189, -189, -189
 
     },
@@ -3834,7 +3834,7 @@ static const flex_int16_t yy_nxt[][128]
      -190, -190, -190, -190, -190, -190, -190, -190, -190, -190,
      -190, -190, -190, -190, -190,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,  209,   43,   43,   43,   43,   43,   43,
        43, -190, -190, -190, -190, -190, -190,   43,   43,   43,
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
@@ -3855,7 +3855,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -191, -191, -191, -191, -191, -191,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,  210,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -191, -191, -191, -191, -191
     },
 
@@ -3872,7 +3872,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -192, -192, -192, -192, -192, -192,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,  206,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  199,   43,   43,   43,   43,
        43,   43,   43, -192, -192, -192, -192, -192
     },
 
@@ -3890,7 +3890,7 @@ static const flex_int16_t yy_nxt[][128]
        43, -193, -193, -193, -193, -193, -193,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
 
-       43,   43,   43,   43,   43,  207,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  200,   43,   43,   43,   43,
        43,   43,   43, -193, -193, -193, -193, -193
     },
 
@@ -3907,7 +3907,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -194, -194, -194, -194, -194, -194,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  211,   43,   43,   43,   43,
        43,   43,   43, -194, -194, -194, -194, -194
     },
 
@@ -3959,7 +3959,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43, -197, -197, -197, -197, -197, -197,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  212,   43,   43,   43,   43,
        43,   43,   43, -197, -197, -197, -197, -197
     },
 
@@ -3976,7 +3976,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -198, -198, -198, -198, -198, -198,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  213,   43,   43,   43,   43,
        43,   43,   43, -198, -198, -198, -198, -198
     },
 
@@ -4027,7 +4027,7 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -201, -201, -201, -201, -201, -201,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,  214,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -201, -201, -201, -201, -201
     },
@@ -4079,7 +4079,7 @@ static const flex_int16_t yy_nxt[][128]
 
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43, -204, -204, -204, -204, -204, -204,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   43,  208,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43, -204, -204, -204, -204, -204
     },
@@ -4153,6 +4153,145 @@ static const flex_int16_t yy_nxt[][128]
        43,   43,   43, -208, -208, -208, -208, -208
     },
 
+    {
+        7, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209, -209, -209,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -209, -209, -209, -209, -209, -209,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43, -209, -209, -209, -209, -209
+
+    },
+
+    {
+        7, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210, -210, -210,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -210, -210, -210, -210, -210, -210,   43,   43,   43,
+
+       43,   43,   43,   43,   43,   43,   43,   43,   43,  215,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43, -210, -210, -210, -210, -210
+    },
+
+    {
+        7, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211, -211, -211, -211, -211, -211,
+     -211, -211, -211, -211, -211,   43,   43,   43,   43,   43,
+
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -211, -211, -211, -211, -211, -211,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43, -211, -211, -211, -211, -211
+    },
+
+    {
+        7, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+     -212, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+     -212, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+     -212, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+
+     -212, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+     -212, -212, -212, -212, -212, -212, -212, -212, -212, -212,
+     -212, -212, -212, -212, -212,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -212, -212, -212, -212, -212, -212,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43, -212, -212, -212, -212, -212
+    },
+
+    {
+        7, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+
+     -213, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+     -213, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+     -213, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+     -213, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+     -213, -213, -213, -213, -213, -213, -213, -213, -213, -213,
+     -213, -213, -213, -213, -213,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -213, -213, -213, -213, -213, -213,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43, -213, -213, -213, -213, -213
+    },
+
+    {
+        7, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214, -214, -214, -214, -214, -214,
+     -214, -214, -214, -214, -214,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -214, -214, -214, -214, -214, -214,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  216,   43,   43,   43,   43,
+       43,   43,   43, -214, -214, -214, -214, -214
+    },
+
+    {
+        7, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+     -215, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+     -215, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+     -215, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+     -215, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+
+     -215, -215, -215, -215, -215, -215, -215, -215, -215, -215,
+     -215, -215, -215, -215, -215,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -215, -215, -215, -215, -215, -215,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,  216,   43,   43,   43,   43,
+       43,   43,   43, -215, -215, -215, -215, -215
+    },
+
+    {
+        7, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+     -216, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+
+     -216, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+     -216, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+     -216, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+     -216, -216, -216, -216, -216, -216, -216, -216, -216, -216,
+     -216, -216, -216, -216, -216,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43, -216, -216, -216, -216, -216, -216,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
+
+       43,   43,   43, -216, -216, -216, -216, -216
+    },
+
     } ;
 
 static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );
@@ -4178,44 +4317,45 @@ struct yy_trans_info
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static const flex_int16_t yy_accept[209] =
+static const flex_int16_t yy_accept[217] =
     {   0,
         0,    0,    0,    0,   36,   36,   38,    3,    2,   31,
        31,   31,   10,   31,   14,   31,   31,   20,   31,   31,
        31,   28,   31,   31,   31,   31,   31,   31,   31,   31,
        31,   31,   31,   31,    2,    1,   35,   37,   35,   32,
        36,    2,   31,   31,   31,   31,   31,   31,   31,   31,
-       13,   15,   17,   31,   31,   19,   31,   31,   31,   31,
-       31,   31,   31,   31,   31,   31,   31,   31,   31,   30,
-       31,   31,   31,   31,   31,   31,   31,   31,   31,    2,
-        1,   33,   33,   34,   32,   36,   31,   31,   31,    9,
-       11,   11,   12,   31,   16,   31,   31,   22,   21,   23,
-
-       31,   31,   31,   26,   27,   31,   31,   31,   31,   31,
-        9,   31,   31,   31,   31,   27,   31,   31,   31,    7,
-        8,    9,   31,   31,   31,   31,   31,   31,   31,   31,
-       31,   31,   31,   29,   29,   30,   31,   31,   31,    9,
-       31,   31,   31,   31,   31,   31,   30,   31,   31,   31,
-       31,   31,   31,   20,   20,   31,   25,   31,   31,   31,
-       29,   29,   30,   31,   31,   31,   31,   20,   20,   31,
-       31,   31,    5,    6,   11,   11,   18,   18,   20,   20,
-       24,   25,   24,   26,   27,   31,   31,   31,   11,   20,
-       20,   26,   27,    5,    6,   11,   11,   18,   18,   24,
+       31,   13,   15,   17,   31,   31,   19,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       30,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+        2,    1,   33,   33,   34,   32,   36,   31,   31,   31,
+       31,    9,   11,   11,   12,   31,   16,   31,   31,   22,
+
+       21,   23,   31,   31,   31,   26,   27,   31,   31,   31,
+       31,   31,    9,   31,   31,   31,   31,   27,   31,   31,
+       31,   31,    7,    8,    9,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   29,   29,   30,   31,
+       31,   31,    9,   31,   31,   31,   31,   31,   31,   30,
+       31,   31,   31,   31,   31,   31,   31,   20,   20,   31,
+       25,   31,   31,   31,   29,   29,   30,   31,   31,   31,
+       31,   20,   20,   31,   31,   31,    5,    6,   31,   11,
+       11,   18,   18,   20,   20,   24,   25,   24,   26,   27,
+       31,   31,   31,   11,   20,   20,   26,   27,    5,    6,
 
-       24,   26,   27,   31,   11,   26,   27,    4
+       31,   11,   11,   18,   18,   24,   24,   26,   27,   31,
+       11,   26,   27,   31,    4,    4
     } ;
 
-static const yy_state_type yy_NUL_trans[209] =
+static const yy_state_type yy_NUL_trans[217] =
     {   0,
         8,    8,   37,   37,   41,   41,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,   82,    0,
-       86,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   83,    0,
+       87,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,   82,    0,    0,   86,    0,    0,    0,    0,
+        0,    0,    0,   83,    0,    0,   87,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
@@ -4229,7 +4369,8 @@ static const yy_state_type yy_NUL_trans[
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 
-        0,    0,    0,    0,    0,    0,    0,    0
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0
     } ;
 
 /* The intent behind this definition is that it'll catch
@@ -4241,9 +4382,8 @@ static const yy_state_type yy_NUL_trans[
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "wcsutrn.l"
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -4260,11 +4400,9 @@ static const yy_state_type yy_NUL_trans[
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsutrn.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsutrn.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
 * wcsutrn.l is a Flex description file containing the definition of a lexical
@@ -4280,7 +4418,7 @@ static const yy_state_type yy_NUL_trans[
 #define YY_NO_INPUT 1
 /* Exclusive start states. */
 
-#line 51 "wcsutrn.l"
+#line 48 "wcsutrn.l"
 #include <setjmp.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -4292,7 +4430,7 @@ static const yy_state_type yy_NUL_trans[
 static int wcsutrne_scanner(int ctrl, char unitstr[], struct wcserr **err,
                             yyscan_t yyscanner);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsutrne(
   int ctrl,
@@ -4312,20 +4450,20 @@ int wcsutrne(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define YY_DECL int wcsutrne_scanner(int ctrl, char unitstr[], \
  struct wcserr **err, yyscan_t yyscanner)
 
-/* Dummy definition to circumvent compiler warnings. */
+// Dummy definition to circumvent compiler warnings.
 #define YY_INPUT(inbuff, count, bufsize) { count = YY_NULL; }
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
+// Used in preempting the call to exit() by yy_fatal_error().
 jmp_buf wcsutrn_abort_jmp_env;
 #define exit(status) longjmp(wcsutrn_abort_jmp_env, status)
 
-#line 4328 "wcsutrn.c"
-#line 4329 "wcsutrn.c"
+#line 4466 "wcsutrn.c"
+#line 4467 "wcsutrn.c"
 
 #define INITIAL 0
 #define NEXT 1
@@ -4574,9 +4712,9 @@ YY_DECL
 		}
 
 	{
-#line 96 "wcsutrn.l"
+#line 93 "wcsutrn.l"
 
-#line 98 "wcsutrn.l"
+#line 95 "wcsutrn.l"
 	static const char *function = "wcsutrne";
 	
 	char orig[80], subs[80];
@@ -4593,7 +4731,7 @@ YY_DECL
 	yy_scan_string(unitstr, yyscanner);
 	*unitstr = '\0';
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
+	// Return here via longjmp() invoked by yy_fatal_error().
 	if (setjmp(wcsutrn_abort_jmp_env)) {
 	  return wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units translator error parsing '%s'", unitstr);
@@ -4605,7 +4743,7 @@ YY_DECL
 	fprintf(stderr, "\n%s ->\n", unitstr);
 #endif
 
-#line 4609 "wcsutrn.c"
+#line 4747 "wcsutrn.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -4638,24 +4776,24 @@ do_action:	/* This label is used only to
 	{ /* beginning of action switch */
 case 1:
 YY_RULE_SETUP
-#line 126 "wcsutrn.l"
+#line 123 "wcsutrn.l"
 {
-	  /* Looks like a keycomment. */
+	  // Looks like a keycomment.
 	  strcat(unitstr, "[");
 	  bracket = 1;
 	}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 132 "wcsutrn.l"
-/* Discard leading whitespace. */
+#line 129 "wcsutrn.l"
+// Discard leading whitespace.
 	YY_BREAK
 case 3:
 /* rule 3 can match eol */
 YY_RULE_SETUP
-#line 134 "wcsutrn.l"
+#line 131 "wcsutrn.l"
 {
-	  /* Non-alphabetic character. */
+	  // Non-alphabetic character.
 	  strcat(unitstr, yytext);
 	  if (bracket && *yytext == ']') {
 	    BEGIN(FLUSH);
@@ -4664,7 +4802,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 142 "wcsutrn.l"
+#line 139 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "Angstrom");
@@ -4673,7 +4811,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 148 "wcsutrn.l"
+#line 145 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "arcmin");
@@ -4682,7 +4820,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 154 "wcsutrn.l"
+#line 151 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "arcsec");
@@ -4691,7 +4829,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 160 "wcsutrn.l"
+#line 157 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "beam");
@@ -4700,7 +4838,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 166 "wcsutrn.l"
+#line 163 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "byte");
@@ -4709,7 +4847,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 172 "wcsutrn.l"
+#line 169 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "d");
@@ -4718,7 +4856,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 178 "wcsutrn.l"
+#line 175 "wcsutrn.l"
 {
 	  unsafe = 1;
 	  strcpy(orig, yytext);
@@ -4728,7 +4866,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 185 "wcsutrn.l"
+#line 182 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "deg");
@@ -4737,7 +4875,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 191 "wcsutrn.l"
+#line 188 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "GHz");
@@ -4746,7 +4884,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 197 "wcsutrn.l"
+#line 194 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "h");
@@ -4755,7 +4893,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 203 "wcsutrn.l"
+#line 200 "wcsutrn.l"
 {
 	  unsafe = 1;
 	  strcpy(orig, yytext);
@@ -4765,7 +4903,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 210 "wcsutrn.l"
+#line 207 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "Hz");
@@ -4774,7 +4912,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 216 "wcsutrn.l"
+#line 213 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "kHz");
@@ -4783,7 +4921,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 222 "wcsutrn.l"
+#line 219 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "Jy");
@@ -4792,7 +4930,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 228 "wcsutrn.l"
+#line 225 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "K");
@@ -4801,7 +4939,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 234 "wcsutrn.l"
+#line 231 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "km");
@@ -4810,7 +4948,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 240 "wcsutrn.l"
+#line 237 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "m");
@@ -4819,7 +4957,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 246 "wcsutrn.l"
+#line 243 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "min");
@@ -4828,7 +4966,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 252 "wcsutrn.l"
+#line 249 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "MHz");
@@ -4837,7 +4975,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 258 "wcsutrn.l"
+#line 255 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "ohm");
@@ -4846,7 +4984,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 264 "wcsutrn.l"
+#line 261 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "Pa");
@@ -4855,7 +4993,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 270 "wcsutrn.l"
+#line 267 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "pixel");
@@ -4864,7 +5002,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 276 "wcsutrn.l"
+#line 273 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "rad");
@@ -4873,7 +5011,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 282 "wcsutrn.l"
+#line 279 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "s");
@@ -4882,7 +5020,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 288 "wcsutrn.l"
+#line 285 "wcsutrn.l"
 {
 	  unsafe = 1;
 	  strcpy(orig, yytext);
@@ -4892,7 +5030,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 295 "wcsutrn.l"
+#line 292 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "V");
@@ -4901,7 +5039,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 301 "wcsutrn.l"
+#line 298 "wcsutrn.l"
 {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "yr");
@@ -4910,9 +5048,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 307 "wcsutrn.l"
+#line 304 "wcsutrn.l"
 {
-	  /* Not a recognized alias. */
+	  // Not a recognized alias.
 	  strcpy(orig, yytext);
 	  strcpy(subs, orig);
 	  BEGIN(NEXT);
@@ -4920,9 +5058,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 314 "wcsutrn.l"
+#line 311 "wcsutrn.l"
 {
-	  /* Reject the alias match. */
+	  // Reject the alias match.
 	  strcat(orig, yytext);
 	  strcpy(subs, orig);
 	}
@@ -4930,17 +5068,17 @@ YY_RULE_SETUP
 case 33:
 /* rule 33 can match eol */
 YY_RULE_SETUP
-#line 320 "wcsutrn.l"
+#line 317 "wcsutrn.l"
 {
-	  /* Discard separating whitespace. */
+	  // Discard separating whitespace.
 	  unput(yytext[yyleng-1]);
 	}
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 325 "wcsutrn.l"
+#line 322 "wcsutrn.l"
 {
-	  /* Compress separating whitespace. */
+	  // Compress separating whitespace.
 	  strcat(unitstr, subs);
 	  strcat(unitstr, " ");
 	  if (strcmp(orig, subs)) status = 0;
@@ -4951,9 +5089,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 335 "wcsutrn.l"
+#line 332 "wcsutrn.l"
 {
-	  /* Copy anything else unchanged. */
+	  // Copy anything else unchanged.
 	  strcat(unitstr, subs);
 	  if (strcmp(orig, subs)) status = 0;
 	  unput(*yytext);
@@ -4963,18 +5101,18 @@ YY_RULE_SETUP
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 344 "wcsutrn.l"
+#line 341 "wcsutrn.l"
 {
-	  /* Copy out remaining input. */
+	  // Copy out remaining input.
 	  strcat(unitstr, yytext);
 	}
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(NEXT):
 case YY_STATE_EOF(FLUSH):
-#line 349 "wcsutrn.l"
+#line 346 "wcsutrn.l"
 {
-	  /* End-of-string. */
+	  // End-of-string.
 	  if (*subs) {
 	    strcat(unitstr, subs);
 	    if (strcmp(orig, subs)) status = 0;
@@ -4989,10 +5127,10 @@ case YY_STATE_EOF(FLUSH):
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 363 "wcsutrn.l"
+#line 360 "wcsutrn.l"
 ECHO;
 	YY_BREAK
-#line 4996 "wcsutrn.c"
+#line 5134 "wcsutrn.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -6142,6 +6280,6 @@ void yyfree (void * ptr , yyscan_t yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 363 "wcsutrn.l"
+#line 360 "wcsutrn.l"
 
 
Index: astropy-4.2/cextern/wcslib/C/getwcstab.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/getwcstab.c
+++ astropy-4.2/cextern/wcslib/C/getwcstab.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: getwcstab.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: getwcstab.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <stdlib.h>
@@ -32,7 +29,7 @@
 
 #include "getwcstab.h"
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int fits_read_wcstab(
   fitsfile   *fptr,
@@ -54,30 +51,30 @@ int fits_read_wcstab(
 
   if (nwtb == 0) return 0;
 
-  /* Zero the array pointers. */
+  // Zero the array pointers.
   wtbp = wtb;
   for (iwtb = 0; iwtb < nwtb; iwtb++, wtbp++) {
     *wtbp->arrayp = 0x0;
   }
 
-  /* Save HDU number so that we can move back to it later. */
+  // Save HDU number so that we can move back to it later.
   fits_get_hdu_num(fptr, &hdunum);
 
   wtbp = wtb;
   for (iwtb = 0; iwtb < nwtb; iwtb++, wtbp++) {
-    /* Move to the required binary table extension. */
+    // Move to the required binary table extension.
     if (fits_movnam_hdu(fptr, BINARY_TBL, (char *)(wtbp->extnam),
         wtbp->extver, status)) {
       goto cleanup;
     }
 
-    /* Locate the table column. */
+    // Locate the table column.
     if (fits_get_colnum(fptr, CASEINSEN, (char *)(wtbp->ttype), &colnum,
         status)) {
       goto cleanup;
     }
 
-    /* Get the array dimensions and check for consistency. */
+    // Get the array dimensions and check for consistency.
     if (wtbp->ndim < 1) {
       *status = NEG_AXIS;
       goto cleanup;
@@ -94,7 +91,7 @@ int fits_read_wcstab(
 
     if (naxis != wtbp->ndim) {
       if (wtbp->kind == 'c' && wtbp->ndim == 2) {
-        /* Allow TDIMn to be omitted for degenerate coordinate arrays. */
+        // Allow TDIMn to be omitted for degenerate coordinate arrays.
         naxis = 2;
         naxes[1] = naxes[0];
         naxes[0] = 1;
@@ -105,16 +102,16 @@ int fits_read_wcstab(
     }
 
     if (wtbp->kind == 'c') {
-      /* Coordinate array; calculate the array size. */
+      // Coordinate array; calculate the array size.
       nelem = naxes[0];
       for (m = 0; m < naxis-1; m++) {
         *(wtbp->dimlen + m) = naxes[m+1];
         nelem *= naxes[m+1];
       }
     } else {
-      /* Index vector; check length. */
+      // Index vector; check length.
       if ((nelem = naxes[0]) != *(wtbp->dimlen)) {
-        /* N.B. coordinate array precedes the index vectors. */
+        // N.B. coordinate array precedes the index vectors.
         *status = BAD_TDIM;
         goto cleanup;
       }
@@ -123,13 +120,13 @@ int fits_read_wcstab(
     free(naxes);
     naxes = 0;
 
-    /* Allocate memory for the array. */
+    // Allocate memory for the array.
     if (!(*wtbp->arrayp = calloc((size_t)nelem, sizeof(double)))) {
       *status = MEMORY_ALLOCATION;
       goto cleanup;
     }
 
-    /* Read the array from the table. */
+    // Read the array from the table.
     if (fits_read_col_dbl(fptr, colnum, wtbp->row, 1L, nelem, 0.0,
         *wtbp->arrayp, &anynul, status)) {
       goto cleanup;
@@ -137,11 +134,11 @@ int fits_read_wcstab(
   }
 
 cleanup:
-  /* Move back to the starting HDU. */
+  // Move back to the starting HDU.
   nostat = 0;
   fits_movabs_hdu(fptr, hdunum, 0, &nostat);
 
-  /* Release allocated memory. */
+  // Release allocated memory.
   if (naxes) free(naxes);
   if (*status) {
     wtbp = wtb;
Index: astropy-4.2/cextern/wcslib/C/getwcstab.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/getwcstab.h
+++ astropy-4.2/cextern/wcslib/C/getwcstab.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: getwcstab.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: getwcstab.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -68,50 +65,50 @@
 *             int       CFITSIO status value.
 *
 * Notes:
-*   In order to maintain WCSLIB and CFITSIO as independent libraries it is not
-*   permissible for any CFITSIO library code to include WCSLIB header files,
-*   or vice versa.  However, the CFITSIO function fits_read_wcstab() accepts
-*   an array of wtbarr structs defined in wcs.h within WCSLIB.
-*
-*   The problem therefore is to define the wtbarr struct within fitsio.h
-*   without including wcs.h, especially noting that wcs.h will often (but not
-*   always) be included together with fitsio.h in an applications program that
-*   uses fits_read_wcstab().
-*
-*   The solution adopted is for WCSLIB to define "struct wtbarr" while
-*   fitsio.h defines "typedef wtbarr" as an untagged struct with identical
-*   members.  This allows both wcs.h and fitsio.h to define a wtbarr data type
-*   without conflict by virtue of the fact that structure tags and typedef
-*   names share different name spaces in C; Appendix A, Sect. A11.1 (p227) of
-*   the K&R ANSI edition states that:
-*
-*     Identifiers fall into several name spaces that do not interfere with one
-*     another; the same identifier may be used for different purposes, even in
-*     the same scope, if the uses are in different name spaces.  These classes
-*     are: objects, functions, typedef names, and enum constants; labels; tags
-*     of structures, unions, and enumerations; and members of each structure
-*     or union individually.
-*
-*   Therefore, declarations within WCSLIB look like
-*
-=     struct wtbarr *w;
-*
-*   while within CFITSIO they are simply
-*
-=     wtbarr *w;
-*
-*   As suggested by the commonality of the names, these are really the same
-*   aggregate data type.  However, in passing a (struct wtbarr *) to
-*   fits_read_wcstab() a cast to (wtbarr *) is formally required.
-*
-*   When using WCSLIB and CFITSIO together in C++ the situation is complicated
-*   by the fact that typedefs and structs share the same namespace; C++
-*   Annotated Reference Manual, Sect. 7.1.3 (p105).  In that case the wtbarr
-*   struct in wcs.h is renamed by preprocessor macro substitution to wtbarr_s
-*   to distinguish it from the typedef defined in fitsio.h.  However, the
-*   scope of this macro substitution is limited to wcs.h itself and CFITSIO
-*   programmer code, whether in C++ or C, should always use the wtbarr
-*   typedef.
+*   1: In order to maintain WCSLIB and CFITSIO as independent libraries it is
+*      not permissible for any CFITSIO library code to include WCSLIB header
+*      files, or vice versa.  However, the CFITSIO function fits_read_wcstab()
+*      accepts an array of wtbarr structs defined in wcs.h within WCSLIB.
+*
+*      The problem therefore is to define the wtbarr struct within fitsio.h
+*      without including wcs.h, especially noting that wcs.h will often (but
+*      not always) be included together with fitsio.h in an applications
+*      program that uses fits_read_wcstab().
+*
+*      The solution adopted is for WCSLIB to define "struct wtbarr" while
+*      fitsio.h defines "typedef wtbarr" as an untagged struct with identical
+*      members.  This allows both wcs.h and fitsio.h to define a wtbarr data
+*      type without conflict by virtue of the fact that structure tags and
+*      typedef names share different name spaces in C; Appendix A, Sect. A11.1
+*      (p227) of the K&R ANSI edition states that:
+*
+=        Identifiers fall into several name spaces that do not interfere with
+=        one another; the same identifier may be used for different purposes,
+=        even in the same scope, if the uses are in different name spaces.
+=        These classes are: objects, functions, typedef names, and enum
+=        constants; labels; tags of structures, unions, and enumerations; and
+=        members of each structure or union individually.
+*
+*      Therefore, declarations within WCSLIB look like
+*
+=        struct wtbarr *w;
+*
+*      while within CFITSIO they are simply
+*
+=        wtbarr *w;
+*
+*      As suggested by the commonality of the names, these are really the same
+*      aggregate data type.  However, in passing a (struct wtbarr *) to
+*      fits_read_wcstab() a cast to (wtbarr *) is formally required.
+*
+*      When using WCSLIB and CFITSIO together in C++ the situation is
+*      complicated by the fact that typedefs and structs share the same
+*      namespace; C++ Annotated Reference Manual, Sect. 7.1.3 (p105).  In that
+*      case the wtbarr struct in wcs.h is renamed by preprocessor macro
+*      substitution to wtbarr_s to distinguish it from the typedef defined in
+*      fitsio.h.  However, the scope of this macro substitution is limited to
+*      wcs.h itself and CFITSIO programmer code, whether in C++ or C, should
+*      always use the wtbarr typedef.
 *
 *
 * wtbarr typedef
@@ -168,18 +165,18 @@ extern "C" {
 #include <fitsio.h>
 
 typedef struct {
-  int  i;			/* Image axis number.                       */
-  int  m;			/* Array axis number for index vectors.     */
-  int  kind;			/* Array type, 'c' (coord) or 'i' (index).  */
-  char extnam[72];		/* EXTNAME of binary table extension.       */
-  int  extver;			/* EXTVER  of binary table extension.       */
-  int  extlev;			/* EXTLEV  of binary table extension.       */
-  char ttype[72];		/* TTYPEn of column containing the array.   */
-  long row;			/* Table row number.                        */
-  int  ndim;			/* Expected array dimensionality.           */
-  int  *dimlen;			/* Where to write the array axis lengths.   */
-  double **arrayp;		/* Where to write the address of the array  */
-				/* allocated to store the array.            */
+  int  i;			// Image axis number.
+  int  m;			// Array axis number for index vectors.
+  int  kind;			// Array type, 'c' (coord) or 'i' (index).
+  char extnam[72];		// EXTNAME of binary table extension.
+  int  extver;			// EXTVER  of binary table extension.
+  int  extlev;			// EXTLEV  of binary table extension.
+  char ttype[72];		// TTYPEn of column containing the array.
+  long row;			// Table row number.
+  int  ndim;			// Expected array dimensionality.
+  int  *dimlen;			// Where to write the array axis lengths.
+  double **arrayp;		// Where to write the address of the array
+				// allocated to store the array.
 } wtbarr;
 
 
@@ -190,4 +187,4 @@ int fits_read_wcstab(fitsfile *fptr, int
 }
 #endif
 
-#endif /* WCSLIB_GETWCSTAB */
+#endif // WCSLIB_GETWCSTAB
Index: astropy-4.2/cextern/wcslib/C/lin.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/lin.c
+++ astropy-4.2/cextern/wcslib/C/lin.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: lin.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: lin.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <stdio.h>
@@ -37,7 +34,7 @@
 
 const int LINSET = 137;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *lin_errmsg[] = {
   "Success",
   "Null linprm pointer passed",
@@ -47,20 +44,20 @@ const char *lin_errmsg[] = {
   "Distort error",
   "De-distort error"};
 
-/* Map error returns for lower-level routines. */
+// Map error returns for lower-level routines.
 const int lin_diserr[] = {
-  LINERR_SUCCESS,		/*  0: DISERR_SUCCESS         */
-  LINERR_NULL_POINTER,		/*  1: DISERR_NULL_POINTER    */
-  LINERR_MEMORY,		/*  2: DISERR_MEMORY          */
-  LINERR_DISTORT_INIT,		/*  3: DISERR_BAD_PARAM       */
-  LINERR_DISTORT,		/*  4: DISERR_DISTORT         */
-  LINERR_DEDISTORT		/*  5: DISERR_DEDISTORT       */
+  LINERR_SUCCESS,		//  0: DISERR_SUCCESS
+  LINERR_NULL_POINTER,		//  1: DISERR_NULL_POINTER
+  LINERR_MEMORY,		//  2: DISERR_MEMORY
+  LINERR_DISTORT_INIT,		//  3: DISERR_BAD_PARAM
+  LINERR_DISTORT,		//  4: DISERR_DISTORT
+  LINERR_DEDISTORT		//  5: DISERR_DEDISTORT
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define LIN_ERRMSG(status) WCSERR_SET(status), lin_errmsg[status]
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linini(int alloc, int naxis, struct linprm *lin)
 
@@ -68,7 +65,7 @@ int linini(int alloc, int naxis, struct
   return lininit(alloc, naxis, lin, -1);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int lininit(int alloc, int naxis, struct linprm *lin, int ndpmax)
 
@@ -81,7 +78,7 @@ int lininit(int alloc, int naxis, struct
 
   if (lin == 0x0) return LINERR_NULL_POINTER;
 
-  /* Initialize error message handling. */
+  // Initialize error message handling.
   if (lin->flag == -1) {
     lin->err = 0x0;
   }
@@ -89,7 +86,7 @@ int lininit(int alloc, int naxis, struct
   wcserr_clear(err);
 
 
-  /* Initialize memory management. */
+  // Initialize memory management.
   if (lin->flag == -1 || lin->m_flag != LINSET) {
     if (lin->flag == -1) {
       lin->dispre = 0x0;
@@ -112,21 +109,21 @@ int lininit(int alloc, int naxis, struct
   }
 
 
-  /* Allocate memory for arrays if required. */
+  // Allocate memory for arrays if required.
   if (alloc ||
       lin->crpix  == 0x0 ||
       lin->pc     == 0x0 ||
       lin->cdelt  == 0x0) {
 
-    /* Was sufficient allocated previously? */
+    // Was sufficient allocated previously?
     if (lin->m_flag == LINSET && lin->m_naxis < naxis) {
-      /* No, free it. */
+      // No, free it.
       linfree(lin);
     }
 
     if (alloc || lin->crpix == 0x0) {
       if (lin->m_crpix) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         lin->crpix = lin->m_crpix;
 
       } else {
@@ -142,7 +139,7 @@ int lininit(int alloc, int naxis, struct
 
     if (alloc || lin->pc == 0x0) {
       if (lin->m_pc) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         lin->pc = lin->m_pc;
 
       } else {
@@ -159,7 +156,7 @@ int lininit(int alloc, int naxis, struct
 
     if (alloc || lin->cdelt == 0x0) {
       if (lin->m_cdelt) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         lin->cdelt = lin->m_cdelt;
 
       } else {
@@ -176,7 +173,7 @@ int lininit(int alloc, int naxis, struct
   }
 
 
-  /* Reinitialize disprm structs if we are managing them. */
+  // Reinitialize disprm structs if we are managing them.
   if (lin->m_dispre) {
     disinit(1, naxis, lin->dispre, ndpmax);
   }
@@ -186,7 +183,7 @@ int lininit(int alloc, int naxis, struct
   }
 
 
-  /* Free memory allocated by linset(). */
+  // Free memory allocated by linset().
   if (lin->flag == LINSET) {
     if (lin->piximg) free(lin->piximg);
     if (lin->imgpix) free(lin->imgpix);
@@ -206,12 +203,12 @@ int lininit(int alloc, int naxis, struct
   lin->naxis = naxis;
 
 
-  /* CRPIXja defaults to 0.0. */
+  // CRPIXja defaults to 0.0.
   for (j = 0; j < naxis; j++) {
     lin->crpix[j] = 0.0;
   }
 
-  /* PCi_ja defaults to the unit matrix. */
+  // PCi_ja defaults to the unit matrix.
   pc = lin->pc;
   for (i = 0; i < naxis; i++) {
     for (j = 0; j < naxis; j++) {
@@ -224,7 +221,7 @@ int lininit(int alloc, int naxis, struct
     }
   }
 
-  /* CDELTia defaults to 1.0. */
+  // CDELTia defaults to 1.0.
   for (i = 0; i < naxis; i++) {
     lin->cdelt[i] = 1.0;
   }
@@ -233,7 +230,7 @@ int lininit(int alloc, int naxis, struct
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int lindis(int sequence, struct linprm *lin, struct disprm *dis)
 
@@ -241,7 +238,7 @@ int lindis(int sequence, struct linprm *
   return lindist(sequence, lin, dis, -1);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int lindist(int sequence, struct linprm *lin, struct disprm *dis, int ndpmax)
 
@@ -288,7 +285,7 @@ int lindist(int sequence, struct linprm
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int lincpy(int alloc, const struct linprm *linsrc, struct linprm *lindst)
 
@@ -384,7 +381,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linfree(struct linprm *lin)
 
@@ -392,7 +389,7 @@ int linfree(struct linprm *lin)
   if (lin == 0x0) return LINERR_NULL_POINTER;
 
   if (lin->flag != -1) {
-    /* Optionally allocated by lininit() for given parameters. */
+    // Optionally allocated by lininit() for given parameters.
     if (lin->m_flag == LINSET) {
       if (lin->crpix  == lin->m_crpix)  lin->crpix  = 0x0;
       if (lin->pc     == lin->m_pc)     lin->pc     = 0x0;
@@ -415,7 +412,7 @@ int linfree(struct linprm *lin)
       }
     }
 
-    /* Allocated unconditionally by linset(). */
+    // Allocated unconditionally by linset().
     if (lin->piximg) free(lin->piximg);
     if (lin->imgpix) free(lin->imgpix);
     if (lin->tmpcrd) free(lin->tmpcrd);
@@ -443,7 +440,7 @@ int linfree(struct linprm *lin)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linprt(const struct linprm *lin)
 
@@ -458,7 +455,7 @@ int linprt(const struct linprm *lin)
   }
   wcsprintf("       flag: %d\n", lin->flag);
 
-  /* Parameters supplied. */
+  // Parameters supplied.
   wcsprintf("      naxis: %d\n", lin->naxis);
 
   WCSPRINTF_PTR("      crpix: ", lin->crpix, "\n");
@@ -492,7 +489,7 @@ int linprt(const struct linprm *lin)
   if (lin->disseq != 0x0) wcsprintf("  (see below)");
   wcsprintf("\n");
 
-  /* Derived values. */
+  // Derived values.
   if (lin->piximg == 0x0) {
     wcsprintf("     piximg: (nil)\n");
   } else {
@@ -524,16 +521,16 @@ int linprt(const struct linprm *lin)
   wcsprintf("     affine: %d\n", lin->affine);
   wcsprintf("     simple: %d\n", lin->simple);
 
-  /* Error handling. */
+  // Error handling.
   WCSPRINTF_PTR("        err: ", lin->err, "\n");
   if (lin->err) {
     wcserr_prt(lin->err, "             ");
   }
 
-  /* Work arrays. */
+  // Work arrays.
   WCSPRINTF_PTR("     tmpcrd: ", lin->tmpcrd, "\n");
 
-  /* Memory management. */
+  // Memory management.
   wcsprintf("     m_flag: %d\n", lin->m_flag);
   wcsprintf("    m_naxis: %d\n", lin->m_naxis);
   WCSPRINTF_PTR("    m_crpix: ", lin->m_crpix, "");
@@ -552,7 +549,7 @@ int linprt(const struct linprm *lin)
   if (lin->disseq && lin->m_disseq == lin->disseq) wcsprintf("  (= disseq)");
   wcsprintf("\n");
 
-  /* Distortion parameters (from above). */
+  // Distortion parameters (from above).
   if (lin->dispre) {
     wcsprintf("\n");
     wcsprintf("dispre.*\n");
@@ -568,7 +565,7 @@ int linprt(const struct linprm *lin)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linperr(const struct linprm *lin, const char *prefix)
 
@@ -583,7 +580,7 @@ int linperr(const struct linprm *lin, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linset(struct linprm *lin)
 
@@ -599,7 +596,7 @@ int linset(struct linprm *lin)
 
   naxis = lin->naxis;
 
-  /* Check for a unit matrix. */
+  // Check for a unit matrix.
   lin->unity = 1;
   pc = lin->pc;
   for (i = 0; i < naxis; i++) {
@@ -621,7 +618,7 @@ int linset(struct linprm *lin)
 
   if (lin->unity) {
     if (lin->flag == LINSET) {
-      /* Free memory that may have been allocated previously. */
+      // Free memory that may have been allocated previously.
       if (lin->piximg) free(lin->piximg);
       if (lin->imgpix) free(lin->imgpix);
     }
@@ -630,7 +627,7 @@ int linset(struct linprm *lin)
     lin->imgpix  = 0x0;
     lin->i_naxis = 0;
 
-    /* Check cdelt. */
+    // Check cdelt.
     for (i = 0; i < naxis; i++) {
       if (lin->cdelt[i] == 0.0) {
         return wcserr_set(LIN_ERRMSG(LINERR_SINGULAR_MTX));
@@ -640,12 +637,12 @@ int linset(struct linprm *lin)
   } else {
     if (lin->flag != LINSET || lin->i_naxis < naxis) {
       if (lin->flag == LINSET) {
-        /* Free memory that may have been allocated previously. */
+        // Free memory that may have been allocated previously.
         if (lin->piximg) free(lin->piximg);
         if (lin->imgpix) free(lin->imgpix);
       }
 
-      /* Allocate memory for internal arrays. */
+      // Allocate memory for internal arrays.
       if ((lin->piximg = calloc(naxis*naxis, sizeof(double))) == 0x0) {
         return wcserr_set(LIN_ERRMSG(LINERR_MEMORY));
       }
@@ -658,28 +655,30 @@ int linset(struct linprm *lin)
       lin->i_naxis = naxis;
     }
 
-    /* Compute the pixel-to-image transformation matrix. */
+    // Compute the pixel-to-image transformation matrix.
     pc     = lin->pc;
     piximg = lin->piximg;
     for (i = 0; i < naxis; i++) {
-      for (j = 0; j < naxis; j++) {
-        if (lin->disseq == 0x0) {
-          /* No sequent distortions, incorporate cdelt into piximg. */
+      if (lin->disseq == 0x0) {
+        // No sequent distortions.  Incorporate cdelt into piximg.
+        for (j = 0; j < naxis; j++) {
           *(piximg++) = lin->cdelt[i] * (*(pc++));
-        } else {
+        }
+      } else {
+        for (j = 0; j < naxis; j++) {
           *(piximg++) = *(pc++);
         }
       }
     }
 
-    /* Compute the image-to-pixel transformation matrix. */
+    // Compute the image-to-pixel transformation matrix.
     if ((status = matinv(naxis, lin->piximg, lin->imgpix))) {
       return wcserr_set(LIN_ERRMSG(status));
     }
   }
 
 
-  /* Set up the distortion functions. */
+  // Set up the distortion functions.
   lin->affine = 1;
   if (lin->dispre) {
     if ((status = disset(lin->dispre))) {
@@ -700,7 +699,7 @@ int linset(struct linprm *lin)
   lin->simple = lin->unity && lin->affine;
 
 
-  /* Create work arrays. */
+  // Create work arrays.
   if (lin->tmpcrd) free(lin->tmpcrd);
   if ((lin->tmpcrd = calloc(naxis, sizeof(double))) == 0x0) {
     linfree(lin);
@@ -713,7 +712,7 @@ int linset(struct linprm *lin)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linp2x(
   struct linprm *lin,
@@ -732,7 +731,7 @@ int linp2x(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (lin == 0x0) return LINERR_NULL_POINTER;
   err = &(lin->err);
 
@@ -743,12 +742,12 @@ int linp2x(
   n = lin->naxis;
 
 
-  /* Convert pixel coordinates to intermediate world coordinates. */
+  // Convert pixel coordinates to intermediate world coordinates.
   pix = pixcrd;
   img = imgcrd;
 
   if (lin->simple) {
-    /* Handle the simplest and most common case with maximum efficiency. */
+    // Handle the simplest and most common case with maximum efficiency.
     nelemn = nelem - n;
     for (k = 0; k < ncoord; k++) {
       for (i = 0; i < n; i++) {
@@ -760,17 +759,17 @@ int linp2x(
     }
 
   } else if (lin->affine) {
-    /* No distortions. */
+    // No distortions.
     ndbl   = n * sizeof(double);
     nelemn = nelem - n;
     for (k = 0; k < ncoord; k++) {
       memset(img, 0, ndbl);
 
       for (j = 0; j < n; j++) {
-        /* cdelt will have been incorporated into piximg. */
+        // cdelt will have been incorporated into piximg.
         piximg = lin->piximg + j;
 
-        /* Column-wise multiplication allows this to be cached. */
+        // Column-wise multiplication allows this to be cached.
         temp = *(pix++) - lin->crpix[j];
         for (i = 0; i < n; i++, piximg += n) {
           img[i] += *piximg * temp;
@@ -782,7 +781,7 @@ int linp2x(
     }
 
   } else {
-    /* Distortions are present. */
+    // Distortions are present.
     ndbl = n * sizeof(double);
     tmp  = lin->tmpcrd;
 
@@ -819,13 +818,13 @@ int linp2x(
           return wcserr_set(LIN_ERRMSG(lin_diserr[status]));
         }
 
-        /* With sequent distortions, cdelt is not incorporated into piximg. */
+        // With sequent distortions, cdelt is not incorporated into piximg...
         for (i = 0; i < n; i++) {
           img[i] = lin->cdelt[i] * tmp[i];
         }
 
       } else if (lin->unity) {
-        /* ...nor if the matrix is unity. */
+        // ...nor if the matrix is unity.
         for (i = 0; i < n; i++) {
           img[i] *= lin->cdelt[i];
         }
@@ -839,7 +838,7 @@ int linp2x(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linx2p(
   struct linprm *lin,
@@ -857,7 +856,7 @@ int linx2p(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (lin == 0x0) return LINERR_NULL_POINTER;
   err = &(lin->err);
 
@@ -868,12 +867,12 @@ int linx2p(
   n = lin->naxis;
 
 
-  /* Convert intermediate world coordinates to pixel coordinates. */
+  // Convert intermediate world coordinates to pixel coordinates.
   img = imgcrd;
   pix = pixcrd;
 
   if (lin->simple) {
-    /* Handle the simplest and most common case with maximum efficiency. */
+    // Handle the simplest and most common case with maximum efficiency.
     nelemn = nelem - n;
     for (k = 0; k < ncoord; k++) {
       for (j = 0; j < n; j++) {
@@ -885,10 +884,10 @@ int linx2p(
     }
 
   } else if (lin->affine) {
-    /* No distortions. */
+    // No distortions.
     nelemn = nelem - n;
     for (k = 0; k < ncoord; k++) {
-      /* cdelt will have been incorporated into imgpix. */
+      // cdelt will have been incorporated into imgpix.
       imgpix = lin->imgpix;
 
       for (j = 0; j < n; j++) {
@@ -906,13 +905,13 @@ int linx2p(
     }
 
   } else {
-    /* Distortions are present. */
+    // Distortions are present.
     ndbl = n * sizeof(double);
     tmp  = lin->tmpcrd;
 
     for (k = 0; k < ncoord; k++) {
       if (lin->disseq) {
-        /* With sequent distortions, cdelt is not incorporated into imgpix. */
+        // With sequent distortions, cdelt is not incorporated into imgpix...
         for (i = 0; i < n; i++) {
           tmp[i] = img[i] / lin->cdelt[i];
         }
@@ -924,13 +923,13 @@ int linx2p(
         memcpy(tmp, pix, ndbl);
 
       } else if (lin->unity) {
-        /* ...nor if the matrix is unity. */
+        // ...nor if the matrix is unity.
         for (i = 0; i < n; i++) {
           tmp[i] = img[i] / lin->cdelt[i];
         }
 
       } else {
-        /* cdelt will have been incorporated into imgpix. */
+        // cdelt will have been incorporated into imgpix.
         memcpy(tmp, img, ndbl);
       }
 
@@ -965,7 +964,7 @@ int linx2p(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int linwarp(
   struct linprm *lin,
@@ -990,7 +989,7 @@ int linwarp(
   struct wcserr **err;
 
 
-  /* Initialize. */
+  // Initialize.
   if (lin == 0x0) return LINERR_NULL_POINTER;
   err = &(lin->err);
 
@@ -1006,17 +1005,17 @@ int linwarp(
   if (avgtot) *avgtot = 0.0;
   if (rmstot) *rmstot = 0.0;
 
-  /* Quick return if no distortions. */
+  // Quick return if no distortions.
   if (lin->affine) return 0;
 
-  /* It's easier if there are no sequent distortions! */
+  // It's easier if there are no sequent distortions!
   if (lin->disseq == 0x0) {
     status = diswarp(lin->dispre, pixblc, pixtrc, pixsamp, nsamp,
                      maxdis, maxtot, avgdis, avgtot, rmsdis, rmstot);
     return wcserr_set(LIN_ERRMSG(lin_diserr[status]));
   }
 
-  /* Make a reference copy of lin without distortions. */
+  // Make a reference copy of lin without distortions.
   affine.flag = -1;
   if ((status = (lincpy(1, lin, &affine) ||
                  lindist(1, &affine, 0x0, 0) ||
@@ -1025,7 +1024,7 @@ int linwarp(
     return wcserr_set(LIN_ERRMSG(status));
   }
 
-  /* Work out increments on each axis. */
+  // Work out increments on each axis.
   pixinc = lin->tmpcrd;
   ncoord = 0;
   for (j = 0; j < naxis; j++) {
@@ -1044,12 +1043,12 @@ int linwarp(
     }
 
     if (j == 0) {
-      /* Number of samples on axis 1. */
+      // Number of samples on axis 1.
       ncoord = 1 + (int)((pixspan/pixinc[0]) + 0.5);
     }
   }
 
-  /* Get memory for processing the image row by row. */
+  // Get memory for processing the image row by row.
   if ((pix0 = calloc((3*ncoord+4)*naxis, sizeof(double))) == 0x0) {
     return wcserr_set(LIN_ERRMSG(LINERR_MEMORY));
   }
@@ -1062,10 +1061,10 @@ int linwarp(
   ssqdis = sumdis + naxis;
 
 
-  /* Copy tmpcrd since linp2x() will overwrite it. */
+  // Copy tmpcrd since linp2x() will overwrite it.
   memcpy(pixinc, lin->tmpcrd, naxis*sizeof(double));
 
-  /* Set up the array of pixel coordinates. */
+  // Set up the array of pixel coordinates.
   for (j = 0; j < naxis; j++) {
     pix0[j] = pixblc ? pixblc[j] : 1.0;
     pixend[j] = pixtrc[j] + 0.5*pixinc[j];
@@ -1080,7 +1079,7 @@ int linwarp(
     }
   }
 
-  /* Initialize accumulators. */
+  // Initialize accumulators.
   for (j = 0; j < naxis; j++) {
     sumdis[j] = 0.0;
     ssqdis[j] = 0.0;
@@ -1089,20 +1088,20 @@ int linwarp(
   ssqtot = 0.0;
 
 
-  /* Loop over N dimensions. */
+  // Loop over N dimensions.
   carry = 0;
   while (carry == 0) {
     if ((status = linp2x(lin, ncoord, naxis, pix0, img))) {
-      /* (Preserve the error message set by linp2x().) */
+      // (Preserve the error message set by linp2x().)
       goto cleanup;
     }
 
     if ((status = linx2p(&affine, ncoord, naxis, img, pix1))) {
-      /* (Preserve the error message set by linx2p().) */
+      // (Preserve the error message set by linx2p().)
       goto cleanup;
     }
 
-    /* Accumulate statistics. */
+    // Accumulate statistics.
     pix0p = pix0;
     pix1p = pix1;
     for (i = 0; i < ncoord; i++) {
@@ -1128,7 +1127,7 @@ int linwarp(
       if (maxtot && *maxtot < totdis) *maxtot = totdis;
     }
 
-    /* Next array of pixel coordinates. */
+    // Next array of pixel coordinates.
     for (j = 1; j < naxis; j++) {
       pix0[j] += pixinc[j];
       if ((carry = (pix0[j] > pixend[j]))) {
@@ -1146,7 +1145,7 @@ int linwarp(
   }
 
 
-  /* Compute the means and RMSs. */
+  // Compute the means and RMSs.
   for (j = 0; j < naxis; j++) {
     ssqdis[j] /= *nsamp;
     sumdis[j] /= *nsamp;
@@ -1167,7 +1166,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int matinv(int n, const double mat[], double inv[])
 
@@ -1177,7 +1176,7 @@ int matinv(int n, const double mat[], do
   double colmax, *lu, *rowmax, dtemp;
 
 
-  /* Allocate memory for internal arrays. */
+  // Allocate memory for internal arrays.
   if ((mxl = calloc(n, sizeof(int))) == 0x0) {
     return LINERR_MEMORY;
   }
@@ -1200,9 +1199,9 @@ int matinv(int n, const double mat[], do
   }
 
 
-  /* Initialize arrays. */
+  // Initialize arrays.
   for (i = 0, ij = 0; i < n; i++) {
-    /* Vector that records row interchanges. */
+    // Vector that records row interchanges.
     mxl[i] = i;
 
     rowmax[i] = 0.0;
@@ -1214,7 +1213,7 @@ int matinv(int n, const double mat[], do
       lu[ij] = mat[ij];
     }
 
-    /* A row of zeroes indicates a singular matrix. */
+    // A row of zeroes indicates a singular matrix.
     if (rowmax[i] == 0.0) {
       free(mxl);
       free(lxm);
@@ -1225,9 +1224,9 @@ int matinv(int n, const double mat[], do
   }
 
 
-  /* Form the LU triangular factorization using scaled partial pivoting. */
+  // Form the LU triangular factorization using scaled partial pivoting.
   for (k = 0; k < n; k++) {
-    /* Decide whether to pivot. */
+    // Decide whether to pivot.
     colmax = fabs(lu[k*n+k]) / rowmax[k];
     pivot = k;
 
@@ -1241,34 +1240,34 @@ int matinv(int n, const double mat[], do
     }
 
     if (pivot > k) {
-      /* We must pivot, interchange the rows of the design matrix. */
+      // We must pivot, interchange the rows of the design matrix.
       for (j = 0, pj = pivot*n, kj = k*n; j < n; j++, pj++, kj++) {
         dtemp = lu[pj];
         lu[pj] = lu[kj];
         lu[kj] = dtemp;
       }
 
-      /* Amend the vector of row maxima. */
+      // Amend the vector of row maxima.
       dtemp = rowmax[pivot];
       rowmax[pivot] = rowmax[k];
       rowmax[k] = dtemp;
 
-      /* Record the interchange for later use. */
+      // Record the interchange for later use.
       itemp = mxl[pivot];
       mxl[pivot] = mxl[k];
       mxl[k] = itemp;
     }
 
-    /* Gaussian elimination. */
+    // Gaussian elimination.
     for (i = k+1; i < n; i++) {
       ik = i*n + k;
 
-      /* Nothing to do if lu[ik] is zero. */
+      // Nothing to do if lu[ik] is zero.
       if (lu[ik] != 0.0) {
-        /* Save the scaling factor. */
+        // Save the scaling factor.
         lu[ik] /= lu[k*n+k];
 
-        /* Subtract rows. */
+        // Subtract rows.
         for (j = k+1; j < n; j++) {
           lu[i*n+j] -= lu[ik]*lu[k*n+j];
         }
@@ -1277,14 +1276,14 @@ int matinv(int n, const double mat[], do
   }
 
 
-  /* mxl[i] records which row of mat corresponds to row i of lu.  */
-  /* lxm[i] records which row of lu  corresponds to row i of mat. */
+  // mxl[i] records which row of mat corresponds to row i of lu.
+  // lxm[i] records which row of lu  corresponds to row i of mat.
   for (i = 0; i < n; i++) {
     lxm[mxl[i]] = i;
   }
 
 
-  /* Determine the inverse matrix. */
+  // Determine the inverse matrix.
   for (i = 0, ij = 0; i < n; i++) {
     for (j = 0; j < n; j++, ij++) {
       inv[ij] = 0.0;
@@ -1294,14 +1293,14 @@ int matinv(int n, const double mat[], do
   for (k = 0; k < n; k++) {
     inv[lxm[k]*n+k] = 1.0;
 
-    /* Forward substitution. */
+    // Forward substitution.
     for (i = lxm[k]+1; i < n; i++) {
       for (j = lxm[k]; j < i; j++) {
         inv[i*n+k] -= lu[i*n+j]*inv[j*n+k];
       }
     }
 
-    /* Backward substitution. */
+    // Backward substitution.
     for (i = n-1; i >= 0; i--) {
       for (j = i+1; j < n; j++) {
         inv[i*n+k] -= lu[i*n+j]*inv[j*n+k];
Index: astropy-4.2/cextern/wcslib/C/lin.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/lin.h
+++ astropy-4.2/cextern/wcslib/C/lin.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: lin.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: lin.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -619,44 +616,44 @@ extern "C" {
 extern const char *lin_errmsg[];
 
 enum lin_errmsg_enum {
-  LINERR_SUCCESS      = 0,	/* Success. */
-  LINERR_NULL_POINTER = 1,	/* Null linprm pointer passed. */
-  LINERR_MEMORY       = 2,	/* Memory allocation failed. */
-  LINERR_SINGULAR_MTX = 3,	/* PCi_ja matrix is singular. */
-  LINERR_DISTORT_INIT = 4,	/* Failed to initialise distortions. */
-  LINERR_DISTORT      = 5,	/* Distort error. */
-  LINERR_DEDISTORT    = 6	/* De-distort error. */
+  LINERR_SUCCESS      = 0,	// Success.
+  LINERR_NULL_POINTER = 1,	// Null linprm pointer passed.
+  LINERR_MEMORY       = 2,	// Memory allocation failed.
+  LINERR_SINGULAR_MTX = 3,	// PCi_ja matrix is singular.
+  LINERR_DISTORT_INIT = 4,	// Failed to initialise distortions.
+  LINERR_DISTORT      = 5,	// Distort error.
+  LINERR_DEDISTORT    = 6	// De-distort error.
 };
 
 struct linprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  int naxis;			/* The number of axes, given by NAXIS.      */
-  double *crpix;		/* CRPIXja keywords for each pixel axis.    */
-  double *pc;			/* PCi_ja  linear transformation matrix.    */
-  double *cdelt;		/* CDELTia keywords for each coord axis.    */
-  struct disprm *dispre;	/* Prior   distortion parameters, if any.   */
-  struct disprm *disseq;	/* Sequent distortion parameters, if any.   */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  double *piximg;		/* Product of CDELTia and PCi_ja matrices.  */
-  double *imgpix;		/* Inverse of the piximg matrix.            */
-  int    i_naxis;		/* Dimension of piximg and imgpix.          */
-  int    unity;			/* True if the PCi_ja matrix is unity.      */
-  int    affine;		/* True if there are no distortions.        */
-  int    simple;		/* True if unity and no distortions.        */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  int naxis;			// The number of axes, given by NAXIS.
+  double *crpix;		// CRPIXja keywords for each pixel axis.
+  double *pc;			// PCi_ja  linear transformation matrix.
+  double *cdelt;		// CDELTia keywords for each coord axis.
+  struct disprm *dispre;	// Prior   distortion parameters, if any.
+  struct disprm *disseq;	// Sequent distortion parameters, if any.
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  double *piximg;		// Product of CDELTia and PCi_ja matrices.
+  double *imgpix;		// Inverse of the piximg matrix.
+  int    i_naxis;		// Dimension of piximg and imgpix.
+  int    unity;			// True if the PCi_ja matrix is unity.
+  int    affine;		// True if there are no distortions.
+  int    simple;		// True if unity and no distortions.
 
-  /* Error handling, if enabled.                                            */
-  /*------------------------------------------------------------------------*/
+  // Error handling, if enabled.
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private - the remainder are for internal use.                          */
-  /*------------------------------------------------------------------------*/
+  // Private - the remainder are for internal use.
+  //--------------------------------------------------------------------------
   double *tmpcrd;
 
   int    m_flag, m_naxis;
@@ -664,7 +661,7 @@ struct linprm {
   struct disprm *m_dispre, *m_disseq;
 };
 
-/* Size of the linprm struct in int units, used by the Fortran wrappers. */
+// Size of the linprm struct in int units, used by the Fortran wrappers.
 #define LINLEN (sizeof(struct linprm)/sizeof(int))
 
 
@@ -701,7 +698,7 @@ int linwarp(struct linprm *lin, const do
 int matinv(int n, const double mat[], double inv[]);
 
 
-/* Deprecated. */
+// Deprecated.
 #define linini_errmsg lin_errmsg
 #define lincpy_errmsg lin_errmsg
 #define linfree_errmsg lin_errmsg
@@ -714,4 +711,4 @@ int matinv(int n, const double mat[], do
 }
 #endif
 
-#endif /* WCSLIB_LIN */
+#endif // WCSLIB_LIN
Index: astropy-4.2/cextern/wcslib/C/log.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/log.c
+++ astropy-4.2/cextern/wcslib/C/log.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,18 +17,16 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: log.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: log.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
 
 #include "log.h"
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *log_errmsg[] = {
   "Success",
   "",
@@ -38,7 +35,7 @@ const char *log_errmsg[] = {
   "One or more of the world coordinates were invalid"};
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int logx2s(
   double crval,
@@ -71,7 +68,7 @@ int logx2s(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int logs2x(
   double crval,
Index: astropy-4.2/cextern/wcslib/C/log.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/log.h
+++ astropy-4.2/cextern/wcslib/C/log.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: log.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: log.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -144,13 +141,13 @@ extern "C" {
 extern const char *log_errmsg[];
 
 enum log_errmsg_enum {
-  LOGERR_SUCCESS         = 0,	/* Success. */
-  LOGERR_NULL_POINTER    = 1,	/* Null pointer passed. */
-  LOGERR_BAD_LOG_REF_VAL = 2,	/* Invalid log-coordinate reference value. */
-  LOGERR_BAD_X           = 3,	/* One or more of the x coordinates were
-				   invalid. */
-  LOGERR_BAD_WORLD       = 4 	/* One or more of the world coordinates were
-				   invalid. */
+  LOGERR_SUCCESS         = 0,	// Success.
+  LOGERR_NULL_POINTER    = 1,	// Null pointer passed.
+  LOGERR_BAD_LOG_REF_VAL = 2,	// Invalid log-coordinate reference value.
+  LOGERR_BAD_X           = 3,	// One or more of the x coordinates were
+				// invalid.
+  LOGERR_BAD_WORLD       = 4 	// One or more of the world coordinates were
+				// invalid.
 };
 
 int logx2s(double crval, int nx, int sx, int slogc, const double x[],
@@ -164,4 +161,4 @@ int logs2x(double crval, int nlogc, int
 }
 #endif
 
-#endif /* WCSLIB_LOG */
+#endif // WCSLIB_LOG
Index: astropy-4.2/cextern/wcslib/C/prj.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/prj.c
+++ astropy-4.2/cextern/wcslib/C/prj.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: prj.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: prj.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -38,7 +35,7 @@
 #include "prj.h"
 
 
-/* Projection categories. */
+// Projection categories.
 const int ZENITHAL          = 1;
 const int CYLINDRICAL       = 2;
 const int PSEUDOCYLINDRICAL = 3;
@@ -53,7 +50,7 @@ const char prj_categories[9][32] =
   "conventional", "conic", "polyconic", "quadcube", "HEALPix"};
 
 
-/* Projection codes. */
+// Projection codes.
 const int  prj_ncode = 28;
 const char prj_codes[28][4] =
   {"AZP", "SZP", "TAN", "STG", "SIN", "ARC", "ZPN", "ZEA", "AIR", "CYP",
@@ -90,7 +87,7 @@ const int HPX = 801;
 const int XPH = 802;
 
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *prj_errmsg[] = {
   "Success",
   "Null prjprm pointer passed",
@@ -98,7 +95,7 @@ const char *prj_errmsg[] = {
   "One or more of the (x,y) coordinates were invalid",
   "One or more of the (phi,theta) coordinates were invalid"};
 
-/* Convenience macros for generating common error messages. */
+// Convenience macros for generating common error messages.
 #define PRJERR_BAD_PARAM_SET(function) \
   wcserr_set(&(prj->err), PRJERR_BAD_PARAM, function, __FILE__, __LINE__, \
     "Invalid parameters for %s projection", prj->name);
@@ -184,7 +181,7 @@ int prjini(struct prjprm *prj)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjfree(struct prjprm *prj)
 
@@ -196,7 +193,7 @@ int prjfree(struct prjprm *prj)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjprt(const struct prjprm *prj)
 
@@ -284,7 +281,7 @@ int prjprt(const struct prjprm *prj)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjperr(const struct prjprm *prj, const char *prefix)
 
@@ -298,7 +295,7 @@ int prjperr(const struct prjprm *prj, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjbchk(
   double tol,
@@ -319,7 +316,7 @@ int prjbchk(
   statp  = stat;
   for (itheta = 0; itheta < ntheta; itheta++) {
     for (iphi = 0; iphi < nphi; iphi++, phip += spt, thetap += spt, statp++) {
-      /* Skip values already marked as illegal. */
+      // Skip values already marked as illegal.
       if (*statp == 0) {
         if (*phip < -180.0) {
           if (*phip < -180.0-tol) {
@@ -359,7 +356,7 @@ int prjbchk(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjset(struct prjprm *prj)
 
@@ -372,7 +369,7 @@ int prjset(struct prjprm *prj)
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   err = &(prj->err);
 
-  /* Invoke the relevant initialization routine. */
+  // Invoke the relevant initialization routine.
   prj->code[3] = '\0';
   if (strcmp(prj->code, "AZP") == 0) {
     status = azpset(prj);
@@ -431,7 +428,7 @@ int prjset(struct prjprm *prj)
   } else if (strcmp(prj->code, "XPH") == 0) {
     status = xphset(prj);
   } else {
-    /* Unrecognized projection code. */
+    // Unrecognized projection code.
     status = wcserr_set(WCSERR_SET(PRJERR_BAD_PARAM),
                "Unrecognized projection code '%s'", prj->code);
   }
@@ -439,7 +436,7 @@ int prjset(struct prjprm *prj)
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjx2s(
   struct prjprm *prj,
@@ -456,7 +453,7 @@ int prjx2s(
 {
   int status;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag == 0) {
     if ((status = prjset(prj))) return status;
@@ -465,7 +462,7 @@ int prjx2s(
   return prj->prjx2s(prj, nx, ny, sxy, spt, x, y, phi, theta, stat);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int prjs2x(
   struct prjprm *prj,
@@ -482,7 +479,7 @@ int prjs2x(
 {
   int status;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag == 0) {
     if ((status = prjset(prj))) return status;
@@ -511,7 +508,7 @@ int prjoff(
   prj->y0 = 0.0;
 
   if (undefined(prj->phi0) || undefined(prj->theta0)) {
-    /* Set both to the projection-specific default if either undefined. */
+    // Set both to the projection-specific default if either undefined.
     prj->phi0   = phi0;
     prj->theta0 = theta0;
 
@@ -607,7 +604,7 @@ int azpset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int azpx2s(
   struct prjprm *prj,
@@ -630,7 +627,7 @@ int azpx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AZP) {
     if ((status = azpset(prj))) return status;
@@ -648,7 +645,7 @@ int azpx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -663,7 +660,7 @@ int azpx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -718,7 +715,7 @@ int azpx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("azpx2s");
   }
@@ -726,7 +723,7 @@ int azpx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int azps2x(
   struct prjprm *prj,
@@ -748,7 +745,7 @@ int azps2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AZP) {
     if ((status = azpset(prj))) return status;
@@ -766,7 +763,7 @@ int azps2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -784,7 +781,7 @@ int azps2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -805,16 +802,16 @@ int azps2x(
       } else {
         r = prj->w[0]*costhe/t;
 
-        /* Bounds checking. */
+        // Bounds checking.
         istat = 0;
         if (prj->bounds&1) {
           if (*thetap < prj->w[5]) {
-            /* Overlap. */
+            // Overlap.
             istat = 1;
             if (!status) status = PRJERR_BAD_WORLD_SET("azps2x");
 
           } else if (prj->w[7] > 0.0) {
-            /* Divergence. */
+            // Divergence.
             t = prj->pv[1] / sqrt(1.0 + s*s);
 
             if (fabs(t) <= 1.0) {
@@ -926,7 +923,7 @@ int szpset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int szpx2s(
   struct prjprm *prj,
@@ -949,7 +946,7 @@ int szpx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SZP) {
     if ((status = szpset(prj))) return status;
@@ -967,7 +964,7 @@ int szpx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -982,7 +979,7 @@ int szpx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -999,7 +996,7 @@ int szpx2s(
       xy = xr*x1 + yr*y1;
 
       if (r2 < 1.0e-10) {
-        /* Use small angle formula. */
+        // Use small angle formula.
         z = r2/2.0;
         *thetap = 90.0 - R2D*sqrt(r2/(1.0 + xy));
 
@@ -1010,7 +1007,7 @@ int szpx2s(
         c = r2 - xy - xy + t - 1.0;
         d = b*b - a*c;
 
-        /* Check for a solution. */
+        // Check for a solution.
         if (d < 0.0) {
           *phip = 0.0;
           *thetap = 0.0;
@@ -1020,7 +1017,7 @@ int szpx2s(
         }
         d = sqrt(d);
 
-        /* Choose solution closest to pole. */
+        // Choose solution closest to pole.
         sinth1 = (-b + d)/a;
         sinth2 = (-b - d)/a;
         sinthe = (sinth1 > sinth2) ? sinth1 : sinth2;
@@ -1057,7 +1054,7 @@ int szpx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("szpx2s");
   }
@@ -1065,7 +1062,7 @@ int szpx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int szps2x(
   struct prjprm *prj,
@@ -1087,7 +1084,7 @@ int szps2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SZP) {
     if ((status = szpset(prj))) return status;
@@ -1105,7 +1102,7 @@ int szps2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -1123,7 +1120,7 @@ int szps2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -1147,16 +1144,16 @@ int szps2x(
       v = prj->w[5]*s/t + prj->y0;
 
       for (iphi = 0; iphi < mphi; iphi++, xp += sxy, yp += sxy) {
-        /* Bounds checking. */
+        // Bounds checking.
         istat = 0;
         if (prj->bounds&1) {
           if (*thetap < prj->w[8]) {
-            /* Divergence. */
+            // Divergence.
             istat = 1;
             if (!status) status = PRJERR_BAD_WORLD_SET("szps2x");
 
           } else if (fabs(prj->pv[1]) > 1.0) {
-            /* Overlap. */
+            // Overlap.
             s = prj->w[1]*(*xp) - prj->w[2]*(*yp);
             t = 1.0/sqrt(prj->w[7] + s*s);
 
@@ -1230,7 +1227,7 @@ int tanset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tanx2s(
   struct prjprm *prj,
@@ -1252,7 +1249,7 @@ int tanx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != TAN) {
     if ((status = tanset(prj))) return status;
@@ -1270,7 +1267,7 @@ int tanx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -1285,7 +1282,7 @@ int tanx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -1310,7 +1307,7 @@ int tanx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("tanx2s");
   }
@@ -1318,7 +1315,7 @@ int tanx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tans2x(
   struct prjprm *prj,
@@ -1340,7 +1337,7 @@ int tans2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != TAN) {
     if ((status = tanset(prj))) return status;
@@ -1358,7 +1355,7 @@ int tans2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -1376,7 +1373,7 @@ int tans2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -1394,7 +1391,7 @@ int tans2x(
     } else {
       r =  prj->r0*cosd(*thetap)/s;
 
-      /* Bounds checking. */
+      // Bounds checking.
       istat = 0;
       if (prj->bounds&1) {
         if (s < 0.0) {
@@ -1465,7 +1462,7 @@ int stgset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int stgx2s(
   struct prjprm *prj,
@@ -1487,7 +1484,7 @@ int stgx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != STG) {
     if ((status = stgset(prj))) return status;
@@ -1503,7 +1500,7 @@ int stgx2s(
   }
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -1518,7 +1515,7 @@ int stgx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -1545,7 +1542,7 @@ int stgx2s(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int stgs2x(
   struct prjprm *prj,
@@ -1567,7 +1564,7 @@ int stgs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != STG) {
     if ((status = stgset(prj))) return status;
@@ -1585,7 +1582,7 @@ int stgs2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -1603,7 +1600,7 @@ int stgs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -1688,7 +1685,7 @@ int sinset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sinx2s(
   struct prjprm *prj,
@@ -1712,7 +1709,7 @@ int sinx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SIN) {
     if ((status = sinset(prj))) return status;
@@ -1733,7 +1730,7 @@ int sinx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -1748,7 +1745,7 @@ int sinx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -1758,12 +1755,12 @@ int sinx2s(
     y02 = y0*y0;
 
     for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
-      /* Compute intermediaries. */
+      // Compute intermediaries.
       x0 = *phip;
       r2 = x0*x0 + y02;
 
       if (prj->w[1] == 0.0) {
-        /* Orthographic projection. */
+        // Orthographic projection.
         if (r2 != 0.0) {
           *phip = atan2d(x0, -y0);
         } else {
@@ -1781,11 +1778,11 @@ int sinx2s(
         }
 
       } else {
-        /* "Synthesis" projection. */
+        // "Synthesis" projection.
         xy = x0*xi + y0*eta;
 
         if (r2 < 1.0e-10) {
-          /* Use small angle formula. */
+          // Use small angle formula.
           z = r2/2.0;
           *thetap = 90.0 - R2D*sqrt(r2/(1.0 + xy));
 
@@ -1795,7 +1792,7 @@ int sinx2s(
           c = r2 - xy - xy + prj->w[3];
           d = b*b - a*c;
 
-          /* Check for a solution. */
+          // Check for a solution.
           if (d < 0.0) {
             *phip = 0.0;
             *thetap = 0.0;
@@ -1805,7 +1802,7 @@ int sinx2s(
           }
           d = sqrt(d);
 
-          /* Choose solution closest to pole. */
+          // Choose solution closest to pole.
           sinth1 = (-b + d)/a;
           sinth2 = (-b - d)/a;
           sinthe = (sinth1 > sinth2) ? sinth1 : sinth2;
@@ -1849,7 +1846,7 @@ int sinx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("sinx2s");
   }
@@ -1857,7 +1854,7 @@ int sinx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sins2x(
   struct prjprm *prj,
@@ -1879,7 +1876,7 @@ int sins2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SIN) {
     if ((status = sinset(prj))) return status;
@@ -1897,7 +1894,7 @@ int sins2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -1915,7 +1912,7 @@ int sins2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -1936,7 +1933,7 @@ int sins2x(
     r = prj->r0*costhe;
 
     if (prj->w[1] == 0.0) {
-      /* Orthographic projection. */
+      // Orthographic projection.
       istat = 0;
       if (prj->bounds&1) {
         if (*thetap < 0.0) {
@@ -1952,7 +1949,7 @@ int sins2x(
       }
 
     } else {
-      /* "Synthesis" projection. */
+      // "Synthesis" projection.
       z *= prj->r0;
       z1 = prj->pv[1]*z - prj->x0;
       z2 = prj->pv[2]*z - prj->y0;
@@ -2028,7 +2025,7 @@ int arcset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int arcx2s(
   struct prjprm *prj,
@@ -2050,7 +2047,7 @@ int arcx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ARC) {
     if ((status = arcset(prj))) return status;
@@ -2068,7 +2065,7 @@ int arcx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -2083,7 +2080,7 @@ int arcx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -2109,7 +2106,7 @@ int arcx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("arcx2s");
   }
@@ -2117,7 +2114,7 @@ int arcx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int arcs2x(
   struct prjprm *prj,
@@ -2139,7 +2136,7 @@ int arcs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ARC) {
     if ((status = arcset(prj))) return status;
@@ -2155,7 +2152,7 @@ int arcs2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -2173,7 +2170,7 @@ int arcs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -2240,7 +2237,7 @@ int zpnset(struct prjprm *prj)
   prj->global    = 0;
   prj->divergent = 0;
 
-  /* Find the highest non-zero coefficient. */
+  // Find the highest non-zero coefficient.
   for (k = PVN-1; k >= 0 && prj->pv[k] == 0.0; k--);
   if (k < 0) {
     return PRJERR_BAD_PARAM_SET("zpnset");
@@ -2249,18 +2246,18 @@ int zpnset(struct prjprm *prj)
   prj->n = k;
 
   if (k < 2) {
-    /* No point of inflection. */
+    // No point of inflection.
     prj->w[0] = PI;
 
   } else {
-    /* Find the point of inflection closest to the pole. */
+    // Find the point of inflection closest to the pole.
     zd1 = 0.0;
     d1  = prj->pv[1];
     if (d1 <= 0.0) {
       return PRJERR_BAD_PARAM_SET("zpnset");
     }
 
-    /* Find the point where the derivative first goes negative. */
+    // Find the point where the derivative first goes negative.
     for (j = 0; j < 180; j++) {
       zd2 = j*D2R;
       d2  = 0.0;
@@ -2274,11 +2271,11 @@ int zpnset(struct prjprm *prj)
     }
 
     if (j == 180) {
-      /* No negative derivative -> no point of inflection. */
+      // No negative derivative -> no point of inflection.
       zd = PI;
       prj->global = 1;
     } else {
-      /* Find where the derivative is zero. */
+      // Find where the derivative is zero.
       for (j = 1; j <= 10; j++) {
         zd = zd1 - d1*(zd2-zd1)/(d2-d1);
 
@@ -2313,7 +2310,7 @@ int zpnset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int zpnx2s(
   struct prjprm *prj,
@@ -2336,7 +2333,7 @@ int zpnx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ZPN) {
     if ((status = zpnset(prj))) return status;
@@ -2356,7 +2353,7 @@ int zpnx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -2371,7 +2368,7 @@ int zpnx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -2391,15 +2388,15 @@ int zpnx2s(
       }
 
       if (k < 1) {
-        /* Constant - no solution. */
+        // Constant - no solution.
         return PRJERR_BAD_PARAM_SET("zpnx2s");
 
       } else if (k == 1) {
-        /* Linear. */
+        // Linear.
         zd = (r - prj->pv[0])/prj->pv[1];
 
       } else if (k == 2) {
-        /* Quadratic. */
+        // Quadratic.
         a = prj->pv[2];
         b = prj->pv[1];
         c = prj->pv[0] - r;
@@ -2413,7 +2410,7 @@ int zpnx2s(
         }
         d = sqrt(d);
 
-        /* Choose solution closest to pole. */
+        // Choose solution closest to pole.
         zd1 = (-b + d)/(2.0*a);
         zd2 = (-b - d)/(2.0*a);
         zd  = (zd1<zd2) ? zd1 : zd2;
@@ -2436,7 +2433,7 @@ int zpnx2s(
           zd = PI;
         }
       } else {
-        /* Higher order - solve iteratively. */
+        // Higher order - solve iteratively.
         zd1 = 0.0;
         r1  = prj->pv[0];
         zd2 = prj->w[0];
@@ -2459,7 +2456,7 @@ int zpnx2s(
           }
           zd = zd2;
         } else {
-          /* Dissect the interval. */
+          // Dissect the interval.
           for (j = 0; j < 100; j++) {
             lambda = (r2 - r)/(r2 - r1);
             if (lambda < 0.1) {
@@ -2496,7 +2493,7 @@ int zpnx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("zpnx2s");
   }
@@ -2504,7 +2501,7 @@ int zpnx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int zpns2x(
   struct prjprm *prj,
@@ -2526,7 +2523,7 @@ int zpns2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ZPN) {
     if ((status = zpnset(prj))) return status;
@@ -2544,7 +2541,7 @@ int zpns2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -2562,7 +2559,7 @@ int zpns2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -2576,7 +2573,7 @@ int zpns2x(
     }
     r *= prj->r0;
 
-    /* Bounds checking. */
+    // Bounds checking.
     istat = 0;
     if (prj->bounds&1) {
       if (s > prj->w[0]) {
@@ -2646,7 +2643,7 @@ int zeaset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int zeax2s(
   struct prjprm *prj,
@@ -2669,7 +2666,7 @@ int zeax2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ZEA) {
     if ((status = zeaset(prj))) return status;
@@ -2687,7 +2684,7 @@ int zeax2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -2702,7 +2699,7 @@ int zeax2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -2740,7 +2737,7 @@ int zeax2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("zeax2s");
   }
@@ -2748,7 +2745,7 @@ int zeax2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int zeas2x(
   struct prjprm *prj,
@@ -2770,7 +2767,7 @@ int zeas2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != ZEA) {
     if ((status = zeaset(prj))) return status;
@@ -2786,7 +2783,7 @@ int zeas2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -2804,7 +2801,7 @@ int zeas2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -2897,7 +2894,7 @@ int airset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int airx2s(
   struct prjprm *prj,
@@ -2920,7 +2917,7 @@ int airx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AIR) {
     if ((status = airset(prj))) return status;
@@ -2938,7 +2935,7 @@ int airx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -2953,7 +2950,7 @@ int airx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -2978,7 +2975,7 @@ int airx2s(
       } else if (r < prj->w[5]) {
         xi = r*prj->w[6];
       } else {
-        /* Find a solution interval. */
+        // Find a solution interval.
         x1 = x2 = 1.0;
         r1 = r2 = 0.0;
         for (k = 0; k < 30; k++) {
@@ -2998,7 +2995,7 @@ int airx2s(
         }
 
         for (k = 0; k < 100; k++) {
-          /* Weighted division of the interval. */
+          // Weighted division of the interval.
           lambda = (r2-r)/(r2-r1);
           if (lambda < 0.1) {
             lambda = 0.1;
@@ -3036,7 +3033,7 @@ int airx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("airx2s");
   }
@@ -3044,7 +3041,7 @@ int airx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int airs2x(
   struct prjprm *prj,
@@ -3066,7 +3063,7 @@ int airs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AIR) {
     if ((status = airset(prj))) return status;
@@ -3084,7 +3081,7 @@ int airs2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -3102,7 +3099,7 @@ int airs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -3222,7 +3219,7 @@ int cypset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cypx2s(
   struct prjprm *prj,
@@ -3244,7 +3241,7 @@ int cypx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CYP) {
     if ((status = cypset(prj))) return status;
@@ -3262,7 +3259,7 @@ int cypx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -3277,7 +3274,7 @@ int cypx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   thetap = theta;
   statp = stat;
@@ -3292,7 +3289,7 @@ int cypx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("cypx2s");
   }
@@ -3300,7 +3297,7 @@ int cypx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cyps2x(
   struct prjprm *prj,
@@ -3322,7 +3319,7 @@ int cyps2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CYP) {
     if ((status = cypset(prj))) return status;
@@ -3340,7 +3337,7 @@ int cyps2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -3355,7 +3352,7 @@ int cyps2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   yp = y;
   statp = stat;
@@ -3450,7 +3447,7 @@ int ceaset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int ceax2s(
   struct prjprm *prj,
@@ -3473,7 +3470,7 @@ int ceax2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CEA) {
     if ((status = ceaset(prj))) return status;
@@ -3491,7 +3488,7 @@ int ceax2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -3506,7 +3503,7 @@ int ceax2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   thetap = theta;
   statp = stat;
@@ -3533,7 +3530,7 @@ int ceax2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("ceax2s");
   }
@@ -3541,7 +3538,7 @@ int ceax2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int ceas2x(
   struct prjprm *prj,
@@ -3563,7 +3560,7 @@ int ceas2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CEA) {
     if ((status = ceaset(prj))) return status;
@@ -3579,7 +3576,7 @@ int ceas2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -3594,7 +3591,7 @@ int ceas2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   yp = y;
   statp = stat;
@@ -3661,7 +3658,7 @@ int carset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int carx2s(
   struct prjprm *prj,
@@ -3683,7 +3680,7 @@ int carx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CAR) {
     if ((status = carset(prj))) return status;
@@ -3701,7 +3698,7 @@ int carx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -3716,7 +3713,7 @@ int carx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   thetap = theta;
   statp = stat;
@@ -3730,7 +3727,7 @@ int carx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("carx2s");
   }
@@ -3738,7 +3735,7 @@ int carx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cars2x(
   struct prjprm *prj,
@@ -3760,7 +3757,7 @@ int cars2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CAR) {
     if ((status = carset(prj))) return status;
@@ -3776,7 +3773,7 @@ int cars2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -3791,7 +3788,7 @@ int cars2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   yp = y;
   statp = stat;
@@ -3858,7 +3855,7 @@ int merset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int merx2s(
   struct prjprm *prj,
@@ -3880,7 +3877,7 @@ int merx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != MER) {
     if ((status = merset(prj))) return status;
@@ -3898,7 +3895,7 @@ int merx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -3913,7 +3910,7 @@ int merx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   thetap = theta;
   statp  = stat;
@@ -3927,7 +3924,7 @@ int merx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("merx2s");
   }
@@ -3935,7 +3932,7 @@ int merx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int mers2x(
   struct prjprm *prj,
@@ -3957,7 +3954,7 @@ int mers2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != MER) {
     if ((status = merset(prj))) return status;
@@ -3975,7 +3972,7 @@ int mers2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -3990,7 +3987,7 @@ int mers2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   yp = y;
   statp = stat;
@@ -4065,7 +4062,7 @@ int sflset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sflx2s(
   struct prjprm *prj,
@@ -4087,7 +4084,7 @@ int sflx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SFL) {
     if ((status = sflset(prj))) return status;
@@ -4105,7 +4102,7 @@ int sflx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -4120,7 +4117,7 @@ int sflx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -4147,7 +4144,7 @@ int sflx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-12, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("sflx2s");
   }
@@ -4155,7 +4152,7 @@ int sflx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sfls2x(
   struct prjprm *prj,
@@ -4177,7 +4174,7 @@ int sfls2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != SFL) {
     if ((status = sflset(prj))) return status;
@@ -4193,7 +4190,7 @@ int sfls2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -4208,7 +4205,7 @@ int sfls2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -4284,7 +4281,7 @@ int parset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int parx2s(
   struct prjprm *prj,
@@ -4307,7 +4304,7 @@ int parx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != PAR) {
     if ((status = parset(prj))) return status;
@@ -4325,7 +4322,7 @@ int parx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -4345,7 +4342,7 @@ int parx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -4363,7 +4360,7 @@ int parx2s(
     } else {
       s = 1.0 - 4.0*r*r;
       if (s == 0.0) {
-        /* Deferred test. */
+        // Deferred test.
         istat = -1;
       } else {
         s = 1.0/s;
@@ -4390,7 +4387,7 @@ int parx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-12, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("parx2s");
   }
@@ -4398,7 +4395,7 @@ int parx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int pars2x(
   struct prjprm *prj,
@@ -4420,7 +4417,7 @@ int pars2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != PAR) {
     if ((status = parset(prj))) return status;
@@ -4436,7 +4433,7 @@ int pars2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -4451,7 +4448,7 @@ int pars2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -4523,7 +4520,7 @@ int molset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int molx2s(
   struct prjprm *prj,
@@ -4546,7 +4543,7 @@ int molx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != MOL) {
     if ((status = molset(prj))) return status;
@@ -4564,7 +4561,7 @@ int molx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -4584,7 +4581,7 @@ int molx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -4600,7 +4597,7 @@ int molx2s(
         istat = 1;
         if (!status) status = PRJERR_BAD_PIX_SET("molx2s");
       } else {
-        /* OK if fabs(x) < tol whence phi = 0.0. */
+        // OK if fabs(x) < tol whence phi = 0.0.
         istat = -1;
       }
 
@@ -4655,7 +4652,7 @@ int molx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-11, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("molx2s");
   }
@@ -4663,7 +4660,7 @@ int molx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int mols2x(
   struct prjprm *prj,
@@ -4686,7 +4683,7 @@ int mols2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != MOL) {
     if ((status = molset(prj))) return status;
@@ -4702,7 +4699,7 @@ int mols2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -4717,7 +4714,7 @@ int mols2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -4815,7 +4812,7 @@ int aitset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int aitx2s(
   struct prjprm *prj,
@@ -4838,7 +4835,7 @@ int aitx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AIT) {
     if ((status = aitset(prj))) return status;
@@ -4856,7 +4853,7 @@ int aitx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -4876,7 +4873,7 @@ int aitx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -4925,7 +4922,7 @@ int aitx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("aitx2s");
   }
@@ -4933,7 +4930,7 @@ int aitx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int aits2x(
   struct prjprm *prj,
@@ -4955,7 +4952,7 @@ int aits2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != AIT) {
     if ((status = aitset(prj))) return status;
@@ -4971,7 +4968,7 @@ int aits2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -4990,7 +4987,7 @@ int aits2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -5083,7 +5080,7 @@ int copset(struct prjprm *prj)
   return prjoff(prj, 0.0, prj->pv[1]);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int copx2s(
   struct prjprm *prj,
@@ -5104,7 +5101,7 @@ int copx2s(
   register const double *xp, *yp;
   register double *phip, *thetap;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COP) {
     if ((status = copset(prj))) return status;
@@ -5122,7 +5119,7 @@ int copx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -5137,7 +5134,7 @@ int copx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -5165,7 +5162,7 @@ int copx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("copx2s");
   }
@@ -5173,7 +5170,7 @@ int copx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cops2x(
   struct prjprm *prj,
@@ -5194,7 +5191,7 @@ int cops2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COP) {
     if ((status = copset(prj))) return status;
@@ -5212,7 +5209,7 @@ int cops2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -5231,7 +5228,7 @@ int cops2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -5243,16 +5240,16 @@ int cops2x(
 
     istat = 0;
     if (s == 0.0) {
-      /* Latitude of divergence. */
+      // Latitude of divergence.
       r = 0.0;
       istat = 1;
       if (!status) status = PRJERR_BAD_WORLD_SET("cops2x");
 
     } else if (fabs(*thetap) == 90.0) {
-      /* Return an exact value at the poles. */
+      // Return an exact value at the poles.
       r = 0.0;
 
-      /* Bounds checking. */
+      // Bounds checking.
       if (prj->bounds&1) {
         if ((*thetap < 0.0) != (prj->pv[1] < 0.0)) {
           istat = 1;
@@ -5263,7 +5260,7 @@ int cops2x(
     } else {
       r = prj->w[2] - prj->w[3]*sind(t)/s;
 
-      /* Bounds checking. */
+      // Bounds checking.
       if (prj->bounds&1) {
         if (r*prj->w[0] < 0.0) {
           istat = 1;
@@ -5363,7 +5360,7 @@ int coeset(struct prjprm *prj)
   return prjoff(prj, 0.0, prj->pv[1]);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int coex2s(
   struct prjprm *prj,
@@ -5385,7 +5382,7 @@ int coex2s(
   register const double *xp, *yp;
   register double *phip, *thetap;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COE) {
     if ((status = coeset(prj))) return status;
@@ -5403,7 +5400,7 @@ int coex2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -5418,7 +5415,7 @@ int coex2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -5466,7 +5463,7 @@ int coex2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("coex2s");
   }
@@ -5474,7 +5471,7 @@ int coex2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int coes2x(
   struct prjprm *prj,
@@ -5495,7 +5492,7 @@ int coes2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COE) {
     if ((status = coeset(prj))) return status;
@@ -5511,7 +5508,7 @@ int coes2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -5530,7 +5527,7 @@ int coes2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -5622,7 +5619,7 @@ int codset(struct prjprm *prj)
   return prjoff(prj, 0.0, prj->pv[1]);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int codx2s(
   struct prjprm *prj,
@@ -5643,7 +5640,7 @@ int codx2s(
   register const double *xp, *yp;
   register double *phip, *thetap;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COD) {
     if ((status = codset(prj))) return status;
@@ -5661,7 +5658,7 @@ int codx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -5676,7 +5673,7 @@ int codx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -5704,7 +5701,7 @@ int codx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("codx2s");
   }
@@ -5712,7 +5709,7 @@ int codx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cods2x(
   struct prjprm *prj,
@@ -5733,7 +5730,7 @@ int cods2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COD) {
     if ((status = codset(prj))) return status;
@@ -5749,7 +5746,7 @@ int cods2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -5768,7 +5765,7 @@ int cods2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -5873,7 +5870,7 @@ int cooset(struct prjprm *prj)
   return prjoff(prj, 0.0, prj->pv[1]);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int coox2s(
   struct prjprm *prj,
@@ -5894,7 +5891,7 @@ int coox2s(
   register const double *xp, *yp;
   register double *phip, *thetap;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COO) {
     if ((status = cooset(prj))) return status;
@@ -5912,7 +5909,7 @@ int coox2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -5927,7 +5924,7 @@ int coox2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -5968,7 +5965,7 @@ int coox2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("coox2s");
   }
@@ -5976,7 +5973,7 @@ int coox2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int coos2x(
   struct prjprm *prj,
@@ -5997,7 +5994,7 @@ int coos2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != COO) {
     if ((status = cooset(prj))) return status;
@@ -6015,7 +6012,7 @@ int coos2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -6034,7 +6031,7 @@ int coos2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -6099,7 +6096,7 @@ int bonset(struct prjprm *prj)
   }
 
   if (prj->pv[1] == 0.0) {
-    /* Sanson-Flamsteed. */
+    // Sanson-Flamsteed.
     return sflset(prj);
   }
 
@@ -6126,7 +6123,7 @@ int bonset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int bonx2s(
   struct prjprm *prj,
@@ -6148,10 +6145,10 @@ int bonx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->pv[1] == 0.0) {
-    /* Sanson-Flamsteed. */
+    // Sanson-Flamsteed.
     return sflx2s(prj, nx, ny, sxy, spt, x, y, phi, theta, stat);
   }
 
@@ -6171,7 +6168,7 @@ int bonx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -6186,7 +6183,7 @@ int bonx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -6222,7 +6219,7 @@ int bonx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-11, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("bonx2s");
   }
@@ -6230,7 +6227,7 @@ int bonx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int bons2x(
   struct prjprm *prj,
@@ -6251,10 +6248,10 @@ int bons2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->pv[1] == 0.0) {
-    /* Sanson-Flamsteed. */
+    // Sanson-Flamsteed.
     return sfls2x(prj, nphi, ntheta, spt, sxy, phi, theta, x, y, stat);
   }
 
@@ -6274,7 +6271,7 @@ int bons2x(
   y0 = prj->y0 - prj->w[2];
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -6289,7 +6286,7 @@ int bons2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -6366,7 +6363,7 @@ int pcoset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int pcox2s(
   struct prjprm *prj,
@@ -6390,7 +6387,7 @@ int pcox2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != PCO) {
     if ((status = pcoset(prj))) return status;
@@ -6408,7 +6405,7 @@ int pcox2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -6423,7 +6420,7 @@ int pcox2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -6445,23 +6442,23 @@ int pcox2s(
 
       } else {
         if (w < 1.0e-4) {
-          /* To avoid cot(theta) blowing up near theta == 0. */
+          // To avoid cot(theta) blowing up near theta == 0.
           the    = yj / (prj->w[0] + prj->w[3]*xj*xj);
           ymthe  = yj - prj->w[0]*the;
           tanthe = tand(the);
 
         } else {
-          /* Iterative solution using weighted division of the interval. */
+          // Iterative solution using weighted division of the interval.
           thepos = yj / prj->w[0];
           theneg = 0.0;
 
-          /* Setting fneg = -fpos halves the interval in the first iter. */
+          // Setting fneg = -fpos halves the interval in the first iter.
           xx = xj*xj;
           fpos  =  xx;
           fneg  = -xx;
 
           for (k = 0; k < 64; k++) {
-            /* Weighted division of the interval. */
+            // Weighted division of the interval.
             lambda = fpos/(fpos-fneg);
             if (lambda < 0.1) {
               lambda = 0.1;
@@ -6470,16 +6467,16 @@ int pcox2s(
             }
             the = thepos - lambda*(thepos-theneg);
 
-            /* Compute the residue. */
+            // Compute the residue.
             ymthe  = yj - prj->w[0]*the;
             tanthe = tand(the);
             f = xx + ymthe*(ymthe - prj->w[2]/tanthe);
 
-            /* Check for convergence. */
+            // Check for convergence.
             if (fabs(f) < tol) break;
             if (fabs(thepos-theneg) < tol) break;
 
-            /* Redefine the interval. */
+            // Redefine the interval.
             if (f > 0.0) {
               thepos = the;
               fpos = f;
@@ -6506,7 +6503,7 @@ int pcox2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-12, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("pcox2s");
   }
@@ -6514,7 +6511,7 @@ int pcox2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int pcos2x(
   struct prjprm *prj,
@@ -6535,7 +6532,7 @@ int pcos2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != PCO) {
     if ((status = pcoset(prj))) return status;
@@ -6551,7 +6548,7 @@ int pcos2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -6564,7 +6561,7 @@ int pcos2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -6578,7 +6575,7 @@ int pcos2x(
       }
 
     } else if (fabs(*thetap) < 1.0e-4) {
-      /* To avoid cot(theta) blowing up near theta == 0. */
+      // To avoid cot(theta) blowing up near theta == 0.
       for (iphi = 0; iphi < mphi; iphi++, xp += sxy, yp += sxy) {
         *xp = prj->w[0]*(*xp)*cosd(*thetap) - prj->x0;
         *yp = (prj->w[0] + prj->w[3]*(*xp)*(*xp))*(*thetap) - prj->y0;
@@ -6653,7 +6650,7 @@ int tscset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tscx2s(
   struct prjprm *prj,
@@ -6675,7 +6672,7 @@ int tscx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != TSC) {
     if ((status = tscset(prj))) return status;
@@ -6693,7 +6690,7 @@ int tscx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -6708,7 +6705,7 @@ int tscx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -6719,7 +6716,7 @@ int tscx2s(
     for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
       xf = *phip;
 
-      /* Bounds checking. */
+      // Bounds checking.
       if (fabs(xf) <= 1.0) {
         if (fabs(yf) > 3.0) {
           *phip = 0.0;
@@ -6738,42 +6735,42 @@ int tscx2s(
         }
       }
 
-      /* Map negative faces to the other side. */
+      // Map negative faces to the other side.
       if (xf < -1.0) xf += 8.0;
 
-      /* Determine the face. */
+      // Determine the face.
       if (xf > 5.0) {
-        /* face = 4 */
+        // face = 4
         xf = xf - 6.0;
         m  = -1.0/sqrt(1.0 + xf*xf + yf*yf);
         l  = -m*xf;
         n  = -m*yf;
       } else if (xf > 3.0) {
-        /* face = 3 */
+        // face = 3
         xf = xf - 4.0;
         l  = -1.0/sqrt(1.0 + xf*xf + yf*yf);
         m  =  l*xf;
         n  = -l*yf;
       } else if (xf > 1.0) {
-        /* face = 2 */
+        // face = 2
         xf = xf - 2.0;
         m  =  1.0/sqrt(1.0 + xf*xf + yf*yf);
         l  = -m*xf;
         n  =  m*yf;
       } else if (yf > 1.0) {
-        /* face = 0 */
+        // face = 0
         yf = yf - 2.0;
         n  = 1.0/sqrt(1.0 + xf*xf + yf*yf);
         l  = -n*yf;
         m  =  n*xf;
       } else if (yf < -1.0) {
-        /* face = 5 */
+        // face = 5
         yf = yf + 2.0;
         n  = -1.0/sqrt(1.0 + xf*xf + yf*yf);
         l  = -n*yf;
         m  = -n*xf;
       } else {
-        /* face = 1 */
+        // face = 1
         l  =  1.0/sqrt(1.0 + xf*xf + yf*yf);
         m  =  l*xf;
         n  =  l*yf;
@@ -6791,7 +6788,7 @@ int tscx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("tscx2s");
   }
@@ -6799,7 +6796,7 @@ int tscx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tscs2x(
   struct prjprm *prj,
@@ -6821,7 +6818,7 @@ int tscs2x(
   register const double *phip, *thetap;
   register double *xp, *yp;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != TSC) {
     if ((status = tscset(prj))) return status;
@@ -6839,7 +6836,7 @@ int tscs2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -6857,7 +6854,7 @@ int tscs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -6925,7 +6922,7 @@ int tscs2x(
         y0 = -2.0;
         break;
       default:
-        /* face == 0 */
+        // face == 0
         xf =  m/zeta;
         yf = -l/zeta;
         x0 =  0.0;
@@ -7009,7 +7006,7 @@ int cscset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cscx2s(
   struct prjprm *prj,
@@ -7060,7 +7057,7 @@ int cscx2s(
   const float p15 =  0.52032238f;
   const float p06 =  0.14381585f;
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CSC) {
     if ((status = cscset(prj))) return status;
@@ -7078,7 +7075,7 @@ int cscx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -7093,7 +7090,7 @@ int cscx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -7104,7 +7101,7 @@ int cscx2s(
     for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
       xf = (float)(*phip);
 
-      /* Bounds checking. */
+      // Bounds checking.
       if (fabs((double)xf) <= 1.0) {
         if (fabs((double)yf) > 3.0) {
           *phip = 0.0;
@@ -7123,10 +7120,10 @@ int cscx2s(
         }
       }
 
-      /* Map negative faces to the other side. */
+      // Map negative faces to the other side.
       if (xf < -1.0f) xf += 8.0f;
 
-      /* Determine the face. */
+      // Determine the face.
       if (xf > 5.0f) {
         face = 4;
         xf = xf - 6.0f;
@@ -7201,7 +7198,7 @@ int cscx2s(
         m = -chi*n;
         break;
       default:
-        /* face == 0 */
+        // face == 0
         n =  t;
         l = -psi*n;
         m =  chi*n;
@@ -7220,7 +7217,7 @@ int cscx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("cscx2s");
   }
@@ -7228,7 +7225,7 @@ int cscx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cscs2x(
   struct prjprm *prj,
@@ -7266,7 +7263,7 @@ int cscs2x(
   const float c02 =  0.106959469314f;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != CSC) {
     if ((status = cscset(prj))) return status;
@@ -7284,7 +7281,7 @@ int cscs2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -7302,7 +7299,7 @@ int cscs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -7370,7 +7367,7 @@ int cscs2x(
         y0  = -2.0;
         break;
       default:
-        /* face == 0 */
+        // face == 0
         xi  =  m;
         eta = -l;
         x0  =  0.0;
@@ -7386,7 +7383,7 @@ int cscs2x(
       chi2co = 1.0f - chi2;
       psi2co = 1.0f - psi2;
 
-      /* Avoid floating underflows. */
+      // Avoid floating underflows.
       chipsi = (float)fabs((double)(chi*psi));
       chi4   = (chi2 > 1.0e-16f) ? chi2*chi2 : 0.0f;
       psi4   = (psi2 > 1.0e-16f) ? psi2*psi2 : 0.0f;
@@ -7475,7 +7472,7 @@ int qscset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int qscx2s(
   struct prjprm *prj,
@@ -7498,7 +7495,7 @@ int qscx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != QSC) {
     if ((status = qscset(prj))) return status;
@@ -7516,7 +7513,7 @@ int qscx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -7531,7 +7528,7 @@ int qscx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -7542,7 +7539,7 @@ int qscx2s(
     for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
       xf = *phip;
 
-      /* Bounds checking. */
+      // Bounds checking.
       if (fabs(xf) <= 1.0) {
         if (fabs(yf) > 3.0) {
           *phip = 0.0;
@@ -7561,10 +7558,10 @@ int qscx2s(
         }
       }
 
-      /* Map negative faces to the other side. */
+      // Map negative faces to the other side.
       if (xf < -1.0) xf += 8.0;
 
-      /* Determine the face. */
+      // Determine the face.
       if (xf > 5.0) {
         face = 4;
         xf -= 6.0;
@@ -7692,7 +7689,7 @@ int qscx2s(
         }
         break;
       default:
-        /* face == 0 */
+        // face == 0
         n = zeta;
         if (direct) {
           m = w;
@@ -7718,7 +7715,7 @@ int qscx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-13, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("qscx2s");
   }
@@ -7726,7 +7723,7 @@ int qscx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int qscs2x(
   struct prjprm *prj,
@@ -7750,7 +7747,7 @@ int qscs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != QSC) {
     if ((status = qscset(prj))) return status;
@@ -7768,7 +7765,7 @@ int qscs2x(
   status = 0;
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -7786,7 +7783,7 @@ int qscs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -7836,7 +7833,7 @@ int qscs2x(
         xi  = m;
         eta = n;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (*thetap)*D2R;
           p = atan2(*yp, *xp);
           zeco = (p*p + t*t)/2.0;
@@ -7848,7 +7845,7 @@ int qscs2x(
         xi  = -l;
         eta =  n;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (*thetap)*D2R;
           p = atan2(*yp, *xp) - PI/2.0;
           zeco = (p*p + t*t)/2.0;
@@ -7860,7 +7857,7 @@ int qscs2x(
         xi  = -m;
         eta =  n;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (*thetap)*D2R;
           p = atan2(*yp, *xp);
           p -= copysign(PI, p);
@@ -7873,7 +7870,7 @@ int qscs2x(
         xi  = l;
         eta = n;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (*thetap)*D2R;
           p = atan2(*yp, *xp) + PI/2.0;
           zeco = (p*p + t*t)/2.0;
@@ -7885,7 +7882,7 @@ int qscs2x(
         xi  =  m;
         eta =  l;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (*thetap + 90.0)*D2R;
           zeco = t*t/2.0;
         }
@@ -7893,11 +7890,11 @@ int qscs2x(
         y0 = -2;
          break;
       default:
-        /* face == 0 */
+        // face == 0
         xi  =  m;
         eta = -l;
         if (zeco < 1.0e-8) {
-          /* Small angle formula. */
+          // Small angle formula.
           t = (90.0 - *thetap)*D2R;
           zeco = t*t/2.0;
         }
@@ -8041,7 +8038,7 @@ int hpxset(struct prjprm *prj)
   return prjoff(prj, 0.0, 0.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int hpxx2s(
   struct prjprm *prj,
@@ -8063,7 +8060,7 @@ int hpxx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != HPX) {
     if ((status = hpxset(prj))) return status;
@@ -8084,20 +8081,20 @@ int hpxx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
   for (ix = 0; ix < nx; ix++, rowoff += spt, xp += sxy) {
     s = prj->w[1] * (*xp + prj->x0);
-    /* x_c for K odd or theta > 0. */
+    // x_c for K odd or theta > 0.
     t = -180.0 + (2.0 * floor((*xp + 180.0) * prj->w[7]) + 1.0) * prj->w[6];
     t = prj->w[1] * (*xp - t);
 
     phip   = phi + rowoff;
     thetap = theta + rowoff;
     for (iy = 0; iy < my; iy++) {
-      /* theta[] is used to hold (x - x_c). */
+      // theta[] is used to hold (x - x_c).
       *phip   = s;
       *thetap = t;
       phip   += rowlen;
@@ -8106,7 +8103,7 @@ int hpxx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -8117,7 +8114,7 @@ int hpxx2s(
 
     istat = 0;
     if (absy <= prj->w[5]) {
-      /* Equatorial regime. */
+      // Equatorial regime.
       t = asind(yr/prj->w[3]);
       for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
         *thetap = t;
@@ -8125,7 +8122,7 @@ int hpxx2s(
       }
 
     } else if (absy <= ylim) {
-      /* Polar regime. */
+      // Polar regime.
       offset = (prj->n || *yp > 0.0) ? 0 : 1;
 
       sigma = prj->w[4] - absy / prj->w[6];
@@ -8150,7 +8147,7 @@ int hpxx2s(
 
       for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
         if (offset) {
-          /* Offset the southern polar half-facets for even K. */
+          // Offset the southern polar half-facets for even K.
           h = (int)floor(*phip / prj->w[6]) + prj->m;
           if (h%2) {
             *thetap -= prj->w[6];
@@ -8159,10 +8156,10 @@ int hpxx2s(
           }
         }
 
-        /* Recall that theta[] holds (x - x_c). */
+        // Recall that theta[] holds (x - x_c).
         r = s * *thetap;
 
-        /* Bounds checking. */
+        // Bounds checking.
         if (prj->bounds&2) {
           if (slim <= fabs(r)) {
             istat = 1;
@@ -8178,7 +8175,7 @@ int hpxx2s(
       }
 
     } else {
-      /* Beyond latitude range. */
+      // Beyond latitude range.
       for (ix = 0; ix < mx; ix++, phip += spt, thetap += spt) {
         *phip   = 0.0;
         *thetap = 0.0;
@@ -8189,7 +8186,7 @@ int hpxx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-12, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("hpxx2s");
   }
@@ -8197,7 +8194,7 @@ int hpxx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int hpxs2x(
   struct prjprm *prj,
@@ -8219,7 +8216,7 @@ int hpxs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != HPX) {
     if ((status = hpxset(prj))) return status;
@@ -8235,21 +8232,21 @@ int hpxs2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
   for (iphi = 0; iphi < nphi; iphi++, rowoff += sxy, phip += spt) {
     xi = prj->w[0] * (*phip) - prj->x0;
 
-    /* phi_c for K odd or theta > 0. */
+    // phi_c for K odd or theta > 0.
     t = -180.0 + (2.0*floor((*phip+180.0) * prj->w[7]) + 1.0) * prj->w[6];
     t = prj->w[0] * (*phip - t);
 
     xp = x + rowoff;
     yp = y + rowoff;
     for (itheta = 0; itheta < mtheta; itheta++) {
-      /* y[] is used to hold (phi - phi_c). */
+      // y[] is used to hold (phi - phi_c).
       *xp = xi;
       *yp = t;
       xp += rowlen;
@@ -8258,7 +8255,7 @@ int hpxs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -8268,7 +8265,7 @@ int hpxs2x(
     abssin = fabs(sinthe);
 
     if (abssin <= prj->w[2]) {
-      /* Equatorial regime. */
+      // Equatorial regime.
       eta = prj->w[8] * sinthe - prj->y0;
       for (iphi = 0; iphi < mphi; iphi++, xp += sxy, yp += sxy) {
         *yp = eta;
@@ -8276,7 +8273,7 @@ int hpxs2x(
       }
 
     } else {
-      /* Polar regime. */
+      // Polar regime.
       offset = (prj->n || *thetap > 0.0) ? 0 : 1;
 
       sigma = sqrt(prj->pv[2]*(1.0 - abssin));
@@ -8288,7 +8285,7 @@ int hpxs2x(
 
       for (iphi = 0; iphi < mphi; iphi++, xp += sxy, yp += sxy) {
         if (offset) {
-          /* Offset the southern polar half-facets for even K. */
+          // Offset the southern polar half-facets for even K.
           h = (int)floor((*xp + prj->x0) / prj->w[9]) + prj->m;
           if (h%2) {
             *yp -= prj->w[9];
@@ -8297,12 +8294,12 @@ int hpxs2x(
           }
         }
 
-        /* Recall that y[] holds (phi - phi_c). */
+        // Recall that y[] holds (phi - phi_c).
         *xp += *yp * xi;
         *yp = eta;
         *(statp++) = 0;
 
-        /* Put the phi = 180 meridian in the expected place. */
+        // Put the phi = 180 meridian in the expected place.
         if (180.0 < *xp) *xp = 360.0 - *xp;
       }
     }
@@ -8375,7 +8372,7 @@ int xphset(struct prjprm *prj)
   return prjoff(prj, 0.0, 90.0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int xphx2s(
   struct prjprm *prj,
@@ -8398,7 +8395,7 @@ int xphx2s(
   register double *phip, *thetap;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != XPH) {
     if ((status = xphset(prj))) return status;
@@ -8416,7 +8413,7 @@ int xphx2s(
   status = 0;
 
 
-  /* Do x dependence. */
+  // Do x dependence.
   xp = x;
   rowoff = 0;
   rowlen = nx*spt;
@@ -8431,7 +8428,7 @@ int xphx2s(
   }
 
 
-  /* Do y dependence. */
+  // Do y dependence.
   yp = y;
   phip   = phi;
   thetap = theta;
@@ -8466,12 +8463,12 @@ int xphx2s(
 
       if (abseta <= 90.0) {
         if (abseta <= 45.0) {
-          /* Equatorial regime. */
+          // Equatorial regime.
           *phip  += xi;
           *thetap = asind(eta/67.5);
           istat = 0;
 
-          /* Bounds checking. */
+          // Bounds checking.
           if (prj->bounds&2) {
             if (45.0+tol < fabs(xi1)) {
               istat = 1;
@@ -8482,10 +8479,10 @@ int xphx2s(
           *(statp++) = istat;
 
         } else {
-          /* Polar regime. */
+          // Polar regime.
           sigma = (90.0 - abseta) / 45.0;
 
-          /* Ensure an exact result for points on the boundary. */
+          // Ensure an exact result for points on the boundary.
           if (xr == 0.0) {
             if (yr <= 0.0) {
               *phip = 0.0;
@@ -8509,7 +8506,7 @@ int xphx2s(
           }
           if (eta < 0.0) *thetap = -(*thetap);
 
-          /* Bounds checking. */
+          // Bounds checking.
           istat = 0;
           if (prj->bounds&2) {
             if (eta < -45.0 && eta+90.0+tol < fabs(xi1)) {
@@ -8522,7 +8519,7 @@ int xphx2s(
         }
 
       } else {
-        /* Beyond latitude range. */
+        // Beyond latitude range.
         *phip   = 0.0;
         *thetap = 0.0;
         *(statp++) = 1;
@@ -8532,7 +8529,7 @@ int xphx2s(
   }
 
 
-  /* Do bounds checking on the native coordinates. */
+  // Do bounds checking on the native coordinates.
   if (prj->bounds&4 && prjbchk(1.0e-12, nx, my, spt, phi, theta, stat)) {
     if (!status) status = PRJERR_BAD_PIX_SET("xphx2s");
   }
@@ -8540,7 +8537,7 @@ int xphx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int xphs2x(
   struct prjprm *prj,
@@ -8562,7 +8559,7 @@ int xphs2x(
   register double *xp, *yp;
 
 
-  /* Initialize. */
+  // Initialize.
   if (prj == 0x0) return PRJERR_NULL_POINTER;
   if (prj->flag != XPH) {
     if ((status = xphset(prj))) return status;
@@ -8578,7 +8575,7 @@ int xphs2x(
   }
 
 
-  /* Do phi dependence. */
+  // Do phi dependence.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sxy;
@@ -8593,14 +8590,14 @@ int xphs2x(
       }
     }
 
-    /* phi is also recomputed from chi to avoid rounding problems. */
+    // phi is also recomputed from chi to avoid rounding problems.
     chi += 180.0;
     psi = fmod(chi, 90.0);
 
     xp = x + rowoff;
     yp = y + rowoff;
     for (itheta = 0; itheta < mtheta; itheta++) {
-      /* y[] is used to hold phi (rounded). */
+      // y[] is used to hold phi (rounded).
       *xp = psi;
       *yp = chi - 180.0;
       xp += rowlen;
@@ -8609,7 +8606,7 @@ int xphs2x(
   }
 
 
-  /* Do theta dependence. */
+  // Do theta dependence.
   thetap = theta;
   xp = x;
   yp = y;
@@ -8620,12 +8617,12 @@ int xphs2x(
 
     for (iphi = 0; iphi < mphi; iphi++, xp += sxy, yp += sxy) {
       if (abssin <= prj->w[2]) {
-        /* Equatorial regime. */
+        // Equatorial regime.
         xi  = *xp;
         eta = 67.5 * sinthe;
 
       } else {
-        /* Polar regime. */
+        // Polar regime.
         if (*thetap < prj->w[5]) {
           sigma = sqrt(3.0*(1.0 - abssin));
         } else {
@@ -8640,7 +8637,7 @@ int xphs2x(
       xi  -= 45.0;
       eta -= 90.0;
 
-      /* Recall that y[] holds phi. */
+      // Recall that y[] holds phi.
       if (*yp < -90.0) {
         *xp = prj->w[0]*(-xi + eta) - prj->x0;
         *yp = prj->w[0]*(-xi - eta) - prj->y0;
Index: astropy-4.2/cextern/wcslib/C/prj.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/prj.h
+++ astropy-4.2/cextern/wcslib/C/prj.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: prj.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: prj.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -630,19 +627,19 @@ extern "C" {
 #endif
 
 
-/* Total number of projection parameters; 0 to PVN-1. */
+// Total number of projection parameters; 0 to PVN-1.
 #define PVN 30
 
 extern const char *prj_errmsg[];
 
 enum prj_errmsg_enum {
-  PRJERR_SUCCESS      = 0,	/* Success. */
-  PRJERR_NULL_POINTER = 1,	/* Null prjprm pointer passed. */
-  PRJERR_BAD_PARAM    = 2,	/* Invalid projection parameters. */
-  PRJERR_BAD_PIX      = 3,	/* One or more of the (x, y) coordinates were
-				   invalid. */
-  PRJERR_BAD_WORLD    = 4	/* One or more of the (phi, theta) coordinates
-				   were invalid. */
+  PRJERR_SUCCESS      = 0,	// Success.
+  PRJERR_NULL_POINTER = 1,	// Null prjprm pointer passed.
+  PRJERR_BAD_PARAM    = 2,	// Invalid projection parameters.
+  PRJERR_BAD_PIX      = 3,	// One or more of the (x, y) coordinates were
+				// invalid.
+  PRJERR_BAD_WORLD    = 4	// One or more of the (phi, theta) coordinates
+				// were invalid.
 };
 
 extern const int CONIC, CONVENTIONAL, CYLINDRICAL, POLYCONIC,
@@ -660,59 +657,59 @@ extern const char prj_codes[28][4];
 #undef PRJS2X_ARGS
 #endif
 
-/* For use in declaring deprojection function prototypes. */
+// For use in declaring deprojection function prototypes.
 #define PRJX2S_ARGS struct prjprm *prj, int nx, int ny, int sxy, int spt, \
 const double x[], const double y[], double phi[], double theta[], int stat[]
 
-/* For use in declaring projection function prototypes. */
+// For use in declaring projection function prototypes.
 #define PRJS2X_ARGS struct prjprm *prj, int nx, int ny, int sxy, int spt, \
 const double phi[], const double theta[], double x[], double y[], int stat[]
 
 
 struct prjprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int    flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  char   code[4];		/* Three-letter projection code.            */
-  double r0;			/* Radius of the generating sphere.         */
-  double pv[PVN];		/* Projection parameters.                   */
-  double phi0, theta0;		/* Fiducial native coordinates.             */
-  int    bounds;		/* Controls bounds checking.                */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  char   name[40];		/* Projection name.                         */
-  int    category;		/* Projection category.                     */
-  int    pvrange;		/* Range of projection parameter indices.   */
-  int    simplezen;		/* Is it a simple zenithal projection?      */
-  int    equiareal;		/* Is it an equal area projection?          */
-  int    conformal;		/* Is it a conformal projection?            */
-  int    global;		/* Can it map the whole sphere?             */
-  int    divergent;		/* Does the projection diverge in latitude? */
-  double x0, y0;		/* Fiducial offsets.                        */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  char   code[4];		// Three-letter projection code.
+  double r0;			// Radius of the generating sphere.
+  double pv[PVN];		// Projection parameters.
+  double phi0, theta0;		// Fiducial native coordinates.
+  int    bounds;		// Controls bounds checking.
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  char   name[40];		// Projection name.
+  int    category;		// Projection category.
+  int    pvrange;		// Range of projection parameter indices.
+  int    simplezen;		// Is it a simple zenithal projection?
+  int    equiareal;		// Is it an equal area projection?
+  int    conformal;		// Is it a conformal projection?
+  int    global;		// Can it map the whole sphere?
+  int    divergent;		// Does the projection diverge in latitude?
+  double x0, y0;		// Fiducial offsets.
 
-  /* Error handling                                                         */
-  /*------------------------------------------------------------------------*/
+  // Error handling
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private                                                                */
-  /*------------------------------------------------------------------------*/
-  void   *padding;		/* (Dummy inserted for alignment purposes.) */
-  double w[10];			/* Intermediate values.                     */
-  int    m, n;			/* Intermediate values.                     */
+  // Private
+  //--------------------------------------------------------------------------
+  void   *padding;		// (Dummy inserted for alignment purposes.)
+  double w[10];			// Intermediate values.
+  int    m, n;			// Intermediate values.
 
-  int (*prjx2s)(PRJX2S_ARGS);	/* Pointers to the spherical projection and */
-  int (*prjs2x)(PRJS2X_ARGS);	/* deprojection functions.                  */
+  int (*prjx2s)(PRJX2S_ARGS);	// Pointers to the spherical projection and
+  int (*prjs2x)(PRJS2X_ARGS);	// deprojection functions.
 };
 
-/* Size of the prjprm struct in int units, used by the Fortran wrappers. */
+// Size of the prjprm struct in int units, used by the Fortran wrappers.
 #define PRJLEN (sizeof(struct prjprm)/sizeof(int))
 
 
-/* Use the preprocessor to help declare function prototypes (see above). */
+// Use the preprocessor to help declare function prototypes (see above).
 int prjini(struct prjprm *prj);
 int prjfree(struct prjprm *prj);
 int prjprt(const struct prjprm *prj);
@@ -837,7 +834,7 @@ int xphx2s(PRJX2S_ARGS);
 int xphs2x(PRJS2X_ARGS);
 
 
-/* Deprecated. */
+// Deprecated.
 #define prjini_errmsg prj_errmsg
 #define prjprt_errmsg prj_errmsg
 #define prjset_errmsg prj_errmsg
@@ -848,4 +845,4 @@ int xphs2x(PRJS2X_ARGS);
 }
 #endif
 
-#endif /* WCSLIB_PROJ */
+#endif // WCSLIB_PROJ
Index: astropy-4.2/cextern/wcslib/C/spc.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/spc.c
+++ astropy-4.2/cextern/wcslib/C/spc.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: spc.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: spc.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -38,29 +35,29 @@
 #include "spc.h"
 #include "spx.h"
 
-/* Spectral algorithm codes. */
-#define F2S 100;		/* Axis linear in frequency.          */
-#define W2S 200;		/* Axis linear in vacuum wavelengths. */
-#define A2S 300;		/* Axis linear in air wavelengths.    */
-#define V2S 400;		/* Axis linear in velocity.           */
-#define GRI 500;		/* Grism in vacuum.                   */
-#define GRA 600;		/* Grism in air.                      */
-
-/* S-type spectral variables. */
-#define FREQ  0;		/* Frequency-like.                    */
-#define AFRQ  1;		/* Frequency-like.                    */
-#define ENER  2;		/* Frequency-like.                    */
-#define WAVN  3;		/* Frequency-like.                    */
-#define VRAD  4;		/* Frequency-like.                    */
-#define WAVE 10;		/* Vacuum wavelength-like.            */
-#define VOPT 11;		/* Vacuum wavelength-like.            */
-#define ZOPT 12;		/* Vacuum wavelength-like.            */
-#define AWAV 20;		/* Air wavelength-like.               */
-#define VELO 30;		/* Velocity-like.                     */
-#define BETA 31;		/* Velocity-like.                     */
+// Spectral algorithm codes.
+#define F2S 100;		// Axis linear in frequency.
+#define W2S 200;		// Axis linear in vacuum wavelengths.
+#define A2S 300;		// Axis linear in air wavelengths.
+#define V2S 400;		// Axis linear in velocity.
+#define GRI 500;		// Grism in vacuum.
+#define GRA 600;		// Grism in air.
+
+// S-type spectral variables.
+#define FREQ  0;		// Frequency-like.
+#define AFRQ  1;		// Frequency-like.
+#define ENER  2;		// Frequency-like.
+#define WAVN  3;		// Frequency-like.
+#define VRAD  4;		// Frequency-like.
+#define WAVE 10;		// Vacuum wavelength-like.
+#define VOPT 11;		// Vacuum wavelength-like.
+#define ZOPT 12;		// Vacuum wavelength-like.
+#define AWAV 20;		// Air wavelength-like.
+#define VELO 30;		// Velocity-like.
+#define BETA 31;		// Velocity-like.
 
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *spc_errmsg[] = {
   "Success",
   "Null spcprm pointer passed",
@@ -68,24 +65,24 @@ const char *spc_errmsg[] = {
   "One or more of x coordinates were invalid",
   "One or more of the spec coordinates were invalid"};
 
-/* Map error returns for lower-level routines.  SPXERR_BAD_INSPEC_COORD */
-/* maps to either SPCERR_BAD_X or SPCERR_BAD_SPEC depending on context. */
+// Map error returns for lower-level routines.  SPXERR_BAD_INSPEC_COORD
+// maps to either SPCERR_BAD_X or SPCERR_BAD_SPEC depending on context.
 const int spc_spxerr[] = {
 
-  SPCERR_SUCCESS,		/*  0: SPXERR_SUCCESS          */
-  SPCERR_NULL_POINTER,		/*  1: SPXERR_NULL_POINTER     */
-  SPCERR_BAD_SPEC_PARAMS,	/*  2: SPXERR_BAD_SPEC_PARAMS  */
-  SPCERR_BAD_SPEC_PARAMS	/*  3: SPXERR_BAD_SPEC_VAR     */
-				/*  4: SPXERR_BAD_INSPEC_COORD */
+  SPCERR_SUCCESS,		//  0: SPXERR_SUCCESS
+  SPCERR_NULL_POINTER,		//  1: SPXERR_NULL_POINTER
+  SPCERR_BAD_SPEC_PARAMS,	//  2: SPXERR_BAD_SPEC_PARAMS
+  SPCERR_BAD_SPEC_PARAMS	//  3: SPXERR_BAD_SPEC_VAR
+				//  4: SPXERR_BAD_INSPEC_COORD
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define SPC_ERRMSG(status) WCSERR_SET(status), spc_errmsg[status]
 
 
 #define C 2.99792458e8
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcini(struct spcprm *spc)
 
@@ -126,7 +123,7 @@ int spcini(struct spcprm *spc)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcfree(struct spcprm *spc)
 
@@ -138,7 +135,7 @@ int spcfree(struct spcprm *spc)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcprt(const struct spcprm *spc)
 
@@ -215,7 +212,7 @@ int spcprt(const struct spcprm *spc)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcperr(const struct spcprm *spc, const char *prefix)
 
@@ -229,7 +226,7 @@ int spcperr(const struct spcprm *spc, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcset(struct spcprm *spc)
 
@@ -257,7 +254,7 @@ int spcset(struct spcprm *spc)
   spc->w[0] = 0.0;
 
 
-  /* Analyse the spectral axis type. */
+  // Analyse the spectral axis type.
   memset(ctype, 0, 9);
   memcpy(ctype, spc->type, 4);
   if (*(spc->code) != ' ') {
@@ -270,12 +267,12 @@ int spcset(struct spcprm *spc)
     return status;
   }
 
-  /* Satisfy rest frequency/wavelength requirements. */
+  // Satisfy rest frequency/wavelength requirements.
   if (restreq) {
     if (restreq == 3 && restfrq == 0.0 && restwav == 0.0) {
-      /* VRAD-V2F, VOPT-V2W, and ZOPT-V2W require the rest frequency or */
-      /* wavelength for the S-P and P-X transformations but not for S-X */
-      /* so supply a phoney value. */
+      // VRAD-V2F, VOPT-V2W, and ZOPT-V2W require the rest frequency or
+      // wavelength for the S-P and P-X transformations but not for S-X
+      // so supply a phoney value.
       restwav = 1.0;
     }
 
@@ -302,34 +299,34 @@ int spcset(struct spcprm *spc)
   spc->w[2] = dXdS;
 
 
-  /* Set pointers-to-functions for the linear part of the transformation. */
+  // Set pointers-to-functions for the linear part of the transformation.
   if (ptype == 'F') {
     if (strcmp(spc->type, "FREQ") == 0) {
-      /* Frequency. */
+      // Frequency.
       spc->flag = FREQ;
       spc->spxP2S = 0x0;
       spc->spxS2P = 0x0;
 
     } else if (strcmp(spc->type, "AFRQ") == 0) {
-      /* Angular frequency. */
+      // Angular frequency.
       spc->flag = AFRQ;
       spc->spxP2S = freqafrq;
       spc->spxS2P = afrqfreq;
 
     } else if (strcmp(spc->type, "ENER") == 0) {
-      /* Photon energy. */
+      // Photon energy.
       spc->flag = ENER;
       spc->spxP2S = freqener;
       spc->spxS2P = enerfreq;
 
     } else if (strcmp(spc->type, "WAVN") == 0) {
-      /* Wave number. */
+      // Wave number.
       spc->flag = WAVN;
       spc->spxP2S = freqwavn;
       spc->spxS2P = wavnfreq;
 
     } else if (strcmp(spc->type, "VRAD") == 0) {
-      /* Radio velocity. */
+      // Radio velocity.
       spc->flag = VRAD;
       spc->spxP2S = freqvrad;
       spc->spxS2P = vradfreq;
@@ -337,19 +334,19 @@ int spcset(struct spcprm *spc)
 
   } else if (ptype == 'W') {
     if (strcmp(spc->type, "WAVE") == 0) {
-      /* Vacuum wavelengths. */
+      // Vacuum wavelengths.
       spc->flag = WAVE;
       spc->spxP2S = 0x0;
       spc->spxS2P = 0x0;
 
     } else if (strcmp(spc->type, "VOPT") == 0) {
-      /* Optical velocity. */
+      // Optical velocity.
       spc->flag = VOPT;
       spc->spxP2S = wavevopt;
       spc->spxS2P = voptwave;
 
     } else if (strcmp(spc->type, "ZOPT") == 0) {
-      /* Redshift. */
+      // Redshift.
       spc->flag = ZOPT;
       spc->spxP2S = wavezopt;
       spc->spxS2P = zoptwave;
@@ -357,7 +354,7 @@ int spcset(struct spcprm *spc)
 
   } else if (ptype == 'A') {
     if (strcmp(spc->type, "AWAV") == 0) {
-      /* Air wavelengths. */
+      // Air wavelengths.
       spc->flag = AWAV;
       spc->spxP2S = 0x0;
       spc->spxS2P = 0x0;
@@ -365,13 +362,13 @@ int spcset(struct spcprm *spc)
 
   } else if (ptype == 'V') {
     if (strcmp(spc->type, "VELO") == 0) {
-      /* Relativistic velocity. */
+      // Relativistic velocity.
       spc->flag = VELO;
       spc->spxP2S = 0x0;
       spc->spxS2P = 0x0;
 
     } else if (strcmp(spc->type, "BETA") == 0) {
-      /* Velocity ratio (v/c). */
+      // Velocity ratio (v/c).
       spc->flag = BETA;
       spc->spxP2S = velobeta;
       spc->spxS2P = betavelo;
@@ -379,11 +376,11 @@ int spcset(struct spcprm *spc)
   }
 
 
-  /* Set pointers-to-functions for the non-linear part of the spectral */
-  /* transformation.                                                   */
+  // Set pointers-to-functions for the non-linear part of the spectral
+  // transformation.
   spc->isGrism = 0;
   if (xtype == 'F') {
-    /* Axis is linear in frequency. */
+    // Axis is linear in frequency.
     if (ptype == 'F') {
       spc->spxX2P = 0x0;
       spc->spxP2X = 0x0;
@@ -404,7 +401,7 @@ int spcset(struct spcprm *spc)
     spc->flag += F2S;
 
   } else if (xtype == 'W' || xtype == 'w') {
-    /* Axis is linear in vacuum wavelengths. */
+    // Axis is linear in vacuum wavelengths.
     if (ptype == 'F') {
       spc->spxX2P = wavefreq;
       spc->spxP2X = freqwave;
@@ -425,13 +422,13 @@ int spcset(struct spcprm *spc)
     if (xtype == 'W') {
       spc->flag += W2S;
     } else {
-      /* Grism in vacuum. */
+      // Grism in vacuum.
       spc->isGrism = 1;
       spc->flag += GRI;
     }
 
   } else if (xtype == 'A' || xtype == 'a') {
-    /* Axis is linear in air wavelengths. */
+    // Axis is linear in air wavelengths.
     if (ptype == 'F') {
       spc->spxX2P = awavfreq;
       spc->spxP2X = freqawav;
@@ -452,13 +449,13 @@ int spcset(struct spcprm *spc)
     if (xtype == 'A') {
       spc->flag += A2S;
     } else {
-      /* Grism in air. */
+      // Grism in air.
       spc->isGrism = 2;
       spc->flag += GRA;
     }
 
   } else if (xtype == 'V') {
-    /* Axis is linear in relativistic velocity. */
+    // Axis is linear in relativistic velocity.
     if (ptype == 'F') {
       spc->spxX2P = velofreq;
       spc->spxP2X = freqvelo;
@@ -480,12 +477,12 @@ int spcset(struct spcprm *spc)
   }
 
 
-  /* Check for grism axes. */
+  // Check for grism axes.
   if (spc->isGrism) {
-    /* Axis is linear in "grism parameter"; work in wavelength. */
+    // Axis is linear in "grism parameter"; work in wavelength.
     lambda_r = crvalX;
 
-    /* Set defaults. */
+    // Set defaults.
     if (undefined(spc->pv[0])) spc->pv[0] = 0.0;
     if (undefined(spc->pv[1])) spc->pv[1] = 0.0;
     if (undefined(spc->pv[2])) spc->pv[2] = 0.0;
@@ -494,7 +491,7 @@ int spcset(struct spcprm *spc)
     if (undefined(spc->pv[5])) spc->pv[5] = 0.0;
     if (undefined(spc->pv[6])) spc->pv[6] = 0.0;
 
-    /* Compute intermediaries. */
+    // Compute intermediaries.
     G       = spc->pv[0];
     m       = spc->pv[1];
     alpha   = spc->pv[2];
@@ -518,7 +515,7 @@ int spcset(struct spcprm *spc)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcx2s(
   struct spcprm *spc,
@@ -540,7 +537,7 @@ int spcx2s(
   register double *specp;
   struct wcserr **err;
 
-  /* Initialize. */
+  // Initialize.
   if (spc == 0x0) return SPCERR_NULL_POINTER;
   err = &(spc->err);
 
@@ -548,7 +545,7 @@ int spcx2s(
     if ((status = spcset(spc))) return status;
   }
 
-  /* Convert intermediate world coordinate x to X. */
+  // Convert intermediate world coordinate x to X.
   xp = x;
   specp = spec;
   statp = stat;
@@ -557,7 +554,7 @@ int spcx2s(
     *(statp++) = 0;
   }
 
-  /* If X is the grism parameter then convert it to wavelength. */
+  // If X is the grism parameter then convert it to wavelength.
   if (spc->isGrism) {
     specp = spec;
     for (ix = 0; ix < nx; ix++, specp += sspec) {
@@ -566,8 +563,8 @@ int spcx2s(
     }
   }
 
-  /* Apply the non-linear step of the algorithm chain to convert the    */
-  /* X-type spectral variable to P-type intermediate spectral variable. */
+  // Apply the non-linear step of the algorithm chain to convert the
+  // X-type spectral variable to P-type intermediate spectral variable.
   if (spc->spxX2P) {
     if ((statX2P = spc->spxX2P(spc->w[0], nx, sspec, sspec, spec, spec,
                                stat))) {
@@ -582,8 +579,8 @@ int spcx2s(
     }
   }
 
-  /* Apply the linear step of the algorithm chain to convert P-type  */
-  /* intermediate spectral variable to the required S-type variable. */
+  // Apply the linear step of the algorithm chain to convert P-type
+  // intermediate spectral variable to the required S-type variable.
   if (spc->spxP2S) {
     if ((statP2S = spc->spxP2S(spc->w[0], nx, sspec, sspec, spec, spec,
                                stat))) {
@@ -604,7 +601,7 @@ int spcx2s(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcs2x(
   struct spcprm *spc,
@@ -626,7 +623,7 @@ int spcs2x(
   register double *xp;
   struct wcserr **err;
 
-  /* Initialize. */
+  // Initialize.
   if (spc == 0x0) return SPCERR_NULL_POINTER;
   err = &(spc->err);
 
@@ -634,8 +631,8 @@ int spcs2x(
     if ((status = spcset(spc))) return status;
   }
 
-  /* Apply the linear step of the algorithm chain to convert the S-type */
-  /* spectral variable to P-type intermediate spectral variable.        */
+  // Apply the linear step of the algorithm chain to convert the S-type
+  // spectral variable to P-type intermediate spectral variable.
   if (spc->spxS2P) {
     if ((statS2P = spc->spxS2P(spc->w[0], nspec, sspec, sx, spec, x, stat))) {
       if (statS2P == SPXERR_BAD_INSPEC_COORD) {
@@ -649,7 +646,7 @@ int spcs2x(
     }
 
   } else {
-    /* Just a copy. */
+    // Just a copy.
     xp = x;
     specp = spec;
     statp = stat;
@@ -660,8 +657,8 @@ int spcs2x(
   }
 
 
-  /* Apply the non-linear step of the algorithm chain to convert P-type */
-  /* intermediate spectral variable to X-type spectral variable. */
+  // Apply the non-linear step of the algorithm chain to convert P-type
+  // intermediate spectral variable to X-type spectral variable.
   if (spc->spxP2X) {
     if ((statP2X = spc->spxP2X(spc->w[0], nspec, sx, sx, x, x, stat))) {
       if (statP2X == SPCERR_BAD_SPEC) {
@@ -676,7 +673,7 @@ int spcs2x(
   }
 
   if (spc->isGrism) {
-    /* Convert X-type spectral variable (wavelength) to grism parameter. */
+    // Convert X-type spectral variable (wavelength) to grism parameter.
     xp = x;
     statp = stat;
     for (ispec = 0; ispec < nspec; ispec++, xp += sx, statp++) {
@@ -693,7 +690,7 @@ int spcs2x(
   }
 
 
-  /* Convert X-type spectral variable to intermediate world coordinate x. */
+  // Convert X-type spectral variable to intermediate world coordinate x.
   xp = x;
   statp = stat;
   for (ispec = 0; ispec < nspec; ispec++, xp += sx) {
@@ -709,7 +706,7 @@ int spcs2x(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spctyp(
   const char ctypei[9],
@@ -726,7 +723,7 @@ int spctyp(
     ctypei, stype, scode, sname, units, ptype, xtype, restreq, NULL);
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int spctype(
   const char ctypei[9],
@@ -747,11 +744,11 @@ int spctype(
 
   if (err) *err = 0x0;
 
-  /* Copy with blank padding. */
+  // Copy with blank padding.
   sprintf(ctype, "%-8.8s", ctypei);
   ctype[8] = '\0';
 
-  /* Validate the S-type spectral variable. */
+  // Validate the S-type spectral variable.
   if (strncmp(ctype, "FREQ", 4) == 0) {
     strcpy(sname_t, "Frequency");
     strcpy(units_t, "Hz");
@@ -805,9 +802,9 @@ int spctype(
   }
 
 
-  /* Determine X-type and validate the spectral algorithm code. */
+  // Determine X-type and validate the spectral algorithm code.
   if ((xtype_t = ctype[5]) == ' ') {
-    /* The algorithm code must be completely blank. */
+    // The algorithm code must be completely blank.
     if (strcmp(ctype+4, "    ") != 0) {
       return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
         "Invalid spectral algorithm '%s'", ctype+4);
@@ -820,21 +817,21 @@ int spctype(
       "Invalid spectral type '%s'", ctype);
 
   } else if (strcmp(ctype+5, "LOG") == 0 || strcmp(ctype+5, "TAB") == 0) {
-    /* Logarithmic or tabular axis, not linear in any spectral type. */
+    // Logarithmic or tabular axis, not linear in any spectral type.
 
   } else if (xtype_t == 'G') {
-    /* Validate the algorithm code. */
+    // Validate the algorithm code.
     if (ctype[6] != 'R') {
       return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
         "Invalid spectral algorithm '%s'", xtype_t);
     }
 
-    /* Grism coordinates... */
+    // Grism coordinates...
     if (ctype[7] == 'I') {
-      /* ...in vacuum. */
+      // ...in vacuum.
       xtype_t = 'w';
     } else if (ctype[7] == 'A') {
-      /* ...in air. */
+      // ...in air.
       xtype_t = 'a';
     } else {
       return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
@@ -842,22 +839,22 @@ int spctype(
     }
 
   } else if (ctype[6] != '2') {
-    /* Algorithm code has invalid syntax. */
+    // Algorithm code has invalid syntax.
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Invalid spectral algorithm syntax '%s'", xtype_t);
   } else if (ctype[7] != ptype_t && ctype[7] != '?') {
-    /* The P-, and S-type variables are inconsistent. */
+    // The P-, and S-type variables are inconsistent.
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "In spectral type '%s', P- and S-type variables are inconsistent",
       ctype);
 
   } else if (ctype[7] == ctype[5]) {
-    /* Degenerate algorithm code. */
+    // Degenerate algorithm code.
     sprintf(ctype+4, "    ");
   }
 
 
-  /* Rest freq/wavelength required for transformation between P and X? */
+  // Rest freq/wavelength required for transformation between P and X?
   if (strchr("FWAwa", (int)xtype_t)) {
     if (ptype_t == 'V') {
       restreq_t += 2;
@@ -867,13 +864,13 @@ int spctype(
       restreq_t += 2;
     }
   } else if (strchr("LT", (int)xtype_t) == 0) {
-    /* Invalid X-type variable code. */
+    // Invalid X-type variable code.
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "In spectral type '%s', invalid X-type variable code", ctype);
   }
 
 
-  /* Copy results. */
+  // Copy results.
   if (stype) {
     memcpy(stype, ctype, 4);
     stype[4] = '\0';
@@ -889,7 +886,7 @@ int spctype(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcspx(
   const char ctypeS[9],
@@ -907,7 +904,7 @@ int spcspx(
                  crvalX, dXdS, 0x0);
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int spcspxe(
   const char ctypeS[9],
@@ -930,25 +927,25 @@ int spcspxe(
   struct spxprm spx;
 
 
-  /* Analyse the spectral axis code. */
+  // Analyse the spectral axis code.
   if ((status = spctype(ctypeS, stype, scode, 0x0, 0x0, ptype, xtype, restreq,
                         err))) {
     return status;
   }
 
   if (strchr("LT", (int)(*xtype))) {
-    /* Can't handle logarithmic or tabular coordinates. */
+    // Can't handle logarithmic or tabular coordinates.
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Can't handle logarithmic or tabular coordinates");
   }
 
-  /* Do we have rest frequency and/or wavelength as required? */
+  // Do we have rest frequency and/or wavelength as required?
   if ((*restreq)%3 && restfrq == 0.0 && restwav == 0.0) {
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Missing required rest frequency or wavelength");
   }
 
-  /* Compute all spectral parameters and their derivatives. */
+  // Compute all spectral parameters and their derivatives.
   strcpy(type, stype);
   spx.err = (err ? *err : 0x0);
   if ((status = specx(type, crvalS, restfrq, restwav, &spx))) {
@@ -964,7 +961,7 @@ int spcspxe(
   }
 
 
-  /* Transform S-P (linear) and P-X (non-linear). */
+  // Transform S-P (linear) and P-X (non-linear).
   dPdS = 0.0;
   dXdP = 0.0;
   if (*ptype == 'F') {
@@ -1063,7 +1060,7 @@ int spcspxe(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcxps(
   const char ctypeS[9],
@@ -1081,7 +1078,7 @@ int spcxps(
                  crvalS, dSdX, NULL);
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int spcxpse(
   const char ctypeS[9],
@@ -1103,25 +1100,25 @@ int spcxpse(
   double dPdX, dSdP;
   struct spxprm spx;
 
-  /* Analyse the spectral axis type. */
+  // Analyse the spectral axis type.
   if ((status = spctype(ctypeS, stype, scode, 0x0, 0x0, ptype, xtype, restreq,
                         err))) {
     return status;
   }
 
   if (strchr("LT", (int)(*xtype))) {
-    /* Can't handle logarithmic or tabular coordinates. */
+    // Can't handle logarithmic or tabular coordinates.
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Can't handle logarithmic or tabular coordinates");
   }
 
-  /* Do we have rest frequency and/or wavelength as required? */
+  // Do we have rest frequency and/or wavelength as required?
   if ((*restreq)%3 && restfrq == 0.0 && restwav == 0.0) {
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Missing required rest frequency or wavelength");
   }
 
-  /* Compute all spectral parameters and their derivatives. */
+  // Compute all spectral parameters and their derivatives.
   if (*xtype == 'F') {
     strcpy(type, "FREQ");
   } else if (*xtype == 'W' || *xtype == 'w') {
@@ -1146,7 +1143,7 @@ int spcxpse(
   }
 
 
-  /* Transform X-P (non-linear) and P-S (linear). */
+  // Transform X-P (non-linear) and P-S (linear).
   dPdX = 0.0;
   dSdP = 0.0;
   if (*ptype == 'F') {
@@ -1240,7 +1237,7 @@ int spcxpse(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spctrn(
   const char ctypeS1[9],
@@ -1257,7 +1254,7 @@ int spctrn(
                  ctypeS2, crvalS2, cdeltS2, NULL);
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int spctrne(
   const char ctypeS1[9],
@@ -1278,9 +1275,9 @@ int spctrne(
   double crvalX, dS2dX, dXdS1;
 
   if (restfrq == 0.0 && restwav == 0.0) {
-    /* If translating between two velocity-characteristic types, or between
-       two wave-characteristic types, then we may need to set a dummy rest
-       frequency or wavelength to perform the calculations. */
+    // If translating between two velocity-characteristic types, or between
+    // two wave-characteristic types, then we may need to set a dummy rest
+    // frequency or wavelength to perform the calculations.
     strncpy(stype1, ctypeS1, 4);
     strncpy(stype2, ctypeS2, 4);
     stype1[4] = stype2[4] = '\0';
@@ -1295,13 +1292,13 @@ int spctrne(
     return status;
   }
 
-  /* Pad with blanks. */
+  // Pad with blanks.
   ctypeS2[8] = '\0';
   for (cp = ctypeS2; *cp; cp++);
   while (cp < ctypeS2+8) *(cp++) = ' ';
 
   if (strncmp(ctypeS2+5, "???", 3) == 0) {
-    /* Set the algorithm code if required. */
+    // Set the algorithm code if required.
     if (xtype1 == 'w') {
       strcpy(ctypeS2+5, "GRI");
     } else if (xtype1 == 'a') {
@@ -1317,7 +1314,7 @@ int spctrne(
     return status;
   }
 
-  /* Are the X-types compatible? */
+  // Are the X-types compatible?
   if (xtype2 != xtype1) {
     return wcserr_set(WCSERR_SET(SPCERR_BAD_SPEC_PARAMS),
       "Incompatible X-types '%c' and '%c'", xtype1, xtype2);
@@ -1336,7 +1333,7 @@ int spctrne(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcaips(
   const char ctypeA[9],
@@ -1350,18 +1347,18 @@ int spcaips(
   char *fcode;
   int  ivf, status;
 
-  /* Make a null-filled copy of ctypeA. */
+  // Make a null-filled copy of ctypeA.
   if (ctype != ctypeA) strncpy(ctype, ctypeA, 8);
   ctype[8] = '\0';
   wcsutil_null_fill(9, ctype);
   *specsys = '\0';
 
-  /* Is it a recognized AIPS-convention type? */
+  // Is it a recognized AIPS-convention type?
   status = SPCERR_NO_CHANGE;
   if (strncmp(ctype, "FREQ", 4) == 0 ||
       strncmp(ctype, "VELO", 4) == 0 ||
       strncmp(ctype, "FELO", 4) == 0) {
-    /* Look for the Doppler frame. */
+    // Look for the Doppler frame.
     if (*(fcode = ctype+4)) {
       if (strcmp(fcode, "-LSR") == 0) {
         strcpy(specsys, "LSRK");
@@ -1370,7 +1367,7 @@ int spcaips(
       } else if (strcmp(fcode, "-OBS") == 0) {
         strcpy(specsys, "TOPOCENT");
       } else {
-        /* Not a recognized AIPS spectral type. */
+        // Not a recognized AIPS spectral type.
         return SPCERR_NO_CHANGE;
       }
 
@@ -1378,7 +1375,7 @@ int spcaips(
       status = 0;
     }
 
-    /* VELREF takes precedence if present. */
+    // VELREF takes precedence if present.
     ivf = velref%256;
     if (0 < ivf && ivf <= 7) {
       strcpy(specsys, frames[ivf-1]);
@@ -1388,9 +1385,9 @@ int spcaips(
     }
 
     if (strcmp(ctype, "VELO") == 0) {
-      /* Check that we found an AIPS-convention Doppler frame. */
+      // Check that we found an AIPS-convention Doppler frame.
       if (*specsys) {
-        /* 'VELO' in AIPS means radio or optical depending on VELREF. */
+        // 'VELO' in AIPS means radio or optical depending on VELREF.
         ivf = velref/256;
         if (ivf == 0) {
           strcpy(ctype, "VOPT");
@@ -1401,8 +1398,8 @@ int spcaips(
         }
       }
     } else if (strcmp(ctype, "FELO") == 0) {
-      /* Uniform in frequency but expressed as an optical velocity (strictly
-         we should also have found an AIPS-convention Doppler frame). */
+      // Uniform in frequency but expressed as an optical velocity (strictly
+      // we should also have found an AIPS-convention Doppler frame).
       strcpy(ctype, "VOPT-F2W");
       if (status < 0) status = 0;
     }
Index: astropy-4.2/cextern/wcslib/C/spc.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/spc.h
+++ astropy-4.2/cextern/wcslib/C/spc.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: spc.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: spc.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -794,67 +791,67 @@ extern "C" {
 extern const char *spc_errmsg[];
 
 enum spc_errmsg_enum {
-  SPCERR_NO_CHANGE       = -1,	/* No change. */
-  SPCERR_SUCCESS         =  0,	/* Success. */
-  SPCERR_NULL_POINTER    =  1,	/* Null spcprm pointer passed. */
-  SPCERR_BAD_SPEC_PARAMS =  2,	/* Invalid spectral parameters. */
-  SPCERR_BAD_X           =  3,	/* One or more of x coordinates were
-				   invalid. */
-  SPCERR_BAD_SPEC        =  4 	/* One or more of the spec coordinates were
-				   invalid. */
+  SPCERR_NO_CHANGE       = -1,	// No change.
+  SPCERR_SUCCESS         =  0,	// Success.
+  SPCERR_NULL_POINTER    =  1,	// Null spcprm pointer passed.
+  SPCERR_BAD_SPEC_PARAMS =  2,	// Invalid spectral parameters.
+  SPCERR_BAD_X           =  3,	// One or more of x coordinates were
+				// invalid.
+  SPCERR_BAD_SPEC        =  4 	// One or more of the spec coordinates were
+				// invalid.
 };
 
 struct spcprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int    flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  char   type[8];		/* Four-letter spectral variable type.      */
-  char   code[4];		/* Three-letter spectral algorithm code.    */
-
-  double crval;			/* Reference value (CRVALia), SI units.     */
-  double restfrq;		/* Rest frequency, Hz.                      */
-  double restwav;		/* Rest wavelength, m.                      */
-
-  double pv[7];			/* Grism parameters:                        */
-				/*   0: G, grating ruling density.          */
-				/*   1: m, interference order.              */
-				/*   2: alpha, angle of incidence.          */
-				/*   3: n_r, refractive index at lambda_r.  */
-				/*   4: n'_r, dn/dlambda at lambda_r.       */
-				/*   5: epsilon, grating tilt angle.        */
-				/*   6: theta, detector tilt angle.         */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  double w[6];			/* Intermediate values.                     */
-				/*   0: Rest frequency or wavelength (SI).  */
-				/*   1: CRVALX (SI units).                  */
-				/*   2: CDELTX/CDELTia = dX/dS (SI units).  */
-				/* The remainder are grism intermediates.   */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  char   type[8];		// Four-letter spectral variable type.
+  char   code[4];		// Three-letter spectral algorithm code.
+
+  double crval;			// Reference value (CRVALia), SI units.
+  double restfrq;		// Rest frequency, Hz.
+  double restwav;		// Rest wavelength, m.
+
+  double pv[7];			// Grism parameters:
+				//   0: G, grating ruling density.
+				//   1: m, interference order.
+				//   2: alpha, angle of incidence.
+				//   3: n_r, refractive index at lambda_r.
+				//   4: n'_r, dn/dlambda at lambda_r.
+				//   5: epsilon, grating tilt angle.
+				//   6: theta, detector tilt angle.
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  double w[6];			// Intermediate values.
+				//   0: Rest frequency or wavelength (SI).
+				//   1: CRVALX (SI units).
+				//   2: CDELTX/CDELTia = dX/dS (SI units).
+				// The remainder are grism intermediates.
 
-  int    isGrism;		/* Grism coordinates?  1: vacuum, 2: air.   */
-  int    padding1;		/* (Dummy inserted for alignment purposes.) */
+  int    isGrism;		// Grism coordinates?  1: vacuum, 2: air.
+  int    padding1;		// (Dummy inserted for alignment purposes.)
 
-  /* Error handling                                                         */
-  /*------------------------------------------------------------------------*/
+  // Error handling
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private                                                                */
-  /*------------------------------------------------------------------------*/
-  void   *padding2;		/* (Dummy inserted for alignment purposes.) */
-  int (*spxX2P)(SPX_ARGS);	/* Pointers to the transformation functions */
-  int (*spxP2S)(SPX_ARGS);	/* in the two-step algorithm chain in the   */
-				/* pixel-to-spectral direction.             */
-
-  int (*spxS2P)(SPX_ARGS);	/* Pointers to the transformation functions */
-  int (*spxP2X)(SPX_ARGS);	/* in the two-step algorithm chain in the   */
-				/* spectral-to-pixel direction.             */
+  // Private
+  //--------------------------------------------------------------------------
+  void   *padding2;		// (Dummy inserted for alignment purposes.)
+  int (*spxX2P)(SPX_ARGS);	// Pointers to the transformation functions
+  int (*spxP2S)(SPX_ARGS);	// in the two-step algorithm chain in the
+				// pixel-to-spectral direction.
+
+  int (*spxS2P)(SPX_ARGS);	// Pointers to the transformation functions
+  int (*spxP2X)(SPX_ARGS);	// in the two-step algorithm chain in the
+				// spectral-to-pixel direction.
 };
 
-/* Size of the spcprm struct in int units, used by the Fortran wrappers. */
+// Size of the spcprm struct in int units, used by the Fortran wrappers.
 #define SPCLEN (sizeof(struct spcprm)/sizeof(int))
 
 
@@ -893,7 +890,7 @@ int spctrne(const char ctypeS1[9], doubl
 int spcaips(const char ctypeA[9], int velref, char ctype[9], char specsys[9]);
 
 
-/* Deprecated. */
+// Deprecated.
 #define spcini_errmsg spc_errmsg
 #define spcprt_errmsg spc_errmsg
 #define spcset_errmsg spc_errmsg
@@ -916,4 +913,4 @@ int spctrn(const char ctypeS1[9], double
 }
 #endif
 
-#endif /* WCSLIB_SPC */
+#endif // WCSLIB_SPC
Index: astropy-4.2/cextern/wcslib/C/sph.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/sph.c
+++ astropy-4.2/cextern/wcslib/C/sph.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: sph.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: sph.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -33,7 +30,7 @@
 
 #define tol 1.0e-5
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sphx2s(
   const double eul[5],
@@ -64,10 +61,10 @@ int sphx2s(
   }
 
 
-  /* Check for special-case rotations. */
+  // Check for special-case rotations.
   if (eul[4] == 0.0) {
     if (eul[1] == 0.0) {
-      /* Simple change in origin of longitude. */
+      // Simple change in origin of longitude.
       dlng = fmod(eul[0] + 180.0 - eul[2], 360.0);
 
       jphi   = 0;
@@ -80,7 +77,7 @@ int sphx2s(
           *lngp = *phip + dlng;
           *latp = *thetap;
 
-          /* Normalize the celestial longitude. */
+          // Normalize the celestial longitude.
           if (eul[0] >= 0.0) {
             if (*lngp < 0.0) *lngp += 360.0;
           } else {
@@ -99,7 +96,7 @@ int sphx2s(
       }
 
     } else {
-      /* Pole-flip with change in origin of longitude. */
+      // Pole-flip with change in origin of longitude.
       dlng = fmod(eul[0] + eul[2], 360.0);
 
       jphi   = 0;
@@ -112,7 +109,7 @@ int sphx2s(
           *lngp = dlng - *phip;
           *latp = -(*thetap);
 
-          /* Normalize the celestial longitude. */
+          // Normalize the celestial longitude.
           if (eul[0] >= 0.0) {
             if (*lngp < 0.0) *lngp += 360.0;
           } else {
@@ -135,7 +132,7 @@ int sphx2s(
   }
 
 
-  /* Do phi dependency. */
+  // Do phi dependency.
   phip = phi;
   rowoff = 0;
   rowlen = nphi*sll;
@@ -150,7 +147,7 @@ int sphx2s(
   }
 
 
-  /* Do theta dependency. */
+  // Do theta dependency.
   thetap = theta;
   lngp = lng;
   latp = lat;
@@ -165,10 +162,10 @@ int sphx2s(
       dphi = *lngp;
       sincosd(dphi, &sinphi, &cosphi);
 
-      /* Compute the celestial longitude. */
+      // Compute the celestial longitude.
       x = sinthe4 - costhe3*cosphi;
       if (fabs(x) < tol) {
-        /* Rearrange formula to reduce roundoff errors. */
+        // Rearrange formula to reduce roundoff errors.
         x = -cosd(*thetap + eul[1]) + costhe3*(1.0 - cosphi);
       }
 
@@ -176,7 +173,7 @@ int sphx2s(
       if (x != 0.0 || y != 0.0) {
         dlng = atan2d(y, x);
       } else {
-        /* Change of origin of longitude. */
+        // Change of origin of longitude.
         if (eul[1] < 90.0) {
           dlng =  dphi + 180.0;
         } else {
@@ -185,7 +182,7 @@ int sphx2s(
       }
       *lngp = eul[0] + dlng;
 
-      /* Normalize the celestial longitude. */
+      // Normalize the celestial longitude.
       if (eul[0] >= 0.0) {
         if (*lngp < 0.0) *lngp += 360.0;
       } else {
@@ -198,7 +195,7 @@ int sphx2s(
         *lngp += 360.0;
       }
 
-      /* Compute the celestial latitude. */
+      // Compute the celestial latitude.
       if (fmod(dphi,180.0) == 0.0) {
         *latp = *thetap + cosphi*eul[1];
         if (*latp >  90.0) *latp =  180.0 - *latp;
@@ -206,7 +203,7 @@ int sphx2s(
       } else {
         z = sinthe3 + costhe4*cosphi;
         if (fabs(z) > 0.99) {
-          /* Use an alternative formula for greater accuracy. */
+          // Use an alternative formula for greater accuracy.
           *latp = copysign(acosd(sqrt(x*x+y*y)), z);
         } else {
           *latp = asind(z);
@@ -218,7 +215,7 @@ int sphx2s(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sphs2x(
   const double eul[5],
@@ -249,10 +246,10 @@ int sphs2x(
   }
 
 
-  /* Check for special-case rotations. */
+  // Check for special-case rotations.
   if (eul[4] == 0.0) {
     if (eul[1] == 0.0) {
-      /* Simple change in origin of longitude. */
+      // Simple change in origin of longitude.
       dphi = fmod(eul[2] - 180.0 - eul[0], 360.0);
 
       jlng   = 0;
@@ -265,7 +262,7 @@ int sphs2x(
           *phip = fmod(*lngp + dphi, 360.0);
           *thetap = *latp;
 
-          /* Normalize the native longitude. */
+          // Normalize the native longitude.
           if (*phip > 180.0) {
             *phip -= 360.0;
           } else if (*phip < -180.0) {
@@ -278,7 +275,7 @@ int sphs2x(
       }
 
     } else {
-      /* Pole-flip with change in origin of longitude. */
+      // Pole-flip with change in origin of longitude.
       dphi = fmod(eul[2] + eul[0], 360.0);
 
       jlng   = 0;
@@ -291,7 +288,7 @@ int sphs2x(
           *phip = fmod(dphi - *lngp, 360.0);
           *thetap = -(*latp);
 
-          /* Normalize the native longitude. */
+          // Normalize the native longitude.
           if (*phip > 180.0) {
             *phip -= 360.0;
           } else if (*phip < -180.0) {
@@ -308,7 +305,7 @@ int sphs2x(
   }
 
 
-  /* Do lng dependency. */
+  // Do lng dependency.
   lngp = lng;
   rowoff = 0;
   rowlen = nlng*spt;
@@ -324,7 +321,7 @@ int sphs2x(
   }
 
 
-  /* Do lat dependency. */
+  // Do lat dependency.
   latp = lat;
   phip   = phi;
   thetap = theta;
@@ -339,10 +336,10 @@ int sphs2x(
       dlng = *phip;
       sincosd(dlng, &sinlng, &coslng);
 
-      /* Compute the native longitude. */
+      // Compute the native longitude.
       x = sinlat4 - coslat3*coslng;
       if (fabs(x) < tol) {
-        /* Rearrange formula to reduce roundoff errors. */
+        // Rearrange formula to reduce roundoff errors.
         x = -cosd(*latp+eul[1]) + coslat3*(1.0 - coslng);
       }
 
@@ -350,7 +347,7 @@ int sphs2x(
       if (x != 0.0 || y != 0.0) {
         dphi = atan2d(y, x);
       } else {
-        /* Change of origin of longitude. */
+        // Change of origin of longitude.
         if (eul[1] < 90.0) {
           dphi =  dlng - 180.0;
         } else {
@@ -359,14 +356,14 @@ int sphs2x(
       }
       *phip = fmod(eul[2] + dphi, 360.0);
 
-      /* Normalize the native longitude. */
+      // Normalize the native longitude.
       if (*phip > 180.0) {
         *phip -= 360.0;
       } else if (*phip < -180.0) {
         *phip += 360.0;
       }
 
-      /* Compute the native latitude. */
+      // Compute the native latitude.
       if (fmod(dlng,180.0) == 0.0) {
         *thetap = *latp + coslng*eul[1];
         if (*thetap >  90.0) *thetap =  180.0 - *thetap;
@@ -374,7 +371,7 @@ int sphs2x(
       } else {
         z = sinlat3 + coslat4*coslng;
         if (fabs(z) > 0.99) {
-          /* Use an alternative formula for greater accuracy. */
+          // Use an alternative formula for greater accuracy.
           *thetap = copysign(acosd(sqrt(x*x+y*y)), z);
         } else {
           *thetap = asind(z);
@@ -386,7 +383,7 @@ int sphs2x(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sphdpa(
   int nfield,
@@ -401,21 +398,21 @@ int sphdpa(
   int i;
   double eul[5];
 
-  /* Set the Euler angles for the coordinate transformation. */
+  // Set the Euler angles for the coordinate transformation.
   eul[0] = lng0;
   eul[1] = 90.0 - lat0;
   eul[2] = 0.0;
   eul[3] = cosd(eul[1]);
   eul[4] = sind(eul[1]);
 
-  /* Transform field points to the new system. */
+  // Transform field points to the new system.
   sphs2x(eul, nfield, 0, 1, 1, lng, lat, pa, dist);
 
   for (i = 0; i < nfield; i++) {
-    /* Angular distance is obtained from latitude in the new frame. */
+    // Angular distance is obtained from latitude in the new frame.
     dist[i] = 90.0 - dist[i];
 
-    /* Position angle is obtained from longitude in the new frame. */
+    // Position angle is obtained from longitude in the new frame.
     pa[i] = -pa[i];
     if (pa[i] < -180.0) pa[i] += 360.0;
   }
@@ -423,7 +420,7 @@ int sphdpa(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int sphpad(
   int nfield,
@@ -438,7 +435,7 @@ int sphpad(
   int i;
   double eul[5];
 
-  /* Set the Euler angles for the coordinate transformation. */
+  // Set the Euler angles for the coordinate transformation.
   eul[0] = lng0;
   eul[1] = 90.0 - lat0;
   eul[2] = 0.0;
@@ -446,14 +443,14 @@ int sphpad(
   eul[4] = sind(eul[1]);
 
   for (i = 0; i < nfield; i++) {
-    /* Latitude in the new frame is obtained from angular distance. */
+    // Latitude in the new frame is obtained from angular distance.
     lat[i] = 90.0 - dist[i];
 
-    /* Longitude in the new frame is obtained from position angle. */
+    // Longitude in the new frame is obtained from position angle.
     lng[i] = -pa[i];
   }
 
-  /* Transform field points to the old system. */
+  // Transform field points to the old system.
   sphx2s(eul, nfield, 0, 1, 1, lng, lat, lng, lat);
 
   return 0;
Index: astropy-4.2/cextern/wcslib/C/sph.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/sph.h
+++ astropy-4.2/cextern/wcslib/C/sph.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: sph.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: sph.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -144,41 +141,41 @@
 *                         0: Success.
 *
 * Notes:
-*   sphdpa() uses sphs2x() to rotate coordinates so that the reference point
-*   is at the north pole of the new system with the north pole of the old
-*   system at zero longitude in the new.  The Euler angles required by
-*   sphs2x() for this rotation are
-*
-=     eul[0] = lng0;
-=     eul[1] = 90.0 - lat0;
-=     eul[2] =  0.0;
-*
-*   The angular distance and generalized position angle are readily obtained
-*   from the longitude and latitude of the field point in the new system.
-*   This applies even if the reference point is at one of the poles, in which
-*   case the "position angle" returned is as would be computed for a reference
-*   point at (lng0,+90-epsilon) or (lng0,-90+epsilon), in the limit as epsilon
-*   goes to zero.
-*
-*   It is evident that the coordinate system in which the two points are
-*   expressed is irrelevant to the determination of the angular separation
-*   between the points.  However, this is not true of the generalized position
-*   angle.
-*
-*   The generalized position angle is here defined as the angle of
-*   intersection of the great circle containing the reference and field points
-*   with that containing the reference point and the pole.  It has its normal
-*   meaning when the the reference and field points are specified in
-*   equatorial coordinates (right ascension and declination).
-*
-*   Interchanging the reference and field points changes the position angle in
-*   a non-intuitive way (because the sum of the angles of a spherical triangle
-*   normally exceeds 180 degrees).
-*
-*   The position angle is undefined if the reference and field points are
-*   coincident or antipodal.  This may be detected by checking for a distance
-*   of 0 or 180 degrees (within rounding tolerance).  sphdpa() will return an
-*   arbitrary position angle in such circumstances.
+*   1. sphdpa() uses sphs2x() to rotate coordinates so that the reference
+*      point is at the north pole of the new system with the north pole of the
+*      old system at zero longitude in the new.  The Euler angles required by
+*      sphs2x() for this rotation are
+*
+=        eul[0] = lng0;
+=        eul[1] = 90.0 - lat0;
+=        eul[2] =  0.0;
+*
+*      The angular distance and generalized position angle are readily
+*      obtained from the longitude and latitude of the field point in the new
+*      system.  This applies even if the reference point is at one of the
+*      poles, in which case the "position angle" returned is as would be
+*      computed for a reference point at (lng0,+90-epsilon) or
+*      (lng0,-90+epsilon), in the limit as epsilon goes to zero.
+*
+*      It is evident that the coordinate system in which the two points are
+*      expressed is irrelevant to the determination of the angular separation
+*      between the points.  However, this is not true of the generalized
+*      position angle.
+*
+*      The generalized position angle is here defined as the angle of
+*      intersection of the great circle containing the reference and field
+*      points with that containing the reference point and the pole.  It has
+*      its normal meaning when the the reference and field points are
+*      specified in equatorial coordinates (right ascension and declination).
+*
+*      Interchanging the reference and field points changes the position angle
+*      in a non-intuitive way (because the sum of the angles of a spherical
+*      triangle normally exceeds 180 degrees).
+*
+*      The position angle is undefined if the reference and field points are
+*      coincident or antipodal.  This may be detected by checking for a
+*      distance of 0 or 180 degrees (within rounding tolerance).  sphdpa()
+*      will return an arbitrary position angle in such circumstances.
 *
 *
 * sphpad() - Compute field points offset from a given point
@@ -208,11 +205,11 @@
 *                         0: Success.
 *
 * Notes:
-*   sphpad() is implemented analogously to sphdpa() although using sphx2s()
-*   for the inverse transformation.  In particular, when the reference point
-*   is at one of the poles, "position angle" is interpreted as though the
-*   reference point was at (lng0,+90-epsilon) or (lng0,-90+epsilon), in the
-*   limit as epsilon goes to zero.
+*   1: sphpad() is implemented analogously to sphdpa() although using sphx2s()
+*      for the inverse transformation.  In particular, when the reference
+*      point is at one of the poles, "position angle" is interpreted as though
+*      the reference point was at (lng0,+90-epsilon) or (lng0,-90+epsilon), in
+*      the limit as epsilon goes to zero.
 *
 *   Applying sphpad() with the distances and position angles computed by
 *   sphdpa() should return the original field points.
@@ -248,4 +245,4 @@ int sphpad(int nfield, double lng0, doub
 }
 #endif
 
-#endif /* WCSLIB_SPH */
+#endif // WCSLIB_SPH
Index: astropy-4.2/cextern/wcslib/C/spx.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/spx.c
+++ astropy-4.2/cextern/wcslib/C/spx.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: spx.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: spx.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -34,7 +31,7 @@
 #include "spx.h"
 
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *spx_errmsg[] = {
   "Success",
   "Null spxprm pointer passed",
@@ -42,7 +39,7 @@ const char *spx_errmsg[] = {
   "Invalid spectral variable",
   "One or more of the inspec coordinates were invalid"};
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define SPX_ERRMSG(status) WCSERR_SET(status), spx_errmsg[status]
 
 #define C 2.99792458e8
@@ -75,10 +72,10 @@ int specx(
   haverest = 1;
   if (restfrq == 0.0) {
     if (restwav == 0.0) {
-      /* No line rest frequency supplied. */
+      // No line rest frequency supplied.
       haverest = 0;
 
-      /* Temporarily set a dummy value for conversions. */
+      // Temporarily set a dummy value for conversions.
       spx->restwav = 1.0;
     } else {
       spx->restwav = restwav;
@@ -92,7 +89,7 @@ int specx(
 
   spx->err = 0x0;
 
-  /* Convert to frequency. */
+  // Convert to frequency.
   spx->wavetype = 0;
   spx->velotype = 0;
   if (strcmp(type, "FREQ") == 0) {
@@ -188,13 +185,13 @@ int specx(
     spx->velotype = 1;
 
   } else {
-    /* Unrecognized type. */
+    // Unrecognized type.
     return wcserr_set(WCSERR_SET(SPXERR_BAD_SPEC_PARAMS),
       "Unrecognized spectral type '%s'", type);
   }
 
 
-  /* Convert frequency to the other spectral types. */
+  // Convert frequency to the other spectral types.
   n = 1.0;
   for (k = 0; k < 4; k++) {
     s = n*spx->freq/C;
@@ -219,7 +216,7 @@ int specx(
   spx->velo = C*(1.0 - s*s)/(1.0 + s*s);
   spx->beta = spx->velo/C;
 
-  /* Compute the required derivatives. */
+  // Compute the required derivatives.
   gamma = 1.0/sqrt(1.0 - spx->beta*spx->beta);
 
   spx->dfreqafrq = 1.0/(2.0*PI);
@@ -262,7 +259,7 @@ int specx(
   spx->dbetavelo = 1.0/spx->dvelobeta;
 
 
-  /* Reset values if no line rest frequency was supplied. */
+  // Reset values if no line rest frequency was supplied.
   if (haverest) {
     spx->wavetype = 1;
     spx->velotype = 1;
@@ -272,7 +269,7 @@ int specx(
     spx->restwav = 0.0;
 
     if (!spx->wavetype) {
-      /* Don't have wave characteristic types. */
+      // Don't have wave characteristic types.
       spx->freq = 0.0;
       spx->afrq = 0.0;
       spx->ener = 0.0;
@@ -290,7 +287,7 @@ int specx(
       spx->dawavwave = 0.0;
 
     } else {
-      /* Don't have velocity types. */
+      // Don't have velocity types.
       spx->vrad = 0.0;
       spx->vopt = 0.0;
       spx->zopt = 0.0;
@@ -320,7 +317,7 @@ int specx(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spxperr(const struct spxprm *spx, const char *prefix)
 
@@ -354,7 +351,7 @@ int freqwave(
   register const double *freqp;
   register double *wavep;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   freqp = freq;
@@ -376,7 +373,7 @@ int freqwave(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wavefreq(
   double dummy,
@@ -393,7 +390,7 @@ int wavefreq(
   register const double *wavep;
   register double *freqp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   wavep = wave;
@@ -438,7 +435,7 @@ int freqawav(
   return waveawav(dummy, nfreq, sawav, sawav, awav, awav, stat);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int awavfreq(
   double dummy,
@@ -495,7 +492,7 @@ int freqvelo(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int velofreq(
   double restfrq,
@@ -553,7 +550,7 @@ int waveawav(
   register const double *wavep;
   register double *awavp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   wavep = wave;
@@ -584,7 +581,7 @@ int waveawav(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int awavwave(
   double dummy,
@@ -602,7 +599,7 @@ int awavwave(
   register const double *awavp;
   register double *wavep;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   awavp = awav;
@@ -665,7 +662,7 @@ int wavevelo(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int velowave(
   double restwav,
@@ -726,7 +723,7 @@ int awavvelo(
   return wavevelo(dummy, nawav, svelo, svelo, velo, velo, stat);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int veloawav(
   double dummy,
@@ -765,7 +762,7 @@ int freqafrq(
   register const double *freqp;
   register double *afrqp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   freqp = freq;
@@ -782,7 +779,7 @@ int freqafrq(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int afrqfreq(
   double dummy,
@@ -798,7 +795,7 @@ int afrqfreq(
   register const double *afrqp;
   register double *freqp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   afrqp = afrq;
@@ -833,7 +830,7 @@ int freqener(
   register const double *freqp;
   register double *enerp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   freqp = freq;
@@ -850,7 +847,7 @@ int freqener(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int enerfreq(
   double dummy,
@@ -866,7 +863,7 @@ int enerfreq(
   register const double *enerp;
   register double *freqp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   enerp = ener;
@@ -901,7 +898,7 @@ int freqwavn(
   register const double *freqp;
   register double *wavnp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   freqp = freq;
@@ -918,7 +915,7 @@ int freqwavn(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wavnfreq(
   double dummy,
@@ -934,7 +931,7 @@ int wavnfreq(
   register const double *wavnp;
   register double *freqp;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   wavnp = wavn;
@@ -989,7 +986,7 @@ int freqvrad(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int vradfreq(
   double restfrq,
@@ -1058,7 +1055,7 @@ int wavevopt(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int voptwave(
   double restwav,
@@ -1127,7 +1124,7 @@ int wavezopt(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int zoptwave(
   double restwav,
@@ -1174,7 +1171,7 @@ int velobeta(
   register const double *velop;
   register double *betap;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   velop = velo;
@@ -1191,7 +1188,7 @@ int velobeta(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int betavelo(
   double dummy,
@@ -1207,7 +1204,7 @@ int betavelo(
   register const double *betap;
   register double *velop;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   betap = beta;
Index: astropy-4.2/cextern/wcslib/C/spx.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/spx.h
+++ astropy-4.2/cextern/wcslib/C/spx.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: spx.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: spx.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -477,60 +474,60 @@ extern "C" {
 extern const char *spx_errmsg[];
 
 enum spx_errmsg {
-  SPXERR_SUCCESS          = 0,	/* Success. */
-  SPXERR_NULL_POINTER     = 1,	/* Null spxprm pointer passed. */
-  SPXERR_BAD_SPEC_PARAMS  = 2,	/* Invalid spectral parameters. */
-  SPXERR_BAD_SPEC_VAR     = 3,	/* Invalid spectral variable. */
-  SPXERR_BAD_INSPEC_COORD = 4 	/* One or more of the inspec coordinates were
-				   invalid. */
+  SPXERR_SUCCESS          = 0,	// Success.
+  SPXERR_NULL_POINTER     = 1,	// Null spxprm pointer passed.
+  SPXERR_BAD_SPEC_PARAMS  = 2,	// Invalid spectral parameters.
+  SPXERR_BAD_SPEC_VAR     = 3,	// Invalid spectral variable.
+  SPXERR_BAD_INSPEC_COORD = 4 	// One or more of the inspec coordinates were
+				// invalid.
 };
 
 struct spxprm {
-  double restfrq, restwav;	/* Rest frequency [Hz] and wavelength [m].  */
+  double restfrq, restwav;	// Rest frequency [Hz] and wavelength [m].
 
-  int wavetype, velotype;	/* True if wave/velocity types have been    */
-				/* computed; types are defined below.       */
+  int wavetype, velotype;	// True if wave/velocity types have been
+				// computed; types are defined below.
 
-  /* Spectral variables computed by specx().                                */
-  /*------------------------------------------------------------------------*/
-  double freq,			/* wavetype: Frequency [Hz].                */
-         afrq,			/* wavetype: Angular frequency [rad/s].     */
-         ener,			/* wavetype: Photon energy [J].             */
-         wavn,			/* wavetype: Wave number [/m].              */
-         vrad,			/* velotype: Radio velocity [m/s].          */
-         wave,			/* wavetype: Vacuum wavelength [m].         */
-         vopt,			/* velotype: Optical velocity [m/s].        */
-         zopt,			/* velotype: Redshift.                      */
-         awav,			/* wavetype: Air wavelength [m].            */
-         velo,			/* velotype: Relativistic velocity [m/s].   */
-         beta;			/* velotype: Relativistic beta.             */
-
-  /* Derivatives of spectral variables computed by specx().                 */
-  /*------------------------------------------------------------------------*/
-  double dfreqafrq, dafrqfreq,	/* Constant, always available.              */
-         dfreqener, denerfreq,	/* Constant, always available.              */
-         dfreqwavn, dwavnfreq,	/* Constant, always available.              */
-         dfreqvrad, dvradfreq,	/* wavetype && velotype.                    */
-         dfreqwave, dwavefreq,	/* wavetype.                                */
-         dfreqawav, dawavfreq,	/* wavetype.                                */
-         dfreqvelo, dvelofreq,	/* wavetype && velotype.                    */
-         dwavevopt, dvoptwave,	/* wavetype && velotype.                    */
-         dwavezopt, dzoptwave,	/* wavetype && velotype.                    */
-         dwaveawav, dawavwave,	/* wavetype.                                */
-         dwavevelo, dvelowave,	/* wavetype && velotype.                    */
-         dawavvelo, dveloawav,	/* wavetype && velotype.                    */
-         dvelobeta, dbetavelo;	/* Constant, always available.              */
+  // Spectral variables computed by specx().
+  //--------------------------------------------------------------------------
+  double freq,			// wavetype: Frequency [Hz].
+         afrq,			// wavetype: Angular frequency [rad/s].
+         ener,			// wavetype: Photon energy [J].
+         wavn,			// wavetype: Wave number [/m].
+         vrad,			// velotype: Radio velocity [m/s].
+         wave,			// wavetype: Vacuum wavelength [m].
+         vopt,			// velotype: Optical velocity [m/s].
+         zopt,			// velotype: Redshift.
+         awav,			// wavetype: Air wavelength [m].
+         velo,			// velotype: Relativistic velocity [m/s].
+         beta;			// velotype: Relativistic beta.
+
+  // Derivatives of spectral variables computed by specx().
+  //--------------------------------------------------------------------------
+  double dfreqafrq, dafrqfreq,	// Constant, always available.
+         dfreqener, denerfreq,	// Constant, always available.
+         dfreqwavn, dwavnfreq,	// Constant, always available.
+         dfreqvrad, dvradfreq,	// wavetype && velotype.
+         dfreqwave, dwavefreq,	// wavetype.
+         dfreqawav, dawavfreq,	// wavetype.
+         dfreqvelo, dvelofreq,	// wavetype && velotype.
+         dwavevopt, dvoptwave,	// wavetype && velotype.
+         dwavezopt, dzoptwave,	// wavetype && velotype.
+         dwaveawav, dawavwave,	// wavetype.
+         dwavevelo, dvelowave,	// wavetype && velotype.
+         dawavvelo, dveloawav,	// wavetype && velotype.
+         dvelobeta, dbetavelo;	// Constant, always available.
 
-  /* Error handling                                                         */
-  /*------------------------------------------------------------------------*/
+  // Error handling
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private                                                                */
-  /*------------------------------------------------------------------------*/
-  void   *padding;		/* (Dummy inserted for alignment purposes.) */
+  // Private
+  //--------------------------------------------------------------------------
+  void   *padding;		// (Dummy inserted for alignment purposes.)
 };
 
-/* Size of the spxprm struct in int units, used by the Fortran wrappers. */
+// Size of the spxprm struct in int units, used by the Fortran wrappers.
 #define SPXLEN (sizeof(struct spxprm)/sizeof(int))
 
 
@@ -539,7 +536,7 @@ int specx(const char *type, double spec,
 
 int spxperr(const struct spxprm *spx, const char *prefix);
 
-/* For use in declaring function prototypes, e.g. in spcprm. */
+// For use in declaring function prototypes, e.g. in spcprm.
 #define SPX_ARGS double param, int nspec, int instep, int outstep, \
     const double inspec[], double outspec[], int stat[]
 
@@ -589,4 +586,4 @@ int zoptwave(SPX_ARGS);
 }
 #endif
 
-#endif /* WCSLIB_SPEC */
+#endif // WCSLIB_SPEC
Index: astropy-4.2/cextern/wcslib/C/tab.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/tab.c
+++ astropy-4.2/cextern/wcslib/C/tab.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: tab.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: tab.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -38,7 +35,7 @@
 
 const int TABSET = 137;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *tab_errmsg[] = {
   "Success",
   "Null tabprm pointer passed",
@@ -47,10 +44,10 @@ const char *tab_errmsg[] = {
   "One or more of the x coordinates were invalid",
   "One or more of the world coordinates were invalid"};
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define TAB_ERRMSG(status) WCSERR_SET(status), tab_errmsg[status]
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabini(int alloc, int M, const int K[], struct tabprm *tab)
 
@@ -63,7 +60,7 @@ int tabini(int alloc, int M, const int K
 
   if (tab == 0x0) return TABERR_NULL_POINTER;
 
-  /* Initialize error message handling. */
+  // Initialize error message handling.
   if (tab->flag == -1) {
     tab->err = 0x0;
   }
@@ -76,7 +73,7 @@ int tabini(int alloc, int M, const int K
       "M must be positive, got %d", M);
   }
 
-  /* Determine the total number of elements in the coordinate array. */
+  // Determine the total number of elements in the coordinate array.
   if (K) {
     N = M;
 
@@ -91,12 +88,12 @@ int tabini(int alloc, int M, const int K
     }
 
   } else {
-    /* Axis lengths as yet unknown. */
+    // Axis lengths as yet unknown.
     N = 0;
   }
 
 
-  /* Initialize memory management. */
+  // Initialize memory management.
   if (tab->flag == -1 || tab->m_flag != TABSET) {
     if (tab->flag == -1) {
       tab->sense   = 0x0;
@@ -117,7 +114,7 @@ int tabini(int alloc, int M, const int K
     tab->m_coord = 0x0;
 
   } else {
-    /* Clear any outstanding signals set by wcstab(). */
+    // Clear any outstanding signals set by wcstab().
     for (m = 0; m < tab->m_M; m++) {
       if (tab->m_indxs[m] == (double *)0x1) tab->m_indxs[m] = 0x0;
     }
@@ -126,7 +123,7 @@ int tabini(int alloc, int M, const int K
   }
 
 
-  /* Allocate memory for arrays if required. */
+  // Allocate memory for arrays if required.
   if (alloc ||
      tab->K == 0x0 ||
      tab->map == 0x0 ||
@@ -134,15 +131,15 @@ int tabini(int alloc, int M, const int K
      tab->index == 0x0 ||
      tab->coord == 0x0) {
 
-    /* Was sufficient allocated previously? */
+    // Was sufficient allocated previously?
     if (tab->m_flag == TABSET && (tab->m_M < M || tab->m_N < N)) {
-      /* No, free it. */
+      // No, free it.
       tabfree(tab);
     }
 
     if (alloc || tab->K == 0x0) {
       if (tab->m_K) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         tab->K = tab->m_K;
 
       } else {
@@ -158,7 +155,7 @@ int tabini(int alloc, int M, const int K
 
     if (alloc || tab->map == 0x0) {
       if (tab->m_map) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         tab->map = tab->m_map;
 
       } else {
@@ -174,7 +171,7 @@ int tabini(int alloc, int M, const int K
 
     if (alloc || tab->crval == 0x0) {
       if (tab->m_crval) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         tab->crval = tab->m_crval;
 
       } else {
@@ -190,7 +187,7 @@ int tabini(int alloc, int M, const int K
 
     if (alloc || tab->index == 0x0) {
       if (tab->m_index) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         tab->index = tab->m_index;
 
       } else {
@@ -207,7 +204,7 @@ int tabini(int alloc, int M, const int K
           return wcserr_set(TAB_ERRMSG(TABERR_MEMORY));
         }
 
-        /* Recall that calloc() initializes these pointers to zero. */
+        // Recall that calloc() initializes these pointers to zero.
         if (K) {
           for (m = 0; m < M; m++) {
             if (K[m]) {
@@ -224,7 +221,7 @@ int tabini(int alloc, int M, const int K
 
     if (alloc || tab->coord == 0x0) {
       if (tab->m_coord) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         tab->coord = tab->m_coord;
 
       } else if (N) {
@@ -243,7 +240,7 @@ int tabini(int alloc, int M, const int K
   tab->flag = 0;
   tab->M = M;
 
-  /* Set defaults. */
+  // Set defaults.
   for (m = 0; m < M; m++) {
     tab->map[m] = -1;
     tab->crval[m] = 0.0;
@@ -260,7 +257,7 @@ int tabini(int alloc, int M, const int K
     }
   }
 
-  /* Initialize the coordinate array. */
+  // Initialize the coordinate array.
   for (dp = tab->coord; dp < tab->coord + N; dp++) {
     *dp = UNDEFINED;
   }
@@ -268,7 +265,7 @@ int tabini(int alloc, int M, const int K
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabmem(struct tabprm *tab)
 
@@ -282,7 +279,7 @@ int tabmem(struct tabprm *tab)
   err = &(tab->err);
 
   if (tab->M == 0 || tab->K == 0x0) {
-    /* Should have been set by this time. */
+    // Should have been set by this time.
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "Null pointers in tabprm struct");
   }
@@ -303,7 +300,7 @@ int tabmem(struct tabprm *tab)
   if (tab->m_M == 0) {
     tab->m_M = M;
   } else if (tab->m_M < M) {
-    /* Only possible if the user changed M. */
+    // Only possible if the user changed M.
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "tabprm struct inconsistent");
   }
@@ -311,7 +308,7 @@ int tabmem(struct tabprm *tab)
   if (tab->m_N == 0) {
     tab->m_N = N;
   } else if (tab->m_N < N) {
-    /* Only possible if the user changed K[]. */
+    // Only possible if the user changed K[].
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "tabprm struct inconsistent");
   }
@@ -359,7 +356,7 @@ int tabmem(struct tabprm *tab)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabcpy(int alloc, const struct tabprm *tabsrc, struct tabprm *tabdst)
 
@@ -409,7 +406,7 @@ int tabcpy(int alloc, const struct tabpr
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabcmp(
   int dummy,
@@ -421,7 +418,7 @@ int tabcmp(
 {
   int m, M, N;
 
-  /* Avert nuisance compiler warnings about unused parameters. */
+  // Avert nuisance compiler warnings about unused parameters.
   (void)dummy;
 
   if (tab1  == 0x0) return TABERR_NULL_POINTER;
@@ -461,7 +458,7 @@ int tabcmp(
 }
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabfree(struct tabprm *tab)
 
@@ -471,14 +468,14 @@ int tabfree(struct tabprm *tab)
   if (tab == 0x0) return TABERR_NULL_POINTER;
 
   if (tab->flag != -1) {
-    /* Clear any outstanding signals set by wcstab(). */
+    // Clear any outstanding signals set by wcstab().
     for (m = 0; m < tab->m_M; m++) {
       if (tab->m_indxs[m] == (double *)0x1) tab->m_indxs[m] = 0x0;
     }
 
     if (tab->m_coord == (double *)0x1) tab->m_coord = 0x0;
 
-    /* Free memory allocated by tabini(). */
+    // Free memory allocated by tabini().
     if (tab->m_flag == TABSET) {
       if (tab->K     == tab->m_K)     tab->K = 0x0;
       if (tab->map   == tab->m_map)   tab->map = 0x0;
@@ -501,7 +498,7 @@ int tabfree(struct tabprm *tab)
       if (tab->m_coord) free(tab->m_coord);
     }
 
-    /* Free memory allocated by tabset(). */
+    // Free memory allocated by tabset().
     if (tab->sense)   free(tab->sense);
     if (tab->p0)      free(tab->p0);
     if (tab->delta)   free(tab->delta);
@@ -531,7 +528,7 @@ int tabfree(struct tabprm *tab)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabprt(const struct tabprm *tab)
 
@@ -550,7 +547,7 @@ int tabprt(const struct tabprm *tab)
   wcsprintf("       flag: %d\n", tab->flag);
   wcsprintf("          M: %d\n", tab->M);
 
-  /* Array dimensions. */
+  // Array dimensions.
   WCSPRINTF_PTR("          K: ", tab->K, "\n");
   wcsprintf("            ");
   for (m = 0; m < tab->M; m++) {
@@ -558,7 +555,7 @@ int tabprt(const struct tabprm *tab)
   }
   wcsprintf("\n");
 
-  /* Map vector. */
+  // Map vector.
   WCSPRINTF_PTR("        map: ", tab->map, "\n");
   wcsprintf("            ");
   for (m = 0; m < tab->M; m++) {
@@ -566,7 +563,7 @@ int tabprt(const struct tabprm *tab)
   }
   wcsprintf("\n");
 
-  /* Reference index value. */
+  // Reference index value.
   WCSPRINTF_PTR("      crval: ", tab->crval, "\n");
   wcsprintf("            ");
   for (m = 0; m < tab->M; m++) {
@@ -574,7 +571,7 @@ int tabprt(const struct tabprm *tab)
   }
   wcsprintf("\n");
 
-  /* Index vectors. */
+  // Index vectors.
   WCSPRINTF_PTR("      index: ", tab->index, "\n");
   for (m = 0; m < tab->M; m++) {
     wcsprintf("   index[%d]: ", m);
@@ -590,11 +587,11 @@ int tabprt(const struct tabprm *tab)
     }
   }
 
-  /* Coordinate array. */
+  // Coordinate array.
   WCSPRINTF_PTR("      coord: ", tab->coord, "\n");
   dp = tab->coord;
   for (n = 0; n < tab->nc; n++) {
-    /* Array index. */
+    // Array index.
     j = n;
     cp = text;
     for (m = 0; m < tab->M; m++) {
@@ -643,7 +640,7 @@ int tabprt(const struct tabprm *tab)
   WCSPRINTF_PTR("    extrema: ", tab->extrema, "\n");
   dp = tab->extrema;
   for (n = 0; n < tab->nc/tab->K[0]; n++) {
-    /* Array index. */
+    // Array index.
     j = n;
     cp = text;
     *cp = '\0';
@@ -667,7 +664,7 @@ int tabprt(const struct tabprm *tab)
     wcserr_prt(tab->err, "             ");
   }
 
-  /* Memory management. */
+  // Memory management.
   wcsprintf("     m_flag: %d\n", tab->m_flag);
   wcsprintf("        m_M: %d\n", tab->m_M);
   wcsprintf("        m_N: %d\n", tab->m_N);
@@ -701,7 +698,7 @@ int tabprt(const struct tabprm *tab)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabperr(const struct tabprm *tab, const char *prefix)
 
@@ -715,7 +712,7 @@ int tabperr(const struct tabprm *tab, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabset(struct tabprm *tab)
 
@@ -729,13 +726,13 @@ int tabset(struct tabprm *tab)
   if (tab == 0x0) return TABERR_NULL_POINTER;
   err = &(tab->err);
 
-  /* Check the number of tabular coordinate axes. */
+  // Check the number of tabular coordinate axes.
   if ((M = tab->M) < 1) {
     return wcserr_set(WCSERR_SET(TABERR_BAD_PARAMS),
       "Invalid tabular parameters: M must be positive, got %d", M);
   }
 
-  /* Check the axis lengths. */
+  // Check the axis lengths.
   if (!tab->K) {
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "Null pointers in tabprm struct");
@@ -749,11 +746,11 @@ int tabset(struct tabprm *tab)
         "got %d", tab->K[m]);
     }
 
-    /* Number of coordinate vectors in the coordinate array. */
+    // Number of coordinate vectors in the coordinate array.
     tab->nc *= tab->K[m];
   }
 
-  /* Check that the map vector is sensible. */
+  // Check that the map vector is sensible.
   if (!tab->map) {
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "Null pointers in tabprm struct");
@@ -768,13 +765,13 @@ int tabset(struct tabprm *tab)
     }
   }
 
-  /* Check memory allocation for the remaining vectors. */
+  // Check memory allocation for the remaining vectors.
   if (!tab->crval || !tab->index || !tab->coord) {
     return wcserr_set(WCSERR_SET(TABERR_MEMORY),
       "Null pointers in tabprm struct");
   }
 
-  /* Take memory if signalled to by wcstab(). */
+  // Take memory if signalled to by wcstab().
   for (m = 0; m < tab->m_M; m++) {
     if (tab->m_indxs[m] == (double *)0x1 &&
       (tab->m_indxs[m] = tab->index[m])) {
@@ -788,15 +785,15 @@ int tabset(struct tabprm *tab)
   }
 
 
-  /* Allocate memory for work vectors. */
+  // Allocate memory for work vectors.
   if (tab->flag != TABSET || tab->set_M < M) {
-    /* Free memory that may have been allocated previously. */
+    // Free memory that may have been allocated previously.
     if (tab->sense)   free(tab->sense);
     if (tab->p0)      free(tab->p0);
     if (tab->delta)   free(tab->delta);
     if (tab->extrema) free(tab->extrema);
 
-    /* Allocate memory for internal arrays. */
+    // Allocate memory for internal arrays.
     if (!(tab->sense = calloc(M, sizeof(int)))) {
       return wcserr_set(TAB_ERRMSG(TABERR_MEMORY));
     }
@@ -823,14 +820,14 @@ int tabset(struct tabprm *tab)
     tab->set_M = M;
   }
 
-  /* Check that the index vectors are monotonic. */
+  // Check that the index vectors are monotonic.
   Km = tab->K;
   for (m = 0; m < M; m++, Km++) {
     tab->sense[m] = 0;
 
     if (*Km > 1) {
       if ((Psi = tab->index[m]) == 0x0) {
-        /* Default indexing. */
+        // Default indexing.
         tab->sense[m] = 1;
 
       } else {
@@ -838,17 +835,17 @@ int tabset(struct tabprm *tab)
           switch (tab->sense[m]) {
           case 0:
             if (Psi[k] < Psi[k+1]) {
-              /* Monotonic increasing. */
+              // Monotonic increasing.
               tab->sense[m] = 1;
             } else if (Psi[k] > Psi[k+1]) {
-              /* Monotonic decreasing. */
+              // Monotonic decreasing.
               tab->sense[m] = -1;
             }
             break;
 
           case 1:
             if (Psi[k] > Psi[k+1]) {
-              /* Should be monotonic increasing. */
+              // Should be monotonic increasing.
               free(tab->sense);
               free(tab->p0);
               free(tab->delta);
@@ -861,7 +858,7 @@ int tabset(struct tabprm *tab)
 
           case -1:
             if (Psi[k] < Psi[k+1]) {
-              /* Should be monotonic decreasing. */
+              // Should be monotonic decreasing.
               free(tab->sense);
               free(tab->p0);
               free(tab->delta);
@@ -886,14 +883,14 @@ int tabset(struct tabprm *tab)
     }
   }
 
-  /* Find the extremal values of the coordinate elements in each row. */
+  // Find the extremal values of the coordinate elements in each row.
   dcrd = tab->coord;
   dmin = tab->extrema;
   dmax = tab->extrema + M;
   for (ic = 0; ic < tab->nc; ic += tab->K[0]) {
     for (m = 0; m < M; m++, dcrd++) {
       if (tab->K[0] > 1) {
-        /* Extrapolate a little before the start of the row. */
+        // Extrapolate a little before the start of the row.
         Psi = tab->index[0];
         if (Psi == 0x0) {
           dPsi = 1.0;
@@ -919,7 +916,7 @@ int tabset(struct tabprm *tab)
         if (*(dmin+m) > *dcrd) *(dmin+m) = *dcrd;
 
         if (tab->K[0] > 1 && i == tab->K[0]-1) {
-          /* Extrapolate a little beyond the end of the row. */
+          // Extrapolate a little beyond the end of the row.
           Psi = tab->index[0];
           if (Psi == 0x0) {
             dPsi = 1.0;
@@ -947,7 +944,7 @@ int tabset(struct tabprm *tab)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int tabx2s(
   struct tabprm *tab,
@@ -970,12 +967,12 @@ int tabx2s(
   if (tab == 0x0) return TABERR_NULL_POINTER;
   err = &(tab->err);
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (tab->flag != TABSET) {
     if ((status = tabset(tab))) return status;
   }
 
-  /* This is used a lot. */
+  // This is used a lot.
   M = tab->M;
 
   status = 0;
@@ -983,25 +980,25 @@ int tabx2s(
   wp = world;
   statp = stat;
   for (n = 0; n < ncoord; n++) {
-    /* Determine the indexes. */
+    // Determine the indexes.
     Km = tab->K;
     for (m = 0; m < M; m++, Km++) {
-      /* N.B. psi_m and Upsilon_m are 1-relative FITS indexes. */
+      // N.B. psi_m and Upsilon_m are 1-relative FITS indexes.
       i = tab->map[m];
       psi_m = *(xp+i) + tab->crval[m];
 
       Psi = tab->index[m];
       if (Psi == 0x0) {
-        /* Default indexing is simple. */
+        // Default indexing is simple.
         upsilon = psi_m;
 
       } else {
-        /* To ease confusion, decrement Psi so that we can use 1-relative
-           C array indexing to match the 1-relative FITS indexing. */
+        // To ease confusion, decrement Psi so that we can use 1-relative
+        // C array indexing to match the 1-relative FITS indexing.
         Psi--;
 
         if (*Km == 1) {
-          /* Index vector is degenerate. */
+          // Index vector is degenerate.
           if (Psi[1]-0.5 <= psi_m && psi_m <= Psi[1]+0.5) {
             upsilon = psi_m;
           } else {
@@ -1011,16 +1008,16 @@ int tabx2s(
           }
 
         } else {
-          /* Interpolate in the indexing vector. */
+          // Interpolate in the indexing vector.
           if (tab->sense[m] == 1) {
-            /* Monotonic increasing index values. */
+            // Monotonic increasing index values.
             if (psi_m < Psi[1]) {
               if (Psi[1] - 0.5*(Psi[2]-Psi[1]) <= psi_m) {
-                /* Allow minor extrapolation. */
+                // Allow minor extrapolation.
                 k = 1;
 
               } else {
-                /* Index is out of range. */
+                // Index is out of range.
                 *statp = 1;
                 status = wcserr_set(TAB_ERRMSG(TABERR_BAD_X));
                 goto next;
@@ -1028,11 +1025,11 @@ int tabx2s(
 
             } else if (Psi[*Km] < psi_m) {
               if (psi_m <= Psi[*Km] + 0.5*(Psi[*Km]-Psi[*Km-1])) {
-                /* Allow minor extrapolation. */
+                // Allow minor extrapolation.
                 k = *Km - 1;
 
               } else {
-                /* Index is out of range. */
+                // Index is out of range.
                 *statp = 1;
                 status = wcserr_set(TAB_ERRMSG(TABERR_BAD_X));
                 goto next;
@@ -1053,14 +1050,14 @@ int tabx2s(
             }
 
           } else {
-            /* Monotonic decreasing index values. */
+            // Monotonic decreasing index values.
             if (psi_m > Psi[1]) {
               if (Psi[1] + 0.5*(Psi[1]-Psi[2]) >= psi_m) {
-                /* Allow minor extrapolation. */
+                // Allow minor extrapolation.
                 k = 1;
 
               } else {
-                /* Index is out of range. */
+                // Index is out of range.
                 *statp = 1;
                 status = wcserr_set(TAB_ERRMSG(TABERR_BAD_X));
                 goto next;
@@ -1068,11 +1065,11 @@ int tabx2s(
 
             } else if (psi_m < Psi[*Km]) {
               if (Psi[*Km] - 0.5*(Psi[*Km-1]-Psi[*Km]) <= psi_m) {
-                /* Allow minor extrapolation. */
+                // Allow minor extrapolation.
                 k = *Km - 1;
 
               } else {
-                /* Index is out of range. */
+                // Index is out of range.
                 *statp = 1;
                 status = wcserr_set(TAB_ERRMSG(TABERR_BAD_X));
                 goto next;
@@ -1098,41 +1095,41 @@ int tabx2s(
       }
 
       if (upsilon < 0.5 || upsilon > *Km + 0.5) {
-        /* Index out of range. */
+        // Index out of range.
         *statp = 1;
         status = wcserr_set(TAB_ERRMSG(TABERR_BAD_X));
         goto next;
       }
 
-      /* Fiducial array indices and fractional offset.
-         p1 is 1-relative while tab::p0 is 0-relative. */
+      // Fiducial array indices and fractional offset.
+      // p1 is 1-relative while tab::p0 is 0-relative.
       p1 = (int)floor(upsilon);
       tab->p0[m] = p1 - 1;
       tab->delta[m] = upsilon - p1;
 
       if (p1 == 0) {
-        /* Extrapolation below p1 == 1. */
+        // Extrapolation below p1 == 1.
         tab->p0[m] += 1;
         tab->delta[m] -= 1.0;
       } else if (p1 == *Km && *Km > 1) {
-        /* Extrapolation above p1 == K_m. */
+        // Extrapolation above p1 == K_m.
         tab->p0[m] -= 1;
         tab->delta[m] += 1.0;
       }
     }
 
 
-    /* Now interpolate in the coordinate array; the M-dimensional linear  */
-    /* interpolation algorithm is described in Sect. 3.4 of WCS Paper IV. */
+    // Now interpolate in the coordinate array; the M-dimensional linear
+    // interpolation algorithm is described in Sect. 3.4 of WCS Paper IV.
     for (m = 0; m < M; m++) {
      i = tab->map[m];
      *(wp+i) = 0.0;
     }
 
-    /* Loop over the 2^M vertices surrounding P. */
+    // Loop over the 2^M vertices surrounding P.
     nv = 1 << M;
     for (iv = 0; iv < nv; iv++) {
-      /* Locate vertex in the coordinate array and compute its weight. */
+      // Locate vertex in the coordinate array and compute its weight.
       offset = 0;
       wgt = 1.0;
       for (m = M-1; m >= 0; m--) {
@@ -1148,7 +1145,7 @@ int tabx2s(
 
       if (wgt == 0.0) continue;
 
-      /* Add the contribution from this vertex to each element. */
+      // Add the contribution from this vertex to each element.
       coord = tab->coord + offset*M;
       for (m = 0; m < M; m++) {
         i = tab->map[m];
@@ -1169,9 +1166,9 @@ next:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
-/* Helper functions used only by tabs2x(). */
+// Helper functions used only by tabs2x().
 static int tabedge(struct tabprm *);
 static int tabrow(struct tabprm *, const double *);
 static int tabvox(struct tabprm *, const double *, int, double **,
@@ -1198,12 +1195,12 @@ int tabs2x(
   if (tab == 0x0) return TABERR_NULL_POINTER;
   err = &(tab->err);
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (tab->flag != TABSET) {
     if ((status = tabset(tab))) return status;
   }
 
-  /* This is used a lot. */
+  // This is used a lot.
   M = tab->M;
 
   tabcoord = 0x0;
@@ -1219,7 +1216,7 @@ int tabs2x(
   xp = x;
   statp = stat;
   for (n = 0; n < ncoord; n++) {
-    /* Locate this coordinate in the coordinate array. */
+    // Locate this coordinate in the coordinate array.
     edge = 0;
     for (m = 0; m < M; m++) {
       tab->p0[m] = 0;
@@ -1227,23 +1224,23 @@ int tabs2x(
 
     for (ic = 0; ic < tab->nc; ic++) {
       if (tab->p0[0] == 0) {
-        /* New row, could it contain a solution? */
+        // New row, could it contain a solution?
         if (edge || tabrow(tab, wp)) {
-          /* No, skip it. */
+          // No, skip it.
           ic += tab->K[0];
           if (1 < M) {
             tab->p0[1]++;
             edge = tabedge(tab);
           }
 
-          /* Because ic will be incremented when the loop is reentered. */
+          // Because ic will be incremented when the loop is reentered.
           ic--;
           continue;
         }
       }
 
       if (M == 1) {
-        /* Deal with the one-dimensional case separately for efficiency. */
+        // Deal with the one-dimensional case separately for efficiency.
         if (*wp == tab->coord[0]) {
           tab->p0[0] = 0;
           tab->delta[0] = 0.0;
@@ -1262,9 +1259,9 @@ int tabs2x(
         }
 
       } else {
-        /* Multi-dimensional tables are harder. */
+        // Multi-dimensional tables are harder.
         if (!edge) {
-          /* Addresses of the coordinates for each corner of the "voxel". */
+          // Addresses of the coordinates for each corner of the "voxel".
           for (iv = 0; iv < nv; iv++) {
             offset = 0;
             for (m = M-1; m >= 0; m--) {
@@ -1276,12 +1273,12 @@ int tabs2x(
           }
 
           if (tabvox(tab, wp, 0, tabcoord, 0x0) == 0) {
-            /* Found a solution. */
+            // Found a solution.
             break;
           }
         }
 
-        /* Next voxel. */
+        // Next voxel.
         tab->p0[0]++;
         edge = tabedge(tab);
       }
@@ -1289,9 +1286,9 @@ int tabs2x(
 
 
     if (ic == tab->nc) {
-      /* Coordinate not found; allow minor extrapolation. */
+      // Coordinate not found; allow minor extrapolation.
       if (M == 1) {
-        /* Should there be a solution? */
+        // Should there be a solution?
         if (tab->extrema[0] <= *wp && *wp <= tab->extrema[1]) {
           dcrd = tab->coord;
           for (i = 0; i < 2; i++) {
@@ -1317,43 +1314,43 @@ int tabs2x(
         }
 
       } else {
-        /* Multi-dimensional tables. */
-        /* >>> TBD <<< */
+        // Multi-dimensional tables.
+        // >>> TBD <<<
       }
     }
 
 
     if (ic == tab->nc) {
-      /* Coordinate not found. */
+      // Coordinate not found.
       *statp = 1;
       status = wcserr_set(TAB_ERRMSG(TABERR_BAD_WORLD));
 
     } else {
-      /* Determine the intermediate world coordinates. */
+      // Determine the intermediate world coordinates.
       Km = tab->K;
       for (m = 0; m < M; m++, Km++) {
-        /* N.B. Upsilon_m and psi_m are 1-relative FITS indexes. */
+        // N.B. Upsilon_m and psi_m are 1-relative FITS indexes.
         upsilon = (tab->p0[m] + 1) + tab->delta[m];
 
         if (upsilon < 0.5 || upsilon > *Km + 0.5) {
-          /* Index out of range. */
+          // Index out of range.
           *statp = 1;
           status = wcserr_set(TAB_ERRMSG(TABERR_BAD_WORLD));
 
         } else {
-          /* Do inverse lookup of the index vector. */
+          // Do inverse lookup of the index vector.
           Psi = tab->index[m];
           if (Psi == 0x0) {
-            /* Default indexing. */
+            // Default indexing.
             psi_m = upsilon;
 
           } else {
-            /* Decrement Psi and use 1-relative C array indexing to match the
-               1-relative FITS indexing. */
+            // Decrement Psi and use 1-relative C array indexing to match the
+            // 1-relative FITS indexing.
             Psi--;
 
             if (*Km == 1) {
-              /* Degenerate index vector. */
+              // Degenerate index vector.
               psi_m = Psi[1];
             } else {
               k = (int)(upsilon);
@@ -1396,14 +1393,14 @@ int tabedge(struct tabprm* tab)
   edge = 0;
   for (m = 0; m < tab->M; m++) {
     if (tab->p0[m] == tab->K[m]) {
-      /* p0 has been incremented beyond the end of an index vector, point it
-         to the next one. */
+      // p0 has been incremented beyond the end of an index vector, point it
+      // to the next one.
       tab->p0[m] = 0;
       if (m < tab->M-1) {
         tab->p0[m+1]++;
       }
     } else if (tab->p0[m] == tab->K[m]-1 && tab->K[m] > 1) {
-      /* p0 is sitting at the end of a non-degenerate index vector. */
+      // p0 is sitting at the end of a non-degenerate index vector.
       edge = 1;
     }
   }
@@ -1450,48 +1447,48 @@ int tabrow(struct tabprm* tab, const dou
 
   M = tab->M;
 
-  /* The number of corners in a "voxel".  We need examine only half this
-     number of rows.  The extra factor of two will be used to select between
-     the minimal and maximal values in each row. */
+  // The number of corners in a "voxel".  We need examine only half this
+  // number of rows.  The extra factor of two will be used to select between
+  // the minimal and maximal values in each row.
   nv = 1 << M;
 
   eq = 0;
   lt = 0;
   gt = 0;
   for (iv = 0; iv < nv; iv++) {
-    /* Find the index into tabprm::extrema for this row. */
+    // Find the index into tabprm::extrema for this row.
     offset = 0;
     for (m = M-1; m > 0; m--) {
       offset *= tab->K[m];
       offset += tab->p0[m];
 
-      /* Select the row. */
+      // Select the row.
       if (iv & (1 << m)) {
         if (tab->K[m] > 1) offset++;
       }
     }
 
-    /* The K_1 dimension has length 2 (see prologue). */
+    // The K_1 dimension has length 2 (see prologue).
     offset *= 2;
 
-    /* Select the minimum on even numbered iterations, else the maximum. */
+    // Select the minimum on even numbered iterations, else the maximum.
     if (iv & 1) offset++;
 
-    /* The last dimension has length M (see prologue). */
+    // The last dimension has length M (see prologue).
     offset *= M;
 
-    /* Address of the extremal elements (min or max) for this row. */
+    // Address of the extremal elements (min or max) for this row.
     cp = tab->extrema + offset;
 
-    /* For each coordinate element, we only need to find one row where its
-       minimum value is less than that of wp, and one row where the maximum
-       value is greater.  That doesn't mean that there is a solution, only
-       that there might be. */
+    // For each coordinate element, we only need to find one row where its
+    // minimum value is less than that of wp, and one row where the maximum
+    // value is greater.  That doesn't mean that there is a solution, only
+    // that there might be.
     for (m = 0; m < M; m++, cp++) {
-      /* Apply the axis mapping. */
+      // Apply the axis mapping.
       w = wp[tab->map[m]];
 
-      /* Finally the test itself; set bits in the bitmask. */
+      // Finally the test itself; set bits in the bitmask.
       if (fabs(*cp - w) < tol) {
         eq |= (1 << m);
       } else if (*cp < w) {
@@ -1501,14 +1498,14 @@ int tabrow(struct tabprm* tab, const dou
       }
     }
 
-    /* Have all bits been switched on? */
+    // Have all bits been switched on?
     if ((lt | eq) == nv-1 && (gt | eq) == nv-1) {
-      /* A solution could lie within this row of voxels. */
+      // A solution could lie within this row of voxels.
       return 0;
     }
   }
 
-  /* No solution in this row. */
+  // No solution in this row.
   return 1;
 }
 
@@ -1547,7 +1544,7 @@ int tabvox(
 
   M = tab->M;
 
-  /* The number of corners in a voxel. */
+  // The number of corners in a voxel.
   nv = 1 << M;
 
   dv = 1.0;
@@ -1555,14 +1552,14 @@ int tabvox(
     dv /= 2.0;
   }
 
-  /* Could the coordinate lie within this voxel (level == 0) or sub-voxel
-     (level > 0)?  We use the fact that with linear interpolation the
-     coordinate elements are extremal in a corner and test each one. */
+  // Could the coordinate lie within this voxel (level == 0) or sub-voxel
+  // (level > 0)?  We use the fact that with linear interpolation the
+  // coordinate elements are extremal in a corner and test each one.
   lt = 0;
   gt = 0;
   eq = 0;
   for (iv = 0; iv < nv; iv++) {
-    /* Select a corner of the sub-voxel. */
+    // Select a corner of the sub-voxel.
     for (m = 0; m < M; m++) {
       coord[m] = 0.0;
       tab->delta[m] = level ? dv*vox[m] : 0.0;
@@ -1572,11 +1569,11 @@ int tabvox(
       }
     }
 
-    /* Compute the coordinates of this corner of the sub-voxel by linear
-       interpolation using the weighting algorithm described in Sect. 3.4 of
-       WCS Paper IV. */
+    // Compute the coordinates of this corner of the sub-voxel by linear
+    // interpolation using the weighting algorithm described in Sect. 3.4 of
+    // WCS Paper IV.
     for (jv = 0; jv < nv; jv++) {
-      /* Find the weight for this corner of the parent voxel. */
+      // Find the weight for this corner of the parent voxel.
       wgt = 1.0;
       for (m = 0; m < M; m++) {
         if (jv & (1 << m)) {
@@ -1588,7 +1585,7 @@ int tabvox(
 
       if (wgt == 0.0) continue;
 
-      /* Add its contribution to each coordinate element. */
+      // Add its contribution to each coordinate element.
       cp = tabcoord[jv];
       for (m = 0; m < M; m++) {
         coord[m] += *(cp++) * wgt;
@@ -1597,13 +1594,13 @@ int tabvox(
       if (wgt == 1.0) break;
     }
 
-    /* Coordinate elements are minimal or maximal in a corner. */
+    // Coordinate elements are minimal or maximal in a corner.
     et = 0;
     for (m = 0; m < M; m++) {
-      /* Apply the axis mapping. */
+      // Apply the axis mapping.
       w = wp[tab->map[m]];
 
-      /* Finally the test itself; set bits in the bitmask. */
+      // Finally the test itself; set bits in the bitmask.
       if (fabs(coord[m] - w) < tol) {
         et |= (1 << m);
       } else if (coord[m] < w) {
@@ -1614,20 +1611,20 @@ int tabvox(
     }
 
     if (et == nv-1) {
-      /* We've stumbled across a solution in this corner of the sub-voxel. */
+      // We've stumbled across a solution in this corner of the sub-voxel.
       return 0;
     }
 
     eq |= et;
   }
 
-  /* Could the coordinate lie within this sub-voxel? */
+  // Could the coordinate lie within this sub-voxel?
   if ((lt | eq) == nv-1 && (gt | eq) == nv-1) {
-    /* Yes it could, but does it? */
+    // Yes it could, but does it?
 
-    /* Is it time to stop the recursion? */
+    // Is it time to stop the recursion?
     if (level == 31) {
-      /* We have a solution, squeeze out the last bit of juice. */
+      // We have a solution, squeeze out the last bit of juice.
       dv /= 2.0;
       for (m = 0; m < M; m++) {
         tab->delta[m] = dv * (2.0*vox[m] + 1.0);
@@ -1636,9 +1633,9 @@ int tabvox(
       return 0;
     }
 
-    /* Subdivide the sub-voxel and try again for each subdivision. */
+    // Subdivide the sub-voxel and try again for each subdivision.
     for (iv = 0; iv < nv; iv++) {
-      /* Select the subdivision. */
+      // Select the subdivision.
       for (m = 0; m < M; m++) {
         vox2[m] = level ? 2*vox[m] : 0;
         if (iv & (1 << m)) {
@@ -1646,13 +1643,13 @@ int tabvox(
         }
       }
 
-      /* Recurse. */
+      // Recurse.
       if (tabvox(tab, wp, level+1, tabcoord, vox2) == 0) {
         return 0;
       }
     }
   }
 
-  /* No solution in this sub-voxel. */
+  // No solution in this sub-voxel.
   return 1;
 }
Index: astropy-4.2/cextern/wcslib/C/tab.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/tab.h
+++ astropy-4.2/cextern/wcslib/C/tab.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: tab.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: tab.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -533,65 +530,65 @@ extern "C" {
 extern const char *tab_errmsg[];
 
 enum tab_errmsg_enum {
-  TABERR_SUCCESS      = 0,	/* Success. */
-  TABERR_NULL_POINTER = 1,	/* Null tabprm pointer passed. */
-  TABERR_MEMORY       = 2,	/* Memory allocation failed. */
-  TABERR_BAD_PARAMS   = 3,	/* Invalid tabular parameters. */
-  TABERR_BAD_X        = 4,	/* One or more of the x coordinates were
-				   invalid. */
-  TABERR_BAD_WORLD    = 5	/* One or more of the world coordinates were
-				   invalid. */
+  TABERR_SUCCESS      = 0,	// Success.
+  TABERR_NULL_POINTER = 1,	// Null tabprm pointer passed.
+  TABERR_MEMORY       = 2,	// Memory allocation failed.
+  TABERR_BAD_PARAMS   = 3,	// Invalid tabular parameters.
+  TABERR_BAD_X        = 4,	// One or more of the x coordinates were
+				// invalid.
+  TABERR_BAD_WORLD    = 5	// One or more of the world coordinates were
+				// invalid.
 };
 
 struct tabprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int    flag;			/* Set to zero to force initialization.     */
-
-  /* Parameters to be provided (see the prologue above).                    */
-  /*------------------------------------------------------------------------*/
-  int    M;			/* Number of tabular coordinate axes.       */
-  int    *K;			/* Vector of length M whose elements        */
-				/* (K_1, K_2,... K_M) record the lengths of */
-				/* the axes of the coordinate array and of  */
-				/* each indexing vector.                    */
-  int    *map;			/* Vector of length M usually such that     */
-				/* map[m-1] == i-1 for coordinate array     */
-				/* axis m and image axis i (see above).     */
-  double *crval;		/* Vector of length M containing the index  */
-				/* value for the reference pixel for each   */
-				/* of the tabular coordinate axes.          */
-  double **index;		/* Vector of pointers to M indexing vectors */
-				/* of lengths (K_1, K_2,... K_M).           */
-  double *coord;		/* (1+M)-dimensional tabular coordinate     */
-				/* array (see above).                       */
-
-  /* Information derived from the parameters supplied.                      */
-  /*------------------------------------------------------------------------*/
-  int    nc;			/* Number of coordinate vectors (of length  */
-				/* M) in the coordinate array.              */
-  int    padding;		/* (Dummy inserted for alignment purposes.) */
-  int    *sense;		/* Vector of M flags that indicate whether  */
-				/* the Mth indexing vector is monotonic     */
-				/* increasing, or else decreasing.          */
-  int    *p0;			/* Vector of M indices.                     */
-  double *delta;		/* Vector of M increments.                  */
-  double *extrema;		/* (1+M)-dimensional array of coordinate    */
-				/* extrema.                                 */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    flag;			// Set to zero to force initialization.
+
+  // Parameters to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    M;			// Number of tabular coordinate axes.
+  int    *K;			// Vector of length M whose elements
+				// (K_1, K_2,... K_M) record the lengths of
+				// the axes of the coordinate array and of
+				// each indexing vector.
+  int    *map;			// Vector of length M usually such that
+				// map[m-1] == i-1 for coordinate array
+				// axis m and image axis i (see above).
+  double *crval;		// Vector of length M containing the index
+				// value for the reference pixel for each
+				// of the tabular coordinate axes.
+  double **index;		// Vector of pointers to M indexing vectors
+				// of lengths (K_1, K_2,... K_M).
+  double *coord;		// (1+M)-dimensional tabular coordinate
+				// array (see above).
+
+  // Information derived from the parameters supplied.
+  //--------------------------------------------------------------------------
+  int    nc;			// Number of coordinate vectors (of length
+				// M) in the coordinate array.
+  int    padding;		// (Dummy inserted for alignment purposes.)
+  int    *sense;		// Vector of M flags that indicate whether
+				// the Mth indexing vector is monotonic
+				// increasing, or else decreasing.
+  int    *p0;			// Vector of M indices.
+  double *delta;		// Vector of M increments.
+  double *extrema;		// (1+M)-dimensional array of coordinate
+				// extrema.
 
-  /* Error handling                                                         */
-  /*------------------------------------------------------------------------*/
+  // Error handling
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Private - the remainder are for memory management.                     */
-  /*------------------------------------------------------------------------*/
+  // Private - the remainder are for memory management.
+  //--------------------------------------------------------------------------
   int    m_flag, m_M, m_N;
   int    set_M;
   int    *m_K, *m_map;
   double *m_crval, **m_index, **m_indxs, *m_coord;
 };
 
-/* Size of the tabprm struct in int units, used by the Fortran wrappers. */
+// Size of the tabprm struct in int units, used by the Fortran wrappers.
 #define TABLEN (sizeof(struct tabprm)/sizeof(int))
 
 
@@ -619,7 +616,7 @@ int tabs2x(struct tabprm *tab, int ncoor
            double x[], int stat[]);
 
 
-/* Deprecated. */
+// Deprecated.
 #define tabini_errmsg tab_errmsg
 #define tabcpy_errmsg tab_errmsg
 #define tabfree_errmsg tab_errmsg
@@ -632,4 +629,4 @@ int tabs2x(struct tabprm *tab, int ncoor
 }
 #endif
 
-#endif /* WCSLIB_TAB */
+#endif // WCSLIB_TAB
Index: astropy-4.2/cextern/wcslib/C/wcs.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcs.c
+++ astropy-4.2/cextern/wcslib/C/wcs.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcs.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcs.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -49,11 +46,11 @@
 
 const int WCSSET = 137;
 
-/* Maximum number of PVi_ma and PSi_ma keywords. */
+// Maximum number of PVi_ma and PSi_ma keywords.
 int NPVMAX = 64;
 int NPSMAX =  8;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *wcs_errmsg[] = {
   "Success",
   "Null wcsprm pointer passed",
@@ -70,70 +67,70 @@ const char *wcs_errmsg[] = {
   "Invalid subimage specification",
   "Non-separable subimage coordinate system"};
 
-/* Map error returns for lower-level routines. */
+// Map error returns for lower-level routines.
 const int wcs_linerr[] = {
-  WCSERR_SUCCESS,		/*  0: LINERR_SUCCESS         */
-  WCSERR_NULL_POINTER,		/*  1: LINERR_NULL_POINTER    */
-  WCSERR_MEMORY,		/*  2: LINERR_MEMORY          */
-  WCSERR_SINGULAR_MTX,		/*  3: LINERR_SINGULAR_MTX    */
-  WCSERR_BAD_PARAM,		/*  4: LINERR_DISTORT_INIT    */
-  WCSERR_BAD_PIX,		/*  5: LINERR_DISTORT         */
-  WCSERR_BAD_WORLD		/*  6: LINERR_DEDISTORT       */
+  WCSERR_SUCCESS,		//  0: LINERR_SUCCESS
+  WCSERR_NULL_POINTER,		//  1: LINERR_NULL_POINTER
+  WCSERR_MEMORY,		//  2: LINERR_MEMORY
+  WCSERR_SINGULAR_MTX,		//  3: LINERR_SINGULAR_MTX
+  WCSERR_BAD_PARAM,		//  4: LINERR_DISTORT_INIT
+  WCSERR_BAD_PIX,		//  5: LINERR_DISTORT
+  WCSERR_BAD_WORLD		//  6: LINERR_DEDISTORT
 };
 
 const int wcs_logerr[] = {
-  WCSERR_SUCCESS,		/*  0: LOGERR_SUCCESS         */
-  WCSERR_NULL_POINTER,		/*  1: LOGERR_NULL_POINTER    */
-  WCSERR_BAD_PARAM,		/*  2: LOGERR_BAD_LOG_REF_VAL */
-  WCSERR_BAD_PIX,		/*  3: LOGERR_BAD_X           */
-  WCSERR_BAD_WORLD		/*  4: LOGERR_BAD_WORLD       */
+  WCSERR_SUCCESS,		//  0: LOGERR_SUCCESS
+  WCSERR_NULL_POINTER,		//  1: LOGERR_NULL_POINTER
+  WCSERR_BAD_PARAM,		//  2: LOGERR_BAD_LOG_REF_VAL
+  WCSERR_BAD_PIX,		//  3: LOGERR_BAD_X
+  WCSERR_BAD_WORLD		//  4: LOGERR_BAD_WORLD
 };
 
 const int wcs_spcerr[] = {
-				/* -1: SPCERR_NO_CHANGE       */
-  WCSERR_SUCCESS,		/*  0: SPCERR_SUCCESS         */
-  WCSERR_NULL_POINTER,		/*  1: SPCERR_NULL_POINTER    */
-  WCSERR_BAD_PARAM,		/*  2: SPCERR_BAD_SPEC_PARAMS */
-  WCSERR_BAD_PIX,		/*  3: SPCERR_BAD_X           */
-  WCSERR_BAD_WORLD		/*  4: SPCERR_BAD_SPEC        */
+				// -1: SPCERR_NO_CHANGE
+  WCSERR_SUCCESS,		//  0: SPCERR_SUCCESS
+  WCSERR_NULL_POINTER,		//  1: SPCERR_NULL_POINTER
+  WCSERR_BAD_PARAM,		//  2: SPCERR_BAD_SPEC_PARAMS
+  WCSERR_BAD_PIX,		//  3: SPCERR_BAD_X
+  WCSERR_BAD_WORLD		//  4: SPCERR_BAD_SPEC
 };
 
 const int wcs_celerr[] = {
-  WCSERR_SUCCESS,		/*  0: CELERR_SUCCESS         */
-  WCSERR_NULL_POINTER,		/*  1: CELERR_NULL_POINTER    */
-  WCSERR_BAD_PARAM,		/*  2: CELERR_BAD_PARAM       */
-  WCSERR_BAD_COORD_TRANS,	/*  3: CELERR_BAD_COORD_TRANS */
-  WCSERR_ILL_COORD_TRANS,	/*  4: CELERR_ILL_COORD_TRANS */
-  WCSERR_BAD_PIX,		/*  5: CELERR_BAD_PIX         */
-  WCSERR_BAD_WORLD		/*  6: CELERR_BAD_WORLD       */
+  WCSERR_SUCCESS,		//  0: CELERR_SUCCESS
+  WCSERR_NULL_POINTER,		//  1: CELERR_NULL_POINTER
+  WCSERR_BAD_PARAM,		//  2: CELERR_BAD_PARAM
+  WCSERR_BAD_COORD_TRANS,	//  3: CELERR_BAD_COORD_TRANS
+  WCSERR_ILL_COORD_TRANS,	//  4: CELERR_ILL_COORD_TRANS
+  WCSERR_BAD_PIX,		//  5: CELERR_BAD_PIX
+  WCSERR_BAD_WORLD		//  6: CELERR_BAD_WORLD
 };
 
 const int wcs_taberr[] = {
-  WCSERR_SUCCESS,		/*  0: TABERR_SUCCESS         */
-  WCSERR_NULL_POINTER,		/*  1: TABERR_NULL_POINTER    */
-  WCSERR_MEMORY,		/*  2: TABERR_MEMORY          */
-  WCSERR_BAD_PARAM,		/*  3: TABERR_BAD_PARAMS      */
-  WCSERR_BAD_PIX,		/*  4: TABERR_BAD_X           */
-  WCSERR_BAD_WORLD		/*  5: TABERR_BAD_WORLD       */
+  WCSERR_SUCCESS,		//  0: TABERR_SUCCESS
+  WCSERR_NULL_POINTER,		//  1: TABERR_NULL_POINTER
+  WCSERR_MEMORY,		//  2: TABERR_MEMORY
+  WCSERR_BAD_PARAM,		//  3: TABERR_BAD_PARAMS
+  WCSERR_BAD_PIX,		//  4: TABERR_BAD_X
+  WCSERR_BAD_WORLD		//  5: TABERR_BAD_WORLD
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define WCS_ERRMSG(status) WCSERR_SET(status), wcs_errmsg[status]
 
 #ifndef signbit
 #define signbit(X) ((X) < 0.0 ? 1 : 0)
 #endif
 
-/* Internal helper functions, not for general use. */
+// Internal helper functions, not for general use.
 static int wcs_types(struct wcsprm *);
 static int wcs_units(struct wcsprm *);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsnpv(int npvmax) { if (npvmax >= 0) NPVMAX = npvmax; return NPVMAX; }
 int wcsnps(int npsmax) { if (npsmax >= 0) NPSMAX = npsmax; return NPSMAX; }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsini(int alloc, int naxis, struct wcsprm *wcs)
 
@@ -141,7 +138,7 @@ int wcsini(int alloc, int naxis, struct
   return wcsinit(alloc, naxis, wcs, -1, -1, -1);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsinit(
   int alloc,
@@ -158,23 +155,23 @@ int wcsinit(
   double *cd;
   struct wcserr **err;
 
-  /* Check inputs. */
+  // Check inputs.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
 
   if (npvmax < 0) npvmax = wcsnpv(-1);
   if (npsmax < 0) npsmax = wcsnps(-1);
 
 
-  /* Initialize error message handling... */
+  // Initialize error message handling...
   if (wcs->flag == -1) {
     wcs->err = 0x0;
   }
   err = &(wcs->err);
   wcserr_clear(err);
 
-  /* ...and also in the contained structs in case we have to return due to
-     an error before they can be initialized by their specialized routines,
-     since wcsperr() assumes their wcserr pointers are valid. */
+  // ...and also in the contained structs in case we have to return due to
+  // an error before they can be initialized by their specialized routines,
+  // since wcsperr() assumes their wcserr pointers are valid.
   if (wcs->flag == -1) {
     wcs->lin.err = 0x0;
     wcs->cel.err = 0x0;
@@ -185,7 +182,7 @@ int wcsinit(
   wcserr_clear(&(wcs->spc.err));
 
 
-  /* Initialize pointers. */
+  // Initialize pointers.
   if (wcs->flag == -1 || wcs->m_flag != WCSSET) {
     if (wcs->flag == -1) {
       wcs->tab   = 0x0;
@@ -193,7 +190,7 @@ int wcsinit(
       wcs->lin.flag = -1;
     }
 
-    /* Initialize memory management. */
+    // Initialize memory management.
     wcs->m_flag  = 0;
     wcs->m_naxis = 0;
     wcs->m_crpix = 0x0;
@@ -223,7 +220,7 @@ int wcsinit(
   }
 
 
-  /* Allocate memory for arrays if required. */
+  // Allocate memory for arrays if required.
   if (alloc ||
      wcs->crpix == 0x0 ||
      wcs->pc    == 0x0 ||
@@ -242,18 +239,18 @@ int wcsinit(
      wcs->czphs == 0x0 ||
      wcs->cperi == 0x0) {
 
-    /* Was sufficient allocated previously? */
+    // Was sufficient allocated previously?
     if (wcs->m_flag == WCSSET &&
        (wcs->m_naxis < naxis  ||
         wcs->npvmax  < npvmax ||
         wcs->npsmax  < npsmax)) {
-      /* No, free it. */
+      // No, free it.
       wcsfree(wcs);
     }
 
     if (alloc || wcs->crpix == 0x0) {
       if (wcs->m_crpix) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->crpix = wcs->m_crpix;
 
       } else {
@@ -269,7 +266,7 @@ int wcsinit(
 
     if (alloc || wcs->pc == 0x0) {
       if (wcs->m_pc) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->pc = wcs->m_pc;
 
       } else {
@@ -286,7 +283,7 @@ int wcsinit(
 
     if (alloc || wcs->cdelt == 0x0) {
       if (wcs->m_cdelt) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->cdelt = wcs->m_cdelt;
 
       } else {
@@ -303,7 +300,7 @@ int wcsinit(
 
     if (alloc || wcs->crval == 0x0) {
       if (wcs->m_crval) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->crval = wcs->m_crval;
 
       } else {
@@ -320,7 +317,7 @@ int wcsinit(
 
     if (alloc || wcs->cunit == 0x0) {
       if (wcs->m_cunit) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->cunit = wcs->m_cunit;
 
       } else {
@@ -337,7 +334,7 @@ int wcsinit(
 
     if (alloc || wcs->ctype == 0x0) {
       if (wcs->m_ctype) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->ctype = wcs->m_ctype;
 
       } else {
@@ -354,7 +351,7 @@ int wcsinit(
 
     if (alloc || wcs->pv == 0x0) {
       if (wcs->m_pv) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->pv = wcs->m_pv;
 
       } else {
@@ -377,7 +374,7 @@ int wcsinit(
 
     if (alloc || wcs->ps == 0x0) {
       if (wcs->m_ps) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->ps = wcs->m_ps;
 
       } else {
@@ -400,7 +397,7 @@ int wcsinit(
 
     if (alloc || wcs->cd == 0x0) {
       if (wcs->m_cd) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->cd = wcs->m_cd;
 
       } else {
@@ -417,7 +414,7 @@ int wcsinit(
 
     if (alloc || wcs->crota == 0x0) {
       if (wcs->m_crota) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->crota = wcs->m_crota;
 
       } else {
@@ -434,7 +431,7 @@ int wcsinit(
 
     if (alloc || wcs->colax == 0x0) {
       if (wcs->m_colax) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->colax = wcs->m_colax;
 
       } else {
@@ -451,7 +448,7 @@ int wcsinit(
 
     if (alloc || wcs->cname == 0x0) {
       if (wcs->m_cname) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->cname = wcs->m_cname;
 
       } else {
@@ -468,7 +465,7 @@ int wcsinit(
 
     if (alloc || wcs->crder == 0x0) {
       if (wcs->m_crder) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->crder = wcs->m_crder;
 
       } else {
@@ -485,7 +482,7 @@ int wcsinit(
 
     if (alloc || wcs->csyer == 0x0) {
       if (wcs->m_csyer) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->csyer = wcs->m_csyer;
 
       } else {
@@ -502,7 +499,7 @@ int wcsinit(
 
     if (alloc || wcs->czphs == 0x0) {
       if (wcs->m_czphs) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->czphs = wcs->m_czphs;
 
       } else {
@@ -519,7 +516,7 @@ int wcsinit(
 
     if (alloc || wcs->cperi == 0x0) {
       if (wcs->m_cperi) {
-        /* In case the caller fiddled with it. */
+        // In case the caller fiddled with it.
         wcs->cperi = wcs->m_cperi;
 
       } else {
@@ -540,7 +537,7 @@ int wcsinit(
   wcs->naxis = naxis;
 
 
-  /* Set defaults for the linear transformation. */
+  // Set defaults for the linear transformation.
   wcs->lin.crpix  = wcs->crpix;
   wcs->lin.pc     = wcs->pc;
   wcs->lin.cdelt  = wcs->cdelt;
@@ -549,28 +546,28 @@ int wcsinit(
   }
 
 
-  /* CRVALia defaults to 0.0. */
+  // CRVALia defaults to 0.0.
   for (i = 0; i < naxis; i++) {
     wcs->crval[i] = 0.0;
   }
 
 
-  /* CUNITia and CTYPEia are blank by default. */
+  // CUNITia and CTYPEia are blank by default.
   for (i = 0; i < naxis; i++) {
     memset(wcs->cunit[i], 0, 72);
     memset(wcs->ctype[i], 0, 72);
   }
 
 
-  /* Set defaults for the celestial transformation parameters. */
+  // Set defaults for the celestial transformation parameters.
   wcs->lonpole = UNDEFINED;
   wcs->latpole = +90.0;
 
-  /* Set defaults for the spectral transformation parameters. */
+  // Set defaults for the spectral transformation parameters.
   wcs->restfrq = 0.0;
   wcs->restwav = 0.0;
 
-  /* Default parameter values. */
+  // Default parameter values.
   wcs->npv = 0;
   for (k = 0; k < wcs->npvmax; k++) {
     wcs->pv[k].i = 0;
@@ -585,7 +582,7 @@ int wcsinit(
     memset(wcs->ps[k].value, 0, 72);
   }
 
-  /* Defaults for alternate linear transformations. */
+  // Defaults for alternate linear transformations.
   cd = wcs->cd;
   for (i = 0; i < naxis; i++) {
     for (j = 0; j < naxis; j++) {
@@ -598,7 +595,7 @@ int wcsinit(
   wcs->altlin = 0;
   wcs->velref = 0;
 
-  /* Defaults for auxiliary coordinate system information. */
+  // Defaults for auxiliary coordinate system information.
   memset(wcs->alt, 0, 4);
   wcs->alt[0] = ' ';
   wcs->colnum = 0;
@@ -661,16 +658,16 @@ int wcsinit(
   memset(wcs->ssyssrc,  0, 72);
   wcs->velangl    = UNDEFINED;
 
-  /* No additional auxiliary coordinate system information. */
+  // No additional auxiliary coordinate system information.
   wcs->aux  = 0x0;
 
-  /* Tabular parameters. */
+  // Tabular parameters.
   wcs->ntab = 0;
   wcs->tab  = 0x0;
   wcs->nwtb = 0;
   wcs->wtb  = 0x0;
 
-  /* Reset derived values. */
+  // Reset derived values.
   strcpy(wcs->lngtyp, "    ");
   strcpy(wcs->lattyp, "    ");
   wcs->lng  = -1;
@@ -684,7 +681,7 @@ int wcsinit(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsauxi(
   int alloc,
@@ -696,14 +693,14 @@ int wcsauxi(
   struct auxprm *aux;
   struct wcserr **err;
 
-  /* Check inputs. */
+  // Check inputs.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
-  /* Allocate memory if required. */
+  // Allocate memory if required.
   if (alloc || wcs->aux == 0x0) {
     if (wcs->m_aux) {
-      /* In case the caller fiddled with it. */
+      // In case the caller fiddled with it.
       wcs->aux = wcs->m_aux;
 
     } else {
@@ -725,7 +722,7 @@ int wcsauxi(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcssub(
   int alloc,
@@ -753,7 +750,7 @@ int wcssub(
   if (wcsdst == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcsdst->err);
 
-  /* N.B. we do not rely on the wcsprm struct having been set up. */
+  // N.B. we do not rely on the wcsprm struct having been set up.
   if ((naxis = wcssrc->naxis) <= 0) {
     return wcserr_set(WCSERR_SET(WCSERR_MEMORY),
       "naxis must be positive (got %d)", naxis);
@@ -766,14 +763,14 @@ int wcssub(
     *nsub = naxis;
   }
 
-  /* Allocate enough temporary storage to hold either axes[] xor map[].*/
+  // Allocate enough temporary storage to hold either axes[] xor map[].
   ntmp = (*nsub <= naxis) ? naxis : *nsub;
   if ((itmp = calloc(ntmp, sizeof(int))) == 0x0) {
     return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
   }
 
   if ((dealloc = (axes == 0x0))) {
-    /* Construct an index array. */
+    // Construct an index array.
     if ((axes = calloc(naxis, sizeof(int))) == 0x0) {
       free(itmp);
       return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
@@ -784,7 +781,7 @@ int wcssub(
     }
   }
 
-  /* So that we don't try to free uninitialized pointers on cleanup. */
+  // So that we don't try to free uninitialized pointers on cleanup.
   wcsdst->m_aux = 0x0;
   wcsdst->m_tab = 0x0;
 
@@ -794,7 +791,7 @@ int wcssub(
     axis = axes[j];
 
     if (abs(axis) > 0x1000) {
-      /* Subimage extraction by type. */
+      // Subimage extraction by type.
       k = abs(axis) & 0xFF;
 
       longitude = k & WCSSUB_LONGITUDE;
@@ -815,7 +812,7 @@ int wcssub(
         strncpy (ctypei, (char *)(wcssrc->ctype + i), 8);
         ctypei[8] = '\0';
 
-        /* Find the last non-blank character. */
+        // Find the last non-blank character.
         c = ctypei + 8;
         while (c-- > ctypei) {
           if (*c == ' ') *c = '\0';
@@ -874,7 +871,7 @@ int wcssub(
           continue;
         }
 
-        /* This axis is wanted, but has it already been added? */
+        // This axis is wanted, but has it already been added?
         for (k = 0; k < msub; k++) {
           if (itmp[k] == i+1) {
             break;
@@ -884,7 +881,7 @@ int wcssub(
       }
 
     } else if (0 < axis && axis <= naxis) {
-      /* Check that the requested axis has not already been added. */
+      // Check that the requested axis has not already been added.
       for (k = 0; k < msub; k++) {
         if (itmp[k] == axis) {
           break;
@@ -893,7 +890,7 @@ int wcssub(
       if (k == msub) itmp[msub++] = axis;
 
     } else if (axis == 0) {
-      /* Graft on a new axis. */
+      // Graft on a new axis.
       itmp[msub++] = 0;
 
     } else {
@@ -903,7 +900,7 @@ int wcssub(
   }
 
   if ((*nsub = msub) == 0) {
-    /* Zero out this struct. */
+    // Zero out this struct.
     status = wcsinit(alloc, 0, wcsdst, 0, 0, 0);
     goto cleanup;
   }
@@ -913,11 +910,11 @@ int wcssub(
   }
 
 
-  /* Construct the inverse axis map (i is 0-relative, j is 1-relative):
-     axes[i] == j means that output axis i+1 comes from input axis j,
-     axes[i] == 0 means to create a new axis,
-      map[i] == j means that input axis i+1 goes to output axis j,
-      map[i] == 0 means that input axis i+1 is not used. */
+  // Construct the inverse axis map (i is 0-relative, j is 1-relative):
+  // axes[i] == j means that output axis i+1 comes from input axis j,
+  // axes[i] == 0 means to create a new axis,
+  //  map[i] == j means that input axis i+1 goes to output axis j,
+  //  map[i] == 0 means that input axis i+1 is not used.
   map = itmp;
   for (i = 0; i < naxis; i++) {
     map[i] = 0;
@@ -930,8 +927,8 @@ int wcssub(
   }
 
 
-  /* Check that the subimage coordinate system is separable.  First check */
-  /* non-zero, off-diagonal elements of the linear transformation matrix. */
+  // Check that the subimage coordinate system is separable.  First check
+  // non-zero, off-diagonal elements of the linear transformation matrix.
   srcp = wcssrc->pc;
   for (i = 0; i < naxis; i++) {
     for (j = 0; j < naxis; j++) {
@@ -944,8 +941,8 @@ int wcssub(
     }
   }
 
-  /* Now check for distortions that depend on other axes.  As the disprm    */
-  /* struct may not have been initialized, we must parse the dpkey entries. */
+  // Now check for distortions that depend on other axes.  As the disprm
+  // struct may not have been initialized, we must parse the dpkey entries.
   ndpmax = 0;
   for (m = 0; m < 2; m++) {
     if (m == 0) {
@@ -959,7 +956,7 @@ int wcssub(
       for (j = 0; j < naxis; j++) {
         if (map[j] == 0) continue;
 
-        /* Axis numbers in axmap[] are 0-relative. */
+        // Axis numbers in axmap[] are 0-relative.
         for (jhat = 0; jhat < 32; jhat++) {
           axmap[jhat] = -1;
         }
@@ -967,7 +964,7 @@ int wcssub(
         Nhat = 0;
         dpsrc = dissrc->dp;
         for (idp = 0; idp < dissrc->ndp; idp++, dpsrc++) {
-          /* Thorough error checking will be done later by disset(). */
+          // Thorough error checking will be done later by disset().
           if (dpsrc->j != j+1) continue;
           if (dpsrc->field[1] != pq[m]) continue;
           if ((fp = strchr(dpsrc->field, '.')) == 0x0) continue;
@@ -994,12 +991,12 @@ int wcssub(
           if (axmap[jhat] < 0) {
             axmap[jhat] = jhat;
 
-            /* Make room for an additional DPja.AXIS.j record. */
+            // Make room for an additional DPja.AXIS.j record.
             ndp++;
           }
 
           if (map[axmap[jhat]] == 0) {
-            /* Distortion depends on an axis excluded from the subimage. */
+            // Distortion depends on an axis excluded from the subimage.
             status = wcserr_set(WCS_ERRMSG(WCSERR_NON_SEPARABLE));
             goto cleanup;
           }
@@ -1011,7 +1008,7 @@ int wcssub(
   }
 
 
-  /* Number of PVi_ma records in the subimage. */
+  // Number of PVi_ma records in the subimage.
   npvmax = 0;
   for (m = 0; m < wcssrc->npv; m++) {
     i = wcssrc->pv[m].i;
@@ -1020,7 +1017,7 @@ int wcssub(
     }
   }
 
-  /* Number of PSi_ma records in the subimage. */
+  // Number of PSi_ma records in the subimage.
   npsmax = 0;
   for (m = 0; m < wcssrc->nps; m++) {
     i = wcssrc->ps[m].i;
@@ -1029,7 +1026,7 @@ int wcssub(
     }
   }
 
-  /* Initialize the destination. */
+  // Initialize the destination.
   status = wcsinit(alloc, *nsub, wcsdst, npvmax, npsmax, ndpmax);
 
   for (m = 0; m < 2; m++) {
@@ -1046,7 +1043,7 @@ int wcssub(
         return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
       }
 
-      /* Also inits disdst. */
+      // Also inits disdst.
       disdst->flag = -1;
       lindist(m+1, &(wcsdst->lin), disdst, ndpmax);
     }
@@ -1057,7 +1054,7 @@ int wcssub(
   }
 
 
-  /* Linear transformation. */
+  // Linear transformation.
   srcp = wcssrc->crpix;
   dstp = wcsdst->crpix;
   for (j = 0; j < *nsub; j++, dstp++) {
@@ -1087,7 +1084,7 @@ int wcssub(
     }
   }
 
-  /* Coordinate reference value. */
+  // Coordinate reference value.
   srcp = wcssrc->crval;
   dstp = wcsdst->crval;
   for (i = 0; i < *nsub; i++, dstp++) {
@@ -1097,7 +1094,7 @@ int wcssub(
     }
   }
 
-  /* Coordinate units and type. */
+  // Coordinate units and type.
   for (i = 0; i < *nsub; i++) {
     if (axes[i] > 0) {
       k = axes[i] - 1;
@@ -1106,18 +1103,18 @@ int wcssub(
     }
   }
 
-  /* Celestial and spectral transformation parameters. */
+  // Celestial and spectral transformation parameters.
   wcsdst->lonpole = wcssrc->lonpole;
   wcsdst->latpole = wcssrc->latpole;
   wcsdst->restfrq = wcssrc->restfrq;
   wcsdst->restwav = wcssrc->restwav;
 
-  /* Parameter values. */
+  // Parameter values.
   npv = 0;
   for (m = 0; m < wcssrc->npv; m++) {
     i = wcssrc->pv[m].i;
     if (i == 0) {
-      /* i == 0 is a special code that means "the latitude axis". */
+      // i == 0 is a special code that means "the latitude axis".
       wcsdst->pv[npv] = wcssrc->pv[m];
       wcsdst->pv[npv].i = 0;
       npv++;
@@ -1140,7 +1137,7 @@ int wcssub(
   }
   wcsdst->nps = nps;
 
-  /* Alternate linear transformations. */
+  // Alternate linear transformations.
   srcp = wcssrc->cd;
   dstp = wcsdst->cd;
   for (i = 0; i < *nsub; i++) {
@@ -1149,8 +1146,8 @@ int wcssub(
         k = (axes[i]-1)*naxis + (axes[j]-1);
         *dstp = *(srcp+k);
       } else if (i == j && wcssrc->altlin & 2) {
-        /* A new axis is being created where CDi_ja was present in the input
-           header, so override the default value of 0 set by wcsinit(). */
+        // A new axis is being created where CDi_ja was present in the input
+        // header, so override the default value of 0 set by wcsinit().
         *dstp = 1.0;
       }
     }
@@ -1168,7 +1165,7 @@ int wcssub(
   wcsdst->altlin = wcssrc->altlin;
   wcsdst->velref = wcssrc->velref;
 
-  /* Auxiliary coordinate system information. */
+  // Auxiliary coordinate system information.
   strncpy(wcsdst->alt, wcssrc->alt, 4);
   wcsdst->colnum = wcssrc->colnum;
 
@@ -1236,7 +1233,7 @@ int wcssub(
   wcsdst->velangl = wcssrc->velangl;
 
 
-  /* Additional auxiliary coordinate system information. */
+  // Additional auxiliary coordinate system information.
   if (wcssrc->aux && !wcsdst->aux) {
     if ((wcsdst->aux = calloc(1, sizeof(struct auxprm))) == 0x0) {
       status = wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
@@ -1253,10 +1250,10 @@ int wcssub(
   }
 
 
-  /* Coordinate lookup tables; only copy what's needed. */
+  // Coordinate lookup tables; only copy what's needed.
   wcsdst->ntab = 0;
   for (itab = 0; itab < wcssrc->ntab; itab++) {
-    /* Is this table wanted? */
+    // Is this table wanted?
     for (m = 0; m < wcssrc->tab[itab].M; m++) {
       i = wcssrc->tab[itab].map[m];
 
@@ -1268,7 +1265,7 @@ int wcssub(
   }
 
   if (wcsdst->ntab) {
-    /* Allocate memory for tabprm structs. */
+    // Allocate memory for tabprm structs.
     if ((wcsdst->tab = calloc(wcsdst->ntab, sizeof(struct tabprm))) == 0x0) {
       wcsdst->ntab = 0;
 
@@ -1297,7 +1294,7 @@ int wcssub(
   }
 
 
-  /* Distortion parameters (in linprm). */
+  // Distortion parameters (in linprm).
   for (m = 0; m < 2; m++) {
     if (m == 0) {
       dissrc = wcssrc->lin.dispre;
@@ -1310,7 +1307,7 @@ int wcssub(
     if (dissrc) {
       disdst->naxis = *nsub;
 
-      /* Distortion type and maximum distortion (but not total distortion). */
+      // Distortion type and maximum distortion (but not total distortion).
       for (j = 0; j < *nsub; j++) {
         if (axes[j] > 0) {
           k = axes[j] - 1;
@@ -1319,13 +1316,13 @@ int wcssub(
         }
       }
 
-      /* DPja or DQia keyvalues. */
+      // DPja or DQia keyvalues.
       ndp = 0;
       dpdst = disdst->dp;
       for (j = 0; j < *nsub; j++) {
         if (axes[j] == 0) continue;
 
-        /* Determine the axis mapping. */
+        // Determine the axis mapping.
         for (jhat = 0; jhat < 32; jhat++) {
           axmap[jhat] = -1;
         }
@@ -1352,7 +1349,7 @@ int wcssub(
           }
         }
 
-        /* Copy the DPja or DQia keyvalues. */
+        // Copy the DPja or DQia keyvalues.
         dpsrc = dissrc->dp;
         for (idp = 0; idp < dissrc->ndp; idp++, dpsrc++) {
           if (dpsrc->j != axes[j]) continue;
@@ -1361,7 +1358,7 @@ int wcssub(
           fp++;
 
           if (strncmp(fp, "AXIS.", 5) == 0) {
-            /* Skip it, we will create our own later. */
+            // Skip it, we will create our own later.
             continue;
           }
 
@@ -1416,7 +1413,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcscompare(
   int cmp,
@@ -1445,7 +1442,7 @@ int wcscompare(
   naxis2 = wcs1->naxis*wcs1->naxis;
 
   if (cmp & WCSCOMPARE_CRPIX) {
-    /* Don't compare crpix. */
+    // Don't compare crpix.
   } else if (cmp & WCSCOMPARE_TILING) {
     for (i = 0; i < naxis; ++i) {
       diff = wcs1->crpix[i] - wcs2->crpix[i];
@@ -1473,7 +1470,7 @@ int wcscompare(
     return 0;
   }
 
-  /* Compare pv cards, which may not be in the same order */
+  // Compare pv cards, which may not be in the same order
   for (i = 0; i < wcs1->npv; ++i) {
     for (j = 0; j < wcs2->npv; ++j) {
       if (wcs1->pv[i].i == wcs2->pv[j].i &&
@@ -1484,13 +1481,13 @@ int wcscompare(
         break;
       }
     }
-    /* We didn't find a match, so they are not equal */
+    // We didn't find a match, so they are not equal
     if (j == wcs2->npv) {
       return 0;
     }
   }
 
-  /* Compare ps cards, which may not be in the same order */
+  // Compare ps cards, which may not be in the same order
   for (i = 0; i < wcs1->nps; ++i) {
     for (j = 0; j < wcs2->nps; ++j) {
       if (wcs1->ps[i].i == wcs2->ps[j].i &&
@@ -1501,7 +1498,7 @@ int wcscompare(
         break;
       }
     }
-    /* We didn't find a match, so they are not equal */
+    // We didn't find a match, so they are not equal
     if (j == wcs2->nps) {
       return 0;
     }
@@ -1565,7 +1562,7 @@ int wcscompare(
       return 0;
     }
 
-    /* Compare additional auxiliary parameters. */
+    // Compare additional auxiliary parameters.
     if (wcs1->aux && wcs2->aux) {
       if (!wcsutil_Eq(1, tol, &wcs1->aux->rsun_ref, &wcs2->aux->rsun_ref) ||
           !wcsutil_Eq(1, tol, &wcs1->aux->dsun_obs, &wcs2->aux->dsun_obs) ||
@@ -1579,7 +1576,7 @@ int wcscompare(
     }
   }
 
-  /* Compare tabular parameters */
+  // Compare tabular parameters
   if (wcs1->ntab != wcs2->ntab) {
     return 0;
   }
@@ -1597,7 +1594,7 @@ int wcscompare(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsfree(struct wcsprm *wcs)
 
@@ -1610,9 +1607,9 @@ int wcsfree(struct wcsprm *wcs)
     wcs->lin.flag = -1;
 
   } else {
-    /* Optionally allocated by wcsinit() for given parameters. */
+    // Optionally allocated by wcsinit() for given parameters.
     if (wcs->m_flag == WCSSET) {
-      /* Start by cleaning the slate. */
+      // Start by cleaning the slate.
       if (wcs->crpix == wcs->m_crpix) wcs->crpix = 0x0;
       if (wcs->pc    == wcs->m_pc)    wcs->pc    = 0x0;
       if (wcs->cdelt == wcs->m_cdelt) wcs->cdelt = 0x0;
@@ -1634,7 +1631,7 @@ int wcsfree(struct wcsprm *wcs)
       if (wcs->tab   == wcs->m_tab)   wcs->tab   = 0x0;
       if (wcs->wtb   == wcs->m_wtb)   wcs->wtb   = 0x0;
 
-      /* Now release the memory. */
+      // Now release the memory.
       if (wcs->m_crpix)  free(wcs->m_crpix);
       if (wcs->m_pc)     free(wcs->m_pc);
       if (wcs->m_cdelt)  free(wcs->m_cdelt);
@@ -1652,10 +1649,10 @@ int wcsfree(struct wcsprm *wcs)
       if (wcs->m_czphs)  free(wcs->m_czphs);
       if (wcs->m_cperi)  free(wcs->m_cperi);
 
-      /* May have been allocated by wcspih() or wcssub(). */
+      // May have been allocated by wcspih() or wcssub().
       if (wcs->m_aux) free(wcs->m_aux);
 
-      /* Allocated unconditionally by wcstab(). */
+      // Allocated unconditionally by wcstab().
       if (wcs->m_tab) {
         for (j = 0; j < wcs->ntab; j++) {
           tabfree(wcs->m_tab + j);
@@ -1666,7 +1663,7 @@ int wcsfree(struct wcsprm *wcs)
       if (wcs->m_wtb) free(wcs->m_wtb);
     }
 
-    /* Allocated unconditionally by wcsset(). */
+    // Allocated unconditionally by wcsset().
     if (wcs->types) free(wcs->types);
 
     if (wcs->lin.crpix == wcs->m_crpix) wcs->lin.crpix = 0x0;
@@ -1713,7 +1710,7 @@ int wcsfree(struct wcsprm *wcs)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 static void wcsprt_auxc(const char *name, const char *value)
 {
@@ -1755,7 +1752,7 @@ int wcsprt(const struct wcsprm *wcs)
   }
   wcsprintf("\n");
 
-  /* Linear transformation. */
+  // Linear transformation.
   k = 0;
   WCSPRINTF_PTR("         pc: ", wcs->pc, "\n");
   for (i = 0; i < wcs->naxis; i++) {
@@ -1766,7 +1763,7 @@ int wcsprt(const struct wcsprm *wcs)
     wcsprintf("\n");
   }
 
-  /* Coordinate increment at reference point. */
+  // Coordinate increment at reference point.
   WCSPRINTF_PTR("      cdelt: ", wcs->cdelt, "\n");
   wcsprintf("            ");
   for (i = 0; i < wcs->naxis; i++) {
@@ -1774,7 +1771,7 @@ int wcsprt(const struct wcsprm *wcs)
   }
   wcsprintf("\n");
 
-  /* Coordinate value at reference point. */
+  // Coordinate value at reference point.
   WCSPRINTF_PTR("      crval: ", wcs->crval, "\n");
   wcsprintf("            ");
   for (i = 0; i < wcs->naxis; i++) {
@@ -1782,7 +1779,7 @@ int wcsprt(const struct wcsprm *wcs)
   }
   wcsprintf("\n");
 
-  /* Coordinate units and type. */
+  // Coordinate units and type.
   WCSPRINTF_PTR("      cunit: ", wcs->cunit, "\n");
   for (i = 0; i < wcs->naxis; i++) {
     wcsprintf("             \"%s\"\n", wcs->cunit[i]);
@@ -1793,7 +1790,7 @@ int wcsprt(const struct wcsprm *wcs)
     wcsprintf("             \"%s\"\n", wcs->ctype[i]);
   }
 
-  /* Celestial and spectral transformation parameters. */
+  // Celestial and spectral transformation parameters.
   if (undefined(wcs->lonpole)) {
     wcsprintf("    lonpole: UNDEFINED\n");
   } else {
@@ -1803,7 +1800,7 @@ int wcsprt(const struct wcsprm *wcs)
   wcsprintf("    restfrq: %f\n", wcs->restfrq);
   wcsprintf("    restwav: %f\n", wcs->restwav);
 
-  /* Parameter values. */
+  // Parameter values.
   wcsprintf("        npv: %d\n", wcs->npv);
   wcsprintf("     npvmax: %d\n", wcs->npvmax);
   WCSPRINTF_PTR("         pv: ", wcs->pv, "\n");
@@ -1819,7 +1816,7 @@ int wcsprt(const struct wcsprm *wcs)
       (wcs->ps[i]).m, (wcs->ps[i]).value);
   }
 
-  /* Alternate linear transformations. */
+  // Alternate linear transformations.
   k = 0;
   WCSPRINTF_PTR("         cd: ", wcs->cd, "\n");
   if (wcs->cd) {
@@ -1846,7 +1843,7 @@ int wcsprt(const struct wcsprm *wcs)
 
 
 
-  /* Auxiliary coordinate system information. */
+  // Auxiliary coordinate system information.
   wcsprintf("        alt: '%c'\n", wcs->alt[0]);
   wcsprintf("     colnum: %d\n", wcs->colnum);
 
@@ -1990,7 +1987,7 @@ int wcsprt(const struct wcsprm *wcs)
   wcsprt_auxc(" ssyssrc", wcs->ssyssrc);
   wcsprt_auxd(" velangl", wcs->velangl);
 
-  /* Additional auxiliary coordinate system information. */
+  // Additional auxiliary coordinate system information.
   WCSPRINTF_PTR("        aux: ", wcs->aux, "\n");
   if (wcs->aux) {
     wcsprt_auxd("rsun_ref", wcs->aux->rsun_ref);
@@ -2009,7 +2006,7 @@ int wcsprt(const struct wcsprm *wcs)
   if (wcs->wtb != 0x0) wcsprintf("  (see below)");
   wcsprintf("\n");
 
-  /* Derived values. */
+  // Derived values.
   WCSPRINTF_PTR("      types: ", wcs->types, "\n           ");
   for (i = 0; i < wcs->naxis; i++) {
     wcsprintf("%5d", wcs->types[i]);
@@ -2032,7 +2029,7 @@ int wcsprt(const struct wcsprm *wcs)
   wcsprintf("        cel: (see below)\n");
   wcsprintf("        spc: (see below)\n");
 
-  /* Memory management. */
+  // Memory management.
   wcsprintf("     m_flag: %d\n", wcs->m_flag);
   wcsprintf("    m_naxis: %d\n", wcs->m_naxis);
   WCSPRINTF_PTR("    m_crpix: ", wcs->m_crpix, "");
@@ -2094,7 +2091,7 @@ int wcsprt(const struct wcsprm *wcs)
   if (wcs->m_wtb == wcs->wtb) wcsprintf("  (= wtb)");
   wcsprintf("\n");
 
-  /* Tabular transformation parameters. */
+  // Tabular transformation parameters.
   if ((wtbp = wcs->wtb)) {
     for (j = 0; j < wcs->nwtb; j++, wtbp++) {
       wcsprintf("\n");
@@ -2122,17 +2119,17 @@ int wcsprt(const struct wcsprm *wcs)
     }
   }
 
-  /* Linear transformation parameters. */
+  // Linear transformation parameters.
   wcsprintf("\n");
   wcsprintf("   lin.*\n");
   linprt(&(wcs->lin));
 
-  /* Celestial transformation parameters. */
+  // Celestial transformation parameters.
   wcsprintf("\n");
   wcsprintf("   cel.*\n");
   celprt(&(wcs->cel));
 
-  /* Spectral transformation parameters. */
+  // Spectral transformation parameters.
   wcsprintf("\n");
   wcsprintf("   spc.*\n");
   spcprt(&(wcs->spc));
@@ -2140,7 +2137,7 @@ int wcsprt(const struct wcsprm *wcs)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsperr(const struct wcsprm *wcs, const char *prefix)
 
@@ -2163,7 +2160,7 @@ int wcsperr(const struct wcsprm *wcs, co
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsbchk(struct wcsprm *wcs, int bounds)
 
@@ -2181,7 +2178,7 @@ int wcsbchk(struct wcsprm *wcs, int boun
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsset(struct wcsprm *wcs)
 
@@ -2204,12 +2201,12 @@ int wcsset(struct wcsprm *wcs)
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
-  /* Determine axis types from CTYPEia. */
+  // Determine axis types from CTYPEia.
   if ((status = wcs_types(wcs))) {
     return status;
   }
 
-  /* Convert to canonical units. */
+  // Convert to canonical units.
   if ((status = wcs_units(wcs))) {
     return status;
   }
@@ -2221,45 +2218,45 @@ int wcsset(struct wcsprm *wcs)
   }
 
 
-  /* Non-linear celestial axes present? */
+  // Non-linear celestial axes present?
   if (wcs->lng >= 0 && wcs->types[wcs->lng] == 2200) {
     celini(wcscel);
 
-    /* CRVALia, LONPOLEa, and LATPOLEa keyvalues. */
+    // CRVALia, LONPOLEa, and LATPOLEa keyvalues.
     wcscel->ref[0] = wcs->crval[wcs->lng];
     wcscel->ref[1] = wcs->crval[wcs->lat];
     wcscel->ref[2] = wcs->lonpole;
     wcscel->ref[3] = wcs->latpole;
 
-    /* Do alias translation for TPU/TPV before dealing with PVi_ma. */
+    // Do alias translation for TPU/TPV before dealing with PVi_ma.
     strncpy(wcsprj->code, wcs->ctype[wcs->lng]+5, 3);
     wcsprj->code[3] = '\0';
     if (strncmp(wcsprj->code, "TPU", 3) == 0 ||
         strncmp(wcsprj->code, "TPV", 3) == 0) {
-      /* Translate the PV parameters. */
+      // Translate the PV parameters.
       if ((dis = calloc(1, sizeof(struct disprm))) == 0x0) {
         return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
       }
 
       ndpmax = 6 + wcs->npv;
 
-      /* Attach it to linprm.  Also inits it. */
+      // Attach it to linprm.  Also inits it.
       dis->flag = -1;
       if (strncmp(wcsprj->code, "TPU", 3) == 0) {
-        /* Prior distortion. */
+        // Prior distortion.
         lindist(1, wcslin, dis, ndpmax);
         strcpy(dpq, "DP");
       } else {
-        /* Sequent distortion. */
+        // Sequent distortion.
         lindist(2, wcslin, dis, ndpmax);
         strcpy(dpq, "DQ");
       }
 
-      /* Yes, the distortion type is "TPV" even for TPU. */
+      // Yes, the distortion type is "TPV" even for TPU.
       strcpy(dis->dtype[wcs->lng], "TPV");
       strcpy(dis->dtype[wcs->lat], "TPV");
 
-      /* Keep the keywords in axis-order to aid debugging. */
+      // Keep the keywords in axis-order to aid debugging.
       keyp = dis->dp;
       dis->ndp = 0;
 
@@ -2269,7 +2266,7 @@ int wcsset(struct wcsprm *wcs)
       dpfill(keyp++, dpq, "AXIS.2", 0, 0, 2, 0.0);
       dis->ndp += 3;
 
-      /* Copy distortion parameters for the longitude axis. */
+      // Copy distortion parameters for the longitude axis.
       for (k = 0; k < wcs->npv; k++) {
         if (wcs->pv[k].i != wcs->lng+1) continue;
         sprintf(keyp->field, "%s.TPV.%d", dpq, wcs->pv[k].m);
@@ -2277,7 +2274,7 @@ int wcsset(struct wcsprm *wcs)
         dis->ndp++;
       }
 
-      /* Now the latitude axis. */
+      // Now the latitude axis.
       sprintf(dpq+2, "%d", wcs->lat+1);
       dpfill(keyp++, dpq, "NAXES",  0, 0, 2, 0.0);
       dpfill(keyp++, dpq, "AXIS.1", 0, 0, 2, 0.0);
@@ -2291,7 +2288,7 @@ int wcsset(struct wcsprm *wcs)
         dis->ndp++;
       }
 
-      /* Erase PVi_ma associated with the celestial axes. */
+      // Erase PVi_ma associated with the celestial axes.
       n = 0;
       for (k = 0; k < wcs->npv; k++) {
         i = wcs->pv[k].i - 1;
@@ -2307,28 +2304,28 @@ int wcsset(struct wcsprm *wcs)
       wcs->npv = n;
       strcpy(wcsprj->code, "TAN");
 
-      /* As the PVi_ma have now been erased, ctype must be reset to prevent
-         this translation from re-occurring if wcsset() is called again. */
+      // As the PVi_ma have now been erased, ctype must be reset to prevent
+      // this translation from re-occurring if wcsset() is called again.
       strcpy(wcs->ctype[wcs->lng]+5, "TAN");
       strcpy(wcs->ctype[wcs->lat]+5, "TAN");
 
     } else if (strncmp(wcsprj->code, "TNX", 3) == 0) {
-      /* The WAT distortion should already have been encoded in disseq. */
+      // The WAT distortion should already have been encoded in disseq.
       strcpy(wcsprj->code, "TAN");
       strcpy(wcs->ctype[wcs->lng]+5, "TAN");
       strcpy(wcs->ctype[wcs->lat]+5, "TAN");
 
     } else if (strncmp(wcsprj->code, "ZPX", 3) == 0) {
-      /* The WAT distortion should already have been encoded in disseq. */
+      // The WAT distortion should already have been encoded in disseq.
       strcpy(wcsprj->code, "ZPN");
       strcpy(wcs->ctype[wcs->lng]+5, "ZPN");
       strcpy(wcs->ctype[wcs->lat]+5, "ZPN");
     }
 
-    /* PVi_ma keyvalues. */
+    // PVi_ma keyvalues.
     for (k = 0; k < wcs->npv; k++) {
       if (wcs->pv[k].i == 0) {
-        /* From a PROJPn keyword. */
+        // From a PROJPn keyword.
         wcs->pv[k].i = wcs->lat + 1;
       }
 
@@ -2336,13 +2333,13 @@ int wcsset(struct wcsprm *wcs)
       m = wcs->pv[k].m;
 
       if (i == wcs->lat) {
-        /* PVi_ma associated with latitude axis. */
+        // PVi_ma associated with latitude axis.
         if (m < 30) {
           wcsprj->pv[m] = wcs->pv[k].value;
         }
 
       } else if (i == wcs->lng) {
-        /* PVi_ma associated with longitude axis. */
+        // PVi_ma associated with longitude axis.
         switch (m) {
         case 0:
           wcscel->offset = (wcs->pv[k].value != 0.0);
@@ -2354,11 +2351,11 @@ int wcsset(struct wcsprm *wcs)
           wcscel->theta0 = wcs->pv[k].value;
           break;
         case 3:
-          /* If present, overrides LONPOLEa. */
+          // If present, overrides LONPOLEa.
           wcscel->ref[2] = wcs->pv[k].value;
           break;
         case 4:
-          /* If present, overrides LATPOLEa. */
+          // If present, overrides LATPOLEa.
           wcscel->ref[3] = wcs->pv[k].value;
           break;
         default:
@@ -2370,7 +2367,7 @@ int wcsset(struct wcsprm *wcs)
       }
     }
 
-    /* Do simple alias translations. */
+    // Do simple alias translations.
     if (strncmp(wcs->ctype[wcs->lng]+5, "GLS", 3) == 0) {
       wcscel->offset = 1;
       wcscel->phi0   = 0.0;
@@ -2378,7 +2375,7 @@ int wcsset(struct wcsprm *wcs)
       strcpy(wcsprj->code, "SFL");
 
     } else if (strncmp(wcs->ctype[wcs->lng]+5, "NCP", 3) == 0) {
-      /* Convert NCP to SIN. */
+      // Convert NCP to SIN.
       if (wcscel->ref[1] == 0.0) {
         return wcserr_set(WCSERR_SET(WCSERR_BAD_PARAM),
           "Invalid projection: NCP blows up on the equator");
@@ -2389,13 +2386,13 @@ int wcsset(struct wcsprm *wcs)
       wcsprj->pv[2] = cosd(wcscel->ref[1])/sind(wcscel->ref[1]);
     }
 
-    /* Initialize the celestial transformation routines. */
+    // Initialize the celestial transformation routines.
     wcsprj->r0 = 0.0;
     if ((status = celset(wcscel))) {
       return wcserr_set(WCS_ERRMSG(wcs_celerr[status]));
     }
 
-    /* Update LONPOLE, LATPOLE, and PVi_ma keyvalues. */
+    // Update LONPOLE, LATPOLE, and PVi_ma keyvalues.
     wcs->lonpole = wcscel->ref[2];
     wcs->latpole = wcscel->ref[3];
 
@@ -2423,7 +2420,7 @@ int wcsset(struct wcsprm *wcs)
   }
 
 
-  /* Non-linear spectral axis present? */
+  // Non-linear spectral axis present?
   if (wcs->spec >= 0 && wcs->types[wcs->spec] == 3300) {
     spcini(wcsspc);
     if ((status = spctype(wcs->ctype[wcs->spec], stype, scode, 0x0, 0x0, 0x0,
@@ -2433,32 +2430,32 @@ int wcsset(struct wcsprm *wcs)
     strcpy(wcsspc->type, stype);
     strcpy(wcsspc->code, scode);
 
-    /* CRVALia, RESTFRQa, and RESTWAVa keyvalues. */
+    // CRVALia, RESTFRQa, and RESTWAVa keyvalues.
     wcsspc->crval = wcs->crval[wcs->spec];
     wcsspc->restfrq = wcs->restfrq;
     wcsspc->restwav = wcs->restwav;
 
-    /* PVi_ma keyvalues. */
+    // PVi_ma keyvalues.
     for (k = 0; k < wcs->npv; k++) {
       i = wcs->pv[k].i - 1;
       m = wcs->pv[k].m;
 
       if (i == wcs->spec) {
-        /* PVi_ma associated with grism axis. */
+        // PVi_ma associated with grism axis.
         if (m < 7) {
           wcsspc->pv[m] = wcs->pv[k].value;
         }
       }
     }
 
-    /* Initialize the spectral transformation routines. */
+    // Initialize the spectral transformation routines.
     if ((status = spcset(wcsspc))) {
       return wcserr_set(WCS_ERRMSG(wcs_spcerr[status]));
     }
   }
 
 
-  /* Tabular axes present? */
+  // Tabular axes present?
   for (j = 0; j < wcs->ntab; j++) {
     if ((status = tabset(wcs->tab + j))) {
       return wcserr_set(WCS_ERRMSG(wcs_taberr[status]));
@@ -2466,13 +2463,13 @@ int wcsset(struct wcsprm *wcs)
   }
 
 
-  /* Initialize the linear transformation. */
+  // Initialize the linear transformation.
   wcs->altlin &= 7;
   if (wcs->altlin > 1 && !(wcs->altlin & 1)) {
     pc = wcs->pc;
 
     if (wcs->altlin & 2) {
-      /* Copy CDi_ja to PCi_ja and reset CDELTia. */
+      // Copy CDi_ja to PCi_ja and reset CDELTia.
       cd = wcs->cd;
       for (i = 0; i < naxis; i++) {
         for (j = 0; j < naxis; j++) {
@@ -2482,7 +2479,7 @@ int wcsset(struct wcsprm *wcs)
       }
 
     } else if (wcs->altlin & 4) {
-      /* Construct PCi_ja from CROTAia. */
+      // Construct PCi_ja from CROTAia.
       if ((i = wcs->lng) >= 0 && (j = wcs->lat) >= 0) {
         rho = wcs->crota[j];
 
@@ -2508,7 +2505,7 @@ int wcsset(struct wcsprm *wcs)
   }
 
 
-  /* Set defaults for radesys and equinox for equatorial or ecliptic. */
+  // Set defaults for radesys and equinox for equatorial or ecliptic.
   if (strcmp(wcs->lngtyp, "RA")   == 0 ||
       strcmp(wcs->lngtyp, "ELON") == 0 ||
       strcmp(wcs->lngtyp, "HLON") == 0) {
@@ -2523,7 +2520,7 @@ int wcsset(struct wcsprm *wcs)
 
     } else if (strcmp(wcs->radesys, "ICRS")  == 0 ||
                strcmp(wcs->radesys, "GAPPT") == 0) {
-      /* Equinox is not applicable for these coordinate systems. */
+      // Equinox is not applicable for these coordinate systems.
       wcs->equinox = UNDEFINED;
 
     } else if (undefined(wcs->equinox)) {
@@ -2536,13 +2533,13 @@ int wcsset(struct wcsprm *wcs)
     }
 
   } else {
-    /* No celestial axes, ensure that radesys and equinox are unset. */
+    // No celestial axes, ensure that radesys and equinox are unset.
     memset(wcs->radesys, 0, 72);
     wcs->equinox = UNDEFINED;
   }
 
 
-  /* Strip off trailing blanks and null-fill auxiliary string members. */
+  // Strip off trailing blanks and null-fill auxiliary string members.
   if (wcs->alt[0] == '\0') wcs->alt[0] = ' ';
   memset(wcs->alt+1, '\0', 3);
 
@@ -2566,7 +2563,7 @@ int wcsset(struct wcsprm *wcs)
   wcsutil_null_fill(72, wcs->ssysobs);
   wcsutil_null_fill(72, wcs->ssyssrc);
 
-  /* MJDREF defaults to zero if no reference date keywords were defined. */
+  // MJDREF defaults to zero if no reference date keywords were defined.
   if (wcs->dateref[0] == '\0') {
     if (undefined(wcs->mjdref[0])) {
       wcs->mjdref[0] = 0.0;
@@ -2581,7 +2578,7 @@ int wcsset(struct wcsprm *wcs)
   return 0;
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int wcs_types(struct wcsprm *wcs)
 
@@ -2599,7 +2596,7 @@ int wcs_types(struct wcsprm *wcs)
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
-  /* Parse the CTYPEia keyvalues. */
+  // Parse the CTYPEia keyvalues.
   pcode[0]  = '\0';
   requir[0] = '\0';
   wcs->lng  = -1;
@@ -2617,63 +2614,63 @@ int wcs_types(struct wcsprm *wcs)
   }
 
   for (i = 0; i < naxis; i++) {
-    /* Null fill. */
+    // Null fill.
     wcsutil_null_fill(72, wcs->ctype[i]);
 
     strncpy(ctypei, wcs->ctype[i], 15);
     ctypei[15] = '\0';
 
-    /* Check for early Paper IV syntax (e.g. '-SIP' used by Spitzer). */
+    // Check for early Paper IV syntax (e.g. '-SIP' used by Spitzer).
     if (strlen(ctypei) == 12 && ctypei[8] == '-') {
-      /* Excise the "4-3-3" or "8-3"-form distortion code. */
+      // Excise the "4-3-3" or "8-3"-form distortion code.
       ctypei[8] = '\0';
 
-      /* Remove trailing dashes from "8-3"-form codes. */
+      // Remove trailing dashes from "8-3"-form codes.
       for (j = 7; j > 0; j--) {
         if (ctypei[j] != '-') break;
         ctypei[j] = '\0';
       }
     }
 
-    /* Logarithmic or tabular axis? */
+    // Logarithmic or tabular axis?
     wcs->types[i] = 0;
     if (strcmp(ctypei+4, "-LOG") == 0) {
-      /* Logarithmic axis. */
+      // Logarithmic axis.
       wcs->types[i] = 400;
 
     } else if (strcmp(ctypei+4, "-TAB") == 0) {
-      /* Tabular axis. */
+      // Tabular axis.
       wcs->types[i] = 500;
     }
 
     if (wcs->types[i]) {
-      /* Could have -LOG or -TAB with celestial or spectral types. */
+      // Could have -LOG or -TAB with celestial or spectral types.
       ctypei[4] = '\0';
 
-      /* Take care of things like 'FREQ-LOG' or 'RA---TAB'. */
+      // Take care of things like 'FREQ-LOG' or 'RA---TAB'.
       for (j = 3; j >= 0; j--) {
         if (ctypei[j] != '-') break;
         ctypei[j] = '\0';
       }
     }
 
-    /* Translate AIPS spectral types for spctyp(). */
+    // Translate AIPS spectral types for spctyp().
     if (spcaips(ctypei, wcs->velref, ctypei, specsys) == 0) {
       strcpy(wcs->ctype[i], ctypei);
       if (wcs->specsys[0] == '\0') strcpy(wcs->specsys, specsys);
     }
 
-    /* Process linear axes. */
+    // Process linear axes.
     if (!(strlen(ctypei) == 8 && ctypei[4] == '-')) {
-      /* Identify Stokes, celestial and spectral types. */
+      // Identify Stokes, celestial and spectral types.
       if (strcmp(ctypei, "STOKES") == 0) {
-        /* STOKES axis. */
+        // STOKES axis.
         wcs->types[i] = 1100;
 
       } else if (strcmp(ctypei, "RA")  == 0 ||
         strcmp(ctypei+1, "LON") == 0 ||
         strcmp(ctypei+2, "LN")  == 0) {
-        /* Longitude axis. */
+        // Longitude axis.
         wcs->types[i] += 2000;
         if (wcs->lng < 0) {
           wcs->lng = i;
@@ -2683,7 +2680,7 @@ int wcs_types(struct wcsprm *wcs)
       } else if (strcmp(ctypei,   "DEC") == 0 ||
                  strcmp(ctypei+1, "LAT") == 0 ||
                  strcmp(ctypei+2, "LT")  == 0) {
-        /* Latitude axis. */
+        // Latitude axis.
         wcs->types[i] += 2001;
         if (wcs->lat < 0) {
           wcs->lat = i;
@@ -2691,19 +2688,19 @@ int wcs_types(struct wcsprm *wcs)
         }
 
       } else if (strcmp(ctypei, "CUBEFACE") == 0) {
-        /* CUBEFACE axis. */
+        // CUBEFACE axis.
         if (wcs->cubeface == -1) {
           wcs->types[i] = 2102;
           wcs->cubeface = i;
         } else {
-          /* Multiple CUBEFACE axes! */
+          // Multiple CUBEFACE axes!
           return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
             "Multiple CUBEFACE axes (in CTYPE%d%.1s and CTYPE%d%.1s)",
             wcs->cubeface+1, alt, i+1, alt);
         }
 
       } else if (spctyp(ctypei, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0) == 0) {
-        /* Spectral axis. */
+        // Spectral axis.
         if (wcs->spec < 0) wcs->spec = i;
         wcs->types[i] += 3000;
       }
@@ -2712,12 +2709,12 @@ int wcs_types(struct wcsprm *wcs)
     }
 
 
-    /* CTYPEia is in "4-3" form; is it a recognized spectral type? */
+    // CTYPEia is in "4-3" form; is it a recognized spectral type?
     if (spctyp(ctypei, 0x0, scode, 0x0, 0x0, 0x0, 0x0, 0x0) == 0) {
-      /* Non-linear spectral axis found. */
+      // Non-linear spectral axis found.
       wcs->types[i] = 3300;
 
-      /* Check uniqueness. */
+      // Check uniqueness.
       if (wcs->spec >= 0) {
         return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
           "Multiple spectral axes (in CTYPE%d%.1s and CTYPE%d%.1s)",
@@ -2730,19 +2727,19 @@ int wcs_types(struct wcsprm *wcs)
     }
 
 
-    /* Is it a recognized celestial projection? */
+    // Is it a recognized celestial projection?
     for (j = 0; j < prj_ncode; j++) {
       if (strncmp(ctypei+5, prj_codes[j], 3) == 0) break;
     }
 
     if (j == prj_ncode) {
-      /* Not a standard projection code, maybe it's an alias. */
+      // Not a standard projection code, maybe it's an alias.
       for (j = 0; j < nalias; j++) {
         if (strncmp(ctypei+5, aliases[j], 3) == 0) break;
       }
 
       if (j == nalias) {
-        /* Not a recognized algorithm code of any type. */
+        // Not a recognized algorithm code of any type.
         wcs->types[i] = -1;
         return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
           "Unrecognized projection code (%s in CTYPE%d%.1s)",
@@ -2750,10 +2747,10 @@ int wcs_types(struct wcsprm *wcs)
       }
     }
 
-    /* Parse the celestial axis type. */
+    // Parse the celestial axis type.
     wcs->types[i] = 2200;
     if (*pcode == '\0') {
-      /* The first of the two celestial axes. */
+      // The first of the two celestial axes.
       sprintf(pcode, "%.3s", ctypei+5);
 
       if (strncmp(ctypei, "RA--", 4) == 0) {
@@ -2793,7 +2790,7 @@ int wcs_types(struct wcsprm *wcs)
         ndx = &wcs->lng;
         sprintf(requir, "%s-%s", wcs->lngtyp, pcode);
       } else {
-        /* Unrecognized celestial type. */
+        // Unrecognized celestial type.
         wcs->types[i] = -1;
 
         wcs->lng = -1;
@@ -2806,11 +2803,11 @@ int wcs_types(struct wcsprm *wcs)
       if (wcs->lat >= 0) wcs->types[i]++;
 
     } else {
-      /* Looking for the complementary celestial axis. */
+      // Looking for the complementary celestial axis.
       if (wcs->lat < 0) wcs->types[i]++;
 
       if (strncmp(ctypei, requir, 8) != 0) {
-        /* Inconsistent projection types. */
+        // Inconsistent projection types.
         wcs->lng = -1;
         wcs->lat = -1;
         return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE), "Inconsistent "
@@ -2823,19 +2820,19 @@ int wcs_types(struct wcsprm *wcs)
     }
   }
 
-  /* Do we have a complementary pair of celestial axes? */
+  // Do we have a complementary pair of celestial axes?
   if (strcmp(requir, "")) {
-    /* Unmatched celestial axis. */
+    // Unmatched celestial axis.
     wcs->lng = -1;
     wcs->lat = -1;
     return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
       "Unmatched celestial axes");
   }
 
-  /* Table group numbers. */
+  // Table group numbers.
   for (j = 0; j < wcs->ntab; j++) {
     for (m = 0; m < wcs->tab[j].M; m++) {
-      /* Get image axis number. */
+      // Get image axis number.
       i = wcs->tab[j].map[m];
 
       type = (wcs->types[i] / 100) % 10;
@@ -2850,7 +2847,7 @@ int wcs_types(struct wcsprm *wcs)
   return 0;
 }
 
-/* : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  */
+// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :
 
 int wcs_units(struct wcsprm *wcs)
 
@@ -2867,15 +2864,15 @@ int wcs_units(struct wcsprm *wcs)
 
   naxis = wcs->naxis;
   for (i = 0; i < naxis; i++) {
-    /* Use types set by wcs_types(). */
+    // Use types set by wcs_types().
     switch (wcs->types[i]/1000) {
     case 2:
-      /* Celestial axis. */
+      // Celestial axis.
       strcpy(units, "deg");
       break;
 
     case 3:
-      /* Spectral axis. */
+      // Spectral axis.
       strncpy(ctype, wcs->ctype[i], 8);
       ctype[8] = '\0';
       spctyp(ctype, 0x0, 0x0, 0x0, units, 0x0, 0x0, 0x0);
@@ -2885,7 +2882,7 @@ int wcs_units(struct wcsprm *wcs)
       continue;
     }
 
-    /* Tabular axis, CDELTia and CRVALia relate to indices. */
+    // Tabular axis, CDELTia and CRVALia relate to indices.
     if ((wcs->types[i]/100)%10 == 5) {
       continue;
     }
@@ -2894,9 +2891,12 @@ int wcs_units(struct wcsprm *wcs)
     if (wcs->cunit[i][0]) {
       if (wcsunitse(wcs->cunit[i], units, &scale, &offset, &power,
                     &uniterr)) {
-        wcserr_set(WCSERR_SET(WCSERR_BAD_COORD_TRANS),
-          "In CUNIT%d%.1s: %s", i+1, (*wcs->alt)?wcs->alt:"", uniterr->msg);
-        free(uniterr);
+        if (uniterr) {
+          // uniterr will not be set if wcserr is not enabled.
+          wcserr_set(WCSERR_SET(WCSERR_BAD_COORD_TRANS),
+            "In CUNIT%d%.1s: %s", i+1, (*wcs->alt)?wcs->alt:"", uniterr->msg);
+          free(uniterr);
+        }
         return WCSERR_BAD_COORD_TRANS;
       }
 
@@ -2919,7 +2919,7 @@ int wcs_units(struct wcsprm *wcs)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsp2s(
   struct wcsprm *wcs,
@@ -2943,7 +2943,7 @@ int wcsp2s(
   struct prjprm *wcsprj = &(wcscel->prj);
   struct wcserr **err;
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
@@ -2951,19 +2951,19 @@ int wcsp2s(
     if ((status = wcsset(wcs))) return status;
   }
 
-  /* Sanity check. */
+  // Sanity check.
   if (ncoord < 1 || (ncoord > 1 && nelem < wcs->naxis)) {
     return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
       "ncoord and/or nelem inconsistent with the wcsprm");
   }
 
 
-  /* Apply pixel-to-world linear transformation. */
+  // Apply pixel-to-world linear transformation.
   if ((status = linp2x(&(wcs->lin), ncoord, nelem, pixcrd, imgcrd))) {
     return wcserr_set(WCS_ERRMSG(wcs_linerr[status]));
   }
 
-  /* Initialize status vectors. */
+  // Initialize status vectors.
   if ((istatp = calloc(ncoord, sizeof(int))) == 0x0) {
     return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
   }
@@ -2972,13 +2972,13 @@ int wcsp2s(
   wcsutil_setAli(ncoord, 1, stat);
 
 
-  /* Convert intermediate world coordinates to world coordinates. */
+  // Convert intermediate world coordinates to world coordinates.
   for (i = 0; i < wcs->naxis; i++) {
-    /* Extract the second digit of the axis type code. */
+    // Extract the second digit of the axis type code.
     type = (wcs->types[i] / 100) % 10;
 
     if (type <= 1) {
-      /* Linear or quantized coordinate axis. */
+      // Linear or quantized coordinate axis.
       img = imgcrd + i;
       wrl = world  + i;
       crvali = wcs->crval[i];
@@ -2989,16 +2989,16 @@ int wcsp2s(
       }
 
     } else if (wcs->types[i] == 2200) {
-      /* Convert celestial coordinates; do we have a CUBEFACE axis? */
+      // Convert celestial coordinates; do we have a CUBEFACE axis?
       if (wcs->cubeface != -1) {
-        /* Separation between faces. */
+        // Separation between faces.
         if (wcsprj->r0 == 0.0) {
           offset = 90.0;
         } else {
           offset = wcsprj->r0*PI/2.0;
         }
 
-        /* Lay out faces in a plane. */
+        // Lay out faces in a plane.
         img = imgcrd;
         statp = stat;
         bits = (1 << i) | (1 << wcs->lat);
@@ -3039,7 +3039,7 @@ int wcsp2s(
         }
       }
 
-      /* Check for constant x and/or y. */
+      // Check for constant x and/or y.
       nx = ncoord;
       ny = 0;
 
@@ -3051,7 +3051,7 @@ int wcsp2s(
         ny = 1;
       }
 
-      /* Transform projection plane coordinates to celestial coordinates. */
+      // Transform projection plane coordinates to celestial coordinates.
       if ((istat = celx2s(wcscel, nx, ny, nelem, nelem, imgcrd+i,
                           imgcrd+wcs->lat, phi, theta, world+i,
                           world+wcs->lat, istatp))) {
@@ -3063,7 +3063,7 @@ int wcsp2s(
         }
       }
 
-      /* If x and y were both constant, replicate values. */
+      // If x and y were both constant, replicate values.
       if (iso_x && iso_y) {
         wcsutil_setAll(ncoord, nelem, world+i);
         wcsutil_setAll(ncoord, nelem, world+wcs->lat);
@@ -3078,7 +3078,7 @@ int wcsp2s(
       }
 
     } else if (type == 3 || type == 4) {
-      /* Check for constant x. */
+      // Check for constant x.
       nx = ncoord;
       if ((iso_x = wcsutil_allEq(ncoord, nelem, imgcrd+i))) {
         nx = 1;
@@ -3086,7 +3086,7 @@ int wcsp2s(
 
       istat = 0;
       if (wcs->types[i] == 3300) {
-        /* Spectral coordinates. */
+        // Spectral coordinates.
         istat = spcx2s(&(wcs->spc), nx, nelem, nelem, imgcrd+i, world+i,
                        istatp);
         if (istat) {
@@ -3096,7 +3096,7 @@ int wcsp2s(
           }
         }
       } else if (type == 4) {
-        /* Logarithmic coordinates. */
+        // Logarithmic coordinates.
         istat = logx2s(wcs->crval[i], nx, nelem, nelem, imgcrd+i, world+i,
                        istatp);
         if (istat) {
@@ -3107,7 +3107,7 @@ int wcsp2s(
         }
       }
 
-      /* If x was constant, replicate values. */
+      // If x was constant, replicate values.
       if (iso_x) {
         wcsutil_setAll(ncoord, nelem, world+i);
         wcsutil_setAli(ncoord, 1, istatp);
@@ -3120,7 +3120,7 @@ int wcsp2s(
   }
 
 
-  /* Do tabular coordinates. */
+  // Do tabular coordinates.
   for (itab = 0; itab < wcs->ntab; itab++) {
     istat = tabx2s(wcs->tab + itab, ncoord, nelem, imgcrd, world, istatp);
 
@@ -3141,7 +3141,7 @@ int wcsp2s(
   }
 
 
-  /* Zero the unused world coordinate elements. */
+  // Zero the unused world coordinate elements.
   for (i = wcs->naxis; i < nelem; i++) {
     world[i] = 0.0;
     wcsutil_setAll(ncoord, nelem, world+i);
@@ -3152,7 +3152,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcss2p(
   struct wcsprm* wcs,
@@ -3178,7 +3178,7 @@ int wcss2p(
   struct wcserr **err;
 
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
@@ -3186,13 +3186,13 @@ int wcss2p(
     if ((status = wcsset(wcs))) return status;
   }
 
-  /* Sanity check. */
+  // Sanity check.
   if (ncoord < 1 || (ncoord > 1 && nelem < wcs->naxis)) {
     return wcserr_set(WCSERR_SET(WCSERR_BAD_CTYPE),
       "ncoord and/or nelem inconsistent with the wcsprm");
   }
 
-  /* Initialize status vectors. */
+  // Initialize status vectors.
   if ((istatp = calloc(ncoord, sizeof(int))) == 0x0) {
     return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));
   }
@@ -3202,13 +3202,13 @@ int wcss2p(
   wcsutil_setAli(ncoord, 1, stat);
 
 
-  /* Convert world coordinates to intermediate world coordinates. */
+  // Convert world coordinates to intermediate world coordinates.
   for (i = 0; i < wcs->naxis; i++) {
-    /* Extract the second digit of the axis type code. */
+    // Extract the second digit of the axis type code.
     type = (wcs->types[i] / 100) % 10;
 
     if (type <= 1) {
-      /* Linear or quantized coordinate axis. */
+      // Linear or quantized coordinate axis.
       wrl = world  + i;
       img = imgcrd + i;
       crvali = wcs->crval[i];
@@ -3219,7 +3219,7 @@ int wcss2p(
       }
 
     } else if (wcs->types[i] == 2200) {
-      /* Celestial coordinates; check for constant lng and/or lat. */
+      // Celestial coordinates; check for constant lng and/or lat.
       nlng = ncoord;
       nlat = 0;
 
@@ -3231,7 +3231,7 @@ int wcss2p(
         nlat = 1;
       }
 
-      /* Transform celestial coordinates to projection plane coordinates. */
+      // Transform celestial coordinates to projection plane coordinates.
       if ((istat = cels2x(wcscel, nlng, nlat, nelem, nelem, world+i,
                           world+wcs->lat, phi, theta, imgcrd+i,
                           imgcrd+wcs->lat, istatp))) {
@@ -3243,7 +3243,7 @@ int wcss2p(
         }
       }
 
-      /* If lng and lat were both constant, replicate values. */
+      // If lng and lat were both constant, replicate values.
       if (isolng && isolat) {
         wcsutil_setAll(ncoord, nelem, imgcrd+i);
         wcsutil_setAll(ncoord, nelem, imgcrd+wcs->lat);
@@ -3257,16 +3257,16 @@ int wcss2p(
         wcsutil_setBit(ncoord, istatp, bits, stat);
       }
 
-      /* Do we have a CUBEFACE axis? */
+      // Do we have a CUBEFACE axis?
       if (wcs->cubeface != -1) {
-        /* Separation between faces. */
+        // Separation between faces.
         if (wcsprj->r0 == 0.0) {
           offset = 90.0;
         } else {
           offset = wcsprj->r0*PI/2.0;
         }
 
-        /* Stack faces in a cube. */
+        // Stack faces in a cube.
         img = imgcrd;
         for (k = 0; k < ncoord; k++) {
           if (*(img+wcs->lat) < -0.5*offset) {
@@ -3293,7 +3293,7 @@ int wcss2p(
       }
 
     } else if (type == 3 || type == 4) {
-      /* Check for constancy. */
+      // Check for constancy.
       nwrld = ncoord;
       if ((isospec = wcsutil_allEq(ncoord, nelem, world+i))) {
         nwrld = 1;
@@ -3301,7 +3301,7 @@ int wcss2p(
 
       istat = 0;
       if (wcs->types[i] == 3300) {
-        /* Spectral coordinates. */
+        // Spectral coordinates.
         istat = spcs2x(&(wcs->spc), nwrld, nelem, nelem, world+i,
                        imgcrd+i, istatp);
         if (istat) {
@@ -3311,7 +3311,7 @@ int wcss2p(
           }
         }
       } else if (type == 4) {
-        /* Logarithmic coordinates. */
+        // Logarithmic coordinates.
         istat = logs2x(wcs->crval[i], nwrld, nelem, nelem, world+i,
                        imgcrd+i, istatp);
         if (istat) {
@@ -3322,7 +3322,7 @@ int wcss2p(
         }
       }
 
-      /* If constant, replicate values. */
+      // If constant, replicate values.
       if (isospec) {
         wcsutil_setAll(ncoord, nelem, imgcrd+i);
         wcsutil_setAli(ncoord, 1, istatp);
@@ -3335,7 +3335,7 @@ int wcss2p(
   }
 
 
-  /* Do tabular coordinates. */
+  // Do tabular coordinates.
   for (itab = 0; itab < wcs->ntab; itab++) {
     istat = tabs2x(wcs->tab + itab, ncoord, nelem, world, imgcrd, istatp);
 
@@ -3356,14 +3356,14 @@ int wcss2p(
   }
 
 
-  /* Zero the unused intermediate world coordinate elements. */
+  // Zero the unused intermediate world coordinate elements.
   for (i = wcs->naxis; i < nelem; i++) {
     imgcrd[i] = 0.0;
     wcsutil_setAll(ncoord, nelem, imgcrd+i);
   }
 
 
-  /* Apply world-to-pixel linear transformation. */
+  // Apply world-to-pixel linear transformation.
   if ((istat = linx2p(&(wcs->lin), ncoord, nelem, imgcrd, pixcrd))) {
     status = wcserr_set(WCS_ERRMSG(wcs_linerr[istat]));
     goto cleanup;
@@ -3374,7 +3374,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsmix(
   struct wcsprm *wcs,
@@ -3408,7 +3408,7 @@ int wcsmix(
   struct wcsprm wcs0;
   struct wcserr **err;
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
@@ -3420,24 +3420,24 @@ int wcsmix(
   worldlat = world + wcs->lat;
 
 
-  /* Check vspan. */
+  // Check vspan.
   if (vspan[0] <= vspan[1]) {
     span[0] = vspan[0];
     span[1] = vspan[1];
   } else {
-    /* Swap them. */
+    // Swap them.
     span[0] = vspan[1];
     span[1] = vspan[0];
   }
 
-  /* Check vstep. */
+  // Check vstep.
   step = fabs(vstep);
   if (step == 0.0) {
     step = (span[1] - span[0])/10.0;
     if (step > 1.0 || step == 0.0) step = 1.0;
   }
 
-  /* Check viter. */
+  // Check viter.
   nstep = viter;
   if (nstep < 5) {
     nstep = 5;
@@ -3445,18 +3445,18 @@ int wcsmix(
     nstep = 10;
   }
 
-  /* Given pixel element. */
+  // Given pixel element.
   pixmix = pixcrd[mixpix];
 
-  /* Iterate on the step size. */
+  // Iterate on the step size.
   for (istep = 0; istep <= nstep; istep++) {
     if (istep) step /= 2.0;
 
-    /* Iterate on the sky coordinate between the specified range. */
+    // Iterate on the sky coordinate between the specified range.
     if (mixcel == 1) {
-      /* Celestial longitude is given. */
+      // Celestial longitude is given.
 
-      /* Check whether the solution interval is a crossing interval. */
+      // Check whether the solution interval is a crossing interval.
       lat0 = span[0];
       *worldlat = lat0;
       if ((status = wcss2p(wcs, 1, 0, world, phi, theta, imgcrd, pixcrd,
@@ -3488,7 +3488,7 @@ int wcsmix(
       lmin = lat1;
       dmin = dabs;
 
-      /* Check for a crossing point. */
+      // Check for a crossing point.
       if (signbit(d0) != signbit(d1)) {
         crossed = 1;
         dx = d1;
@@ -3498,7 +3498,7 @@ int wcsmix(
       }
 
       for (retry = 0; retry < 4; retry++) {
-        /* Refine the solution interval. */
+        // Refine the solution interval.
         while (lat0 > span[0]) {
           lat0 -= step;
           if (lat0 < span[0]) lat0 = span[0];
@@ -3512,32 +3512,32 @@ int wcsmix(
           }
           d0 = pixcrd[mixpix] - pixmix;
 
-          /* Check for a solution. */
+          // Check for a solution.
           dabs = fabs(d0);
           if (dabs < tol) return 0;
 
-          /* Record the point of closest approach. */
+          // Record the point of closest approach.
           if (dabs < dmin) {
             lmin = lat0;
             dmin = dabs;
           }
 
-          /* Check for a crossing point. */
+          // Check for a crossing point.
           if (signbit(d0) != signbit(d1)) {
             crossed = 2;
             dx = d0;
             break;
           }
 
-          /* Advance to the next subinterval. */
+          // Advance to the next subinterval.
           lat1 = lat0;
           d1 = d0;
         }
 
         if (crossed) {
-          /* A crossing point was found. */
+          // A crossing point was found.
           for (iter = 0; iter < niter; iter++) {
-            /* Use regula falsi division of the interval. */
+            // Use regula falsi division of the interval.
             lambda = d0/(d0-d1);
             if (lambda < 0.1) {
               lambda = 0.1;
@@ -3556,20 +3556,20 @@ int wcsmix(
               return status;
             }
 
-            /* Check for a solution. */
+            // Check for a solution.
             d = pixcrd[mixpix] - pixmix;
             dabs = fabs(d);
             if (dabs < tol) return 0;
 
             if (dlat < tol) {
-              /* An artifact of numerical imprecision. */
+              // An artifact of numerical imprecision.
               if (dabs < tol2) return 0;
 
-              /* Must be a discontinuity. */
+              // Must be a discontinuity.
               break;
             }
 
-            /* Record the point of closest approach. */
+            // Record the point of closest approach.
             if (dabs < dmin) {
               lmin = lat;
               dmin = dabs;
@@ -3584,14 +3584,14 @@ int wcsmix(
             }
           }
 
-          /* No convergence, must have been a discontinuity. */
+          // No convergence, must have been a discontinuity.
           if (crossed == 1) lat0 = span[1];
           lat1 = lat0;
           d1 = dx;
           crossed = 0;
 
         } else {
-          /* No crossing point; look for a tangent point. */
+          // No crossing point; look for a tangent point.
           if (lmin == span[0]) break;
           if (lmin == span[1]) break;
 
@@ -3671,9 +3671,9 @@ int wcsmix(
       }
 
     } else {
-      /* Celestial latitude is given. */
+      // Celestial latitude is given.
 
-      /* Check whether the solution interval is a crossing interval. */
+      // Check whether the solution interval is a crossing interval.
       lng0 = span[0];
       *worldlng = lng0;
       if ((status = wcss2p(wcs, 1, 0, world, phi, theta, imgcrd, pixcrd,
@@ -3704,7 +3704,7 @@ int wcsmix(
       lmin = lng1;
       dmin = dabs;
 
-      /* Check for a crossing point. */
+      // Check for a crossing point.
       if (signbit(d0) != signbit(d1)) {
         crossed = 1;
         dx = d1;
@@ -3714,7 +3714,7 @@ int wcsmix(
       }
 
       for (retry = 0; retry < 4; retry++) {
-        /* Refine the solution interval. */
+        // Refine the solution interval.
         while (lng0 > span[0]) {
           lng0 -= step;
           if (lng0 < span[0]) lng0 = span[0];
@@ -3728,32 +3728,32 @@ int wcsmix(
           }
           d0 = pixcrd[mixpix] - pixmix;
 
-          /* Check for a solution. */
+          // Check for a solution.
           dabs = fabs(d0);
           if (dabs < tol) return 0;
 
-          /* Record the point of closest approach. */
+          // Record the point of closest approach.
           if (dabs < dmin) {
             lmin = lng0;
             dmin = dabs;
           }
 
-          /* Check for a crossing point. */
+          // Check for a crossing point.
           if (signbit(d0) != signbit(d1)) {
             crossed = 2;
             dx = d0;
             break;
           }
 
-          /* Advance to the next subinterval. */
+          // Advance to the next subinterval.
           lng1 = lng0;
           d1 = d0;
         }
 
         if (crossed) {
-          /* A crossing point was found. */
+          // A crossing point was found.
           for (iter = 0; iter < niter; iter++) {
-            /* Use regula falsi division of the interval. */
+            // Use regula falsi division of the interval.
             lambda = d0/(d0-d1);
             if (lambda < 0.1) {
               lambda = 0.1;
@@ -3772,20 +3772,20 @@ int wcsmix(
               return status;
             }
 
-            /* Check for a solution. */
+            // Check for a solution.
             d = pixcrd[mixpix] - pixmix;
             dabs = fabs(d);
             if (dabs < tol) return 0;
 
             if (dlng < tol) {
-              /* An artifact of numerical imprecision. */
+              // An artifact of numerical imprecision.
               if (dabs < tol2) return 0;
 
-              /* Must be a discontinuity. */
+              // Must be a discontinuity.
               break;
             }
 
-            /* Record the point of closest approach. */
+            // Record the point of closest approach.
             if (dabs < dmin) {
               lmin = lng;
               dmin = dabs;
@@ -3800,14 +3800,14 @@ int wcsmix(
             }
           }
 
-          /* No convergence, must have been a discontinuity. */
+          // No convergence, must have been a discontinuity.
           if (crossed == 1) lng0 = span[1];
           lng1 = lng0;
           d1 = dx;
           crossed = 0;
 
         } else {
-          /* No crossing point; look for a tangent point. */
+          // No crossing point; look for a tangent point.
           if (lmin == span[0]) break;
           if (lmin == span[1]) break;
 
@@ -3889,7 +3889,7 @@ int wcsmix(
   }
 
 
-  /* Set cel0 to the unity transformation. */
+  // Set cel0 to the unity transformation.
   wcs0 = *wcs;
   wcs0.cel.euler[0] = -90.0;
   wcs0.cel.euler[1] =   0.0;
@@ -3897,10 +3897,10 @@ int wcsmix(
   wcs0.cel.euler[3] =   1.0;
   wcs0.cel.euler[4] =   0.0;
 
-  /* No convergence, check for aberrant behaviour at a native pole. */
+  // No convergence, check for aberrant behaviour at a native pole.
   *theta = -90.0;
   for (j = 1; j <= 2; j++) {
-    /* Could the celestial coordinate element map to a native pole? */
+    // Could the celestial coordinate element map to a native pole?
     *phi = 0.0;
     *theta = -*theta;
     sphx2s(wcscel->euler, 1, 1, 1, 1, phi, theta, &lng, &lat);
@@ -3919,11 +3919,11 @@ int wcsmix(
       *worldlng = lng;
     }
 
-    /* Is there a solution for the given pixel coordinate element? */
+    // Is there a solution for the given pixel coordinate element?
     lng = *worldlng;
     lat = *worldlat;
 
-    /* Feed native coordinates to wcss2p() with cel0 set to unity. */
+    // Feed native coordinates to wcss2p() with cel0 set to unity.
     *worldlng = -180.0;
     *worldlat = *theta;
     if ((status = wcss2p(&wcs0, 1, 0, world, phi, theta, imgcrd, pixcrd,
@@ -3937,15 +3937,15 @@ int wcsmix(
     }
     d0 = pixcrd[mixpix] - pixmix;
 
-    /* Check for a solution. */
+    // Check for a solution.
     if (fabs(d0) < tol) {
-      /* Recall saved world coordinates. */
+      // Recall saved world coordinates.
       *worldlng = lng;
       *worldlat = lat;
       return 0;
     }
 
-    /* Search for a crossing interval. */
+    // Search for a crossing interval.
     phi0 = -180.0;
     for (k = -179; k <= 180; k++) {
       phi1 = (double) k;
@@ -3961,16 +3961,16 @@ int wcsmix(
       }
       d1 = pixcrd[mixpix] - pixmix;
 
-      /* Check for a solution. */
+      // Check for a solution.
       dabs = fabs(d1);
       if (dabs < tol) {
-        /* Recall saved world coordinates. */
+        // Recall saved world coordinates.
         *worldlng = lng;
         *worldlat = lat;
         return 0;
       }
 
-      /* Is it a crossing interval? */
+      // Is it a crossing interval?
       if (signbit(d0) != signbit(d1)) break;
 
       phi0 = phi1;
@@ -3978,7 +3978,7 @@ int wcsmix(
     }
 
     for (iter = 1; iter <= niter; iter++) {
-      /* Use regula falsi division of the interval. */
+      // Use regula falsi division of the interval.
       lambda = d0/(d0-d1);
       if (lambda < 0.1) {
         lambda = 0.1;
@@ -3998,11 +3998,11 @@ int wcsmix(
         return status;
       }
 
-      /* Check for a solution. */
+      // Check for a solution.
       d = pixcrd[mixpix] - pixmix;
       dabs = fabs(d);
       if (dabs < tol || (dphi < tol && dabs < tol2)) {
-        /* Recall saved world coordinates. */
+        // Recall saved world coordinates.
         *worldlng = lng;
         *worldlat = lat;
         return 0;
@@ -4019,11 +4019,11 @@ int wcsmix(
   }
 
 
-  /* No solution. */
+  // No solution.
   return wcserr_set(WCS_ERRMSG(WCSERR_NO_SOLUTION));
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcssptr(
   struct wcsprm *wcs,
@@ -4037,7 +4037,7 @@ int wcssptr(
   double cdelt, crval;
   struct wcserr **err;
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (wcs == 0x0) return WCSERR_NULL_POINTER;
   err = &(wcs->err);
 
@@ -4047,7 +4047,7 @@ int wcssptr(
 
   if ((j = *i) < 0) {
     if ((j = wcs->spec) < 0) {
-      /* Look for a linear spectral axis. */
+      // Look for a linear spectral axis.
       for (j = 0; j < wcs->naxis; j++) {
         if (wcs->types[j]/100 == 30) {
           break;
@@ -4055,7 +4055,7 @@ int wcssptr(
       }
 
       if (j >= wcs->naxis) {
-        /* No spectral axis. */
+        // No spectral axis.
         return wcserr_set(WCSERR_SET(WCSERR_BAD_SUBIMAGE),
           "No spectral axis found.");
       }
@@ -4064,7 +4064,7 @@ int wcssptr(
     *i = j;
   }
 
-  /* Translate the spectral axis. */
+  // Translate the spectral axis.
   if ((status = spctrne(wcs->ctype[j], wcs->crval[j], wcs->cdelt[j],
                         wcs->restfrq, wcs->restwav, ctype, &crval, &cdelt,
                         &(wcs->spc.err)))) {
@@ -4072,21 +4072,21 @@ int wcssptr(
   }
 
 
-  /* Translate keyvalues. */
+  // Translate keyvalues.
   wcs->flag = 0;
   wcs->cdelt[j] = cdelt;
   wcs->crval[j] = crval;
   spctyp(ctype, 0x0, 0x0, 0x0, wcs->cunit[j], 0x0, 0x0, 0x0);
   strcpy(wcs->ctype[j], ctype);
 
-  /* This keeps things tidy if the spectral axis is linear. */
+  // This keeps things tidy if the spectral axis is linear.
   spcfree(&(wcs->spc));
   spcini(&(wcs->spc));
 
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define STRINGIZE(s) STRINGIFY(s)
 #define STRINGIFY(s) #s
Index: astropy-4.2/cextern/wcslib/C/wcs.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcs.h
+++ astropy-4.2/cextern/wcslib/C/wcs.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcs.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcs.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -358,38 +355,39 @@
 *                       wcsprm::err if enabled, see wcserr_enable().
 *
 * Notes:
-*   Combinations of subimage axes of particular types may be extracted in the
-*   same order as they occur in the input image by combining preprocessor
-*   codes, for example
-*
-=     *nsub = 1;
-=     axes[0] = WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_SPECTRAL;
-*
-*   would extract the longitude, latitude, and spectral axes in the same order
-*   as the input image.  If one of each were present, *nsub = 3 would be
-*   returned.
-*
-*   For convenience, WCSSUB_CELESTIAL is defined as the combination
-*   WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_CUBEFACE.
-*
-*   The codes may also be negated to extract all but the types specified, for
-*   example
-*
-=     *nsub = 4;
-=     axes[0] = WCSSUB_LONGITUDE;
-=     axes[1] = WCSSUB_LATITUDE;
-=     axes[2] = WCSSUB_CUBEFACE;
-=     axes[3] = -(WCSSUB_SPECTRAL | WCSSUB_STOKES);
-*
-*   The last of these specifies all axis types other than spectral or Stokes.
-*   Extraction is done in the order specified by axes[] a longitude axis (if
-*   present) would be extracted first (via axes[0]) and not subsequently (via
-*   axes[3]).  Likewise for the latitude and cubeface axes in this example.
-*
-*   From the foregoing, it is apparent that the value of *nsub returned may be
-*   less than or greater than that given.  However, it will never exceed the
-*   number of axes in the input image (plus the number of newly-created axes
-*   if any were specified on input).
+*   1: Combinations of subimage axes of particular types may be extracted in
+*      the same order as they occur in the input image by combining
+*      preprocessor codes, for example
+*
+=        *nsub = 1;
+=        axes[0] = WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_SPECTRAL;
+*
+*      would extract the longitude, latitude, and spectral axes in the same
+*      order as the input image.  If one of each were present, *nsub = 3 would
+*      be returned.
+*
+*      For convenience, WCSSUB_CELESTIAL is defined as the combination
+*      WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_CUBEFACE.
+*
+*      The codes may also be negated to extract all but the types specified,
+*      for example
+*
+=        *nsub = 4;
+=        axes[0] = WCSSUB_LONGITUDE;
+=        axes[1] = WCSSUB_LATITUDE;
+=        axes[2] = WCSSUB_CUBEFACE;
+=        axes[3] = -(WCSSUB_SPECTRAL | WCSSUB_STOKES);
+*
+*      The last of these specifies all axis types other than spectral or
+*      Stokes.  Extraction is done in the order specified by axes[] a
+*      longitude axis (if present) would be extracted first (via axes[0]) and
+*      not subsequently (via axes[3]).  Likewise for the latitude and cubeface
+*      axes in this example.
+*
+*      From the foregoing, it is apparent that the value of *nsub returned may
+*      be less than or greater than that given.  However, it will never exceed
+*      the number of axes in the input image (plus the number of newly-created
+*      axes if any were specified on input).
 *
 *
 * wcscompare() - Compare two wcsprm structs for equality
@@ -561,9 +559,9 @@
 *                       wcsprm::err if enabled, see wcserr_enable().
 *
 * Notes:
-*   wcsset() always enables strict bounds checking in the projection routines
-*   (via a call to prjini()).  Use wcsbchk() to modify bounds-checking after
-*   wcsset() is invoked.
+*   1: wcsset() always enables strict bounds checking in the projection
+*      routines (via a call to prjini()).  Use wcsbchk() to modify
+*      bounds-checking after wcsset() is invoked.
 *
 *
 * wcsp2s() - Pixel-to-world transformation
@@ -780,31 +778,31 @@
 *                       wcsprm::err if enabled, see wcserr_enable().
 *
 * Notes:
-*   Initially the specified solution interval is checked to see if it's a
-*   "crossing" interval.  If it isn't, a search is made for a crossing
-*   solution by iterating on the unknown celestial coordinate starting at the
-*   upper limit of the solution interval and decrementing by the specified
-*   step size.  A crossing is indicated if the trial value of the pixel
-*   coordinate steps through the value specified.  If a crossing interval is
-*   found then the solution is determined by a modified form of "regula falsi"
-*   division of the crossing interval.  If no crossing interval was found
-*   within the specified solution interval then a search is made for a
-*   "non-crossing" solution as may arise from a point of tangency.  The
-*   process is complicated by having to make allowance for the discontinuities
-*   that occur in all map projections.
-*
-*   Once one solution has been determined others may be found by subsequent
-*   invokations of wcsmix() with suitably restricted solution intervals.
-*
-*   Note the circumstance that arises when the solution point lies at a native
-*   pole of a projection in which the pole is represented as a finite curve,
-*   for example the zenithals and conics.  In such cases two or more valid
-*   solutions may exist but wcsmix() only ever returns one.
-*
-*   Because of its generality wcsmix() is very compute-intensive.  For
-*   compute-limited applications more efficient special-case solvers could be
-*   written for simple projections, for example non-oblique cylindrical
-*   projections.
+*   1: Initially the specified solution interval is checked to see if it's a
+*      "crossing" interval.  If it isn't, a search is made for a crossing
+*      solution by iterating on the unknown celestial coordinate starting at
+*      the upper limit of the solution interval and decrementing by the
+*      specified step size.  A crossing is indicated if the trial value of the
+*      pixel coordinate steps through the value specified.  If a crossing
+*      interval is found then the solution is determined by a modified form of
+*      "regula falsi" division of the crossing interval.  If no crossing
+*      interval was found within the specified solution interval then a search
+*      is made for a "non-crossing" solution as may arise from a point of
+*      tangency.  The process is complicated by having to make allowance for
+*      the discontinuities that occur in all map projections.
+*
+*      Once one solution has been determined others may be found by subsequent
+*      invokations of wcsmix() with suitably restricted solution intervals.
+*
+*      Note the circumstance that arises when the solution point lies at a
+*      native pole of a projection in which the pole is represented as a
+*      finite curve, for example the zenithals and conics.  In such cases two
+*      or more valid solutions may exist but wcsmix() only ever returns one.
+*
+*      Because of its generality wcsmix() is very compute-intensive.  For
+*      compute-limited applications more efficient special-case solvers could
+*      be written for simple projections, for example non-oblique cylindrical
+*      projections.
 *
 *
 * wcssptr() - Spectral axis translation
@@ -928,8 +926,8 @@
 *       - wcsprm::wtb.
 *
 *     This signals the initialization routine, wcsset(), to recompute the
-*     returned members of the celprm struct.  celset() will reset flag to
-*     indicate that this has been done.
+*     returned members of the linprm, celprm, spcprm, and tabprm structs.
+*     wcsset() will reset flag to indicate that this has been done.
 *
 *     PLEASE NOTE: flag should be set to -1 when wcsinit() is called for the
 *     first time for a particular wcsprm struct in order to initialize memory
@@ -1730,7 +1728,7 @@
 
 #ifdef __cplusplus
 extern "C" {
-#define wtbarr wtbarr_s		/* See prologue of wtbarr.h.                */
+#define wtbarr wtbarr_s		// See prologue of wtbarr.h.
 #endif
 
 #define WCSSUB_LONGITUDE 0x1001
@@ -1749,111 +1747,109 @@ extern "C" {
 extern const char *wcs_errmsg[];
 
 enum wcs_errmsg_enum {
-  WCSERR_SUCCESS         =  0,	/* Success. */
-  WCSERR_NULL_POINTER    =  1,	/* Null wcsprm pointer passed. */
-  WCSERR_MEMORY          =  2,	/* Memory allocation failed. */
-  WCSERR_SINGULAR_MTX    =  3,	/* Linear transformation matrix is
-				   singular. */
-  WCSERR_BAD_CTYPE       =  4,	/* Inconsistent or unrecognized coordinate
-				   axis type. */
-  WCSERR_BAD_PARAM       =  5,	/* Invalid parameter value. */
-  WCSERR_BAD_COORD_TRANS =  6,	/* Unrecognized coordinate transformation
-				   parameter. */
-  WCSERR_ILL_COORD_TRANS =  7,	/* Ill-conditioned coordinate transformation
-				   parameter. */
-  WCSERR_BAD_PIX         =  8,	/* One or more of the pixel coordinates were
-				   invalid. */
-  WCSERR_BAD_WORLD       =  9,	/* One or more of the world coordinates were
-				   invalid. */
-  WCSERR_BAD_WORLD_COORD = 10,	/* Invalid world coordinate. */
-  WCSERR_NO_SOLUTION     = 11,	/* No solution found in the specified
-				   interval. */
-  WCSERR_BAD_SUBIMAGE    = 12,	/* Invalid subimage specification. */
-  WCSERR_NON_SEPARABLE   = 13 	/* Non-separable subimage coordinate
-				   system. */
+  WCSERR_SUCCESS         =  0,	// Success.
+  WCSERR_NULL_POINTER    =  1,	// Null wcsprm pointer passed.
+  WCSERR_MEMORY          =  2,	// Memory allocation failed.
+  WCSERR_SINGULAR_MTX    =  3,	// Linear transformation matrix is singular.
+  WCSERR_BAD_CTYPE       =  4,	// Inconsistent or unrecognized coordinate
+				// axis type.
+  WCSERR_BAD_PARAM       =  5,	// Invalid parameter value.
+  WCSERR_BAD_COORD_TRANS =  6,	// Unrecognized coordinate transformation
+				// parameter.
+  WCSERR_ILL_COORD_TRANS =  7,	// Ill-conditioned coordinate transformation
+				// parameter.
+  WCSERR_BAD_PIX         =  8,	// One or more of the pixel coordinates were
+				// invalid.
+  WCSERR_BAD_WORLD       =  9,	// One or more of the world coordinates were
+				// invalid.
+  WCSERR_BAD_WORLD_COORD = 10,	// Invalid world coordinate.
+  WCSERR_NO_SOLUTION     = 11,	// No solution found in the specified
+				// interval.
+  WCSERR_BAD_SUBIMAGE    = 12,	// Invalid subimage specification.
+  WCSERR_NON_SEPARABLE   = 13 	// Non-separable subimage coordinate system.
 };
 
 
-/* Struct used for storing PVi_ma keywords. */
+// Struct used for storing PVi_ma keywords.
 struct pvcard {
-  int i;			/* Axis number, as in PVi_ma (1-relative).  */
-  int m;			/* Parameter number, ditto  (0-relative).   */
-  double value;			/* Parameter value.                         */
+  int i;			// Axis number, as in PVi_ma (1-relative).
+  int m;			// Parameter number, ditto  (0-relative).
+  double value;			// Parameter value.
 };
 
-/* Size of the pvcard struct in int units, used by the Fortran wrappers. */
+// Size of the pvcard struct in int units, used by the Fortran wrappers.
 #define PVLEN (sizeof(struct pvcard)/sizeof(int))
 
-/* Struct used for storing PSi_ma keywords. */
+// Struct used for storing PSi_ma keywords.
 struct pscard {
-  int i;			/* Axis number, as in PSi_ma (1-relative).  */
-  int m;			/* Parameter number, ditto  (0-relative).   */
-  char value[72];		/* Parameter value.                         */
+  int i;			// Axis number, as in PSi_ma (1-relative).
+  int m;			// Parameter number, ditto  (0-relative).
+  char value[72];		// Parameter value.
 };
 
-/* Size of the pscard struct in int units, used by the Fortran wrappers. */
+// Size of the pscard struct in int units, used by the Fortran wrappers.
 #define PSLEN (sizeof(struct pscard)/sizeof(int))
 
-/* Struct used to hold additional auxiliary parameters.                     */
+// Struct used to hold additional auxiliary parameters.
 struct auxprm {
-  double rsun_ref;              /* Solar radius.                            */
-  double dsun_obs;              /* Distance from Sun centre to observer.    */
-  double crln_obs;              /* Carrington heliographic lng of observer. */
-  double hgln_obs;              /* Stonyhurst heliographic lng of observer. */
-  double hglt_obs;              /* Heliographic latitude of observer.       */
+  double rsun_ref;              // Solar radius.
+  double dsun_obs;              // Distance from Sun centre to observer.
+  double crln_obs;              // Carrington heliographic lng of observer.
+  double hgln_obs;              // Stonyhurst heliographic lng of observer.
+  double hglt_obs;              // Heliographic latitude of observer.
 };
 
-/* Size of the auxprm struct in int units, used by the Fortran wrappers. */
+// Size of the auxprm struct in int units, used by the Fortran wrappers.
 #define AUXLEN (sizeof(struct auxprm)/sizeof(int))
 
 
 struct wcsprm {
-  /* Initialization flag (see the prologue above).                          */
-  /*------------------------------------------------------------------------*/
-  int    flag;			/* Set to zero to force initialization.     */
-
-  /* FITS header keyvalues to be provided (see the prologue above).         */
-  /*------------------------------------------------------------------------*/
-  int    naxis;			/* Number of axes (pixel and coordinate).   */
-  double *crpix;		/* CRPIXja keyvalues for each pixel axis.   */
-  double *pc;			/* PCi_ja  linear transformation matrix.    */
-  double *cdelt;		/* CDELTia keyvalues for each coord axis.   */
-  double *crval;		/* CRVALia keyvalues for each coord axis.   */
-
-  char   (*cunit)[72];		/* CUNITia keyvalues for each coord axis.   */
-  char   (*ctype)[72];		/* CTYPEia keyvalues for each coord axis.   */
-
-  double lonpole;		/* LONPOLEa keyvalue.                       */
-  double latpole;		/* LATPOLEa keyvalue.                       */
-
-  double restfrq;		/* RESTFRQa keyvalue.                       */
-  double restwav;		/* RESTWAVa keyvalue.                       */
-
-  int    npv;			/* Number of PVi_ma keywords, and the       */
-  int    npvmax;		/* number for which space was allocated.    */
-  struct pvcard *pv;		/* PVi_ma keywords for each i and m.        */
-
-  int    nps;			/* Number of PSi_ma keywords, and the       */
-  int    npsmax;		/* number for which space was allocated.    */
-  struct pscard *ps;		/* PSi_ma keywords for each i and m.        */
-
-  /* Alternative header keyvalues (see the prologue above).                 */
-  /*------------------------------------------------------------------------*/
-  double *cd;			/* CDi_ja linear transformation matrix.     */
-  double *crota;		/* CROTAi keyvalues for each coord axis.    */
-  int    altlin;		/* Alternative representations              */
-				/*   Bit 0: PCi_ja  is present,             */
-				/*   Bit 1: CDi_ja  is present,             */
-				/*   Bit 2: CROTAi is present.              */
-  int    velref;		/* AIPS velocity code, VELREF.              */
-
-  /* Auxiliary coordinate system information of a general nature.  Not      */
-  /* used by WCSLIB.  Refer to the prologue comments above for a brief      */
-  /* explanation of these values.                                           */
+  // Initialization flag (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    flag;			// Set to zero to force initialization.
+
+  // FITS header keyvalues to be provided (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    naxis;			// Number of axes (pixel and coordinate).
+  double *crpix;		// CRPIXja keyvalues for each pixel axis.
+  double *pc;			// PCi_ja  linear transformation matrix.
+  double *cdelt;		// CDELTia keyvalues for each coord axis.
+  double *crval;		// CRVALia keyvalues for each coord axis.
+
+  char   (*cunit)[72];		// CUNITia keyvalues for each coord axis.
+  char   (*ctype)[72];		// CTYPEia keyvalues for each coord axis.
+
+  double lonpole;		// LONPOLEa keyvalue.
+  double latpole;		// LATPOLEa keyvalue.
+
+  double restfrq;		// RESTFRQa keyvalue.
+  double restwav;		// RESTWAVa keyvalue.
+
+  int    npv;			// Number of PVi_ma keywords, and the
+  int    npvmax;		// number for which space was allocated.
+  struct pvcard *pv;		// PVi_ma keywords for each i and m.
+
+  int    nps;			// Number of PSi_ma keywords, and the
+  int    npsmax;		// number for which space was allocated.
+  struct pscard *ps;		// PSi_ma keywords for each i and m.
+
+  // Alternative header keyvalues (see the prologue above).
+  //--------------------------------------------------------------------------
+  double *cd;			// CDi_ja linear transformation matrix.
+  double *crota;		// CROTAi keyvalues for each coord axis.
+  int    altlin;		// Alternative representations
+				//   Bit 0: PCi_ja  is present,
+				//   Bit 1: CDi_ja  is present,
+				//   Bit 2: CROTAi is present.
+  int    velref;		// AIPS velocity code, VELREF.
+
+  // Auxiliary coordinate system information of a general nature.  Not
+  // used by WCSLIB.  Refer to the prologue comments above for a brief
+  // explanation of these values.
   char   alt[4];
   int    colnum;
   int    *colax;
-				/* Auxiliary coordinate axis information.   */
+				// Auxiliary coordinate axis information.
   char   (*cname)[72];
   double *crder;
   double *csyer;
@@ -1861,22 +1857,22 @@ struct wcsprm {
   double *cperi;
 
   char   wcsname[72];
-				/* Time reference system and measurement.   */
+				// Time reference system and measurement.
   char   timesys[72], trefpos[72], trefdir[72], plephem[72];
   char   timeunit[72];
   char   dateref[72];
   double mjdref[2];
   double timeoffs;
-				/* Data timestamps and durations.           */
+				// Data timestamps and durations.
   char   dateobs[72], datebeg[72], dateavg[72], dateend[72];
   double mjdobs, mjdbeg, mjdavg, mjdend;
   double jepoch, bepoch;
   double tstart, tstop;
   double xposure, telapse;
-				/* Timing accuracy.                         */
+				// Timing accuracy.
   double timsyer, timrder;
   double timedel, timepixr;
-				/* Spatial & celestial reference frame.     */
+				// Spatial & celestial reference frame.
   double obsgeo[6];
   char   obsorbit[72];
   char   radesys[72];
@@ -1888,40 +1884,40 @@ struct wcsprm {
   char   ssyssrc[72];
   double velangl;
 
-  /* Additional auxiliary coordinate system information of a specialist     */
-  /* nature.  Not used by WCSLIB.  Refer to the prologue comments above.    */
+  // Additional auxiliary coordinate system information of a specialist
+  // nature.  Not used by WCSLIB.  Refer to the prologue comments above.
   struct auxprm *aux;
 
-  /* Coordinate lookup tables (see the prologue above).                     */
-  /*------------------------------------------------------------------------*/
-  int    ntab;			/* Number of separate tables.               */
-  int    nwtb;			/* Number of wtbarr structs.                */
-  struct tabprm *tab;		/* Tabular transformation parameters.       */
-  struct wtbarr *wtb;		/* Array of wtbarr structs.                 */
-
-  /*------------------------------------------------------------------------*/
-  /* Information derived from the FITS header keyvalues by wcsset().        */
-  /*------------------------------------------------------------------------*/
-  char   lngtyp[8], lattyp[8];	/* Celestial axis types, e.g. RA, DEC.      */
-  int    lng, lat, spec;	/* Longitude, latitude and spectral axis    */
-				/* indices (0-relative).                    */
-  int    cubeface;		/* True if there is a CUBEFACE axis.        */
-  int    *types;		/* Coordinate type codes for each axis.     */
-
-  struct linprm lin;		/*    Linear transformation parameters.     */
-  struct celprm cel;		/* Celestial transformation parameters.     */
-  struct spcprm spc;		/*  Spectral transformation parameters.     */
-
-  /*------------------------------------------------------------------------*/
-  /*             THE REMAINDER OF THE WCSPRM STRUCT IS PRIVATE.             */
-  /*------------------------------------------------------------------------*/
+  // Coordinate lookup tables (see the prologue above).
+  //--------------------------------------------------------------------------
+  int    ntab;			// Number of separate tables.
+  int    nwtb;			// Number of wtbarr structs.
+  struct tabprm *tab;		// Tabular transformation parameters.
+  struct wtbarr *wtb;		// Array of wtbarr structs.
+
+  //--------------------------------------------------------------------------
+  // Information derived from the FITS header keyvalues by wcsset().
+  //--------------------------------------------------------------------------
+  char   lngtyp[8], lattyp[8];	// Celestial axis types, e.g. RA, DEC.
+  int    lng, lat, spec;	// Longitude, latitude and spectral axis
+				// indices (0-relative).
+  int    cubeface;		// True if there is a CUBEFACE axis.
+  int    *types;		// Coordinate type codes for each axis.
+
+  struct linprm lin;		//    Linear transformation parameters.
+  struct celprm cel;		// Celestial transformation parameters.
+  struct spcprm spc;		//  Spectral transformation parameters.
+
+  //--------------------------------------------------------------------------
+  //             THE REMAINDER OF THE WCSPRM STRUCT IS PRIVATE.
+  //--------------------------------------------------------------------------
 
-  /* Error handling, if enabled.                                            */
-  /*------------------------------------------------------------------------*/
+  // Error handling, if enabled.
+  //--------------------------------------------------------------------------
   struct wcserr *err;
 
-  /* Memory management.                                                     */
-  /*------------------------------------------------------------------------*/
+  // Memory management.
+  //--------------------------------------------------------------------------
   int    m_flag, m_naxis;
   double *m_crpix, *m_pc, *m_cdelt, *m_crval;
   char  (*m_cunit)[72], (*m_ctype)[72];
@@ -1936,7 +1932,7 @@ struct wcsprm {
   struct wtbarr *m_wtb;
 };
 
-/* Size of the wcsprm struct in int units, used by the Fortran wrappers. */
+// Size of the wcsprm struct in int units, used by the Fortran wrappers.
 #define WCSLEN (sizeof(struct wcsprm)/sizeof(int))
 
 
@@ -1983,11 +1979,11 @@ int wcssptr(struct wcsprm *wcs, int *i,
 
 const char* wcslib_version(int vers[3]);
 
-/* Defined mainly for backwards compatibility, use wcssub() instead. */
+// Defined mainly for backwards compatibility, use wcssub() instead.
 #define wcscopy(alloc, wcssrc, wcsdst) wcssub(alloc, wcssrc, 0x0, 0x0, wcsdst)
 
 
-/* Deprecated. */
+// Deprecated.
 #define wcsini_errmsg wcs_errmsg
 #define wcssub_errmsg wcs_errmsg
 #define wcscopy_errmsg wcs_errmsg
@@ -2003,4 +1999,4 @@ const char* wcslib_version(int vers[3]);
 }
 #endif
 
-#endif /* WCSLIB_WCS */
+#endif // WCSLIB_WCS
Index: astropy-4.2/cextern/wcslib/C/wcsbth.l
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsbth.l
+++ astropy-4.2/cextern/wcslib/C/wcsbth.l
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsbth.l,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsbth.l,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
 * wcsbth.l is a Flex description file containing the definition of a lexical
@@ -125,30 +122,30 @@ INLINE " "*(\/.*)?
 #include "wcsprintf.h"
 #include "wcsutil.h"
 
-			/* Codes used for keyvalue data types. */
+			// Codes used for keyvalue data types.
 #define INTEGER 0
 #define FLOAT   1
 #define FLOAT2  2
 #define STRING  3
 
-			/* Bit masks used for keyword types:        */
-#define IMGAUX  0x1	/* Auxiliary image header, e.g. LONPOLEa or */
-			/* DATE-OBS.                                */
-#define IMGAXIS 0x2	/* Image header with axis number, e.g.      */
-			/* CTYPEia.                                 */
-#define IMGHEAD 0x3	/* IMGAUX | IMGAXIS, i.e. image header of   */
-			/* either type.                             */
-#define BIMGARR 0x4	/* Binary table image array, e.g. iCTYna.   */
-#define PIXLIST 0x8	/* Pixel list, e.g. TCTYna.                 */
-#define BINTAB  0xC	/* BIMGARR | PIXLIST, i.e. binary table     */
-			/* image array (without axis number) or     */
-			/* pixel list, e.g. LONPna or OBSGXn.       */
+			// Bit masks used for keyword types:
+#define IMGAUX  0x1	// Auxiliary image header, e.g. LONPOLEa or
+			// DATE-OBS.
+#define IMGAXIS 0x2	// Image header with axis number, e.g.
+			// CTYPEia.
+#define IMGHEAD 0x3	// IMGAUX | IMGAXIS, i.e. image header of
+			// either type.
+#define BIMGARR 0x4	// Binary table image array, e.g. iCTYna.
+#define PIXLIST 0x8	// Pixel list, e.g. TCTYna.
+#define BINTAB  0xC	// BIMGARR | PIXLIST, i.e. binary table
+			// image array (without axis number) or
+			// pixel list, e.g. LONPna or OBSGXn.
 
 static int wcsbth_scanner(char *header, int nkeyrec, int relax, int ctrl,
                           int keysel, int *colsel, int *nreject, int *nwcs,
                           struct wcsprm **wcs, yyscan_t yyscanner);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsbth(
   char *header,
@@ -175,7 +172,7 @@ int wcsbth(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define YY_DECL int wcsbth_scanner(char *header, int nkeyrec, int relax, \
  int ctrl, int keysel, int *colsel, int *nreject, int *nwcs, \
@@ -194,18 +191,18 @@ int wcsbth(
 	  } \
 	}
 
-/* A convenience macro to get around incompatibilities between unput() and
-   yyless(): put yytext followed by a blank back onto the input stream. */
+// A convenience macro to get around incompatibilities between unput() and
+// yyless(): put yytext followed by a blank back onto the input stream.
 #define WCSBTH_PUTBACK \
   sprintf(strtmp, "%s ", yytext); \
   iz = strlen(strtmp); \
   while (iz) unput(strtmp[--iz]);
 
-/* These global variables are required by YY_INPUT. */
+// These global variables are required by YY_INPUT.
 static char *wcsbth_hdr;
 static int  wcsbth_nkeyrec;
 
-/* Struct used internally for header bookkeeping. */
+// Struct used internally for header bookkeeping.
 struct wcsbth_alts {
   int ncol, ialt, icol, imgherit;
   short int (*arridx)[27];
@@ -220,7 +217,7 @@ struct wcsbth_alts {
   unsigned char pad2[2];
 };
 
-/* Internal helper functions. */
+// Internal helper functions.
 static int wcsbth_colax(struct wcsprm *wcs, struct wcsbth_alts *alts, int k,
         char a);
 static int wcsbth_final(struct wcsbth_alts *alts, int *nwcs,
@@ -232,24 +229,24 @@ static int wcsbth_init1(struct wcsbth_al
 static int wcsbth_pass1(int keytype, int i, int j, int n, int k, char a,
         char ptype, struct wcsbth_alts *alts);
 
-/* Helper functions for keywords that require special handling. */
+// Helper functions for keywords that require special handling.
 static int wcsbth_jdref(double *wptr,   const double *jdref);
 static int wcsbth_jdrefi(double *wptr,  const double *jdrefi);
 static int wcsbth_jdreff(double *wptr,  const double *jdreff);
 static int wcsbth_epoch(double *wptr,   const double *epoch);
 static int wcsbth_vsource(double *wptr, const double *vsource);
 
-/* Helper functions for keyvalue validity checking. */
+// Helper functions for keyvalue validity checking.
 static int wcsbth_timepixr(double timepixr);
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
+// Used in preempting the call to exit() by yy_fatal_error().
 jmp_buf wcsbth_abort_jmp_env;
 #define exit(status) longjmp(wcsbth_abort_jmp_env, status)
 
 %}
 
 %%
-	/* Keyword indices, as used in the WCS papers, e.g. iVn_ma, TPn_ka. */
+	// Keyword indices, as used in the WCS papers, e.g. iVn_ma, TPn_ka.
 	char a;
 	int  i, j, k, m, n;
 	
@@ -268,37 +265,37 @@ jmp_buf wcsbth_abort_jmp_env;
 	int (*chekval)(double);
 	int (*special)(double *, const double *);
 	
-	/* The data structures produced. */
+	// The data structures produced.
 	*nwcs = 0;
 	*wcs  = 0x0;
 	
-	/* Parameters used to implement YY_INPUT. */
+	// Parameters used to implement YY_INPUT.
 	wcsbth_hdr = header;
 	wcsbth_nkeyrec = nkeyrec;
 	
-	/* Our handle on the input stream. */
+	// Our handle on the input stream.
 	keyrec = header;
 	hptr = header;
 	keep = 0x0;
 	
-	/* For keeping tallies of keywords found. */
+	// For keeping tallies of keywords found.
 	*nreject = 0;
 	nvalid = 0;
 	nother = 0;
 	
-	/* Used to flag image header keywords that are always inherited. */
+	// Used to flag image header keywords that are always inherited.
 	imherit = 1;
 	
-	/* If strict, then also reject. */
+	// If strict, then also reject.
 	if (relax & WCSHDR_strict) relax |= WCSHDR_reject;
 	
-	/* Keyword parameters. */
+	// Keyword parameters.
 	i = j = 0;
 	n = k = 0;
 	m = 0;
 	a = ' ';
 	
-	/* Header bookkeeping. */
+	// Header bookkeeping.
 	alts.ncol = 0;
 	alts.arridx  = 0x0;
 	alts.pixlist = 0x0;
@@ -311,12 +308,12 @@ jmp_buf wcsbth_abort_jmp_env;
 	  alts.pixnps[ialt] = 0;
 	}
 	
-	/* For decoding the keyvalue. */
+	// For decoding the keyvalue.
 	keytype =  0;
 	valtype = -1;
 	vptr    = 0x0;
 	
-	/* For keywords that require special handling. */
+	// For keywords that require special handling.
 	altlin  = 0;
 	ptype   = ' ';
 	chekval = 0x0;
@@ -324,7 +321,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	auxprm  = 0;
 	naux    = 0;
 	
-	/* Selection by column number. */
+	// Selection by column number.
 	nsel = colsel ? colsel[0] : 0;
 	incl = (nsel > 0);
 	for (icol = 0; icol < 1000; icol++) {
@@ -338,7 +335,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	}
 	exclude[0] = 0;
 	
-	/* Selection by keyword type. */
+	// Selection by keyword type.
 	itmp = keysel;
 	keysel = 0;
 	if (itmp) {
@@ -350,11 +347,11 @@ jmp_buf wcsbth_abort_jmp_env;
 	  keysel = IMGHEAD | BINTAB;
 	}
 	
-	/* Control variables. */
+	// Control variables.
 	ipass = 1;
 	npass = 2;
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
+	// Return here via longjmp() invoked by yy_fatal_error().
 	if (setjmp(wcsbth_abort_jmp_env)) {
 	  return 4;
 	}
@@ -379,7 +376,7 @@ jmp_buf wcsbth_abort_jmp_env;
 
 ^WCSAXES{ALT}=" "" "*{INTEGER} {
 	  if (!(keysel & IMGAXIS)) {
-	    /* Ignore this key type. */
+	    // Ignore this key type.
 	    BEGIN(DISCARD);
 	
 	  } else {
@@ -404,7 +401,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	  }
@@ -415,12 +412,12 @@ jmp_buf wcsbth_abort_jmp_env;
 ^WCAX{I3}{ALT}"= "" "*{INTEGER} {
 	  keyname = "WCAXna";
 	
-	  /* Note that a blank in the sscanf() format string matches zero or
-	     more of them in the input. */
+	  // Note that a blank in the sscanf() format string matches zero or
+	  // more of them in the input.
 	  sscanf(yytext, "WCAX%d%c = %d", &n, &a, &i);
 	
 	  if (!(keysel & BIMGARR) || exclude[n]) {
-	    /* Ignore this key type or column. */
+	    // Ignore this key type or column.
 	    BEGIN(DISCARD);
 	
 	  } else if (i < 0) {
@@ -440,7 +437,7 @@ jmp_buf wcsbth_abort_jmp_env;
 ^WCST{I1}{ALT}"  = "" "*{STRING} |
 ^WCST{I2}{ALT}" = "" "*{STRING} |
 ^WCST{I3}{ALT}"= "" "*{STRING} {
-	  /* Cross-reference supplier. */
+	  // Cross-reference supplier.
 	  keyname = "WCSTna";
 	  errmsg = "cross-references are not implemented";
 	  BEGIN(ERROR);
@@ -449,7 +446,7 @@ jmp_buf wcsbth_abort_jmp_env;
 ^WCSX{I1}{ALT}"  = "" "*{STRING} |
 ^WCSX{I2}{ALT}" = "" "*{STRING} |
 ^WCSX{I3}{ALT}"= "" "*{STRING} {
-	  /* Cross-reference consumer. */
+	  // Cross-reference consumer.
 	  keyname = "WCSXna";
 	  errmsg = "cross-references are not implemented";
 	  BEGIN(ERROR);
@@ -1247,7 +1244,7 @@ jmp_buf wcsbth_abort_jmp_env;
 ^MJDREFI" " |
 ^MJD-REFI {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	
@@ -1303,7 +1300,7 @@ jmp_buf wcsbth_abort_jmp_env;
 ^JDREFI"  " |
 ^JD-REFI {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	    special = wcsbth_jdrefi;
@@ -1850,7 +1847,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1971,7 +1968,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1980,13 +1977,13 @@ jmp_buf wcsbth_abort_jmp_env;
 <CCCCCia>00{I1} {
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (relax & WCSHDR_reject) {
-	      /* Violates the basic FITS standard. */
+	      // Violates the basic FITS standard.
 	      errmsg = "indices in parameterized keywords must not have "
 	               "leading zeroes";
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -1997,7 +1994,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2005,8 +2002,8 @@ jmp_buf wcsbth_abort_jmp_env;
 <CCCCCia>0{ALT}" " |
 <CCCCCia>00{ALT} |
 <CCCCCia>{Z3} {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  if (relax & WCSHDR_ALLIMG) {
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
@@ -2018,21 +2015,21 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 
 <CCCCCia>. {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "keyword looks very much like %s but isn't",
 	      keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2076,7 +2073,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2119,7 +2116,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2158,7 +2155,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -2169,7 +2166,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2184,8 +2181,8 @@ jmp_buf wcsbth_abort_jmp_env;
 <CCi_ja>{Z3}_{Z2} |
 <CCi_ja>{Z2}_{Z3} |
 <CCi_ja>{Z1}_{Z4} {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  if (relax & WCSHDR_ALLIMG) {
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
@@ -2197,7 +2194,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2225,13 +2222,13 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 
 <CCi_ja>{Z1}{6} {
-	  /* This covers the defunct forms CD00i00j and PC00i00j. */
+	  // This covers the defunct forms CD00i00j and PC00i00j.
 	  if (relax & WCSHDR_ALLIMG) {
 	    if (((altlin == 1) && (relax & WCSHDR_PC00i00j)) ||
 	        ((altlin == 2) && (relax & WCSHDR_CD00i00j))) {
@@ -2248,7 +2245,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -2259,7 +2256,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2292,7 +2289,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2350,7 +2347,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -2361,7 +2358,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2371,7 +2368,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    yyless(0);
 	    BEGIN(CCCCCia);
 	  } else {
-	    /* Let it go. */
+	    // Let it go.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2401,7 +2398,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2413,7 +2410,7 @@ jmp_buf wcsbth_abort_jmp_env;
 
 <CCCCCCCa>{ALT} |
 <CCCCCCCC>. {
-	  /* Image-header keyword. */
+	  // Image-header keyword.
 	  if (imherit || (relax & (WCSHDR_AUXIMG | WCSHDR_ALLIMG))) {
 	    if (YY_START == CCCCCCCa) {
 	      sscanf(yytext, "%c", &a);
@@ -2431,21 +2428,21 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
 
 <CCCCCCCa>. {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "invalid alternate code, keyword resembles %s "
 	      "but isn't", keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2494,7 +2491,7 @@ jmp_buf wcsbth_abort_jmp_env;
 <CCi_ma>{I1}_{I2}{ALT}" " |
 <CCi_ma>{I2}_{Z1}{ALT}" " |
 <CCi_ma>{I2}_{I2}{ALT} {
-	  /* Image-header keyword. */
+	  // Image-header keyword.
 	  if (relax & WCSHDR_ALLIMG) {
 	    sscanf(yytext, "%d_%d%c", &i, &m, &a);
 	    keytype = IMGAXIS;
@@ -2507,7 +2504,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2546,7 +2543,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -2557,7 +2554,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2573,8 +2570,8 @@ jmp_buf wcsbth_abort_jmp_env;
 <CCi_ma>{Z2}_{Z3} |
 <CCi_ma>{Z1}_{Z4} {
 	  if (relax & WCSHDR_ALLIMG) {
-	    /* Anything that has fallen through to this point must contain */
-	    /* an invalid parameter. */
+	    // Anything that has fallen through to this point must contain
+	    // an invalid parameter.
 	    errmsg = "axis number must exceed 0";
 	    BEGIN(ERROR);
 	
@@ -2585,7 +2582,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2632,7 +2629,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2668,7 +2665,7 @@ jmp_buf wcsbth_abort_jmp_env;
 <TCn_ma>{I2}_{I3} |
 <TCn_ma>{I3}_{I2} |
 <TCn_ma>{I4}_{Z1} {
-	  /* Invalid combinations will be flagged by <VALUE>. */
+	  // Invalid combinations will be flagged by <VALUE>.
 	  sscanf(yytext, "%d_%d", &n, &m);
 	  a = ' ';
 	  if (YY_START == TCn_ma) i = wcsbth_colax(*wcs, &alts, n, a);
@@ -2694,7 +2691,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -2715,16 +2712,16 @@ jmp_buf wcsbth_abort_jmp_env;
 	}
 
 <VALUE>=" "+ {
-	  /* Do checks on i, j, m, n, k. */
+	  // Do checks on i, j, m, n, k.
 	  if (!(keytype & keysel)) {
-	    /* Selection by keyword type. */
+	    // Selection by keyword type.
 	    BEGIN(DISCARD);
 	
 	  } else if (exclude[n] || exclude[k]) {
-	    /* One or other column is not selected. */
+	    // One or other column is not selected.
 	    if (k && (exclude[n] != exclude[k])) {
-	      /* For keywords such as TCn_ka, both columns must be excluded.
-	         User error, so return immediately. */
+	      // For keywords such as TCn_ka, both columns must be excluded.
+	      // User error, so return immediately.
 	      return 3;
 	
 	    } else {
@@ -2744,18 +2741,18 @@ jmp_buf wcsbth_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
 	  } else if (ipass == 2 && npass == 3 && (keytype & BINTAB)) {
-	    /* Skip keyvalues that won't be inherited. */
+	    // Skip keyvalues that won't be inherited.
 	    BEGIN(FLUSH);
 	
 	  } else {
 	    if (ipass == 3 && (keytype & IMGHEAD)) {
-	      /* IMGHEAD keytypes are always dealt with on the second pass. */
-	      /* However, they must be re-parsed in order to report errors. */
+	      // IMGHEAD keytypes are always dealt with on the second pass.
+	      // However, they must be re-parsed in order to report errors.
 	      vptr = 0x0;
 	    }
 	
@@ -2786,7 +2783,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    sscanf(yytext, "%d", &inttmp);
 	
 	    BEGIN(COMMENT);
@@ -2803,7 +2800,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    wcsutil_str2double(yytext, &dbltmp);
 	
 	    if (chekval && chekval(dbltmp)) {
@@ -2825,7 +2822,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue as integer and fractional parts. */
+	    // Read the keyvalue as integer and fractional parts.
 	    wcsutil_str2double2(yytext, dbl2tmp);
 	
 	    BEGIN(COMMENT);
@@ -2842,10 +2839,10 @@ jmp_buf wcsbth_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	      strcpy(strtmp, yytext+1);
 	
-	    /* Squeeze out repeated quotes. */
+	    // Squeeze out repeated quotes.
 	    ix = 0;
 	    for (jx = 0; jx < 72; jx++) {
 	      if (ix < jx) {
@@ -2873,28 +2870,28 @@ jmp_buf wcsbth_abort_jmp_env;
 
 <COMMENT>{INLINE}$ {
 	  if (ipass == 1) {
-	    /* Do first-pass bookkeeping. */
+	    // Do first-pass bookkeeping.
 	    wcsbth_pass1(keytype, i, j, n, k, a, ptype, &alts);
 	    BEGIN(FLUSH);
 	
 	  } else if (*wcs) {
-	    /* Store the value now that the keyrecord has been validated. */
+	    // Store the value now that the keyrecord has been validated.
 	    alts.icol = 0;
 	    alts.ialt = 0;
 	
-	    /* Update each coordinate representation. */
+	    // Update each coordinate representation.
 	    gotone = 0;
 	    while ((wcsp = wcsbth_idx(*wcs, &alts, keytype, n, a))) {
 	      gotone = 1;
 	
 	      if (vptr) {
 	        if (auxprm) {
-	          /* Additional auxiliary parameter. */
+	          // Additional auxiliary parameter.
 	          auxp = wcsp->aux;
 	          voff = (char *)vptr - (char *)(&auxtem);
 	          wptr = (void *)((char *)auxp + voff);
 	        } else {
-	          /* A parameter that lives directly in wcsprm. */
+	          // A parameter that lives directly in wcsprm.
 	          voff = (char *)vptr - (char *)(&wcstem);
 	          wptr = (void *)((char *)wcsp + voff);
 	        }
@@ -2903,7 +2900,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	          *((int *)wptr) = inttmp;
 	
 	        } else if (valtype == FLOAT) {
-	          /* Apply keyword parameterization. */
+	          // Apply keyword parameterization.
 	          if (ptype == 'v') {
 	            ipx = (wcsp->npv)++;
 	            wcsp->pv[ipx].i = i;
@@ -2924,14 +2921,14 @@ jmp_buf wcsbth_abort_jmp_env;
 	            *((double *)wptr) = dbltmp;
 	          }
 	
-	          /* Flag the presence of PCi_ja, or CDi_ja and/or CROTAia. */
+	          // Flag the presence of PCi_ja, or CDi_ja and/or CROTAia.
 	          if (altlin) {
 	            wcsp->altlin |= altlin;
 	            altlin = 0;
 	          }
 	
 	          } else if (valtype == FLOAT2) {
-	            /* Split MJDREF and JDREF into integer and fraction.*/
+	            // Split MJDREF and JDREF into integer and fraction.
 	            if (special) {
 	              special(wptr, dbl2tmp);
 	            } else {
@@ -2940,7 +2937,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	            }
 	
 	        } else if (valtype == STRING) {
-	          /* Apply keyword parameterization. */
+	          // Apply keyword parameterization.
 	          if (ptype == 's') {
 	            ipx = wcsp->nps++;
 	            wcsp->ps[ipx].i = i;
@@ -3009,7 +3006,7 @@ jmp_buf wcsbth_abort_jmp_env;
 <DISCARD>.*$ {
 	  if (ipass == npass) {
 	    if (ctrl < 0) {
-	      /* Preserve discards. */
+	      // Preserve discards.
 	      keep = keyrec;
 	
 	    } else if (2 < ctrl) {
@@ -3047,7 +3044,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	
 	  naux += auxprm;
 	
-	  /* Throw away the rest of the line and reset for the next one. */
+	  // Throw away the rest of the line and reset for the next one.
 	  i = j = 0;
 	  n = k = 0;
 	  m = 0;
@@ -3069,7 +3066,7 @@ jmp_buf wcsbth_abort_jmp_env;
 	}
 
 <<EOF>>	 {
-	  /* End-of-input. */
+	  // End-of-input.
 	  if (ipass == 1) {
 	    if ((status = wcsbth_init1(&alts, naux, nwcs, wcs)) ||
 	        (*nwcs == 0 && ctrl == 0)) {
@@ -3178,20 +3175,20 @@ int wcsbth_pass1(
   int ialt, icol, mask, ncol;
 
   if (a == 0) {
-    /* Keywords such as DATE-OBS go along for the ride. */
+    // Keywords such as DATE-OBS go along for the ride.
     return 0;
   }
 
   ncol = alts->ncol;
 
-  /* Do we need to allocate memory for alts? */
+  // Do we need to allocate memory for alts?
   if (alts->arridx == 0x0) {
     if (ncol == 0) {
-      /* Can only happen if TFIELDS is missing or out-of-sequence.  If n and
-         k are both zero then we may be processing an image header so leave
-         ncol alone - the array will be realloc'd later if required. */
+      // Can only happen if TFIELDS is missing or out-of-sequence.  If n and
+      // k are both zero then we may be processing an image header so leave
+      // ncol alone - the array will be realloc'd later if required.
       if (n || k) {
-        /* The header is mangled, assume the worst. */
+        // The header is mangled, assume the worst.
         ncol = 999;
       }
     }
@@ -3210,7 +3207,7 @@ int wcsbth_pass1(
     alts->ncol = ncol;
 
   } else if (n > ncol || k > ncol) {
-    /* Can only happen if TFIELDS or the WCS keyword is wrong; carry on. */
+    // Can only happen if TFIELDS or the WCS keyword is wrong; carry on.
     ncol = 999;
     if (!(alts->arridx  = realloc(alts->arridx,
                                     27*(1 + ncol)*sizeof(short int))) ||
@@ -3227,7 +3224,7 @@ int wcsbth_pass1(
       return 2;
     }
 
-    /* Since realloc() doesn't initialize the extra memory. */
+    // Since realloc() doesn't initialize the extra memory.
     for (icol = (1 + alts->ncol); icol < (1 + ncol); icol++) {
       for (ialt = 0; ialt < 27; ialt++) {
         alts->arridx[icol][ialt] = 0;
@@ -3245,18 +3242,18 @@ int wcsbth_pass1(
     ialt = a - 'A' + 1;
   }
 
-  /* A BINTAB keytype such as LONPna, in conjunction with an IMGAXIS keytype
-     causes a table column to be recognized as an image array. */
+  // A BINTAB keytype such as LONPna, in conjunction with an IMGAXIS keytype
+  // causes a table column to be recognized as an image array.
   if (keytype & IMGHEAD || keytype & BIMGARR) {
-    /* n == 0 is expected for IMGHEAD keywords. */
+    // n == 0 is expected for IMGHEAD keywords.
     if (i == 0 && j == 0) {
       if (alts->arridx[n][ialt] == 0) {
-        /* Flag that an auxiliary keyword was seen. */
+        // Flag that an auxiliary keyword was seen.
         alts->arridx[n][ialt] = -1;
       }
 
     } else {
-      /* Record the maximum axis number found. */
+      // Record the maximum axis number found.
       if (alts->arridx[n][ialt] < i) {
         alts->arridx[n][ialt] = i;
       }
@@ -3273,17 +3270,17 @@ int wcsbth_pass1(
     }
   }
 
-  /* BINTAB keytypes, which apply both to pixel lists as well as binary table
-     image arrays, never contribute to recognizing a table column as a pixel
-     list axis.  A PIXLIST keytype is required for that. */
+  // BINTAB keytypes, which apply both to pixel lists as well as binary table
+  // image arrays, never contribute to recognizing a table column as a pixel
+  // list axis.  A PIXLIST keytype is required for that.
   if (keytype == PIXLIST) {
     mask = 1 << ialt;
 
-    /* n > 0 for PIXLIST keytypes. */
+    // n > 0 for PIXLIST keytypes.
     alts->pixlist[n] |= mask;
     if (k) alts->pixlist[k] |= mask;
 
-    /* Used as a flag over all columns. */
+    // Used as a flag over all columns.
     alts->pixlist[0] |= mask;
 
     if (ptype == 'v') {
@@ -3320,7 +3317,7 @@ int wcsbth_init1(
     return 0;
   }
 
-  /* Determine the number of axes in each pixel list representation. */
+  // Determine the number of axes in each pixel list representation.
   ncol = alts->ncol;
   for (ialt = 0, mask = 1; ialt < 27; ialt++, mask <<= 1) {
     alts->pixidx[ialt] = 0;
@@ -3334,7 +3331,7 @@ int wcsbth_init1(
     }
   }
 
-  /* Find the total number of coordinate representations. */
+  // Find the total number of coordinate representations.
   *nwcs = 0;
   alts->imgherit = 0;
   for (ialt = 0; ialt < 27; ialt++) {
@@ -3342,10 +3339,10 @@ int wcsbth_init1(
 
     for (icol = 1; icol <= ncol; icol++) {
       if (alts->arridx[icol][ialt] < 0) {
-        /* No BIMGARR keytype but there's at least one BINTAB. */
+        // No BIMGARR keytype but there's at least one BINTAB.
         if (alts->arridx[0][ialt] > 0) {
-          /* There is an IMGAXIS keytype that we will inherit, so count this
-             representation. */
+          // There is an IMGAXIS keytype that we will inherit, so count this
+          // representation.
           alts->arridx[icol][ialt] = alts->arridx[0][ialt];
         } else {
           alts->arridx[icol][ialt] = 0;
@@ -3354,11 +3351,11 @@ int wcsbth_init1(
 
       if (alts->arridx[icol][ialt]) {
         if (alts->arridx[0][ialt]) {
-          /* All IMGHEAD keywords are inherited for this ialt. */
+          // All IMGHEAD keywords are inherited for this ialt.
           inherit[ialt] = 1;
 
           if (alts->arridx[icol][ialt] < alts->arridx[0][ialt]) {
-            /* The extra axes are also inherited. */
+            // The extra axes are also inherited.
             alts->arridx[icol][ialt] = alts->arridx[0][ialt];
           }
         }
@@ -3367,10 +3364,10 @@ int wcsbth_init1(
       }
     }
 
-    /* Count every "a" found in any IMGHEAD keyword... */
+    // Count every "a" found in any IMGHEAD keyword...
     if (alts->arridx[0][ialt]) {
       if (inherit[ialt]) {
-        /* ...but not if the IMGHEAD keywords will be inherited. */
+        // ...but not if the IMGHEAD keywords will be inherited.
         alts->arridx[0][ialt] = 0;
         alts->imgherit = 1;
       } else if (alts->arridx[0][ialt] > 0) {
@@ -3378,7 +3375,7 @@ int wcsbth_init1(
       }
     }
 
-    /* We need a struct for every "a" found in a PIXLIST keyword. */
+    // We need a struct for every "a" found in a PIXLIST keyword.
     if (alts->pixidx[ialt]) {
       (*nwcs)++;
     }
@@ -3386,19 +3383,19 @@ int wcsbth_init1(
 
 
   if (*nwcs) {
-    /* Allocate memory for the required number of wcsprm structs. */
+    // Allocate memory for the required number of wcsprm structs.
     if (!(*wcs = calloc(*nwcs, sizeof(struct wcsprm)))) {
       return 2;
     }
 
-    /* Initialize each wcsprm struct. */
+    // Initialize each wcsprm struct.
     wcsp = *wcs;
     *nwcs = 0;
     for (icol = 0; icol <= ncol; icol++) {
       for (ialt = 0; ialt < 27; ialt++) {
         if (alts->arridx[icol][ialt] > 0) {
-          /* Image-header representations that are not for inheritance
-             (icol == 0) or binary table image array representations. */
+          // Image-header representations that are not for inheritance
+          // (icol == 0) or binary table image array representations.
           wcsp->flag = -1;
           npvmax = alts->npv[icol][ialt];
           npsmax = alts->nps[icol][ialt];
@@ -3408,29 +3405,29 @@ int wcsbth_init1(
             break;
           }
 
-          /* Record the alternate version code. */
+          // Record the alternate version code.
           if (ialt) {
             wcsp->alt[0] = 'A' + ialt - 1;
           }
 
-          /* Any additional auxiliary keywords present? */
+          // Any additional auxiliary keywords present?
           if (naux) {
             if (wcsauxi(1, wcsp)) {
               return WCSHDRERR_MEMORY;
             }
           }
 
-          /* Record the table column number. */
+          // Record the table column number.
           wcsp->colnum = icol;
 
-          /* On the second pass alts->arridx[icol][27] indexes the array of
-             wcsprm structs. */
+          // On the second pass alts->arridx[icol][27] indexes the array of
+          // wcsprm structs.
           alts->arridx[icol][ialt] = (*nwcs)++;
 
           wcsp++;
 
         } else {
-          /* Signal that this column has no WCS for this "a". */
+          // Signal that this column has no WCS for this "a".
           alts->arridx[icol][ialt] = -1;
         }
       }
@@ -3438,7 +3435,7 @@ int wcsbth_init1(
 
     for (ialt = 0; ialt < 27; ialt++) {
       if (alts->pixidx[ialt]) {
-        /* Pixel lists representations. */
+        // Pixel lists representations.
         wcsp->flag = -1;
         npvmax = alts->pixnpv[ialt];
         npsmax = alts->pixnps[ialt];
@@ -3448,19 +3445,19 @@ int wcsbth_init1(
           break;
         }
 
-        /* Record the alternate version code. */
+        // Record the alternate version code.
         if (ialt) {
           wcsp->alt[0] = 'A' + ialt - 1;
         }
 
-        /* Any additional auxiliary keywords present? */
+        // Any additional auxiliary keywords present?
         if (naux) {
           if (wcsauxi(1, wcsp)) {
             return WCSHDRERR_MEMORY;
           }
         }
 
-        /* Record the pixel list column numbers. */
+        // Record the pixel list column numbers.
         mask = (1 << ialt);
         for (icol = 1, ix = 0; icol <= ncol; icol++) {
           if (alts->pixlist[icol] & mask) {
@@ -3468,13 +3465,13 @@ int wcsbth_init1(
           }
         }
 
-        /* alts->pixidx[] indexes the array of wcsprm structs. */
+        // alts->pixidx[] indexes the array of wcsprm structs.
         alts->pixidx[ialt] = (*nwcs)++;
 
         wcsp++;
 
       } else {
-        /* Signal that this column is not a pixel list axis for this "a". */
+        // Signal that this column is not a pixel list axis for this "a".
         alts->pixidx[ialt] = -1;
       }
     }
@@ -3504,22 +3501,22 @@ struct wcsprm *wcsbth_idx(
 
   iwcs = -1;
   for (; iwcs < 0 && alts->ialt < 27; alts->ialt++) {
-    /* Note that a == 0 applies to every alternate, otherwise this
-       loop simply determines the appropriate value of alts->ialt. */
+    // Note that a == 0 applies to every alternate, otherwise this
+    // loop simply determines the appropriate value of alts->ialt.
     if (a && a != as[alts->ialt]) continue;
 
     if (keytype & (IMGHEAD | BIMGARR)) {
       for (; iwcs < 0 && alts->icol <= alts->ncol; alts->icol++) {
-        /* Image header keywords, n == 0, apply to all columns, otherwise this
-           loop simply determines the appropriate value of alts->icol. */
+        // Image header keywords, n == 0, apply to all columns, otherwise this
+        // loop simply determines the appropriate value of alts->icol.
         if (n && n != alts->icol) continue;
         iwcs = alts->arridx[alts->icol][alts->ialt];
       }
 
-      /* Break out of the loop to stop alts->ialt from being incremented. */
+      // Break out of the loop to stop alts->ialt from being incremented.
       if (iwcs >= 0) break;
 
-      /* Start from scratch for the next alts->ialt. */
+      // Start from scratch for the next alts->ialt.
       alts->icol = 0;
     }
 
@@ -3571,7 +3568,7 @@ int wcsbth_colax(
 int wcsbth_jdref(double *mjdref, const double *jdref)
 
 {
-  /* Set MJDREF from JDREF. */
+  // Set MJDREF from JDREF.
   if (undefined(mjdref[0] && undefined(mjdref[1]))) {
     mjdref[0] = jdref[0] - 2400000.0;
     mjdref[1] = jdref[1] - 0.5;
@@ -3588,7 +3585,7 @@ int wcsbth_jdref(double *mjdref, const d
 int wcsbth_jdrefi(double *mjdref, const double *jdrefi)
 
 {
-  /* Set the integer part of MJDREF from JDREFI. */
+  // Set the integer part of MJDREF from JDREFI.
   if (undefined(mjdref[0])) {
     mjdref[0] = *jdrefi - 2400000.5;
   }
@@ -3600,7 +3597,7 @@ int wcsbth_jdrefi(double *mjdref, const
 int wcsbth_jdreff(double *mjdref, const double *jdreff)
 
 {
-  /* Set the fractional part of MJDREF from JDREFF. */
+  // Set the fractional part of MJDREF from JDREFF.
   if (undefined(mjdref[1])) {
     mjdref[1] = *jdreff;
   }
@@ -3616,7 +3613,7 @@ int wcsbth_jdreff(double *mjdref, const
 int wcsbth_epoch(double *equinox, const double *epoch)
 
 {
-  /* If EQUINOXa is currently undefined then set it from EPOCHa. */
+  // If EQUINOXa is currently undefined then set it from EPOCHa.
   if (undefined(*equinox)) {
     *equinox = *epoch;
   }
@@ -3634,9 +3631,9 @@ int wcsbth_vsource(double *zsource, cons
 {
   double beta, c = 299792458.0;
 
-  /* If ZSOURCEa is currently undefined then set it from VSOURCEa. */
+  // If ZSOURCEa is currently undefined then set it from VSOURCEa.
   if (undefined(*zsource)) {
-    /* Convert relativistic Doppler velocity to redshift. */
+    // Convert relativistic Doppler velocity to redshift.
     beta = *vsource/c;
     *zsource = (1.0 + beta)/sqrt(1.0 - beta*beta) - 1.0;
   }
@@ -3674,7 +3671,7 @@ int wcsbth_final(
   if (alts->pixlist) free(alts->pixlist);
 
   for (ialt = 0; ialt < *nwcs; ialt++) {
-    /* Interpret -TAB header keywords. */
+    // Interpret -TAB header keywords.
     if ((status = wcstab(*wcs+ialt))) {
        wcsvfree(nwcs, wcs);
        return status;
Index: astropy-4.2/cextern/wcslib/C/wcserr.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcserr.c
+++ astropy-4.2/cextern/wcslib/C/wcserr.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,12 +17,10 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   Module author: Michael Droettboom
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcserr.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcserr.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <stdarg.h>
@@ -36,7 +33,7 @@
 
 static int wcserr_enabled = 0;
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcserr_enable(int enable)
 
@@ -44,7 +41,7 @@ int wcserr_enable(int enable)
   return wcserr_enabled = (enable ? 1 : 0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcserr_prt(const struct wcserr *err, const char *prefix)
 
@@ -66,7 +63,7 @@ int wcserr_prt(const struct wcserr *err,
         prefix, err->status, err->function, err->line_no, err->file, prefix,
         err->msg);
     } else {
-      /* An informative message only. */
+      // An informative message only.
       wcsprintf("%sINFORMATIVE message from %s() at line %d of file "
         "%s:\n%s%s.\n", prefix, err->function, err->line_no, err->file,
         prefix, err->msg);
@@ -76,7 +73,7 @@ int wcserr_prt(const struct wcserr *err,
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcserr_clear(struct wcserr **errp)
 
@@ -92,7 +89,7 @@ int wcserr_clear(struct wcserr **errp)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcserr_set(
   struct wcserr **errp,
@@ -130,7 +127,7 @@ int wcserr_set(
     err->line_no  = line_no;
     err->msg      = 0x0;
 
-    /* Determine the required message buffer size. */
+    // Determine the required message buffer size.
     va_start(argp, format);
     msglen = vsnprintf(0x0, 0, format, argp) + 1;
     va_end(argp);
@@ -140,7 +137,7 @@ int wcserr_set(
       return status;
     }
 
-    /* Write the message. */
+    // Write the message.
     va_start(argp, format);
     msglen = vsnprintf(err->msg, msglen, format, argp);
     va_end(argp);
@@ -153,7 +150,7 @@ int wcserr_set(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcserr_copy(const struct wcserr *src, struct wcserr *dst)
 
Index: astropy-4.2/cextern/wcslib/C/wcserr.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcserr.h
+++ astropy-4.2/cextern/wcslib/C/wcserr.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,15 +17,13 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   Module author: Michael Droettboom
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcserr.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcserr.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -221,14 +218,14 @@ extern "C" {
 #endif
 
 struct wcserr {
-  int  status;			/* Status code for the error.               */
-  int  line_no;			/* Line number where the error occurred.    */
-  const char *function;		/* Function name.                           */
-  const char *file;		/* Source file name.                        */
-  char *msg;			/* Informative error message.               */
+  int  status;			// Status code for the error.
+  int  line_no;			// Line number where the error occurred.
+  const char *function;		// Function name.
+  const char *file;		// Source file name.
+  char *msg;			// Informative error message.
 };
 
-/* Size of the wcserr struct in int units, used by the Fortran wrappers. */
+// Size of the wcserr struct in int units, used by the Fortran wrappers.
 #define ERRLEN (sizeof(struct wcserr)/sizeof(int))
 
 int wcserr_enable(int enable);
@@ -238,18 +235,18 @@ int wcserr_prt(const struct wcserr *err,
 int wcserr_clear(struct wcserr **err);
 
 
-/* INTERNAL USE ONLY -------------------------------------------------------*/
+// INTERNAL USE ONLY -------------------------------------------------------
 
 int wcserr_set(struct wcserr **err, int status, const char *function,
   const char *file, int line_no, const char *format, ...);
 
 int wcserr_copy(const struct wcserr *src, struct wcserr *dst);
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define WCSERR_SET(status) err, status, function, __FILE__, __LINE__
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* WSCLIB_WCSERR */
+#endif // WSCLIB_WCSERR
Index: astropy-4.2/cextern/wcslib/C/wcsfix.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsfix.c
+++ astropy-4.2/cextern/wcslib/C/wcsfix.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsfix.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsfix.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -42,10 +39,10 @@
 
 extern const int WCSSET;
 
-/* Maximum number of coordinate axes that can be handled. */
+// Maximum number of coordinate axes that can be handled.
 #define NMAX 16
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *wcsfix_errmsg[] = {
   "Success",
   "Null wcsprm pointer passed",
@@ -59,36 +56,36 @@ const char *wcsfix_errmsg[] = {
   "Could not determine reference pixel coordinate",
   "Could not determine reference pixel value"};
 
-/* Map error returns for lower-level routines. */
+// Map error returns for lower-level routines.
 const int fix_linerr[] = {
-  FIXERR_SUCCESS,		/*  0: LINERR_SUCCESS         */
-  FIXERR_NULL_POINTER,		/*  1: LINERR_NULL_POINTER    */
-  FIXERR_MEMORY,		/*  2: LINERR_MEMORY          */
-  FIXERR_SINGULAR_MTX,		/*  3: LINERR_SINGULAR_MTX    */
-  FIXERR_BAD_PARAM,		/*  4: LINERR_DISTORT_INIT    */
-  FIXERR_NO_REF_PIX_COORD,	/*  5: LINERR_DISTORT         */
-  FIXERR_NO_REF_PIX_VAL		/*  6: LINERR_DEDISTORT       */
+  FIXERR_SUCCESS,		//  0: LINERR_SUCCESS
+  FIXERR_NULL_POINTER,		//  1: LINERR_NULL_POINTER
+  FIXERR_MEMORY,		//  2: LINERR_MEMORY
+  FIXERR_SINGULAR_MTX,		//  3: LINERR_SINGULAR_MTX
+  FIXERR_BAD_PARAM,		//  4: LINERR_DISTORT_INIT
+  FIXERR_NO_REF_PIX_COORD,	//  5: LINERR_DISTORT
+  FIXERR_NO_REF_PIX_VAL		//  6: LINERR_DEDISTORT
 };
 
 const int fix_wcserr[] = {
-  FIXERR_SUCCESS,		/*  0: WCSERR_SUCCESS         */
-  FIXERR_NULL_POINTER,		/*  1: WCSERR_NULL_POINTER    */
-  FIXERR_MEMORY,		/*  2: WCSERR_MEMORY          */
-  FIXERR_SINGULAR_MTX,		/*  3: WCSERR_SINGULAR_MTX    */
-  FIXERR_BAD_CTYPE,		/*  4: WCSERR_BAD_CTYPE       */
-  FIXERR_BAD_PARAM,		/*  5: WCSERR_BAD_PARAM       */
-  FIXERR_BAD_COORD_TRANS,	/*  6: WCSERR_BAD_COORD_TRANS */
-  FIXERR_ILL_COORD_TRANS,	/*  7: WCSERR_ILL_COORD_TRANS */
-  FIXERR_BAD_CORNER_PIX,	/*  8: WCSERR_BAD_PIX         */
-  FIXERR_NO_REF_PIX_VAL,	/*  9: WCSERR_BAD_WORLD       */
-  FIXERR_NO_REF_PIX_VAL 	/* 10: WCSERR_BAD_WORLD_COORD */
-				/*     ...others not used     */
+  FIXERR_SUCCESS,		//  0: WCSERR_SUCCESS
+  FIXERR_NULL_POINTER,		//  1: WCSERR_NULL_POINTER
+  FIXERR_MEMORY,		//  2: WCSERR_MEMORY
+  FIXERR_SINGULAR_MTX,		//  3: WCSERR_SINGULAR_MTX
+  FIXERR_BAD_CTYPE,		//  4: WCSERR_BAD_CTYPE
+  FIXERR_BAD_PARAM,		//  5: WCSERR_BAD_PARAM
+  FIXERR_BAD_COORD_TRANS,	//  6: WCSERR_BAD_COORD_TRANS
+  FIXERR_ILL_COORD_TRANS,	//  7: WCSERR_ILL_COORD_TRANS
+  FIXERR_BAD_CORNER_PIX,	//  8: WCSERR_BAD_PIX
+  FIXERR_NO_REF_PIX_VAL,	//  9: WCSERR_BAD_WORLD
+  FIXERR_NO_REF_PIX_VAL 	// 10: WCSERR_BAD_WORLD_COORD
+				//     ...others not used
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define WCSFIX_ERRMSG(status) WCSERR_SET(status), wcsfix_errmsg[status]
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsfix(int ctrl, const int naxis[], struct wcsprm *wcs, int stat[])
 
@@ -126,7 +123,7 @@ int wcsfix(int ctrl, const int naxis[],
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsfixi(
   int ctrl,
@@ -139,20 +136,20 @@ int wcsfixi(
   int ifix, status = 0;
   struct wcserr err;
 
-  /* Handling the status values returned from the sub-fixers is trickier than
-  it might seem, especially considering that wcs->err may contain an error
-  status on input which should be preserved if no translation errors occur.
-  The simplest way seems to be to save a copy of wcs->err and clear it before
-  each sub-fixer.  The last real error to occur, excluding informative
-  messages, is the one returned.
-
-  To get informative messages from spcfix() it must precede celfix() and
-  cylfix().  The latter call wcsset() which also translates AIPS-convention
-  spectral axes. */
+  // Handling the status values returned from the sub-fixers is trickier than
+  // it might seem, especially considering that wcs->err may contain an error
+  // status on input which should be preserved if no translation errors occur.
+  // The simplest way seems to be to save a copy of wcs->err and clear it
+  // before each sub-fixer.  The last real error to occur, excluding
+  // informative messages, is the one returned.
+
+  // To get informative messages from spcfix() it must precede celfix() and
+  // cylfix().  The latter call wcsset() which also translates AIPS-convention
+  // spectral axes.
   wcserr_copy(wcs->err, &err);
 
   for (ifix = CDFIX; ifix < NWCSFIX; ifix++) {
-    /* Clear (delete) wcs->err. */
+    // Clear (delete) wcs->err.
     wcserr_clear(&(wcs->err));
 
     switch (ifix) {
@@ -182,11 +179,11 @@ int wcsfixi(
     }
 
     if (stat[ifix] == FIXERR_NO_CHANGE) {
-      /* No change => no message. */
+      // No change => no message.
       wcserr_copy(0x0, info+ifix);
 
     } else if (stat[ifix] == 0) {
-      /* Successful translation, but there may be an informative message. */
+      // Successful translation, but there may be an informative message.
       if (wcs->err && wcs->err->status < 0) {
         wcserr_copy(wcs->err, info+ifix);
       } else {
@@ -194,17 +191,17 @@ int wcsfixi(
       }
 
     } else {
-      /* An informative message or error message. */
+      // An informative message or error message.
       wcserr_copy(wcs->err, info+ifix);
 
       if ((status = (stat[ifix] > 0))) {
-        /* It was an error, replace the previous one. */
+        // It was an error, replace the previous one.
         wcserr_copy(wcs->err, &err);
       }
     }
   }
 
-  /* Restore the last error to occur. */
+  // Restore the last error to occur.
   if (err.status) {
     wcserr_copy(&err, wcs->err);
   } else {
@@ -214,7 +211,7 @@ int wcsfixi(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cdfix(struct wcsprm *wcs)
 
@@ -225,20 +222,20 @@ int cdfix(struct wcsprm *wcs)
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
 
   if ((wcs->altlin & 1) || !(wcs->altlin & 2)) {
-    /* Either we have PCi_ja or there are no CDi_ja. */
+    // Either we have PCi_ja or there are no CDi_ja.
     return FIXERR_NO_CHANGE;
   }
 
   naxis = wcs->naxis;
   status = FIXERR_NO_CHANGE;
   for (i = 0; i < naxis; i++) {
-    /* Row of zeros? */
+    // Row of zeros?
     cd = wcs->cd + i * naxis;
     for (k = 0; k < naxis; k++, cd++) {
       if (*cd != 0.0) goto next;
     }
 
-    /* Column of zeros? */
+    // Column of zeros?
     cd = wcs->cd + i;
     for (k = 0; k < naxis; k++, cd += naxis) {
       if (*cd != 0.0) goto next;
@@ -246,7 +243,7 @@ int cdfix(struct wcsprm *wcs)
 
     cd = wcs->cd + i * (naxis + 1);
     *cd = 1.0;
-    status = 0;
+    status = FIXERR_SUCCESS;
 
 next: ;
   }
@@ -254,7 +251,7 @@ next: ;
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 static int parse_date(const char *buf, int *hour, int *minute, double *sec)
 
@@ -300,11 +297,11 @@ int datfix(struct wcsprm *wcs)
 {
   static const char *function = "datfix";
 
-  /* MJD of J2000.0 and B1900.0. */
+  // MJD of J2000.0 and B1900.0.
   const double mjd2000 = 51544.5;
   const double mjd1900 = 15019.81352;
 
-  /* Days per Julian year and per tropical year. */
+  // Days per Julian year and per tropical year.
   const double djy = 365.25;
   const double dty = 365.242198781;
 
@@ -322,10 +319,10 @@ int datfix(struct wcsprm *wcs)
   status = FIXERR_NO_CHANGE;
 
   for (i = 0; i < 5; i++) {
-    /* MJDREF is split into integer and fractional parts, wheres MJDOBS and
-       the rest are a single value. */
+    // MJDREF is split into integer and fractional parts, wheres MJDOBS and
+    // the rest are a single value.
     if (i == 0) {
-      /* Note, DATEREF and MJDREF, not DATE-REF and MJD-REF (sigh). */
+      // Note, DATEREF and MJDREF, not DATE-REF and MJD-REF (sigh).
       dateid = "REF";
       date   = wcs->dateref;
       wcsmjd = wcs->mjdref;
@@ -350,10 +347,10 @@ int datfix(struct wcsprm *wcs)
     strncpy(orig_date, date, 72);
 
     if (date[0] == '\0') {
-      /* Fill in DATE from MJD if possible. */
+      // Fill in DATE from MJD if possible.
 
       if (i == 1 && undefined(*wcsmjd)) {
-        /* See if we have jepoch or bepoch. */
+        // See if we have jepoch or bepoch.
         if (!undefined(wcs->jepoch)) {
           *wcsmjd = mjd2000 + (wcs->jepoch - 2000.0)*djy;
           sprintf(newline(&cp), "Set MJD-OBS to %.6f from JEPOCH", *wcsmjd);
@@ -362,25 +359,27 @@ int datfix(struct wcsprm *wcs)
           *wcsmjd = mjd1900 + (wcs->bepoch - 1900.0)*dty;
           sprintf(newline(&cp), "Set MJD-OBS to %.6f from BEPOCH", *wcsmjd);
         }
+
+	if (status == FIXERR_NO_CHANGE) status = FIXERR_SUCCESS;
       }
 
       if (undefined(*wcsmjd)) {
-        /* No date information was provided. */
+        // No date information was provided.
 
       } else {
-        /* Calendar date from MJD, with allowance for MJD < 0. */
+        // Calendar date from MJD, with allowance for MJD < 0.
         if (i == 0) {
-          /* MJDREF is already split into integer and fractional parts. */
+          // MJDREF is already split into integer and fractional parts.
           mjd[0] = wcsmjd[0];
           mjd[1] = wcsmjd[1];
           if (1.0 < mjd[1]) {
-            /* Ensure the fractional part lies between 0 and +1. */
+            // Ensure the fractional part lies between 0 and +1.
             t = floor(mjd[1]);
             mjd[0] += t;
             mjd[1] -= t;
           }
         } else {
-          /* Split it into integer and fractional parts. */
+          // Split it into integer and fractional parts.
           mjd[0] = floor(*wcsmjd);
           mjd[1] = *wcsmjd - mjd[0];
         }
@@ -395,7 +394,7 @@ int datfix(struct wcsprm *wcs)
         day   = (dd%306)/10 + 1;
         sprintf(date, "%.4d-%.2d-%.2d", year, month, day);
 
-        /* Write time part only if non-zero. */
+        // Write time part only if non-zero.
         if (0.0 < (t = mjd[1])) {
           t *= 24.0;
           hour = (int)t;
@@ -403,7 +402,7 @@ int datfix(struct wcsprm *wcs)
           minute = (int)t;
           sec    = 60.0 * (t - minute);
 
-          /* Round to 1ms. */
+          // Round to 1ms.
           dd = 60000*(60*hour + minute) + (int)(1000*(sec+0.0005));
           hour = dd / 3600000;
           dd -= 3600000 * hour;
@@ -411,7 +410,7 @@ int datfix(struct wcsprm *wcs)
           msec = dd - 60000 * minute;
           sprintf(date+10, "T%.2d:%.2d:%.2d", hour, minute, msec/1000);
 
-          /* Write fractions of a second only if non-zero. */
+          // Write fractions of a second only if non-zero.
           if (msec%1000) {
             sprintf(date+19, ".%.3d", msec%1000);
           }
@@ -420,16 +419,16 @@ int datfix(struct wcsprm *wcs)
 
     } else {
       if (strlen(date) < 8) {
-        /* Can't be a valid date. */
+        // Can't be a valid date.
         status = FIXERR_BAD_PARAM;
         sprintf(newline(&cp), "Invalid DATE%s format '%s' is too short",
           dateid, date);
         continue;
       }
 
-      /* Identify the date format. */
+      // Identify the date format.
       if (date[4] == '-' && date[7] == '-') {
-        /* Standard year-2000 form: CCYY-MM-DD[Thh:mm:ss[.sss...]] */
+        // Standard year-2000 form: CCYY-MM-DD[Thh:mm:ss[.sss...]]
         if (sscanf(date, "%4d-%2d-%2d", &year, &month, &day) < 3) {
           status = FIXERR_BAD_PARAM;
           sprintf(newline(&cp), "Invalid DATE%s format '%s'", dateid, date);
@@ -455,7 +454,7 @@ int datfix(struct wcsprm *wcs)
         }
 
       } else if (date[4] == '/' && date[7] == '/') {
-        /* Also allow CCYY/MM/DD[Thh:mm:ss[.sss...]] */
+        // Also allow CCYY/MM/DD[Thh:mm:ss[.sss...]]
         if (sscanf(date, "%4d/%2d/%2d", &year, &month, &day) < 3) {
           status = FIXERR_BAD_PARAM;
           sprintf(newline(&cp), "Invalid DATE%s format '%s'", dateid, date);
@@ -480,13 +479,13 @@ int datfix(struct wcsprm *wcs)
           }
         }
 
-        /* Looks ok, fix it up. */
+        // Looks ok, fix it up.
         date[4]  = '-';
         date[7]  = '-';
 
       } else {
         if (i == 1 && date[2] == '/' && date[5] == '/') {
-          /* Old format DATE-OBS date: DD/MM/YY, also allowing DD/MM/CCYY. */
+          // Old format DATE-OBS date: DD/MM/YY, also allowing DD/MM/CCYY.
           if (sscanf(date, "%2d/%2d/%4d", &day, &month, &year) < 3) {
             status = FIXERR_BAD_PARAM;
             sprintf(newline(&cp), "Invalid DATE%s format '%s'", dateid,
@@ -495,7 +494,7 @@ int datfix(struct wcsprm *wcs)
           }
 
         } else if (i == 1 && date[2] == '-' && date[5] == '-') {
-          /* Also recognize DD-MM-YY and DD-MM-CCYY */
+          // Also recognize DD-MM-YY and DD-MM-CCYY
           if (sscanf(date, "%2d-%2d-%4d", &day, &month, &year) < 3) {
             status = FIXERR_BAD_PARAM;
             sprintf(newline(&cp), "Invalid DATE%s format '%s'", dateid,
@@ -504,7 +503,7 @@ int datfix(struct wcsprm *wcs)
           }
 
         } else {
-          /* Not a valid date format. */
+          // Not a valid date format.
           status = FIXERR_BAD_PARAM;
           sprintf(newline(&cp), "Invalid DATE%s format '%s'", dateid, date);
           continue;
@@ -512,11 +511,11 @@ int datfix(struct wcsprm *wcs)
 
         if (year < 100) year += 1900;
 
-        /* Doesn't have a time. */
+        // Doesn't have a time.
         sprintf(date, "%.4d-%.2d-%.2d", year, month, day);
       }
 
-      /* Compute MJD. */
+      // Compute MJD.
       mjd[0] = (double)((1461*(year - (12-month)/10 + 4712))/4
                + (306*((month+9)%12) + 5)/10
                - (3*((year - (12-month)/10 + 4900)/100))/4
@@ -534,8 +533,10 @@ int datfix(struct wcsprm *wcs)
         sprintf(newline(&cp), "Set MJD%s to %.6f from DATE%s", dateid,
           mjdsum, dateid);
 
+        if (status == FIXERR_NO_CHANGE) status = FIXERR_SUCCESS;
+
       } else {
-        /* Check for consistency. */
+        // Check for consistency.
         if (i == 0) {
           mjdtmp = wcsmjd[0] + wcsmjd[1];
         } else {
@@ -552,21 +553,21 @@ int datfix(struct wcsprm *wcs)
 
       if (i == 1) {
         if (!undefined(wcs->jepoch)) {
-          /* Check consistency of JEPOCH. */
+          // Check consistency of JEPOCH.
           jepoch = 2000.0 + (*wcsmjd - mjd2000) / djy;
 
           if (0.000002 < fabs(jepoch - wcs->jepoch)) {
-            /* Informational only, no error. */
+            // Informational only, no error.
             sprintf(newline(&cp), "JEPOCH is inconsistent with DATE-OBS");
           }
         }
 
         if (!undefined(wcs->bepoch)) {
-          /* Check consistency of BEPOCH. */
+          // Check consistency of BEPOCH.
           bepoch = 1900.0 + (*wcsmjd - mjd1900) / dty;
 
           if (0.000002 < fabs(bepoch - wcs->bepoch)) {
-            /* Informational only, no error. */
+            // Informational only, no error.
             sprintf(newline(&cp), "BEPOCH is inconsistent with DATE-OBS");
           }
         }
@@ -582,7 +583,7 @@ int datfix(struct wcsprm *wcs)
           orig_date, date);
       }
 
-      if (status == FIXERR_NO_CHANGE) status = 0;
+      if (status == FIXERR_NO_CHANGE) status = FIXERR_SUCCESS;
     }
   }
 
@@ -593,14 +594,14 @@ int datfix(struct wcsprm *wcs)
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int obsfix(int ctrl, struct wcsprm *wcs)
 
 {
   static const char *function = "obsfix";
 
-  /* IAU(1976) ellipsoid (as prescribed by WCS Paper VII). */
+  // IAU(1976) ellipsoid (as prescribed by WCS Paper VII).
   const double a = 6378140.0, f = 1.0 / 298.2577;
   const double e2 = (2.0 - f)*f;
 
@@ -614,7 +615,7 @@ int obsfix(int ctrl, struct wcsprm *wcs)
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
   err = &(wcs->err);
 
-  /* Set masks for checking partially-defined coordinate triplets. */
+  // Set masks for checking partially-defined coordinate triplets.
   havexyz -= 1*undefined(wcs->obsgeo[0]);
   havexyz -= 2*undefined(wcs->obsgeo[1]);
   havexyz -= 4*undefined(wcs->obsgeo[2]);
@@ -623,7 +624,7 @@ int obsfix(int ctrl, struct wcsprm *wcs)
   havelbh -= 4*undefined(wcs->obsgeo[5]);
 
   if (ctrl == 2) {
-    /* Make no changes. */
+    // Make no changes.
     if (0 < havexyz && havexyz < 7) {
       return wcserr_set(WCSERR_SET(FIXERR_BAD_PARAM),
         "Partially undefined Cartesian coordinate triplet");
@@ -648,7 +649,7 @@ int obsfix(int ctrl, struct wcsprm *wcs)
   status = FIXERR_NO_CHANGE;
 
   if (havelbh == 7) {
-    /* Compute (x,y,z) from (lng,lat,hgt). */
+    // Compute (x,y,z) from (lng,lat,hgt).
     sincosd(wcs->obsgeo[3], &sinlng, &coslng);
     sincosd(wcs->obsgeo[4], &sinlat, &coslat);
     n = a / sqrt(1.0 - e2*sinlat*sinlat);
@@ -659,8 +660,8 @@ int obsfix(int ctrl, struct wcsprm *wcs)
     z = (rho - n*e2)*sinlat;
 
     if (havexyz < 7) {
-      /* One or more of the Cartesian elements was undefined. */
-      status = 0;
+      // One or more of the Cartesian elements was undefined.
+      status = FIXERR_SUCCESS;
       cp = infomsg;
 
       if (ctrl == 1 || !(havexyz & 1)) {
@@ -695,19 +696,19 @@ int obsfix(int ctrl, struct wcsprm *wcs)
       wcserr_set(WCSERR_SET(FIXERR_OBSGEO_FIX), infomsg);
 
       if (havexyz == 0) {
-        /* Skip the consistency check. */
+        // Skip the consistency check.
         return status;
       }
     }
 
   } else if (havexyz == 7) {
-    /* Compute (lng,lat,hgt) from (x,y,z). */
+    // Compute (lng,lat,hgt) from (x,y,z).
     x = wcs->obsgeo[0];
     y = wcs->obsgeo[1];
     z = wcs->obsgeo[2];
     r2 = x*x + y*y;
 
-    /* Iterate over the value of zeta. */
+    // Iterate over the value of zeta.
     zeta = z;
     for (i = 0; i < 4; i++) {
       rho = sqrt(r2 + zeta*zeta);
@@ -722,8 +723,8 @@ int obsfix(int ctrl, struct wcsprm *wcs)
     hgt = rho - n;
 
     if (havelbh < 7) {
-      /* One or more of the Geodetic elements was undefined. */
-      status = 0;
+      // One or more of the Geodetic elements was undefined.
+      status = FIXERR_SUCCESS;
       cp = infomsg;
 
       if (ctrl == 1 || !(havelbh & 1)) {
@@ -757,12 +758,12 @@ int obsfix(int ctrl, struct wcsprm *wcs)
       wcserr_set(WCSERR_SET(FIXERR_OBSGEO_FIX), infomsg);
 
       if (havelbh == 0) {
-        /* Skip the consistency check. */
+        // Skip the consistency check.
         return status;
       }
     }
 
-    /* Compute (x,y,z) from (lng,lat,hgt) for consistency checking. */
+    // Compute (x,y,z) from (lng,lat,hgt) for consistency checking.
     sincosd(wcs->obsgeo[3], &sinlng, &coslng);
     sincosd(wcs->obsgeo[4], &sinlat, &coslat);
     n = a / sqrt(1.0 - e2*sinlat*sinlat);
@@ -778,7 +779,7 @@ int obsfix(int ctrl, struct wcsprm *wcs)
   }
 
 
-  /* Check consistency. */
+  // Check consistency.
   r2 = 0.0;
   d = wcs->obsgeo[0] - x;
   r2 += d*d;
@@ -797,7 +798,7 @@ int obsfix(int ctrl, struct wcsprm *wcs)
 }
 
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int unitfix(int ctrl, struct wcsprm *wcs)
 
@@ -829,18 +830,18 @@ int unitfix(int ctrl, struct wcsprm *wcs
   }
 
   if (status == FIXERR_UNITS_ALIAS) {
-    /* Chop off the trailing ", ". */
+    // Chop off the trailing ", ".
     msglen = strlen(msg) - 2;
     msg[msglen] = '\0';
     wcserr_set(WCSERR_SET(FIXERR_UNITS_ALIAS), msg);
 
-    status = 0;
+    status = FIXERR_SUCCESS;
   }
 
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int spcfix(struct wcsprm *wcs)
 
@@ -855,26 +856,26 @@ int spcfix(struct wcsprm *wcs)
   err = &(wcs->err);
 
   for (i = 0; i < wcs->naxis; i++) {
-    /* Translate an AIPS-convention spectral type if present. */
+    // Translate an AIPS-convention spectral type if present.
     status = spcaips(wcs->ctype[i], wcs->velref, ctype, specsys);
-    if (status == 0) {
-      /* An AIPS type was found but it may match what we already have. */
+    if (status == FIXERR_SUCCESS) {
+      // An AIPS type was found but it may match what we already have.
       status = FIXERR_NO_CHANGE;
 
-      /* Was specsys translated? */
+      // Was specsys translated?
       if (wcs->specsys[0] == '\0' && *specsys) {
         strncpy(wcs->specsys, specsys, 9);
         wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),
           "Changed SPECSYS to '%s'", specsys);
-        status = 0;
+        status = FIXERR_SUCCESS;
       }
 
-      /* Was ctype translated?  Have to null-fill for comparing them. */
+      // Was ctype translated?  Have to null-fill for comparing them.
       wcsutil_null_fill(9, wcs->ctype[i]);
       if (strncmp(wcs->ctype[i], ctype, 9)) {
-        /* ctype was translated... */
-        if (status == 0) {
-          /* ...and specsys was also. */
+        // ctype was translated...
+        if (status == FIXERR_SUCCESS) {
+          // ...and specsys was also.
           wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),
             "Changed CTYPE%d from '%s' to '%s', and SPECSYS to '%s' "
             "(VELREF=%d)", i+1, wcs->ctype[i], ctype, wcs->specsys,
@@ -883,23 +884,23 @@ int spcfix(struct wcsprm *wcs)
           wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),
             "Changed CTYPE%d from '%s' to '%s' (VELREF=%d)", i+1,
             wcs->ctype[i], ctype, wcs->velref);
-          status = 0;
+          status = FIXERR_SUCCESS;
         }
 
         strncpy(wcs->ctype[i], ctype, 9);
       }
 
-      /* Tidy up. */
-      if (status == 0) {
+      // Tidy up.
+      if (status == FIXERR_SUCCESS) {
         wcsutil_null_fill(72, wcs->ctype[i]);
         wcsutil_null_fill(72, wcs->specsys);
       }
 
-      /* No need to check for others, wcsset() will fail if so. */
+      // No need to check for others, wcsset() will fail if so.
       return status;
 
     } else if (status == SPCERR_BAD_SPEC_PARAMS) {
-      /* An AIPS spectral type was found but with invalid velref. */
+      // An AIPS spectral type was found but with invalid velref.
       return wcserr_set(WCSERR_SET(FIXERR_BAD_PARAM),
         "Invalid parameter value: velref = %d", wcs->velref);
     }
@@ -908,7 +909,7 @@ int spcfix(struct wcsprm *wcs)
   return FIXERR_NO_CHANGE;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int celfix(struct wcsprm *wcs)
 
@@ -923,20 +924,20 @@ int celfix(struct wcsprm *wcs)
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
   err = &(wcs->err);
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (wcs->flag != WCSSET) {
     if ((status = wcsset(wcs))) return fix_wcserr[status];
   }
 
-  /* Was an NCP or GLS projection code translated? */
+  // Was an NCP or GLS projection code translated?
   if (wcs->lat >= 0) {
-    /* Check ctype. */
+    // Check ctype.
     if (strcmp(wcs->ctype[wcs->lat]+5, "NCP") == 0) {
       strcpy(wcs->ctype[wcs->lng]+5, "SIN");
       strcpy(wcs->ctype[wcs->lat]+5, "SIN");
 
       if (wcs->npvmax < wcs->npv + 2) {
-        /* Allocate space for two more PVi_ma keyvalues. */
+        // Allocate space for two more PVi_ma keyvalues.
         if (wcs->m_flag == WCSSET && wcs->pv == wcs->m_pv) {
           if (!(wcs->pv = calloc(wcs->npv+2, sizeof(struct pvcard)))) {
             wcs->pv = wcs->m_pv;
@@ -975,16 +976,16 @@ int celfix(struct wcsprm *wcs)
       strcpy(wcs->ctype[wcs->lat]+5, "SFL");
 
       if (wcs->crval[wcs->lng] != 0.0 || wcs->crval[wcs->lat] != 0.0) {
-        /* In the AIPS convention, setting the reference longitude and
-         * latitude for GLS does not create an oblique graticule.  A non-zero
-         * reference longitude introduces an offset in longitude in the normal
-         * way, whereas a non-zero reference latitude simply translates the
-         * reference point (i.e. the map as a whole) to that latitude.  This
-         * might be effected by adjusting CRPIXja but that is complicated by
-         * the linear transformation and instead is accomplished here by
-         * setting theta_0. */
+        // In the AIPS convention, setting the reference longitude and
+        // latitude for GLS does not create an oblique graticule.  A non-zero
+        // reference longitude introduces an offset in longitude in the normal
+        // way, whereas a non-zero reference latitude simply translates the
+        // reference point (i.e. the map as a whole) to that latitude.  This
+        // might be effected by adjusting CRPIXja but that is complicated by
+        // the linear transformation and instead is accomplished here by
+        // setting theta_0.
         if (wcs->npvmax < wcs->npv + 3) {
-          /* Allocate space for three more PVi_ma keyvalues. */
+          // Allocate space for three more PVi_ma keyvalues.
           if (wcs->m_flag == WCSSET && wcs->pv == wcs->m_pv) {
             if (!(wcs->pv = calloc(wcs->npv+3, sizeof(struct pvcard)))) {
               wcs->pv = wcs->m_pv;
@@ -1011,7 +1012,7 @@ int celfix(struct wcsprm *wcs)
         wcs->pv[wcs->npv].value = 1.0;
         (wcs->npv)++;
 
-        /* Note that the reference longitude is still zero. */
+        // Note that the reference longitude is still zero.
         wcs->pv[wcs->npv].i = wcs->lng + 1;
         wcs->pv[wcs->npv].m = 1;
         wcs->pv[wcs->npv].value = 0.0;
@@ -1030,7 +1031,7 @@ int celfix(struct wcsprm *wcs)
   return FIXERR_NO_CHANGE;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int cylfix(const int naxis[], struct wcsprm *wcs)
 
@@ -1047,17 +1048,17 @@ int cylfix(const int naxis[], struct wcs
   if (wcs == 0x0) return FIXERR_NULL_POINTER;
   err = &(wcs->err);
 
-  /* Initialize if required. */
+  // Initialize if required.
   if (wcs->flag != WCSSET) {
     if ((status = wcsset(wcs))) return fix_wcserr[status];
   }
 
-  /* Check that we have a cylindrical projection. */
+  // Check that we have a cylindrical projection.
   if (wcs->cel.prj.category != CYLINDRICAL) return FIXERR_NO_CHANGE;
   if (wcs->naxis < 2) return FIXERR_NO_CHANGE;
 
 
-  /* Compute the native longitude in each corner of the image. */
+  // Compute the native longitude in each corner of the image.
   ncnr = 1 << wcs->naxis;
 
   for (k = 0; k < NMAX; k++) {
@@ -1067,7 +1068,7 @@ int cylfix(const int naxis[], struct wcs
   phimin =  1.0e99;
   phimax = -1.0e99;
   for (icnr = 0; icnr < ncnr;) {
-    /* Do four corners at a time. */
+    // Do four corners at a time.
     for (j = 0; j < 4; j++, icnr++) {
       pixj = pix[j];
 
@@ -1091,11 +1092,11 @@ int cylfix(const int naxis[], struct wcs
 
   if (phimin > phimax) return fix_wcserr[status];
 
-  /* Any changes needed? */
+  // Any changes needed?
   if (phimin >= -180.0 && phimax <= 180.0) return FIXERR_NO_CHANGE;
 
 
-  /* Compute the new reference pixel coordinates. */
+  // Compute the new reference pixel coordinates.
   phi0 = (phimin + phimax) / 2.0;
   theta0 = 0.0;
 
@@ -1120,13 +1121,13 @@ int cylfix(const int naxis[], struct wcs
   }
 
 
-  /* Compute celestial coordinates at the new reference pixel. */
+  // Compute celestial coordinates at the new reference pixel.
   if ((status = wcsp2s(wcs, 1, 0, pix[0], img[0], phi, theta, world[0],
                        stat))) {
     return fix_wcserr[status];
   }
 
-  /* Compute native coordinates of the celestial pole. */
+  // Compute native coordinates of the celestial pole.
   lng =  0.0;
   lat = 90.0;
   (void)sphs2x(wcs->cel.euler, 1, 1, 1, 1, &lng, &lat, phi, theta);
Index: astropy-4.2/cextern/wcslib/C/wcsfix.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsfix.h
+++ astropy-4.2/cextern/wcslib/C/wcsfix.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsfix.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsfix.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -92,18 +89,17 @@
 *   header parser supplied with WCSLIB, refer to wcshdr.h.
 *
 * wcsfix() and wcsfixi() apply all of the corrections handled by the following
-* specific functions which may also be invoked separately:
+* specific functions, which may also be invoked separately:
 *
 *   - cdfix(): Sets the diagonal element of the CDi_ja matrix to 1.0 if all
 *     CDi_ja keywords associated with a particular axis are omitted.
 *
 *   - datfix(): recast an older DATE-OBS date format in dateobs to year-2000
-*     standard form.
-*
-*     Derive dateref from mjdref if not already set.  Alternatively, if
-*     dateref is set and mjdref isn't, then derive mjdref from it.  If both
-*     are set, then check consistency.  Likewise for dateobs and mjdobs;
-*     datebeg and mjdbeg; dateavg and mjdavg; and dateend and mjdend.
+*     standard form.  Derive dateref from mjdref if not already set.
+*     Alternatively, if dateref is set and mjdref isn't, then derive mjdref
+*     from it.  If both are set, then check consistency.  Likewise for dateobs
+*     and mjdobs; datebeg and mjdbeg; dateavg and mjdavg; and dateend and
+*     mjdend.
 *
 *   - obsfix(): if only one half of obsgeo[] is set, then derive the other
 *     half from it.  If both halves are set, then check consistency.
@@ -173,7 +169,7 @@
 * cdfix() - Fix erroneously omitted CDi_ja keywords
 * -------------------------------------------------
 * cdfix() sets the diagonal element of the CDi_ja matrix to unity if all
-* CDi_ja keywords associated with a given axis were omitted.  According to
+* CDi_ja keywords associated with a given axis were omitted.  According to WCS
 * Paper I, if any CDi_ja keywords at all are given in a FITS header then those
 * not given default to zero.  This results in a singular matrix with an
 * intersecting row and column of zeros.
@@ -192,14 +188,13 @@
 * datfix() - Translate DATE-OBS and derive MJD-OBS or vice versa
 * --------------------------------------------------------------
 * datfix() translates the old DATE-OBS date format set in wcsprm::dateobs to
-* year-2000 standard form (yyyy-mm-ddThh:mm:ss).
-*
-* datfix() derives wcsprm::dateref from wcsprm::mjdref if not already set.
-* Alternatively, if dateref is set and mjdref isn't, then it derives mjdref
-* from it.  If both are set but disagree by more than 0.001 day (86.4 seconds)
-* then status 5 is returned.  Likewise for wcsprm::dateobs and wcsprm::mjdobs;
-* wcsprm::datebeg and wcsprm::mjdbeg; wcsprm::dateavg and wcsprm::mjdavg; and
-* wcsprm::dateend and wcsprm::mjdend.
+* year-2000 standard form (yyyy-mm-ddThh:mm:ss).  It derives wcsprm::dateref
+* from wcsprm::mjdref if not already set.  Alternatively, if dateref is set
+* and mjdref isn't, then it derives mjdref from it.  If both are set but
+* disagree by more than 0.001 day (86.4 seconds) then an error status is
+* returned.  Likewise for wcsprm::dateobs and wcsprm::mjdobs; wcsprm::datebeg
+* and wcsprm::mjdbeg; wcsprm::dateavg and wcsprm::mjdavg; and wcsprm::dateend
+* and wcsprm::mjdend.
 *
 * If neither dateobs nor mjdobs are set, but wcsprm::jepoch (primarily) or
 * wcsprm::bepoch is, then both are derived from it.  If jepoch and/or bepoch
@@ -222,13 +217,15 @@
 *                         1: Null wcsprm pointer passed.
 *                         5: Invalid parameter value.
 *
-*                       For returns > 1, a detailed error message is set in
-*                       wcsprm::err if enabled, see wcserr_enable().
+*                       For returns >= 0, a detailed message, whether
+*                       informative or an error message, may be set in
+*                       wcsprm::err if enabled, see wcserr_enable(), with
+*                       wcsprm::err.status set to FIXERR_DATE_FIX.
 *
 * Notes:
-*   The MJD algorithms used by datfix() are from D.A. Hatcher, 1984, QJRAS,
-*   25, 53-55, as modified by P.T. Wallace for use in SLALIB subroutines CLDJ
-*   and DJCL.
+*   1: The MJD algorithms used by datfix() are from D.A. Hatcher, 1984, QJRAS,
+*      25, 53-55, as modified by P.T. Wallace for use in SLALIB subroutines
+*      CLDJ and DJCL.
 *
 *
 * obsfix() - complete the OBSGEO-[XYZLBH] vector of observatory coordinates
@@ -261,8 +258,10 @@
 *                         1: Null wcsprm pointer passed.
 *                         5: Invalid parameter value.
 *
-*                       For returns > 1, a detailed error message is set in
-*                       wcsprm::err if enabled, see wcserr_enable().
+*                       For returns >= 0, a detailed message, whether
+*                       informative or an error message, may be set in
+*                       wcsprm::err if enabled, see wcserr_enable(), with
+*                       wcsprm::err.status set to FIXERR_OBS_FIX.
 *
 * Notes:
 *   1: While the International Terrestrial Reference System (ITRS) is based
@@ -332,9 +331,10 @@
 *                         0: Success (an alias was applied).
 *                         1: Null wcsprm pointer passed.
 *
-*                       When units are translated (i.e. status 0), status -2
-*                       is set in the wcserr struct to allow an informative
-*                       message to be returned.
+*                       When units are translated (i.e. 0 is returned), an
+*                       informative message is set in wcsprm::err if enabled,
+*                       see wcserr_enable(), with wcsprm::err.status set to
+*                       FIXERR_UNITS_ALIAS.
 *
 *
 * spcfix() - Translate AIPS-convention spectral types
@@ -364,8 +364,10 @@
 *                         7: Ill-conditioned coordinate transformation
 *                            parameters.
 *
-*                       For returns > 1, a detailed error message is set in
-*                       wcsprm::err if enabled, see wcserr_enable().
+*                       For returns >= 0, a detailed message, whether
+*                       informative or an error message, may be set in
+*                       wcsprm::err if enabled, see wcserr_enable(), with
+*                       wcsprm::err.status set to FIXERR_SPC_UPDTE.
 *
 *
 * celfix() - Translate AIPS-convention celestial projection types
@@ -465,29 +467,27 @@ extern const char *wcsfix_errmsg[];
 #define cylfix_errmsg wcsfix_errmsg
 
 enum wcsfix_errmsg_enum {
-  FIXERR_OBSGEO_FIX       = -5, /* Observatory coordinates amended. */
-  FIXERR_DATE_FIX         = -4, /* Date string reformatted. */
-  FIXERR_SPC_UPDATE       = -3, /* Spectral axis type modified. */
-  FIXERR_UNITS_ALIAS      = -2,	/* Units alias translation. */
-  FIXERR_NO_CHANGE        = -1,	/* No change. */
-  FIXERR_SUCCESS          =  0,	/* Success. */
-  FIXERR_NULL_POINTER     =  1,	/* Null wcsprm pointer passed. */
-  FIXERR_MEMORY           =  2,	/* Memory allocation failed. */
-  FIXERR_SINGULAR_MTX     =  3,	/* Linear transformation matrix is
-				   singular. */
-  FIXERR_BAD_CTYPE        =  4,	/* Inconsistent or unrecognized coordinate
-				   axis types. */
-  FIXERR_BAD_PARAM        =  5,	/* Invalid parameter value. */
-  FIXERR_BAD_COORD_TRANS  =  6,	/* Invalid coordinate transformation
-				   parameters. */
-  FIXERR_ILL_COORD_TRANS  =  7,	/* Ill-conditioned coordinate transformation
-				   parameters. */
-  FIXERR_BAD_CORNER_PIX   =  8,	/* All of the corner pixel coordinates are
-				   invalid. */
-  FIXERR_NO_REF_PIX_COORD =  9,	/* Could not determine reference pixel
-				   coordinate. */
-  FIXERR_NO_REF_PIX_VAL   = 10	/* Could not determine reference pixel
-				   value. */
+  FIXERR_OBSGEO_FIX       = -5, // Observatory coordinates amended.
+  FIXERR_DATE_FIX         = -4, // Date string reformatted.
+  FIXERR_SPC_UPDATE       = -3, // Spectral axis type modified.
+  FIXERR_UNITS_ALIAS      = -2,	// Units alias translation.
+  FIXERR_NO_CHANGE        = -1,	// No change.
+  FIXERR_SUCCESS          =  0,	// Success.
+  FIXERR_NULL_POINTER     =  1,	// Null wcsprm pointer passed.
+  FIXERR_MEMORY           =  2,	// Memory allocation failed.
+  FIXERR_SINGULAR_MTX     =  3,	// Linear transformation matrix is singular.
+  FIXERR_BAD_CTYPE        =  4,	// Inconsistent or unrecognized coordinate
+				// axis types.
+  FIXERR_BAD_PARAM        =  5,	// Invalid parameter value.
+  FIXERR_BAD_COORD_TRANS  =  6,	// Invalid coordinate transformation
+				// parameters.
+  FIXERR_ILL_COORD_TRANS  =  7,	// Ill-conditioned coordinate transformation
+				// parameters.
+  FIXERR_BAD_CORNER_PIX   =  8,	// All of the corner pixel coordinates are
+				// invalid.
+  FIXERR_NO_REF_PIX_COORD =  9,	// Could not determine reference pixel
+				// coordinate.
+  FIXERR_NO_REF_PIX_VAL   = 10	// Could not determine reference pixel value.
 };
 
 int wcsfix(int ctrl, const int naxis[], struct wcsprm *wcs, int stat[]);
@@ -514,4 +514,4 @@ int cylfix(const int naxis[], struct wcs
 }
 #endif
 
-#endif /* WCSLIB_WCSFIX */
+#endif // WCSLIB_WCSFIX
Index: astropy-4.2/cextern/wcslib/C/wcshdr.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcshdr.c
+++ astropy-4.2/cextern/wcslib/C/wcshdr.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcshdr.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcshdr.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <ctype.h>
@@ -44,7 +41,7 @@ extern const int WCSSET;
 
 extern const int DIS_DOTPD;
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *wcshdr_errmsg[] = {
   "Success",
   "Null wcsprm pointer passed",
@@ -53,27 +50,27 @@ const char *wcshdr_errmsg[] = {
   "Fatal error returned by Flex parser",
   "Invalid tabular parameters"};
 
-/* Map error returns for lower-level routines. */
+// Map error returns for lower-level routines.
 const int wcshdr_taberr[] = {
-  WCSHDRERR_SUCCESS,		/*  0: TABERR_SUCCESS         */
-  WCSHDRERR_NULL_POINTER,	/*  1: TABERR_NULL_POINTER    */
-  WCSHDRERR_MEMORY,		/*  2: TABERR_MEMORY          */
-  WCSHDRERR_BAD_TABULAR_PARAMS	/*  3: TABERR_BAD_PARAMS      */
-				/*  4: TABERR_BAD_X           */
-				/*  5: TABERR_BAD_WORLD       */
+  WCSHDRERR_SUCCESS,		//  0: TABERR_SUCCESS
+  WCSHDRERR_NULL_POINTER,	//  1: TABERR_NULL_POINTER
+  WCSHDRERR_MEMORY,		//  2: TABERR_MEMORY
+  WCSHDRERR_BAD_TABULAR_PARAMS	//  3: TABERR_BAD_PARAMS
+				//  4: TABERR_BAD_X
+				//  5: TABERR_BAD_WORLD
 };
 
-/* Convenience macro for invoking wcserr_set(). */
+// Convenience macro for invoking wcserr_set().
 #define WCSHDR_ERRMSG(status) WCSERR_SET(status), wcshdr_errmsg[status]
 
-/* Internal helper functions, not for general use. */
+// Internal helper functions, not for general use.
 static void wcshdo_format(int, int, const double [], char *);
 static void wcshdo_tpdterm(int, int, char *);
 static void wcshdo_util(int, const char [], const char [], int, const char [],
   int, int, int, char, int, int [], char [], const char [], int *, char **,
   int *);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcstab(struct wcsprm *wcs)
 
@@ -90,7 +87,7 @@ int wcstab(struct wcsprm *wcs)
   if (wcs == 0x0) return WCSHDRERR_NULL_POINTER;
   err = &(wcs->err);
 
-  /* Free memory previously allocated by wcstab(). */
+  // Free memory previously allocated by wcstab().
   if (wcs->flag != -1 && wcs->m_flag == WCSSET) {
     if (wcs->wtb == wcs->m_wtb) wcs->wtb = 0x0;
     if (wcs->tab == wcs->m_tab) wcs->tab = 0x0;
@@ -111,7 +108,7 @@ int wcstab(struct wcsprm *wcs)
   wcs->tab  = 0x0;
 
 
-  /* Determine the number of -TAB axes. */
+  // Determine the number of -TAB axes.
   naxis = wcs->naxis;
   if (!(tabax = calloc(naxis, sizeof(int)))) {
     return wcserr_set(WCSHDR_ERRMSG(WCSHDRERR_MEMORY));
@@ -119,7 +116,7 @@ int wcstab(struct wcsprm *wcs)
 
   ntabax = 0;
   for (i = 0; i < naxis; i++) {
-    /* Null fill. */
+    // Null fill.
     wcsutil_null_fill(72, wcs->ctype[i]);
 
     if (!strcmp(wcs->ctype[i]+4, "-TAB")) {
@@ -130,13 +127,13 @@ int wcstab(struct wcsprm *wcs)
   }
 
   if (ntabax == 0) {
-    /* No lookup tables. */
+    // No lookup tables.
     status = 0;
     goto cleanup;
   }
 
 
-  /* Collect information from the PSi_ma and PVi_ma keyvalues. */
+  // Collect information from the PSi_ma and PVi_ma keyvalues.
   if (!((PSi_0a = calloc(ntabax, sizeof(char[72]))) &&
         (PVi_1a = calloc(ntabax, sizeof(int)))      &&
         (PVi_2a = calloc(ntabax, sizeof(int)))      &&
@@ -149,7 +146,7 @@ int wcstab(struct wcsprm *wcs)
   }
 
   for (itabax = 0; itabax < ntabax; itabax++) {
-    /* Remember that calloc() zeroes allocated memory. */
+    // Remember that calloc() zeroes allocated memory.
     PVi_1a[itabax] = 1;
     PVi_2a[itabax] = 1;
     PVi_3a[itabax] = 1;
@@ -160,17 +157,17 @@ int wcstab(struct wcsprm *wcs)
     if (itabax >= 0) {
       switch (wcs->ps[ip].m) {
       case 0:
-        /* EXTNAME. */
+        // EXTNAME.
         strcpy(PSi_0a[itabax], wcs->ps[ip].value);
         wcsutil_null_fill(72, PSi_0a[itabax]);
         break;
       case 1:
-        /* TTYPEn for coordinate array. */
+        // TTYPEn for coordinate array.
         strcpy(PSi_1a[itabax], wcs->ps[ip].value);
         wcsutil_null_fill(72, PSi_1a[itabax]);
         break;
       case 2:
-        /* TTYPEn for index vector. */
+        // TTYPEn for index vector.
         strcpy(PSi_2a[itabax], wcs->ps[ip].value);
         wcsutil_null_fill(72, PSi_2a[itabax]);
         break;
@@ -183,15 +180,15 @@ int wcstab(struct wcsprm *wcs)
     if (itabax >= 0) {
       switch (wcs->pv[ip].m) {
       case 1:
-        /* EXTVER. */
+        // EXTVER.
         PVi_1a[itabax] = (int)(wcs->pv[ip].value + 0.5);
         break;
       case 2:
-        /* EXTLEVEL. */
+        // EXTLEVEL.
         PVi_2a[itabax] = (int)(wcs->pv[ip].value + 0.5);
         break;
       case 3:
-        /* Table axis number. */
+        // Table axis number.
         PVi_3a[itabax] = (int)(wcs->pv[ip].value + 0.5);
         break;
       }
@@ -199,9 +196,9 @@ int wcstab(struct wcsprm *wcs)
   }
 
 
-  /* Determine the number of independent tables. */
+  // Determine the number of independent tables.
   for (itabax = 0; itabax < ntabax; itabax++) {
-    /* These have no defaults. */
+    // These have no defaults.
     if (!PSi_0a[itabax][0] || !PSi_1a[itabax][0]) {
       status = wcserr_set(WCSERR_SET(WCSHDRERR_BAD_TABULAR_PARAMS),
         "Invalid tabular parameters: PSi_0a and PSi_1a must be specified");
@@ -210,8 +207,8 @@ int wcstab(struct wcsprm *wcs)
 
     tabidx[itabax] = -1;
     for (jtabax = 0; jtabax < i; jtabax++) {
-      /* EXTNAME, EXTVER, EXTLEVEL, and TTYPEn for the coordinate array */
-      /* must match for each axis of a multi-dimensional lookup table.  */
+      // EXTNAME, EXTVER, EXTLEVEL, and TTYPEn for the coordinate array
+      // must match for each axis of a multi-dimensional lookup table.
       if (strcmp(PSi_0a[itabax], PSi_0a[jtabax]) == 0 &&
           strcmp(PSi_1a[itabax], PSi_1a[jtabax]) == 0 &&
           PVi_1a[itabax] == PVi_1a[jtabax] &&
@@ -233,11 +230,11 @@ int wcstab(struct wcsprm *wcs)
   }
   wcs->m_tab = wcs->tab;
 
-  /* Table dimensionality; find the largest axis number. */
+  // Table dimensionality; find the largest axis number.
   for (itabax = 0; itabax < ntabax; itabax++) {
     tabp = wcs->tab + tabidx[itabax];
 
-    /* PVi_3a records the 1-relative table axis number. */
+    // PVi_3a records the 1-relative table axis number.
     if (PVi_3a[itabax] > tabp->M) {
       tabp->M = PVi_3a[itabax];
     }
@@ -251,14 +248,14 @@ int wcstab(struct wcsprm *wcs)
   }
 
 
-  /* Copy parameters into the tabprm structs. */
+  // Copy parameters into the tabprm structs.
   for (i = 0; i < naxis; i++) {
     if ((itabax = tabax[i]) < 0) {
-      /* Not a -TAB axis. */
+      // Not a -TAB axis.
       continue;
     }
 
-    /* PVi_3a records the 1-relative table axis number. */
+    // PVi_3a records the 1-relative table axis number.
     m = PVi_3a[itabax] - 1;
 
     tabp = wcs->tab + tabidx[itabax];
@@ -266,7 +263,7 @@ int wcstab(struct wcsprm *wcs)
     tabp->crval[m] = wcs->crval[i];
   }
 
-  /* Check for completeness. */
+  // Check for completeness.
   for (itab = 0; itab < wcs->ntab; itab++) {
     for (m = 0; m < wcs->tab[itab].M; m++) {
       if (wcs->tab[itab].map[m] < 0) {
@@ -278,18 +275,18 @@ int wcstab(struct wcsprm *wcs)
   }
 
 
-  /* Set up for reading the arrays; how many arrays are there? */
+  // Set up for reading the arrays; how many arrays are there?
   for (itabax = 0; itabax < ntabax; itabax++) {
-    /* Does this -TAB axis have a non-degenerate index array? */
+    // Does this -TAB axis have a non-degenerate index array?
     if (PSi_2a[itabax][0]) {
       wcs->nwtb++;
     }
   }
 
-  /* Add one coordinate array for each table. */
+  // Add one coordinate array for each table.
   wcs->nwtb += wcs->ntab;
 
-  /* Allocate memory for structs to be returned. */
+  // Allocate memory for structs to be returned.
   if (!(wcs->wtb = calloc(wcs->nwtb, sizeof(struct wtbarr)))) {
     wcs->nwtb = 0;
 
@@ -298,7 +295,7 @@ int wcstab(struct wcsprm *wcs)
   }
   wcs->m_wtb = wcs->wtb;
 
-  /* Set pointers for the index and coordinate arrays. */
+  // Set pointers for the index and coordinate arrays.
   wtbp = wcs->wtb;
   for (itab = 0; itab < wcs->ntab; itab++) {
     getcrd = 1;
@@ -306,7 +303,7 @@ int wcstab(struct wcsprm *wcs)
       if (tabidx[itabax] != itab) continue;
 
       if (getcrd) {
-        /* Coordinate array. */
+        // Coordinate array.
         wtbp->i = itabax + 1;
         wtbp->m = PVi_3a[itabax];
         wtbp->kind = 'c';
@@ -320,7 +317,7 @@ int wcstab(struct wcsprm *wcs)
         wtbp->dimlen = wcs->tab[itab].K;
         wtbp->arrayp = &(wcs->tab[itab].coord);
 
-        /* Signal for tabset() to take this memory. */
+        // Signal for tabset() to take this memory.
         wcs->tab[itab].m_coord = (double *)0x1;
 
         wtbp++;
@@ -328,7 +325,7 @@ int wcstab(struct wcsprm *wcs)
       }
 
       if (PSi_2a[itabax][0]) {
-        /* Index array. */
+        // Index array.
         wtbp->i = itabax + 1;
         wtbp->m = PVi_3a[itabax];
         wtbp->kind = 'i';
@@ -343,7 +340,7 @@ int wcstab(struct wcsprm *wcs)
         wtbp->dimlen = wcs->tab[itab].K + m;
         wtbp->arrayp = wcs->tab[itab].index + m;
 
-        /* Signal for tabset() to take this memory. */
+        // Signal for tabset() to take this memory.
         wcs->tab[itab].m_indxs[m] = (double *)0x1;
 
         wtbp++;
@@ -371,7 +368,7 @@ cleanup:
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsidx(int nwcs, struct wcsprm **wcs, int alts[27])
 
@@ -403,7 +400,7 @@ int wcsidx(int nwcs, struct wcsprm **wcs
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsbdx(int nwcs, struct wcsprm **wcs, int type, short alts[1000][28])
 
@@ -433,7 +430,7 @@ int wcsbdx(int nwcs, struct wcsprm **wcs
     }
 
     if (type) {
-      /* Pixel list. */
+      // Pixel list.
       if (wcsp->colax[0]) {
         for (i = 0; i < wcsp->naxis; i++) {
           alts[wcsp->colax[i]][a]  = iwcs;
@@ -445,7 +442,7 @@ int wcsbdx(int nwcs, struct wcsprm **wcs
       }
 
     } else {
-      /* Binary table image array. */
+      // Binary table image array.
       if (wcsp->colnum) {
         alts[wcsp->colnum][a] = iwcs;
         alts[wcsp->colnum][27]++;
@@ -459,7 +456,7 @@ int wcsbdx(int nwcs, struct wcsprm **wcs
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsvfree(int *nwcs, struct wcsprm **wcs)
 
@@ -484,19 +481,19 @@ int wcsvfree(int *nwcs, struct wcsprm **
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
-#define I_DTYPE   0	/* Distortion type code.                            */
-#define I_NIPARM  1	/* Full (allocated) length of iparm[].              */
-#define I_NDPARM  2	/* No. of parameters in dparm[], excl. work space.  */
-#define I_DOCORR  3	/* True if distortion func computes a correction.   */
-#define I_TPDNCO  4	/* No. of TPD coefficients, forward...              */
-#define I_TPDINV  5	/* ...and inverse.                                  */
-#define I_TPDAUX  6	/* True if auxiliary variables are used.            */
-#define I_TPDRAD  7	/* True if the radial variable is used.             */
+//----------------------------------------------------------------------------
+// Matching the definitions in dis.c.
+#define I_DTYPE   0	// Distortion type code.
+#define I_NIPARM  1	// Full (allocated) length of iparm[].
+#define I_NDPARM  2	// No. of parameters in dparm[], excl. work space.
+#define I_TPDNCO  3	// No. of TPD coefficients, forward...
+#define I_TPDINV  4	// ...and inverse.
+#define I_TPDAUX  5	// True if auxiliary variables are used.
+#define I_TPDRAD  6	// True if the radial variable is used.
 
 int wcshdo(int ctrl, struct wcsprm *wcs, int *nkeyrec, char **header)
 
-/* ::: CUBEFACE and STOKES handling? */
+// ::: CUBEFACE and STOKES handling?
 
 {
   static const char *function = "wcshdo";
@@ -532,7 +529,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   }
 
 
-  /* These are mainly for convenience. */
+  // These are mainly for convenience.
   alt = wcs->alt[0];
   if (alt == ' ') alt = '\0';
   colnum = wcs->colnum;
@@ -550,7 +547,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   }
 
 
-  /* Initialize floating point format control. */
+  // Initialize floating point format control.
   *format = '\0';
   if (ctrl & WCSHDO_P17) {
     strcpy(format, "% 20.17G");
@@ -577,14 +574,14 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   dofmt = (*format == '\0');
 
 
-  /* WCS dimension. */
+  // WCS dimension.
   if (!pixlist) {
     sprintf(keyvalue, "%20d", naxis);
     wcshdo_util(ctrl, "WCSAXES", "WCAX", 0, 0x0, 0, 0, 0, alt, colnum, colax,
       keyvalue, "Number of coordinate axes", nkeyrec, header, &status);
   }
 
-  /* Reference pixel coordinates. */
+  // Reference pixel coordinates.
   if (dofmt) wcshdo_format('G', naxis, wcs->crpix, format);
   for (j = 0; j < naxis; j++) {
     wcsutil_double2str(keyvalue, format, wcs->crpix[j]);
@@ -593,7 +590,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       header, &status);
   }
 
-  /* Linear transformation matrix. */
+  // Linear transformation matrix.
   if (dofmt) wcshdo_format('G', naxis*naxis, wcs->pc, format);
   k = 0;
   for (i = 0; i < naxis; i++) {
@@ -612,7 +609,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Coordinate increment at reference point. */
+  // Coordinate increment at reference point.
   if (dofmt) wcshdo_format('G', naxis, wcs->cdelt, format);
   for (i = 0; i < naxis; i++) {
     wcsutil_double2str(keyvalue, format, wcs->cdelt[i]);
@@ -623,7 +620,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       colnum, colax, keyvalue, comment, nkeyrec, header, &status);
   }
 
-  /* Units of coordinate increment and reference value. */
+  // Units of coordinate increment and reference value.
   for (i = 0; i < naxis; i++) {
     if (wcs->cunit[i][0] == '\0') continue;
 
@@ -633,9 +630,9 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* May need to alter ctype for particular distortions so do basic checks */
-  /* now.  Note that SIP, TPV, DSS, TNX, and ZPX are restricted to exactly */
-  /* two axes and cannot coexist with other distortion types.              */
+  // May need to alter ctype for particular distortions so do basic checks
+  // now.  Note that SIP, TPV, DSS, TNX, and ZPX are restricted to exactly
+  // two axes and cannot coexist with other distortion types.
   dosip = 0;
   dotpv = 0;
   dotpd = 0;
@@ -643,8 +640,8 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   if ((dis = wcs->lin.dispre)) {
     for (i = 0; i < naxis; i++) {
       if (strcmp(dis->dtype[i], "SIP") == 0) {
-        /* Simple Imaging Polynomial (SIP).  Write it in its native form  */
-        /* if possible, unless specifically requested to write it as TPD. */
+        // Simple Imaging Polynomial (SIP).  Write it in its native form
+        // if possible, unless specifically requested to write it as TPD.
         dotpd = (dis->iparm[i][I_DTYPE] & DIS_DOTPD);
 
         if (!dotpd) {;
@@ -663,13 +660,13 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
               dis->scale[0][1]  != 1.0 ||
               dis->scale[1][0]  != 1.0 ||
               dis->scale[1][1]  != 1.0) {
-            /* Must have been read as a 'SIP' distortion, CPDISja = 'SIP'. */
-            /* Cannot be written as native SIP so write it as TPD.         */
+            // Must have been read as a 'SIP' distortion, CPDISja = 'SIP'.
+            // Cannot be written as native SIP so write it as TPD.
             dotpd = DIS_DOTPD;
           } else if (strncmp(wcs->ctype[0], "RA---TAN", 8) ||
                      strncmp(wcs->ctype[1], "DEC--TAN", 8)) {
-            /* Must have been permuted by wcssub(). */
-            /* Native SIP doesn't have axis mapping so write it as TPD. */
+            // Must have been permuted by wcssub().
+            // Native SIP doesn't have axis mapping so write it as TPD.
             dotpd = DIS_DOTPD;
           }
 
@@ -688,8 +685,8 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   if ((dis = wcs->lin.disseq)) {
     for (i = 0; i < naxis; i++) {
       if (strcmp(dis->dtype[i], "TPV") == 0) {
-        /* TPV "projection".  Write it in its native form if possible, */
-        /* unless specifically requested to write it as TPD.           */
+        // TPV "projection".  Write it in its native form if possible,
+        // unless specifically requested to write it as TPD.
         dotpd = (dis->iparm[i][I_DTYPE] & DIS_DOTPD);
 
         if (!dotpd) {;
@@ -705,8 +702,8 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
               dis->scale[wcs->lng][wcs->lat]  != 1.0 ||
               dis->scale[wcs->lat][wcs->lng]  != 1.0 ||
               dis->scale[wcs->lat][wcs->lat]  != 1.0) {
-            /* Must have been read as a 'TPV' distortion, CPDISja = 'TPV'. */
-            /* Cannot be written as native TPV so write it as TPD.         */
+            // Must have been read as a 'TPV' distortion, CPDISja = 'TPV'.
+            // Cannot be written as native TPV so write it as TPD.
             dotpd = DIS_DOTPD;
           }
 
@@ -720,12 +717,12 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
         break;
 
       } else if (strcmp(dis->dtype[i], "DSS") == 0) {
-        /* Always written as TPD. */
+        // Always written as TPD.
         dotpd = DIS_DOTPD;
         strcpy(tpdsrc, dis->dtype[i]);
 
       } else if (strncmp(dis->dtype[i], "WAT", 3) == 0) {
-        /* Always written as TPD. */
+        // Always written as TPD.
         dotpd = DIS_DOTPD;
         strcpy(tpdsrc, dis->dtype[i]+4);
 
@@ -740,7 +737,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Coordinate type. */
+  // Coordinate type.
   for (i = 0; i < naxis; i++) {
     if (wcs->ctype[i][0] == '\0') continue;
 
@@ -749,12 +746,12 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
 
     ctypei = keyvalue + 1;
     if (i == wcs->lng || i == wcs->lat) {
-      /* Alter ctype for particular distortions. */
+      // Alter ctype for particular distortions.
       if (dosip) {
-        /* It could have come in as CPDISja = 'SIP'. */
+        // It could have come in as CPDISja = 'SIP'.
         strcpy(ctypei+8, "-SIP'");
       } else if (dotpv) {
-        /* Reinstate projection code edited by wcsset(). */
+        // Reinstate projection code edited by wcsset().
         strcpy(ctypei+4, "-TPV'");
       }
 
@@ -824,7 +821,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       colnum, colax, keyvalue, comment, nkeyrec, header, &status);
   }
 
-  /* Coordinate value at reference point. */
+  // Coordinate value at reference point.
   for (i = 0; i < naxis; i++) {
     if (dofmt) wcshdo_format('G', 1, wcs->crval+i, format);
     wcsutil_double2str(keyvalue, format, wcs->crval[i]);
@@ -835,7 +832,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       colnum, colax, keyvalue, comment, nkeyrec, header, &status);
   }
 
-  /* Parameter values. */
+  // Parameter values.
   if (dofmt) strcpy(format, "%20.12G");
   for (k = 0; k < wcs->npv; k++) {
     wcsutil_double2str(keyvalue, format, (wcs->pv[k]).value);
@@ -887,7 +884,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* Celestial and spectral transformation parameters. */
+  // Celestial and spectral transformation parameters.
   if (!undefined(wcs->lonpole)) {
     wcsutil_double2str(keyvalue, format, wcs->lonpole);
     wcshdo_util(ctrl, "LONPOLE", "LONP", 0, 0x0, 0, 0, 0, alt,
@@ -916,10 +913,10 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* - - - - - - - - - - - - - - - - Auxiliary coordinate axis information. */
+  // - - - - - - - - - - - - - - - - -  Auxiliary coordinate axis information.
   sprintf(timeunit, "%.15s", wcs->timeunit[0] ? wcs->timeunit : "s");
 
-  /* Coordinate axis title. */
+  // Coordinate axis title.
   if (wcs->cname) {
     for (i = 0; i < naxis; i++) {
       if (wcs->cname[i][0] == '\0') continue;
@@ -931,7 +928,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Random error in coordinate. */
+  // Random error in coordinate.
   if (wcs->crder) {
     for (i = 0; i < naxis; i++) {
       if (undefined(wcs->crder[i])) continue;
@@ -945,7 +942,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Systematic error in coordinate. */
+  // Systematic error in coordinate.
   if (wcs->csyer) {
     for (i = 0; i < naxis; i++) {
       if (undefined(wcs->csyer[i])) continue;
@@ -959,7 +956,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Time at zero point of phase axis. */
+  // Time at zero point of phase axis.
   if (wcs->czphs) {
     for (i = 0; i < naxis; i++) {
       if (undefined(wcs->czphs[i])) continue;
@@ -971,7 +968,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Period of phase axis. */
+  // Period of phase axis.
   if (wcs->cperi) {
     for (i = 0; i < naxis; i++) {
       if (undefined(wcs->cperi[i])) continue;
@@ -983,9 +980,9 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* - - - - - - - - - - - - - - - - - - - - - -  Coordinate system title.  */
+  // - - - - - - - - - - - - - - - - - - - - - - - -  Coordinate system title.
 
-  /* Coordinate system title. */
+  // Coordinate system title.
   if (wcs->wcsname[0]) {
     sprintf(keyvalue, "'%s'", wcs->wcsname);
     if (bintab) {
@@ -993,59 +990,59 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
         colnum, colax, keyvalue, "Coordinate system title",
         nkeyrec, header, &status);
     } else {
-      /* TWCS was a mistake. */
+      // TWCS was a mistake.
       wcshdo_util(ctrl, "WCSNAME", "TWCS", WCSHDO_WCSNna, "WCSN", 0, 0, 0,
         alt, colnum, colax, keyvalue, "Coordinate system title",
         nkeyrec, header, &status);
     }
   }
 
-  /* - - - - - - - - - - - - - - - - Time reference system and measurement. */
+  // - - - - - - - - - - - - - - - - -  Time reference system and measurement.
 
-  /* Time scale. */
+  // Time scale.
   if (wcs->timesys[0]) {
     sprintf(keyvalue, "'%s'", wcs->timesys);
     wcshdo_util(ctrl, "TIMESYS", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Time scale", nkeyrec, header, &status);
   }
 
-  /* Time reference position. */
+  // Time reference position.
   if (wcs->trefpos[0]) {
     sprintf(keyvalue, "'%s'", wcs->trefpos);
     wcshdo_util(ctrl, "TREFPOS", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Time reference position", nkeyrec, header, &status);
   }
 
-  /* Time reference direction. */
+  // Time reference direction.
   if (wcs->trefdir[0]) {
     sprintf(keyvalue, "'%s'", wcs->trefdir);
     wcshdo_util(ctrl, "TREFDIR", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Time reference direction", nkeyrec, header, &status);
   }
 
-  /* Ephemerides used for pathlength delay calculation. */
+  // Ephemerides used for pathlength delay calculation.
   if (wcs->plephem[0]) {
     sprintf(keyvalue, "'%s'", wcs->plephem);
     wcshdo_util(ctrl, "PLEPHEM", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Ephemerides used for pathlength delays", nkeyrec, header, &status);
   }
 
-  /* Time units. */
+  // Time units.
   if (wcs->timeunit[0]) {
     sprintf(keyvalue, "'%s'", wcs->timeunit);
     wcshdo_util(ctrl, "TIMEUNIT", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Time units", nkeyrec, header, &status);
   }
 
-  /* Fiducial (reference) time. */
+  // Fiducial (reference) time.
   if (wcs->mjdref[0] == 0.0 && wcs->mjdref[1] == 0.0) {
-    /* MJD of fiducial time (simplified if it takes its default value). */
+    // MJD of fiducial time (simplified if it takes its default value).
     wcsutil_double2str(keyvalue, format, 0.0);
     wcshdo_util(ctrl, "MJDREF", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "[d] MJD of fiducial time", nkeyrec, header, &status);
 
   } else {
-    /* ISO-8601 fiducial time. */
+    // ISO-8601 fiducial time.
     if (wcs->dateref[0]) {
       sprintf(keyvalue, "'%s'", wcs->dateref);
       wcshdo_util(ctrl, "DATEREF", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0,
@@ -1053,7 +1050,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
 
     if (wcs->mjdref[1] == 0.0) {
-      /* MJD of fiducial time (no fractional part). */
+      // MJD of fiducial time (no fractional part).
       if (!undefined(wcs->mjdref[0])) {
         wcsutil_double2str(keyvalue, format, wcs->mjdref[0]);
         wcshdo_util(ctrl, "MJDREF", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0,
@@ -1061,7 +1058,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       }
 
     } else {
-      /* MJD of fiducial time, integer part. */
+      // MJD of fiducial time, integer part.
       if (!undefined(wcs->mjdref[0])) {
         wcsutil_double2str(keyvalue, format, wcs->mjdref[0]);
         wcshdo_util(ctrl, "MJDREFI", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0,
@@ -1069,7 +1066,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           header, &status);
       }
 
-      /* MJD of fiducial time, fractional part. */
+      // MJD of fiducial time, fractional part.
       if (!undefined(wcs->mjdref[1])) {
         wcsutil_double2str(keyvalue, format, wcs->mjdref[1]);
         wcshdo_util(ctrl, "MJDREFF", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0,
@@ -1079,7 +1076,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* Clock correction. */
+  // Clock correction.
   if (!undefined(wcs->timeoffs)) {
     wcsutil_double2str(keyvalue, format, wcs->timeoffs);
     sprintf(comment, "[%s] Clock correction", timeunit);
@@ -1087,25 +1084,25 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* - - - - - - - - - - - - - - - - - - - - Data timestamps and durations. */
+  // - - - - - - - - - - - - - - - - - - - - -  Data timestamps and durations.
 
-  /* ISO-8601 time of observation. */
+  // ISO-8601 time of observation.
   if (wcs->dateobs[0]) {
     sprintf(keyvalue, "'%s'", wcs->dateobs);
     strcpy(comment, "ISO-8601 time of observation");
 
     if (ctrl & 1) {
-      /* Allow DOBSn. */
+      // Allow DOBSn.
       wcshdo_util(ctrl, "DATE-OBS", "DOBS", WCSHDO_DOBSn, 0x0, 0, 0, 0, ' ',
         colnum, colax, keyvalue, comment, nkeyrec, header, &status);
     } else {
-      /* Force DATE-OBS. */
+      // Force DATE-OBS.
       wcshdo_util(ctrl, "DATE-OBS", 0x0, 0, 0x0, 0, 0, 0, ' ',
         0, 0x0, keyvalue, comment, nkeyrec, header, &status);
     }
   }
 
-  /* MJD of observation. */
+  // MJD of observation.
   if (!undefined(wcs->mjdobs)) {
     wcsutil_double2str(keyvalue, format, wcs->mjdobs);
     wcshdo_util(ctrl, "MJD-OBS", "MJDOB", 0, 0x0, 0, 0, 0, ' ',
@@ -1113,35 +1110,35 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* Julian epoch of observation. */
+  // Julian epoch of observation.
   if (!undefined(wcs->jepoch)) {
     wcsutil_double2str(keyvalue, format, wcs->jepoch);
     wcshdo_util(ctrl, "JEPOCH", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "[a] Julian epoch of observation", nkeyrec, header, &status);
   }
 
-  /* Besselian epoch of observation. */
+  // Besselian epoch of observation.
   if (!undefined(wcs->bepoch)) {
     wcsutil_double2str(keyvalue, format, wcs->bepoch);
     wcshdo_util(ctrl, "BEPOCH", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "[a] Besselian epoch of observation", nkeyrec, header, &status);
   }
 
-  /* ISO-8601 time at start of observation. */
+  // ISO-8601 time at start of observation.
   if (wcs->datebeg[0]) {
     sprintf(keyvalue, "'%s'", wcs->datebeg);
     wcshdo_util(ctrl, "DATE-BEG", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "ISO-8601 time at start of observation", nkeyrec, header, &status);
   }
 
-  /* MJD at start of observation. */
+  // MJD at start of observation.
   if (!undefined(wcs->mjdbeg)) {
     wcsutil_double2str(keyvalue, format, wcs->mjdbeg);
     wcshdo_util(ctrl, "MJD-BEG", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "[d] MJD at start of observation", nkeyrec, header, &status);
   }
 
-  /* Time elapsed at start since fiducial time. */
+  // Time elapsed at start since fiducial time.
   if (!undefined(wcs->tstart)) {
     wcsutil_double2str(keyvalue, format, wcs->tstart);
     sprintf(comment, "[%s] Time elapsed since fiducial time at start",
@@ -1150,7 +1147,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* ISO-8601 time at midpoint of observation. */
+  // ISO-8601 time at midpoint of observation.
   if (wcs->dateavg[0]) {
     sprintf(keyvalue, "'%s'", wcs->dateavg);
     wcshdo_util(ctrl, "DATE-AVG", "DAVG", 0, 0x0, 0, 0, 0, ' ',
@@ -1158,7 +1155,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* MJD at midpoint of observation. */
+  // MJD at midpoint of observation.
   if (!undefined(wcs->mjdavg)) {
     wcsutil_double2str(keyvalue, format, wcs->mjdavg);
     wcshdo_util(ctrl, "MJD-AVG", "MJDA", 0, 0x0, 0, 0, 0, ' ',
@@ -1166,21 +1163,21 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       nkeyrec, header, &status);
   }
 
-  /* ISO-8601 time at end of observation. */
+  // ISO-8601 time at end of observation.
   if (wcs->dateend[0]) {
     sprintf(keyvalue, "'%s'", wcs->dateend);
     wcshdo_util(ctrl, "DATE-END", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "ISO-8601 time at end of observation", nkeyrec, header, &status);
   }
 
-  /* MJD at end of observation. */
+  // MJD at end of observation.
   if (!undefined(wcs->mjdend)) {
     wcsutil_double2str(keyvalue, format, wcs->mjdend);
     wcshdo_util(ctrl, "MJD-END", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "[d] MJD at end of observation", nkeyrec, header, &status);
   }
 
-  /* Time elapsed at end since fiducial time. */
+  // Time elapsed at end since fiducial time.
   if (!undefined(wcs->tstop)) {
     wcsutil_double2str(keyvalue, format, wcs->tstop);
     sprintf(comment, "[%s] Time elapsed since fiducial time at end",
@@ -1189,7 +1186,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* Exposure (integration) time. */
+  // Exposure (integration) time.
   if (!undefined(wcs->xposure)) {
     wcsutil_double2str(keyvalue, format, wcs->xposure);
     sprintf(comment, "[%s] Exposure (integration) time", timeunit);
@@ -1197,7 +1194,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* Elapsed time (start to stop). */
+  // Elapsed time (start to stop).
   if (!undefined(wcs->telapse)) {
     wcsutil_double2str(keyvalue, format, wcs->telapse);
     sprintf(comment, "[%s] Elapsed time (start to stop)", timeunit);
@@ -1205,9 +1202,9 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - Timing accuracy. */
+  // - - - - - - - - - - - - - - - - - - - - - - - - - - - -  Timing accuracy.
 
-  /* Systematic error in time measurements. */
+  // Systematic error in time measurements.
   if (!undefined(wcs->timsyer)) {
     wcsutil_double2str(keyvalue, format, wcs->timsyer);
     sprintf(comment, "[%s] Systematic error in time measurements", timeunit);
@@ -1215,7 +1212,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* Relative error in time measurements. */
+  // Relative error in time measurements.
   if (!undefined(wcs->timrder)) {
     wcsutil_double2str(keyvalue, format, wcs->timrder);
     sprintf(comment, "[%s] Relative error in time measurements", timeunit);
@@ -1223,7 +1220,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* Time resolution. */
+  // Time resolution.
   if (!undefined(wcs->timedel)) {
     wcsutil_double2str(keyvalue, format, wcs->timedel);
     sprintf(comment, "[%s] Time resolution", timeunit);
@@ -1231,7 +1228,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       comment, nkeyrec, header, &status);
   }
 
-  /* Reference position of timestamp in binned data. */
+  // Reference position of timestamp in binned data.
   if (!undefined(wcs->timepixr)) {
     wcsutil_double2str(keyvalue, format, wcs->timepixr);
     wcshdo_util(ctrl, "TIMEPIXR", "", 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
@@ -1239,9 +1236,9 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       &status);
   }
 
-  /* - - - - - - - - - - - - - - - - - Spatial & celestial reference frame. */
+  // - - - - - - - - - - - - - - - - - -  Spatial & celestial reference frame.
 
-  /* Observatory coordinates. */
+  // Observatory coordinates.
   if (!undefined(wcs->obsgeo[0]) &&
       !undefined(wcs->obsgeo[1]) &&
       !undefined(wcs->obsgeo[2])) {
@@ -1273,21 +1270,21 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       "[m]   IAU(1976) observatory height", nkeyrec, header, &status);
   }
 
-  /* Spacecraft orbit ephemeris file. */
+  // Spacecraft orbit ephemeris file.
   if (wcs->obsorbit[0]) {
     sprintf(keyvalue, "'%s'", wcs->obsorbit);
     wcshdo_util(ctrl, "OBSORBIT", 0x0, 0, 0x0, 0, 0, 0, ' ', 0, 0x0, keyvalue,
       "Spacecraft orbit ephemeris file", nkeyrec, header, &status);
   }
 
-  /* Equatorial coordinate system type. */
+  // Equatorial coordinate system type.
   if (wcs->radesys[0]) {
     sprintf(keyvalue, "'%s'", wcs->radesys);
     wcshdo_util(ctrl, "RADESYS", "RADE", 0, 0x0, 0, 0, 0, alt, colnum, colax,
       keyvalue, "Equatorial coordinate system", nkeyrec, header, &status);
   }
 
-  /* Equinox of equatorial coordinate system. */
+  // Equinox of equatorial coordinate system.
   if (!undefined(wcs->equinox)) {
     wcsutil_double2str(keyvalue, format, wcs->equinox);
     wcshdo_util(ctrl, "EQUINOX", "EQUI", 0, 0x0, 0, 0, 0, alt, colnum, colax,
@@ -1295,7 +1292,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       &status);
   }
 
-  /* Reference frame of spectral coordinates. */
+  // Reference frame of spectral coordinates.
   if (wcs->specsys[0]) {
     sprintf(keyvalue, "'%s'", wcs->specsys);
     wcshdo_util(ctrl, "SPECSYS", "SPEC", 0, 0x0, 0, 0, 0, alt, colnum, colax,
@@ -1303,7 +1300,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       &status);
   }
 
-  /* Reference frame of spectral observation. */
+  // Reference frame of spectral observation.
   if (wcs->ssysobs[0]) {
     sprintf(keyvalue, "'%s'", wcs->ssysobs);
     wcshdo_util(ctrl, "SSYSOBS", "SOBS", 0, 0x0, 0, 0, 0, alt, colnum, colax,
@@ -1311,21 +1308,21 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       &status);
   }
 
-  /* Observer's velocity towards source. */
+  // Observer's velocity towards source.
   if (!undefined(wcs->velosys)) {
     wcsutil_double2str(keyvalue, format, wcs->velosys);
     wcshdo_util(ctrl, "VELOSYS", "VSYS", 0, 0x0, 0, 0, 0, alt, colnum, colax,
       keyvalue, "[m/s] Velocity towards source", nkeyrec, header, &status);
   }
 
-  /* Redshift of the source. */
+  // Redshift of the source.
   if (!undefined(wcs->zsource)) {
     wcsutil_double2str(keyvalue, format, wcs->zsource);
     wcshdo_util(ctrl, "ZSOURCE", "ZSOU", 0, 0x0, 0, 0, 0, alt, colnum, colax,
       keyvalue, "Redshift of the source", nkeyrec, header, &status);
   }
 
-  /* Reference frame of source redshift. */
+  // Reference frame of source redshift.
   if (wcs->ssyssrc[0]) {
     sprintf(keyvalue, "'%s'", wcs->ssyssrc);
     wcshdo_util(ctrl, "SSYSSRC", "SSRC", 0, 0x0, 0, 0, 0, alt, colnum, colax,
@@ -1333,14 +1330,14 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       &status);
   }
 
-  /* Velocity orientation angle. */
+  // Velocity orientation angle.
   if (!undefined(wcs->velangl)) {
     wcsutil_double2str(keyvalue, format, wcs->velangl);
     wcshdo_util(ctrl, "VELANGL", "VANG", 0, 0x0, 0, 0, 0, alt, colnum, colax,
       keyvalue, "[deg] Velocity orientation angle", nkeyrec, header, &status);
   }
 
-  /* - - - - - - - - - - - - - - - - - - - Additional auxiliary parameters. */
+  // - - - - - - - - - - - - - - - - - - - -  Additional auxiliary parameters.
 
   if ((aux = wcs->aux)) {
     if (!undefined(aux->rsun_ref)) {
@@ -1385,13 +1382,13 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
     }
   }
 
-  /* - - - - - - - - - - - - - - - - - - - Distortion function parameters.  */
+  // - - - - - - - - - - - - - - - - - - - - - Distortion function parameters.
 
   if (dosip) {
-    /* Simple Imaging Polynomial (SIP) is handled by translating its dpkey */
-    /* records.  Determine a suitable numerical precision for the          */
-    /* polynomial coefficients to avoid trailing zeroes common to all of   */
-    /* them.                                                               */
+    // Simple Imaging Polynomial (SIP) is handled by translating its dpkey
+    // records.  Determine a suitable numerical precision for the
+    // polynomial coefficients to avoid trailing zeroes common to all of
+    // them.
     dis = wcs->lin.dispre;
     if (dofmt) {
       keyp = dis->dp;
@@ -1412,9 +1409,9 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       sprintf(format, "%%20.%dE", precision);
     }
 
-    /* Ensure the coefficients are written in a human-readable sequence. */
+    // Ensure the coefficients are written in a human-readable sequence.
     for (j = 0; j <= 1; j++) {
-      /* Distortion function polynomial coefficients. */
+      // Distortion function polynomial coefficients.
       wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
         nkeyrec, header, &status);
 
@@ -1463,7 +1460,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           header, &status);
       }
 
-      /* Inverse distortion function polynomial coefficients. */
+      // Inverse distortion function polynomial coefficients.
       if (dis->disx2p == 0x0) continue;
 
       wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
@@ -1518,20 +1515,20 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       iparm = dis->iparm[j];
       dparm = dis->dparm[j];
 
-      /* Identify the distortion type. */
+      // Identify the distortion type.
       if (dotpv) {
-        /* TPV "projection" is handled by translating its dpkey records, */
-        /* which were originally translated from PVi_ma by wcsset(), or  */
-        /* possibly input directly as a CQDISia = 'TPV' distortion type. */
-        /* Determine a suitable numerical precision for the polynomial   */
-        /* coefficients to avoid trailing zeroes common to all of them.  */
+        // TPV "projection" is handled by translating its dpkey records,
+        // which were originally translated from PVi_ma by wcsset(), or
+        // possibly input directly as a CQDISia = 'TPV' distortion type.
+        // Determine a suitable numerical precision for the polynomial
+        // coefficients to avoid trailing zeroes common to all of them.
         if (dofmt) wcshdo_format('E', iparm[I_NDPARM], dparm, format);
         sprintf(fmt01, "%.3ss", format);
 
         wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
           nkeyrec, header, &status);
 
-        /* Distortion function polynomial coefficients. */
+        // Distortion function polynomial coefficients.
         sprintf(keyword, "PV%d_", j+1);
         kp = keyword + strlen(keyword);
 
@@ -1544,7 +1541,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           if (strncmp(cp, "TPV.", 4) != 0) continue;
           strcpy(kp, cp+4);
 
-          /* Identify the term of the TPV polynomial for human readers. */
+          // Identify the term of the TPV polynomial for human readers.
           sscanf(cp+4, "%d", &m);
           wcshdo_tpdterm(m, j == wcs->lng, term);
           sprintf(comment, "TPV coefficient: %s", term);
@@ -1561,15 +1558,15 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       } else if (strcmp(dis->dtype[j], "TPD") == 0 || dotpd ||
                  strcmp(dis->dtype[j], "Polynomial")  == 0 ||
                  strcmp(dis->dtype[j], "Polynomial*") == 0) {
-        /* One of the Paper IV type polynomial distortions. */
+        // One of the Paper IV type polynomial distortions.
         wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
           nkeyrec, header, &status);
 
         if (strcmp(dis->dtype[j], "TPD") == 0) {
-          /* Pure TPD. */
+          // Pure TPD.
           dotpd = 1;
         } else if (strncmp(dis->dtype[j], "Polynomial", 10) == 0) {
-          /* Polynomial distortion.  Write it as TPD by request? */
+          // Polynomial distortion.  Write it as TPD by request?
           dotpd = (iparm[I_DTYPE] & DIS_DOTPD);
           strcpy(tpdsrc, "Polynomial distortion");
         }
@@ -1577,7 +1574,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
         pq = idis ? 'Q' : 'P';
         Nhat = dis->Nhat[j];
 
-        /* CPDISja/CQDISia */
+        // CPDISja/CQDISia
         sprintf(keyword, "C%cDIS%d", pq, j+1);
         if (idis == 0) {
           strcpy(comment, "P = prior, ");
@@ -1589,18 +1586,18 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           strcpy(keyvalue, "'TPD'");
           strcat(comment, "Template Polynomial Distortion");
 
-          /* For identifying terms of the TPD polynomial. */
+          // For identifying terms of the TPD polynomial.
           axmap  = dis->axmap[j];
           direct = 1;
           doaux  = iparm[I_TPDAUX];
           if (Nhat == 2) {
-            /* Associate x with longitude, y with latitude. */
+            // Associate x with longitude, y with latitude.
             if (axmap[0] == wcs->lng && axmap[1] == wcs->lat) {
               direct = 1;
             } else if (axmap[0] == wcs->lat && axmap[1] == wcs->lng) {
               direct = 0;
             } else {
-              /* Non-celestial. */
+              // Non-celestial.
               direct = (axmap[0] < axmap[1]);
             }
           }
@@ -1612,7 +1609,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
         wcshdo_util(ctrl, keyword, "", 0, 0x0, 0, 0, 0, alt, 0, 0,
           keyvalue, comment, nkeyrec, header, &status);
 
-        /* NAXES. */
+        // NAXES.
         sprintf(keyword,  "D%c%d", pq, j+1);
         sprintf(keyvalue, "'NAXES:  %d'", Nhat);
         if (Nhat == 1) {
@@ -1625,7 +1622,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
         wcshdo_util(ctrl, keyword, "", 0, 0x0, 0, 0, 0, alt, 0, 0,
           keyvalue, comment, nkeyrec, header, &status);
 
-        /* AXIS.jhat */
+        // AXIS.jhat
         for (jhat = 0; jhat < Nhat; jhat++) {
           axmap = dis->axmap[j];
           sprintf(keyvalue, "'AXIS.%d: %d'", jhat+1, axmap[jhat]+1);
@@ -1642,7 +1639,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           sprintf(comment+strlen(comment), " independent variable: axis %d",
             axmap[jhat]+1);
           if (dotpd) {
-            /* axid is "xyxuvu". */
+            // axid is "xyxuvu".
             cp = axid;
             if (!direct) cp++;
             if (doaux) cp += 3;
@@ -1653,7 +1650,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
             keyvalue, comment, nkeyrec, header, &status);
         }
 
-        /* OFFSET.jhat */
+        // OFFSET.jhat
         if (dofmt) wcshdo_format('f', Nhat, dis->offset[j], format);
         for (jhat = 0; jhat < Nhat; jhat++) {
           if (dis->offset[j][jhat] == 0.0) continue;
@@ -1666,7 +1663,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
             keyvalue, comment, nkeyrec, header, &status);
         }
 
-        /* SCALE.jhat */
+        // SCALE.jhat
         if (dofmt) wcshdo_format('f', Nhat, dis->scale[j], format);
         for (jhat = 0; jhat < Nhat; jhat++) {
           if (dis->scale[j][jhat] == 1.0) continue;
@@ -1679,22 +1676,26 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
             keyvalue, comment, nkeyrec, header, &status);
         }
 
-        /* Does the distortion function compute a correction? */
-        if (iparm[I_DOCORR]) {
+        // Does the distortion function compute a correction?
+        if (dis->docorr[j]) {
           wcshdo_util(ctrl, keyword, "", 0, 0x0, 0, 0, 0, alt, 0, 0,
             "'DOCORR: 1'", "Distortion function computes a correction",
             nkeyrec, header, &status);
+        } else {
+          wcshdo_util(ctrl, keyword, "", 0, 0x0, 0, 0, 0, alt, 0, 0,
+            "'DOCORR: 0'", "Distortion function computes coordinates",
+            nkeyrec, header, &status);
         }
 
         if (dotpd) {
-          /* Template Polynomial Distortion (TPD).  As it may have been */
-          /* translated from SIP, TPV, DSS, TNX, ZPX, or perhaps        */
-          /* Polynomial, the dpkey records may not relate to TPD.       */
-          /* Output is therefore handled via dparm.                     */
+          // Template Polynomial Distortion (TPD).  As it may have been
+          // translated from SIP, TPV, DSS, TNX, ZPX, or perhaps
+          // Polynomial, the dpkey records may not relate to TPD.
+          // Output is therefore handled via dparm.
           if (dofmt) wcshdo_format('E', iparm[I_NDPARM], dparm, format);
           sprintf(fmt01, "%.3ss", format);
 
-          /* AUX.jhat.COEFF.m */
+          // AUX.jhat.COEFF.m
           if (doaux) {
             for (idp = 0; idp < 6; idp++) {
               if (dparm[idp] == 0.0) {
@@ -1721,7 +1722,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
             dparm += 6;
           }
 
-          /* TPD.FWD.m */
+          // TPD.FWD.m
           for (idp = 0; idp < iparm[I_TPDNCO]; idp++) {
             if (dparm[idp] == 0.0) continue;
 
@@ -1740,7 +1741,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
               keyvalue, comment, nkeyrec, header, &status);
           }
 
-          /* CPERRja/CQERRia */
+          // CPERRja/CQERRia
           if (dis->maxdis[j] != 0.0) {
             sprintf(keyword,  "C%cERR%d", pq, j+1);
             sprintf(keyvalue, "%20.2f", dis->maxdis[j]);
@@ -1750,13 +1751,13 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
               keyvalue, comment, nkeyrec, header, &status);
           }
 
-          /* Inverse distortion function polynomial coefficients. */
+          // Inverse distortion function polynomial coefficients.
           if (dis->disx2p[j] == 0x0) continue;
 
           wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
             nkeyrec, header, &status);
 
-          /* TPD.REV.m */
+          // TPD.REV.m
           sprintf(keyword,  "D%c%d", pq, j+1);
           for (idp = iparm[I_TPDNCO]; idp < iparm[I_NDPARM]; idp++) {
             if (dparm[idp] == 0.0) continue;
@@ -1772,10 +1773,10 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
           }
 
         } else {
-          /* General polynomial distortion, handled via its dpkey records */
-          /* since iparm and dparm may hold a translation to TPD.         */
+          // General polynomial distortion, handled via its dpkey records
+          // since iparm and dparm may hold a translation to TPD.
 
-          /* Do auxiliary variables first. */
+          // Do auxiliary variables first.
           keyp = dis->dp;
           for (idp = 0; idp < dis->ndp; idp++, keyp++) {
             if (keyp->j != j+1) continue;
@@ -1834,7 +1835,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
             break;
           }
 
-          /* Do polynomial terms. */
+          // Do polynomial terms.
           keyp = dis->dp;
           for (idp = 0; idp < dis->ndp; idp++, keyp++) {
             if (keyp->j != j+1) continue;
@@ -1886,7 +1887,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
               keyvalue, comment, nkeyrec, header, &status);
           }
 
-          /* CPERRja/CQERRia */
+          // CPERRja/CQERRia
           if (dis->maxdis[j] != 0.0) {
             sprintf(keyword,  "C%cERR%d", pq, j+1);
             sprintf(keyvalue, "%20.2f", dis->maxdis[j]);
@@ -1899,7 +1900,7 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
       }
     }
 
-    /* DVERRa */
+    // DVERRa
     if (dis->totdis != 0.0) {
       sprintf(keyvalue, "%20.2f", dis->totdis);
       sprintf(comment, "Maximum combined distortion");
@@ -1909,12 +1910,12 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   }
 
 
-  /* Add identification. */
+  // Add identification.
   wcshdo_util(ctrl, "", "", 0, 0x0, 0, 0, 0, ' ', 0, 0, "", "",
     nkeyrec, header, &status);
 
   if (dotpd == DIS_DOTPD) {
-    /* TPD by translation. */
+    // TPD by translation.
     sprintf(comment, "Translated from %s to TPD by WCSLIB %s", tpdsrc,
       wcslib_version(0x0));
   } else {
@@ -1932,8 +1933,8 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
-/* Determine a suitable floating point format for a set of parameters.      */
+//----------------------------------------------------------------------------
+// Determine a suitable floating point format for a set of parameters.
 
 void wcshdo_format(
   int fmt,
@@ -1942,45 +1943,51 @@ void wcshdo_format(
   char *format)
 
 {
-  char cval[24];
-  int  cp0, cpi, i, expmax, expon, nsig, precision;
-
-  if (fmt == 'G') {
-    fmt = 'f';
-    for (i = 0; i < nval; i++) {
-      if (fabs(val[i]) < 1e-4 || 1e12 < val[i]) {
-        fmt = 'E';
-        break;
-      }
-    }
-  }
-
-  cp0 = 2;
-  expmax = -999;
+  int emax = -999;
+  int emin = +999;
+  int precision = 0;
+  int i;
   for (i = 0; i < nval; i++) {
-    /* Double precision has at least 15 significant digits, and up to 17:  */
-    /* http://en.wikipedia.org/wiki/Double-precision_floating-point_format */
+    // Double precision has at least 15 significant digits, and up to 17:
+    // http://en.wikipedia.org/wiki/Double-precision_floating-point_format
+    char cval[24];
     wcsutil_double2str(cval, "%21.14E", val[i]);
 
-    cpi = 16;
-    while (cp0 < cpi && cval[cpi] == '0') cpi--;
-    cp0 = cpi;
+    int cpi = 16;
+    while (2 < cpi && cval[cpi] == '0') cpi--;
+
+    // Precision for 'E' format.
+    cpi -= 2;
+    if (precision < cpi) precision = cpi;
 
+    // Range of significant digits for 'f' format.
+    int expon;
     sscanf(cval+18, "%d", &expon);
-    if (expmax < expon) expmax = expon;
+
+    if (emax < expon) emax = expon;
+    expon -= cpi;
+    if (expon < emin) emin = expon;
   }
 
-  nsig = cp0 - 1;
 
+  if (fmt == 'G') {
+    // Because e.g. writing 1e4 as 10000 requires an extra digit.
+    emax++;
+
+    if (emin < -15 || 15 < emax || 15 < (emax - emin)) {
+      fmt = 'E';
+    } else {
+      fmt = 'f';
+    }
+  }
 
   if (fmt == 'f') {
-    precision = nsig - (expmax + 1);
+    precision = -emin;
     if (precision < 1)  precision = 1;
     if (17 < precision) precision = 17;
     sprintf(format, "%%20.%df", precision);
 
   } else {
-    precision = nsig - 1;
     if (precision < 1)  precision = 1;
     if (14 < precision) precision = 14;
     if (precision < 14) {
@@ -1991,8 +1998,8 @@ void wcshdo_format(
   }
 }
 
-/*--------------------------------------------------------------------------*/
-/* Construct a string that identifies the term of a TPD or TPV polynomial.  */
+//----------------------------------------------------------------------------
+// Construct a string that identifies the term of a TPD or TPV polynomial.
 
 void wcshdo_tpdterm(
   int m,
@@ -2028,8 +2035,8 @@ void wcshdo_tpdterm(
   }
 }
 
-/*--------------------------------------------------------------------------*/
-/* Construct a keyrecord from the components given.                         */
+//----------------------------------------------------------------------------
+// Construct a keyrecord from the components given.
 
 void wcshdo_util(
   int relax,
@@ -2055,7 +2062,7 @@ void wcshdo_util(
 
   if (*status) return;
 
-  /* Reallocate memory in blocks of 2880 bytes. */
+  // Reallocate memory in blocks of 2880 bytes.
   if ((*nkeyrec)%32 == 0) {
     nbyte = ((*nkeyrec)/32 + 1) * 2880;
     if (!(hptr = realloc(*header, nbyte))) {
@@ -2066,10 +2073,10 @@ void wcshdo_util(
     *header = hptr;
   }
 
-  /* Construct the keyword. */
+  // Construct the keyword.
   if (alt == ' ') alt = '\0';
   if (btcol) {
-    /* Binary table image array. */
+    // Binary table image array.
     if (i > 0 && j) {
       if (j > 0) {
         sprintf(keyword, "%d%d%s%d%c", i, j, tbkey, btcol, alt);
@@ -2085,7 +2092,7 @@ void wcshdo_util(
     }
 
     if ((strlen(keyword) < 8) && tlkey && (relax & level)) {
-      /* Use the long form. */
+      // Use the long form.
       if (i > 0 && j) {
         if (j > 0) {
           sprintf(keyword, "%d%d%s%d%c", i, j, tlkey, btcol, alt);
@@ -2102,7 +2109,7 @@ void wcshdo_util(
     }
 
   } else if (plcol && plcol[0]) {
-    /* Pixel list. */
+    // Pixel list.
     if (i > 0 && j) {
       if (j > 0) {
         sprintf(keyword, "T%s%d_%d%c", tbkey, plcol[i-1], plcol[j-1], alt);
@@ -2118,7 +2125,7 @@ void wcshdo_util(
     }
 
     if ((strlen(keyword) < 8) && tlkey && (relax & level)) {
-      /* Use the long form. */
+      // Use the long form.
       if (i > 0 && j) {
         if (j > 0) {
           sprintf(keyword, "T%s%d_%d%c", tlkey, plcol[i-1], plcol[j-1], alt);
@@ -2149,7 +2156,7 @@ void wcshdo_util(
     }
   }
 
-  /* Double-up single-quotes in string keyvalues. */
+  // Double-up single-quotes in string keyvalues.
   if (*keyvalue == '\'') {
     hptr = keyvalue + 1;
     while (*hptr) {
@@ -2170,23 +2177,23 @@ void wcshdo_util(
       hptr++;
     }
 
-    /* Check length. */
+    // Check length.
     if (strlen(keyvalue) > 70) {
-      /* Truncate. */
+      // Truncate.
       keyvalue[69] = '\'';
       keyvalue[70] = '\0';
     }
 
   } else {
-    /* Check length. */
+    // Check length.
     if (strlen(keyvalue) > 70) {
-      /* Truncate. */
+      // Truncate.
       keyvalue[70] = '\0';
     }
   }
 
   if ((nv = strlen(keyvalue) > 20)) {
-    /* Rob the keycomment to make space for the keyvalue. */
+    // Rob the keycomment to make space for the keyvalue.
     nc -= (nv - 20);
   }
 
Index: astropy-4.2/cextern/wcslib/C/wcshdr.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcshdr.h
+++ astropy-4.2/cextern/wcslib/C/wcshdr.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcshdr.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcshdr.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -227,7 +224,7 @@
 *                         4: Fatal error returned by Flex parser.
 *
 * Notes:
-*   Refer to wcsbth() notes 1, 2, 3, 5, 7, and 8.
+*   1: Refer to wcsbth() notes 1, 2, 3, 5, 7, and 8.
 *
 *
 * wcsbth() - FITS WCS parser routine for binary table and image headers
@@ -1177,91 +1174,96 @@
 *                       wcsprm::err if enabled, see wcserr_enable().
 *
 * Notes:
-*   wcshdo() interprets the "relax" argument as a vector of flag bits to
-*   provide fine-grained control over what non-standard WCS keywords to write.
-*   The flag bits are subject to change in future and should be set by using
-*   the preprocessor macros (see below) for the purpose.
+*   1: wcshdo() interprets the "relax" argument as a vector of flag bits to
+*      provide fine-grained control over what non-standard WCS keywords to
+*      write.  The flag bits are subject to change in future and should be set
+*      by using the preprocessor macros (see below) for the purpose.
 *
-*   - WCSHDO_none: Don't use any extensions.
+*      - WCSHDO_none: Don't use any extensions.
 *
-*   - WCSHDO_all: Write all recognized extensions, equivalent to setting each
-*           flag bit.
+*      - WCSHDO_all: Write all recognized extensions, equivalent to setting
+*              each flag bit.
 *
-*   - WCSHDO_safe: Write all extensions that are considered to be safe and
-*           recommended.
+*      - WCSHDO_safe: Write all extensions that are considered to be safe and
+*              recommended.
 *
-*   - WCSHDO_DOBSn: Write DOBSn, the column-specific analogue of DATE-OBS for
-*           use in binary tables and pixel lists.  WCS Paper III introduced
-*           DATE-AVG and DAVGn but by an oversight DOBSn (the obvious analogy)
-*           was never formally defined by the standard.  The alternative to
-*           using DOBSn is to write DATE-OBS which applies to the whole table.
-*           This usage is considered to be safe and is recommended.
+*      - WCSHDO_DOBSn: Write DOBSn, the column-specific analogue of DATE-OBS
+*              for use in binary tables and pixel lists.  WCS Paper III
+*              introduced DATE-AVG and DAVGn but by an oversight DOBSn (the
+*              obvious analogy) was never formally defined by the standard.
+*              The alternative to using DOBSn is to write DATE-OBS which
+*              applies to the whole table.  This usage is considered to be
+*              safe and is recommended.
 *
-*   - WCSHDO_TPCn_ka: WCS Paper I defined
+*      - WCSHDO_TPCn_ka: WCS Paper I defined
 *
-*           - TPn_ka and TCn_ka for pixel lists
+*              - TPn_ka and TCn_ka for pixel lists
 *
-*           but WCS Paper II uses TPCn_ka in one example and subsequently the
-*           errata for the WCS papers legitimized the use of
+*              but WCS Paper II uses TPCn_ka in one example and subsequently
+*              the errata for the WCS papers legitimized the use of
 *
-*           - TPCn_ka and TCDn_ka for pixel lists
+*              - TPCn_ka and TCDn_ka for pixel lists
 *
-*           provided that the keyword does not exceed eight characters.  This
-*           usage is considered to be safe and is recommended because of the
-*           non-mnemonic terseness of the shorter forms.
+*              provided that the keyword does not exceed eight characters.
+*              This usage is considered to be safe and is recommended because
+*              of the non-mnemonic terseness of the shorter forms.
 *
-*   - WCSHDO_PVn_ma: WCS Paper I defined
+*      - WCSHDO_PVn_ma: WCS Paper I defined
 *
-*           - iVn_ma and iSn_ma for bintables and
-*           - TVn_ma and TSn_ma for pixel lists
+*              - iVn_ma and iSn_ma for bintables and
+*              - TVn_ma and TSn_ma for pixel lists
 *
-*           but WCS Paper II uses iPVn_ma and TPVn_ma in the examples and
-*           subsequently the errata for the WCS papers legitimized the use of
+*              but WCS Paper II uses iPVn_ma and TPVn_ma in the examples and
+*              subsequently the errata for the WCS papers legitimized the use
+*              of
 *
-*           - iPVn_ma and iPSn_ma for bintables and
-*           - TPVn_ma and TPSn_ma for pixel lists
+*              - iPVn_ma and iPSn_ma for bintables and
+*              - TPVn_ma and TPSn_ma for pixel lists
 *
-*           provided that the keyword does not exceed eight characters.  This
-*           usage is considered to be safe and is recommended because of the
-*           non-mnemonic terseness of the shorter forms.
+*              provided that the keyword does not exceed eight characters.
+*              This usage is considered to be safe and is recommended because
+*              of the non-mnemonic terseness of the shorter forms.
 *
-*   - WCSHDO_CRPXna: For historical reasons WCS Paper I defined
+*      - WCSHDO_CRPXna: For historical reasons WCS Paper I defined
 *
-*           - jCRPXn, iCDLTn, iCUNIn, iCTYPn, and iCRVLn for bintables and
-*           - TCRPXn, TCDLTn, TCUNIn, TCTYPn, and TCRVLn for pixel lists
+*              - jCRPXn, iCDLTn, iCUNIn, iCTYPn, and iCRVLn for bintables and
+*              - TCRPXn, TCDLTn, TCUNIn, TCTYPn, and TCRVLn for pixel lists
 *
-*           for use without an alternate version specifier.  However, because
-*           of the eight-character keyword constraint, in order to accommodate
-*           column numbers greater than 99 WCS Paper I also defined
+*              for use without an alternate version specifier.  However,
+*              because of the eight-character keyword constraint, in order to
+*              accommodate column numbers greater than 99 WCS Paper I also
+*              defined
 *
-*           - jCRPna, iCDEna, iCUNna, iCTYna and iCRVna for bintables and
-*           - TCRPna, TCDEna, TCUNna, TCTYna and TCRVna for pixel lists
+*              - jCRPna, iCDEna, iCUNna, iCTYna and iCRVna for bintables and
+*              - TCRPna, TCDEna, TCUNna, TCTYna and TCRVna for pixel lists
 *
-*           for use with an alternate version specifier (the "a").  Like the
-*           PC, CD, PV, and PS keywords there is an obvious tendency to
-*           confuse these two forms for column numbers up to 99.  It is very
-*           unlikely that any parser would reject keywords in the first set
-*           with a non-blank alternate version specifier so this usage is
-*           considered to be safe and is recommended.
+*              for use with an alternate version specifier (the "a").  Like
+*              the PC, CD, PV, and PS keywords there is an obvious tendency to
+*              confuse these two forms for column numbers up to 99.  It is
+*              very unlikely that any parser would reject keywords in the
+*              first set with a non-blank alternate version specifier so this
+*              usage is considered to be safe and is recommended.
 *
-*   - WCSHDO_CNAMna: WCS Papers I and III defined
+*      - WCSHDO_CNAMna: WCS Papers I and III defined
 *
-*           - iCNAna,  iCRDna,  and iCSYna  for bintables and
-*           - TCNAna,  TCRDna,  and TCSYna  for pixel lists
+*              - iCNAna,  iCRDna,  and iCSYna  for bintables and
+*              - TCNAna,  TCRDna,  and TCSYna  for pixel lists
 *
-*           By analogy with the above, the long forms would be
+*              By analogy with the above, the long forms would be
 *
-*           - iCNAMna, iCRDEna, and iCSYEna for bintables and
-*           - TCNAMna, TCRDEna, and TCSYEna for pixel lists
+*              - iCNAMna, iCRDEna, and iCSYEna for bintables and
+*              - TCNAMna, TCRDEna, and TCSYEna for pixel lists
 *
-*           Note that these keywords provide auxiliary information only, none
-*           of them are needed to compute world coordinates.  This usage is
-*           potentially unsafe and is not recommended at this time.
+*              Note that these keywords provide auxiliary information only,
+*              none of them are needed to compute world coordinates.  This
+*              usage is potentially unsafe and is not recommended at this
+*              time.
 *
-*   - WCSHDO_WCSNna: In light of wcsbth() note 4, write WCSNna instead of
-*           TWCSna for pixel lists.  While wcsbth() treats WCSNna and TWCSna
-*           as equivalent, other parsers may not.  Consequently, this usage
-*           is potentially unsafe and is not recommended at this time.
+*      - WCSHDO_WCSNna: In light of wcsbth() note 4, write WCSNna instead of
+*              TWCSna for pixel lists.  While wcsbth() treats WCSNna and
+*              TWCSna as equivalent, other parsers may not.  Consequently,
+*              this usage is potentially unsafe and is not recommended at this
+*              time.
 *
 *
 * Global variable: const char *wcshdr_errmsg[] - Status return messages
@@ -1330,13 +1332,13 @@ extern "C" {
 extern const char *wcshdr_errmsg[];
 
 enum wcshdr_errmsg_enum {
-  WCSHDRERR_SUCCESS            = 0,	/* Success. */
-  WCSHDRERR_NULL_POINTER       = 1,	/* Null wcsprm pointer passed. */
-  WCSHDRERR_MEMORY             = 2,	/* Memory allocation failed. */
-  WCSHDRERR_BAD_COLUMN         = 3,	/* Invalid column selection. */
-  WCSHDRERR_PARSER             = 4,	/* Fatal error returned by Flex
-					   parser. */
-  WCSHDRERR_BAD_TABULAR_PARAMS = 5 	/* Invalid tabular parameters. */
+  WCSHDRERR_SUCCESS            = 0,	// Success.
+  WCSHDRERR_NULL_POINTER       = 1,	// Null wcsprm pointer passed.
+  WCSHDRERR_MEMORY             = 2,	// Memory allocation failed.
+  WCSHDRERR_BAD_COLUMN         = 3,	// Invalid column selection.
+  WCSHDRERR_PARSER             = 4,	// Fatal error returned by Flex
+					// parser.
+  WCSHDRERR_BAD_TABULAR_PARAMS = 5 	// Invalid tabular parameters.
 };
 
 int wcspih(char *header, int nkeyrec, int relax, int ctrl, int *nreject,
@@ -1360,4 +1362,4 @@ int wcshdo(int ctrl, struct wcsprm *wcs,
 }
 #endif
 
-#endif /* WCSLIB_WCSHDR */
+#endif // WCSLIB_WCSHDR
Index: astropy-4.2/cextern/wcslib/C/wcslib.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcslib.h
+++ astropy-4.2/cextern/wcslib/C/wcslib.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcslib.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcslib.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -60,4 +57,4 @@
 #include "wcsutil.h"
 #include "wtbarr.h"
 
-#endif /* WCSLIB_WCSLIB */
+#endif // WCSLIB_WCSLIB
Index: astropy-4.2/cextern/wcslib/C/wcsmath.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsmath.h
+++ astropy-4.2/cextern/wcslib/C/wcsmath.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsmath.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsmath.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -72,4 +69,4 @@
 #define UNDEFINED 987654321.0e99
 #define undefined(value) (value == UNDEFINED)
 
-#endif /* WCSLIB_WCSMATH */
+#endif // WCSLIB_WCSMATH
Index: astropy-4.2/cextern/wcslib/C/wcspih.l
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcspih.l
+++ astropy-4.2/cextern/wcslib/C/wcspih.l
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcspih.l,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcspih.l,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
 * wcspih.l is a Flex description file containing the definition of a lexical
@@ -141,7 +138,7 @@ static int wcspih_scanner(char *header,
                           int *nreject, int *nwcs, struct wcsprm **wcs,
                           yyscan_t yyscanner);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcspih(
   char *header,
@@ -166,7 +163,7 @@ int wcspih(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define YY_DECL int wcspih_scanner(char *header, int nkeyrec, int relax, \
  int ctrl, int *nreject, int *nwcs, struct wcsprm **wcs, yyscan_t yyscanner)
@@ -184,11 +181,11 @@ int wcspih(
 	  } \
 	}
 
-/* These global variables are required by YY_INPUT. */
+// These global variables are required by YY_INPUT.
 static char *wcspih_hdr;
 static int  wcspih_nkeyrec;
 
-/* Internal helper functions. */
+// Internal helper functions.
 static int wcspih_final(int ndp[], int ndq[], int distran, double dsstmp[],
              char *wat[], int *nwcs, struct wcsprm **wcs);
 static int wcspih_init1(int naxis, int alts[], int dpq[], int npv[],
@@ -205,14 +202,14 @@ static int wcspih_vsource(double *wptr,
 
 static int wcspih_timepixr(double timepixr);
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
+// Used in preempting the call to exit() by yy_fatal_error().
 jmp_buf wcspih_abort_jmp_env;
 #define exit(status) longjmp(wcspih_abort_jmp_env, status)
 
 %}
 
 %%
-	/* Keyword indices, as used in the WCS papers, e.g. PCi_ja, PVi_ma. */
+	// Keyword indices, as used in the WCS papers, e.g. PCi_ja, PVi_ma.
 	char a;
 	int  i, j, m, p, q;
 	
@@ -241,34 +238,34 @@ jmp_buf wcspih_abort_jmp_env;
 	  ndq[ialt]  = 0;
 	}
 	
-	/* Parameters used to implement YY_INPUT. */
+	// Parameters used to implement YY_INPUT.
 	wcspih_hdr = header;
 	wcspih_nkeyrec = nkeyrec;
 	
-	/* Our handle on the input stream. */
+	// Our handle on the input stream.
 	keyrec = header;
 	hptr = header;
 	keep = 0x0;
 	
-	/* For keeping tallies of keywords found. */
+	// For keeping tallies of keywords found.
 	*nreject = 0;
 	nvalid = 0;
 	nother = 0;
 	
-	/* If strict, then also reject. */
+	// If strict, then also reject.
 	if (relax & WCSHDR_strict) relax |= WCSHDR_reject;
 	
-	/* Keyword parameters. */
+	// Keyword parameters.
 	i = j = 0;
 	m = 0;
 	a = ' ';
 	
-	/* For decoding the keyvalue. */
+	// For decoding the keyvalue.
 	valtype = -1;
 	distype =  0;
 	vptr    = 0x0;
 	
-	/* For keywords that require special handling. */
+	// For keywords that require special handling.
 	altlin  = 0;
 	npptr   = 0x0;
 	chekval = 0x0;
@@ -281,15 +278,15 @@ jmp_buf wcspih_abort_jmp_env;
 	watflag = 0;
 	watn    = 0;
 	
-	/* The data structures produced. */
+	// The data structures produced.
 	*nwcs = 0;
 	*wcs  = 0x0;
 	
-	/* Control variables. */
+	// Control variables.
 	ipass = 1;
 	npass = 2;
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
+	// Return here via longjmp() invoked by yy_fatal_error().
 	if (setjmp(wcspih_abort_jmp_env)) {
 	  return 3;
 	}
@@ -627,7 +624,7 @@ jmp_buf wcspih_abort_jmp_env;
 ^MJDREFI" " |
 ^MJD-REFI {
 	  if ((yytext[3] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	
@@ -683,7 +680,7 @@ jmp_buf wcspih_abort_jmp_env;
 ^JDREFI"  " |
 ^JD-REFI {
 	  if ((yytext[2] == 'R') || (relax & WCSHDR_DATEREF)) {
-	    /* Actually integer, but treated as float. */
+	    // Actually integer, but treated as float.
 	    valtype = FLOAT;
 	    vptr    = wcstem.mjdref;
 	    special = wcspih_jdrefi;
@@ -1193,7 +1190,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^A_ORDER" " {
-	  /* SIP: axis 1 polynomial degree (not stored). */
+	  // SIP: axis 1 polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -1206,7 +1203,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^B_ORDER" " {
-	  /* SIP: axis 2 polynomial degree (not stored). */
+	  // SIP: axis 2 polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -1219,7 +1216,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^AP_ORDER {
-	  /* SIP: axis 1 inverse polynomial degree (not stored). */
+	  // SIP: axis 1 inverse polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -1232,7 +1229,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^BP_ORDER {
-	  /* SIP: axis 2 inverse polynomial degree (not stored). */
+	  // SIP: axis 2 inverse polynomial degree (not stored).
 	  valtype = INTEGER;
 	  distype = PRIOR;
 	  vptr    = 0x0;
@@ -1245,7 +1242,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^A_DMAX"  " {
-	  /* SIP: axis 1 maximum distortion. */
+	  // SIP: axis 1 maximum distortion.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.maxdis);
@@ -1258,7 +1255,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^B_DMAX"  " {
-	  /* SIP: axis 2 maximum distortion. */
+	  // SIP: axis 2 maximum distortion.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.maxdis);
@@ -1271,7 +1268,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^A_	{
-	  /* SIP: axis 1 polynomial coefficient. */
+	  // SIP: axis 1 polynomial coefficient.
 	  i = 1;
 	  sipflag = 2;
 	
@@ -1280,7 +1277,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^B_	{
-	  /* SIP: axis 2 polynomial coefficient. */
+	  // SIP: axis 2 polynomial coefficient.
 	  i = 2;
 	  sipflag = 2;
 	
@@ -1289,7 +1286,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^AP_	{
-	  /* SIP: axis 1 inverse polynomial coefficient. */
+	  // SIP: axis 1 inverse polynomial coefficient.
 	  i = 1;
 	  sipflag = 3;
 	
@@ -1298,7 +1295,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^BP_	{
-	  /* SIP: axis 2 inverse polynomial coefficient. */
+	  // SIP: axis 2 inverse polynomial coefficient.
 	  i = 2;
 	  sipflag = 3;
 	
@@ -1307,7 +1304,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^CNPIX1"  " {
-	  /* DSS: LLH corner pixel coordinate 1. */
+	  // DSS: LLH corner pixel coordinate 1.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp;
@@ -1319,7 +1316,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^CNPIX2"  " {
-	  /* DSS: LLH corner pixel coordinate 2. */
+	  // DSS: LLH corner pixel coordinate 2.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+1;
@@ -1331,7 +1328,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PPO3"    " {
-	  /* DSS: plate centre x-coordinate in micron. */
+	  // DSS: plate centre x-coordinate in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+2;
@@ -1343,7 +1340,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PPO6"    " {
-	  /* DSS: plate centre y-coordinate in micron. */
+	  // DSS: plate centre y-coordinate in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+3;
@@ -1355,7 +1352,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^XPIXELSZ {
-	  /* DSS: pixel x-dimension in micron. */
+	  // DSS: pixel x-dimension in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+4;
@@ -1367,7 +1364,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^YPIXELSZ {
-	  /* DSS: pixel y-dimension in micron. */
+	  // DSS: pixel y-dimension in micron.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+5;
@@ -1379,7 +1376,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTRAH"  " {
-	  /* DSS: plate centre, right ascension - hours. */
+	  // DSS: plate centre, right ascension - hours.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+6;
@@ -1391,7 +1388,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTRAM"  " {
-	  /* DSS: plate centre, right ascension - minutes. */
+	  // DSS: plate centre, right ascension - minutes.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+7;
@@ -1403,7 +1400,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTRAS"  " {
-	  /* DSS: plate centre, right ascension - seconds. */
+	  // DSS: plate centre, right ascension - seconds.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+8;
@@ -1415,7 +1412,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTDECSN {
-	  /* DSS: plate centre, declination - sign. */
+	  // DSS: plate centre, declination - sign.
 	  valtype = STRING;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+9;
@@ -1427,7 +1424,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTDECD" " {
-	  /* DSS: plate centre, declination - degrees. */
+	  // DSS: plate centre, declination - degrees.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+10;
@@ -1439,7 +1436,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTDECM" " {
-	  /* DSS: plate centre, declination - arcmin. */
+	  // DSS: plate centre, declination - arcmin.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+11;
@@ -1451,7 +1448,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLTDECS" " {
-	  /* DSS: plate centre, declination - arcsec. */
+	  // DSS: plate centre, declination - arcsec.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+12;
@@ -1463,7 +1460,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^PLATEID" " {
-	  /* DSS: plate identification (insufficient to trigger DSS). */
+	  // DSS: plate identification (insufficient to trigger DSS).
 	  valtype = STRING;
 	  distype = SEQUENT;
 	  vptr    = dsstmp+13;
@@ -1475,7 +1472,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^AMDX	{
-	  /* DSS: axis 1 polynomial coefficient. */
+	  // DSS: axis 1 polynomial coefficient.
 	  i = 1;
 	  dssflag = 3;
 	
@@ -1484,7 +1481,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^AMDY	{
-	  /* DSS: axis 2 polynomial coefficient. */
+	  // DSS: axis 2 polynomial coefficient.
 	  i = 2;
 	  dssflag = 3;
 	
@@ -1493,7 +1490,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 ^WAT[12]_{Z3} {
-	  /* TNX or ZPX: string-encoded data array. */
+	  // TNX or ZPX: string-encoded data array.
 	  sscanf(yytext, "WAT%d_%d", &i, &m);
 	  if (watn < m) watn = m;
 	  watflag = 1;
@@ -1539,13 +1536,13 @@ jmp_buf wcspih_abort_jmp_env;
 <CCCCCia>0{I1}{ALT}      |
 <CCCCCia>0{Z1}{I1} {
 	  if (relax & WCSHDR_reject) {
-	    /* Violates the basic FITS standard. */
+	    // Violates the basic FITS standard.
 	    errmsg = "indices in parameterized keywords must not have "
 	             "leading zeroes";
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1559,27 +1556,27 @@ jmp_buf wcspih_abort_jmp_env;
 <CCCCCia>{Z1}{ALT}" " |
 <CCCCCia>{Z2}{ALT}    |
 <CCCCCia>{Z3} {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
 
 <CCia>. {
-	  /* Let it go. */
+	  // Let it go.
 	  BEGIN(DISCARD);
 	}
 
 <CCCCCia>. {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "keyword looks very much like %s but isn't",
 	      keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Let it go. */
+	    // Let it go.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1625,7 +1622,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1640,8 +1637,8 @@ jmp_buf wcspih_abort_jmp_env;
 <CCi_ja>{Z3}_{Z2} |
 <CCi_ja>{Z2}_{Z3} |
 <CCi_ja>{Z1}_{Z4} {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
@@ -1663,7 +1660,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 <CCi_ja>{Z2}{I1}{Z2}{I1} {
-	  /* This covers the defunct forms CD00i00j and PC00i00j. */
+	  // This covers the defunct forms CD00i00j and PC00i00j.
 	  if (((altlin == 1) && (relax & WCSHDR_PC00i00j)) ||
 	      ((altlin == 2) && (relax & WCSHDR_CD00i00j))) {
 	    sscanf(yytext, "%3d%3d", &i, &j);
@@ -1678,7 +1675,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1701,14 +1698,14 @@ jmp_buf wcspih_abort_jmp_env;
 
 <CCCCCCCa>. {
 	  if (relax & WCSHDR_reject) {
-	    /* Looks too much like a FITS WCS keyword not to flag it. */
+	    // Looks too much like a FITS WCS keyword not to flag it.
 	    errmsg = errtxt;
 	    sprintf(errmsg, "invalid alternate code, keyword resembles %s "
 	      "but isn't", keyname);
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1753,7 +1750,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1768,8 +1765,8 @@ jmp_buf wcspih_abort_jmp_env;
 <CCi_ma>{Z3}_{Z2} |
 <CCi_ma>{Z2}_{Z3} |
 <CCi_ma>{Z1}_{Z4} {
-	  /* Anything that has fallen through to this point must contain */
-	  /* an invalid axis number. */
+	  // Anything that has fallen through to this point must contain
+	  // an invalid axis number.
 	  errmsg = "axis number must exceed 0";
 	  BEGIN(ERROR);
 	}
@@ -1813,7 +1810,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(ERROR);
 	
 	  } else {
-	    /* Pretend we don't recognize it. */
+	    // Pretend we don't recognize it.
 	    BEGIN(DISCARD);
 	  }
 	}
@@ -1856,7 +1853,7 @@ jmp_buf wcspih_abort_jmp_env;
 
 <SIP2>{Z1}_{Z1}"   " |
 <SIP3>{Z1}_{Z1}"  " {
-	  /* SIP keywords. */
+	  // SIP keywords.
 	  valtype = FLOAT;
 	  distype = PRIOR;
 	  vptr    = &(distem.dp);
@@ -1876,7 +1873,7 @@ jmp_buf wcspih_abort_jmp_env;
 
 <DSSAMDXY>{I1}"   " |
 <DSSAMDXY>{I2}"  " {
-	  /* DSS keywords. */
+	  // DSS keywords.
 	  valtype = FLOAT;
 	  distype = SEQUENT;
 	  vptr    = &(distem.dp);
@@ -1894,9 +1891,9 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 <PLTDECSN>=" "+{STRING} {
-	  /* Special handling for this iconic DSS keyword. */
+	  // Special handling for this iconic DSS keyword.
 	  if (1 < ipass) {
-	    /* Look for a minus sign. */
+	    // Look for a minus sign.
 	    sscanf(yytext, "= '%s", strtmp);
 	    dbltmp = strcmp(strtmp, "-") ? 1.0 : -1.0;
 	  }
@@ -1909,7 +1906,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 <VALUE>=" "+ {
-	  /* Do checks on i, j & m. */
+	  // Do checks on i, j & m.
 	  if (99 < i || 99 < j || 99 < m) {
 	    if (relax & WCSHDR_reject) {
 	      if (99 < i || 99 < j) {
@@ -1920,7 +1917,7 @@ jmp_buf wcspih_abort_jmp_env;
 	      BEGIN(ERROR);
 	
 	    } else {
-	      /* Pretend we don't recognize it. */
+	      // Pretend we don't recognize it.
 	      BEGIN(DISCARD);
 	    }
 	
@@ -1954,7 +1951,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    sscanf(yytext, "%d", &inttmp);
 	
 	    BEGIN(COMMENT);
@@ -1971,7 +1968,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    wcsutil_str2double(yytext, &dbltmp);
 
 	    if (chekval && chekval(dbltmp)) {
@@ -1993,7 +1990,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue as integer and fractional parts. */
+	    // Read the keyvalue as integer and fractional parts.
 	    wcsutil_str2double2(yytext, dbl2tmp);
 	
 	    BEGIN(COMMENT);
@@ -2010,10 +2007,10 @@ jmp_buf wcspih_abort_jmp_env;
 	    BEGIN(COMMENT);
 	
 	  } else {
-	    /* Read the keyvalue. */
+	    // Read the keyvalue.
 	    strcpy(strtmp, yytext+1);
 	
-	    /* Squeeze out repeated quotes. */
+	    // Squeeze out repeated quotes.
 	    ix = 0;
 	    for (jx = 0; jx < 72; jx++) {
 	      if (ix < jx) {
@@ -2097,16 +2094,16 @@ jmp_buf wcspih_abort_jmp_env;
 
 <COMMENT>{INLINE}$ {
 	  if (ipass == 1) {
-	    /* Do first-pass bookkeeping. */
+	    // Do first-pass bookkeeping.
 	    wcspih_pass1(naxis, i, j, a, distype, alts, dpq, npptr);
 	    BEGIN(FLUSH);
 	
 	  } else if (*wcs) {
-	    /* Store the value now that the keyrecord has been validated. */
+	    // Store the value now that the keyrecord has been validated.
 	    gotone = 0;
 	    for (ialt = 0; ialt < *nwcs; ialt++) {
-	      /* The loop here is for keywords that apply */
-	      /* to every alternate; these have a == 0. */
+	      // The loop here is for keywords that apply
+	      // to every alternate; these have a == 0.
 	      if (a >= 'A') {
 	        ialt = alts[a-'A'+1];
 	        if (ialt < 0) break;
@@ -2115,11 +2112,11 @@ jmp_buf wcspih_abort_jmp_env;
 	
 	      if (vptr) {
 	        if (sipflag) {
-	          /* Translate a SIP keyword into DPja. */
+	          // Translate a SIP keyword into DPja.
 	          disp = (*wcs)->lin.dispre;
 	          ipx = (disp->ndp)++;
 	
-	          /* SIP doesn't have alternates. */
+	          // SIP doesn't have alternates.
 	          sprintf(keyword, "DP%d", i);
 	          sprintf(strtmp, "SIP.%s.%d_%d", (sipflag==2)?"FWD":"REV",
 	                  p, q);
@@ -2130,27 +2127,27 @@ jmp_buf wcspih_abort_jmp_env;
 	          }
 	
 	        } else if (dssflag) {
-	          /* All DSS keywords require special handling. */
+	          // All DSS keywords require special handling.
 	          if (dssflag == 1) {
-	            /* Temporary parameter for DSS used by wcspih_final(). */
+	            // Temporary parameter for DSS used by wcspih_final().
 	            *((double *)vptr) = dbltmp;
 	
 	          } else if (dssflag == 2) {
-	            /* Temporary parameter for DSS used by wcspih_final(). */
+	            // Temporary parameter for DSS used by wcspih_final().
 	            strcpy((char *)vptr, strtmp);
 	
 	          } else {
-	            /* Translate a DSS keyword into DQia. */
+	            // Translate a DSS keyword into DQia.
 	            if (m <= 13 || dbltmp != 0.0) {
 	              disp = (*wcs)->lin.disseq;
 	              ipx = (disp->ndp)++;
 	
-	              /* DSS doesn't have alternates. */
+	              // DSS doesn't have alternates.
 	              sprintf(keyword, "DQ%d", i);
 	              sprintf(strtmp, "DSS.AMD.%d", m);
 	              dpfill(disp->dp+ipx, keyword, strtmp, i, 1, 0, dbltmp);
 	
-	              /* Also required by wcspih_final(). */
+	              // Also required by wcspih_final().
 	              if (m <= 3) {
 	                dsstmp[13+(i-1)*3+m] = dbltmp;
 	              }
@@ -2158,32 +2155,32 @@ jmp_buf wcspih_abort_jmp_env;
 	          }
 	
 	        } else if (watflag) {
-	          /* String array for TNX and ZPX used by wcspih_final(). */
+	          // String array for TNX and ZPX used by wcspih_final().
 	          strcpy((char *)vptr, strtmp);
 	
 	        } else {
-	          /* An "ordinary" keyword. */
+	          // An "ordinary" keyword.
 	          wcsp = *wcs + ialt;
 	          if (auxprm) {
-	            /* Additional auxiliary parameter. */
+	            // Additional auxiliary parameter.
 	            auxp = wcsp->aux;
 	            voff = (char *)vptr - (char *)(&auxtem);
 	            wptr = (void *)((char *)auxp + voff);
 	
 	          } else if (distype) {
-	            /* Distortion parameter of some kind. */
+	            // Distortion parameter of some kind.
 	            if (distype == PRIOR) {
-	              /* Prior distortion. */
+	              // Prior distortion.
 	              disp = wcsp->lin.dispre;
 	            } else {
-	              /* Sequent distortion. */
+	              // Sequent distortion.
 	              disp = wcsp->lin.disseq;
 	            }
 	            voff = (char *)vptr - (char *)(&distem);
 	            wptr = (void *)((char *)disp + voff);
 	
 	          } else {
-	            /* A parameter that lives directly in wcsprm. */
+	            // A parameter that lives directly in wcsprm.
 	            voff = (char *)vptr - (char *)(&wcstem);
 	            wptr = (void *)((char *)wcsp + voff);
 	          }
@@ -2192,7 +2189,7 @@ jmp_buf wcspih_abort_jmp_env;
 	            *((int *)wptr) = inttmp;
 	
 	          } else if (valtype == FLOAT) {
-	            /* Apply keyword parameterization. */
+	            // Apply keyword parameterization.
 	            if (npptr == npv) {
 	              ipx = (wcsp->npv)++;
 	              wcsp->pv[ipx].i = i;
@@ -2213,14 +2210,14 @@ jmp_buf wcspih_abort_jmp_env;
 	              *((double *)wptr) = dbltmp;
 	            }
 	
-	            /* Flag presence of PCi_ja, or CDi_ja and/or CROTAia. */
+	            // Flag presence of PCi_ja, or CDi_ja and/or CROTAia.
 	            if (altlin) {
 	              wcsp->altlin |= altlin;
 	              altlin = 0;
 	            }
 	
 	          } else if (valtype == FLOAT2) {
-	            /* Split MJDREF and JDREF into integer and fraction.*/
+	            // Split MJDREF and JDREF into integer and fraction.
 	            if (special) {
 	              special(wptr, dbl2tmp);
 	            } else {
@@ -2229,7 +2226,7 @@ jmp_buf wcspih_abort_jmp_env;
 	            }
 	
 	          } else if (valtype == STRING) {
-	            /* Apply keyword parameterization. */
+	            // Apply keyword parameterization.
 	            if (npptr == nps) {
 	              ipx = (wcsp->nps)++;
 	              wcsp->ps[ipx].i = i;
@@ -2312,7 +2309,7 @@ jmp_buf wcspih_abort_jmp_env;
 <DISCARD>.*$ {
 	  if (ipass == npass) {
 	    if (ctrl < 0) {
-	      /* Preserve discards. */
+	      // Preserve discards.
 	      keep = keyrec;
 	
 	    } else if (2 < ctrl) {
@@ -2329,7 +2326,7 @@ jmp_buf wcspih_abort_jmp_env;
 	    (*nreject)++;
 	
 	    if (ctrl%10 == -1) {
-	      /* Preserve rejects. */
+	      // Preserve rejects.
 	      keep = keyrec;
 	    }
 	
@@ -2351,7 +2348,7 @@ jmp_buf wcspih_abort_jmp_env;
 	
 	  naux += auxprm;
 	
-	  /* Throw away the rest of the line and reset for the next one. */
+	  // Throw away the rest of the line and reset for the next one.
 	  i = j = 0;
 	  m = 0;
 	  a = ' ';
@@ -2376,7 +2373,7 @@ jmp_buf wcspih_abort_jmp_env;
 	}
 
 <<EOF>>	 {
-	  /* End-of-input. */
+	  // End-of-input.
 	  if (ipass == 1) {
 	    if ((status = wcspih_init1(naxis, alts, dpq, npv, nps, ndp, ndq,
 	                               naux, distran, nwcs, wcs)) ||
@@ -2467,8 +2464,8 @@ void wcspih_pass1(
   int *npptr)
 
 {
-  /* On the first pass alts[] is used to determine the number of axes */
-  /* for each of the 27 possible alternate coordinate descriptions.   */
+  // On the first pass alts[] is used to determine the number of axes
+  // for each of the 27 possible alternate coordinate descriptions.
   int ialt, *ip;
 
   if (a == 0) {
@@ -2486,7 +2483,7 @@ void wcspih_pass1(
     *ip = naxis;
   }
 
-  /* i or j can be greater than naxis. */
+  // i or j can be greater than naxis.
   if (*ip < i) {
     *ip = i;
   }
@@ -2495,10 +2492,10 @@ void wcspih_pass1(
     *ip = j;
   }
 
-  /* Type of distortions present. */
+  // Type of distortions present.
   dpq[ialt] |= distype;
 
-  /* Count PVi_ma, PSi_ma, DPja, or DQia keywords. */
+  // Count PVi_ma, PSi_ma, DPja, or DQia keywords.
   if (npptr) {
     npptr[ialt]++;
   }
@@ -2528,37 +2525,37 @@ int wcspih_init1(
   struct wcsprm *wcsp;
   struct disprm *dis;
 
-  /* Find the number of coordinate descriptions. */
+  // Find the number of coordinate descriptions.
   *nwcs = 0;
   for (ialt = 0; ialt < 27; ialt++) {
     if (alts[ialt]) (*nwcs)++;
   }
 
   if ((defaults = !(*nwcs) && naxis)) {
-    /* NAXIS is non-zero but there were no WCS keywords with an alternate
-       version code; create a default WCS with blank alternate version. */
+    // NAXIS is non-zero but there were no WCS keywords with an alternate
+    // version code; create a default WCS with blank alternate version.
     wcspih_pass1(naxis, 0, 0, ' ', 0, alts, dpq, 0x0);
     *nwcs = 1;
   }
 
   if (*nwcs) {
-    /* Allocate memory for the required number of wcsprm structs. */
+    // Allocate memory for the required number of wcsprm structs.
     if ((*wcs = calloc(*nwcs, sizeof(struct wcsprm))) == 0x0) {
       return WCSHDRERR_MEMORY;
     }
 
     ndis = 0;
     if (distran == SIP) {
-      /* DPja.NAXES and DPja.OFFSET.j to be added for SIP (see below and
-         wcspih_final()). */
+      // DPja.NAXES and DPja.OFFSET.j to be added for SIP (see below and
+      // wcspih_final()).
       ndp[0] += 6;
 
     } else if (distran == DSS) {
-      /* DPja.NAXES to be added for DSS (see below and wcspih_final()). */
+      // DPja.NAXES to be added for DSS (see below and wcspih_final()).
       ndq[0] += 2;
     }
 
-    /* Initialize each wcsprm struct. */
+    // Initialize each wcsprm struct.
     wcsp = *wcs;
     *nwcs = 0;
     for (ialt = 0; ialt < 27; ialt++) {
@@ -2571,30 +2568,30 @@ int wcspih_init1(
           break;
         }
 
-        /* Record the alternate version code. */
+        // Record the alternate version code.
         if (ialt) {
           wcsp->alt[0] = 'A' + ialt - 1;
         }
 
-        /* Record in wcsname whether this is a default description. */
+        // Record in wcsname whether this is a default description.
         if (defaults) {
           strcpy(wcsp->wcsname, "DEFAULTS");
         }
 
-        /* Any additional auxiliary keywords present? */
+        // Any additional auxiliary keywords present?
         if (naux) {
           if (wcsauxi(1, wcsp)) {
             return WCSHDRERR_MEMORY;
           }
         }
 
-        /* Any distortions present? */
+        // Any distortions present?
         if (dpq[ialt] & 1) {
           if ((dis = calloc(1, sizeof(struct disprm))) == 0x0) {
             return WCSHDRERR_MEMORY;
           }
 
-          /* Attach it to linprm.  Also inits it. */
+          // Attach it to linprm.  Also inits it.
           ndis++;
           ndpmax = ndp[ialt];
           dis->flag = -1;
@@ -2606,33 +2603,33 @@ int wcspih_init1(
             return WCSHDRERR_MEMORY;
           }
 
-          /* Attach it to linprm.  Also inits it. */
+          // Attach it to linprm.  Also inits it.
           ndis++;
           ndpmax = ndq[ialt];
           dis->flag = -1;
           lindist(2, &(wcsp->lin), dis, ndpmax);
         }
 
-        /* On the second pass alts[] indexes the array of wcsprm structs. */
+        // On the second pass alts[] indexes the array of wcsprm structs.
         alts[ialt] = (*nwcs)++;
 
         wcsp++;
 
       } else {
-        /* Signal that there is no wcsprm for this alt. */
+        // Signal that there is no wcsprm for this alt.
         alts[ialt] = -1;
       }
     }
 
 
-    /* Translated distortion?  Neither SIP nor DSS have alternates, so the */
-    /* presence of keywords for either (not both together), as flagged by  */
-    /* distran, necessarily refers to the primary representation.          */
+    // Translated distortion?  Neither SIP nor DSS have alternates, so the
+    // presence of keywords for either (not both together), as flagged by
+    // distran, necessarily refers to the primary representation.
     if (distran == SIP) {
       strcpy((*wcs)->lin.dispre->dtype[0], "SIP");
       strcpy((*wcs)->lin.dispre->dtype[1], "SIP");
 
-      /* SIP doesn't have axis mapping. */
+      // SIP doesn't have axis mapping.
       (*wcs)->lin.dispre->ndp = 6;
       dpfill((*wcs)->lin.dispre->dp,   "DP1", "NAXES",  0, 0, 2, 0.0);
       dpfill((*wcs)->lin.dispre->dp+3, "DP2", "NAXES",  0, 0, 2, 0.0);
@@ -2641,7 +2638,7 @@ int wcspih_init1(
       strcpy((*wcs)->lin.disseq->dtype[0], "DSS");
       strcpy((*wcs)->lin.disseq->dtype[1], "DSS");
 
-      /* The Paper IV translation of DSS doesn't require an axis mapping. */
+      // The Paper IV translation of DSS doesn't require an axis mapping.
       (*wcs)->lin.disseq->ndp = 2;
       dpfill((*wcs)->lin.disseq->dp,   "DQ1", "NAXES",  0, 0, 2, 0.0);
       dpfill((*wcs)->lin.disseq->dp+1, "DQ2", "NAXES",  0, 0, 2, 0.0);
@@ -2659,7 +2656,7 @@ int wcspih_init1(
 int wcspih_jdref(double *mjdref, const double *jdref)
 
 {
-  /* Set MJDREF from JDREF. */
+  // Set MJDREF from JDREF.
   if (undefined(mjdref[0] && undefined(mjdref[1]))) {
     mjdref[0] = jdref[0] - 2400000.0;
     mjdref[1] = jdref[1] - 0.5;
@@ -2676,7 +2673,7 @@ int wcspih_jdref(double *mjdref, const d
 int wcspih_jdrefi(double *mjdref, const double *jdrefi)
 
 {
-  /* Set the integer part of MJDREF from JDREFI. */
+  // Set the integer part of MJDREF from JDREFI.
   if (undefined(mjdref[0])) {
     mjdref[0] = *jdrefi - 2400000.5;
   }
@@ -2688,7 +2685,7 @@ int wcspih_jdrefi(double *mjdref, const
 int wcspih_jdreff(double *mjdref, const double *jdreff)
 
 {
-  /* Set the fractional part of MJDREF from JDREFF. */
+  // Set the fractional part of MJDREF from JDREFF.
   if (undefined(mjdref[1])) {
     mjdref[1] = *jdreff;
   }
@@ -2704,7 +2701,7 @@ int wcspih_jdreff(double *mjdref, const
 int wcspih_epoch(double *equinox, const double *epoch)
 
 {
-  /* If EQUINOXa is currently undefined then set it from EPOCHa. */
+  // If EQUINOXa is currently undefined then set it from EPOCHa.
   if (undefined(*equinox)) {
     *equinox = *epoch;
   }
@@ -2722,9 +2719,9 @@ int wcspih_vsource(double *zsource, cons
 {
   double beta, c = 299792458.0;
 
-  /* If ZSOURCEa is currently undefined then set it from VSOURCEa. */
+  // If ZSOURCEa is currently undefined then set it from VSOURCEa.
   if (undefined(*zsource)) {
-    /* Convert relativistic Doppler velocity to redshift. */
+    // Convert relativistic Doppler velocity to redshift.
     beta = *vsource/c;
     *zsource = (1.0 + beta)/sqrt(1.0 - beta*beta) - 1.0;
   }
@@ -2766,23 +2763,23 @@ int wcspih_final(
   struct wcsprm *wcsp;
 
   for (ialt = 0; ialt < *nwcs; ialt++) {
-    /* Interpret -TAB header keywords. */
+    // Interpret -TAB header keywords.
     if ((status = wcstab(*wcs+ialt))) {
        wcsvfree(nwcs, wcs);
        return status;
     }
 
     if (ndp[ialt] && ndq[ialt]) {
-      /* Prior and sequent distortions co-exist in this representation;
-         ensure the latter gets DVERRa. */
+      // Prior and sequent distortions co-exist in this representation;
+      // ensure the latter gets DVERRa.
       (*wcs+ialt)->lin.disseq->totdis = (*wcs+ialt)->lin.dispre->totdis;
     }
   }
 
-  /* Translated distortion functions; apply only to the primary WCS. */
+  // Translated distortion functions; apply only to the primary WCS.
   wcsp = *wcs;
   if (distran == SIP) {
-    /* SIP doesn't have alternates, nor axis mapping. */
+    // SIP doesn't have alternates, nor axis mapping.
     disp = wcsp->lin.dispre;
     dpfill(disp->dp+1, "DP1", "OFFSET.1",  0, 1, 0, wcsp->crpix[0]);
     dpfill(disp->dp+2, "DP1", "OFFSET.2",  0, 1, 0, wcsp->crpix[1]);
@@ -2790,8 +2787,8 @@ int wcspih_final(
     dpfill(disp->dp+5, "DP2", "OFFSET.2",  0, 1, 0, wcsp->crpix[1]);
 
   } else if (distran == DSS) {
-    /* DSS doesn't have alternates, nor axis mapping.  This translation */
-    /* follows Paper IV, Sect. 5.2 using the same variable names.       */
+    // DSS doesn't have alternates, nor axis mapping.  This translation
+    // follows Paper IV, Sect. 5.2 using the same variable names.
     CNPIX1 = dsstmp[0];
     CNPIX2 = dsstmp[1];
 
@@ -2833,17 +2830,17 @@ int wcspih_final(
 
     sprintf(wcsp->wcsname, "DSS PLATEID %.4s", (char *)(dsstmp+13));
 
-    /* Erase the approximate WCS provided in modern DSS headers. */
+    // Erase the approximate WCS provided in modern DSS headers.
     wcsp->cd[0] = 0.0;
     wcsp->cd[1] = 0.0;
     wcsp->cd[2] = 0.0;
     wcsp->cd[3] = 0.0;
 
   } else if (distran == WAT) {
-    /* TNX and ZPX don't have alternates, nor axis mapping. */
+    // TNX and ZPX don't have alternates, nor axis mapping.
     disp = wcsp->lin.disseq;
 
-    /* Disassemble the core dump stored in the WATi_m strings. */
+    // Disassemble the core dump stored in the WATi_m strings.
     nterms = 0;
     for (i = 0; i < 2; i++) {
       sscanf(wat[i], "wtype=%s", wtype);
@@ -2853,22 +2850,22 @@ int wcspih_final(
       } else if (strcmp(wtype, "zpx") == 0) {
         strcpy(disp->dtype[i], "WAT-ZPX");
       } else {
-        /* Could contain "tan" or something else to be ignored. */
+        // Could contain "tan" or something else to be ignored.
         lindist(2, &(wcsp->lin), 0x0, 0);
         return 0;
       }
 
-      /* The PROJPn parameters are duplicated on each ZPX axis. */
+      // The PROJPn parameters are duplicated on each ZPX axis.
       if (i == 1 && strcmp(wtype, "zpx") == 0) {
-        /* Take those on the second (latitude) axis ignoring the other. */
-        /* First we have to count them and allocate space in wcsprm.    */
+        // Take those on the second (latitude) axis ignoring the other.
+        // First we have to count them and allocate space in wcsprm.
         wp  = wat[i];
         for (npv = 0; npv < 30; npv++) {
           if ((wp = strstr(wp, "projp")) == 0x0) break;
           wp += 5;
         }
 
-        /* Allocate space. */
+        // Allocate space.
         if (npv) {
           wcsp->npvmax += npv;
           wcsp->pv = realloc(wcsp->pv, wcsp->npvmax*sizeof(struct pvcard));
@@ -2879,7 +2876,7 @@ int wcspih_final(
           wcsp->m_pv = wcsp->pv;
         }
 
-        /* Copy the values. */
+        // Copy the values.
         wp = wat[i];
         for (ipv = wcsp->npv; ipv < wcsp->npvmax; ipv++) {
           if ((wp = strstr(wp, "projp")) == 0x0) break;
@@ -2895,7 +2892,7 @@ int wcspih_final(
         wcsp->npv += npv;
       }
 
-      /* Read the control parameters. */
+      // Read the control parameters.
       if ((wp = strchr(wat[i], '"')) == 0x0) {
         return WCSHDRERR_PARSER;
       }
@@ -2909,24 +2906,24 @@ int wcspih_final(
         wp++;
       }
 
-      /* How many coefficients are we expecting? */
+      // How many coefficients are we expecting?
       omin = (wctrl[1] < wctrl[2]) ? wctrl[1] : wctrl[2];
       omax = (wctrl[1] < wctrl[2]) ? wctrl[2] : wctrl[1];
       if (wctrl[3] == 0) {
-        /* No cross terms. */
+        // No cross terms.
         nterms += omin + omax;
 
       } else if (wctrl[3] == 1) {
-        /* Full cross terms. */
+        // Full cross terms.
         nterms += omin*omax;
 
       } else if (wctrl[3] == 2) {
-        /* Half cross terms. */
+        // Half cross terms.
         nterms += omin*omax - omin*(omin-1)/2;
       }
     }
 
-    /* Allocate memory for dpkeys. */
+    // Allocate memory for dpkeys.
     ndq[0] += 2*(1 + 1 + 4) + nterms;
 
     disp->ndpmax += ndq[0];
@@ -2938,12 +2935,12 @@ int wcspih_final(
     disp->m_dp = disp->dp;
 
 
-    /* Populate dpkeys. */
+    // Populate dpkeys.
     idp = disp->ndp;
     for (i = 0; i < 2; i++) {
       dpfill(disp->dp+(idp++), "DQ", "NAXES", i+1, 0, 2, 0.0);
 
-      /* Read the control parameters. */
+      // Read the control parameters.
       if ((wp = strchr(wat[i], '"')) == 0x0) {
         return WCSHDRERR_PARSER;
       }
@@ -2957,23 +2954,23 @@ int wcspih_final(
         wp++;
       }
 
-      /* Polynomial type. */
+      // Polynomial type.
       dpfill(disp->dp+(idp++), "DQ", "WAT.POLY", i+1, 0, wctrl[0], 0.0);
       if (wctrl[0] == 1) {
-        /* Chebyshev polynomial. */
+        // Chebyshev polynomial.
         strcpy(wpoly, "CHBY");
       } else if (wctrl[0] == 2) {
-        /* Legendre polynomial. */
+        // Legendre polynomial.
         strcpy(wpoly, "LEGR");
       } else if (wctrl[0] == 3) {
-        /* Polynomial is the sum of monomials. */
+        // Polynomial is the sum of monomials.
         strcpy(wpoly, "MONO");
       } else {
-        /* Unknown code. */
+        // Unknown code.
         strcpy(wpoly, "UNKN");
       }
 
-      /* Read the scaling parameters. */
+      // Read the scaling parameters.
       for (m = 0; m < 4; m++) {
         sscanf(wp, "%lf", &wval);
         sprintf(field, "WAT.%c%s", (m<2)?'X':'Y', (m%2)?"MAX":"MIN");
@@ -2985,7 +2982,7 @@ int wcspih_final(
         wp++;
       }
 
-      /* Read the coefficients. */
+      // Read the coefficients.
       for (n = 0; n < wctrl[2]; n++) {
         for (m = 0; m < wctrl[1]; m++) {
           if (wctrl[3] == 0) {
Index: astropy-4.2/cextern/wcslib/C/wcsprintf.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsprintf.c
+++ astropy-4.2/cextern/wcslib/C/wcsprintf.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsprintf.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsprintf.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <stdarg.h>
@@ -36,27 +33,27 @@ static char  *wcsprintf_buff = 0x0;
 static char  *wcsprintf_bufp = 0x0;
 static size_t wcsprintf_size = 0;
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsprintf_set(FILE *wcsout)
 
 {
   if (wcsout != 0x0) {
-    /* Output to file. */
+    // Output to file.
     wcsprintf_file = wcsout;
 
     if (wcsprintf_buff != 0x0) {
-      /* Release the buffer. */
+      // Release the buffer.
       free(wcsprintf_buff);
       wcsprintf_buff = 0x0;
     }
 
   } else {
-    /* Output to buffer. */
+    // Output to buffer.
     wcsprintf_file = 0x0;
 
     if (wcsprintf_buff == 0x0) {
-      /* Allocate a buffer. */
+      // Allocate a buffer.
       wcsprintf_buff = malloc(1024);
       if (wcsprintf_buff == NULL) {
         return 1;
@@ -64,7 +61,7 @@ int wcsprintf_set(FILE *wcsout)
       wcsprintf_size = 1024;
     }
 
-    /* Reset pointer to the start of the buffer. */
+    // Reset pointer to the start of the buffer.
     wcsprintf_bufp = wcsprintf_buff;
     *wcsprintf_bufp = '\0';
   }
@@ -72,7 +69,7 @@ int wcsprintf_set(FILE *wcsout)
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 const char *wcsprintf_buf(void)
 
@@ -80,7 +77,7 @@ const char *wcsprintf_buf(void)
   return wcsprintf_buff;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsprintf(const char *format, ...)
 
@@ -91,21 +88,21 @@ int wcsprintf(const char *format, ...)
   va_list arg_list;
 
   if (wcsprintf_buff == 0x0 && wcsprintf_file == 0x0) {
-    /* Send output to stdout if wcsprintf_set() hasn't been called. */
+    // Send output to stdout if wcsprintf_set() hasn't been called.
     wcsprintf_file = stdout;
   }
 
   va_start(arg_list, format);
 
   if (wcsprintf_file) {
-    /* Output to file. */
+    // Output to file.
     nbytes = vfprintf(wcsprintf_file, format, arg_list);
 
   } else {
-    /* Output to buffer. */
+    // Output to buffer.
     used = wcsprintf_bufp - wcsprintf_buff;
     if (wcsprintf_size - used < 128) {
-      /* Expand the buffer. */
+      // Expand the buffer.
       wcsprintf_size += 1024;
       realloc_buff = realloc(wcsprintf_buff, wcsprintf_size);
       if (realloc_buff == NULL) {
@@ -126,7 +123,7 @@ int wcsprintf(const char *format, ...)
   return nbytes;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsfprintf(FILE *stream, const char *format, ...)
 
@@ -137,21 +134,21 @@ int wcsfprintf(FILE *stream, const char
   va_list arg_list;
 
   if (wcsprintf_buff == 0x0 && wcsprintf_file == 0x0) {
-    /* Send output to stream if wcsprintf_set() hasn't been called. */
+    // Send output to stream if wcsprintf_set() hasn't been called.
     wcsprintf_file = stream;
   }
 
   va_start(arg_list, format);
 
   if (wcsprintf_file) {
-    /* Output to file. */
+    // Output to file.
     nbytes = vfprintf(wcsprintf_file, format, arg_list);
 
   } else {
-    /* Output to buffer. */
+    // Output to buffer.
     used = wcsprintf_bufp - wcsprintf_buff;
     if (wcsprintf_size - used < 128) {
-      /* Expand the buffer. */
+      // Expand the buffer.
       wcsprintf_size += 1024;
       realloc_buff = realloc(wcsprintf_buff, wcsprintf_size);
       if (realloc_buff == NULL) {
Index: astropy-4.2/cextern/wcslib/C/wcsprintf.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsprintf.h
+++ astropy-4.2/cextern/wcslib/C/wcsprintf.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsprintf.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsprintf.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -150,4 +147,4 @@ const char *wcsprintf_buf(void);
 }
 #endif
 
-#endif /* WCSLIB_WCSPRINTF */
+#endif // WCSLIB_WCSPRINTF
Index: astropy-4.2/cextern/wcslib/C/wcstrig.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcstrig.c
+++ astropy-4.2/cextern/wcslib/C/wcstrig.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcstrig.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcstrig.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
@@ -52,7 +49,7 @@ double cosd(double angle)
   return cos(angle*D2R);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double sind(double angle)
 
@@ -76,7 +73,7 @@ double sind(double angle)
   return sin(angle*D2R);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void sincosd(double angle, double *s, double *c)
 
@@ -115,7 +112,7 @@ void sincosd(double angle, double *s, do
   return;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double tand(double angle)
 
@@ -134,7 +131,7 @@ double tand(double angle)
   return tan(angle*D2R);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double acosd(double v)
 
@@ -150,7 +147,7 @@ double acosd(double v)
   return acos(v)*R2D;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double asind(double v)
 
@@ -166,7 +163,7 @@ double asind(double v)
   return asin(v)*R2D;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double atand(double v)
 
@@ -182,7 +179,7 @@ double atand(double v)
   return atan(v)*R2D;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 double atan2d(double y, double x)
 
Index: astropy-4.2/cextern/wcslib/C/wcstrig.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcstrig.h
+++ astropy-4.2/cextern/wcslib/C/wcstrig.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcstrig.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcstrig.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -175,7 +172,7 @@ extern "C" {
 
 #ifdef WCSTRIG_MACRO
 
-/* Macro implementation of the trigd functions. */
+// Macro implementation of the trigd functions.
 #include "wcsmath.h"
 
 #define cosd(X) cos((X)*D2R)
@@ -193,7 +190,7 @@ extern "C" {
 
 #else
 
-/* Use WCSLIB wrappers or native trigd functions. */
+// Use WCSLIB wrappers or native trigd functions.
 
 double cosd(double angle);
 double sind(double angle);
@@ -204,14 +201,14 @@ double asind(double y);
 double atand(double s);
 double atan2d(double y, double x);
 
-/* Domain tolerance for asin() and acos() functions. */
+// Domain tolerance for asin() and acos() functions.
 #define WCSTRIG_TOL 1e-10
 
-#endif /* WCSTRIG_MACRO */
+#endif // WCSTRIG_MACRO
 
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* WCSLIB_WCSTRIG */
+#endif // WCSLIB_WCSTRIG
Index: astropy-4.2/cextern/wcslib/C/wcsulex.l
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsulex.l
+++ astropy-4.2/cextern/wcslib/C/wcsulex.l
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsulex.l,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsulex.l,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
 * wcsulex.l is a Flex description file containing the definition of a
@@ -98,7 +95,7 @@ static int wcsulex_scanner(const char un
                            double units[WCSUNITS_NTYPE], struct wcserr **err,
                            yyscan_t yyscanner);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsulexe(
   const char unitstr[],
@@ -120,16 +117,16 @@ int wcsulexe(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define YY_DECL int wcsulex_scanner(const char unitstr[], int *func, \
  double *scale, double units[WCSUNITS_NTYPE], struct wcserr **err, \
  yyscan_t yyscanner)
 
-/* Dummy definition to circumvent compiler warnings. */
+// Dummy definition to circumvent compiler warnings.
 #define YY_INPUT(inbuff, count, bufsize) { count = YY_NULL; }
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
+// Used in preempting the call to exit() by yy_fatal_error().
 jmp_buf wcsulex_abort_jmp_env;
 #define exit(status) longjmp(wcsulex_abort_jmp_env, status)
 
@@ -160,14 +157,14 @@ jmp_buf wcsulex_abort_jmp_env;
 	factor = 1.0;
 	*scale = 1.0;
 	
-	/* Avert a flex-induced memory leak. */
+	// Avert a flex-induced memory leak.
 	if (YY_CURRENT_BUFFER && YY_CURRENT_BUFFER->yy_input_file == stdin) {
 	  yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
 	}
 	
 	yy_scan_string(unitstr, yyscanner);
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
+	// Return here via longjmp() invoked by yy_fatal_error().
 	if (setjmp(wcsulex_abort_jmp_env)) {
 	  return wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
@@ -180,7 +177,7 @@ jmp_buf wcsulex_abort_jmp_env;
 	#endif
 
 ^" "+	{
-	  /* Pretend initial whitespace doesn't exist. */
+	  // Pretend initial whitespace doesn't exist.
 	  yy_set_bol(1);
 	}
 
@@ -222,13 +219,13 @@ jmp_buf wcsulex_abort_jmp_env;
 	}
 
 ^[*.]	{
-	  /* Leading binary multiply. */
+	  // Leading binary multiply.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_DANGLING_BINOP),
 	    "Dangling binary operator in '%s'", unitstr);
 	  BEGIN(FLUSH);
 	}
 
-" "+	  /* Discard whitespace in INITIAL context. */
+" "+	  // Discard whitespace in INITIAL context.
 
 sqrt" "*"(" {
 	  expon /= 2.0;
@@ -237,7 +234,7 @@ sqrt" "*"(" {
 	}
 
 "("	{
-	  /* Gather terms in parentheses. */
+	  // Gather terms in parentheses.
 	  yyless(0);
 	  BEGIN(PAREN);
 	}
@@ -291,11 +288,11 @@ sqrt" "*"(" {
 <PAREN>")" {
 	  paren--;
 	  if (paren) {
-	    /* Not balanced yet. */
+	    // Not balanced yet.
 	    yymore();
 	
 	  } else {
-	    /* Balanced; strip off the outer parentheses and recurse. */
+	    // Balanced; strip off the outer parentheses and recurse.
 	    yytext[yyleng-1] = '\0';
 	
 	    buf = YY_CURRENT_BUFFER;
@@ -421,125 +418,125 @@ sqrt" "*"(" {
 	}
 
 <PREFIX>. {
-	  /* Internal parser error. */
+	  // Internal parser error.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
 	  BEGIN(FLUSH);
 	}
 
 <UNITS>A {
-	  /* Ampere. */
+	  // Ampere.
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  types[WCSUNITS_TIME]   -= 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>a|yr {
-	  /* Julian year (annum). */
+	  // Julian year (annum).
 	  factor *= 31557600.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>adu {
-	  /* Analogue-to-digital converter units. */
+	  // Analogue-to-digital converter units.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>[Aa]ngstrom {
-	  /* Angstrom. */
+	  // Angstrom.
 	  factor *= 1e-10;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>arcmin {
-	  /* Minute of arc. */
+	  // Minute of arc.
 	  factor /= 60.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>arcsec {
-	  /* Second of arc. */
+	  // Second of arc.
 	  factor /= 3600.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>AU {
-	  /* Astronomical unit. */
+	  // Astronomical unit.
 	  factor *= 1.49598e+11;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>barn {
-	  /* Barn. */
+	  // Barn.
 	  factor *= 1e-28;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>beam {
-	  /* Beam, as in Jy/beam. */
+	  // Beam, as in Jy/beam.
 	  types[WCSUNITS_BEAM] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>bin {
-	  /* Bin (e.g. histogram). */
+	  // Bin (e.g. histogram).
 	  types[WCSUNITS_BIN] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>bit {
-	  /* Bit. */
+	  // Bit.
 	  types[WCSUNITS_BIT] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>[bB]yte {
-	  /* Byte. */
+	  // Byte.
 	  factor *= 8.0;
 	  types[WCSUNITS_BIT] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>C {
-	  /* Coulomb. */
+	  // Coulomb.
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>cd {
-	  /* Candela. */
+	  // Candela.
 	  types[WCSUNITS_LUMINTEN] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>chan {
-	  /* Channel. */
+	  // Channel.
 	  types[WCSUNITS_BIN] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>count|ct {
-	  /* Count. */
+	  // Count.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>cy {
-	  /* Julian century. */
+	  // Julian century.
 	  factor *= 3155760000.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>D {
-	  /* Debye. */
+	  // Debye.
 	  factor *= 1e-29 / 3.0;
 	  types[WCSUNITS_CHARGE] += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
@@ -547,20 +544,20 @@ sqrt" "*"(" {
 	}
 
 <UNITS>d {
-	  /* Day. */
+	  // Day.
 	  factor *= 86400.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>deg {
-	  /* Degree. */
+	  // Degree.
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>erg {
-	  /* Erg. */
+	  // Erg.
 	  factor *= 1e-7;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -569,7 +566,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>eV {
-	  /* Electron volt. */
+	  // Electron volt.
 	  factor *= 1.6021765e-19;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -578,7 +575,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>F {
-	  /* Farad. */
+	  // Farad.
 	  types[WCSUNITS_MASS]   -= 1.0;
 	  types[WCSUNITS_LENGTH] -= 2.0;
 	  types[WCSUNITS_TIME]   += 3.0;
@@ -587,7 +584,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>G {
-	  /* Gauss. */
+	  // Gauss.
 	  factor *= 1e-4;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -596,14 +593,14 @@ sqrt" "*"(" {
 	}
 
 <UNITS>g {
-	  /* Gram. */
+	  // Gram.
 	  factor *= 1e-3;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>H {
-	  /* Henry. */
+	  // Henry.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   += 2.0;
@@ -612,20 +609,20 @@ sqrt" "*"(" {
 	}
 
 <UNITS>h {
-	  /* Hour. */
+	  // Hour.
 	  factor *= 3600.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>Hz {
-	  /* Hertz. */
+	  // Hertz.
 	  types[WCSUNITS_TIME] -= 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>J {
-	  /* Joule. */
+	  // Joule.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -633,7 +630,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>Jy {
-	  /* Jansky. */
+	  // Jansky.
 	  factor *= 1e-26;
 	  types[WCSUNITS_MASS] += 1.0;
 	  types[WCSUNITS_TIME] -= 2.0;
@@ -641,20 +638,20 @@ sqrt" "*"(" {
 	}
 
 <UNITS>K {
-	  /* Kelvin. */
+	  // Kelvin.
 	  types[WCSUNITS_TEMPERATURE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>lm {
-	  /* Lumen. */
+	  // Lumen.
 	  types[WCSUNITS_LUMINTEN]    += 1.0;
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>lx {
-	  /* Lux. */
+	  // Lux.
 	  types[WCSUNITS_LUMINTEN]    += 1.0;
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  types[WCSUNITS_LENGTH]      -= 2.0;
@@ -662,46 +659,46 @@ sqrt" "*"(" {
 	}
 
 <UNITS>lyr {
-	  /* Light year. */
+	  // Light year.
 	  factor *= 2.99792458e8 * 31557600.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>m {
-	  /* Metre. */
+	  // Metre.
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>mag {
-	  /* Stellar magnitude. */
+	  // Stellar magnitude.
 	  types[WCSUNITS_MAGNITUDE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>mas {
-	  /* Milli-arcsec. */
+	  // Milli-arcsec.
 	  factor /= 3600e+3;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>min {
-	  /* Minute. */
+	  // Minute.
 	  factor *= 60.0;
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>mol {
-	  /* Mole. */
+	  // Mole.
 	  types[WCSUNITS_MOLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>N {
-	  /* Newton. */
+	  // Newton.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -709,7 +706,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>[Oo]hm {
-	  /* Ohm. */
+	  // Ohm.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 1.0;
@@ -718,7 +715,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>Pa {
-	  /* Pascal. */
+	  // Pascal.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] -= 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -726,26 +723,26 @@ sqrt" "*"(" {
 	}
 
 <UNITS>pc {
-	  /* Parsec. */
+	  // Parsec.
 	  factor *= 3.0857e16;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>photon|ph {
-	  /* Photon. */
+	  // Photon.
 	  types[WCSUNITS_COUNT] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>pixel|pix {
-	  /* Pixel. */
+	  // Pixel.
 	  types[WCSUNITS_PIXEL] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>R {
-	  /* Rayleigh. */
+	  // Rayleigh.
 	  factor *= 1e10 / (4.0 * PI);
 	  types[WCSUNITS_LENGTH]      -= 2.0;
 	  types[WCSUNITS_TIME]        -= 1.0;
@@ -754,14 +751,14 @@ sqrt" "*"(" {
 	}
 
 <UNITS>rad {
-	  /* Radian. */
+	  // Radian.
 	  factor *= 180.0 / PI;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>Ry {
-	  /* Rydberg. */
+	  // Rydberg.
 	  factor *= 13.605692 * 1.6021765e-19;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -770,7 +767,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>S {
-	  /* Siemen. */
+	  // Siemen.
 	  types[WCSUNITS_MASS]   -= 1.0;
 	  types[WCSUNITS_LENGTH] -= 2.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -779,13 +776,13 @@ sqrt" "*"(" {
 	}
 
 <UNITS>s {
-	  /* Second. */
+	  // Second.
 	  types[WCSUNITS_TIME] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>solLum {
-	  /* Solar luminosity. */
+	  // Solar luminosity.
 	  factor *= 3.8268e26;
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
@@ -794,33 +791,33 @@ sqrt" "*"(" {
 	}
 
 <UNITS>solMass {
-	  /* Solar mass. */
+	  // Solar mass.
 	  factor *= 1.9891e30;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>solRad {
-	  /* Solar radius. */
+	  // Solar radius.
 	  factor *= 6.9599e8;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>sr {
-	  /* Steradian. */
+	  // Steradian.
 	  types[WCSUNITS_SOLID_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>Sun {
-	  /* Sun (with respect to). */
+	  // Sun (with respect to).
 	  types[WCSUNITS_SOLRATIO] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>T {
-	  /* Tesla. */
+	  // Tesla.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_TIME]   += 1.0;
 	  types[WCSUNITS_CHARGE] -= 1.0;
@@ -828,21 +825,21 @@ sqrt" "*"(" {
 	}
 
 <UNITS>turn {
-	  /* Turn. */
+	  // Turn.
 	  factor *= 360.0;
 	  types[WCSUNITS_PLANE_ANGLE] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>u {
-	  /* Unified atomic mass unit. */
+	  // Unified atomic mass unit.
 	  factor *= 1.6605387e-27;
 	  types[WCSUNITS_MASS] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>V {
-	  /* Volt. */
+	  // Volt.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 1.0;
 	  types[WCSUNITS_TIME]   -= 2.0;
@@ -851,13 +848,13 @@ sqrt" "*"(" {
 	}
 
 <UNITS>voxel {
-	  /* Voxel. */
+	  // Voxel.
 	  types[WCSUNITS_VOXEL] += 1.0;
 	  BEGIN(EXPON);
 	}
 
 <UNITS>W {
-	  /* Watt. */
+	  // Watt.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   -= 3.0;
@@ -865,7 +862,7 @@ sqrt" "*"(" {
 	}
 
 <UNITS>Wb {
-	  /* Weber. */
+	  // Weber.
 	  types[WCSUNITS_MASS]   += 1.0;
 	  types[WCSUNITS_LENGTH] += 2.0;
 	  types[WCSUNITS_TIME]   += 1.0;
@@ -874,14 +871,14 @@ sqrt" "*"(" {
 	}
 
 <UNITS>. {
-	  /* Internal parser error. */
+	  // Internal parser error.
 	  status = wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units parser error parsing '%s'", unitstr);
 	  BEGIN(FLUSH);
 	}
 
 <EXPON>" "*("**"|^) {
-	  /* Exponentiation. */
+	  // Exponentiation.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  }
@@ -921,7 +918,7 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "*[.*]" "* {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -931,7 +928,7 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "*"(" {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -942,7 +939,7 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "+ {
-	  /* Multiply. */
+	  // Multiply.
 	  if (operator) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -952,7 +949,7 @@ sqrt" "*"(" {
 	}
 
 <EXPON>" "*"/"" "* {
-	  /* Divide. */
+	  // Divide.
 	  if (operator++) {
 	    BEGIN(FLUSH);
 	  } else {
@@ -975,11 +972,11 @@ sqrt" "*"(" {
 	}
 
 <FLUSH>.* {
-	  /* Discard any remaining input. */
+	  // Discard any remaining input.
 	}
 
 <<EOF>>	{
-	  /* End-of-string. */
+	  // End-of-string.
 	  if (YY_START == EXPON) {
 	    add(&factor, types, &expon, scale, units);
 	  }
Index: astropy-4.2/cextern/wcslib/C/wcsunits.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsunits.c
+++ astropy-4.2/cextern/wcslib/C/wcsunits.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,18 +17,16 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsunits.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsunits.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <math.h>
 
 #include "wcsunits.h"
 
-/* Map status return value to message. */
+// Map status return value to message.
 const char *wcsunits_errmsg[] = {
   "Success",
   "Invalid numeric multiplier",
@@ -46,7 +43,7 @@ const char *wcsunits_errmsg[] = {
   "Potentially unsafe translation"};
 
 
-/* Unit types. */
+// Unit types.
 const char *wcsunits_types[] = {
   "plane angle",
   "solid angle",
@@ -84,7 +81,7 @@ const char *wcsunits_funcs[] = {
   "ln",
   "exp"};
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsunits(
   const char have[],
@@ -97,7 +94,7 @@ int wcsunits(
   return wcsunitse(have, want, scale, offset, power, 0x0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsunitse(
   const char have[],
@@ -121,7 +118,7 @@ int wcsunitse(
     return status;
   }
 
-  /* Check conformance. */
+  // Check conformance.
   for (i = 0; i < WCSUNITS_NTYPE; i++) {
     if (units1[i] != units2[i]) {
       return wcserr_set(WCSERR_SET(UNITSERR_BAD_UNIT_SPEC),
@@ -136,7 +133,7 @@ int wcsunitse(
 
   switch (func1) {
   case 0:
-    /* No function. */
+    // No function.
     if (func2) {
       return wcserr_set(WCSERR_SET(UNITSERR_BAD_FUNCS),
         "Mismatched unit functions: have '%s' (%s), want '%s' (%s)",
@@ -147,14 +144,14 @@ int wcsunitse(
     break;
 
   case 1:
-    /* log(). */
+    // log().
     if (func2 == 1) {
-      /* log(). */
+      // log().
       *scale  = 1.0;
       *offset = log10(scale1 / scale2);
 
     } else if (func2 == 2) {
-      /* ln(). */
+      // ln().
       *scale  = log(10.0);
       *offset = log(scale1 / scale2);
 
@@ -167,14 +164,14 @@ int wcsunitse(
     break;
 
   case 2:
-    /* ln(). */
+    // ln().
     if (func2 == 1) {
-      /* log(). */
+      // log().
       *scale  = 1.0 / log(10.0);
       *offset = log(scale1 / scale2);
 
     } else if (func2 == 2) {
-      /* ln(). */
+      // ln().
       *scale  = 1.0;
       *offset = log(scale1 / scale2);
 
@@ -187,7 +184,7 @@ int wcsunitse(
     break;
 
   case 3:
-    /* exp(). */
+    // exp().
     if (func2 != 3) {
       return wcserr_set(WCSERR_SET(UNITSERR_BAD_FUNCS),
         "Mismatched unit functions: have '%s' (%s), want '%s' (%s)",
@@ -199,7 +196,7 @@ int wcsunitse(
     break;
 
   default:
-    /* Internal parser error. */
+    // Internal parser error.
     return wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
       "Internal units parser error");
   }
@@ -207,7 +204,7 @@ int wcsunitse(
   return 0;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsutrn(int ctrl, char unitstr[])
 
@@ -215,7 +212,7 @@ int wcsutrn(int ctrl, char unitstr[])
   return wcsutrne(ctrl, unitstr, 0x0);
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsulex(const char unitstr[], int *func, double *scale, double units[])
 
Index: astropy-4.2/cextern/wcslib/C/wcsunits.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsunits.h
+++ astropy-4.2/cextern/wcslib/C/wcsunits.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsunits.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsunits.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -162,42 +159,44 @@
 *                            or not (see notes).
 *
 * Notes:
-*   Translation of non-standard unit specifications: apart from leading and
-*   trailing blanks, a case-sensitive match is required for the aliases listed
-*   below, in particular the only recognized aliases with metric prefixes are
-*   "KM", "KHZ", "MHZ", and "GHZ".  Potentially unsafe translations of "D",
-*   "H", and "S", shown in parentheses, are optional.
-*
-=     Unit       Recognized aliases
-=     ----       -------------------------------------------------------------
-=     Angstrom   angstrom
-=     arcmin     arcmins, ARCMIN, ARCMINS
-=     arcsec     arcsecs, ARCSEC, ARCSECS
-=     beam       BEAM
-=     byte       Byte
-=     d          day, days, (D), DAY, DAYS
-=     deg        degree, degrees, Deg, Degree, Degrees, DEG, DEGREE, DEGREES
-=     GHz        GHZ
-=     h          hr, (H), HR
-=     Hz         hz, HZ
-=     kHz        KHZ
-=     Jy         JY
-=     K          kelvin, kelvins, Kelvin, Kelvins, KELVIN, KELVINS
-=     km         KM
-=     m          metre, meter, metres, meters, M, METRE, METER, METRES, METERS
-=     min        MIN
-=     MHz        MHZ
-=     Ohm        ohm
-=     Pa         pascal, pascals, Pascal, Pascals, PASCAL, PASCALS
-=     pixel      pixels, PIXEL, PIXELS
-=     rad        radian, radians, RAD, RADIAN, RADIANS
-=     s          sec, second, seconds, (S), SEC, SECOND, SECONDS
-=     V          volt, volts, Volt, Volts, VOLT, VOLTS
-=     yr         year, years, YR, YEAR, YEARS
-*
-*   The aliases "angstrom", "ohm", and "Byte" for (Angstrom, Ohm, and byte)
-*   are recognized by wcsulexe() itself as an unofficial extension of the
-*   standard, but they are converted to the standard form here.
+*   1: Translation of non-standard unit specifications: apart from leading and
+*      trailing blanks, a case-sensitive match is required for the aliases
+*      listed below, in particular the only recognized aliases with metric
+*      prefixes are "KM", "KHZ", "MHZ", and "GHZ".  Potentially unsafe
+*      translations of "D", "H", and "S", shown in parentheses, are optional.
+*
+=        Unit       Recognized aliases
+=        ----       ----------------------------------------------------------
+=        Angstrom   Angstroms angstrom angstroms
+=        arcmin     arcmins, ARCMIN, ARCMINS
+=        arcsec     arcsecs, ARCSEC, ARCSECS
+=        beam       BEAM
+=        byte       Byte
+=        d          day, days, (D), DAY, DAYS
+=        deg        degree, degrees, Deg, Degree, Degrees, DEG, DEGREE,
+=                   DEGREES
+=        GHz        GHZ
+=        h          hr, (H), HR
+=        Hz         hz, HZ
+=        kHz        KHZ
+=        Jy         JY
+=        K          kelvin, kelvins, Kelvin, Kelvins, KELVIN, KELVINS
+=        km         KM
+=        m          metre, meter, metres, meters, M, METRE, METER, METRES,
+=                   METERS
+=        min        MIN
+=        MHz        MHZ
+=        Ohm        ohm
+=        Pa         pascal, pascals, Pascal, Pascals, PASCAL, PASCALS
+=        pixel      pixels, PIXEL, PIXELS
+=        rad        radian, radians, RAD, RADIAN, RADIANS
+=        s          sec, second, seconds, (S), SEC, SECOND, SECONDS
+=        V          volt, volts, Volt, Volts, VOLT, VOLTS
+=        yr         year, years, YR, YEAR, YEARS
+*
+*      The aliases "angstrom", "ohm", and "Byte" for (Angstrom, Ohm, and byte)
+*      are recognized by wcsulexe() itself as an unofficial extension of the
+*      standard, but they are converted to the standard form here.
 *
 *
 * wcsulexe() - FITS units specification parser
@@ -348,21 +347,19 @@ extern "C" {
 extern const char *wcsunits_errmsg[];
 
 enum wcsunits_errmsg_enum {
-  UNITSERR_SUCCESS            =  0,	/* Success. */
-  UNITSERR_BAD_NUM_MULTIPLIER =  1,	/* Invalid numeric multiplier. */
-  UNITSERR_DANGLING_BINOP     =  2,	/* Dangling binary operator. */
-  UNITSERR_BAD_INITIAL_SYMBOL =  3,	/* Invalid symbol in INITIAL
-					   context. */
-  UNITSERR_FUNCTION_CONTEXT   =  4,	/* Function in invalid context. */
-  UNITSERR_BAD_EXPON_SYMBOL   =  5,	/* Invalid symbol in EXPON context. */
-  UNITSERR_UNBAL_BRACKET      =  6,	/* Unbalanced bracket. */
-  UNITSERR_UNBAL_PAREN        =  7,	/* Unbalanced parenthesis. */
-  UNITSERR_CONSEC_BINOPS      =  8,	/* Consecutive binary operators. */
-  UNITSERR_PARSER_ERROR       =  9,	/* Internal parser error. */
-  UNITSERR_BAD_UNIT_SPEC      = 10,	/* Non-conformant unit
-					   specifications. */
-  UNITSERR_BAD_FUNCS          = 11,	/* Non-conformant functions. */
-  UNITSERR_UNSAFE_TRANS       = 12	/* Potentially unsafe translation. */
+  UNITSERR_SUCCESS            =  0,	// Success.
+  UNITSERR_BAD_NUM_MULTIPLIER =  1,	// Invalid numeric multiplier.
+  UNITSERR_DANGLING_BINOP     =  2,	// Dangling binary operator.
+  UNITSERR_BAD_INITIAL_SYMBOL =  3,	// Invalid symbol in INITIAL context.
+  UNITSERR_FUNCTION_CONTEXT   =  4,	// Function in invalid context.
+  UNITSERR_BAD_EXPON_SYMBOL   =  5,	// Invalid symbol in EXPON context.
+  UNITSERR_UNBAL_BRACKET      =  6,	// Unbalanced bracket.
+  UNITSERR_UNBAL_PAREN        =  7,	// Unbalanced parenthesis.
+  UNITSERR_CONSEC_BINOPS      =  8,	// Consecutive binary operators.
+  UNITSERR_PARSER_ERROR       =  9,	// Internal parser error.
+  UNITSERR_BAD_UNIT_SPEC      = 10,	// Non-conformant unit specifications.
+  UNITSERR_BAD_FUNCS          = 11,	// Non-conformant functions.
+  UNITSERR_UNSAFE_TRANS       = 12	// Potentially unsafe translation.
 };
 
 extern const char *wcsunits_types[];
@@ -397,7 +394,7 @@ int wcsutrne(int ctrl, char unitstr[], s
 int wcsulexe(const char unitstr[], int *func, double *scale,
              double units[WCSUNITS_NTYPE], struct wcserr **err);
 
-/* Deprecated. */
+// Deprecated.
 int wcsunits(const char have[], const char want[], double *scale,
              double *offset, double *power);
 int wcsutrn(int ctrl, char unitstr[]);
@@ -408,4 +405,4 @@ int wcsulex(const char unitstr[], int *f
 }
 #endif
 
-#endif /* WCSLIB_WCSUNITS */
+#endif // WCSLIB_WCSUNITS
Index: astropy-4.2/cextern/wcslib/C/wcsutil.c
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsutil.c
+++ astropy-4.2/cextern/wcslib/C/wcsutil.c
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsutil.c,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsutil.c,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *===========================================================================*/
 
 #include <ctype.h>
@@ -35,7 +32,7 @@
 #include "wcsutil.h"
 #include "wcsmath.h"
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsdealloc(void *ptr)
 
@@ -45,7 +42,7 @@ void wcsdealloc(void *ptr)
   return;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_strcvt(int n, char c, const char src[], char dst[])
 
@@ -64,7 +61,7 @@ void wcsutil_strcvt(int n, char c, const
     return;
   }
 
-  /* Copy to the first NULL character. */
+  // Copy to the first NULL character.
   for (j = 0; j < n; j++) {
     if ((dst[j] = src[j]) == '\0') {
       break;
@@ -72,18 +69,18 @@ void wcsutil_strcvt(int n, char c, const
   }
 
   if (j < n) {
-    /* The given string is null-terminated. */
+    // The given string is null-terminated.
     memset(dst+j, c, n-j);
 
   } else {
-    /* The given string is not null-terminated. */
+    // The given string is not null-terminated.
     if (c == '\0') {
       j = n - 1;
       dst[j] = '\0';
 
       j--;
 
-      /* Work backwards, looking for the first non-blank. */
+      // Work backwards, looking for the first non-blank.
       for (; j >= 0; j--) {
         if (dst[j] != ' ') {
           break;
@@ -98,7 +95,7 @@ void wcsutil_strcvt(int n, char c, const
   return;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_blank_fill(int n, char c[])
 
@@ -111,7 +108,7 @@ void wcsutil_blank_fill(int n, char c[])
     return;
   }
 
-  /* Replace the terminating null and all successive characters. */
+  // Replace the terminating null and all successive characters.
   for (j = 0; j < n; j++) {
     if (c[j] == '\0') {
       memset(c+j, ' ', n-j);
@@ -122,7 +119,7 @@ void wcsutil_blank_fill(int n, char c[])
   return;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_null_fill(int n, char c[])
 
@@ -135,20 +132,20 @@ void wcsutil_null_fill(int n, char c[])
     return;
   }
 
-  /* Find the first NULL character. */
+  // Find the first NULL character.
   for (j = 0; j < n; j++) {
     if (c[j] == '\0') {
       break;
     }
   }
 
-  /* Ensure null-termination. */
+  // Ensure null-termination.
   if (j == n) {
     j = n - 1;
     c[j] = '\0';
   }
 
-  /* Work backwards, looking for the first non-blank. */
+  // Work backwards, looking for the first non-blank.
   j--;
   for (; j > 0; j--) {
     if (c[j] != ' ') {
@@ -163,7 +160,7 @@ void wcsutil_null_fill(int n, char c[])
   return;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsutil_allEq(int nvec, int nelem, const double *first)
 
@@ -181,7 +178,7 @@ int wcsutil_allEq(int nvec, int nelem, c
   return 1;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsutil_Eq(int nelem, double tol, const double *arr1, const double *arr2)
 
@@ -195,18 +192,18 @@ int wcsutil_Eq(int nelem, double tol, co
   if (arr1 == 0x0 || arr2 == 0x0) return 0;
 
   if (tol == 0.0) {
-    /* Handled separately for speed of execution. */
+    // Handled separately for speed of execution.
     for (i = 0; i < nelem; i++, arr1++, arr2++) {
       if (*arr1 != *arr2) return 0;
     }
 
   } else {
     for (i = 0; i < nelem; i++, arr1++, arr2++) {
-      /* Undefined values must match exactly. */
+      // Undefined values must match exactly.
       if (*arr1 == UNDEFINED && *arr2 != UNDEFINED) return 0;
       if (*arr1 != UNDEFINED && *arr2 == UNDEFINED) return 0;
 
-      /* Otherwise, compare within the specified tolerance. */
+      // Otherwise, compare within the specified tolerance.
       if (fabs(*arr1 - *arr2) > 0.5*tol) return 0;
     }
   }
@@ -214,7 +211,7 @@ int wcsutil_Eq(int nelem, double tol, co
   return 1;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsutil_intEq(int nelem, const int *arr1, const int *arr2)
 
@@ -234,7 +231,7 @@ int wcsutil_intEq(int nelem, const int *
   return 1;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsutil_strEq(int nelem, char (*arr1)[72], char (*arr2)[72])
 
@@ -254,7 +251,7 @@ int wcsutil_strEq(int nelem, char (*arr1
   return 1;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_setAll(int nvec, int nelem, double *first)
 
@@ -269,7 +266,7 @@ void wcsutil_setAll(int nvec, int nelem,
   }
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_setAli(int nvec, int nelem, int *first)
 
@@ -284,7 +281,7 @@ void wcsutil_setAli(int nvec, int nelem,
   }
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 void wcsutil_setBit(int nelem, const int *sel, int bits, int *array)
 
@@ -294,20 +291,20 @@ void wcsutil_setBit(int nelem, const int
   if (bits == 0 || nelem <= 0) return;
 
   if (sel == 0x0) {
-    /* All elements selected. */
+    // All elements selected.
     for (arrp = array; arrp < array + nelem; arrp++) {
       *arrp |= bits;
     }
 
   } else {
-    /* Some elements selected. */
+    // Some elements selected.
     for (arrp = array; arrp < array + nelem; arrp++) {
       if (*(sel++)) *arrp |= bits;
     }
   }
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 char *wcsutil_fptr2str(void (*fptr)(void), char hext[19])
 
@@ -317,11 +314,11 @@ char *wcsutil_fptr2str(void (*fptr)(void
   unsigned int i;
   int *(ip[2]), j[2], le = 1, gotone = 0;
 
-  /* Test for little-endian addresses. */
+  // Test for little-endian addresses.
   ip[0] = j;
   ip[1] = j + 1;
   if ((unsigned char *)ip[0] < (unsigned char *)ip[1]) {
-    /* Little-endian, reverse it. */
+    // Little-endian, reverse it.
     p += sizeof(fptr) - 1;
     le = -1;
   }
@@ -330,7 +327,7 @@ char *wcsutil_fptr2str(void (*fptr)(void
   t += 2;
 
   for (i = 0; i < sizeof(fptr); i++) {
-    /* Skip leading zeroes. */
+    // Skip leading zeroes.
     if (*p) gotone = 1;
 
     if (gotone) {
@@ -344,7 +341,7 @@ char *wcsutil_fptr2str(void (*fptr)(void
   return hext;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 static void wcsutil_locale_to_dot(char *buf)
 
@@ -379,7 +376,7 @@ void wcsutil_double2str(char *buf, const
   sprintf(buf, format, value);
   wcsutil_locale_to_dot(buf);
 
-  /* Look for a decimal point or exponent. */
+  // Look for a decimal point or exponent.
   bp = buf;
   while (*bp) {
     if (*bp != ' ') {
@@ -390,7 +387,7 @@ void wcsutil_double2str(char *buf, const
     bp++;
   }
 
-  /* Not found, add a fractional part. */
+  // Not found, add a fractional part.
   bp = buf;
   if (*bp == ' ') {
     cp = buf + 1;
@@ -408,7 +405,7 @@ void wcsutil_double2str(char *buf, const
   }
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 static const char *wcsutil_dot_to_locale(const char *inbuf, char *outbuf)
 
@@ -455,7 +452,7 @@ int wcsutil_str2double2(const char *buf,
   value[0] = 0.0;
   value[1] = 0.0;
 
-  /* Get the integer part. */
+  // Get the integer part.
   if (sscanf(wcsutil_dot_to_locale(buf, ltmp), "%lf", value) < 1) {
     return 1;
   }
@@ -463,10 +460,10 @@ int wcsutil_str2double2(const char *buf,
 
   strcpy(ctmp, buf);
 
-  /* Look for a decimal point. */
+  // Look for a decimal point.
   dptr = strchr(ctmp, '.');
 
-  /* Look for an exponent. */
+  // Look for an exponent.
   if ((eptr = strchr(ctmp, 'E')) == NULL) {
     if ((eptr = strchr(ctmp, 'D')) == NULL) {
       if ((eptr = strchr(ctmp, 'e')) == NULL) {
@@ -476,7 +473,7 @@ int wcsutil_str2double2(const char *buf,
   }
 
   if (eptr) {
-    /* Get the exponent. */
+    // Get the exponent.
     if (sscanf(eptr+1, "%d", &exp) < 1) {
       return 1;
     }
@@ -487,15 +484,15 @@ int wcsutil_str2double2(const char *buf,
     }
 
     if (dptr+exp <= ctmp) {
-      /* There is only a fractional part. */
+      // There is only a fractional part.
       return sscanf(wcsutil_dot_to_locale(buf, ctmp), "%lf", value+1) < 1;
     } else if (eptr <= dptr+exp+1) {
-      /* There is no fractional part. */
+      // There is no fractional part.
       return 0;
     }
   }
 
-  /* Get the fractional part. */
+  // Get the fractional part.
   if (dptr) {
     cptr = ctmp;
     while (cptr <= dptr+exp) {
Index: astropy-4.2/cextern/wcslib/C/wcsutil.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsutil.h
+++ astropy-4.2/cextern/wcslib/C/wcsutil.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsutil.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsutil.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -428,4 +425,4 @@ int  wcsutil_str2double2(const char *buf
 }
 #endif
 
-#endif /* WCSLIB_WCSUTIL */
+#endif // WCSLIB_WCSUTIL
Index: astropy-4.2/cextern/wcslib/C/wcsutrn.l
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wcsutrn.l
+++ astropy-4.2/cextern/wcslib/C/wcsutrn.l
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,11 +17,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wcsutrn.l,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wcsutrn.l,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
 * wcsutrn.l is a Flex description file containing the definition of a lexical
@@ -59,7 +56,7 @@
 static int wcsutrne_scanner(int ctrl, char unitstr[], struct wcserr **err,
                             yyscan_t yyscanner);
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 int wcsutrne(
   int ctrl,
@@ -79,15 +76,15 @@ int wcsutrne(
   return status;
 }
 
-/*--------------------------------------------------------------------------*/
+//----------------------------------------------------------------------------
 
 #define YY_DECL int wcsutrne_scanner(int ctrl, char unitstr[], \
  struct wcserr **err, yyscan_t yyscanner)
 
-/* Dummy definition to circumvent compiler warnings. */
+// Dummy definition to circumvent compiler warnings.
 #define YY_INPUT(inbuff, count, bufsize) { count = YY_NULL; }
 
-/* Used in preempting the call to exit() by yy_fatal_error(). */
+// Used in preempting the call to exit() by yy_fatal_error().
 jmp_buf wcsutrn_abort_jmp_env;
 #define exit(status) longjmp(wcsutrn_abort_jmp_env, status)
 
@@ -110,7 +107,7 @@ jmp_buf wcsutrn_abort_jmp_env;
 	yy_scan_string(unitstr, yyscanner);
 	*unitstr = '\0';
 	
-	/* Return here via longjmp() invoked by yy_fatal_error(). */
+	// Return here via longjmp() invoked by yy_fatal_error().
 	if (setjmp(wcsutrn_abort_jmp_env)) {
 	  return wcserr_set(WCSERR_SET(UNITSERR_PARSER_ERROR),
 	    "Internal units translator error parsing '%s'", unitstr);
@@ -123,22 +120,22 @@ jmp_buf wcsutrn_abort_jmp_env;
 	#endif
 
 ^" "*"[" {
-	  /* Looks like a keycomment. */
+	  // Looks like a keycomment.
 	  strcat(unitstr, "[");
 	  bracket = 1;
 	}
 
-" "+	  /* Discard leading whitespace. */
+" "+	  // Discard leading whitespace.
 
 [^A-Za-z] {
-	  /* Non-alphabetic character. */
+	  // Non-alphabetic character.
 	  strcat(unitstr, yytext);
 	  if (bracket && *yytext == ']') {
 	    BEGIN(FLUSH);
 	  }
 	}
 
-angstrom {
+Angstroms|angstroms? {
 	  strcpy(orig, yytext);
 	  strcpy(subs, "Angstrom");
 	  BEGIN(NEXT);
@@ -304,25 +301,25 @@ years?|YR|YEARS? {
 	}
 
 [A-Za-z]+ {
-	  /* Not a recognized alias. */
+	  // Not a recognized alias.
 	  strcpy(orig, yytext);
 	  strcpy(subs, orig);
 	  BEGIN(NEXT);
 	}
 
 <NEXT>[A-Za-z]+ {
-	  /* Reject the alias match. */
+	  // Reject the alias match.
 	  strcat(orig, yytext);
 	  strcpy(subs, orig);
 	}
 
 <NEXT>" "+[^A-Za-z] {
-	  /* Discard separating whitespace. */
+	  // Discard separating whitespace.
 	  unput(yytext[yyleng-1]);
 	}
 
 <NEXT>" "+[A-Za-z] {
-	  /* Compress separating whitespace. */
+	  // Compress separating whitespace.
 	  strcat(unitstr, subs);
 	  strcat(unitstr, " ");
 	  if (strcmp(orig, subs)) status = 0;
@@ -332,7 +329,7 @@ years?|YR|YEARS? {
 	}
 
 <NEXT>.	{
-	  /* Copy anything else unchanged. */
+	  // Copy anything else unchanged.
 	  strcat(unitstr, subs);
 	  if (strcmp(orig, subs)) status = 0;
 	  unput(*yytext);
@@ -341,12 +338,12 @@ years?|YR|YEARS? {
 	}
 
 <FLUSH>.* {
-	  /* Copy out remaining input. */
+	  // Copy out remaining input.
 	  strcat(unitstr, yytext);
 	}
 
 <<EOF>>	{
-	  /* End-of-string. */
+	  // End-of-string.
 	  if (*subs) {
 	    strcat(unitstr, subs);
 	    if (strcmp(orig, subs)) status = 0;
Index: astropy-4.2/cextern/wcslib/C/wtbarr.h
===================================================================
--- astropy-4.2.orig/cextern/wcslib/C/wtbarr.h
+++ astropy-4.2/cextern/wcslib/C/wtbarr.h
@@ -1,7 +1,6 @@
 /*============================================================================
-
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -18,14 +17,12 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: wtbarr.h,v 7.3 2020/06/03 03:37:02 mcalabre Exp $
+  $Id: wtbarr.h,v 7.4 2021/01/31 02:24:51 mcalabre Exp $
 *=============================================================================
 *
-* WCSLIB 7.3 - C routines that implement the FITS World Coordinate System
+* WCSLIB 7.4 - C routines that implement the FITS World Coordinate System
 * (WCS) standard.  Refer to the README file provided with WCSLIB for an
 * overview of the library.
 *
@@ -95,24 +92,24 @@
 
 #ifdef __cplusplus
 extern "C" {
-#define wtbarr wtbarr_s		/* See prologue above.                      */
+#define wtbarr wtbarr_s		// See prologue above.
 #endif
-				/* For extracting wcstab arrays.  Matches   */
-				/* the wtbarr typedef defined in CFITSIO    */
-				/* header fitsio.h.                         */
+				// For extracting wcstab arrays.  Matches
+				// the wtbarr typedef defined in CFITSIO
+				// header fitsio.h.
 struct wtbarr {
-  int  i;			/* Image axis number.                       */
-  int  m;			/* Array axis number for index vectors.     */
-  int  kind;			/* wcstab array type.                       */
-  char extnam[72];		/* EXTNAME of binary table extension.       */
-  int  extver;			/* EXTVER  of binary table extension.       */
-  int  extlev;			/* EXTLEV  of binary table extension.       */
-  char ttype[72];		/* TTYPEn of column containing the array.   */
-  long row;			/* Table row number.                        */
-  int  ndim;			/* Expected wcstab array dimensionality.    */
-  int  *dimlen;			/* Where to write the array axis lengths.   */
-  double **arrayp;		/* Where to write the address of the array  */
-				/* allocated to store the wcstab array.     */
+  int  i;			// Image axis number.
+  int  m;			// Array axis number for index vectors.
+  int  kind;			// wcstab array type.
+  char extnam[72];		// EXTNAME of binary table extension.
+  int  extver;			// EXTVER  of binary table extension.
+  int  extlev;			// EXTLEV  of binary table extension.
+  char ttype[72];		// TTYPEn of column containing the array.
+  long row;			// Table row number.
+  int  ndim;			// Expected wcstab array dimensionality.
+  int  *dimlen;			// Where to write the array axis lengths.
+  double **arrayp;		// Where to write the address of the array
+				// allocated to store the wcstab array.
 };
 
 #ifdef __cplusplus
@@ -120,4 +117,4 @@ struct wtbarr {
 }
 #endif
 
-#endif /* WCSLIB_WTBARR */
+#endif // WCSLIB_WTBARR
Index: astropy-4.2/cextern/wcslib/CHANGES
===================================================================
--- astropy-4.2.orig/cextern/wcslib/CHANGES
+++ astropy-4.2/cextern/wcslib/CHANGES
@@ -1,3 +1,66 @@
+WCSLIB version 7.4 (2021/01/31)
+-------------------------------
+
+* C library
+
+  - In wcshdo(), fixed a bug introduced in release 5.9 that potentially
+    caused loss of numerical precision in the sprintf() formatting of
+    floating point keyvalues.  This was triggered when a large range of
+    CRPIXja, PCi_ja, or CDELTia values (as three separate groups) were
+    formatted using an 'f' format descriptor, the range not being so
+    large that it would have forced wcshdo() to revert to 'E' format.
+    Reported by Mohammad Akhlaghi.
+
+    Also in wcshdo(), fixed a bug introduced in release 7.1 that caused
+    the coefficients of the TPD distortion function not to be written to
+    the header.  TPD and Polynomial distortion function headers will now
+    always include the DPja.DOCORR keyword.  Reported by Derek Homeier
+    with patch.
+
+  - In wcsset(), fixed a segv generated in attempting to report a non-
+    standard units string with wcserr message reporting disabled.
+    Reported by Mohammad Akhlaghi.
+
+    In wcsutrne(), allow 'Angstroms' and 'angstroms' as additional
+    synonyms for 'Angstrom'.
+
+  - In datfix(), ensure that 0 is returned if an informational message
+    is set in wcsprm::err.  Consequent on feedback independently from
+    Mihai Cara and Bruce Merry.
+
+    Clarified that informational messages may be set in wcsprm::err
+    for returns of 0 from datfix(), obsfix(), unitfix(), and spcfix().
+
+* User manual
+
+  - Added cautions about translating CDi_ja to PCi_ja plus CDELTia for
+    those historical distortion functions (TPV, TNX, ZPX) that expect to
+    operate on intermediate world coordinates, rather than intermediate
+    pixel coordinates.  Consequent on feedback from Mohammad Akhlaghi.
+
+  - Documentation generation moved to doxygen 1.9.1 (was 1.8.19).
+
+
+WCSLIB version 7.3.1 (2020/08/17)
+---------------------------------
+
+There are no functional changes in this release.
+
+* C library
+* Fortran wrappers
+* PGSBOX
+* Utilities
+
+  - Changed all C code, including within the flex sources, Fortran and
+    PGSBOX wrappers, and test suite, to use C99 style commenting (i.e.
+    using //), excluding the header prologues used to generate the user
+    manual.
+
+* User manual
+
+  - Documentation generation moved to doxygen 1.8.19 (was 1.8.18).
+
+
 WCSLIB version 7.3 (2020/06/03)
 -------------------------------
 
@@ -3030,4 +3093,4 @@ WCSLIB version 1.0 (1995/01/31)
   Initial release.
 
 ------------------------------------------------------------------------
-$Id: CHANGES,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+$Id: CHANGES,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
Index: astropy-4.2/cextern/wcslib/GNUmakefile
===================================================================
--- astropy-4.2.orig/cextern/wcslib/GNUmakefile
+++ astropy-4.2/cextern/wcslib/GNUmakefile
@@ -1,5 +1,5 @@
 #-----------------------------------------------------------------------------
-# GNU makefile for building WCSLIB 7.3
+# GNU makefile for building WCSLIB 7.4
 #
 # Summary of the main targets
 # ---------------------------
@@ -32,7 +32,7 @@
 #
 # Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 # http://www.atnf.csiro.au/people/Mark.Calabretta
-# $Id: GNUmakefile,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+# $Id: GNUmakefile,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
 #-----------------------------------------------------------------------------
 # Get configure settings.
 SUBDIR := .
Index: astropy-4.2/cextern/wcslib/INSTALL
===================================================================
--- astropy-4.2.orig/cextern/wcslib/INSTALL
+++ astropy-4.2/cextern/wcslib/INSTALL
@@ -1,5 +1,5 @@
 ------------------------------------------------------------------------------
-WCSLIB 7.3 and PGSBOX 7.3 INSTALLATION
+WCSLIB 7.4 and PGSBOX 7.4 INSTALLATION
 --------------------------------------
 
 WCSLIB requires an ANSI C compiler with standard ANSI C environment, that is,
@@ -9,8 +9,8 @@ Ritchie, 2nd ed.
 If you are running a typical Linux distro and have installed WCSLIB before,
 then all you should need to do is
 
-  tar pxvf wcslib-7.3.tar.bz2
-  cd wcslib-7.3
+  tar pxvf wcslib-7.4.tar.bz2
+  cd wcslib-7.4
   make install
 
 Otherwise, read on.
@@ -19,8 +19,8 @@ Installation of WCSLIB is handled by GNU
 as 'gmake') must be used.  The WCSLIB distribution also includes PGSBOX (refer
 to the README file).  To unpack the tar file, type
 
-  bzcat wcslib-7.3.tar.bz2 | tar pvxf -
-  cd wcslib-7.3
+  bzcat wcslib-7.4.tar.bz2 | tar pvxf -
+  cd wcslib-7.4
 
 then if you do not need to specify any configuration options, simply run
 
@@ -102,7 +102,7 @@ The INSTALL file provided with GNU autoc
 
 Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 http://www.atnf.csiro.au/people/Mark.Calabretta
-$Id: INSTALL,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+$Id: INSTALL,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
 
 ==============================================================================
 
Index: astropy-4.2/cextern/wcslib/README
===================================================================
--- astropy-4.2.orig/cextern/wcslib/README
+++ astropy-4.2/cextern/wcslib/README
@@ -1,8 +1,8 @@
 ------------------------------------------------------------------------------
-                         WCSLIB 7.3 and PGSBOX 7.3
+                         WCSLIB 7.4 and PGSBOX 7.4
 ------------------------------------------------------------------------------
-  WCSLIB 7.3 - an implementation of the FITS WCS standard.
-  Copyright (C) 1995-2020, Mark Calabretta
+  WCSLIB 7.4 - an implementation of the FITS WCS standard.
+  Copyright (C) 1995-2021, Mark Calabretta
 
   This file is part of WCSLIB.
 
@@ -19,11 +19,9 @@
   You should have received a copy of the GNU Lesser General Public License
   along with WCSLIB.  If not, see http://www.gnu.org/licenses.
 
-  Direct correspondence concerning WCSLIB to mark@calabretta.id.au
-
   Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
   http://www.atnf.csiro.au/people/Mark.Calabretta
-  $Id: README,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+  $Id: README,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
 ------------------------------------------------------------------------------
 
 Please refer to
Index: astropy-4.2/cextern/wcslib/THANKS
===================================================================
--- astropy-4.2.orig/cextern/wcslib/THANKS
+++ astropy-4.2/cextern/wcslib/THANKS
@@ -2,7 +2,7 @@ I would like to acknowledge the followin
 to WCSLIB and/or PGSBOX in some way since 1995 - via bug reports,
 patches, suggestions for improvements, positive feedback, etc.
 
-Mohammad Aghlaghi (IAC & GNUastro)
+Mohammad Akhlaghi (IAC & GNUastro)
 James Allen (U. Sydney)
 James M. Anderson (MPIfR)
 Robbie Auld (Cardiff U.)
@@ -16,7 +16,7 @@ Erik M. Bray (STScI)
 Jeremy Brewer (U. Pittsburgh)
 Wim Brouw (ATNF/CSIRO)
 Peter Bunclark (IoA, U. Cambridge)
-Mihai Cara (STScI)
+Mihai Cara (STScI/Astropy)
 Rodrigo Tobar Carrizo (ICRAR/UWA)
 Pan Chai (GSFC/NASA)
 Charles Copley
@@ -24,7 +24,7 @@ Simon Conseil (CRAL)
 Neil Crighton
 Cesar Enrique Garcia Dabo (ESO)
 Lindsey Davis (NOAO)
-Nadezhda (Nadia) Dencheva (STScI)
+Nadezhda (Nadia) Dencheva (STScI/Astropy)
 Ger van Diepen (ASTRON)
 Patrick Dowler (CADC/NRC)
 Michael Droettboom (STScI)
@@ -39,6 +39,7 @@ Eric Greisen (NRAO)
 Michael Halle (AM/Harvard)
 Booth Hartley (IPAC/NASA)
 Phil Hodge (STScI)
+Derek Homeier (Astropy)
 Bryan Irby (GSFC/NASA)
 Justin Jonas (Rhodes U.)
 Yves Jung (ESO)
@@ -65,6 +66,7 @@ Tom Marsh (U. Warwick)
 Sean Mattingly (IPAC/NASA)
 Dave McConnell (ATNF/CSIRO)
 Thomas A. McGlynn (GSFC/NASA)
+Bruce Merry (SARAO)
 Michelle Miller (NOAO)
 Jessica Mink (CfA)
 David Motl (var.astro.cz)
@@ -86,7 +88,7 @@ Keith A. Scollick (GSFC/NASA)
 Arno Schoenmakers (ASTRON)
 Pim Schellart (Princeton U.)
 Corentin Schreiber (Oxford U.)
-Michael Seifert (astropy)
+Michael Seifert (Astropy)
 Colin Slater (LSST)
 Hanno Spreeuw (ASTRON)
 Ole Streicher (Debian maintainer)
@@ -108,4 +110,4 @@ Daren Scot Wilson (NRAO)
 Tony Wong (ATNF/CSIRO)
 
 
-$Id: THANKS,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+$Id: THANKS,v 7.3.1.4 2021/01/31 01:24:38 mcalabre Exp $
Index: astropy-4.2/cextern/wcslib/VALIDATION
===================================================================
--- astropy-4.2.orig/cextern/wcslib/VALIDATION
+++ astropy-4.2/cextern/wcslib/VALIDATION
@@ -1,5 +1,25 @@
 Platforms on which the installation procedures and test suite were exercised.
 
+WCSLIB version 7.4 (2021/01/31)
+-------------------------------
+
+* Dell Latitude XPS 15 9560 (Intel Core i7-7700HQ, 4 cores, 8 CPUs, x86_64)
+  KDE Neon User Edition 5.20 (over Kubuntu 20.04, (focal))
+  uname -r (kernel version): 5.4.0-62-generic
+  gcc --version: gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
+  gfortran --version: GNU Fortran (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
+
+
+WCSLIB version 7.3.1 (2020/08/17)
+---------------------------------
+
+* Dell Latitude XPS 15 9560 (Intel Core i7-7700HQ, 4 cores, 8 CPUs, x86_64)
+  KDE Neon User Edition 5.19 (over Kubuntu 18.04, (bionic))
+  uname -r (kernel version): 4.15.0-112-generic
+  gcc --version: gcc (GCC) 9.2.0 (local build)
+  gfortran --version: GNU Fortran (GCC) 9.2.0 (local build)
+
+
 WCSLIB version 7.3 (2020/06/03)
 -------------------------------
 
@@ -626,4 +646,4 @@ WCSLIB version 4.4 (2009/08/06)
           2004/04/23
 
 ------------------------------------------------------------------------------
-$Id: VALIDATION,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+$Id: VALIDATION,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
Index: astropy-4.2/cextern/wcslib/configure
===================================================================
--- astropy-4.2.orig/cextern/wcslib/configure
+++ astropy-4.2/cextern/wcslib/configure
@@ -1,7 +1,7 @@
 #! /bin/sh
-# From configure.ac Revision: 7.3 .
+# From configure.ac Revision: 7.4 .
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for WCSLIB 7.3.
+# Generated by GNU Autoconf 2.69 for WCSLIB 7.4.
 #
 # Report bugs to <mark@calabretta.id.au>.
 #
@@ -580,9 +580,9 @@ MAKEFLAGS=
 
 # Identity of this package.
 PACKAGE_NAME='WCSLIB'
-PACKAGE_TARNAME='wcslib-7.3'
-PACKAGE_VERSION='7.3'
-PACKAGE_STRING='WCSLIB 7.3'
+PACKAGE_TARNAME='wcslib-7.4'
+PACKAGE_VERSION='7.4'
+PACKAGE_STRING='WCSLIB 7.4'
 PACKAGE_BUGREPORT='mark@calabretta.id.au'
 PACKAGE_URL=''
 
@@ -1290,7 +1290,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures WCSLIB 7.3 to adapt to many kinds of systems.
+\`configure' configures WCSLIB 7.4 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1339,7 +1339,7 @@ Fine tuning of the installation director
   --infodir=DIR           info documentation [DATAROOTDIR/info]
   --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
   --mandir=DIR            man documentation [DATAROOTDIR/man]
-  --docdir=DIR            documentation root [DATAROOTDIR/doc/wcslib-7.3]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/wcslib-7.4]
   --htmldir=DIR           html documentation [DOCDIR]
   --dvidir=DIR            dvi documentation [DOCDIR]
   --pdfdir=DIR            pdf documentation [DOCDIR]
@@ -1360,7 +1360,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of WCSLIB 7.3:";;
+     short | recursive ) echo "Configuration of WCSLIB 7.4:";;
    esac
   cat <<\_ACEOF
 
@@ -1464,7 +1464,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-WCSLIB configure 7.3
+WCSLIB configure 7.4
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
@@ -2238,7 +2238,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by WCSLIB $as_me 7.3, which was
+It was created by WCSLIB $as_me 7.4, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
@@ -9061,7 +9061,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_wri
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by WCSLIB $as_me 7.3, which was
+This file was extended by WCSLIB $as_me 7.4, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -9123,7 +9123,7 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-WCSLIB config.status 7.3
+WCSLIB config.status 7.4
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
Index: astropy-4.2/cextern/wcslib/configure.ac
===================================================================
--- astropy-4.2.orig/cextern/wcslib/configure.ac
+++ astropy-4.2/cextern/wcslib/configure.ac
@@ -3,12 +3,12 @@
 #-----------------------------------------------------------------------------
 # Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 # http://www.atnf.csiro.au/people/Mark.Calabretta
-# $Id: configure.ac,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+# $Id: configure.ac,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
 #-----------------------------------------------------------------------------
 
-AC_INIT([WCSLIB], [7.3], [mark@calabretta.id.au], [wcslib-7.3])
+AC_INIT([WCSLIB], [7.4], [mark@calabretta.id.au], [wcslib-7.4])
 AC_PREREQ([2.53])
-AC_REVISION([$Revision: 7.3 $])
+AC_REVISION([$Revision: 7.4 $])
 AC_SUBST([PACKAGE_VERSION])
 AC_DEFINE_UNQUOTED([WCSLIB_VERSION], [$PACKAGE_VERSION], [Define wcslib version])
 
Index: astropy-4.2/cextern/wcslib/flavours
===================================================================
--- astropy-4.2.orig/cextern/wcslib/flavours
+++ astropy-4.2/cextern/wcslib/flavours
@@ -12,7 +12,7 @@
 #
 # Reminder: add '-d' to FLFLAGS for debugging.
 #
-# $Id: flavours,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+# $Id: flavours,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
 #-----------------------------------------------------------------------------
 
 # The list of FLAVOURs can be set on the command line.
Index: astropy-4.2/cextern/wcslib/makedefs.in
===================================================================
--- astropy-4.2.orig/cextern/wcslib/makedefs.in
+++ astropy-4.2/cextern/wcslib/makedefs.in
@@ -1,5 +1,5 @@
 #-----------------------------------------------------------------------------
-# GNU makefile definitions for building WCSLIB 7.3
+# GNU makefile definitions for building WCSLIB 7.4
 #
 # makedefs is generated from makedefs.in by configure.  It contains variable
 # definitions and some general-purpose rules for building WCSLIB.
@@ -39,11 +39,11 @@
 #      compiled separately without this option.
 #
 #      The shared library will be installed with version number, e.g. as
-#      libwcs.so.7.3 or libwcs.7.3.dylib with or without the symlink
+#      libwcs.so.7.4 or libwcs.7.4.dylib with or without the symlink
 #      required to make it visible to the linker (controlled by the SHRLN
 #      variable).  On Macs it is deliberately not created because its very
 #      existence precludes static linking with the cctools linker.  You can
-#      still link dynamically by using -lwcs.7.3.
+#      still link dynamically by using -lwcs.7.4.
 #
 #   4) PGPLOT is Tim Pearson's Fortran graphics library with separate C
 #      interface available from astro.caltech.edu.  It is only required by
@@ -74,7 +74,7 @@
 #
 # Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 # http://www.atnf.csiro.au/people/Mark.Calabretta
-# $Id: makedefs.in,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+# $Id: makedefs.in,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
 #-----------------------------------------------------------------------------
 # Version.
   LIBVER    := @LIBVER@
Index: astropy-4.2/cextern/wcslib/wcsconfig.h.in
===================================================================
--- astropy-4.2.orig/cextern/wcslib/wcsconfig.h.in
+++ astropy-4.2/cextern/wcslib/wcsconfig.h.in
@@ -1,11 +1,11 @@
 /*============================================================================
 *
 * wcsconfig.h is generated from wcsconfig.h.in by 'configure'.  It contains
-* C preprocessor macro definitions for compiling WCSLIB 7.3
+* C preprocessor macro definitions for compiling WCSLIB 7.4
 *
 * Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 * http://www.atnf.csiro.au/people/Mark.Calabretta
-* $Id: wcsconfig.h.in,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+* $Id: wcsconfig.h.in,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
 *===========================================================================*/
 
 /* wcslib_version() is available (as of 5.0). */
Index: astropy-4.2/cextern/wcslib/wcsconfig_f77.h.in
===================================================================
--- astropy-4.2.orig/cextern/wcslib/wcsconfig_f77.h.in
+++ astropy-4.2/cextern/wcslib/wcsconfig_f77.h.in
@@ -1,12 +1,12 @@
 /*============================================================================
 *
 * wcsconfig_f77.h is generated from wcsconfig_f77.h.in by 'configure'.  It
-* contains C preprocessor definitions for building the WCSLIB 7.3 Fortran
+* contains C preprocessor definitions for building the WCSLIB 7.4 Fortran
 * wrappers.
 *
 * Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 * http://www.atnf.csiro.au/people/Mark.Calabretta
-* $Id: wcsconfig_f77.h.in,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+* $Id: wcsconfig_f77.h.in,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
 *===========================================================================*/
 
 /* Integer array type large enough to hold an address.  Set here to int[2] for
Index: astropy-4.2/cextern/wcslib/wcsconfig_tests.h.in
===================================================================
--- astropy-4.2.orig/cextern/wcslib/wcsconfig_tests.h.in
+++ astropy-4.2/cextern/wcslib/wcsconfig_tests.h.in
@@ -1,12 +1,12 @@
 /*============================================================================
 *
 * wcsconfig_test.h is generated from wcsconfig_test.h.in by 'configure'.  It
-* contains C preprocessor definitions for compiling the WCSLIB 7.3 test/demo
+* contains C preprocessor definitions for compiling the WCSLIB 7.4 test/demo
 * programs.
 *
 * Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 * http://www.atnf.csiro.au/people/Mark.Calabretta
-* $Id: wcsconfig_tests.h.in,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+* $Id: wcsconfig_tests.h.in,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
 *===========================================================================*/
 
 #include <wcsconfig.h>
Index: astropy-4.2/cextern/wcslib/wcsconfig_utils.h.in
===================================================================
--- astropy-4.2.orig/cextern/wcslib/wcsconfig_utils.h.in
+++ astropy-4.2/cextern/wcslib/wcsconfig_utils.h.in
@@ -1,12 +1,12 @@
 /*============================================================================
 *
 * wcsconfig_utils.h is generated from wcsconfig_utils.h.in by 'configure'.
-* It contains C preprocessor macro definitions for compiling the WCSLIB 7.3
+* It contains C preprocessor macro definitions for compiling the WCSLIB 7.4
 * utilities.
 *
 * Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.
 * http://www.atnf.csiro.au/people/Mark.Calabretta
-* $Id: wcsconfig_utils.h.in,v 7.3 2020/06/03 03:37:03 mcalabre Exp $
+* $Id: wcsconfig_utils.h.in,v 7.4 2021/01/31 02:24:52 mcalabre Exp $
 *===========================================================================*/
 
 #include <wcsconfig.h>
Index: astropy-4.2/CHANGES.rst
===================================================================
--- astropy-4.2.orig/CHANGES.rst
+++ astropy-4.2/CHANGES.rst
@@ -330,6 +330,10 @@ Other Changes and Additions
 - When importing astropy without first building the extension modules first,
   raise an error directly instead of trying to auto-build. [#10883]
 
+- Updated bundled version of ``WCSLIB`` to v7.4, fixing a bug that caused
+  the coefficients of the TPD distortion function to not be written to the
+  header. [#11260]
+
 
 
 4.1 (2020-10-21)
Index: astropy-4.2/astropy/wcs/tests/data/validate.7.4.txt
===================================================================
--- /dev/null
+++ astropy-4.2/astropy/wcs/tests/data/validate.7.4.txt
@@ -0,0 +1,20 @@
+HDU 1:
+  WCS key ' ':
+    - RADECSYS= 'ICRS ' / Astrometric system
+      the RADECSYS keyword is deprecated, use RADESYSa.
+    - The WCS transformation has more axes (2) than the image it is
+      associated with (0)
+    - Removed redundant SCAMP distortion parameters because SIP
+      parameters are also present
+    - 'datfix' made the change 'Set MJD-OBS to 55007.362083 from DATE-
+      OBS'.
+
+HDU 2:
+  WCS key ' ':
+    - The WCS transformation has more axes (3) than the image it is
+      associated with (0)
+    - 'datfix' made the change 'Success'.
+    - 'unitfix' made the change 'Changed units:
+        'HZ' -> 'Hz'.
+    - 'celfix' made the change 'In CUNIT3 : Mismatched units type
+      'length': have 'Hz', want 'm''.
Index: astropy-4.2/astropy/wcs/tests/test_wcs.py
===================================================================
--- astropy-4.2.orig/astropy/wcs/tests/test_wcs.py
+++ astropy-4.2/astropy/wcs/tests/test_wcs.py
@@ -22,6 +22,7 @@ from astropy.utils.exceptions import (
 from astropy.tests.helper import assert_quantity_allclose
 from astropy.io import fits
 from astropy.coordinates import SkyCoord
+from astropy.nddata import Cutout2D
 
 
 _WCSLIB_VER = Version(_wcs.__version__)
@@ -117,11 +118,15 @@ def test_fixes():
     with pytest.raises(wcs.InvalidTransformError), pytest.warns(wcs.FITSFixedWarning) as w:
         wcs.WCS(header, translate_units='dhs')
 
-    assert len(w) == 2
+    if _WCSLIB_VER >= Version('7.4'):
+        assert len(w) == 3
+        assert "'datfix' made the change 'Success'." in str(w.pop().message)
+    else:
+        assert len(w) == 2
 
     first_wmsg = str(w[0].message)
     assert 'unitfix' in first_wmsg and 'Hz' in first_wmsg and 'M/S' in first_wmsg
-    assert 'm/s' in str(w[1].message)
+    assert 'plane angle' in str(w[1].message) and 'm/s' in str(w[1].message)
 
 
 # Ignore "PV2_2 = 0.209028857410973 invalid keyvalue" warning seen on Windows.
@@ -145,6 +150,7 @@ def test_pix2world():
     """
     # TODO: write this to test the expected output behavior of pix2world,
     # currently this just makes sure it doesn't error out in unexpected ways
+    # (and compares `wcs.pc` and `result` values?)
     filename = get_pkg_data_filename('data/sip2.fits')
     with pytest.warns(wcs.FITSFixedWarning) as caught_warnings:
         # this raises a warning unimportant for this testing the pix2world
@@ -153,7 +159,10 @@ def test_pix2world():
         ww = wcs.WCS(filename)
 
     # might as well monitor for changing behavior
-    assert len(caught_warnings) == 1
+    if _WCSLIB_VER >= Version('7.4'):
+        assert len(caught_warnings) == 2
+    else:
+        assert len(caught_warnings) == 1
 
     n = 3
     pixels = (np.arange(n) * np.ones((2, n))).T
@@ -162,18 +171,17 @@ def test_pix2world():
     # Catch #2791
     ww.wcs_pix2world(pixels[..., 0], pixels[..., 1], 0, ra_dec_order=True)
 
-    close_enough = 1e-8
     # assuming that the data of sip2.fits doesn't change
     answer = np.array([[0.00024976, 0.00023018],
                        [0.00023043, -0.00024997]])
 
-    assert np.all(np.abs(ww.wcs.pc - answer) < close_enough)
+    assert np.allclose(ww.wcs.pc, answer, atol=1.e-8)
 
     answer = np.array([[202.39265216, 47.17756518],
                        [202.39335826, 47.17754619],
                        [202.39406436, 47.1775272]])
 
-    assert np.all(np.abs(result - answer) < close_enough)
+    assert np.allclose(result, answer, atol=1.e-8, rtol=1.e-10)
 
 
 def test_load_fits_path():
@@ -319,13 +327,19 @@ def test_invalid_shape():
 
 def test_warning_about_defunct_keywords():
     header = get_pkg_data_contents('data/defunct_keywords.hdr', encoding='binary')
+    if _WCSLIB_VER >= Version('7.4'):
+        n_warn = 5
+    else:
+        n_warn = 4
+
     # Make sure the warnings come out every time...
     for _ in range(2):
         with pytest.warns(wcs.FITSFixedWarning) as w:
             wcs.WCS(header)
 
-        assert len(w) == 4
-        for item in w:
+        assert len(w) == n_warn
+        # 7.4 adds a fifth warning "'datfix' made the change 'Success'."
+        for item in w[:4]:
             assert 'PCi_ja' in str(item.message)
 
 
@@ -431,14 +445,14 @@ def test_find_all_wcs_crash():
 def test_validate():
     results = wcs.validate(get_pkg_data_filename("data/validate.fits"))
     results_txt = sorted(set([x.strip() for x in repr(results).splitlines()]))
-    version = wcs._wcs.__version__
-    if version[0] in ['6', '7']:
+    if _WCSLIB_VER >= Version('7.4'):
+        filename = 'data/validate.7.4.txt'
+    elif _WCSLIB_VER >= Version('6.0'):
         filename = 'data/validate.6.txt'
-    elif version[0] == '5':
-        if version >= '5.13':
-            filename = 'data/validate.5.13.txt'
-        else:
-            filename = 'data/validate.5.0.txt'
+    elif _WCSLIB_VER >= Version('5.13'):
+        filename = 'data/validate.5.13.txt'
+    elif _WCSLIB_VER >= Version('5.0'):
+        filename = 'data/validate.5.0.txt'
     else:
         filename = 'data/validate.txt'
     with open(get_pkg_data_filename(filename), "r") as fd:
@@ -1457,3 +1471,47 @@ def test_no_pixel_area():
 
     # Pixel scales still possible
     assert_quantity_allclose(w.proj_plane_pixel_scales(), 1)
+
+
+def test_distortion_header(tmpdir):
+    """
+    Test that plate distortion model is correctly described by `wcs.to_header()`
+    and preserved when creating a Cutout2D from the image, writing it to FITS,
+    and reading it back from the file.
+    """
+    path = get_pkg_data_filename("data/dss.14.29.56-62.41.05.fits.gz")
+    cen = np.array((50, 50))
+    siz = np.array((20, 20))
+
+    with fits.open(path) as hdulist:
+        with pytest.warns(wcs.FITSFixedWarning):
+            w = wcs.WCS(hdulist[0].header)
+        cut = Cutout2D(hdulist[0].data, position=cen, size=siz, wcs=w)
+
+    # This converts the DSS plate solution model with AMD[XY]n coefficients into a
+    # Template Polynomial Distortion model (TPD.FWD.n coefficients);
+    # not testing explicitly for the header keywords here.
+
+    if _WCSLIB_VER < Version("7.4"):
+        with pytest.warns(AstropyWarning, match="WCS contains a TPD distortion model in CQDIS"):
+            w0 = wcs.WCS(w.to_header_string())
+        with pytest.warns(AstropyWarning, match="WCS contains a TPD distortion model in CQDIS"):
+            w1 = wcs.WCS(cut.wcs.to_header_string())
+        if _WCSLIB_VER >= Version("7.1"):
+            pytest.xfail("TPD coefficients incomplete with WCSLIB >= 7.1 < 7.4")
+    else:
+        w0 = wcs.WCS(w.to_header_string())
+        w1 = wcs.WCS(cut.wcs.to_header_string())
+
+    assert w.pixel_to_world(0, 0).separation(w0.pixel_to_world(0, 0)) < 1.e-3 * u.mas
+    assert w.pixel_to_world(*cen).separation(w0.pixel_to_world(*cen)) < 1.e-3 * u.mas
+
+    assert w.pixel_to_world(*cen).separation(w1.pixel_to_world(*(siz / 2))) < 1.e-3 * u.mas
+
+    cutfile = str(tmpdir.join('cutout.fits'))
+    fits.writeto(cutfile, cut.data, cut.wcs.to_header())
+
+    with fits.open(cutfile) as hdulist:
+        w2 = wcs.WCS(hdulist[0].header)
+
+    assert w.pixel_to_world(*cen).separation(w2.pixel_to_world(*(siz / 2))) < 1.e-3 * u.mas
Index: astropy-4.2/astropy/wcs/tests/test_wcsprm.py
===================================================================
--- astropy-4.2.orig/astropy/wcs/tests/test_wcsprm.py
+++ astropy-4.2/astropy/wcs/tests/test_wcsprm.py
@@ -414,6 +414,9 @@ def test_fix():
         del fix_ref['obsfix']
     if Version(version) >= Version('7.1'):
         w.dateref = '1858-11-17'
+    if Version(version) >= Version('7.4'):
+        fix_ref['datfix'] = 'Success'
+
     assert w.fix() == fix_ref
 
 
Index: astropy-4.2/setup.cfg
===================================================================
--- astropy-4.2.orig/setup.cfg
+++ astropy-4.2/setup.cfg
@@ -134,6 +134,7 @@ filterwarnings =
 	ignore:the imp module is deprecated:DeprecationWarning
 	ignore:The toolz.compatibility module is no longer needed:DeprecationWarning
 	ignore:parallel reading does not currently work, so falling back to serial
+        ignore:'datfix' made the change:astropy.wcs.wcs.FITSFixedWarning
 doctest_norecursedirs = 
 	*/setup_package.py
 doctest_subpackage_requires = 
Index: astropy-4.2/astropy/wcs/wcs.py
===================================================================
--- astropy-4.2.orig/astropy/wcs/wcs.py
+++ astropy-4.2/astropy/wcs/wcs.py
@@ -2671,6 +2671,22 @@ reduce these to 2 dimensions using the n
             for kw in keys_to_remove:
                 if kw in header:
                     del header[kw]
+            # Check if we can handle TPD distortion correctly
+            if int(_parsed_version[0]) * 10 + int(_parsed_version[1]) < 71:
+                for kw, val in header.items():
+                    if kw[:5] in ('CPDIS', 'CQDIS') and val == 'TPD':
+                        warnings.warn(
+                            f"WCS contains a TPD distortion model in {kw}. WCSLIB "
+                            f"{_wcs.__version__} is writing this in a format incompatible with "
+                            f"current versions - please update to 7.4 or use the bundled WCSLIB.",
+                            AstropyWarning)
+            elif int(_parsed_version[0]) * 10 + int(_parsed_version[1]) < 74:
+                for kw, val in header.items():
+                    if kw[:5] in ('CPDIS', 'CQDIS') and val == 'TPD':
+                        warnings.warn(
+                            f"WCS contains a TPD distortion model in {kw}, which requires WCSLIB "
+                            f"7.4 or later to store in a FITS header (having {_wcs.__version__}).",
+                            AstropyWarning)
         else:
             header = fits.Header()
 
