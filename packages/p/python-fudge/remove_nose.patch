---
 fudge/tests/test_fudge.py     |  713 +++++++++++++++++++++---------------------
 fudge/tests/test_inspector.py |   93 ++---
 fudge/tests/test_patcher.py   |  416 ++++++++++++------------
 fudge/tests/test_registry.py  |  119 +++----
 setup.py                      |    2 
 8 files changed, 678 insertions(+), 680 deletions(-)

--- a/fudge/tests/test_fudge.py
+++ b/fudge/tests/test_fudge.py
@@ -2,9 +2,6 @@ from __future__ import with_statement
 import sys
 import unittest
 
-from nose.tools import eq_, raises
-from nose.exc import SkipTest
-
 import fudge
 from fudge.inspector import arg
 from fudge import (
@@ -17,15 +14,19 @@ def test_decorator_on_def():
     bobby = fudge.Fake()
     bobby.expects("suzie_called")
 
-    @raises(AssertionError)
     @fudge.with_fakes
     def some_test():
-        holder.test_called = True
+        try:
+            holder.test_called = True
+        except AssertionError:
+            pass
+        else:
+            raise AssertionError("Didn't raise AssertionError")
 
-    eq_(some_test.__name__, 'some_test')
+    assert some_test.__name__ == 'some_test'
     some_test()
 
-    eq_(holder.test_called, True)
+    assert holder.test_called == True
 
 # for a test below
 _some_fake = fudge.Fake()
@@ -34,54 +35,54 @@ class TestFake(unittest.TestCase):
 
     def test_guess_name(self):
         if sys.platform.startswith('java'):
-            raise SkipTest("not supported")
+            raise unittest.SkipTest("not supported")
         my_obj = fudge.Fake()
-        eq_(repr(my_obj), "fake:my_obj")
+        self.assertEqual(repr(my_obj), "fake:my_obj")
 
     def test_guess_name_globals(self):
         if sys.platform.startswith('java'):
-            raise SkipTest("not supported")
-        eq_(repr(_some_fake), "fake:_some_fake")
+            raise unittest.SkipTest("not supported")
+        self.assertEqual(repr(_some_fake), "fake:_some_fake")
 
     def test_guess_name_deref(self):
         if sys.platform.startswith('java'):
-            raise SkipTest("not supported")
+            raise unittest.SkipTest("not supported")
         my_obj = 44
         my_obj = fudge.Fake()
-        eq_(repr(my_obj), "fake:my_obj")
+        self.assertEqual(repr(my_obj), "fake:my_obj")
 
     def test_has_attr(self):
         my_obj = fudge.Fake().has_attr(vice='versa', beach='playa')
-        eq_(my_obj.vice, 'versa')
-        eq_(my_obj.beach, 'playa')
+        self.assertEqual(my_obj.vice, 'versa')
+        self.assertEqual(my_obj.beach, 'playa')
 
     def test_has_property(self):
         fake_vise = fudge.Fake().is_callable().returns('versa')
         fake_stuff = fudge.Fake().is_callable().raises(
             Exception('broken stuff'))
         my_obj = fudge.Fake().has_property(vice=fake_vise, stuff=fake_stuff)
-        eq_(my_obj.vice, 'versa')
+        self.assertEqual(my_obj.vice, 'versa')
         try:
             my_obj.stuff
-        except Exception, exc:
-            eq_(str(exc), 'broken stuff')
+        except Exception as exc:
+            self.assertEqual(str(exc), 'broken stuff')
         else:
             raise RuntimeError('expected Exception')
 
     def test_attributes_are_settable(self):
         my_obj = fudge.Fake().has_attr(vice='versa')
         my_obj.vice = 'miami'
-        eq_(my_obj.vice, 'miami')
+        self.assertEqual(my_obj.vice, 'miami')
 
     def test_none_type_attributes_are_settable(self):
         my_obj = fudge.Fake().has_attr(vice=None)
-        eq_(my_obj.vice, None)
+        self.assertEqual(my_obj.vice, None)
         my_obj.vice = 'miami'
-        eq_(my_obj.vice, 'miami')
+        self.assertEqual(my_obj.vice, 'miami')
 
     def test_attributes_can_replace_internals(self):
         my_obj = fudge.Fake().has_attr(provides='hijacked')
-        eq_(my_obj.provides, 'hijacked')
+        self.assertEqual(my_obj.provides, 'hijacked')
 
     def test_repr_shortens_long_values(self):
         fake = Fake("widget").provides("set_bits").with_args(
@@ -89,8 +90,8 @@ class TestFake(unittest.TestCase):
         )
         try:
             fake.set_bits()
-        except AssertionError, exc:
-            eq_(str(exc),
+        except AssertionError as exc:
+            self.assertEqual(str(exc),
             "fake:widget.set_bits('123456789101112131415161718192021222324252627...') "
             "was called unexpectedly with args ()")
         else:
@@ -106,14 +107,14 @@ class TestChainedNames(unittest.TestCase
         fudge.clear_expectations()
 
     def test_basic(self):
-        eq_(repr(self.fake), 'fake:db.Adapter')
+        self.assertEqual(repr(self.fake), 'fake:db.Adapter')
 
     def test_nesting(self):
         f = self.fake
         f = f.provides('query').returns_fake().provides('fetchall')
-        eq_(repr(f), 'fake:db.Adapter.query()')
+        self.assertEqual(repr(f), 'fake:db.Adapter.query()')
         f = f.provides('cursor').returns_fake()
-        eq_(repr(f), 'fake:db.Adapter.query().cursor()')
+        self.assertEqual(repr(f), 'fake:db.Adapter.query().cursor()')
 
     def test_more_nesting(self):
         class ctx:
@@ -125,7 +126,7 @@ class TestChainedNames(unittest.TestCase
              .provides('sendmail'))
             ctx.fake = fake_SMTP()
         test()
-        eq_(str(ctx.fake), 'fake:smtplib.SMTP()')
+        self.assertEqual(str(ctx.fake), 'fake:smtplib.SMTP()')
 
 
 class TestIsAStub(unittest.TestCase):
@@ -171,16 +172,16 @@ class TestIsAStub(unittest.TestCase):
         f.foo.bar().expects('barfoo')
         f.foo.bar().barfoo()
 
-    @raises(AssertionError)
     def test_infinite_path_expectation_is_verified(self):
-        f = fudge.Fake().is_a_stub()
-        f.foo.bar().expects('barfoo').with_args(foo='bar')
-        f.foo.bar().barfoo()
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            f = fudge.Fake().is_a_stub()
+            f.foo.bar().expects('barfoo').with_args(foo='bar')
+            f.foo.bar().barfoo()
+            fudge.verify()
 
     def test_infinite_path_naming(self):
         f = fudge.Fake(name='base').is_a_stub()
-        eq_(str(f.foo.bar().baz), 'fake:base.foo.bar().baz')
+        self.assertEqual(str(f.foo.bar().baz), 'fake:base.foo.bar().baz')
 
 
 class TestLongArgValues(unittest.TestCase):
@@ -192,8 +193,8 @@ class TestLongArgValues(unittest.TestCas
         try:
             # this should not be shortened but the above arg spec should:
             fake.set_bits("99999999999999999999999999999999999999999999999999999999")
-        except AssertionError, exc:
-            eq_(str(exc),
+        except AssertionError as exc:
+            self.assertEqual(str(exc),
             "fake:widget.set_bits('123456789101112131415161718192021222324252627...') "
             "was called unexpectedly with args "
             "('99999999999999999999999999999999999999999999999999999999')")
@@ -207,8 +208,8 @@ class TestLongArgValues(unittest.TestCas
         try:
             # this should not be shortened but the above arg spec should:
             fake.set_bits(newbits="99999999999999999999999999999999999999999999999999999999")
-        except AssertionError, exc:
-            eq_(str(exc),
+        except AssertionError as exc:
+            self.assertEqual(str(exc),
             "fake:widget.set_bits(newbits='123456789101112131415161718192021222324252627...') "
             "was called unexpectedly with args "
             "(newbits='99999999999999999999999999999999999999999999999999999999')")
@@ -223,65 +224,65 @@ class TestArguments(unittest.TestCase):
     def tearDown(self):
         fudge.clear_expectations()
 
-    @raises(AssertionError)
     def test_wrong_args(self):
-        exp = self.fake.expects('theCall').with_args(
-                        1,
-                        "ho ho ho ho ho ho ho, it's Santa",
-                        {'ditto':False})
-        exp.theCall()
+        with self.assertRaises(AssertionError):
+            exp = self.fake.expects('theCall').with_args(
+                            1,
+                            "ho ho ho ho ho ho ho, it's Santa",
+                            {'ditto':False})
+            exp.theCall()
 
-    @raises(AssertionError)
     def test_wrong_kwargs(self):
-        exp = self.fake.expects('other').with_args(one="twozy", items=[1,2,3,4])
-        exp.other(nice="NOT NICE")
+        with self.assertRaises(AssertionError):
+            exp = self.fake.expects('other').with_args(one="twozy", items=[1,2,3,4])
+            exp.other(nice="NOT NICE")
 
-    @raises(AssertionError)
     def test_arg_count(self):
-        exp = self.fake.expects('one').with_arg_count(3)
-        exp.one('no', 'maybe')
+        with self.assertRaises(AssertionError):
+            exp = self.fake.expects('one').with_arg_count(3)
+            exp.one('no', 'maybe')
 
-    @raises(AssertionError)
     def test_kwarg_count(self):
-        exp = self.fake.expects('__init__').with_kwarg_count(2)
-        exp(maybe="yes, maybe")
+        with self.assertRaises(AssertionError):
+            exp = self.fake.expects('__init__').with_kwarg_count(2)
+            exp(maybe="yes, maybe")
 
-    @raises(FakeDeclarationError)
     def test_with_args_requires_a_method(self):
-        self.fake.with_args('something')
+        with self.assertRaises(FakeDeclarationError):
+            self.fake.with_args('something')
 
-    @raises(AssertionError)
     def test_with_args_can_operate_on_provision(self):
-        self.fake.provides("not_expected").with_args('something')
-        self.fake.not_expected() # should still raise arg error
+        with self.assertRaises(AssertionError):
+            self.fake.provides("not_expected").with_args('something')
+            self.fake.not_expected() # should still raise arg error
 
-    @raises(AssertionError)
     def test_with_args_checks_args(self):
-        self.fake.expects('count').with_args('one', two='two')
-        self.fake.count(two='two')
+        with self.assertRaises(AssertionError):
+            self.fake.expects('count').with_args('one', two='two')
+            self.fake.count(two='two')
 
-    @raises(AssertionError)
     def test_with_args_checks_kwargs(self):
-        self.fake.expects('count').with_args('one', two='two')
-        self.fake.count('one')
+        with self.assertRaises(AssertionError):
+            self.fake.expects('count').with_args('one', two='two')
+            self.fake.count('one')
 
-    @raises(AssertionError)
     def test_raises_does_not_obscure_with_kwargs(self):
         # previously, this test failed because the raises(exc)
         # was raised too early.  Issue 6
-        self.fake.expects('count').with_args(two='two').raises(RuntimeError('bork'))
-        self.fake.count('one') # wrong kwargs
+        with self.assertRaises(AssertionError):
+            self.fake.expects('count').with_args(two='two').raises(RuntimeError('bork'))
+            self.fake.count('one') # wrong kwargs
 
-    @raises(AssertionError)
     def test_raises_does_not_obscure_with_args(self):
         # Issue 6
-        self.fake.expects('count').with_args('one').raises(RuntimeError('bork'))
-        self.fake.count(two='two') # wrong args
+        with self.assertRaises(AssertionError):
+            self.fake.expects('count').with_args('one').raises(RuntimeError('bork'))
+            self.fake.count(two='two') # wrong args
 
-    @raises(AssertionError)
     def test_too_many_args(self):
-        db = Fake("db").expects("execute").with_args(bind={'one':1})
-        db.execute("select foozilate()", bind={'one':1}) # unexpected statement arg
+        with self.assertRaises(AssertionError):
+            db = Fake("db").expects("execute").with_args(bind={'one':1})
+            db.execute("select foozilate()", bind={'one':1}) # unexpected statement arg
 
     def test_zero_keywords_ok(self):
         mail = fudge.Fake('mail').expects('send').with_arg_count(3)
@@ -319,37 +320,37 @@ class TestArguments(unittest.TestCase):
         db.transaction("insert", isolation_level="lock")
         fudge.verify()
 
-    @raises(AssertionError)
     def test_with_non_matching_positional_args(self):
-        db = self.fake
-        db.expects('transaction').with_matching_args('update')
-        db.transaction("insert", isolation_level="lock")
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            db = self.fake
+            db.expects('transaction').with_matching_args('update')
+            db.transaction("insert", isolation_level="lock")
+            fudge.verify()
 
-    @raises(AssertionError)
     def test_with_too_many_non_matching_positional_args(self):
         # this may be unintuitve but specifying too many
         # arguments constitutes as non-matching.  Why?
         # Because how else is it possible to implement, by index?
-        db = self.fake
-        db.expects('transaction').with_matching_args('update')
-        db.transaction("update", "delete", isolation_level="lock")
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            db = self.fake
+            db.expects('transaction').with_matching_args('update')
+            db.transaction("update", "delete", isolation_level="lock")
+            fudge.verify()
 
-    @raises(AssertionError)
     def test_with_non_matching_keyword_args(self):
-        db = self.fake
-        db.expects('transaction').with_matching_args(isolation_level="read")
-        db.transaction("insert", isolation_level="lock")
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            db = self.fake
+            db.expects('transaction').with_matching_args(isolation_level="read")
+            db.transaction("insert", isolation_level="lock")
+            fudge.verify()
 
-    @raises(AssertionError)
     def test_missing_matching_positional_args_is_not_ok(self):
         # this is awkward to implement so I think it should not be supported
-        db = self.fake
-        db.expects('transaction').with_matching_args("update")
-        db.transaction()
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            db = self.fake
+            db.expects('transaction').with_matching_args("update")
+            db.transaction()
+            fudge.verify()
 
     def test_missing_matching_keyword_args_is_ok(self):
         db = self.fake
@@ -366,29 +367,29 @@ class TestArguments(unittest.TestCase):
 #         self.call = Call(self.fake)
 #
 #     def test_empty(self):
-#         eq_(self.call._arg_diff(tuple(), tuple()), "")
+#         self.assertEqual(self.call._arg_diff(tuple(), tuple()), "")
 #
 #     def test_one_unexpected(self):
-#         eq_(self.call._arg_diff(('one',), tuple()), "arg #1 was unexpected")
+#         self.assertEqual(self.call._arg_diff(('one',), tuple()), "arg #1 was unexpected")
 #
 #     def test_one_missing(self):
-#         eq_(self.call._arg_diff(tuple(), ('one',)), "arg #1 never showed up")
+#         self.assertEqual(self.call._arg_diff(tuple(), ('one',)), "arg #1 never showed up")
 #
 #     def test_four_unexpected(self):
-#         eq_(self.call._arg_diff(
+#         self.assertEqual(self.call._arg_diff(
 #             ('one','two','three','four'),
 #             ('one','two','three')), "arg #4 was unexpected")
 #
 #     def test_four_missing(self):
-#         eq_(self.call._arg_diff(
+#         self.assertEqual(self.call._arg_diff(
 #             ('one','two','three'),
 #             ('one','two','three','four')), "arg #4 never showed up")
 #
 #     def test_one_mismatch(self):
-#         eq_(self.call._arg_diff(('won',), ('one',)), "arg #1 'won' != 'one'")
+#         self.assertEqual(self.call._arg_diff(('won',), ('one',)), "arg #1 'won' != 'one'")
 #
 #     def test_four_mismatch(self):
-#         eq_(self.call._arg_diff(
+#         self.assertEqual(self.call._arg_diff(
 #             ('one','two','three','not four'),
 #             ('one','two','three','four')), "arg #4 'not four' != 'four'")
 
@@ -399,50 +400,50 @@ class TestArguments(unittest.TestCase):
 #         self.call = Call(self.fake)
 #
 #     def test_empty(self):
-#         eq_(self.call._keyword_diff({}, {}), (True, ""))
+#         self.assertEqual(self.call._keyword_diff({}, {}), (True, ""))
 #
 #     def test_one_empty(self):
-#         eq_(self.call._keyword_diff({},
+#         self.assertEqual(self.call._keyword_diff({},
 #             {'something':'here','another':'there'}),
 #             (False, "these keywords never showed up: ('something', 'another')"))
 #
 #     def test_complex_match_yields_no_reason(self):
 #         actual = {'num':1, 'two':2, 'three':3}
 #         expected = {'num':1, 'two':2, 'three':3}
-#         eq_(self.call._keyword_diff(actual, expected), (True, ""))
+#         self.assertEqual(self.call._keyword_diff(actual, expected), (True, ""))
 #
 #     def test_simple_mismatch_yields_no_reason(self):
 #         actual = {'num':1}
 #         expected = {'num':2}
-#         eq_(self.call._keyword_diff(actual, expected), (False, ""))
+#         self.assertEqual(self.call._keyword_diff(actual, expected), (False, ""))
 #
 #     def test_simple_match_yields_no_reason(self):
 #         actual = {'num':1}
 #         expected = {'num':1}
-#         eq_(self.call._keyword_diff(actual, expected), (True, ""))
+#         self.assertEqual(self.call._keyword_diff(actual, expected), (True, ""))
 #
 #     def test_actual_kw_extra_key(self):
 #         actual = {'one':1, 'two':2}
 #         expected = {'one':1}
-#         eq_(self.call._keyword_diff(actual, expected),
+#         self.assertEqual(self.call._keyword_diff(actual, expected),
 #             (False, "keyword 'two' was not expected"))
 #
 #     def test_actual_kw_value_inequal(self):
 #         actual = {'one':1, 'two':2}
 #         expected = {'one':1, 'two':3}
-#         eq_(self.call._keyword_diff(actual, expected),
+#         self.assertEqual(self.call._keyword_diff(actual, expected),
 #             (False, "two=2 != two=3"))
 #
 #     def test_expected_kw_extra_key(self):
 #         actual = {'one':1}
 #         expected = {'one':1, 'two':2}
-#         eq_(self.call._keyword_diff(actual, expected),
+#         self.assertEqual(self.call._keyword_diff(actual, expected),
 #             (False, "this keyword never showed up: ('two',)"))
 #
 #     def test_expected_kw_value_inequal(self):
 #         actual = {'one':1, 'two':'not two'}
 #         expected = {'one':1, 'two':2}
-#         eq_(self.call._keyword_diff(actual, expected),
+#         self.assertEqual(self.call._keyword_diff(actual, expected),
 #             (False, "two='not two' != two=2"))
 
 class TestCall(unittest.TestCase):
@@ -452,41 +453,41 @@ class TestCall(unittest.TestCase):
 
     def test_repr(self):
         s = Call(self.fake)
-        eq_(repr(s), "fake:SMTP()")
+        self.assertEqual(repr(s), "fake:SMTP()")
 
     def test_repr_callable(self):
         s = Call(self.fake.is_callable())
-        eq_(repr(s), "fake:SMTP()")
+        self.assertEqual(repr(s), "fake:SMTP()")
 
     def test_repr_with_args(self):
         s = Call(self.fake)
         s.expected_args = [1,"bad"]
-        eq_(repr(s), "fake:SMTP(1, 'bad')")
+        self.assertEqual(repr(s), "fake:SMTP(1, 'bad')")
 
     def test_repr_with_kwargs(self):
         s = Call(self.fake)
         s.expected_args = [1,"bad"]
         s.expected_kwargs = {'baz':'borzo'}
-        eq_(repr(s), "fake:SMTP(1, 'bad', baz='borzo')")
+        self.assertEqual(repr(s), "fake:SMTP(1, 'bad', baz='borzo')")
 
     def test_named_repr_with_args(self):
         s = Call(self.fake, call_name='connect')
         s.expected_args = [1,"bad"]
-        eq_(repr(s), "fake:SMTP.connect(1, 'bad')")
+        self.assertEqual(repr(s), "fake:SMTP.connect(1, 'bad')")
 
     def test_nested_named_repr_with_args(self):
         f = self.fake.provides('get_conn').returns_fake()
         s = Call(f, call_name='connect')
         s.expected_args = [1,"bad"]
-        eq_(repr(s), "fake:SMTP.get_conn().connect(1, 'bad')")
+        self.assertEqual(repr(s), "fake:SMTP.get_conn().connect(1, 'bad')")
 
     def test_named_repr_with_index(self):
         s = Call(self.fake, call_name='connect')
         s.expected_args = [1,"bad"]
         s.index = 0
-        eq_(repr(s), "fake:SMTP.connect(1, 'bad')[0]")
+        self.assertEqual(repr(s), "fake:SMTP.connect(1, 'bad')[0]")
         s.index = 1
-        eq_(repr(s), "fake:SMTP.connect(1, 'bad')[1]")
+        self.assertEqual(repr(s), "fake:SMTP.connect(1, 'bad')[1]")
 
 
 class TestCallStack(unittest.TestCase):
@@ -505,24 +506,24 @@ class TestCallStack(unittest.TestCase):
         c.return_val = 2
         call_stack.add_call(c)
 
-        eq_(call_stack(), 1)
-        eq_(call_stack(), 2)
+        self.assertEqual(call_stack(), 1)
+        self.assertEqual(call_stack(), 2)
 
-    @raises(AssertionError)
     def test_no_calls(self):
-        call_stack = CallStack(self.fake)
-        call_stack()
+        with self.assertRaises(AssertionError):
+            call_stack = CallStack(self.fake)
+            call_stack()
 
-    @raises(AssertionError)
     def test_end_of_calls(self):
-        call_stack = CallStack(self.fake)
+        with self.assertRaises(AssertionError):
+            call_stack = CallStack(self.fake)
 
-        c = Call(self.fake)
-        c.return_val = 1
-        call_stack.add_call(c)
+            c = Call(self.fake)
+            c.return_val = 1
+            call_stack.add_call(c)
 
-        eq_(call_stack(), 1)
-        call_stack()
+            self.assertEqual(call_stack(), 1)
+            call_stack()
 
     def test_get_call_object(self):
         call_stack = CallStack(self.fake)
@@ -542,7 +543,7 @@ class TestCallStack(unittest.TestCase):
         c.return_val = 1
         call_stack = CallStack(self.fake, initial_calls=[c])
 
-        eq_(call_stack(), 1)
+        self.assertEqual(call_stack(), 1)
 
     def test_reset(self):
         call_stack = CallStack(self.fake)
@@ -555,47 +556,47 @@ class TestCallStack(unittest.TestCase):
         c.return_val = 2
         call_stack.add_call(c)
 
-        eq_(call_stack(), 1)
-        eq_(call_stack(), 2)
+        self.assertEqual(call_stack(), 1)
+        self.assertEqual(call_stack(), 2)
 
         call_stack.reset()
 
-        eq_(call_stack(), 1)
-        eq_(call_stack(), 2)
+        self.assertEqual(call_stack(), 1)
+        self.assertEqual(call_stack(), 2)
 
 class TestFakeCallables(unittest.TestCase):
 
     def tearDown(self):
         fudge.clear_expectations()
 
-    @raises(RuntimeError)
     def test_not_callable_by_default(self):
-        self.fake = fudge.Fake()
-        self.fake()
+        with self.assertRaises(RuntimeError):
+            self.fake = fudge.Fake()
+            self.fake()
 
     def test_callable(self):
         fake = fudge.Fake().is_callable()
         fake() # allow the call
         fudge.verify() # no error
 
-    @raises(AttributeError)
     def test_cannot_stub_any_call_by_default(self):
-        self.fake.Anything() # must define this first
+        with self.assertRaises(AttributeError):
+            self.fake.Anything() # must define this first
 
-    @raises(AssertionError)
     def test_stub_with_args(self):
-        self.fake = fudge.Fake().is_callable().with_args(1,2)
-        self.fake(1)
+        with self.assertRaises(AssertionError):
+            self.fake = fudge.Fake().is_callable().with_args(1,2)
+            self.fake(1)
 
-    @raises(AssertionError)
     def test_stub_with_arg_count(self):
-        self.fake = fudge.Fake().is_callable().with_arg_count(3)
-        self.fake('bah')
+        with self.assertRaises(AssertionError):
+            self.fake = fudge.Fake().is_callable().with_arg_count(3)
+            self.fake('bah')
 
-    @raises(AssertionError)
     def test_stub_with_kwarg_count(self):
-        self.fake = fudge.Fake().is_callable().with_kwarg_count(3)
-        self.fake(two=1)
+        with self.assertRaises(AssertionError):
+            self.fake = fudge.Fake().is_callable().with_kwarg_count(3)
+            self.fake(two=1)
 
     def test_stub_with_provides(self):
         self.fake = fudge.Fake().provides("something")
@@ -608,28 +609,28 @@ class TestFakeCallables(unittest.TestCas
 
         # replace Fake.with_args()
         self.fake = fudge.Fake().provides("with_args").returns(1)
-        eq_(self.fake.with_args(), 1)
+        self.assertEqual(self.fake.with_args(), 1)
 
-    @raises(AssertionError)
     def test_stub_with_provides_and_args(self):
-        self.fake = fudge.Fake().provides("something").with_args(1,2)
-        self.fake.something()
+        with self.assertRaises(AssertionError):
+            self.fake = fudge.Fake().provides("something").with_args(1,2)
+            self.fake.something()
 
     def test_stub_is_not_registered(self):
         self.fake = fudge.Fake().provides("something")
         exp = self.fake._get_current_call()
-        eq_(exp.call_name, "something")
-        assert exp not in fudge.registry
+        self.assertEqual(exp.call_name, "something")
+        self.assertNotIn(exp, fudge.registry)
 
-    @raises(RuntimeError)
     def test_raises_class(self):
-        self.fake = fudge.Fake().provides("fail").raises(RuntimeError)
-        self.fake.fail()
+        with self.assertRaises(RuntimeError):
+            self.fake = fudge.Fake().provides("fail").raises(RuntimeError)
+            self.fake.fail()
 
-    @raises(RuntimeError)
     def test_raises_instance(self):
-        self.fake = fudge.Fake().provides("fail").raises(RuntimeError("batteries ran out"))
-        self.fake.fail()
+        with self.assertRaises(RuntimeError):
+            self.fake = fudge.Fake().provides("fail").raises(RuntimeError("batteries ran out"))
+            self.fake.fail()
 
 class TestReplacementCalls(unittest.TestCase):
 
@@ -642,7 +643,7 @@ class TestReplacementCalls(unittest.Test
             return "hijacked"
 
         fake = fudge.Fake().provides("something").calls(something)
-        eq_(fake.something(), "hijacked")
+        self.assertEqual(fake.something(), "hijacked")
 
     def test_calls_mixed_with_returns(self):
 
@@ -652,18 +653,18 @@ class TestReplacementCalls(unittest.Test
             return "hijacked"
 
         fake = fudge.Fake().provides("something").calls(something).returns("other")
-        eq_(fake.something(), "other")
-        eq_(called, [True])
+        self.assertEqual(fake.something(), "other")
+        self.assertEqual(called, [True])
 
-    @raises(AssertionError)
     def test_calls_mixed_with_expectations(self):
 
         def something():
             return "hijacked"
 
-        # with_args() expectation should not get lost:
-        fake = fudge.Fake().provides("something").calls(something).with_args(1,2)
-        eq_(fake.something(), "hijacked")
+        with self.assertRaises(AssertionError):
+            # with_args() expectation should not get lost:
+            fake = fudge.Fake().provides("something").calls(something).with_args(1,2)
+            self.assertEqual(fake.something(), "hijacked")
 
     def test_replace_init(self):
 
@@ -672,7 +673,7 @@ class TestReplacementCalls(unittest.Test
                 return "hi"
 
         fake = fudge.Fake().provides("__init__").returns(custom_object())
-        eq_(fake().hello(), "hi")
+        self.assertEqual(fake().hello(), "hi")
 
 class TestFakeTimesCalled(unittest.TestCase):
 
@@ -684,32 +685,32 @@ class TestFakeTimesCalled(unittest.TestC
         # this should not raise an error because the call was provided not expected
         fudge.verify()
 
-    @raises(AssertionError)
     def test_when_provided_raises_on_too_many_calls(self):
-        self.fake = fudge.Fake().provides("something").times_called(2)
-        self.fake.something()
-        self.fake.something()
-        self.fake.something() # too many
+        with self.assertRaises(AssertionError):
+            self.fake = fudge.Fake().provides("something").times_called(2)
+            self.fake.something()
+            self.fake.something()
+            self.fake.something() # too many
 
-    @raises(AssertionError)
     def test_when_expected(self):
-        self.fake = fudge.Fake().expects("something").times_called(2)
-        self.fake.something()
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            self.fake = fudge.Fake().expects("something").times_called(2)
+            self.fake.something()
+            fudge.verify()
 
-    @raises(AssertionError)
     def test_when_expected_raises_on_too_many_calls(self):
-        self.fake = fudge.Fake().expects("something").times_called(2)
-        self.fake.something()
-        self.fake.something()
-        self.fake.something() # too many
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            self.fake = fudge.Fake().expects("something").times_called(2)
+            self.fake.something()
+            self.fake.something()
+            self.fake.something() # too many
+            fudge.verify()
 
-    @raises(AssertionError)
     def test_expected_callable(self):
-        login = fudge.Fake('login',expect_call=True).times_called(2)
-        login()
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            login = fudge.Fake('login',expect_call=True).times_called(2)
+            login()
+            fudge.verify()
 
     def test_callable_ok(self):
         self.fake = fudge.Fake(callable=True).times_called(2)
@@ -734,19 +735,19 @@ class TestNextCall(unittest.TestCase):
     def tearDown(self):
         fudge.clear_expectations()
 
-    @raises(FakeDeclarationError)
     def test_next_call_then_times_called_is_error(self):
-        self.fake = fudge.Fake().expects("hi").returns("goodday").next_call().times_called(4)
-        self.fake.hi()
-        self.fake.hi()
-        fudge.verify()
+        with self.assertRaises(FakeDeclarationError):
+            self.fake = fudge.Fake().expects("hi").returns("goodday").next_call().times_called(4)
+            self.fake.hi()
+            self.fake.hi()
+            fudge.verify()
 
-    @raises(FakeDeclarationError)
     def test_times_called_then_next_call_is_error(self):
-        self.fake = fudge.Fake().expects("hi").times_called(4).next_call()
-        self.fake.hi()
-        self.fake.hi()
-        fudge.verify()
+        with self.assertRaises(FakeDeclarationError):
+            self.fake = fudge.Fake().expects("hi").times_called(4).next_call()
+            self.fake.hi()
+            self.fake.hi()
+            fudge.verify()
 
     def test_stacked_returns(self):
         fake = fudge.Fake().provides("something")
@@ -756,20 +757,20 @@ class TestNextCall(unittest.TestCase):
         fake = fake.next_call()
         fake = fake.returns(3)
 
-        eq_(fake.something(), 1)
-        eq_(fake.something(), 2)
-        eq_(fake.something(), 3)
+        self.assertEqual(fake.something(), 1)
+        self.assertEqual(fake.something(), 2)
+        self.assertEqual(fake.something(), 3)
 
-    @raises(AssertionError)
     def test_stacked_calls_are_finite(self):
-        self.fake = fudge.Fake().provides("something")
-        self.fake = self.fake.returns(1)
-        self.fake = self.fake.next_call()
-        self.fake = self.fake.returns(2)
-
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 2)
-        self.fake.something()
+        with self.assertRaises(AssertionError):
+            self.fake = fudge.Fake().provides("something")
+            self.fake = self.fake.returns(1)
+            self.fake = self.fake.next_call()
+            self.fake = self.fake.returns(2)
+
+            self.assertEqual(self.fake.something(), 1)
+            self.assertEqual(self.fake.something(), 2)
+            self.fake.something()
 
     def test_stack_is_reset_when_name_changes(self):
         self.fake = fudge.Fake().provides("something")
@@ -779,13 +780,13 @@ class TestNextCall(unittest.TestCase):
         self.fake = self.fake.provides("other")
         self.fake = self.fake.returns(3)
 
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 2)
-        eq_(self.fake.other(), 3)
-        eq_(self.fake.other(), 3)
-        eq_(self.fake.other(), 3)
-        eq_(self.fake.other(), 3)
-        eq_(self.fake.other(), 3)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 2)
+        self.assertEqual(self.fake.other(), 3)
+        self.assertEqual(self.fake.other(), 3)
+        self.assertEqual(self.fake.other(), 3)
+        self.assertEqual(self.fake.other(), 3)
+        self.assertEqual(self.fake.other(), 3)
 
     def test_next_call_with_multiple_returns(self):
         self.fake = fudge.Fake().provides("something")
@@ -797,10 +798,10 @@ class TestNextCall(unittest.TestCase):
         self.fake = self.fake.next_call()
         self.fake = self.fake.returns(4)
 
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 2)
-        eq_(self.fake.other(), 3)
-        eq_(self.fake.other(), 4)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 2)
+        self.assertEqual(self.fake.other(), 3)
+        self.assertEqual(self.fake.other(), 4)
 
     def test_stacked_calls_do_not_collide(self):
         self.fake = fudge.Fake().provides("something")
@@ -812,22 +813,22 @@ class TestNextCall(unittest.TestCase):
         self.fake = self.fake.next_call()
         self.fake = self.fake.returns(4)
 
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.other(), 3)
-        eq_(self.fake.something(), 2)
-        eq_(self.fake.other(), 4)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.other(), 3)
+        self.assertEqual(self.fake.something(), 2)
+        self.assertEqual(self.fake.other(), 4)
 
     def test_returns_are_infinite(self):
         self.fake = fudge.Fake().provides("something").returns(1)
 
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 1)
 
     def test_stacked_does_not_copy_expectations(self):
 
@@ -837,8 +838,8 @@ class TestNextCall(unittest.TestCase):
         fake = fake.next_call()
         fake = fake.returns(-1)
 
-        eq_(fake.add(1,2), 3)
-        eq_(fake.add(), -1)
+        self.assertEqual(fake.add(1,2), 3)
+        self.assertEqual(fake.add(), -1)
 
     def test_stacked_calls_are_in_registry(self):
         fake = fudge.Fake().expects("count").with_args(1)
@@ -863,10 +864,10 @@ class TestNextCall(unittest.TestCase):
         # hmm
         call_stack = fake._declared_calls[fake._last_declared_call_name]
         calls = [c for c in call_stack]
-        eq_(calls[0].index, 0)
-        eq_(calls[1].index, 1)
-        eq_(calls[2].index, 2)
-        eq_(calls[3].index, 3)
+        self.assertEqual(calls[0].index, 0)
+        self.assertEqual(calls[1].index, 1)
+        self.assertEqual(calls[2].index, 2)
+        self.assertEqual(calls[3].index, 3)
 
     def test_start_stop_resets_stack(self):
         fudge.clear_expectations()
@@ -875,18 +876,18 @@ class TestNextCall(unittest.TestCase):
         fake = fake.next_call()
         fake = fake.returns(2)
 
-        eq_(fake.something(), 1)
-        eq_(fake.something(), 2)
+        self.assertEqual(fake.something(), 1)
+        self.assertEqual(fake.something(), 2)
 
         fudge.clear_calls()
 
-        eq_(fake.something(), 1)
-        eq_(fake.something(), 2)
+        self.assertEqual(fake.something(), 1)
+        self.assertEqual(fake.something(), 2)
 
         fudge.verify()
 
-        eq_(fake.something(), 1)
-        eq_(fake.something(), 2)
+        self.assertEqual(fake.something(), 1)
+        self.assertEqual(fake.something(), 2)
 
     def test_next_call_with_callables(self):
         login = (fudge.Fake('login')
@@ -896,9 +897,9 @@ class TestNextCall(unittest.TestCase):
                                 .returns("maybe")
                                 .next_call()
                                 .returns("no"))
-        eq_(login(), "yes")
-        eq_(login(), "maybe")
-        eq_(login(), "no")
+        self.assertEqual(login(), "yes")
+        self.assertEqual(login(), "maybe")
+        self.assertEqual(login(), "no")
 
     def test_returns(self):
         db = Fake("db")\
@@ -906,18 +907,18 @@ class TestNextCall(unittest.TestCase):
             .provides("set_id")\
             .next_call(for_method="get_id").returns(2)
         # print [c.return_val for c in db._declared_calls["get_id"]._calls]
-        eq_(db.get_id(), 1)
-        eq_(db.set_id(), None)
-        eq_(db.get_id(), 2)
+        self.assertEqual(db.get_id(), 1)
+        self.assertEqual(db.set_id(), None)
+        self.assertEqual(db.get_id(), 2)
 
     def test_expectations_with_multiple_return_values(self):
         db = Fake("db")\
             .expects("get_id").returns(1)\
             .expects("set_id")\
             .next_call(for_method="get_id").returns(2)
-        eq_(db.get_id(), 1)
-        eq_(db.set_id(), None)
-        eq_(db.get_id(), 2)
+        self.assertEqual(db.get_id(), 1)
+        self.assertEqual(db.set_id(), None)
+        self.assertEqual(db.get_id(), 2)
 
         fudge.verify()
 
@@ -927,11 +928,11 @@ class TestExpectsAndProvides(unittest.Te
     def tearDown(self):
         fudge.clear_expectations()
 
-    @raises(AssertionError)
     def test_nocall(self):
-        fake = fudge.Fake()
-        exp = fake.expects('something')
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            fake = fudge.Fake()
+            exp = fake.expects('something')
+            fudge.verify()
 
     def test_multiple_provides_on_chained_fakes_ok(self):
         db = Fake("db").provides("insert").returns_fake().provides("insert")
@@ -958,8 +959,8 @@ class TestExpectsAndProvides(unittest.Te
         self.fake = self.fake.expects("something")
         self.fake = self.fake.returns(2)
 
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 2)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 2)
 
     def test_multiple_provides_act_like_next_call(self):
         self.fake = fudge.Fake().provides("something")
@@ -967,8 +968,8 @@ class TestExpectsAndProvides(unittest.Te
         self.fake = self.fake.provides("something")
         self.fake = self.fake.returns(2)
 
-        eq_(self.fake.something(), 1)
-        eq_(self.fake.something(), 2)
+        self.assertEqual(self.fake.something(), 1)
+        self.assertEqual(self.fake.something(), 2)
 
     def test_multiple_expects_for_sep_methods(self):
         self.fake = (fudge.Fake()
@@ -982,10 +983,10 @@ class TestExpectsAndProvides(unittest.Te
                         .returns('B')
         )
 
-        eq_(self.fake.marco(), 1)
-        eq_(self.fake.marco(), 2)
-        eq_(self.fake.polo(), 'A')
-        eq_(self.fake.polo(), 'B')
+        self.assertEqual(self.fake.marco(), 1)
+        self.assertEqual(self.fake.marco(), 2)
+        self.assertEqual(self.fake.polo(), 'A')
+        self.assertEqual(self.fake.polo(), 'B')
 
     def test_multiple_provides_for_sep_methods(self):
         self.fake = (fudge.Fake()
@@ -999,60 +1000,60 @@ class TestExpectsAndProvides(unittest.Te
                         .returns('B')
         )
 
-        eq_(self.fake.marco(), 1)
-        eq_(self.fake.marco(), 2)
-        eq_(self.fake.polo(), 'A')
-        eq_(self.fake.polo(), 'B')
+        self.assertEqual(self.fake.marco(), 1)
+        self.assertEqual(self.fake.marco(), 2)
+        self.assertEqual(self.fake.polo(), 'A')
+        self.assertEqual(self.fake.polo(), 'B')
 
 class TestOrderedCalls(unittest.TestCase):
 
     def tearDown(self):
         fudge.clear_expectations()
 
-    @raises(AssertionError)
     def test_out_of_order(self):
-        fake = fudge.Fake().remember_order().expects("one").expects("two")
-        fake.two()
-        fake.one()
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            fake = fudge.Fake().remember_order().expects("one").expects("two")
+            fake.two()
+            fake.one()
+            fudge.verify()
 
-    @raises(FakeDeclarationError)
     def test_cannot_remember_order_when_callable_is_true(self):
-        fake = fudge.Fake().is_callable().remember_order()
+        with self.assertRaises(FakeDeclarationError):
+            fake = fudge.Fake().is_callable().remember_order()
 
-    @raises(FakeDeclarationError)
     def test_cannot_remember_order_when_expect_call_is_true(self):
-        fake = fudge.Fake(expect_call=True).remember_order()
+        with self.assertRaises(FakeDeclarationError):
+            fake = fudge.Fake(expect_call=True).remember_order()
 
-    @raises(AssertionError)
     def test_not_enough_calls(self):
-        # need to drop down a level to bypass expected calls:
-        r = Registry()
-        fake = Fake()
-        call_order = ExpectedCallOrder(fake)
-        r.remember_expected_call_order(call_order)
+        with self.assertRaises(AssertionError):
+            # need to drop down a level to bypass expected calls:
+            r = Registry()
+            fake = Fake()
+            call_order = ExpectedCallOrder(fake)
+            r.remember_expected_call_order(call_order)
 
-        exp = ExpectedCall(fake, "callMe", call_order=call_order)
-        call_order.add_expected_call(exp)
+            exp = ExpectedCall(fake, "callMe", call_order=call_order)
+            call_order.add_expected_call(exp)
 
-        r.verify()
+            r.verify()
 
-    @raises(AssertionError)
     def test_only_one_call(self):
-        # need to drop down a level to bypass expected calls:
-        r = Registry()
-        fake = Fake()
-        call_order = ExpectedCallOrder(fake)
-        r.remember_expected_call_order(call_order)
-
-        exp = ExpectedCall(fake, "one", call_order=call_order)
-        call_order.add_expected_call(exp)
-        exp() # call this
+        with self.assertRaises(AssertionError):
+            # need to drop down a level to bypass expected calls:
+            r = Registry()
+            fake = Fake()
+            call_order = ExpectedCallOrder(fake)
+            r.remember_expected_call_order(call_order)
+
+            exp = ExpectedCall(fake, "one", call_order=call_order)
+            call_order.add_expected_call(exp)
+            exp() # call this
 
-        exp = ExpectedCall(fake, "two", call_order=call_order)
-        call_order.add_expected_call(exp)
+            exp = ExpectedCall(fake, "two", call_order=call_order)
+            call_order.add_expected_call(exp)
 
-        r.verify()
+            r.verify()
 
     def test_incremental_order_assertion_ok(self):
         # need to drop down a level to bypass expected calls:
@@ -1075,38 +1076,38 @@ class TestOrderedCalls(unittest.TestCase
             .expects("get_id").returns(1)\
             .expects("set_id")\
             .next_call(for_method="get_id").returns(2)
-        eq_(db.get_id(), 1)
-        eq_(db.set_id(), None)
-        eq_(db.get_id(), 2)
+        self.assertEqual(db.get_id(), 1)
+        self.assertEqual(db.set_id(), None)
+        self.assertEqual(db.get_id(), 2)
         fudge.verify()
 
-    @raises(AssertionError)
     def test_chained_fakes_honor_order(self):
-        Thing = Fake("thing").remember_order().expects("__init__")
-        holder = Thing.expects("get_holder").returns_fake()
-        holder = holder.expects("init")
-
-        thing = Thing()
-        holder = thing.get_holder()
-        # missing thing.init()
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            Thing = Fake("thing").remember_order().expects("__init__")
+            holder = Thing.expects("get_holder").returns_fake()
+            holder = holder.expects("init")
+
+            thing = Thing()
+            holder = thing.get_holder()
+            # missing thing.init()
+            fudge.verify()
 
-    @raises(AssertionError)
     def test_too_many_calls(self):
-        db = Fake("db")\
-            .remember_order()\
-            .expects("get_id").returns(1)\
-            .expects("set_id")
-        eq_(db.get_id(), 1)
-        eq_(db.set_id(), None)
-        # extra :
-        eq_(db.get_id(), 1)
+        with self.assertRaises(AssertionError):
+            db = Fake("db")\
+                .remember_order()\
+                .expects("get_id").returns(1)\
+                .expects("set_id")
+            self.assertEqual(db.get_id(), 1)
+            self.assertEqual(db.set_id(), None)
+            # extra :
+            self.assertEqual(db.get_id(), 1)
 
-    @raises(AssertionError)
     def test_expects_call_shortcut(self):
-        remove = Fake("os.remove").expects_call()
-        fudge.verify()
-        assert isinstance(remove, Fake)
+        with self.assertRaises(AssertionError):
+            remove = Fake("os.remove").expects_call()
+            fudge.verify()
+            assert isinstance(remove, Fake)
 
     def test_expects_call_shortcut_ok(self):
         remove = Fake("os.remove").expects_call()
@@ -1139,37 +1140,37 @@ class TestPatchedFakes(unittest.TestCase
 
         some_test()
         fudge.verify() # should be no errors
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
 
     def test_expectations_are_verified(self):
 
         class holder:
             test_called = False
 
-        @raises(AssertionError)
         @fudge.patch('shutil.copy')
         def some_test(copy):
-            copy.expects('__call__')
-            holder.test_called = True
+            with self.assertRaises(AssertionError):
+                copy.expects('__call__')
+                holder.test_called = True
 
-        some_test()
-        eq_(holder.test_called, True)
+                some_test()
+                self.assertEqual(holder.test_called, True)
 
     def test_expectations_are_always_cleared(self):
 
         class holder:
             test_called = False
 
-        @raises(RuntimeError)
         @fudge.patch('shutil.copy')
         def some_test(copy):
-            holder.test_called = True
-            copy.expects_call()
-            raise RuntimeError
+            with self.assertRaises(RuntimeError):
+                holder.test_called = True
+                copy.expects_call()
+                raise RuntimeError
 
         some_test()
         fudge.verify() # should be no errors
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
 
     def test_calls_are_cleared(self):
 
@@ -1188,29 +1189,29 @@ class TestPatchedFakes(unittest.TestCase
 
         some_test()
         fudge.verify() # should be no errors
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
 
     def test_with_statement(self):
 
         class holder:
             test_called = False
 
-        @raises(AssertionError)
         def run_test():
-            with fudge.patch('shutil.copy') as copy:
-                copy.expects('__call__')
-                holder.test_called = True
+            with self.assertRaises(AssertionError):
+                with fudge.patch('shutil.copy') as copy:
+                    copy.expects('__call__')
+                    holder.test_called = True
 
         run_test()
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
 
     def test_with_statement_exception(self):
 
-        @raises(RuntimeError)
         def run_test():
-            with fudge.patch('shutil.copy') as copy:
-                copy.expects('__call__')
-                raise RuntimeError()
+            with self.assertRaises(RuntimeError):
+                with fudge.patch('shutil.copy') as copy:
+                    copy.expects('__call__')
+                    raise RuntimeError()
 
         run_test()
 
@@ -1226,7 +1227,7 @@ class TestNonPatchedFakeTest(unittest.Te
         def some_test():
             holder.test_called = True
 
-        eq_(some_test.__name__, 'some_test')
+        self.assertEqual(some_test.__name__, 'some_test')
 
     def test_expectations_are_cleared(self):
 
@@ -1242,23 +1243,23 @@ class TestNonPatchedFakeTest(unittest.Te
 
         some_test()
         fudge.verify() # should be no errors
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
 
     def test_expectations_are_always_cleared(self):
 
         class holder:
             test_called = False
 
-        @raises(RuntimeError)
         @fudge.test
         def some_test():
-            holder.test_called = True
-            fake = fudge.Fake('db').expects('save')
-            raise RuntimeError
+            with self.assertRaises(RuntimeError):
+                holder.test_called = True
+                fake = fudge.Fake('db').expects('save')
+                raise RuntimeError
 
         some_test()
         fudge.verify() # should be no errors
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
 
     def test_calls_are_cleared(self):
 
@@ -1277,13 +1278,13 @@ class TestNonPatchedFakeTest(unittest.Te
 
         some_test()
         fudge.verify() # should be no errors
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
 
-    @raises(AssertionError)
     def test_verify(self):
 
         @fudge.test
         def some_test():
             fake = fudge.Fake('db').expects('save')
 
-        some_test()
+        with self.assertRaises(AssertionError):
+            some_test()
--- a/fudge/tests/test_inspector.py
+++ b/fudge/tests/test_inspector.py
@@ -1,12 +1,9 @@
 # -*- coding: utf-8 -*-
-import re
 import unittest
 
-from nose.tools import eq_, raises
-
 import fudge
 from fudge import inspector
-from fudge.inspector import arg, arg_not
+from fudge.inspector import arg
 from fudge import Fake
 
 class TestAnyValue(unittest.TestCase):
@@ -20,11 +17,11 @@ class TestAnyValue(unittest.TestCase):
 
     def test_repr(self):
         any = inspector.AnyValue()
-        eq_(repr(any), "arg.any()")
+        self.assertEqual(repr(any), "arg.any()")
 
     def test_str(self):
         any = inspector.AnyValue()
-        eq_(str(any), "arg.any()")
+        self.assertEqual(str(any), "arg.any()")
 
 
 class TestPassesTest(unittest.TestCase):
@@ -38,12 +35,12 @@ class TestPassesTest(unittest.TestCase):
         counter = Fake("counter").expects("increment").with_args(arg.passes_test(isint))
         counter.increment(25)
 
-    @raises(AssertionError)
     def test_passes_fail(self):
         def is_str(v):
             return isinstance(v,str)
-        counter = Fake("counter").expects("set_name").with_args(arg.passes_test(is_str))
-        counter.set_name(25)
+        with self.assertRaises(AssertionError):
+            counter = Fake("counter").expects("set_name").with_args(arg.passes_test(is_str))
+            counter.set_name(25)
 
     def test_repr(self):
         class test(object):
@@ -53,7 +50,7 @@ class TestPassesTest(unittest.TestCase):
                 return "v is an int"
 
         passes = inspector.PassesTest(test())
-        eq_(repr(passes), "arg.passes_test(v is an int)")
+        self.assertEqual(repr(passes), "arg.passes_test(v is an int)")
 
     def test_str(self):
         class test(object):
@@ -63,7 +60,7 @@ class TestPassesTest(unittest.TestCase):
                 return "v is an int"
 
         passes = inspector.PassesTest(test())
-        eq_(str(passes), "arg.passes_test(v is an int)")
+        self.assertEqual(str(passes), "arg.passes_test(v is an int)")
 
 class TestIsInstance(unittest.TestCase):
 
@@ -74,22 +71,22 @@ class TestIsInstance(unittest.TestCase):
         counter = Fake("counter").expects("increment").with_args(arg.isinstance(int))
         counter.increment(25)
 
-    @raises(AssertionError)
     def test_passes_fail(self):
-        counter = Fake("counter").expects("set_name").with_args(arg.isinstance(str))
-        counter.set_name(25)
+        with self.assertRaises(AssertionError):
+            counter = Fake("counter").expects("set_name").with_args(arg.isinstance(str))
+            counter.set_name(25)
 
     def test_repr(self):
         passes = inspector.IsInstance(int)
-        eq_(repr(passes), "arg.isinstance('int')")
+        self.assertEqual(repr(passes), "arg.isinstance('int')")
 
     def test_str(self):
         passes = inspector.IsInstance(str)
-        eq_(str(passes), "arg.isinstance('str')")
+        self.assertEqual(str(passes), "arg.isinstance('str')")
 
     def test_list(self):
         passes = inspector.IsInstance((str, int))
-        eq_(str(passes), "arg.isinstance(('str', 'int'))")
+        self.assertEqual(str(passes), "arg.isinstance(('str', 'int'))")
 
 class TestObjectlike(unittest.TestCase):
 
@@ -106,40 +103,40 @@ class TestObjectlike(unittest.TestCase):
                                .with_args(arg.has_attr(size=12,color='red'))
         widget.configure(Config())
 
-    @raises(AssertionError)
     def test_has_attr_fail(self):
         class Config(object):
             color = 'red'
 
-        widget = Fake("widget").expects("configure")\
-                               .with_args(arg.has_attr(size=12))
-        widget.configure(Config())
+        with self.assertRaises(AssertionError):
+            widget = Fake("widget").expects("configure")\
+                                   .with_args(arg.has_attr(size=12))
+            widget.configure(Config())
 
-    @raises(AssertionError)
     def test_has_attr_fail_wrong_value(self):
         class Config(object):
             color = 'red'
 
-        widget = Fake("widget").expects("configure")\
-                               .with_args(arg.has_attr(color="green"))
-        widget.configure(Config())
+        with self.assertRaises(AssertionError):
+            widget = Fake("widget").expects("configure")\
+                                   .with_args(arg.has_attr(color="green"))
+            widget.configure(Config())
 
     def test_objectlike_str(self):
         o = inspector.HasAttr(one=1, two="two")
-        eq_(str(o), "arg.has_attr(one=1, two='two')")
+        self.assertEqual(str(o), "arg.has_attr(one=1, two='two')")
 
     def test_objectlike_repr(self):
         o = inspector.HasAttr(one=1, two="two")
-        eq_(repr(o), "arg.has_attr(one=1, two='two')")
+        self.assertEqual(repr(o), "arg.has_attr(one=1, two='two')")
 
     def test_objectlike_unicode(self):
         o = inspector.HasAttr(one=1, ivan=u"Ivan_Krsti\u0107")
-        eq_(repr(o), "arg.has_attr(ivan=%s, one=1)" % repr(u'Ivan_Krsti\u0107'))
+        self.assertEqual(repr(o), "arg.has_attr(ivan=%s, one=1)" % repr(u'Ivan_Krsti\u0107'))
 
     def test_objectlike_repr_long_val(self):
         o = inspector.HasAttr(
                 bytes="011110101000101010011111111110000001010100000001110000000011")
-        eq_(repr(o),
+        self.assertEqual(repr(o),
             "arg.has_attr(bytes='011110101000101010011111111110000001010100000...')")
 
 class TestStringlike(unittest.TestCase):
@@ -151,10 +148,10 @@ class TestStringlike(unittest.TestCase):
         db = Fake("db").expects("execute").with_args(arg.startswith("insert into"))
         db.execute("insert into foo values (1,2,3,4)")
 
-    @raises(AssertionError)
     def test_startswith_fail(self):
-        db = Fake("db").expects("execute").with_args(arg.startswith("insert into"))
-        db.execute("select from")
+        with self.assertRaises(AssertionError):
+            db = Fake("db").expects("execute").with_args(arg.startswith("insert into"))
+            db.execute("select from")
 
     def test_startswith_ok_uni(self):
         db = Fake("db").expects("execute").with_args(arg.startswith(u"Ivan_Krsti\u0107"))
@@ -162,7 +159,7 @@ class TestStringlike(unittest.TestCase):
 
     def test_startswith_unicode(self):
         p = inspector.Startswith(u"Ivan_Krsti\u0107")
-        eq_(repr(p), "arg.startswith(%s)" % repr(u'Ivan_Krsti\u0107'))
+        self.assertEqual(repr(p), "arg.startswith(%s)" % repr(u'Ivan_Krsti\u0107'))
 
     def test_endswith_ok(self):
         db = Fake("db").expects("execute").with_args(arg.endswith("values (1,2,3,4)"))
@@ -174,36 +171,36 @@ class TestStringlike(unittest.TestCase):
 
     def test_endswith_unicode(self):
         p = inspector.Endswith(u"Ivan_Krsti\u0107")
-        eq_(repr(p), "arg.endswith(%s)" % repr(u'Ivan_Krsti\u0107'))
+        self.assertEqual(repr(p), "arg.endswith(%s)" % repr(u'Ivan_Krsti\u0107'))
 
     def test_startswith_repr(self):
         p = inspector.Startswith("_start")
-        eq_(repr(p), "arg.startswith('_start')")
+        self.assertEqual(repr(p), "arg.startswith('_start')")
 
     def test_endswith_repr(self):
         p = inspector.Endswith("_ending")
-        eq_(repr(p), "arg.endswith('_ending')")
+        self.assertEqual(repr(p), "arg.endswith('_ending')")
 
     def test_startswith_str(self):
         p = inspector.Startswith("_start")
-        eq_(str(p), "arg.startswith('_start')")
+        self.assertEqual(str(p), "arg.startswith('_start')")
 
     def test_endswith_str(self):
         p = inspector.Endswith("_ending")
-        eq_(str(p), "arg.endswith('_ending')")
+        self.assertEqual(str(p), "arg.endswith('_ending')")
 
     def test_startswith_str_long_value(self):
         p = inspector.Startswith(
             "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
         )
-        eq_(str(p),
+        self.assertEqual(str(p),
             "arg.startswith('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...')" )
 
     def test_endswith_str_long_value(self):
         p = inspector.Endswith(
             "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
         )
-        eq_(str(p),
+        self.assertEqual(str(p),
             "arg.endswith('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...')" )
 
 class TestContains(unittest.TestCase):
@@ -217,11 +214,11 @@ class TestContains(unittest.TestCase):
         db.execute("select * from table foo where bar = 1")
         fudge.verify()
 
-    @raises(AssertionError)
     def test_contains_fail(self):
-        db = Fake("db").expects("execute").with_args(arg.contains("table foo"))
-        db.execute("select into table notyourmama;")
-        fudge.verify()
+        with self.assertRaises(AssertionError):
+            db = Fake("db").expects("execute").with_args(arg.contains("table foo"))
+            db.execute("select into table notyourmama;")
+            fudge.verify()
 
     def test_contains_list(self):
         db = Fake("db").expects("execute_statements").with_args(
@@ -235,20 +232,20 @@ class TestContains(unittest.TestCase):
 
     def test_str(self):
         c = inspector.Contains(":part:")
-        eq_(str(c), "arg.contains(':part:')")
+        self.assertEqual(str(c), "arg.contains(':part:')")
 
     def test_str_long_val(self):
         c = inspector.Contains(
             "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
-        eq_(str(c), "arg.contains('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...')")
+        self.assertEqual(str(c), "arg.contains('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...')")
 
     def test_repr(self):
         c = inspector.Contains(":part:")
-        eq_(repr(c), "arg.contains(':part:')")
+        self.assertEqual(repr(c), "arg.contains(':part:')")
 
     def test_unicode(self):
         c = inspector.Contains(u"Ivan_Krsti\u0107")
-        eq_(repr(c), "arg.contains(%s)" % repr(u'Ivan_Krsti\u0107'))
+        self.assertEqual(repr(c), "arg.contains(%s)" % repr(u'Ivan_Krsti\u0107'))
 
 class TestMakeValueTest(unittest.TestCase):
 
--- a/fudge/tests/test_patcher.py
+++ b/fudge/tests/test_patcher.py
@@ -1,207 +1,203 @@
-from __future__ import with_statement
 import inspect
 import unittest
 
-from nose.exc import SkipTest
-from nose.tools import eq_, raises
-
 import fudge
 
 
 class Freddie(object):
     pass
 
-        
-def test_patch_obj():
-    class holder:
-        exc = Exception()
-    
-    patched = fudge.patch_object(holder, "exc", Freddie())
-    eq_(type(holder.exc), type(Freddie()))
-    patched.restore()
-    eq_(type(holder.exc), type(Exception()))
-
-
-def test_patch_path():
-    from os.path import join as orig_join
-    patched = fudge.patch_object("os.path", "join", Freddie())
-    import os.path
-    eq_(type(os.path.join), type(Freddie()))
-    patched.restore()
-    eq_(type(os.path.join), type(orig_join))
-
-
-def test_patch_builtin():
-    import datetime
-    orig_datetime = datetime.datetime
-    now = datetime.datetime(2010, 11, 4, 8, 19, 11, 28778)
-    fake = fudge.Fake('now').is_callable().returns(now)
-    patched = fudge.patch_object(datetime.datetime, 'now', fake)
-    try:
-        eq_(datetime.datetime.now(), now)
-    finally:
+
+class PatcherTest(unittest.TestCase):
+    def test_patch_obj(self):
+        class holder:
+            exc = Exception()
+
+        patched = fudge.patch_object(holder, "exc", Freddie())
+        self.assertEqual(type(holder.exc), type(Freddie()))
         patched.restore()
-    eq_(datetime.datetime.now, orig_datetime.now)
+        self.assertEqual(type(holder.exc), type(Exception()))
 
 
-def test_patch_long_path():
-    import fudge.tests.support._for_patch
-    orig = fudge.tests.support._for_patch.some_object.inner
-    long_path = 'fudge.tests.support._for_patch.some_object.inner'
-    with fudge.patch(long_path) as fake:
-        assert isinstance(fake, fudge.Fake)
-    eq_(fudge.tests.support._for_patch.some_object.inner, orig)
-
-
-@raises(ImportError)
-def test_patch_non_existant_path():
-    with fudge.patch('__not_a_real_import_path.nested.one.two.three') as fake:
-        pass
-
-
-@raises(AttributeError)
-def test_patch_non_existant_attribute():
-    with fudge.patch('fudge.tests.support._for_patch.does.not.exist') as fake:
-        pass
-
-
-def test_patch_builtin_as_string():
-    import datetime
-    orig_datetime = datetime.datetime
-    now = datetime.datetime(2006, 11, 4, 8, 19, 11, 28778)
-    fake_dt = fudge.Fake('datetime').provides('now').returns(now)
-    patched = fudge.patch_object('datetime', 'datetime', fake_dt)
-    try:
-        # timetuple is a workaround for strange Jython behavior!
-        eq_(datetime.datetime.now().timetuple(), now.timetuple())
-    finally:
+    def test_patch_path(self):
+        from os.path import join as orig_join
+        patched = fudge.patch_object("os.path", "join", Freddie())
+        import os.path
+        self.assertEqual(type(os.path.join), type(Freddie()))
         patched.restore()
-    eq_(datetime.datetime.now, orig_datetime.now)
+        self.assertEqual(type(os.path.join), type(orig_join))
 
 
-def test_decorator_on_def():
-    class holder:
-        test_called = False
-        exc = Exception()
-        
-    @fudge.with_patched_object(holder, "exc", Freddie())
-    def some_test():
-        holder.test_called = True
-        eq_(type(holder.exc), type(Freddie()))
-    
-    eq_(some_test.__name__, 'some_test')
-    some_test()
-    eq_(holder.test_called, True)
-    eq_(type(holder.exc), type(Exception()))
-
-
-def test_decorator_on_class():
-    class holder:
-        test_called = False
-        exc = Exception()
-    
-    class SomeTest(object):
-        
+    def test_patch_builtin(self):
+        import datetime
+        orig_datetime = datetime.datetime
+        now = datetime.datetime(2010, 11, 4, 8, 19, 11, 28778)
+        fake = fudge.Fake('now').is_callable().returns(now)
+        patched = fudge.patch_object(datetime.datetime, 'now', fake)
+        try:
+            self.assertEqual(datetime.datetime.now(), now)
+        finally:
+            patched.restore()
+        self.assertEqual(datetime.datetime.now, orig_datetime.now)
+
+
+    def test_patch_long_path(self):
+        import fudge.tests.support._for_patch
+        orig = fudge.tests.support._for_patch.some_object.inner
+        long_path = 'fudge.tests.support._for_patch.some_object.inner'
+        with fudge.patch(long_path) as fake:
+            assert isinstance(fake, fudge.Fake)
+        self.assertEqual(fudge.tests.support._for_patch.some_object.inner, orig)
+
+
+    def test_patch_non_existant_path(self):
+        with self.assertRaises(ImportError):
+            with fudge.patch('__not_a_real_import_path.nested.one.two.three') as fake:
+                pass
+
+
+    def test_patch_non_existant_attribute(self):
+        with self.assertRaises(AttributeError):
+            with fudge.patch('fudge.tests.support._for_patch.does.not.exist') as fake:
+                pass
+
+    def test_patch_builtin_as_string(self):
+        import datetime
+        orig_datetime = datetime.datetime
+        now = datetime.datetime(2006, 11, 4, 8, 19, 11, 28778)
+        fake_dt = fudge.Fake('datetime').provides('now').returns(now)
+        patched = fudge.patch_object('datetime', 'datetime', fake_dt)
+        try:
+            # timetuple is a workaround for strange Jython behavior!
+            self.assertEqual(datetime.datetime.now().timetuple(), now.timetuple())
+        finally:
+            patched.restore()
+        self.assertEqual(datetime.datetime.now, orig_datetime.now)
+
+
+    def test_decorator_on_def(self):
+        class holder:
+            test_called = False
+            exc = Exception()
+
         @fudge.with_patched_object(holder, "exc", Freddie())
-        def some_test(self):
+        def some_test():
             holder.test_called = True
-            eq_(type(holder.exc), type(Freddie()))
-    
-    eq_(SomeTest.some_test.__name__, 'some_test')
-    s = SomeTest()
-    s.some_test()
-    eq_(holder.test_called, True)
-    eq_(type(holder.exc), type(Exception()))
-
-
-def test_patched_context():
-    if not hasattr(fudge, "patched_context"):
-        raise SkipTest("Cannot test with patched_context() because not in 2.5")
-    
-    class Boo:
-        fargo = "is over there"
-    
-    ctx = fudge.patched_context(Boo, 'fargo', 'is right here')
-    # simulate with fudge.patched_context():
-    ctx.__enter__()
-    eq_(Boo.fargo, "is right here")
-    ctx.__exit__(None, None, None)
-    eq_(Boo.fargo, "is over there")
-
-
-def test_base_class_attribute():
-    class Base(object):
-        foo = 'bar'
-    class Main(Base):
-        pass
-    fake = fudge.Fake()
-    p = fudge.patch_object(Main, 'foo', fake)
-    eq_(Main.foo, fake)
-    eq_(Base.foo, 'bar')
-    p.restore()
-    eq_(Main.foo, 'bar')
-    assert 'foo' not in Main.__dict__, ('Main.foo was not restored correctly')
-
-
-def test_bound_methods():
-    class Klass(object):
-        def method(self):
-            return 'foozilate'
-    instance = Klass()
-    fake = fudge.Fake()
-    p = fudge.patch_object(instance, 'method', fake)
-    eq_(instance.method, fake)
-    p.restore()
-    eq_(instance.method(), Klass().method())
-    assert inspect.ismethod(instance.method)
-    assert 'method' not in instance.__dict__, (
-                            'instance.method was not restored correctly')
-
-
-def test_staticmethod_descriptor():
-    class Klass(object):
-        @staticmethod
-        def static():
-            return 'OK'
-    fake = fudge.Fake()
-    p = fudge.patch_object(Klass, 'static', fake)
-    eq_(Klass.static, fake)
-    p.restore()
-    eq_(Klass.static(), 'OK')
-
-
-def test_property():
-    class Klass(object):
-        @property
-        def prop(self):
-            return 'OK'
-    exact_prop = Klass.prop
-    instance = Klass()
-    fake = fudge.Fake()
-    p = fudge.patch_object(instance, 'prop', fake)
-    eq_(instance.prop, fake)
-    p.restore()
-    eq_(instance.prop, 'OK')
-    eq_(Klass.prop, exact_prop)
-
-
-def test_inherited_property():
-    class SubKlass(object):
-        @property
-        def prop(self):
-            return 'OK'
-    class Klass(SubKlass):
-        pass
-    exact_prop = SubKlass.prop
-    instance = Klass()
-    fake = fudge.Fake()
-    p = fudge.patch_object(instance, 'prop', fake)
-    eq_(instance.prop, fake)
-    p.restore()
-    eq_(instance.prop, 'OK')
-    assert 'prop' not in Klass.__dict__, (
-                                'Klass.prop was not restored properly')
-    eq_(SubKlass.prop, exact_prop)
+            self.assertEqual(type(holder.exc), type(Freddie()))
+
+        self.assertEqual(some_test.__name__, 'some_test')
+        some_test()
+        self.assertEqual(holder.test_called, True)
+        self.assertEqual(type(holder.exc), type(Exception()))
+
+
+    def test_decorator_on_class(self):
+        class holder:
+            test_called = False
+            exc = Exception()
+
+        class SomeTest(object):
+
+            @fudge.with_patched_object(holder, "exc", Freddie())
+            def some_test(self):
+                holder.test_called = True
+                assert isinstance(holder.exc, Freddie)
+
+        self.assertEqual(SomeTest.some_test.__name__, 'some_test')
+        s = SomeTest()
+        s.some_test()
+        self.assertEqual(holder.test_called, True)
+        self.assertEqual(type(holder.exc), type(Exception()))
+
+
+    def test_patched_context(self):
+        if not hasattr(fudge, "patched_context"):
+            raise unittest.SkipTest("Cannot test with patched_context() because not in 2.5")
+
+        class Boo:
+            fargo = "is over there"
+
+        ctx = fudge.patched_context(Boo, 'fargo', 'is right here')
+        # simulate with fudge.patched_context():
+        ctx.__enter__()
+        self.assertEqual(Boo.fargo, "is right here")
+        ctx.__exit__(None, None, None)
+        self.assertEqual(Boo.fargo, "is over there")
+
+
+    def test_base_class_attribute(self):
+        class Base(object):
+            foo = 'bar'
+        class Main(Base):
+            pass
+        fake = fudge.Fake()
+        p = fudge.patch_object(Main, 'foo', fake)
+        self.assertEqual(Main.foo, fake)
+        self.assertEqual(Base.foo, 'bar')
+        p.restore()
+        self.assertEqual(Main.foo, 'bar')
+        assert 'foo' not in Main.__dict__, ('Main.foo was not restored correctly')
+
+
+    def test_bound_methods(self):
+        class Klass(object):
+            def method(self):
+                return 'foozilate'
+        instance = Klass()
+        fake = fudge.Fake()
+        p = fudge.patch_object(instance, 'method', fake)
+        self.assertEqual(instance.method, fake)
+        p.restore()
+        self.assertEqual(instance.method(), Klass().method())
+        assert inspect.ismethod(instance.method)
+        assert 'method' not in instance.__dict__, (
+                                'instance.method was not restored correctly')
+
+
+    def test_staticmethod_descriptor(self):
+        class Klass(object):
+            @staticmethod
+            def static():
+                return 'OK'
+        fake = fudge.Fake()
+        p = fudge.patch_object(Klass, 'static', fake)
+        self.assertEqual(Klass.static, fake)
+        p.restore()
+        self.assertEqual(Klass.static(), 'OK')
+
+
+    def test_property(self):
+        class Klass(object):
+            @property
+            def prop(self):
+                return 'OK'
+        exact_prop = Klass.prop
+        instance = Klass()
+        fake = fudge.Fake()
+        p = fudge.patch_object(instance, 'prop', fake)
+        self.assertEqual(instance.prop, fake)
+        p.restore()
+        self.assertEqual(instance.prop, 'OK')
+        self.assertEqual(Klass.prop, exact_prop)
+
+
+    def test_inherited_property(self):
+        class SubKlass(object):
+            @property
+            def prop(self):
+                return 'OK'
+        class Klass(SubKlass):
+            pass
+        exact_prop = SubKlass.prop
+        instance = Klass()
+        fake = fudge.Fake()
+        p = fudge.patch_object(instance, 'prop', fake)
+        self.assertEqual(instance.prop, fake)
+        p.restore()
+        self.assertEqual(instance.prop, 'OK')
+        assert 'prop' not in Klass.__dict__, (
+                                    'Klass.prop was not restored properly')
+        self.assertEqual(SubKlass.prop, exact_prop)
 
 
 class TestPatch(unittest.TestCase):
@@ -213,17 +209,17 @@ class TestPatch(unittest.TestCase):
 
         class holder:
             test_called = False
-        
+
         @fudge.patch('shutil.copy')
         def some_test(copy):
             import shutil
             holder.test_called = True
             assert isinstance(copy, fudge.Fake)
-            eq_(copy, shutil.copy)
-    
-        eq_(some_test.__name__, 'some_test')
+            self.assertEqual(copy, shutil.copy)
+
+        self.assertEqual(some_test.__name__, 'some_test')
         some_test()
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
         import shutil
         assert not isinstance(shutil.copy, fudge.Fake)
 
@@ -232,7 +228,7 @@ class TestPatch(unittest.TestCase):
 
         class holder:
             test_called = False
-    
+
         class MyTest(object):
 
             @fudge.patch('shutil.copy')
@@ -240,12 +236,12 @@ class TestPatch(unittest.TestCase):
                 import shutil
                 holder.test_called = True
                 assert isinstance(copy, fudge.Fake)
-                eq_(copy, shutil.copy)
-    
-        eq_(MyTest.some_test.__name__, 'some_test')
+                assert copy == shutil.copy
+
+        self.assertEqual(MyTest.some_test.__name__, 'some_test')
         m = MyTest()
         m.some_test()
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
         import shutil
         assert not isinstance(shutil.copy, fudge.Fake)
 
@@ -253,7 +249,7 @@ class TestPatch(unittest.TestCase):
 
         class holder:
             test_called = False
-        
+
         @fudge.patch('shutil.copy',
                      'os.remove')
         def some_test(copy, remove):
@@ -262,12 +258,12 @@ class TestPatch(unittest.TestCase):
             holder.test_called = True
             assert isinstance(copy, fudge.Fake)
             assert isinstance(remove, fudge.Fake)
-            eq_(copy, shutil.copy)
-            eq_(remove, os.remove)
-    
-        eq_(some_test.__name__, 'some_test')
+            self.assertEqual(copy, shutil.copy)
+            self.assertEqual(remove, os.remove)
+
+        self.assertEqual(some_test.__name__, 'some_test')
         some_test()
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
         import shutil
         assert not isinstance(shutil.copy, fudge.Fake)
         import os
@@ -282,11 +278,11 @@ class TestPatch(unittest.TestCase):
             with fudge.patch('shutil.copy') as copy:
                 import shutil
                 assert isinstance(copy, fudge.Fake)
-                eq_(copy, shutil.copy)
+                self.assertEqual(copy, shutil.copy)
                 holder.test_called = True
-        
+
         run_test()
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
         import shutil
         assert not isinstance(shutil.copy, fudge.Fake)
 
@@ -302,12 +298,12 @@ class TestPatch(unittest.TestCase):
                 import os
                 assert isinstance(copy, fudge.Fake)
                 assert isinstance(remove, fudge.Fake)
-                eq_(copy, shutil.copy)
-                eq_(remove, os.remove)
+                self.assertEqual(copy, shutil.copy)
+                self.assertEqual(remove, os.remove)
                 holder.test_called = True
-        
+
         run_test()
-        eq_(holder.test_called, True)
+        self.assertEqual(holder.test_called, True)
         import shutil
         assert not isinstance(shutil.copy, fudge.Fake)
         import os
--- a/fudge/tests/test_registry.py
+++ b/fudge/tests/test_registry.py
@@ -1,109 +1,108 @@
-
-import thread
+try:
+    import _thread as thread
+except ImportError:
+    import thread
 import sys
 import unittest
 import fudge
-from nose.exc import SkipTest
-from nose.tools import eq_, raises
-from fudge import (
-    Fake, Registry, ExpectedCall, ExpectedCallOrder, Call, CallStack, FakeDeclarationError)
+from fudge import ExpectedCall, ExpectedCallOrder
 
 class TestRegistry(unittest.TestCase):
-    
+
     def setUp(self):
         self.fake = fudge.Fake()
         self.reg = fudge.registry
         # in case of error, clear out everything:
         self.reg.clear_all()
-    
+
     def tearDown(self):
         pass
-    
-    @raises(AssertionError)
+
     def test_expected_call_not_called(self):
-        self.reg.clear_calls()
-        self.reg.expect_call(ExpectedCall(self.fake, 'nothing'))
-        self.reg.verify()
-        
+        with self.assertRaises(AssertionError):
+            self.reg.clear_calls()
+            self.reg.expect_call(ExpectedCall(self.fake, 'nothing'))
+            self.reg.verify()
+
     def test_clear_calls_resets_calls(self):
         exp = ExpectedCall(self.fake, 'callMe')
         self.reg.expect_call(exp)
         exp()
-        eq_(exp.was_called, True)
-        
+        self.assertEqual(exp.was_called, True)
+
         self.reg.clear_calls()
-        eq_(exp.was_called, False, "call was not reset by clear_calls()")
-        
+        self.assertEqual(exp.was_called, False, "call was not reset by clear_calls()")
+
     def test_clear_calls_resets_call_order(self):
         exp_order = ExpectedCallOrder(self.fake)
         exp = ExpectedCall(self.fake, 'callMe', call_order=exp_order)
         exp_order.add_expected_call(exp)
         self.reg.remember_expected_call_order(exp_order)
-        
+
         exp()
-        eq_(exp_order._actual_calls, [exp])
-        
+        self.assertEqual(exp_order._actual_calls, [exp])
+
         self.reg.clear_calls()
-        eq_(exp_order._actual_calls, [], "call order calls were not reset by clear_calls()")
-    
+        self.assertEqual(exp_order._actual_calls, [], "call order calls were not reset by clear_calls()")
+
     def test_verify_resets_calls(self):
         exp = ExpectedCall(self.fake, 'callMe')
         exp()
-        eq_(exp.was_called, True)
-        eq_(len(self.reg.get_expected_calls()), 1)
-        
+        self.assertEqual(exp.was_called, True)
+        self.assertEqual(len(self.reg.get_expected_calls()), 1)
+
         self.reg.verify()
-        eq_(exp.was_called, False, "call was not reset by verify()")
-        eq_(len(self.reg.get_expected_calls()), 1, "verify() should not reset expectations")
-        
+        self.assertEqual(exp.was_called, False, "call was not reset by verify()")
+        self.assertEqual(len(self.reg.get_expected_calls()), 1, "verify() should not reset expectations")
+
     def test_verify_resets_call_order(self):
         exp_order = ExpectedCallOrder(self.fake)
         exp = ExpectedCall(self.fake, 'callMe', call_order=exp_order)
         exp_order.add_expected_call(exp)
         self.reg.remember_expected_call_order(exp_order)
-        
+
         exp()
-        eq_(exp_order._actual_calls, [exp])
-        
+        self.assertEqual(exp_order._actual_calls, [exp])
+
         self.reg.verify()
-        eq_(exp_order._actual_calls, [], "call order calls were not reset by verify()")
-    
+        self.assertEqual(exp_order._actual_calls, [], "call order calls were not reset by verify()")
+
     def test_global_verify(self):
         exp = ExpectedCall(self.fake, 'callMe')
         exp()
-        eq_(exp.was_called, True)
-        eq_(len(self.reg.get_expected_calls()), 1)
-        
+        self.assertEqual(exp.was_called, True)
+        self.assertEqual(len(self.reg.get_expected_calls()), 1)
+
         fudge.verify()
-        
-        eq_(exp.was_called, False, "call was not reset by verify()")
-        eq_(len(self.reg.get_expected_calls()), 1, "verify() should not reset expectations")
-    
+
+        self.assertEqual(exp.was_called, False, "call was not reset by verify()")
+        self.assertEqual(len(self.reg.get_expected_calls()), 1, "verify() should not reset expectations")
+
     def test_global_clear_expectations(self):
         exp = ExpectedCall(self.fake, 'callMe')
         exp()
-        eq_(len(self.reg.get_expected_calls()), 1)
+        self.assertEqual(len(self.reg.get_expected_calls()), 1)
         exp_order = ExpectedCallOrder(self.fake)
         self.reg.remember_expected_call_order(exp_order)
-        eq_(self.reg.get_expected_call_order().keys(), [self.fake])
-        
+        self.assertEqual(list(self.reg.get_expected_call_order().keys()), [self.fake])
+
         fudge.clear_expectations()
-        
-        eq_(len(self.reg.get_expected_calls()), 0, 
+
+        self.assertEqual(len(self.reg.get_expected_calls()), 0,
             "clear_expectations() should reset expectations")
-        eq_(len(self.reg.get_expected_call_order().keys()), 0,
+        self.assertEqual(len(self.reg.get_expected_call_order().keys()), 0,
             "clear_expectations() should reset expected call order")
-    
+
     def test_multithreading(self):
         if sys.platform.startswith('java'):
-            raise SkipTest('this test is flaky in Jython')
+            raise unittest.SkipTest('this test is flaky in Jython')
 
         reg = fudge.registry
-        
+
         class thread_run:
             waiting = 5
             errors = []
-        
+
         # while this barely catches collisions
         # it ensures that each thread can use the registry ok
         def registry(num):
@@ -111,32 +110,32 @@ class TestRegistry(unittest.TestCase):
                 try:
                     fudge.clear_calls()
                     fudge.clear_expectations()
-                    
+
                     exp_order = ExpectedCallOrder(self.fake)
                     reg.remember_expected_call_order(exp_order)
-                    eq_(len(reg.get_expected_call_order().keys()), 1)
-                    
+                    self.assertEqual(len(reg.get_expected_call_order().keys()), 1)
+
                     # registered first time on __init__ :
-                    exp = ExpectedCall(self.fake, 'callMe', call_order=exp_order) 
+                    exp = ExpectedCall(self.fake, 'callMe', call_order=exp_order)
                     reg.expect_call(exp)
                     reg.expect_call(exp)
                     reg.expect_call(exp)
-                    eq_(len(reg.get_expected_calls()), 4)
-                    
+                    self.assertEqual(len(reg.get_expected_calls()), 4)
+
                     # actual calls:
                     exp()
                     exp()
                     exp()
                     exp()
-                    
+
                     fudge.verify()
                     fudge.clear_expectations()
-                except Exception, er:
+                except Exception as er:
                     thread_run.errors.append(er)
                     raise
             finally:
                 thread_run.waiting -= 1
-                
+
         thread.start_new_thread(registry, (1,))
         thread.start_new_thread(registry, (2,))
         thread.start_new_thread(registry, (3,))
--- a/setup.py
+++ b/setup.py
@@ -51,7 +51,7 @@ email without actually sending email::
     author_email='kumar.mcmillan@gmail.com',
     license="The MIT License",
     packages=find_packages(exclude=['ez_setup']),
-    install_requires=[],
+    install_requires=['six'],
     url='https://github.com/fudge-py/fudge',
     include_package_data=True,
     classifiers = [
