Index: librosa-0.9.2/librosa/segment.py
===================================================================
--- librosa-0.9.2.orig/librosa/segment.py
+++ librosa-0.9.2/librosa/segment.py
@@ -255,7 +255,7 @@ def cross_similarity(
     xsim.eliminate_zeros()
 
     if mode == "connectivity":
-        xsim = xsim.astype(np.bool)
+        xsim = xsim.astype(bool)
     elif mode == "affinity":
         if bandwidth is None:
             bandwidth = np.nanmedian(xsim.max(axis=1).data)
@@ -519,7 +519,7 @@ def recurrence_matrix(
     rec.eliminate_zeros()
 
     if mode == "connectivity":
-        rec = rec.astype(np.bool)
+        rec = rec.astype(bool)
     elif mode == "affinity":
         if bandwidth is None:
             bandwidth = np.nanmedian(rec.max(axis=1).data)
Index: librosa-0.9.2/tests/test_display.py
===================================================================
--- librosa-0.9.2.orig/tests/test_display.py
+++ librosa-0.9.2/tests/test_display.py
@@ -630,7 +630,7 @@ def test_unknown_axis(S_abs, axis):
         np.arange(1, 10.0),  # strictly positive
         -np.arange(1, 10.0),  # strictly negative
         np.arange(-3, 4.0),  # signed,
-        np.arange(2, dtype=np.bool),
+        np.arange(2, dtype=bool),
     ],
 )  # binary
 def test_cmap_robust(data):
Index: librosa-0.9.2/tests/test_decompose.py
===================================================================
--- librosa-0.9.2.orig/tests/test_decompose.py
+++ librosa-0.9.2/tests/test_decompose.py
@@ -160,7 +160,7 @@ def test_nn_filter_mean():
     X_filtered = librosa.decompose.nn_filter(X)
 
     # Normalize the recurrence matrix so dotting computes an average
-    rec = librosa.util.normalize(rec.astype(np.float), axis=0, norm=1)
+    rec = librosa.util.normalize(rec.astype(float), axis=0, norm=1)
 
     assert np.allclose(X_filtered, X.dot(rec))
 
@@ -182,7 +182,7 @@ def test_nn_filter_mean_rec():
         assert np.allclose(X_filtered[:, i], X[:, i])
 
     # Normalize the recurrence matrix
-    rec = librosa.util.normalize(rec.astype(np.float), axis=0, norm=1)
+    rec = librosa.util.normalize(rec.astype(float), axis=0, norm=1)
     assert np.allclose(X_filtered[:, 3:], (X.dot(rec))[:, 3:])
 
 
@@ -197,7 +197,7 @@ def test_nn_filter_mean_rec_sparse():
     X_filtered = librosa.decompose.nn_filter(X, rec=rec)
 
     # Normalize the recurrence matrix
-    rec = librosa.util.normalize(rec.toarray().astype(np.float), axis=0, norm=1)
+    rec = librosa.util.normalize(rec.toarray().astype(float), axis=0, norm=1)
     assert np.allclose(X_filtered, (X.dot(rec)))
 
 
Index: librosa-0.9.2/tests/test_dtw.py
===================================================================
--- librosa-0.9.2.orig/tests/test_dtw.py
+++ librosa-0.9.2/tests/test_dtw.py
@@ -272,7 +272,7 @@ def test_dtw_global_inf():
     # path-following to (0, 0)
 
     # Construct a cost matrix where full alignment is impossible
-    C = np.zeros((4, 4), dtype=np.float)
+    C = np.zeros((4, 4), dtype=float)
     C[-1, -1] = np.inf
     with pytest.raises(librosa.ParameterError):
         librosa.sequence.dtw(C=C, subseq=False)
@@ -280,7 +280,7 @@ def test_dtw_global_inf():
 
 def test_dtw_subseq_inf():
     # Construct a cost matrix where partial alignment is impossible
-    C = np.zeros((4, 4), dtype=np.float)
+    C = np.zeros((4, 4), dtype=float)
     C[-1, :] = np.inf
 
     with pytest.raises(librosa.ParameterError):
@@ -289,7 +289,7 @@ def test_dtw_subseq_inf():
 
 def test_dtw_subseq_pass():
     # Construct a cost matrix where partial alignment is possible
-    C = np.zeros((4, 4), dtype=np.float)
+    C = np.zeros((4, 4), dtype=float)
     C[-1, 2:] = np.inf
     librosa.sequence.dtw(C=C, subseq=True)
 
Index: librosa-0.9.2/tests/test_effects.py
===================================================================
--- librosa-0.9.2.orig/tests/test_effects.py
+++ librosa-0.9.2/tests/test_effects.py
@@ -122,8 +122,8 @@ def test_pitch_shift_multi(y_multi):
 def test_remix_mono(align_zeros):
 
     # without zc alignment
-    y = np.asarray([1, 1, -1, -1, 2, 2, -1, -1, 1, 1], dtype=np.float)
-    y_t = np.asarray([-1, -1, -1, -1, 1, 1, 1, 1, 2, 2], dtype=np.float)
+    y = np.asarray([1, 1, -1, -1, 2, 2, -1, -1, 1, 1], dtype=float)
+    y_t = np.asarray([-1, -1, -1, -1, 1, 1, 1, 1, 2, 2], dtype=float)
     intervals = np.asarray([[2, 4], [6, 8], [0, 2], [8, 10], [4, 6]])
 
     y_out = librosa.effects.remix(y, intervals, align_zeros=align_zeros)
@@ -134,8 +134,8 @@ def test_remix_mono(align_zeros):
 def test_remix_stereo(align_zeros):
 
     # without zc alignment
-    y = np.asarray([1, 1, -1, -1, 2, 2, -1, -1, 1, 1], dtype=np.float)
-    y_t = np.asarray([-1, -1, -1, -1, 1, 1, 1, 1, 2, 2], dtype=np.float)
+    y = np.asarray([1, 1, -1, -1, 2, 2, -1, -1, 1, 1], dtype=float)
+    y_t = np.asarray([-1, -1, -1, -1, 1, 1, 1, 1, 2, 2], dtype=float)
     y = np.vstack([y, y])
     y_t = np.vstack([y_t, y_t])
 
Index: librosa-0.9.2/tests/test_multichannel.py
===================================================================
--- librosa-0.9.2.orig/tests/test_multichannel.py
+++ librosa-0.9.2/tests/test_multichannel.py
@@ -49,7 +49,7 @@ def tfr_multi(y_multi):
     "ndim,axis", [(1, 0), (1, -1), (2, 0), (2, 1), (2, -1), (3, 0), (3, 2), (3, -1), (4, 0), (4, 3), (4, -1)]
 )
 def test_sync_multi(aggregate, ndim, axis):
-    data = np.ones([6] * ndim, dtype=np.float)
+    data = np.ones([6] * ndim, dtype=float)
 
     # Make some slices that don't fill the entire dimension
     slices = [slice(1, 3), slice(3, 4)]
Index: librosa-0.9.2/tests/test_util.py
===================================================================
--- librosa-0.9.2.orig/tests/test_util.py
+++ librosa-0.9.2/tests/test_util.py
@@ -866,7 +866,7 @@ def test_index_to_slice(idx, idx_min, id
     "ndim,axis", [(1, 0), (1, -1), (2, 0), (2, 1), (2, -1), (3, 0), (3, 2), (3, -1)]
 )
 def test_sync(aggregate, ndim, axis):
-    data = np.ones([6] * ndim, dtype=np.float)
+    data = np.ones([6] * ndim, dtype=float)
 
     # Make some slices that don't fill the entire dimension
     slices = [slice(1, 3), slice(3, 4)]
Index: librosa-0.9.2/librosa/core/constantq.py
===================================================================
--- librosa-0.9.2.orig/librosa/core/constantq.py
+++ librosa-0.9.2/librosa/core/constantq.py
@@ -287,7 +287,7 @@ def hybrid_cqt(
 
     Returns
     -------
-    CQT : np.ndarray [shape=(..., n_bins, t), dtype=np.float]
+    CQT : np.ndarray [shape=(..., n_bins, t), dtype=float]
         Constant-Q energy for each frequency at each time.
 
     See Also
@@ -468,7 +468,7 @@ def pseudo_cqt(
 
     Returns
     -------
-    CQT : np.ndarray [shape=(..., n_bins, t), dtype=np.float]
+    CQT : np.ndarray [shape=(..., n_bins, t), dtype=float]
         Pseudo Constant-Q energy for each frequency at each time.
 
     Notes
@@ -622,7 +622,7 @@ def icqt(
 
     Returns
     -------
-    y : np.ndarray, [shape=(..., n_samples), dtype=np.float]
+    y : np.ndarray, [shape=(..., n_samples), dtype=float]
         Audio time-series reconstructed from the CQT representation.
 
     See Also
@@ -889,7 +889,7 @@ def vqt(
 
     Returns
     -------
-    VQT : np.ndarray [shape=(..., n_bins, t), dtype=np.complex]
+    VQT : np.ndarray [shape=(..., n_bins, t), dtype=complex]
         Variable-Q value each frequency at each time.
 
     See Also
Index: librosa-0.9.2/librosa/core/spectrum.py
===================================================================
--- librosa-0.9.2.orig/librosa/core/spectrum.py
+++ librosa-0.9.2/librosa/core/spectrum.py
@@ -2544,7 +2544,7 @@ def _spectrogram(
 
     Returns
     -------
-    S_out : np.ndarray [dtype=np.float]
+    S_out : np.ndarray [dtype=float]
         - If ``S`` is provided as input, then ``S_out == S``
         - Else, ``S_out = |stft(y, ...)|**power``
     n_fft : int > 0
Index: librosa-0.9.2/librosa/util/utils.py
===================================================================
--- librosa-0.9.2.orig/librosa/util/utils.py
+++ librosa-0.9.2/librosa/util/utils.py
@@ -2181,7 +2181,7 @@ def dtype_c2r(d, *, default=np.float32):
     mapping = {
         np.dtype(np.complex64): np.float32,
         np.dtype(np.complex128): np.float64,
-        np.dtype(complex): np.dtype(np.float).type,
+        np.dtype(complex): np.dtype(float).type,
     }
 
     # If we're given a real type already, return it
Index: librosa-0.9.2/tests/test_convert.py
===================================================================
--- librosa-0.9.2.orig/tests/test_convert.py
+++ librosa-0.9.2/tests/test_convert.py
@@ -531,7 +531,7 @@ def test_blocks_to_frames(blocks, block_
     assert np.allclose(frames, block_length * np.asanyarray(blocks))
 
     # Check dtype
-    assert np.issubdtype(frames.dtype, np.int)
+    assert np.issubdtype(frames.dtype, int)
 
 
 @pytest.mark.parametrize("blocks", [0, 1, [10, 20]])
@@ -548,7 +548,7 @@ def test_blocks_to_samples(blocks, block
     assert np.allclose(samples, np.asanyarray(blocks) * hop_length * block_length)
 
     # Check dtype
-    assert np.issubdtype(samples.dtype, np.int)
+    assert np.issubdtype(samples.dtype, int)
 
 
 @pytest.mark.parametrize("blocks", [0, 1, [10, 20]])
@@ -568,7 +568,7 @@ def test_blocks_to_time(blocks, block_le
     )
 
     # Check dtype
-    assert np.issubdtype(times.dtype, np.float)
+    assert np.issubdtype(times.dtype, float)
 
 
 @pytest.mark.parametrize("abbr", [False, True])
Index: librosa-0.9.2/tests/test_failures.py
===================================================================
--- librosa-0.9.2.orig/tests/test_failures.py
+++ librosa-0.9.2/tests/test_failures.py
@@ -24,7 +24,7 @@ def test_mono_valid_stereo():
 
 @pytest.mark.xfail(raises=librosa.ParameterError)
 def test_valid_audio_int():
-    y = np.zeros(10, dtype=np.int)
+    y = np.zeros(10, dtype=int)
     librosa.util.valid_audio(y)
 
 
Index: librosa-0.9.2/tests/test_core.py
===================================================================
--- librosa-0.9.2.orig/tests/test_core.py
+++ librosa-0.9.2/tests/test_core.py
@@ -1347,7 +1347,7 @@ def test_amplitude_to_db_complex():
     x = np.abs(np.random.randn(1000)) + NOISE_FLOOR
 
     with warnings.catch_warnings(record=True) as out:
-        db1 = librosa.amplitude_to_db(x.astype(np.complex), top_db=None)
+        db1 = librosa.amplitude_to_db(x.astype(complex), top_db=None)
         assert len(out) > 0
         assert "complex" in str(out[0].message).lower()
 
@@ -1883,7 +1883,7 @@ def test_pcen_drc(S_pcen, bias, power):
 
 
 def test_pcen_complex():
-    S = np.ones((9, 30), dtype=np.complex)
+    S = np.ones((9, 30), dtype=complex)
     Pexp = np.ones((9, 30))
 
     with warnings.catch_warnings(record=True) as out:
