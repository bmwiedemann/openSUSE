Description: gen.with_timeout: Don't log CancelledError after timeout
  This patch originated with upstream commit 0684b61c1d4feaaf5ac3. The
  patch has been modified to handle Python 2 as version 5.1 still
  supports Python 2. Upstream dropped Python 2 support prior to when
  this patch landed.
Author: Petr Viktorin <encukou@gmail.com> (original author)
        Corey Bryant <corey.bryant@canonical.com> (modified original)

See also: commit a237a995a1d54ad6e07c1ecdf5103ff8f45073b5
---
 tornado/gen.py | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

--- a/tornado/gen.py
+++ b/tornado/gen.py
@@ -933,8 +933,9 @@
     an absolute time relative to `.IOLoop.time`)
 
     If the wrapped `.Future` fails after it has timed out, the exception
-    will be logged unless it is of a type contained in ``quiet_exceptions``
-    (which may be an exception type or a sequence of types).
+    will be logged unless it is either of a type contained in
+    ``quiet_exceptions`` (which may be an exception type or a sequence of
+    types), or a `CancelledError`.
 
     Does not support `YieldPoint` subclasses.
 
@@ -951,6 +952,9 @@
     .. versionchanged:: 4.4
        Added support for yieldable objects other than `.Future`.
 
+    .. versionchanged:: 5.1
+       Do not log CancelledError after timeout.
+
     """
     # TODO: allow YieldPoints in addition to other yieldables?
     # Tricky to do with stack_context semantics.
@@ -966,12 +970,23 @@
     io_loop = IOLoop.current()
 
     def error_callback(future):
-        try:
-            future.result()
-        except Exception as e:
-            if not isinstance(e, quiet_exceptions):
-                app_log.error("Exception in Future %r after timeout",
-                              future, exc_info=True)
+        if PY3:
+            import asyncio
+            try:
+                future.result()
+            except asyncio.CancelledError:
+                pass
+            except Exception as e:
+                if not isinstance(e, quiet_exceptions):
+                    app_log.error("Exception in Future %r after timeout",
+                                  future, exc_info=True)
+        else:
+            try:
+                future.result()
+            except Exception as e:
+                if not isinstance(e, quiet_exceptions):
+                    app_log.error("Exception in Future %r after timeout",
+                                  future, exc_info=True)
 
     def timeout_callback():
         if not result.done():
