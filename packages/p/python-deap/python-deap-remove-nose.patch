Index: deap-1.3.1/deap/tests/test_algorithms.py
===================================================================
--- deap-1.3.1.orig/deap/tests/test_algorithms.py	2020-01-21 02:17:45.000000000 +0100
+++ deap-1.3.1/deap/tests/test_algorithms.py	2020-09-10 16:04:32.667140461 +0200
@@ -13,7 +13,7 @@
 #    You should have received a copy of the GNU Lesser General Public
 #    License along with DEAP. If not, see <http://www.gnu.org/licenses/>.
 
-from nose import with_setup
+import unittest
 import random
 
 import numpy
@@ -31,203 +31,206 @@ INDCLSNAME = "IND_TYPE"
 
 HV_THRESHOLD = 116.0        # 120.777 is Optimal value
 
-
-def setup_func_single_obj():
-    creator.create(FITCLSNAME, base.Fitness, weights=(-1.0,))
-    creator.create(INDCLSNAME, list, fitness=creator.__dict__[FITCLSNAME])
-
-def setup_func_multi_obj():
-    creator.create(FITCLSNAME, base.Fitness, weights=(-1.0, -1.0))
-    creator.create(INDCLSNAME, list, fitness=creator.__dict__[FITCLSNAME])
-
-def setup_func_multi_obj_numpy():
-    creator.create(FITCLSNAME, base.Fitness, weights=(-1.0, -1.0))
-    creator.create(INDCLSNAME, numpy.ndarray, fitness=creator.__dict__[FITCLSNAME])
-
-def teardown_func():
-    # Messy way to remove a class from the creator
-    del creator.__dict__[FITCLSNAME]
-    del creator.__dict__[INDCLSNAME]
-
-@with_setup(setup_func_single_obj, teardown_func)
-def test_cma():
-    NDIM = 5
-
-    strategy = cma.Strategy(centroid=[0.0]*NDIM, sigma=1.0)
-
-    toolbox = base.Toolbox()
-    toolbox.register("evaluate", benchmarks.sphere)
-    toolbox.register("generate", strategy.generate, creator.__dict__[INDCLSNAME])
-    toolbox.register("update", strategy.update)
-
-    pop, _ = algorithms.eaGenerateUpdate(toolbox, ngen=100)
-    best, = tools.selBest(pop, k=1)
-
-    assert best.fitness.values < (1e-8,), "CMA algorithm did not converged properly."
-
-@with_setup(setup_func_multi_obj, teardown_func)
-def test_nsga2():
-    NDIM = 5
-    BOUND_LOW, BOUND_UP = 0.0, 1.0
-    MU = 16
-    NGEN = 100
-
-    toolbox = base.Toolbox()
-    toolbox.register("attr_float", random.uniform, BOUND_LOW, BOUND_UP)
-    toolbox.register("individual", tools.initRepeat, creator.__dict__[INDCLSNAME], toolbox.attr_float, NDIM)
-    toolbox.register("population", tools.initRepeat, list, toolbox.individual)
-
-    toolbox.register("evaluate", benchmarks.zdt1)
-    toolbox.register("mate", tools.cxSimulatedBinaryBounded, low=BOUND_LOW, up=BOUND_UP, eta=20.0)
-    toolbox.register("mutate", tools.mutPolynomialBounded, low=BOUND_LOW, up=BOUND_UP, eta=20.0, indpb=1.0/NDIM)
-    toolbox.register("select", tools.selNSGA2)
-
-    pop = toolbox.population(n=MU)
-    fitnesses = toolbox.map(toolbox.evaluate, pop)
-    for ind, fit in zip(pop, fitnesses):
-        ind.fitness.values = fit
-
-    pop = toolbox.select(pop, len(pop))
-    for gen in range(1, NGEN):
-        offspring = tools.selTournamentDCD(pop, len(pop))
-        offspring = [toolbox.clone(ind) for ind in offspring]
-
-        for ind1, ind2 in zip(offspring[::2], offspring[1::2]):
-            if random.random() <= 0.9:
-                toolbox.mate(ind1, ind2)
-
-            toolbox.mutate(ind1)
-            toolbox.mutate(ind2)
-            del ind1.fitness.values, ind2.fitness.values
-
-        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
-        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
-        for ind, fit in zip(invalid_ind, fitnesses):
+class AlgorithmsTest(unittest.TestCase):
+    def setup_func_single_obj(self):
+        creator.create(FITCLSNAME, base.Fitness, weights=(-1.0,))
+        creator.create(INDCLSNAME, list, fitness=creator.__dict__[FITCLSNAME])
+
+    def setup_func_multi_obj(self):
+        creator.create(FITCLSNAME, base.Fitness, weights=(-1.0, -1.0))
+        creator.create(INDCLSNAME, list, fitness=creator.__dict__[FITCLSNAME])
+
+    def setup_func_multi_obj_numpy(self):
+        creator.create(FITCLSNAME, base.Fitness, weights=(-1.0, -1.0))
+        creator.create(INDCLSNAME, numpy.ndarray, fitness=creator.__dict__[FITCLSNAME])
+
+    def tearDown(self):
+        # Messy way to remove a class from the creator
+        del creator.__dict__[FITCLSNAME]
+        del creator.__dict__[INDCLSNAME]
+
+    def test_cma(self):
+        self.setup_func_single_obj()
+
+        NDIM = 5
+
+        strategy = cma.Strategy(centroid=[0.0]*NDIM, sigma=1.0)
+
+        toolbox = base.Toolbox()
+        toolbox.register("evaluate", benchmarks.sphere)
+        toolbox.register("generate", strategy.generate, creator.__dict__[INDCLSNAME])
+        toolbox.register("update", strategy.update)
+
+        pop, _ = algorithms.eaGenerateUpdate(toolbox, ngen=100)
+        best, = tools.selBest(pop, k=1)
+
+        assert best.fitness.values < (1e-8,), "CMA algorithm did not converged properly."
+
+    def test_nsga2(self):
+        self.setup_func_multi_obj()
+
+        NDIM = 5
+        BOUND_LOW, BOUND_UP = 0.0, 1.0
+        MU = 16
+        NGEN = 100
+
+        toolbox = base.Toolbox()
+        toolbox.register("attr_float", random.uniform, BOUND_LOW, BOUND_UP)
+        toolbox.register("individual", tools.initRepeat, creator.__dict__[INDCLSNAME], toolbox.attr_float, NDIM)
+        toolbox.register("population", tools.initRepeat, list, toolbox.individual)
+
+        toolbox.register("evaluate", benchmarks.zdt1)
+        toolbox.register("mate", tools.cxSimulatedBinaryBounded, low=BOUND_LOW, up=BOUND_UP, eta=20.0)
+        toolbox.register("mutate", tools.mutPolynomialBounded, low=BOUND_LOW, up=BOUND_UP, eta=20.0, indpb=1.0/NDIM)
+        toolbox.register("select", tools.selNSGA2)
+
+        pop = toolbox.population(n=MU)
+        fitnesses = toolbox.map(toolbox.evaluate, pop)
+        for ind, fit in zip(pop, fitnesses):
             ind.fitness.values = fit
 
-        pop = toolbox.select(pop + offspring, MU)
+        pop = toolbox.select(pop, len(pop))
+        for gen in range(1, NGEN):
+            offspring = tools.selTournamentDCD(pop, len(pop))
+            offspring = [toolbox.clone(ind) for ind in offspring]
 
-    hv = hypervolume(pop, [11.0, 11.0])
-    # hv = 120.777 # Optimal value
+            for ind1, ind2 in zip(offspring[::2], offspring[1::2]):
+                if random.random() <= 0.9:
+                    toolbox.mate(ind1, ind2)
 
-    assert hv > HV_THRESHOLD, "Hypervolume is lower than expected %f < %f" % (hv, HV_THRESHOLD)
+                toolbox.mutate(ind1)
+                toolbox.mutate(ind2)
+                del ind1.fitness.values, ind2.fitness.values
 
-    for ind in pop:
-        assert not (any(numpy.asarray(ind) < BOUND_LOW) or any(numpy.asarray(ind) > BOUND_UP))
+            invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
+            fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
+            for ind, fit in zip(invalid_ind, fitnesses):
+                ind.fitness.values = fit
 
+            pop = toolbox.select(pop + offspring, MU)
 
-@with_setup(setup_func_multi_obj_numpy, teardown_func)
-def test_mo_cma_es():
+        hv = hypervolume(pop, [11.0, 11.0])
+        # hv = 120.777 # Optimal value
 
-    def distance(feasible_ind, original_ind):
-        """A distance function to the feasibility region."""
-        return sum((f - o)**2 for f, o in zip(feasible_ind, original_ind))
+        assert hv > HV_THRESHOLD, "Hypervolume is lower than expected %f < %f" % (hv, HV_THRESHOLD)
 
-    def closest_feasible(individual):
-        """A function returning a valid individual from an invalid one."""
-        feasible_ind = numpy.array(individual)
-        feasible_ind = numpy.maximum(BOUND_LOW, feasible_ind)
-        feasible_ind = numpy.minimum(BOUND_UP, feasible_ind)
-        return feasible_ind
+        for ind in pop:
+            assert not (any(numpy.asarray(ind) < BOUND_LOW) or any(numpy.asarray(ind) > BOUND_UP))
 
-    def valid(individual):
-        """Determines if the individual is valid or not."""
-        if any(individual < BOUND_LOW) or any(individual > BOUND_UP):
-            return False
-        return True
 
-    NDIM = 5
-    BOUND_LOW, BOUND_UP = 0.0, 1.0
-    MU, LAMBDA = 10, 10
-    NGEN = 500
+    def test_mo_cma_es(self):
+        self.setup_func_multi_obj_numpy()
 
-    numpy.random.seed(128)
+        def distance(feasible_ind, original_ind):
+            """A distance function to the feasibility region."""
+            return sum((f - o)**2 for f, o in zip(feasible_ind, original_ind))
 
-    # The MO-CMA-ES algorithm takes a full population as argument
-    population = [creator.__dict__[INDCLSNAME](x) for x in numpy.random.uniform(BOUND_LOW, BOUND_UP, (MU, NDIM))]
+        def closest_feasible(individual):
+            """A function returning a valid individual from an invalid one."""
+            feasible_ind = numpy.array(individual)
+            feasible_ind = numpy.maximum(BOUND_LOW, feasible_ind)
+            feasible_ind = numpy.minimum(BOUND_UP, feasible_ind)
+            return feasible_ind
 
-    toolbox = base.Toolbox()
-    toolbox.register("evaluate", benchmarks.zdt1)
-    toolbox.decorate("evaluate", tools.ClosestValidPenalty(valid, closest_feasible, 1.0e+6, distance))
+        def valid(individual):
+            """Determines if the individual is valid or not."""
+            if any(individual < BOUND_LOW) or any(individual > BOUND_UP):
+                return False
+            return True
 
-    for ind in population:
-        ind.fitness.values = toolbox.evaluate(ind)
+        NDIM = 5
+        BOUND_LOW, BOUND_UP = 0.0, 1.0
+        MU, LAMBDA = 10, 10
+        NGEN = 500
 
-    strategy = cma.StrategyMultiObjective(population, sigma=1.0, mu=MU, lambda_=LAMBDA)
+        numpy.random.seed(128)
 
-    toolbox.register("generate", strategy.generate, creator.__dict__[INDCLSNAME])
-    toolbox.register("update", strategy.update)
+        # The MO-CMA-ES algorithm takes a full population as argument
+        population = [creator.__dict__[INDCLSNAME](x) for x in numpy.random.uniform(BOUND_LOW, BOUND_UP, (MU, NDIM))]
 
-    for gen in range(NGEN):
-        # Generate a new population
-        population = toolbox.generate()
+        toolbox = base.Toolbox()
+        toolbox.register("evaluate", benchmarks.zdt1)
+        toolbox.decorate("evaluate", tools.ClosestValidPenalty(valid, closest_feasible, 1.0e+6, distance))
 
-        # Evaluate the individuals
-        fitnesses = toolbox.map(toolbox.evaluate, population)
-        for ind, fit in zip(population, fitnesses):
-            ind.fitness.values = fit
+        for ind in population:
+            ind.fitness.values = toolbox.evaluate(ind)
+
+        strategy = cma.StrategyMultiObjective(population, sigma=1.0, mu=MU, lambda_=LAMBDA)
+
+        toolbox.register("generate", strategy.generate, creator.__dict__[INDCLSNAME])
+        toolbox.register("update", strategy.update)
+
+        for gen in range(NGEN):
+            # Generate a new population
+            population = toolbox.generate()
+
+            # Evaluate the individuals
+            fitnesses = toolbox.map(toolbox.evaluate, population)
+            for ind, fit in zip(population, fitnesses):
+                ind.fitness.values = fit
+
+            # Update the strategy with the evaluated individuals
+            toolbox.update(population)
+
+        # Note that we use a penalty to guide the search to feasible solutions,
+        # but there is no guarantee that individuals are valid.
+        # We expect the best individuals will be within bounds or very close.
+        num_valid = 0
+        for ind in strategy.parents:
+            dist = distance(closest_feasible(ind), ind)
+            if numpy.isclose(dist, 0.0, rtol=1.e-5, atol=1.e-5):
+                num_valid += 1
+        assert num_valid >= len(strategy.parents)
+
+        # Note that NGEN=500 is enough to get consistent hypervolume > 116,
+        # but not 119. More generations would help but would slow down testing.
+        hv = hypervolume(strategy.parents, [11.0, 11.0])
+        assert hv > HV_THRESHOLD, "Hypervolume is lower than expected %f < %f" % (hv, HV_THRESHOLD)
+
+
+    def test_nsga3(self):
+        self.setup_func_multi_obj()
+
+        NDIM = 5
+        BOUND_LOW, BOUND_UP = 0.0, 1.0
+        MU = 16
+        NGEN = 100
+
+        ref_points = tools.uniform_reference_points(2, p=12)
+
+        toolbox = base.Toolbox()
+        toolbox.register("attr_float", random.uniform, BOUND_LOW, BOUND_UP)
+        toolbox.register("individual", tools.initRepeat, creator.__dict__[INDCLSNAME], toolbox.attr_float, NDIM)
+        toolbox.register("population", tools.initRepeat, list, toolbox.individual)
 
-        # Update the strategy with the evaluated individuals
-        toolbox.update(population)
+        toolbox.register("evaluate", benchmarks.zdt1)
+        toolbox.register("mate", tools.cxSimulatedBinaryBounded, low=BOUND_LOW, up=BOUND_UP, eta=20.0)
+        toolbox.register("mutate", tools.mutPolynomialBounded, low=BOUND_LOW, up=BOUND_UP, eta=20.0, indpb=1.0/NDIM)
+        toolbox.register("select", tools.selNSGA3, ref_points=ref_points)
 
-    # Note that we use a penalty to guide the search to feasible solutions,
-    # but there is no guarantee that individuals are valid.
-    # We expect the best individuals will be within bounds or very close.
-    num_valid = 0
-    for ind in strategy.parents:
-        dist = distance(closest_feasible(ind), ind)
-        if numpy.isclose(dist, 0.0, rtol=1.e-5, atol=1.e-5):
-            num_valid += 1
-    assert num_valid >= len(strategy.parents)
-
-    # Note that NGEN=500 is enough to get consistent hypervolume > 116,
-    # but not 119. More generations would help but would slow down testing.
-    hv = hypervolume(strategy.parents, [11.0, 11.0])
-    assert hv > HV_THRESHOLD, "Hypervolume is lower than expected %f < %f" % (hv, HV_THRESHOLD)
-
-
-@with_setup(setup_func_multi_obj, teardown_func)
-def test_nsga3():
-    NDIM = 5
-    BOUND_LOW, BOUND_UP = 0.0, 1.0
-    MU = 16
-    NGEN = 100
-
-    ref_points = tools.uniform_reference_points(2, p=12)
-
-    toolbox = base.Toolbox()
-    toolbox.register("attr_float", random.uniform, BOUND_LOW, BOUND_UP)
-    toolbox.register("individual", tools.initRepeat, creator.__dict__[INDCLSNAME], toolbox.attr_float, NDIM)
-    toolbox.register("population", tools.initRepeat, list, toolbox.individual)
-
-    toolbox.register("evaluate", benchmarks.zdt1)
-    toolbox.register("mate", tools.cxSimulatedBinaryBounded, low=BOUND_LOW, up=BOUND_UP, eta=20.0)
-    toolbox.register("mutate", tools.mutPolynomialBounded, low=BOUND_LOW, up=BOUND_UP, eta=20.0, indpb=1.0/NDIM)
-    toolbox.register("select", tools.selNSGA3, ref_points=ref_points)
-
-    pop = toolbox.population(n=MU)
-    fitnesses = toolbox.map(toolbox.evaluate, pop)
-    for ind, fit in zip(pop, fitnesses):
-        ind.fitness.values = fit
-
-    pop = toolbox.select(pop, len(pop))
-     # Begin the generational process
-    for gen in range(1, NGEN):
-        offspring = algorithms.varAnd(pop, toolbox, 1.0, 1.0)
-
-        # Evaluate the individuals with an invalid fitness
-        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
-        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
-        for ind, fit in zip(invalid_ind, fitnesses):
+        pop = toolbox.population(n=MU)
+        fitnesses = toolbox.map(toolbox.evaluate, pop)
+        for ind, fit in zip(pop, fitnesses):
             ind.fitness.values = fit
 
-        # Select the next generation population
-        pop = toolbox.select(pop + offspring, MU)
+        pop = toolbox.select(pop, len(pop))
+         # Begin the generational process
+        for gen in range(1, NGEN):
+            offspring = algorithms.varAnd(pop, toolbox, 1.0, 1.0)
+
+            # Evaluate the individuals with an invalid fitness
+            invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
+            fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
+            for ind, fit in zip(invalid_ind, fitnesses):
+                ind.fitness.values = fit
+
+            # Select the next generation population
+            pop = toolbox.select(pop + offspring, MU)
 
-    hv = hypervolume(pop, [11.0, 11.0])
-    # hv = 120.777 # Optimal value
+        hv = hypervolume(pop, [11.0, 11.0])
+        # hv = 120.777 # Optimal value
 
-    assert hv > HV_THRESHOLD, "Hypervolume is lower than expected %f < %f" % (hv, HV_THRESHOLD)
+        assert hv > HV_THRESHOLD, "Hypervolume is lower than expected %f < %f" % (hv, HV_THRESHOLD)
 
-    for ind in pop:
-        assert not (any(numpy.asarray(ind) < BOUND_LOW) or any(numpy.asarray(ind) > BOUND_UP))
+        for ind in pop:
+            assert not (any(numpy.asarray(ind) < BOUND_LOW) or any(numpy.asarray(ind) > BOUND_UP))
Index: deap-1.3.1/deap/tests/test_creator.py
===================================================================
--- deap-1.3.1.orig/deap/tests/test_creator.py	2020-01-21 02:17:45.000000000 +0100
+++ deap-1.3.1/deap/tests/test_creator.py	2020-09-10 16:04:32.671140485 +0200
@@ -13,7 +13,7 @@
 #    You should have received a copy of the GNU Lesser General Public
 #    License along with DEAP. If not, see <http://www.gnu.org/licenses/>.
 
-from nose import with_setup
+import unittest
 from unittest import skipIf
 
 import array
@@ -27,57 +27,53 @@ from deap import creator
 
 CNAME = "CLASS_NAME"
 
-def teardown_func():
-    creator.__dict__.pop(CNAME)
-
-@with_setup(None, teardown_func)
-def test_create():
-    creator.create(CNAME, list)
-    l = creator.__dict__[CNAME]([1,2,3,4])
-
-    assert l == [1,2,3,4], "%s, expected %s" % (l, [1,2,3,4])
-
-@with_setup(None, teardown_func)
-def test_attribute():
-    creator.create(CNAME, list, a=1)
-    l = creator.__dict__[CNAME]([1,2,3,4])
-
-    assert l.a == 1, "%s, expected %i" % (l.a, 1)
-
-@with_setup(None, teardown_func)
-def test_array():
-    creator.create(CNAME, array.array, typecode="i")
-    a = creator.__dict__[CNAME]([1,2,3,4])
-    b = creator.__dict__[CNAME]([5,6,7,8])
-
-    a[1:3], b[1:3] = b[1:3], a[1:3]
-    ta = array.array("i", [1,6,7,4])
-    tb = array.array("i", [5,2,3,8])
-    assert a == ta, "%s, expected %s" % (a, ta)
-    assert b == tb, "%s, expected %s" % (b, tb)
-
-@skipIf(not numpy, "Cannot import Numpy numerical library")
-@with_setup(None, teardown_func)
-def test_numpy_nocopy():
-    creator.create(CNAME, numpy.ndarray)
-    a = creator.__dict__[CNAME]([1,2,3,4])
-    b = creator.__dict__[CNAME]([5,6,7,8])
-
-    a[1:3], b[1:3] = b[1:3], a[1:3]
-    ta = numpy.array([1,6,7,4])
-    tb = numpy.array([5,6,7,8])
-    assert all(a == ta), "%s, expected %s" % (a, ta)
-    assert all(b == tb), "%s, expected %s" % (b, tb)
-
-@skipIf(not numpy, "Cannot import Numpy numerical library")
-@with_setup(None, teardown_func)
-def test_numpy_copy():
-    creator.create(CNAME, numpy.ndarray)
-    a = creator.__dict__[CNAME]([1,2,3,4])
-    b = creator.__dict__[CNAME]([5,6,7,8])
-
-    a[1:3], b[1:3] = b[1:3].copy(), a[1:3].copy()
-    ta = numpy.array([1,6,7,4])
-    tb = numpy.array([5,2,3,8])
-    assert all(a == ta), "%s, expected %s" % (a, ta)
-    assert all(b == tb), "%s, expected %s" % (b, tb)
+class CreatorTest(unittest.TestCase):
+    def tearDown(self):
+        creator.__dict__.pop(CNAME)
+
+    def test_create(self):
+        creator.create(CNAME, list)
+        l = creator.__dict__[CNAME]([1,2,3,4])
+
+        assert l == [1,2,3,4], "%s, expected %s" % (l, [1,2,3,4])
+
+    def test_attribute(self):
+        creator.create(CNAME, list, a=1)
+        l = creator.__dict__[CNAME]([1,2,3,4])
+
+        assert l.a == 1, "%s, expected %i" % (l.a, 1)
+
+    def test_array(self):
+        creator.create(CNAME, array.array, typecode="i")
+        a = creator.__dict__[CNAME]([1,2,3,4])
+        b = creator.__dict__[CNAME]([5,6,7,8])
+
+        a[1:3], b[1:3] = b[1:3], a[1:3]
+        ta = array.array("i", [1,6,7,4])
+        tb = array.array("i", [5,2,3,8])
+        assert a == ta, "%s, expected %s" % (a, ta)
+        assert b == tb, "%s, expected %s" % (b, tb)
+
+    @skipIf(not numpy, "Cannot import Numpy numerical library")
+    def test_numpy_nocopy(self):
+        creator.create(CNAME, numpy.ndarray)
+        a = creator.__dict__[CNAME]([1,2,3,4])
+        b = creator.__dict__[CNAME]([5,6,7,8])
+
+        a[1:3], b[1:3] = b[1:3], a[1:3]
+        ta = numpy.array([1,6,7,4])
+        tb = numpy.array([5,6,7,8])
+        assert all(a == ta), "%s, expected %s" % (a, ta)
+        assert all(b == tb), "%s, expected %s" % (b, tb)
+
+    @skipIf(not numpy, "Cannot import Numpy numerical library")
+    def test_numpy_copy(self):
+        creator.create(CNAME, numpy.ndarray)
+        a = creator.__dict__[CNAME]([1,2,3,4])
+        b = creator.__dict__[CNAME]([5,6,7,8])
+
+        a[1:3], b[1:3] = b[1:3].copy(), a[1:3].copy()
+        ta = numpy.array([1,6,7,4])
+        tb = numpy.array([5,2,3,8])
+        assert all(a == ta), "%s, expected %s" % (a, ta)
+        assert all(b == tb), "%s, expected %s" % (b, tb)
Index: deap-1.3.1/deap/tests/test_init.py
===================================================================
--- deap-1.3.1.orig/deap/tests/test_init.py	2020-01-21 02:17:45.000000000 +0100
+++ deap-1.3.1/deap/tests/test_init.py	2020-09-10 16:04:35.175155518 +0200
@@ -5,7 +5,7 @@ import unittest
 from deap import tools
 
 
-class LogbookTest(unittest.TestCase):
+class InitTest(unittest.TestCase):
     def test_statistics_compile(self):
         l = 10
         gen_idx = partial(random.sample, range(l), l)
Index: deap-1.3.1/deap/tests/test_pickle.py
===================================================================
--- deap-1.3.1.orig/deap/tests/test_pickle.py	2020-01-21 02:17:45.000000000 +0100
+++ deap-1.3.1/deap/tests/test_pickle.py	2020-09-10 16:04:32.671140485 +0200
@@ -16,7 +16,7 @@ from deap import tools
 def func():
     return "True"
 
-class Pickling(unittest.TestCase):
+class PickleTest(unittest.TestCase):
 
     def setUp(self):
         creator.create("FitnessMax", base.Fitness, weights=(1.0,))
Index: deap-1.3.1/deap/tests/test_statistics.py
===================================================================
--- deap-1.3.1.orig/deap/tests/test_statistics.py	2020-01-21 02:17:45.000000000 +0100
+++ deap-1.3.1/deap/tests/test_statistics.py	2020-09-10 16:04:32.671140485 +0200
@@ -6,7 +6,7 @@ import numpy
 from deap import tools
 
 
-class LogbookTest(unittest.TestCase):
+class StatisticsTest(unittest.TestCase):
     def test_statistics_compile(self):
         s = tools.Statistics()
         s.register("mean", numpy.mean)
Index: deap-1.3.1/deap/tests/test_benchmarks.py
===================================================================
--- deap-1.3.1.orig/deap/tests/test_benchmarks.py	2020-01-21 02:17:45.000000000 +0100
+++ deap-1.3.1/deap/tests/test_benchmarks.py	2020-09-10 16:04:35.175155518 +0200
@@ -1,7 +1,6 @@
 """Test functions from deap/benchmarks."""
 import sys
 import unittest
-from nose import with_setup
 
 from deap import base
 from deap import benchmarks
Index: deap-1.3.1/pytest.ini
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ deap-1.3.1/pytest.ini	2020-09-10 16:06:18.491775783 +0200
@@ -0,0 +1,3 @@
+[pytest]
+testpaths = deap
+addopts = --doctest-modules
