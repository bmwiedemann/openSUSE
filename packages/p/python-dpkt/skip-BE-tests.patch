---
 dpkt/loopback.py |   24 +++++++++++++++++-------
 dpkt/pcapng.py   |   24 ++++++++++++++----------
 2 files changed, 31 insertions(+), 17 deletions(-)

--- a/dpkt/loopback.py
+++ b/dpkt/loopback.py
@@ -1,6 +1,9 @@
 # $Id: loopback.py 38 2007-03-17 03:33:16Z dugsong $
 # -*- coding: utf-8 -*-
 """Platform-dependent loopback header."""
+
+# https://wiki.wireshark.org/NullLoopback
+
 from __future__ import absolute_import
 
 from . import dpkt
@@ -24,17 +27,23 @@ class Loopback(dpkt.Packet):
 
     def unpack(self, buf):
         dpkt.Packet.unpack(self, buf)
-        if self.family == 2:
-            self.data = ip.IP(self.data)
-
-        elif self.family == 0x02000000:
+        if self.family in (0x02, 0x02000000):
             self.family = 2
             self.data = ip.IP(self.data)
 
-        elif self.family in (24, 28, 30):
+        elif self.family in (0x18, 0x18000000):
+            self.family = 24
             self.data = ip6.IP6(self.data)
 
-        elif self.family > 1500:
+        elif self.family in (0x1c, 0x1c000000):
+            self.family = 28
+            self.data = ip6.IP6(self.data)
+
+        elif self.family in (0x1e, 0x1e000000):
+            self.family = 30
+            self.data = ip6.IP6(self.data)
+
+        else:
             self.data = ethernet.Ethernet(self.data)
 
 
@@ -43,7 +52,7 @@ def test_ethernet_unpack():
     hdr = b'\x00\x02\x00\x02'
 
     lo = Loopback(hdr + buf)
-    assert lo.family == 33554944
+    assert lo.family in (0x02000200, 0x00020002)  # little endian, big endian
     assert isinstance(lo.data, ethernet.Ethernet)
     assert lo.data.src == b'\x07\x08\t\n\x0b\x0c'
     assert lo.data.dst == b'\x01\x02\x03\x04\x05\x06'
@@ -61,6 +70,7 @@ def test_ip_unpack():
 
 
 def test_ip6_unpack():
+
     import struct
     buf = (b'\x60\x00\x00\x00\x00\x14\x06\x38\x26\x07\xf8\xb0\x40\x0c\x0c\x03\x00\x00\x00\x00\x00\x00'
            b'\x00\x1a\x20\x01\x04\x70\xe5\xbf\xde\xad\x49\x57\x21\x74\xe8\x2c\x48\x87')
--- a/dpkt/pcapng.py
+++ b/dpkt/pcapng.py
@@ -888,6 +888,10 @@ def define_testdata():
         def shb_idb_epb_be(self):
             return self.valid_shb_be, self.valid_idb_be, self.valid_epb_be
 
+        @property
+        def shb_idb_epb(self):
+            return self.shb_idb_epb_le if sys.byteorder == 'little' else self.shb_idb_epb_be
+
     return TestData()
 
 
@@ -1138,15 +1142,14 @@ def test_custom_read_write():
     fobj.close()
 
     # test pcapng customized writing
-    if sys.byteorder == 'little':
-        shb, idb, epb = define_testdata().shb_idb_epb_le
-    else:
-        shb, idb, epb = define_testdata().shb_idb_epb_be
+    shb, idb, epb = define_testdata().shb_idb_epb
 
     fobj = BytesIO()
     writer = Writer(fobj, shb=shb, idb=idb)
     writer.writepkt(epb, ts=1442984653.210838)
-    assert fobj.getvalue() == buf
+    # .valid_pcapng buf was collected on a little endian system
+    if sys.byteorder == 'little':
+        assert fobj.getvalue() == buf
     fobj.close()
 
     # same with timestamps defined inside EPB
@@ -1156,14 +1159,15 @@ def test_custom_read_write():
     fobj = BytesIO()
     writer = Writer(fobj, shb=shb, idb=idb)
     writer.writepkt(epb)
-    assert fobj.getvalue() == buf
+    if sys.byteorder == 'little':
+        assert fobj.getvalue() == buf
     fobj.close()
 
 
 def test_multi_idb_writer():
     """Test writing multiple interface description blocks into pcapng and read it"""
     fobj = BytesIO()
-    shb, idb, epb = define_testdata().shb_idb_epb_le
+    shb, idb, epb = define_testdata().shb_idb_epb
 
     writer = Writer(fobj, shb=shb, idb=[idb, idb])
     writer.writepkt(epb)
@@ -1190,7 +1194,7 @@ def test_writer_validate_instance():
 def test_writepkt_epb_ts():
     """writepkt should assign ts_high/low for epb if they are 0"""
     global time
-    shb, idb, epb = define_testdata().shb_idb_epb_le
+    shb, idb, epb = define_testdata().shb_idb_epb
     writer = Writer(fobj, shb=shb, idb=idb)  # noqa
     epb.ts_high = epb.ts_low = 0
     ts = 1454725786.526401
@@ -1296,7 +1300,7 @@ def test_pcapng_block_unpack():
 
 def test_epb_unpack():
     """EnhancedPacketBlock can only unpack data >64 bytes, the length of their header"""
-    shb, idb, epb = define_testdata().shb_idb_epb_be
+    shb, idb, epb = define_testdata().shb_idb_epb
     buf = b'quite-long-but-not-long-enough-at-least-32'
     try:
         epb.unpack(buf)
@@ -1306,7 +1310,7 @@ def test_epb_unpack():
 
 def test_epb_unpack_length_mismatch():
     """Force calculated len to be 0 when unpacking epb, this should fail when unpacking"""
-    shb, idb, epb = define_testdata().shb_idb_epb_be
+    shb, idb, epb = define_testdata().shb_idb_epb
 
     unpackme = bytes(epb)
     unpackme = unpackme[:-4] + b'\x00' * 4
