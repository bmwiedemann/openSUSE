---
 anyjson/__init__.py           |   12 ++++++------
 setup.py                      |    7 +------
 tests/benchmark.py            |   20 ++++++++++----------
 tests/test_implementations.py |   15 +++++++++------
 4 files changed, 26 insertions(+), 28 deletions(-)

--- a/anyjson/__init__.py
+++ b/anyjson/__init__.py
@@ -50,7 +50,7 @@ class _JsonImplementation(object):
     """Incapsulates a JSON implementation"""
 
     def __init__(self, modspec):
-        modinfo = dict(zip(_fields, modspec))
+        modinfo = dict(list(zip(_fields, modspec)))
 
         # No try block. We want importerror to end up at caller
         module = self._attempt_load(modinfo["modname"])
@@ -61,9 +61,9 @@ class _JsonImplementation(object):
         self._encode_error = modinfo["encerror"]
         self._decode_error = modinfo["decerror"]
 
-        if isinstance(modinfo["encerror"], basestring):
+        if isinstance(modinfo["encerror"], str):
             self._encode_error = getattr(module, modinfo["encerror"])
-        if isinstance(modinfo["decerror"], basestring):
+        if isinstance(modinfo["decerror"], str):
             self._decode_error = getattr(module, modinfo["decerror"])
 
         self.name = modinfo["modname"]
@@ -82,7 +82,7 @@ class _JsonImplementation(object):
         TypeError if the object could not be serialized."""
         try:
             return self._encode(data)
-        except self._encode_error, exc:
+        except self._encode_error as exc:
             raise TypeError(*exc.args)
 
     def deserialize(self, s):
@@ -90,7 +90,7 @@ class _JsonImplementation(object):
         ValueError if the string vould not be parsed."""
         try:
             return self._decode(s)
-        except self._decode_error, exc:
+        except self._decode_error as exc:
             raise ValueError(*exc.args)
 
 
@@ -109,7 +109,7 @@ if __name__ == "__main__":
     # We do NOT try to load a compatible module because that may throw an
     # exception, which renders the package uninstallable with easy_install
     # (It trys to execfile the script when installing, to make sure it works)
-    print "Running anyjson as a stand alone script is not supported"
+    print("Running anyjson as a stand alone script is not supported")
     sys.exit(1)
 else:
     for modspec in _modules:
--- a/setup.py
+++ b/setup.py
@@ -1,8 +1,4 @@
-import sys
-
 extra = {}
-if sys.version_info >= (3, 0):
-    extra.update(use_2to3=True)
 
 try:
     from setuptools import setup, find_packages
@@ -12,7 +8,7 @@ except ImportError:
 author = "Rune Halvorsen"
 email = "runefh@gmail.com"
 version = "0.3"
-desc = """Wraps the best available JSON implementation available in a common interface"""
+desc = """Wraps the best JSON implementation available in a common interface"""
 
 setup(name='anyjson',
       version=version,
@@ -38,6 +34,5 @@ setup(name='anyjson',
       packages=find_packages(exclude=['ez_setup', 'examples', 'tests']),
       zip_safe=False,
       platforms=["any"],
-      test_suite = 'nose.collector',
       **extra
 )
--- a/tests/benchmark.py
+++ b/tests/benchmark.py
@@ -4,7 +4,7 @@ Simple benchmark script to do some basic
 
 import sys
 import time
-import urllib
+import urllib.request, urllib.parse, urllib.error
 
 _small = """
 {
@@ -77,8 +77,8 @@ _twitter = "[]"
 
 def load_external_json():
     global _reddit, _twitter
-    _reddit = urllib.urlopen("http://reddit.com/.json").read()
-    _twitter = urllib.urlopen("http://api.twitter.com/1/statuses/user_timeline.json?screen_name=twitterapi&count=200").read()
+    _reddit = urllib.request.urlopen("http://reddit.com/.json").read()
+    _twitter = urllib.request.urlopen("http://api.twitter.com/1/statuses/user_timeline.json?screen_name=twitterapi&count=200").read()
 
 
 def do_benchmark(impspec, json, runs=10):
@@ -93,13 +93,13 @@ def do_benchmark(impspec, json, runs=10)
         return None
 
     start = time.time()
-    for n in xrange(runs):
+    for n in range(runs):
         data = reads(json)
 
     readtime = time.time() - start
 
     start = time.time()
-    for n in xrange(runs):
+    for n in range(runs):
         devnull = dumps(data)
 
     return readtime, time.time() - start # tuple (readtime, writetime)
@@ -131,13 +131,13 @@ for e in modules:
 
 no_res = set([e for e in res if e[1] is None])
 res = list(set(res) - no_res)
-res = [(e[0], sum(map(lambda x:x[0], e[1:])), sum(map(lambda x:x[1], e[1:]))) for e in res]
+res = [(e[0], sum([x[0] for x in e[1:]]), sum([x[1] for x in e[1:]])) for e in res]
 
 res.sort(lambda a,b: cmp((a[1]+a[2]), b[1]+b[2]))
 
-print "Total  Read   Write  Implementation"
-print "-----------------------------------"
+print("Total  Read   Write  Implementation")
+print("-----------------------------------")
 for e in res:
-    print "%.3f  %.3f  %.3f  %s" % (e[1]+e[2], e[1], e[2], e[0])
+    print("%.3f  %.3f  %.3f  %s" % (e[1]+e[2], e[1], e[2], e[0]))
 for e in no_res:
-    print "Not installed:", e[0]
+    print("Not installed:", e[0])
--- a/tests/test_implementations.py
+++ b/tests/test_implementations.py
@@ -1,4 +1,4 @@
-from nose.tools import assert_raises
+import pytest
 import anyjson
 
 modnames = [e[0] for e in anyjson._modules]
@@ -42,8 +42,11 @@ def test_exceptions():
         except ImportError:
             continue # module can't be tested, try next
 
-        assert_raises(TypeError, anyjson.serialize, [object()])
-        assert_raises(TypeError, anyjson.dumps, [object()])
-        assert_raises(ValueError, anyjson.deserialize, "[")
-        assert_raises(ValueError, anyjson.loads, "[")
-
+        with pytest.raises(TypeError):
+            anyjson.serialize([object()])
+        with pytest.raises(TypeError):
+            anyjson.dumps([object()])
+        with pytest.raises(ValueError):
+            anyjson.deserialize("[")
+        with pytest.raises(ValueError):
+            anyjson.loads("[")
