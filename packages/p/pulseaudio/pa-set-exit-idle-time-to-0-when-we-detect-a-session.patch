From: Tanu Kaskinen <tanuk@iki.fi>
Subject: [PATCH] set exit-idle-time to 0 when we detect a session
Date: Wed, 28 Feb 2018 18:16:03 +0200
Message-Id: <20180228161603.30746-1-tanuk@iki.fi>

As the comments explain, this fixes relogin problems on some systems
that remove our sockets on logout without terminating the daemon.
---

 src/modules/module-console-kit.c   |   13 +++++++++++++
 src/modules/module-systemd-login.c |   14 ++++++++++++++
 src/modules/x11/module-x11-xsmp.c  |   13 +++++++++++++
 src/pulsecore/core.c               |   10 ++++++++++
 src/pulsecore/core.h               |    2 ++
 5 files changed, 52 insertions(+)

--- a/src/modules/module-console-kit.c
+++ b/src/modules/module-console-kit.c
@@ -120,6 +120,19 @@ static void add_session(struct userdata
 
     pa_log_debug("Added new session %s", id);
 
+    /* Positive exit_idle_time is only useful when we have no session tracking
+     * capability, so we can set it to 0 now that we have detected a session.
+     * The benefit of setting exit_idle_time to 0 is that pulseaudio will exit
+     * immediately when the session ends. That in turn is useful, because some
+     * systems (those that use pam_systemd but don't use systemd for managing
+     * pulseaudio) clean $XDG_RUNTIME_DIR on logout, but fail to terminate all
+     * services that depend on the files in $XDG_RUNTIME_DIR. The directory
+     * contains our sockets, and if the sockets are removed without terminating
+     * pulseaudio, a quick relogin will likely cause trouble, because a new
+     * instance will be spawned while the old instance is still running. */
+    if (u->core->exit_idle_time > 0)
+        pa_core_set_exit_idle_time(u->core, 0);
+
 fail:
 
     if (m)
--- a/src/modules/module-systemd-login.c
+++ b/src/modules/module-systemd-login.c
@@ -86,6 +86,20 @@ static int add_session(struct userdata *
     pa_hashmap_put(u->sessions, session->id, session);
 
     pa_log_debug("Added new session %s", id);
+
+    /* Positive exit_idle_time is only useful when we have no session tracking
+     * capability, so we can set it to 0 now that we have detected a session.
+     * The benefit of setting exit_idle_time to 0 is that pulseaudio will exit
+     * immediately when the session ends. That in turn is useful, because some
+     * systems (those that use pam_systemd but don't use systemd for managing
+     * pulseaudio) clean $XDG_RUNTIME_DIR on logout, but fail to terminate all
+     * services that depend on the files in $XDG_RUNTIME_DIR. The directory
+     * contains our sockets, and if the sockets are removed without terminating
+     * pulseaudio, a quick relogin will likely cause trouble, because a new
+     * instance will be spawned while the old instance is still running. */
+    if (u->core->exit_idle_time > 0)
+        pa_core_set_exit_idle_time(u->core, 0);
+
     return 0;
 }
 
--- a/src/modules/x11/module-x11-xsmp.c
+++ b/src/modules/x11/module-x11-xsmp.c
@@ -208,6 +208,19 @@ int pa__init(pa_module*m) {
     if (!u->client)
         goto fail;
 
+    /* Positive exit_idle_time is only useful when we have no session tracking
+     * capability, so we can set it to 0 now that we have detected a session.
+     * The benefit of setting exit_idle_time to 0 is that pulseaudio will exit
+     * immediately when the session ends. That in turn is useful, because some
+     * systems (those that use pam_systemd but don't use systemd for managing
+     * pulseaudio) clean $XDG_RUNTIME_DIR on logout, but fail to terminate all
+     * services that depend on the files in $XDG_RUNTIME_DIR. The directory
+     * contains our sockets, and if the sockets are removed without terminating
+     * pulseaudio, a quick relogin will likely cause trouble, because a new
+     * instance will be spawned while the old instance is still running. */
+    if (u->core->exit_idle_time > 0)
+        pa_core_set_exit_idle_time(u->core, 0);
+
     pa_modargs_free(ma);
 
     return 0;
--- a/src/pulsecore/core.c
+++ b/src/pulsecore/core.c
@@ -426,6 +426,16 @@ void pa_core_update_default_source(pa_co
     pa_hook_fire(&core->hooks[PA_CORE_HOOK_DEFAULT_SOURCE_CHANGED], core->default_source);
 }
 
+void pa_core_set_exit_idle_time(pa_core *core, int time) {
+    pa_assert(core);
+
+    if (time == core->exit_idle_time)
+        return;
+
+    pa_log_info("exit_idle_time: %i -> %i", core->exit_idle_time, time);
+    core->exit_idle_time = time;
+}
+
 static void exit_callback(pa_mainloop_api *m, pa_time_event *e, const struct timeval *t, void *userdata) {
     pa_core *c = userdata;
     pa_assert(c->exit_event == e);
--- a/src/pulsecore/core.h
+++ b/src/pulsecore/core.h
@@ -254,6 +254,8 @@ void pa_core_set_configured_default_sour
 void pa_core_update_default_sink(pa_core *core);
 void pa_core_update_default_source(pa_core *core);
 
+void pa_core_set_exit_idle_time(pa_core *core, int time);
+
 /* Check whether no one is connected to this core */
 void pa_core_check_idle(pa_core *c);
 
