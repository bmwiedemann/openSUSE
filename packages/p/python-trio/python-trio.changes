-------------------------------------------------------------------
Sun Oct 11 15:36:02 UTC 2020 - John Vandenberg <jayvdb@gmail.com>

- Remove hashbang and tests in runtime package
- Disable test test_close_at_bad_time_for_send_all due to failure on PPC
- Update to v0.17.0
  * trio.open_tcp_stream has a new local_address= keyword argument
    that can be used on machines with multiple IP addresses to
    control which IP is used for the outgoing connection
  * If you pass a raw IP address into sendto, it no longer spends
    any time trying to resolve the hostname. If you're using UDP,
    this should substantially reduce your per-packet overhead
  * trio.lowlevel.checkpoint is now much faster
  * new, lower-overhead data structure to track upcoming timeouts,
    which should make your programs faster
  * Trio can now be imported when sys.excepthook is a functools.partial
    instance, which might occur in a pytest-qt test function
  * The thread cache didn't release its reference to the previous job
  * Remove wait_socket_*, notify_socket_closing, notify_fd_closing,
    run_sync_in_worker_thread and current_default_worker_thread_limiter
  * When using "instruments", you now only "pay for what you use":
    if there are no instruments installed that override a particular
    hook such as `abc.Instrument.before_task_step`, then Trio doesn't
    waste any effort on checking its instruments when the event
    corresponding to that hook occurs.
    
-------------------------------------------------------------------
Thu Jul 23 12:46:45 UTC 2020 - Marketa Calabkova <mcalabkova@suse.com>

- Update to 0.16.0
  * If you want to use Trio, but are stuck with some other event loop 
    like Qt or PyGame, then good news: now you can have both.
  * To speed up `trio.to_thread.run_sync`, Trio now caches and re-uses
    worker threads.
  * Tasks spawned with `nursery.start() <trio.Nursery.start>` aren't treated as
    direct children of their nursery until they call ``task_status.started()``.
  * Some bugfixes and deprecations
  
-------------------------------------------------------------------
Tue Jun  9 07:36:03 UTC 2020 - Tomáš Chvátal <tchvatal@suse.com>

- Update to 0.15.1:
  * Added a helpful error message if an async function is passed to
    trio.from_thread.run_sync or a sync function to trio.from_thread.run. (#1244)
  * Previously, when trio.run_process was cancelled, it always killed the subprocess immediately. Now, on Unix, it first gives the process a chance to clean up by sending SIGTERM, and only escalates to SIGKILL if the process is still running after 5 seconds. But if you prefer the old behavior, or want to adjust the timeout, then don't worry: you can now pass a custom deliver_cancel= argument to define your own process killing policy. (#1104)
  * It turns out that creating a subprocess can block the parent process for a surprisingly long time. So trio.open_process now uses a worker thread to avoid blocking the event loop. (#1109)
  * On Linux kernels v5.3 or newer, trio.Process.wait now uses the pidfd API to track child processes. This shouldn't have any user-visible change, but it makes working with subprocesses faster and use less memory. (#1241)
  * The trio.Process.returncode attribute is now automatically updated as needed, instead of only when you call ~trio.Process.poll or ~trio.Process.wait. Also, repr(process_object) now always contains up-to-date information about the process status. (#1315)

-------------------------------------------------------------------
Sat Jan 11 12:01:37 UTC 2020 - Ondřej Súkup <mimi.vx@gmail.com>

- update to 0.13.0
 * Use slots for memory channel state and statistics which should make
    memory channels slightly smaller and faster. 
 * OpenSSL has a bug in its handling of TLS 1.3 session tickets that can cause
    deadlocks or data loss in some rare edge cases. These edge cases most frequently
    happen during tests.
 * Trio now uses signal.set_wakeup_fd on all platforms.
 * Trio no longer crashes when an async function is implemented in C or Cython
    and then passed directly to trio.run or nursery.start_soon.
 * When a Trio task makes improper use of a non-Trio async library, Trio nowi
    causes an exception to be raised within the task at the point of the error,
    rather than abandoning the task and raising an error in its parent.
    This improves debuggability and resolves the TrioInternalError that would
    sometimes result from the old strategy. (#552)
 * In 0.12.0 we deprecated trio.run_sync_in_worker_thread in favor
    of trio.to_thread.run_sync. But, the deprecation message listed the wrong
    name for the replacement.
 * Fix regression introduced with cancellation changes in 0.12.0, where
    a trio.CancelScope which isn't cancelled could catch a propagating
    trio.Cancelled exception if shielding were changed while the cancellation
    was propagating.
 * Fix a crash that could happen when using MockClock with autojump enabled
    and a non-zero rate.
 * If you nest >1000 cancel scopes within each other, Trio now handles that
    gracefully instead of crashing with a RecursionError.
 * Fixed the hash behavior of trio.Path to match pathlib.Path. Previously
    trio.Path's hash was inherited from object instead of from pathlib.PurePath.

-------------------------------------------------------------------
Mon Aug  5 12:56:53 UTC 2019 - pgajdos@suse.com

- version update to 0.12.1
  Features
  * If you have a `~trio.abc.ReceiveStream` object, you can now use
    ``async for data in stream: ...`` instead of calling
    `~trio.abc.ReceiveStream.receive_some`. Each iteration gives an
    arbitrary sized chunk of bytes. And the best part is, the loop
    automatically exits when you reach EOF, so you don't have to check for
    it yourself anymore. Relatedly, you no longer need to pick a magic
    buffer size value before calling
    `~trio.abc.ReceiveStream.receive_some`; you can ``await
    stream.receive_some()`` with no arguments, and the stream will
    automatically pick a reasonable size for you. (`#959 <https://github.com/python-trio/trio/issues/959>`__)
  * Threading interfaces have been reworked:
    ``run_sync_in_worker_thread`` is now `trio.to_thread.run_sync`, and
    instead of ``BlockingTrioPortal``, use `trio.from_thread.run` and
    `trio.from_thread.run_sync`. What's neat about this is that these
    cooperate, so if you're in a thread created by `to_thread.run_sync`,
    it remembers which Trio created it, and you can call
    ``trio.from_thread.*`` directly without having to pass around a
    ``BlockingTrioPortal`` object everywhere. (`#810 <https://github.com/python-trio/trio/issues/810>`__)
  * We cleaned up the distinction between the "abstract channel interface"
    and the "memory channel" concrete implementation.
    `trio.abc.SendChannel` and `trio.abc.ReceiveChannel` have been slimmed
    down, `trio.MemorySendChannel` and `trio.MemoryReceiveChannel` are now
    public types that can be used in type hints, and there's a new
    `trio.abc.Channel` interface for future bidirectional channels. (`#719 <https://github.com/python-trio/trio/issues/719>`__)
  * Add :func:`trio.run_process` as a high-level helper for running a process
    and waiting for it to finish, like the standard :func:`subprocess.run` does. (`#822 <https://github.com/python-trio/trio/issues/822>`__)
  * On Linux, when wrapping a bare file descriptor in a Trio socket object,
    Trio now auto-detects the correct ``family``, ``type``, and ``protocol``.
    This is useful, for example, when implementing `systemd socket activation
    <http://0pointer.de/blog/projects/socket-activation.html>`__. (`#251 <https://github.com/python-trio/trio/issues/251>`__)
  * Trio sockets have a new method `~trio.socket.SocketType.is_readable` that allows
    you to check whether a socket is readable. This is useful for HTTP/1.1 clients. (`#760 <https://github.com/python-trio/trio/issues/760>`__)
  * We no longer use runtime code generation to dispatch core functions
    like `current_time`. Static analysis tools like mypy and pylint should
    now be able to recognize and analyze all of Trio's top-level functions
    (though some class attributes are still dynamic... we're working on it). (`#805 <https://github.com/python-trio/trio/issues/805>`__)
  * Add `trio.hazmat.FdStream` for wrapping a Unix file descriptor as a `~trio.abc.Stream`. (`#829 <https://github.com/python-trio/trio/issues/829>`__)
  * Trio now gives a reasonable traceback and error message in most cases
    when its invariants surrounding cancel scope nesting have been
    violated. (One common source of such violations is an async generator
    that yields within a cancel scope.) The previous behavior was an
    inscrutable chain of TrioInternalErrors. (`#882 <https://github.com/python-trio/trio/issues/882>`__)
  * MultiError now defines its ``exceptions`` attribute in ``__init__()``
    to better support linters and code autocompletion. (`#1066 <https://github.com/python-trio/trio/issues/1066>`__)
  * Use ``__slots__`` in more places internally, which should make Trio slightly faster. (`#984 <https://github.com/python-trio/trio/issues/984>`__)
  * In v0.12.0, we accidentally moved ``BlockingTrioPortal`` from ``trio``
    to ``trio.hazmat``. It's now been restored to its proper position.
    (It's still deprecated though, and will issue a warning if you use it.) (`#1167 <https://github.com/python-trio/trio/issues/1167>`__)
  Bugfixes
  * Destructor methods (``__del__``) are now protected against ``KeyboardInterrupt``. (`#676 <https://github.com/python-trio/trio/issues/676>`__)
  * The :class:`trio.Path` methods :meth:`~trio.Path.glob` and
    :meth:`~trio.Path.rglob` now return iterables of :class:`trio.Path`
    (not :class:`pathlib.Path`). (`#917 <https://github.com/python-trio/trio/issues/917>`__)
  * Inspecting the :attr:`~trio.CancelScope.cancel_called` attribute of a
    not-yet-exited cancel scope whose deadline is in the past now always
    returns ``True``, like you might expect. (Previously it would return
    ``False`` for not-yet-entered cancel scopes, and for active cancel
    scopes until the first checkpoint after their deadline expiry.) (`#958 <https://github.com/python-trio/trio/issues/958>`__)
  * The :class:`trio.Path` classmethods, :meth:`~trio.Path.home` and
    :meth:`~trio.Path.cwd`, are now async functions.  Previously, a bug
    in the forwarding logic meant :meth:`~trio.Path.cwd` was synchronous
    and :meth:`~trio.Path.home` didn't work at all. (`#960 <https://github.com/python-trio/trio/issues/960>`__)
  * An exception encapsulated within a :class:`MultiError` doesn't need to be
    hashable anymore.

-------------------------------------------------------------------
Mon Aug  5 12:45:29 UTC 2019 - pgajdos@suse.com

- version update to 0.12.1
  * no upstream change log found

-------------------------------------------------------------------
Sun Jun  2 12:40:48 UTC 2019 - Jan Engelhardt <jengelh@inai.de>

- Trim filler wording from descriptions.

-------------------------------------------------------------------
Wed May 29 09:09:31 UTC 2019 - Tomáš Chvátal <tchvatal@suse.com>

- Skip tests that fail with TLS 1.3 as upstream is not finished
  with supporting it yet

-------------------------------------------------------------------
Wed May 22 13:02:44 UTC 2019 - Tomáš Chvátal <tchvatal@suse.com>

- Fix deadlocks in the testsuite

-------------------------------------------------------------------
Tue May 14 21:27:51 UTC 2019 - Tomáš Chvátal <tchvatal@suse.com>

- Run the tests
- Fix the deps

-------------------------------------------------------------------
Sat May 11 19:16:24 UTC 2019 - Torsten Gruner <t.gruner@katodev.de>

- Initial release version 0.11.0

