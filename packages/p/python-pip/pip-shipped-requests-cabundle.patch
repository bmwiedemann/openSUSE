---
 src/pip/_vendor/certifi/core.py |  105 +++-------------------------------------
 tests/unit/test_options.py      |    5 +
 2 files changed, 13 insertions(+), 97 deletions(-)

Index: pip-25.2/src/pip/_vendor/certifi/core.py
===================================================================
--- pip-25.2.orig/src/pip/_vendor/certifi/core.py
+++ pip-25.2/src/pip/_vendor/certifi/core.py
@@ -3,81 +3,14 @@ certifi.py
 ~~~~~~~~~~
 
 This module returns the installation location of cacert.pem or its contents.
+Patched by openSUSE: return the system bundle
 """
-import sys
-import atexit
+def read_text(_module=None, _path=None, encoding="ascii"):
+    with open(where(), "r", encoding=encoding) as data:
+        return data.read()
 
-def exit_cacert_ctx() -> None:
-    _CACERT_CTX.__exit__(None, None, None)  # type: ignore[union-attr]
+def where() -> str:
+    return "/etc/ssl/ca-bundle.pem"
 
-
-if sys.version_info >= (3, 11):
-
-    from importlib.resources import as_file, files
-
-    _CACERT_CTX = None
-    _CACERT_PATH = None
-
-    def where() -> str:
-        # This is slightly terrible, but we want to delay extracting the file
-        # in cases where we're inside of a zipimport situation until someone
-        # actually calls where(), but we don't want to re-extract the file
-        # on every call of where(), so we'll do it once then store it in a
-        # global variable.
-        global _CACERT_CTX
-        global _CACERT_PATH
-        if _CACERT_PATH is None:
-            # This is slightly janky, the importlib.resources API wants you to
-            # manage the cleanup of this file, so it doesn't actually return a
-            # path, it returns a context manager that will give you the path
-            # when you enter it and will do any cleanup when you leave it. In
-            # the common case of not needing a temporary file, it will just
-            # return the file system location and the __exit__() is a no-op.
-            #
-            # We also have to hold onto the actual context manager, because
-            # it will do the cleanup whenever it gets garbage collected, so
-            # we will also store that at the global level as well.
-            _CACERT_CTX = as_file(files("pip._vendor.certifi").joinpath("cacert.pem"))
-            _CACERT_PATH = str(_CACERT_CTX.__enter__())
-            atexit.register(exit_cacert_ctx)
-
-        return _CACERT_PATH
-
-    def contents() -> str:
-        return files("pip._vendor.certifi").joinpath("cacert.pem").read_text(encoding="ascii")
-
-else:
-
-    from importlib.resources import path as get_path, read_text
-
-    _CACERT_CTX = None
-    _CACERT_PATH = None
-
-    def where() -> str:
-        # This is slightly terrible, but we want to delay extracting the
-        # file in cases where we're inside of a zipimport situation until
-        # someone actually calls where(), but we don't want to re-extract
-        # the file on every call of where(), so we'll do it once then store
-        # it in a global variable.
-        global _CACERT_CTX
-        global _CACERT_PATH
-        if _CACERT_PATH is None:
-            # This is slightly janky, the importlib.resources API wants you
-            # to manage the cleanup of this file, so it doesn't actually
-            # return a path, it returns a context manager that will give
-            # you the path when you enter it and will do any cleanup when
-            # you leave it. In the common case of not needing a temporary
-            # file, it will just return the file system location and the
-            # __exit__() is a no-op.
-            #
-            # We also have to hold onto the actual context manager, because
-            # it will do the cleanup whenever it gets garbage collected, so
-            # we will also store that at the global level as well.
-            _CACERT_CTX = get_path("pip._vendor.certifi", "cacert.pem")
-            _CACERT_PATH = str(_CACERT_CTX.__enter__())
-            atexit.register(exit_cacert_ctx)
-
-        return _CACERT_PATH
-
-    def contents() -> str:
-        return read_text("pip._vendor.certifi", "cacert.pem", encoding="ascii")
+def contents() -> str:
+    return read_text(encoding="ascii")
Index: pip-25.2/tests/unit/test_options.py
===================================================================
--- pip-25.2.orig/tests/unit/test_options.py
+++ pip-25.2/tests/unit/test_options.py
@@ -1,6 +1,7 @@
 from __future__ import annotations
 
 import os
+import os.path
 from collections.abc import Iterator
 from contextlib import contextmanager
 from optparse import Values
@@ -13,6 +14,7 @@ import pip._internal.configuration
 from pip._internal.cli.main import main
 from pip._internal.commands import create_command
 from pip._internal.commands.configuration import ConfigurationCommand
+from pip._vendor.certifi import where
 from pip._internal.exceptions import PipError
 
 from tests.lib.options_helpers import AddFakeCommandMixin
@@ -621,6 +623,9 @@ class TestOptionsConfigFiles:
         else:
             assert expect == cmd._determine_file(options, need_value=False)
 
+    def test_certificates(self):
+        assert os.path.exists(where())
+
 
 class TestOptionsExpandUser(AddFakeCommandMixin):
     def test_cache_dir(self) -> None:
