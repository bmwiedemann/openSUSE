From 945be16617dce4254b8a4793e9431d248b43b9c1 Mon Sep 17 00:00:00 2001
From: Wim Taymans <wtaymans@redhat.com>
Date: Mon, 9 Oct 2023 10:35:30 +0200
Subject: [PATCH] acp: only join and link when 1 capture and 1 playback

Only schedule nodes together when there is just 1 capture and 1 playback
device. Devices might be mutually exclusive or require special setup
that would break otherwise.

See #3556
---
 spa/plugins/alsa/acp/acp.c | 23 ++++++++++++++++-------
 1 file changed, 16 insertions(+), 7 deletions(-)

diff --git a/spa/plugins/alsa/acp/acp.c b/spa/plugins/alsa/acp/acp.c
index 1dbc0c2d7..e2e0b3eb5 100644
--- a/spa/plugins/alsa/acp/acp.c
+++ b/spa/plugins/alsa/acp/acp.c
@@ -296,7 +296,7 @@ static const char *find_best_verb(pa_card *impl)
 static int add_pro_profile(pa_card *impl, uint32_t index)
 {
 	snd_ctl_t *ctl_hndl;
-	int err, dev, count = 0;
+	int err, dev, count = 0, n_capture = 0, n_playback = 0;
 	pa_alsa_profile *ap;
 	pa_alsa_profile_set *ps = impl->profile_set;
 	pa_alsa_mapping *m;
@@ -304,6 +304,7 @@ static int add_pro_profile(pa_card *impl, uint32_t index)
 	snd_pcm_info_t *pcminfo;
 	pa_sample_spec ss;
 	snd_pcm_uframes_t try_period_size, try_buffer_size;
+	uint32_t idx;
 
 	if (impl->use_ucm) {
 		const char *verb = find_best_verb(impl);
@@ -388,12 +389,10 @@ static int add_pro_profile(pa_card *impl, uint32_t index)
 				pa_alsa_init_proplist_pcm(NULL, m->output_proplist, m->output_pcm);
 				pa_proplist_setf(m->output_proplist, "clock.name", "api.alsa.%u", index);
 				pa_proplist_setf(m->output_proplist, "device.profile.pro", "true");
-				pa_proplist_setf(m->output_proplist, "node.group", "pro-audio-%u", index);
-				pa_proplist_setf(m->output_proplist, "node.link-group", "pro-audio-%u", index);
-				pa_proplist_setf(m->input_proplist, "api.alsa.auto-link", "true");
 				pa_alsa_close(&m->output_pcm);
 				m->supported = true;
 				pa_channel_map_init_auto(&m->channel_map, m->sample_spec.channels, PA_CHANNEL_MAP_AUX);
+				n_playback++;
 			}
 			pa_idxset_put(ap->output_mappings, m, NULL);
 			free(name);
@@ -422,12 +421,10 @@ static int add_pro_profile(pa_card *impl, uint32_t index)
 				pa_alsa_init_proplist_pcm(NULL, m->input_proplist, m->input_pcm);
 				pa_proplist_setf(m->input_proplist, "clock.name", "api.alsa.%u", index);
 				pa_proplist_setf(m->input_proplist, "device.profile.pro", "true");
-				pa_proplist_setf(m->input_proplist, "node.group", "pro-audio-%u", index);
-				pa_proplist_setf(m->input_proplist, "node.link-group", "pro-audio-%u", index);
-				pa_proplist_setf(m->input_proplist, "api.alsa.auto-link", "true");
 				pa_alsa_close(&m->input_pcm);
 				m->supported = true;
 				pa_channel_map_init_auto(&m->channel_map, m->sample_spec.channels, PA_CHANNEL_MAP_AUX);
+				n_capture++;
 			}
 			pa_idxset_put(ap->input_mappings, m, NULL);
 			free(name);
@@ -435,6 +432,18 @@ static int add_pro_profile(pa_card *impl, uint32_t index)
 	}
 	snd_ctl_close(ctl_hndl);
 
+	if (n_capture == 1 && n_playback == 1) {
+		PA_IDXSET_FOREACH(m, ap->output_mappings, idx) {
+			pa_proplist_setf(m->output_proplist, "node.group", "pro-audio-%u", index);
+			pa_proplist_setf(m->output_proplist, "node.link-group", "pro-audio-%u", index);
+			pa_proplist_setf(m->output_proplist, "api.alsa.auto-link", "true");
+		}
+		PA_IDXSET_FOREACH(m, ap->input_mappings, idx) {
+			pa_proplist_setf(m->input_proplist, "node.group", "pro-audio-%u", index);
+			pa_proplist_setf(m->input_proplist, "node.link-group", "pro-audio-%u", index);
+			pa_proplist_setf(m->input_proplist, "api.alsa.auto-link", "true");
+		}
+	}
 	return 0;
 }
 
-- 
GitLab

