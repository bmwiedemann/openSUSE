From 13afef630c7c1df244150d5828cd295f1363f380 Mon Sep 17 00:00:00 2001
From: Luca Saiu <positron@gnu.org>
Date: Wed, 7 Sep 2022 01:38:17 +0200
Subject: [PATCH] support non-executable stacks on more architectures

Ensure that the stack is not unintentionally made executable in more cases by
not relying on the architecture being known for
  .section .note.GNU-stack, "", @progbits
.  Also support the alternative ARM syntax.

* jitter/jitter-machine-common.S (.section .note.GNU-stack, "", @progbits):
Move code and comments out of the large CPP conditional.  Add another equivalent
line guarded by JITTER_HAVE_SECTION_NOTE_GNU_STACK_IN_ARM_SYNTAX for the
alternative syntax.  No longer depend on ELF, by switching from .previous to a
more crude but portable .text

* configure.ac: New check for .note-GNU-stack section support in ARM syntax.
(ac_cv_have_section_note_gnu_stack_in_arm_syntax): New shell variable.
(JITTER_HAVE_SECTION_NOTE_GNU_STACK_IN_ARM_SYNTAX): New CPP feature macro.
* jitter/jitter-config.h.in (JITTER_HAVE_SECTION_NOTE_GNU_STACK_IN_ARM_SYNTAX):
New feature macro.

Thanks to Antoine Belvire for reporting the problem.  My fix is a little
different from what he suggested.
---
 configure.ac                   | 21 ++++++++++
 jitter/jitter-config.h.in      |  2 +
 jitter/jitter-machine-common.S | 71 ++++++++++++++++++++--------------
 3 files changed, 66 insertions(+), 28 deletions(-)

diff --git a/configure.ac b/configure.ac
index 24e8216..da2ead9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1421,6 +1421,27 @@ if test "x$ac_cv_have_section_note_gnu_stack" = "xyes"; then
             [Define if the platform supports a .note.GNU-stack section.])
 fi
 
+# Same in ARM syntax.  Notice that we check this on every architecture, not
+# only ARM: this is the Autoconf way, and may prevent future problems in case
+# other architectures have the same quirk.
+AC_CACHE_CHECK([for .note-GNU-stack section support in ARM syntax],
+  [ac_cv_have_section_note_gnu_stack_in_arm_syntax],
+  [AC_LINK_IFELSE(
+     [AC_LANG_PROGRAM(
+        [[]],
+        [[/* The section prefix character here is '%' instead of '@'. */
+          asm volatile (".section .note.GNU-stack, \"\", %progbits\n"
+                        ".previous");
+        ]])],
+     [ac_cv_have_section_note_gnu_stack_in_arm_syntax=yes],
+     [ac_cv_have_section_note_gnu_stack_in_arm_syntax=no])])
+if test "x$ac_cv_have_section_note_gnu_stack_in_arm_syntax" = "xyes"; then
+  AC_DEFINE([JITTER_HAVE_SECTION_NOTE_GNU_STACK_IN_ARM_SYNTAX], [1],
+            [Define if the platform supports a .note.GNU-stack section using
+             ARM assembly syntax for section prefixes instead of the syntax
+             that works for most architectures.])
+fi
+
 
 # Check for specific functions or "declarations" in the C library.
 ##################################################################
diff --git a/jitter/jitter-config.h.in b/jitter/jitter-config.h.in
index a8d01b8..0e6bfb4 100644
--- a/jitter/jitter-config.h.in
+++ b/jitter/jitter-config.h.in
@@ -2,6 +2,7 @@
 
    Copyright (C) 2017, 2019, 2020, 2021 Luca Saiu
    Updated in 2021 by pEp foundation (JITTER_HOST_OS_IS_ANDROID)
+   Updated in 2022 by Luca Saiu
    Written by Luca Saiu
 
    This file is part of GNU Jitter.
@@ -172,6 +173,7 @@
 #undef JITTER_HOST_OS_IS_COFF
 #undef JITTER_HOST_OS_IS_MACHO
 #undef JITTER_HAVE_SECTION_NOTE_GNU_STACK
+#undef JITTER_HAVE_SECTION_NOTE_GNU_STACK_IN_ARM_SYNTAX
 
 /* Assembler flavour. */
 #undef JITTER_HOST_ASSEMBLER_IS_GNU
diff --git a/jitter/jitter-machine-common.S b/jitter/jitter-machine-common.S
index 87309db..a693c03 100644
--- a/jitter/jitter-machine-common.S
+++ b/jitter/jitter-machine-common.S
@@ -1,6 +1,6 @@
 /* VM library: macros to be optionally included in architecture-specific asm.
 
-   Copyright (C) 2017, 2019 Luca Saiu
+   Copyright (C) 2017, 2019, 2022 Luca Saiu
    Updated in 2020 by Luca Saiu
    Written by Luca Saiu
 
@@ -48,7 +48,7 @@
 #include <jitter/jitter-cpp.h>
 
 
-/* Expand to nothing if we have no assembly support.
+/* Expand to nothing except stack executability if we have no assembly support.
  * ************************************************************************** */
 
 /* If in this configuration the assembler is not Gas or we do not know its
@@ -87,32 +87,6 @@
 #endif // #if JITTER_SIZEOF_VOID_P == ...
 
 
-
-
-/* Stack executability not required.
- * ************************************************************************** */
-
-/* Do not require an executable stack.  Jitter, or a Jittery VM runtime, never
-   directly relies on that.
-
-   Rationale: none of my assembly code relies on executable stacks, even if GCC
-   assumes, by default, that an assembly source file does.  Since this file is
-   included in every assembly source this is a good place to put this.  If some
-   other source linked to the Jitter runtime requires an executable stack then
-   the linked executable will have it, thanks to another
-     .section .note.GNU-stack, "x", @progbits
-   written somewhere else.
-   The Jitter runtime itself, along with every example in the distribution,
-   could easily be compiled and linked with
-     -Wa,--noexecstack -Wl,-z,noexecstack
-   , if there were nothing else. */
-#if defined (JITTER_HOST_OS_IS_ELF) \
-    && defined (JITTER_HAVE_SECTION_NOTE_GNU_STACK)
-.section .note.GNU-stack, "", @progbits
-.previous
-#endif // defined (JITTER_HOST_OS_IS_ELF) && ...
-
-
 
 
 /* Switching sections.
@@ -294,4 +268,45 @@ jitter_asm_exit_section
 
 #endif // #if defined (JITTER_HAVE_ASSEMBLY) && defined (JITTER_HAVE_KNOWN_BINARY_FORMAT)
 
+/* The large CPP conditional ends here: the rest is executed even on
+      ! defined (JITTER_HAVE_ASSEMBLY)                \
+      || ! defined (JITTER_HAVE_KNOWN_BINARY_FORMAT)
+   , becasue stack executability is in fact orthogonal to the rest. */
+
+
+
+
+/* Stack executability not required.
+ * ************************************************************************** */
+
+/* See the previous comment: this is included in every architecture, even if
+   complely unsupported. */
+
+
+/* Do not require an executable stack.  Jitter, or a Jittery VM runtime, never
+   directly relies on that.
+
+   Rationale: none of my assembly code relies on executable stacks, even if GCC
+   assumes, by default, that an assembly source file does.  Since this file is
+   included in every assembly source this is a good place to put this.  If some
+   other source linked to the Jitter runtime requires an executable stack then
+   the linked executable will have it, thanks to another
+     .section .note.GNU-stack, "x", @progbits
+   written somewhere else.
+   The Jitter runtime itself, along with every example in the distribution,
+   could easily be compiled and linked with
+     -Wa,--noexecstack -Wl,-z,noexecstack
+   , if there were nothing else. */
+#if defined (JITTER_HAVE_SECTION_NOTE_GNU_STACK)
+.section .note.GNU-stack, "", @progbits
+.text  /* back to the "previous" section.  .previous would be better, but
+          in practice this works and is more portable, since this code is
+          only included from a global context. */
+#elif defined (JITTER_HAVE_SECTION_NOTE_GNU_STACK_IN_ARM_SYNTAX)
+/* ARM uses % as the section-type prefix character, and '@' as a comment. */
+.section .note.GNU-stack, "", %progbits
+.text  /* See the comment about .text in the previous CPP conditional
+          branch. */
+#endif // defined (JITTER_HAVE_SECTION_NOTE_GNU_STACK)
+
 #endif // #ifndef MACHINE_COMMON_S_
-- 
2.37.2

