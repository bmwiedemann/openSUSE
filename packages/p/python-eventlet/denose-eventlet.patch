---
 eventlet.egg-info/SOURCES.txt |    3 
 setup.py                      |    2 
 tests/__init__.py             |    3 
 tests/dagpool_test.py         |  149 ++++++++++++++++++++----------------------
 tests/greenio_test.py         |    8 --
 tests/nosewrapper.py          |   13 ---
 6 files changed, 83 insertions(+), 95 deletions(-)

--- a/eventlet.egg-info/SOURCES.txt
+++ b/eventlet.egg-info/SOURCES.txt
@@ -175,7 +175,6 @@ tests/greenthread_test.py
 tests/hub_test.py
 tests/mock.py
 tests/mysqldb_test.py
-tests/nosewrapper.py
 tests/openssl_test.py
 tests/os_test.py
 tests/parse_results.py
@@ -275,4 +274,4 @@ tests/stdlib/test_threading_local.py
 tests/stdlib/test_timeout.py
 tests/stdlib/test_urllib.py
 tests/stdlib/test_urllib2.py
-tests/stdlib/test_urllib2_localnet.py
\ No newline at end of file
+tests/stdlib/test_urllib2_localnet.py
--- a/setup.py
+++ b/setup.py
@@ -30,7 +30,7 @@ setuptools.setup(
             'README.rst'
         )
     ).read(),
-    test_suite='nose.collector',
+    test_suite='tests',
     classifiers=[
         "Development Status :: 4 - Beta",
         "Intended Audience :: Developers",
--- a/tests/__init__.py
+++ b/tests/__init__.py
@@ -20,7 +20,7 @@ import sys
 import unittest
 import warnings
 
-from nose.plugins.skip import SkipTest
+from unittest import SkipTest
 
 import eventlet
 from eventlet import tpool
@@ -223,7 +223,6 @@ class LimitedTestCase(unittest.TestCase)
 def check_idle_cpu_usage(duration, allowed_part):
     if resource is None:
         # TODO: use https://code.google.com/p/psutil/
-        from nose.plugins.skip import SkipTest
         raise SkipTest('CPU usage testing not supported (`import resource` failed)')
 
     r1 = resource.getrusage(resource.RUSAGE_SELF)
--- a/tests/dagpool_test.py
+++ b/tests/dagpool_test.py
@@ -5,7 +5,6 @@
 @brief  Test DAGPool class
 """
 
-from nose.tools import *
 import eventlet
 from eventlet.dagpool import DAGPool, Collision, PropagateError
 import six
@@ -13,8 +12,8 @@ from contextlib import contextmanager
 import itertools
 
 
-# Not all versions of nose.tools.assert_raises() support the usage in this
-# module, but it's straightforward enough to code that explicitly.
+# Not all versions of assert_raises() support the usage in this module,
+# but it's straightforward enough to code that explicitly.
 @contextmanager
 def assert_raises(exc):
     """exc is an exception class"""
@@ -163,7 +162,7 @@ class Capture(object):
                     # a set. Make a set containing its elements.
                     setlist.append(set(subseq))
         # Now that we've massaged 'sequence' into 'setlist', compare.
-        assert_equal(self.sequence, setlist)
+        assert self.sequence == setlist
 
 
 # ****************************************************************************
@@ -191,14 +190,14 @@ def test_init():
         with check_no_suspend():
             results = pool.waitall()
         # with no spawn() or post(), waitall() returns preload data
-        assert_equals(results, dict(a=1, b=2, c=3))
+        assert results == dict(a=1, b=2, c=3)
 
         # preload sequence of pairs
         pool = DAGPool([("d", 4), ("e", 5), ("f", 6)])
         # this must not hang
         with check_no_suspend():
             results = pool.waitall()
-        assert_equals(results, dict(d=4, e=5, f=6))
+        assert results == dict(d=4, e=5, f=6)
 
 
 def test_wait_each_empty():
@@ -216,10 +215,10 @@ def test_wait_each_preload():
         with check_no_suspend():
             # wait_each() may deliver in arbitrary order; collect into a dict
             # for comparison
-            assert_equals(dict(pool.wait_each("abc")), dict(a=1, b=2, c=3))
+            assert dict(pool.wait_each("abc")) == dict(a=1, b=2, c=3)
 
             # while we're at it, test wait() for preloaded keys
-            assert_equals(pool.wait("bc"), dict(b=2, c=3))
+            assert pool.wait("bc") == dict(b=2, c=3)
 
 
 def post_each(pool, capture):
@@ -257,7 +256,7 @@ def test_wait_posted():
     eventlet.spawn(post_each, pool, capture)
     gotten = pool.wait("bcdefg")
     capture.add("got all")
-    assert_equals(gotten,
+    assert (gotten ==
                   dict(b=2, c=3,
                        d="dval", e="eval",
                        f="fval", g="gval"))
@@ -285,7 +284,7 @@ def test_spawn_collision_spawn():
     pool = DAGPool()
     pool.spawn("a", (), lambda key, results: "aval")
     # hasn't yet even started
-    assert_equals(pool.get("a"), None)
+    assert pool.get("a") == None
     with assert_raises(Collision):
         # Attempting to spawn again with same key should collide even if the
         # first spawned greenthread hasn't yet had a chance to run.
@@ -293,7 +292,7 @@ def test_spawn_collision_spawn():
     # now let the spawned eventlet run
     eventlet.sleep(0)
     # should have finished
-    assert_equals(pool.get("a"), "aval")
+    assert pool.get("a") == "aval"
     with assert_raises(Collision):
         # Attempting to spawn with same key collides even when the greenthread
         # has completed.
@@ -324,60 +323,60 @@ def test_spawn_multiple():
     capture.step()
     # but none of them has yet produced a result
     for k in "defgh":
-        assert_equals(pool.get(k), None)
-    assert_equals(set(pool.keys()), set("abc"))
-    assert_equals(dict(pool.items()), dict(a=1, b=2, c=3))
-    assert_equals(pool.running(), 5)
-    assert_equals(set(pool.running_keys()), set("defgh"))
-    assert_equals(pool.waiting(), 1)
-    assert_equals(pool.waiting_for(), dict(h=set("defg")))
-    assert_equals(pool.waiting_for("d"), set())
-    assert_equals(pool.waiting_for("c"), set())
+        assert pool.get(k) == None
+    assert set(pool.keys()) == set("abc")
+    assert dict(pool.items()) == dict(a=1, b=2, c=3)
+    assert pool.running() == 5
+    assert set(pool.running_keys()) == set("defgh")
+    assert pool.waiting() == 1
+    assert pool.waiting_for() == dict(h=set("defg"))
+    assert pool.waiting_for("d") == set()
+    assert pool.waiting_for("c") == set()
     with assert_raises(KeyError):
         pool.waiting_for("j")
-    assert_equals(pool.waiting_for("h"), set("defg"))
+    assert pool.waiting_for("h") == set("defg")
 
     # let one of the upstream greenthreads complete
     events["f"].send("fval")
     spin()
     capture.step()
-    assert_equals(pool.get("f"), "fval")
-    assert_equals(set(pool.keys()), set("abcf"))
-    assert_equals(dict(pool.items()), dict(a=1, b=2, c=3, f="fval"))
-    assert_equals(pool.running(), 4)
-    assert_equals(set(pool.running_keys()), set("degh"))
-    assert_equals(pool.waiting(), 1)
-    assert_equals(pool.waiting_for("h"), set("deg"))
+    assert pool.get("f") == "fval"
+    assert set(pool.keys()) == set("abcf")
+    assert dict(pool.items()) == dict(a=1, b=2, c=3, f="fval")
+    assert pool.running() == 4
+    assert set(pool.running_keys()) == set("degh")
+    assert pool.waiting() == 1
+    assert pool.waiting_for("h") == set("deg")
 
     # now two others
     events["e"].send("eval")
     events["g"].send("gval")
     spin()
     capture.step()
-    assert_equals(pool.get("e"), "eval")
-    assert_equals(pool.get("g"), "gval")
-    assert_equals(set(pool.keys()), set("abcefg"))
-    assert_equals(dict(pool.items()),
+    assert pool.get("e") == "eval"
+    assert pool.get("g") == "gval"
+    assert set(pool.keys()) == set("abcefg")
+    assert (dict(pool.items()) ==
                   dict(a=1, b=2, c=3, e="eval", f="fval", g="gval"))
-    assert_equals(pool.running(), 2)
-    assert_equals(set(pool.running_keys()), set("dh"))
-    assert_equals(pool.waiting(), 1)
-    assert_equals(pool.waiting_for("h"), set("d"))
+    assert pool.running() == 2
+    assert set(pool.running_keys()) == set("dh")
+    assert pool.waiting() == 1
+    assert pool.waiting_for("h") == set("d")
 
     # last one
     events["d"].send("dval")
     # make sure both pool greenthreads get a chance to run
     spin()
     capture.step()
-    assert_equals(pool.get("d"), "dval")
-    assert_equals(set(pool.keys()), set("abcdefgh"))
-    assert_equals(dict(pool.items()),
+    assert pool.get("d") == "dval"
+    assert set(pool.keys()) == set("abcdefgh")
+    assert (dict(pool.items()) ==
                   dict(a=1, b=2, c=3,
                        d="dval", e="eval", f="fval", g="gval", h="hval"))
-    assert_equals(pool.running(), 0)
-    assert_false(pool.running_keys())
-    assert_equals(pool.waiting(), 0)
-    assert_equals(pool.waiting_for("h"), set())
+    assert pool.running() == 0
+    assert not pool.running_keys()
+    assert pool.waiting() == 0
+    assert pool.waiting_for("h") == set()
 
     capture.validate([
         ["h got b", "h got c"],
@@ -432,13 +431,13 @@ def test_spawn_many():
     spin()
     # verify that e completed (also that post(key) within greenthread
     # overrides implicit post of return value, which would be None)
-    assert_equals(pool.get("e"), "e")
+    assert pool.get("e") == "e"
 
     # With the dependency graph shown above, it is not guaranteed whether b or
     # c will complete first. Handle either case.
     sequence = capture.sequence[:]
     sequence[1:3] = [set([sequence[1].pop(), sequence[2].pop()])]
-    assert_equals(sequence,
+    assert (sequence ==
                   [set(["a done"]),
                    set(["b done", "c done"]),
                    set(["d done"]),
@@ -466,7 +465,7 @@ def test_wait_each_all():
     for pos in range(len(keys)):
         # next value from wait_each()
         k, v = next(each)
-        assert_equals(k, keys[pos])
+        assert k == keys[pos]
         # advance every pool greenlet as far as it can go
         spin()
         # everything from keys[:pos+1] should have a value by now
@@ -494,7 +493,7 @@ def test_kill():
     pool.kill("a")
     # didn't run
     spin()
-    assert_equals(pool.get("a"), None)
+    assert pool.get("a") == None
     # killing it forgets about it
     with assert_raises(KeyError):
         pool.kill("a")
@@ -505,7 +504,7 @@ def test_kill():
     with assert_raises(KeyError):
         pool.kill("a")
     # verify it ran to completion
-    assert_equals(pool.get("a"), 2)
+    assert pool.get("a") == 2
 
 
 def test_post_collision_preload():
@@ -533,7 +532,7 @@ def test_post_collision_spawn():
     pool.kill("a")
     # now we can post
     pool.post("a", 3)
-    assert_equals(pool.get("a"), 3)
+    assert pool.get("a") == 3
 
     pool = DAGPool()
     pool.spawn("a", (), lambda key, result: 4)
@@ -553,10 +552,10 @@ def test_post_replace():
     pool = DAGPool()
     pool.post("a", 1)
     pool.post("a", 2, replace=True)
-    assert_equals(pool.get("a"), 2)
-    assert_equals(dict(pool.wait_each("a")), dict(a=2))
-    assert_equals(pool.wait("a"), dict(a=2))
-    assert_equals(pool["a"], 2)
+    assert pool.get("a") == 2
+    assert dict(pool.wait_each("a")) == dict(a=2)
+    assert pool.wait("a") == dict(a=2)
+    assert pool["a"] == 2
 
 
 def waitfor(capture, pool, key):
@@ -598,14 +597,14 @@ def test_waitall_exc():
     try:
         pool.waitall()
     except PropagateError as err:
-        assert_equals(err.key, "a")
+        assert err.key == "a"
         assert isinstance(err.exc, BogusError), \
             "exc attribute is {0}, not BogusError".format(err.exc)
-        assert_equals(str(err.exc), "bogus")
+        assert str(err.exc) == "bogus"
         msg = str(err)
-        assert_in("PropagateError(a)", msg)
-        assert_in("BogusError", msg)
-        assert_in("bogus", msg)
+        assert "PropagateError(a)" in msg
+        assert "BogusError" in msg
+        assert "bogus" in msg
 
 
 def test_propagate_exc():
@@ -616,20 +615,20 @@ def test_propagate_exc():
     try:
         pool["c"]
     except PropagateError as errc:
-        assert_equals(errc.key, "c")
+        assert errc.key == "c"
         errb = errc.exc
-        assert_equals(errb.key, "b")
+        assert errb.key == "b"
         erra = errb.exc
-        assert_equals(erra.key, "a")
+        assert erra.key == "a"
         assert isinstance(erra.exc, BogusError), \
             "exc attribute is {0}, not BogusError".format(erra.exc)
-        assert_equals(str(erra.exc), "bogus")
+        assert str(erra.exc) == "bogus"
         msg = str(errc)
-        assert_in("PropagateError(a)", msg)
-        assert_in("PropagateError(b)", msg)
-        assert_in("PropagateError(c)", msg)
-        assert_in("BogusError", msg)
-        assert_in("bogus", msg)
+        assert "PropagateError(a)" in msg
+        assert "PropagateError(b)" in msg
+        assert "PropagateError(c)" in msg
+        assert "BogusError" in msg
+        assert "bogus" in msg
 
 
 def test_wait_each_exc():
@@ -681,13 +680,13 @@ def test_post_get_exc():
             pass
 
     # wait_each_success() filters
-    assert_equals(dict(pool.wait_each_success()), dict(a=bogua))
-    assert_equals(dict(pool.wait_each_success("ab")), dict(a=bogua))
-    assert_equals(dict(pool.wait_each_success("a")), dict(a=bogua))
-    assert_equals(dict(pool.wait_each_success("b")), {})
+    assert dict(pool.wait_each_success()) == dict(a=bogua)
+    assert dict(pool.wait_each_success("ab")) == dict(a=bogua)
+    assert dict(pool.wait_each_success("a")) == dict(a=bogua)
+    assert dict(pool.wait_each_success("b")) == {}
 
     # wait_each_exception() filters the other way
-    assert_equals(dict(pool.wait_each_exception()), dict(b=bogub))
-    assert_equals(dict(pool.wait_each_exception("ab")), dict(b=bogub))
-    assert_equals(dict(pool.wait_each_exception("a")), {})
-    assert_equals(dict(pool.wait_each_exception("b")), dict(b=bogub))
+    assert dict(pool.wait_each_exception()) == dict(b=bogub)
+    assert dict(pool.wait_each_exception("ab")) == dict(b=bogub)
+    assert dict(pool.wait_each_exception("a")) == {}
+    assert dict(pool.wait_each_exception("b")) == dict(b=bogub)
--- a/tests/greenio_test.py
+++ b/tests/greenio_test.py
@@ -9,8 +9,6 @@ import socket as _orig_sock
 import sys
 import tempfile
 
-from nose.tools import eq_
-
 import eventlet
 from eventlet import event, greenio, debug
 from eventlet.hubs import get_hub
@@ -39,7 +37,7 @@ def expect_socket_timeout(function, *arg
         raise AssertionError("socket.timeout not raised")
     except socket.timeout as e:
         assert hasattr(e, 'args')
-        eq_(e.args[0], 'timed out')
+        assert e.args[0] == 'timed out'
 
 
 def min_buf_size():
@@ -674,8 +672,8 @@ class TestGreenSocket(tests.LimitedTestC
         sender.sendto(b'second', 0, address)
 
         sender_address = ('127.0.0.1', sender.getsockname()[1])
-        eq_(receiver.recvfrom(1024), (b'first', sender_address))
-        eq_(receiver.recvfrom(1024), (b'second', sender_address))
+        assert receiver.recvfrom(1024) == (b'first', sender_address)
+        assert receiver.recvfrom(1024) == (b'second', sender_address)
 
 
 def test_get_fileno_of_a_socket_works():
--- a/tests/nosewrapper.py
+++ b/tests/nosewrapper.py
@@ -1,20 +1,13 @@
 """ This script simply gets the paths correct for testing eventlet with the
 hub extension for Nose."""
-import nose
 from os.path import dirname, realpath, abspath
 import sys
+import unittest
 
 
 parent_dir = dirname(dirname(realpath(abspath(__file__))))
 if parent_dir not in sys.path:
     sys.path.insert(0, parent_dir)
 
-# hudson does a better job printing the test results if the exit value is 0
-zero_status = '--force-zero-status'
-if zero_status in sys.argv:
-    sys.argv.remove(zero_status)
-    launch = nose.run
-else:
-    launch = nose.main
-
-launch(argv=sys.argv)
+if __name__ == '__main__':
+    unittest.main()
