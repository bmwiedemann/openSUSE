---
 setup.cfg                                        |    2 
 setup.py                                         |   68 ++++-----
 source_py2/combi/_python_toolbox/cute_testing.py |   38 ++---
 source_py2/test_combi/__init__.py                |   16 +-
 source_py2/test_combi/test_extensive.py          |  156 +++++++++++-----------
 source_py3/combi/_python_toolbox/cute_testing.py |   42 +++---
 source_py3/test_combi/__init__.py                |   16 +-
 source_py3/test_combi/test_extensive.py          |  158 +++++++++++------------
 8 files changed, 247 insertions(+), 249 deletions(-)

--- a/setup.cfg
+++ b/setup.cfg
@@ -7,7 +7,7 @@ detailed-errors=1
 
 with-xunit=1
 
-cover-erase=1 
+cover-erase=1
 cover-package=combi,test_combi
 cover-branches=1
 cover-html-dir=../.coverage_html_report
--- a/setup.py
+++ b/setup.py
@@ -35,11 +35,11 @@ else:
 def get_combi_packages():
     '''
     Get all the packages in `combi`.
-    
+
     Returns something like:
-    
+
         ['combi', 'combi.perming', ... ]
-        
+
     '''
     return ['combi.' + p for p in
             setuptools.find_packages('%s/combi' % source_folder)] + \
@@ -49,11 +49,11 @@ def get_combi_packages():
 def get_test_combi_packages():
     '''
     Get all the packages in `test_combi`.
-    
+
     Returns something like:
-    
+
         ['test_combi', 'test_combi.test_whatever', ... ]
-        
+
     '''
     return ['test_combi.' + p for p in
             setuptools.find_packages('%s/test_combi' % source_folder)] + \
@@ -63,11 +63,11 @@ def get_test_combi_packages():
 def get_packages():
     '''
     Get all the packages in `combi` and `test_combi`.
-    
+
     Returns something like:
-    
+
         ['test_combi', 'combi', 'combi.perming', ... ]
-        
+
     '''
     return get_combi_packages() + get_test_combi_packages()
 
@@ -98,7 +98,7 @@ Use `PermSpace`_ to create a permutation
 
    >>> from combi import *
    >>> perm_space = PermSpace('meow')
-   
+
 It behaves like a sequence:
 
 .. code:: python
@@ -109,7 +109,7 @@ It behaves like a sequence:
    <Perm: ('e', 'm', 'w', 'o')>
    >>> perm_space.index('mowe')
    3
-   
+
 And yet the permutations are created on-demand rather than in advance.
 
 Use `CombSpace`_ to create a combination space, where order doesn't
@@ -132,43 +132,43 @@ Features
 
 - `PermSpace`_ lets you explore a space of permutations as if it was a
   Python sequence.
-  
-  * Permutations are generated on-demand, so huge permutation spaces can be 
+
+  * Permutations are generated on-demand, so huge permutation spaces can be
     created easily without big memory footprint.
-  * `PermSpace`_ will notice if you have repeating elements in your sequence, 
-    and treat all occurences of the same value as interchangable rather than 
+  * `PermSpace`_ will notice if you have repeating elements in your sequence,
+    and treat all occurences of the same value as interchangable rather than
     create redundant permutations.
   * A custom domain can be specified instead of just using index numbers.
   * You may specify some elements to be fixed, so they'll point to the same
-    value in all permutations. (Useful for limiting an experiment to a subset 
+    value in all permutations. (Useful for limiting an experiment to a subset
     of the original permutation space.)
   * Permutation spaces may be limited to a certain degree of permutations. (A
     permutation's degree is the number of transformations it takes to make it.)
   * `k-permutations`_ are supported.
-  * You may specify a custom type for the generated permutations, so you could 
+  * You may specify a custom type for the generated permutations, so you could
     implement your own functionality on them.
-    
+
 - `CombSpace`_ lets you explore a space of combinations as if it was a
   Python sequence.
-  
+
 - `MapSpace`_ is like Python's built-in `map`_, except it's a
   sequence that allows index access.
-  
+
 - `ProductSpace`_ is like Python's `itertools.product`_, except
   it's a sequence that allows index access.
-  
+
 - `ChainSpace`_ is like Python's `itertools.chain`_, except
   it's a sequence that allows index access.
-  
+
 - `SelectionSpace`_ is a space of all selections from a sequence, of all
   possible lengths.
-  
-- The `Bag`_ class is a multiset like Python's `collections.Counter`_, except 
-  it offers far more functionality, like more `arithmetic operations between 
-  bags`_, `comparison between bags`_, and more. (It can do that because unlike 
+
+- The `Bag`_ class is a multiset like Python's `collections.Counter`_, except
+  it offers far more functionality, like more `arithmetic operations between
+  bags`_, `comparison between bags`_, and more. (It can do that because unlike
   Python's `collections.Counter`_, it only allows natural numbers as keys.)
-  
-- Classes `FrozenBag`_, `OrderedBag`_ and `FrozenOrderedBag`_ are provided, 
+
+- Classes `FrozenBag`_, `OrderedBag`_ and `FrozenOrderedBag`_ are provided,
   which are variations on `Bag`_.
 
 
@@ -177,7 +177,7 @@ Requirements
 
 * Python, version 2.6, 2.7 or 3.3 or above. If you're new to Python, `download
   the newest version from here <http://python.org/download>`_.
- 
+
 * `Setuptools`_.
 
 
@@ -247,9 +247,9 @@ Combi was created by Ram Rachum. I provi
 
 my_classifiers = [
     'Development Status :: 3 - Alpha',
-    'Intended Audience :: Developers', 
+    'Intended Audience :: Developers',
     'License :: OSI Approved :: MIT License',
-    'Operating System :: OS Independent', 
+    'Operating System :: OS Independent',
     'Programming Language :: Python',
     'Programming Language :: Python :: 2.6',
     'Programming Language :: Python :: 2.7',
@@ -261,7 +261,7 @@ my_classifiers = [
 
 
 install_requires = ['setuptools']
-    
+
 
 setuptools.setup(
     name='combi',
@@ -273,13 +273,13 @@ setuptools.setup(
     description='A Pythonic package for combinatorics',
     author='Ram Rachum',
     author_email='ram@rachum.com',
-    package_dir={'': source_folder}, 
+    package_dir={'': source_folder},
     packages=get_packages(),
     entry_points={
         'console_scripts': [
             '_test_combi = test_combi:invoke_nose',
         ],
-    }, 
+    },
     long_description=my_long_description,
     license='MIT',
     classifiers=my_classifiers,
--- a/source_py2/combi/_python_toolbox/cute_testing.py
+++ b/source_py2/combi/_python_toolbox/cute_testing.py
@@ -25,19 +25,19 @@ class RaiseAssertor(context_management.C
     Asserts that a certain exception was raised in the suite. You may use a
     snippet of text that must appear in the exception message or a regex that
     the exception message must match.
-    
+
     Example:
-    
+
         with RaiseAssertor(ZeroDivisionError, 'modulo by zero'):
             1/0
-    
+
     '''
-    
+
     def __init__(self, exception_type=Exception, text='',
                  assert_exact_type=False):
         '''
         Construct the `RaiseAssertor`.
-        
+
         `exception_type` is an exception type that the exception must be of;
         `text` may be either a snippet of text that must appear in the
         exception's message, or a regex pattern that the exception message must
@@ -47,22 +47,22 @@ class RaiseAssertor(context_management.C
         '''
         self.exception_type = exception_type
         '''The type of exception that should be raised.'''
-        
+
         self.text = text
         '''The snippet or regex that the exception message must match.'''
-        
+
         self.exception = None
         '''The exception that was caught.'''
-        
+
         self.assert_exact_type = assert_exact_type
         '''
         Flag saying whether we require an exact match to `exception_type`.
-        
+
         If set to `False`, a subclass of `exception_type` will also be
         acceptable.
         '''
-        
-        
+
+
     def manage_context(self):
         '''Manage the `RaiseAssertor'`s context.'''
         try:
@@ -106,23 +106,23 @@ class RaiseAssertor(context_management.C
         else:
             raise Failure("%s wasn't raised." % self.exception_type.__name__)
 
-                    
+
 def assert_same_signature(*callables):
     '''Assert that all the `callables` have the same function signature.'''
     arg_specs = [cute_inspect.getargspec(callable_) for callable_ in callables]
     if not logic_tools.all_equivalent(arg_specs, assume_transitive=False):
         raise Failure('Not all the callables have the same signature.')
-    
-    
+
+
 class _MissingAttribute(object):
     '''Object signifying that an attribute was not found.'''
     # todo: make uninstanciable
 
-    
+
 def assert_polite_wrapper(wrapper, wrapped=None, same_signature=True):
     '''
     Assert that `wrapper` is a polite function wrapper around `wrapped`.
-    
+
     A function wrapper (usually created by a decorator) has a few
     responsibilties; maintain the same name, signature, documentation etc. of
     the original function, and a few others. Here we check that the wrapper did
@@ -139,18 +139,16 @@ def assert_polite_wrapper(wrapper, wrapp
         assert (getattr(wrapper, attribute, None) or _MissingAttribute) == \
                (getattr(wrapped, attribute,  None) or _MissingAttribute)
     assert wrapper.__wrapped__ == wrapped
-        
+
 class TestCase(unittest2.TestCase, context_management.ContextManager):
     setUp = misc_tools.ProxyProperty('.setup')
     tearDown = misc_tools.ProxyProperty('.tear_down')
     def manage_context(self):
         yield self
-        
+
     def setup(self):
         return self.__enter__()
     def tear_down(self):
         # todo: Should probably do something with exception-swallowing here to
         # abide with the context manager protocol, but I don't need it yet.
         return self.__exit__(*sys.exc_info())
-        
-        
\ No newline at end of file
--- a/source_py2/test_combi/__init__.py
+++ b/source_py2/test_combi/__init__.py
@@ -18,7 +18,7 @@ if nose.__versioninfo__ < (1, 0, 0):
 def __bootstrap():
     '''
     Add needed packages in repo to path if we can't find them.
-    
+
     This adds `combi`'s root folder to `sys.path` if it can't
     currently be imported.
     '''
@@ -29,11 +29,11 @@ def __bootstrap():
     def exists(module_name):
         '''
         Return whether a module by the name `module_name` exists.
-        
+
         This seems to be the best way to carefully import a module.
-        
+
         Currently implemented for top-level packages only. (i.e. no dots.)
-    
+
         Doesn't support modules imported from a zip file.
         '''
         assert '.' not in module_name
@@ -43,16 +43,16 @@ def __bootstrap():
             return False
         else:
             return True
-    
+
     if not exists('combi'):
         combi_candidate_path = pathlib(__file__).parent.parent.absolute()
         sys.path.append(combi_candidate_path)
-        
-        
+
+
 __bootstrap()
 
 
-_default_nose_arguments = [   
+_default_nose_arguments = [
     '--verbosity=3',
     '--detailed-errors',
     '--with-xunit',
--- a/source_py2/test_combi/test_extensive.py
+++ b/source_py2/test_combi/test_extensive.py
@@ -24,23 +24,23 @@ infinities = (infinity, -infinity)
 
 class _NO_ARGUMENT_TYPE(type):
     __repr__ = lambda cls: '<%s>' % cls.__name__
-        
+
 
 class NO_ARGUMENT(object):
     __metaclass__ = _NO_ARGUMENT_TYPE
-        
+
 
 
 class BrutePermSpace(object):
     '''
     A `PermSpace` substitute used for testing `PermSpace`.
-    
+
     This class is used for comparing with `PermSpace` in tests and ensuring it
     produces the same results. The reason we have high confidence that
     `BrutePermSpace` itself produces true results is because it's
     implementation is much simpler than `PermSpace`'s, which is because it
     doesn't need to be efficient, because it's only used for tests.
-    
+
     `BrutePermSpace` takes the some signature of arguments used for
     `PermSpace`, though it's not guaranteed to be able to deal with all the
     kinds of arguments that `PermSpace` would take.
@@ -64,21 +64,21 @@ class BrutePermSpace(object):
         self.degrees = \
                       degrees or sequence_tools.CuteRange(self.sequence_length)
         self.is_combination = is_combination
-        
+
         self.is_degreed = (self.degrees !=
                                 sequence_tools.CuteRange(self.sequence_length))
-        
+
         self.slice_ = slice_
- 
+
         if perm_type is None:
             self.perm_type = tuple
             self.is_typed = False
         else:
             self.perm_type = FruityTuple
             self.is_typed = True
-        
-        
-        
+
+
+
     def __iter__(self):
         if (self.is_recurrent and self.is_combination):
             def make_iterator():
@@ -98,7 +98,7 @@ class BrutePermSpace(object):
                                     self.slice_.stop)
         else:
             return iterator
-        
+
     def _iter(self):
         yielded_candidates = set()
         for candidate in itertools.permutations(self.sequence, self.n_elements):
@@ -123,24 +123,24 @@ class BrutePermSpace(object):
                 n_cycles = 0
                 while unvisited_items:
                     starting_item = current_item = next(iter(unvisited_items))
-                    
+
                     while current_item in unvisited_items:
                         unvisited_items.remove(current_item)
                         current_item = self.sequence.index(
                             candidate[current_item]
                         )
-                        
+
                     if current_item == starting_item:
                         n_cycles += 1
-                        
+
                 degree = self.sequence_length - n_cycles
-                
+
                 if degree not in self.degrees:
                     continue
-                
+
             yielded_candidates.add(candidate)
             yield candidate
-                
+
 
 
 class FruityMixin(object): pass
@@ -155,24 +155,24 @@ def _check_variation_selection(variation
     assert isinstance(variation_selection,
                       combi.perming.variations.VariationSelection)
     kwargs = {}
-    
+
     iterable_or_length, sequence = iterable_or_length_and_sequence
-    
+
     kwargs['iterable_or_length'] = iterable_or_length
     sequence_set = set(sequence)
-    
+
     if domain_to_cut != NO_ARGUMENT:
         kwargs['domain'] = actual_domain = domain_to_cut[:len(sequence)]
     else:
         actual_domain = sequence_tools.CuteRange(len(sequence))
-        
+
     if n_elements != NO_ARGUMENT:
         kwargs['n_elements'] = n_elements
     actual_n_elements = n_elements if (n_elements != NO_ARGUMENT) else 0
-        
+
     if is_combination != NO_ARGUMENT:
         kwargs['is_combination'] = is_combination
-        
+
     if purified_fixed_map != NO_ARGUMENT:
         kwargs['fixed_map'] = actual_fixed_map = dict(
             (actual_domain[key], sequence[value]) for key, value
@@ -180,10 +180,10 @@ def _check_variation_selection(variation
         )
     else:
         actual_fixed_map = {}
-        
+
     if variation_selection.is_degreed:
         kwargs['degrees'] = degrees = (0, 2, 4, 5)
-        
+
     if perm_type != NO_ARGUMENT:
         kwargs['perm_type'] = perm_type
 
@@ -194,51 +194,51 @@ def _check_variation_selection(variation
             return
         else:
             raise
-        
+
     if slice_ != NO_ARGUMENT:
         perm_space = perm_space[slice_]
-        
+
     else:
         if not variation_selection.is_allowed:
             raise TypeError(
                 "Shouldn't have allowed this `VariationSelection.`"
             )
-    
+
     brute_perm_space = BrutePermSpace(
         slice_=(perm_space.canonical_slice if variation_selection.is_sliced else
-                None), 
+                None),
         **kwargs
     )
     assert perm_space.variation_selection == variation_selection
     assert perm_space.sequence_length == len(sequence)
-    
+
     assert (perm_space.domain == perm_space.sequence) == (
         not variation_selection.is_dapplied and
         not variation_selection.is_rapplied and
         not variation_selection.is_partial
     )
-    
+
     if perm_space.length:
         assert perm_space.index(perm_space[-1]) == perm_space.length - 1
         assert perm_space.index(perm_space[0]) == 0
-        
+
     if variation_selection.is_partial:
         assert 0 < perm_space.n_unused_elements == \
                                               len(sequence) - actual_n_elements
     else:
         assert perm_space.n_unused_elements == 0
-        
+
     assert perm_space == PermSpace(**kwargs)[perm_space.canonical_slice]
     assert (not perm_space != PermSpace(**kwargs)[perm_space.canonical_slice])
     assert hash(perm_space) == \
                           hash(PermSpace(**kwargs)[perm_space.canonical_slice])
-    
+
     typed_perm_space = perm_space.get_typed(FruityComb if
                             variation_selection.is_combination else FruityPerm)
     assert typed_perm_space.is_typed
     assert variation_selection.is_typed is perm_space.is_typed is \
          (perm_space != perm_space.untyped) is (perm_space == typed_perm_space)
-    
+
 
     if perm_space.is_sliced and perm_space.length >= 2:
         assert perm_space[0] == perm_space.unsliced[2]
@@ -251,23 +251,23 @@ def _check_variation_selection(variation
         assert perm_space.unsliced[-1] not in perm_space
         assert perm_space.unsliced[-2] not in perm_space
         assert perm_space.unsliced[-3] in perm_space
-        
+
     if perm_space:
         # Making sure that `brute_perm_space` isn't empty:
         next(iter(brute_perm_space))
         # This is crucial otherwise the zip-based loop below won't run and
         # we'll get the illusion that the tests are running while they're
         # really not.
-    
+
     for i, (perm, brute_perm_tuple) in enumerate(
            itertools.islice(itertools.izip(perm_space, brute_perm_space), 10)):
-        
+
         assert tuple(perm) == brute_perm_tuple
         assert perm in perm_space
         assert tuple(perm) in perm_space
         assert iter(list(perm)) in perm_space
         assert set(perm) not in perm_space
-        
+
         assert isinstance(perm, combi.Perm)
         assert perm.is_rapplied == variation_selection.is_rapplied
         assert perm.is_dapplied == variation_selection.is_dapplied
@@ -277,9 +277,9 @@ def _check_variation_selection(variation
                                      variation_selection.is_dapplied or
                                      variation_selection.is_partial or
                                      variation_selection.is_combination))
-        
+
         assert isinstance(perm, FruityMixin) is variation_selection.is_typed
-        
+
         if variation_selection.is_rapplied:
             assert perm != perm.unrapplied
             if not variation_selection.is_recurrent:
@@ -293,13 +293,13 @@ def _check_variation_selection(variation
                 assert tuple(sample_domain * perm) == tuple(
                     perm_space.get_rapplied(sample_domain)[i]._perm_sequence
                 )
-            
-        
+
+
         if variation_selection.is_dapplied:
             assert perm != perm.undapplied == perm_space.undapplied[i]
         else:
             assert perm == perm.undapplied == perm_space.undapplied[i]
-            
+
         if variation_selection.is_combination:
             if variation_selection.is_typed:
                 with cute_testing.RaiseAssertor(TypeError):
@@ -308,7 +308,7 @@ def _check_variation_selection(variation
                 assert perm != perm.uncombinationed
         else:
             assert perm == perm.uncombinationed
-        
+
         if variation_selection.is_combination:
             if variation_selection.is_typed:
                 assert type(perm) == FruityComb
@@ -319,7 +319,7 @@ def _check_variation_selection(variation
                 assert type(perm) == FruityPerm
             else:
                 assert type(perm) == Perm
-        
+
         if variation_selection.variations <= set((
             perming.variations.Variation.DAPPLIED,
             perming.variations.Variation.RAPPLIED,
@@ -329,14 +329,14 @@ def _check_variation_selection(variation
                                    perm_space._nominal_perm_space_of_perms == \
                                           perm_space.unsliced.undegreed.unfixed
         # Give me your unsliced, your undegreed, your unfixed.
-        
+
         if not variation_selection.is_fixed and \
                                             not variation_selection.is_degreed:
             assert perm_space.index(perm) == i
-            
+
         assert type(perm)(iter(perm), perm_space=perm_space) == perm
         assert type(perm)(perm._perm_sequence, perm_space=perm_space) == perm
-        
+
         assert perm.length == perm_space.n_elements
         if variation_selection.is_partial or variation_selection.is_rapplied \
                                             or variation_selection.is_dapplied:
@@ -353,7 +353,7 @@ def _check_variation_selection(variation
                                                      perm.nominal_perm_space[0]
             assert isinstance(perm ** 4, Perm)
             assert isinstance(perm ** -7, Perm)
-            
+
         perm_set = set(perm)
         if variation_selection.is_partial:
             assert len(perm) == actual_n_elements
@@ -365,7 +365,7 @@ def _check_variation_selection(variation
         else:
             assert perm_set == sequence_set
             assert len(perm) == len(sequence)
-            
+
         for j, (value, key, (key__, value__)) in enumerate(
                                        zip(perm, perm.as_dictoid, perm.items)):
             assert key == key__
@@ -376,15 +376,15 @@ def _check_variation_selection(variation
             assert perm[key] == value
             assert key in perm.domain
             assert value in perm
-            
+
         if variation_selection.is_degreed:
             assert perm.degree == degrees or perm.degree in degrees
         elif variation_selection.is_partial:
             assert perm.degree == NotImplemented
         else:
             assert 0 <= perm.degree <= len(sequence)
-            
-        
+
+
         ### Testing neighbors: ################################################
         #                                                                     #
         if variation_selection.is_combination or \
@@ -403,29 +403,29 @@ def _check_variation_selection(variation
                     # there aren't any neighbors.)
                     assert neighbors
                 for neigbhor in itertools.islice(neighbors, 0, 10):
-                    assert neigbhor in perm_space 
+                    assert neigbhor in perm_space
                     assert len(cute_iter_tools.zip_non_equal((perm, neigbhor),
                                                          lazy_tuple=True)) == 2
-        
+
         #                                                                     #
         ### Finished testing neighbors. #######################################
-        
+
         perm_repr = repr(perm)
-        
-        
+
+
 def _iterate_tests():
     for variation_selection in \
                             combi.perming.variations.variation_selection_space:
-        
+
         kwargs = {}
-        
+
         if variation_selection.is_recurrent and \
                                            not variation_selection.is_rapplied:
             assert not variation_selection.is_allowed
             # Can't even test this illogical clash.
             continue
-            
-        
+
+
         if variation_selection.is_recurrent:
             iterable_or_length_and_sequence_options = (
                 ('abracab', 'abracab'),
@@ -435,14 +435,14 @@ def _iterate_tests():
         elif variation_selection.is_rapplied:
             iterable_or_length_and_sequence_options = (
                 ([1, 4, 2, 5, 3, 7],
-                 (1, 4, 2, 5, 3, 7)), 
+                 (1, 4, 2, 5, 3, 7)),
             )
         else:
             iterable_or_length_and_sequence_options = (
                 (7, sequence_tools.CuteRange(7)),
                 (sequence_tools.CuteRange(9), sequence_tools.CuteRange(9))
             )
-        
+
         if variation_selection.is_dapplied:
             domain_to_cut_options = (
                 'QPONMLKJIHGFEDCBAZYXWVUTSR',
@@ -450,19 +450,19 @@ def _iterate_tests():
             )
         else:
             domain_to_cut_options = (NO_ARGUMENT,)
-            
+
         if variation_selection.is_partial:
             n_elements_options = (1, 2, 5)
         else:
             n_elements_options = (NO_ARGUMENT,)
-            
+
         perm_space_type_options = (PermSpace,)
         if variation_selection.is_combination:
             is_combination_options = (True,)
         else:
             is_combination_options = (NO_ARGUMENT,)
-            
-            
+
+
         if variation_selection.is_fixed:
             # All fixed maps have key `0` so even if `n_elements=1` the space
             # will still be fixed.
@@ -472,7 +472,7 @@ def _iterate_tests():
             )
         else:
             purified_fixed_map_options = (NO_ARGUMENT,)
-            
+
         if variation_selection.is_degreed:
             degrees_options = (
                 (0, 2, 4, 5),
@@ -480,7 +480,7 @@ def _iterate_tests():
             )
         else:
             degrees_options = (NO_ARGUMENT,)
-            
+
         if variation_selection.is_sliced:
             slice_options = (
                 slice(2, -2),
@@ -488,8 +488,8 @@ def _iterate_tests():
             )
         else:
             slice_options = (NO_ARGUMENT,)
-            
-            
+
+
         if variation_selection.is_typed:
             if variation_selection.is_combination:
                 perm_type_options = (FruityComb,)
@@ -497,7 +497,7 @@ def _iterate_tests():
                 perm_type_options = (FruityPerm,)
         else:
             perm_type_options = (NO_ARGUMENT,)
-            
+
         product_space_ = combi.ProductSpace(
             ((variation_selection,), perm_space_type_options,
              iterable_or_length_and_sequence_options, domain_to_cut_options,
@@ -505,7 +505,7 @@ def _iterate_tests():
              purified_fixed_map_options, degrees_options, slice_options,
              perm_type_options)
         )
-        
+
         for i in range(len(product_space_)):
             fucking_globals = dict(globals())
             fucking_globals.update(locals())
@@ -513,7 +513,7 @@ def _iterate_tests():
                 'lambda: _check_variation_selection(*product_space_[%s])' % i,
                 fucking_globals, locals()
             )
-            
+
 
 # We use this shit because Nose can't parallelize generator tests:
 lambdas = []
@@ -524,5 +524,5 @@ for i, f in enumerate(_iterate_tests()):
 for i, partition in enumerate(sequence_tools.partitions(lambdas, 500)):
     exec('def test_%s(): return (%s)' %
          (i, ', '.join('%s()'% f.name for f in partition)))
-    
-    
\ No newline at end of file
+
+
--- a/source_py3/combi/_python_toolbox/cute_testing.py
+++ b/source_py3/combi/_python_toolbox/cute_testing.py
@@ -25,19 +25,19 @@ class RaiseAssertor(context_management.C
     Asserts that a certain exception was raised in the suite. You may use a
     snippet of text that must appear in the exception message or a regex that
     the exception message must match.
-    
+
     Example:
-    
+
         with RaiseAssertor(ZeroDivisionError, 'modulo by zero'):
             1/0
-    
+
     '''
-    
+
     def __init__(self, exception_type=Exception, text='',
                  assert_exact_type=False):
         '''
         Construct the `RaiseAssertor`.
-        
+
         `exception_type` is an exception type that the exception must be of;
         `text` may be either a snippet of text that must appear in the
         exception's message, or a regex pattern that the exception message must
@@ -47,22 +47,22 @@ class RaiseAssertor(context_management.C
         '''
         self.exception_type = exception_type
         '''The type of exception that should be raised.'''
-        
+
         self.text = text
         '''The snippet or regex that the exception message must match.'''
-        
+
         self.exception = None
         '''The exception that was caught.'''
-        
+
         self.assert_exact_type = assert_exact_type
         '''
         Flag saying whether we require an exact match to `exception_type`.
-        
+
         If set to `False`, a subclass of `exception_type` will also be
         acceptable.
         '''
-        
-        
+
+
     def manage_context(self):
         '''Manage the `RaiseAssertor'`s context.'''
         try:
@@ -106,23 +106,23 @@ class RaiseAssertor(context_management.C
         else:
             raise Failure("%s wasn't raised." % self.exception_type.__name__)
 
-                    
+
 def assert_same_signature(*callables):
     '''Assert that all the `callables` have the same function signature.'''
     arg_specs = [cute_inspect.getargspec(callable_) for callable_ in callables]
     if not logic_tools.all_equivalent(arg_specs, assume_transitive=False):
         raise Failure('Not all the callables have the same signature.')
-    
-    
+
+
 class _MissingAttribute:
     '''Object signifying that an attribute was not found.'''
     # todo: make uninstanciable
 
-    
+
 def assert_polite_wrapper(wrapper, wrapped=None, same_signature=True):
     '''
     Assert that `wrapper` is a polite function wrapper around `wrapped`.
-    
+
     A function wrapper (usually created by a decorator) has a few
     responsibilties; maintain the same name, signature, documentation etc. of
     the original function, and a few others. Here we check that the wrapper did
@@ -139,19 +139,19 @@ def assert_polite_wrapper(wrapper, wrapp
         assert (getattr(wrapper, attribute, None) or _MissingAttribute) == \
                (getattr(wrapped, attribute,  None) or _MissingAttribute)
     assert wrapper.__wrapped__ == wrapped
-    
-    
+
+
 class TestCase(unittest2.TestCase, context_management.ContextManager):
     setUp = misc_tools.ProxyProperty('.setup')
     tearDown = misc_tools.ProxyProperty('.tear_down')
     def manage_context(self):
         yield self
-        
+
     def setup(self):
         return self.__enter__()
     def tear_down(self):
         # todo: Should probably do something with exception-swallowing here to
         # abide with the context manager protocol, but I don't need it yet.
         return self.__exit__(*sys.exc_info())
-        
-        
\ No newline at end of file
+
+
--- a/source_py3/test_combi/__init__.py
+++ b/source_py3/test_combi/__init__.py
@@ -18,7 +18,7 @@ if nose.__versioninfo__ < (1, 0, 0):
 def __bootstrap():
     '''
     Add needed packages in repo to path if we can't find them.
-    
+
     This adds `combi`'s root folder to `sys.path` if it can't
     currently be imported.
     '''
@@ -29,11 +29,11 @@ def __bootstrap():
     def exists(module_name):
         '''
         Return whether a module by the name `module_name` exists.
-        
+
         This seems to be the best way to carefully import a module.
-        
+
         Currently implemented for top-level packages only. (i.e. no dots.)
-    
+
         Doesn't support modules imported from a zip file.
         '''
         assert '.' not in module_name
@@ -43,16 +43,16 @@ def __bootstrap():
             return False
         else:
             return True
-    
+
     if not exists('combi'):
         combi_candidate_path = pathlib(__file__).parent.parent.absolute()
         sys.path.append(combi_candidate_path)
-        
-        
+
+
 __bootstrap()
 
 
-_default_nose_arguments = [   
+_default_nose_arguments = [
     '--verbosity=3',
     '--detailed-errors',
     '--with-xunit',
--- a/source_py3/test_combi/test_extensive.py
+++ b/source_py3/test_combi/test_extensive.py
@@ -24,22 +24,22 @@ infinities = (infinity, -infinity)
 
 class _NO_ARGUMENT_TYPE(type):
     __repr__ = lambda cls: '<%s>' % cls.__name__
-        
+
 
 class NO_ARGUMENT(metaclass=_NO_ARGUMENT_TYPE): pass
-        
+
 
 
 class BrutePermSpace:
     '''
     A `PermSpace` substitute used for testing `PermSpace`.
-    
+
     This class is used for comparing with `PermSpace` in tests and ensuring it
     produces the same results. The reason we have high confidence that
     `BrutePermSpace` itself produces true results is because it's
     implementation is much simpler than `PermSpace`'s, which is because it
     doesn't need to be efficient, because it's only used for tests.
-    
+
     `BrutePermSpace` takes the some signature of arguments used for
     `PermSpace`, though it's not guaranteed to be able to deal with all the
     kinds of arguments that `PermSpace` would take.
@@ -63,21 +63,21 @@ class BrutePermSpace:
         self.degrees = \
                       degrees or sequence_tools.CuteRange(self.sequence_length)
         self.is_combination = is_combination
-        
+
         self.is_degreed = (self.degrees !=
                                 sequence_tools.CuteRange(self.sequence_length))
-        
+
         self.slice_ = slice_
- 
+
         if perm_type is None:
             self.perm_type = tuple
             self.is_typed = False
         else:
             self.perm_type = FruityTuple
             self.is_typed = True
-        
-        
-        
+
+
+
     def __iter__(self):
         if (self.is_recurrent and self.is_combination):
             def make_iterator():
@@ -97,7 +97,7 @@ class BrutePermSpace:
                                     self.slice_.stop)
         else:
             return iterator
-        
+
     def _iter(self):
         yielded_candidates = set()
         for candidate in itertools.permutations(self.sequence, self.n_elements):
@@ -122,24 +122,24 @@ class BrutePermSpace:
                 n_cycles = 0
                 while unvisited_items:
                     starting_item = current_item = next(iter(unvisited_items))
-                    
+
                     while current_item in unvisited_items:
                         unvisited_items.remove(current_item)
                         current_item = self.sequence.index(
                             candidate[current_item]
                         )
-                        
+
                     if current_item == starting_item:
                         n_cycles += 1
-                        
+
                 degree = self.sequence_length - n_cycles
-                
+
                 if degree not in self.degrees:
                     continue
-                
+
             yielded_candidates.add(candidate)
             yield candidate
-                
+
 
 
 class FruityMixin: pass
@@ -154,26 +154,26 @@ def _check_variation_selection(variation
                                degrees, slice_, perm_type):
     assert isinstance(variation_selection,
                       combi.perming.variations.VariationSelection)
-    
+
     kwargs = {}
-    
+
     iterable_or_length, sequence = iterable_or_length_and_sequence
-    
+
     kwargs['iterable_or_length'] = iterable_or_length
     sequence_set = set(sequence)
-    
+
     if domain_to_cut != NO_ARGUMENT:
         kwargs['domain'] = actual_domain = domain_to_cut[:len(sequence)]
     else:
         actual_domain = sequence_tools.CuteRange(len(sequence))
-        
+
     if n_elements != NO_ARGUMENT:
         kwargs['n_elements'] = n_elements
     actual_n_elements = n_elements if (n_elements != NO_ARGUMENT) else 0
-        
+
     if is_combination != NO_ARGUMENT:
         kwargs['is_combination'] = is_combination
-        
+
     if purified_fixed_map != NO_ARGUMENT:
         kwargs['fixed_map'] = actual_fixed_map = {
             actual_domain[key]: sequence[value] for key, value
@@ -181,10 +181,10 @@ def _check_variation_selection(variation
         }
     else:
         actual_fixed_map = {}
-        
+
     if variation_selection.is_degreed:
         kwargs['degrees'] = degrees = (0, 2, 4, 5)
-        
+
     if perm_type != NO_ARGUMENT:
         kwargs['perm_type'] = perm_type
 
@@ -195,51 +195,51 @@ def _check_variation_selection(variation
             return
         else:
             raise
-        
+
     if slice_ != NO_ARGUMENT:
         perm_space = perm_space[slice_]
-        
+
     else:
         if not variation_selection.is_allowed:
             raise TypeError(
                 "Shouldn't have allowed this `VariationSelection.`"
             )
-    
+
     brute_perm_space = BrutePermSpace(
         slice_=(perm_space.canonical_slice if variation_selection.is_sliced else
-                None), 
+                None),
         **kwargs
     )
     assert perm_space.variation_selection == variation_selection
     assert perm_space.sequence_length == len(sequence)
-    
+
     assert (perm_space.domain == perm_space.sequence) == (
         not variation_selection.is_dapplied and
         not variation_selection.is_rapplied and
         not variation_selection.is_partial
     )
-    
+
     if perm_space.length:
         assert perm_space.index(perm_space[-1]) == perm_space.length - 1
         assert perm_space.index(perm_space[0]) == 0
-        
+
     if variation_selection.is_partial:
         assert 0 < perm_space.n_unused_elements == \
                                               len(sequence) - actual_n_elements
     else:
         assert perm_space.n_unused_elements == 0
-        
+
     assert perm_space == PermSpace(**kwargs)[perm_space.canonical_slice]
     assert (not perm_space != PermSpace(**kwargs)[perm_space.canonical_slice])
     assert hash(perm_space) == \
                           hash(PermSpace(**kwargs)[perm_space.canonical_slice])
-    
+
     typed_perm_space = perm_space.get_typed(FruityComb if
                             variation_selection.is_combination else FruityPerm)
     assert typed_perm_space.is_typed
     assert variation_selection.is_typed is perm_space.is_typed is \
          (perm_space != perm_space.untyped) is (perm_space == typed_perm_space)
-    
+
 
     if perm_space.is_sliced and perm_space.length >= 2:
         assert perm_space[0] == perm_space.unsliced[2]
@@ -252,23 +252,23 @@ def _check_variation_selection(variation
         assert perm_space.unsliced[-1] not in perm_space
         assert perm_space.unsliced[-2] not in perm_space
         assert perm_space.unsliced[-3] in perm_space
-        
+
     if perm_space:
         # Making sure that `brute_perm_space` isn't empty:
         next(iter(brute_perm_space))
         # This is crucial otherwise the zip-based loop below won't run and
         # we'll get the illusion that the tests are running while they're
         # really not.
-    
+
     for i, (perm, brute_perm_tuple) in enumerate(
                       itertools.islice(zip(perm_space, brute_perm_space), 10)):
-        
+
         assert tuple(perm) == brute_perm_tuple
         assert perm in perm_space
         assert tuple(perm) in perm_space
         assert iter(list(perm)) in perm_space
         assert set(perm) not in perm_space
-        
+
         assert isinstance(perm, combi.Perm)
         assert perm.is_rapplied == variation_selection.is_rapplied
         assert perm.is_dapplied == variation_selection.is_dapplied
@@ -278,9 +278,9 @@ def _check_variation_selection(variation
                                      variation_selection.is_dapplied or
                                      variation_selection.is_partial or
                                      variation_selection.is_combination))
-        
+
         assert isinstance(perm, FruityMixin) is variation_selection.is_typed
-        
+
         if variation_selection.is_rapplied:
             assert perm != perm.unrapplied
             if not variation_selection.is_recurrent:
@@ -294,13 +294,13 @@ def _check_variation_selection(variation
                 assert tuple(sample_domain * perm) == tuple(
                     perm_space.get_rapplied(sample_domain)[i]._perm_sequence
                 )
-            
-        
+
+
         if variation_selection.is_dapplied:
             assert perm != perm.undapplied == perm_space.undapplied[i]
         else:
             assert perm == perm.undapplied == perm_space.undapplied[i]
-            
+
         if variation_selection.is_combination:
             if variation_selection.is_typed:
                 with cute_testing.RaiseAssertor(TypeError):
@@ -309,7 +309,7 @@ def _check_variation_selection(variation
                 assert perm != perm.uncombinationed
         else:
             assert perm == perm.uncombinationed
-        
+
         if variation_selection.is_combination:
             if variation_selection.is_typed:
                 assert type(perm) == FruityComb
@@ -320,7 +320,7 @@ def _check_variation_selection(variation
                 assert type(perm) == FruityPerm
             else:
                 assert type(perm) == Perm
-        
+
         if variation_selection.variations <= {
             perming.variations.Variation.DAPPLIED,
             perming.variations.Variation.RAPPLIED,
@@ -330,14 +330,14 @@ def _check_variation_selection(variation
                                    perm_space._nominal_perm_space_of_perms == \
                                           perm_space.unsliced.undegreed.unfixed
         # Give me your unsliced, your undegreed, your unfixed.
-        
+
         if not variation_selection.is_fixed and \
                                             not variation_selection.is_degreed:
             assert perm_space.index(perm) == i
-            
+
         assert type(perm)(iter(perm), perm_space=perm_space) == perm
         assert type(perm)(perm._perm_sequence, perm_space=perm_space) == perm
-        
+
         assert perm.length == perm_space.n_elements
         if variation_selection.is_partial or variation_selection.is_rapplied \
                                             or variation_selection.is_dapplied:
@@ -354,7 +354,7 @@ def _check_variation_selection(variation
                                                      perm.nominal_perm_space[0]
             assert isinstance(perm ** 4, Perm)
             assert isinstance(perm ** -7, Perm)
-            
+
         perm_set = set(perm)
         if variation_selection.is_partial:
             assert len(perm) == actual_n_elements
@@ -366,7 +366,7 @@ def _check_variation_selection(variation
         else:
             assert perm_set == sequence_set
             assert len(perm) == len(sequence)
-            
+
         for j, (value, key, (key__, value__)) in enumerate(
                                        zip(perm, perm.as_dictoid, perm.items)):
             assert key == key__
@@ -377,15 +377,15 @@ def _check_variation_selection(variation
             assert perm[key] == value
             assert key in perm.domain
             assert value in perm
-            
+
         if variation_selection.is_degreed:
             assert perm.degree == degrees or perm.degree in degrees
         elif variation_selection.is_partial:
             assert perm.degree == NotImplemented
         else:
             assert 0 <= perm.degree <= len(sequence)
-            
-        
+
+
         ### Testing neighbors: ################################################
         #                                                                     #
         if variation_selection.is_combination or \
@@ -404,29 +404,29 @@ def _check_variation_selection(variation
                     # there aren't any neighbors.)
                     assert neighbors
                 for neigbhor in itertools.islice(neighbors, 0, 10):
-                    assert neigbhor in perm_space 
+                    assert neigbhor in perm_space
                     assert len(cute_iter_tools.zip_non_equal((perm, neigbhor),
                                                          lazy_tuple=True)) == 2
-        
+
         #                                                                     #
         ### Finished testing neighbors. #######################################
-        
+
         perm_repr = repr(perm)
-        
-        
+
+
 def _iterate_tests():
     for variation_selection in \
                             combi.perming.variations.variation_selection_space:
-        
+
         kwargs = {}
-        
+
         if variation_selection.is_recurrent and \
                                            not variation_selection.is_rapplied:
             assert not variation_selection.is_allowed
             # Can't even test this illogical clash.
             continue
-            
-        
+
+
         if variation_selection.is_recurrent:
             iterable_or_length_and_sequence_options = (
                 ('abracab', 'abracab'),
@@ -436,14 +436,14 @@ def _iterate_tests():
         elif variation_selection.is_rapplied:
             iterable_or_length_and_sequence_options = (
                 ([1, 4, 2, 5, 3, 7],
-                 (1, 4, 2, 5, 3, 7)), 
+                 (1, 4, 2, 5, 3, 7)),
             )
         else:
             iterable_or_length_and_sequence_options = (
                 (7, sequence_tools.CuteRange(7)),
                 (sequence_tools.CuteRange(9), sequence_tools.CuteRange(9))
             )
-        
+
         if variation_selection.is_dapplied:
             domain_to_cut_options = (
                 'QPONMLKJIHGFEDCBAZYXWVUTSR',
@@ -451,19 +451,19 @@ def _iterate_tests():
             )
         else:
             domain_to_cut_options = (NO_ARGUMENT,)
-            
+
         if variation_selection.is_partial:
             n_elements_options = (1, 2, 5)
         else:
             n_elements_options = (NO_ARGUMENT,)
-            
+
         perm_space_type_options = (PermSpace,)
         if variation_selection.is_combination:
             is_combination_options = (True,)
         else:
             is_combination_options = (NO_ARGUMENT,)
-            
-            
+
+
         if variation_selection.is_fixed:
             # All fixed maps have key `0` so even if `n_elements=1` the space
             # will still be fixed.
@@ -473,7 +473,7 @@ def _iterate_tests():
             )
         else:
             purified_fixed_map_options = (NO_ARGUMENT,)
-            
+
         if variation_selection.is_degreed:
             degrees_options = (
                 (0, 2, 4, 5),
@@ -481,7 +481,7 @@ def _iterate_tests():
             )
         else:
             degrees_options = (NO_ARGUMENT,)
-            
+
         if variation_selection.is_sliced:
             slice_options = (
                 slice(2, -2),
@@ -489,8 +489,8 @@ def _iterate_tests():
             )
         else:
             slice_options = (NO_ARGUMENT,)
-            
-            
+
+
         if variation_selection.is_typed:
             if variation_selection.is_combination:
                 perm_type_options = (FruityComb,)
@@ -498,7 +498,7 @@ def _iterate_tests():
                 perm_type_options = (FruityPerm,)
         else:
             perm_type_options = (NO_ARGUMENT,)
-            
+
         product_space_ = combi.ProductSpace(
             ((variation_selection,), perm_space_type_options,
              iterable_or_length_and_sequence_options, domain_to_cut_options,
@@ -506,7 +506,7 @@ def _iterate_tests():
              purified_fixed_map_options, degrees_options, slice_options,
              perm_type_options)
         )
-        
+
         for i in range(len(product_space_)):
             fucking_globals = dict(globals())
             fucking_globals.update(locals())
@@ -514,7 +514,7 @@ def _iterate_tests():
                 'lambda: _check_variation_selection(*product_space_[%s])' % i,
                 fucking_globals, locals()
             )
-            
+
 
 # We use this shit because Nose can't parallelize generator tests:
 lambdas = []
@@ -525,5 +525,5 @@ for i, f in enumerate(_iterate_tests()):
 for i, partition in enumerate(sequence_tools.partitions(lambdas, 500)):
     exec('def test_%s(): return (%s)' %
          (i, ', '.join('%s()'% f.name for f in partition)))
-    
-    
\ No newline at end of file
+
+
