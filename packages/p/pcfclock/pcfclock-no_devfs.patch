--- linux/pcfclock.c
+++ linux/pcfclock.c
@@ -49,7 +49,9 @@
 #include <linux/major.h>
 #include <linux/fs.h>
 #include <linux/sched.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
 #include <linux/devfs_fs_kernel.h>
+#endif
 #include <linux/string.h>
 #include <linux/delay.h>
 #include <linux/parport.h>
@@ -441,7 +443,9 @@
 		return 1;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
 	devfs_mk_cdev(MKDEV(PCFCLOCK_MAJOR, n), S_IFCHR | S_IRUGO, "pcfclocks/%d", n);
+#endif
 #else
 	sprintf(name, "%d", n);
 	devfs_register(devfs_handle, name, DEVFS_FL_DEFAULT, PCFCLOCK_MAJOR, n, S_IFCHR | S_IRUGO,
@@ -508,7 +512,9 @@
 		printk(KERN_ERR "pcfclock: unable to get major %d\n", PCFCLOCK_MAJOR);
 		return -EIO;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
 	devfs_mk_dir("pcfclocks");
+#endif
 #else
 	if (devfs_register_chrdev(PCFCLOCK_MAJOR, "pcfclock", &pcfclock_fops)) {
 		printk(KERN_ERR "pcfclock: unable to get major %d\n", PCFCLOCK_MAJOR);
@@ -562,10 +568,14 @@
 	for (n = 0; n < PCFCLOCK_NO; n++) {
 		if (pcfclock_table[n].dev != NULL) {
 			parport_unregister_device(pcfclock_table[n].dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
 			devfs_remove("pcfclocks/%d", n);
+#endif
 		}
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
 	devfs_remove("pcfclocks");
+#endif
 #else
 	devfs_unregister(devfs_handle);
 	devfs_unregister_chrdev(PCFCLOCK_MAJOR, "pcfclock");
