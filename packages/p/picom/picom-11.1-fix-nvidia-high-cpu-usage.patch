--- a/src/vblank.c
+++ b/src/vblank.c
@@ -78,13 +78,14 @@ struct sgi_video_sync_vblank_scheduler {
 
 	// Since glXWaitVideoSyncSGI blocks, we need to run it in a separate thread.
 	// ... and all the thread shenanigans that come with it.
-	_Atomic unsigned int last_msc;
-	_Atomic uint64_t last_ust;
+	_Atomic unsigned int current_msc;
+	_Atomic uint64_t current_ust;
 	ev_async notify;
 	pthread_t sync_thread;
 	bool running, error;
+	unsigned int last_msc;
 
-	/// Protects `running`, `error` and `base.vblank_event_requested`
+	/// Protects `running`, and `base.vblank_event_requested`
 	pthread_mutex_t vblank_requested_mtx;
 	pthread_cond_t vblank_requested_cnd;
 };
@@ -207,8 +208,8 @@ static void *sgi_video_sync_thread(void
 
 		struct timespec now;
 		clock_gettime(CLOCK_MONOTONIC, &now);
-		atomic_store(&self->last_msc, last_msc);
-		atomic_store(&self->last_ust,
+		atomic_store(&self->current_msc, last_msc);
+		atomic_store(&self->current_ust,
 		             (uint64_t)(now.tv_sec * 1000000 + now.tv_nsec / 1000));
 		ev_async_send(self->base.loop, &self->notify);
 		pthread_mutex_lock(&self->vblank_requested_mtx);
@@ -241,7 +242,10 @@ cleanup:
 
 static void sgi_video_sync_scheduler_schedule(struct vblank_scheduler *base) {
 	auto self = (struct sgi_video_sync_vblank_scheduler *)base;
-	log_verbose("Requesting vblank event for msc %d", self->last_msc + 1);
+	if (self->error) {
+		return;
+	}
+	log_verbose("Requesting vblank event for msc %d", self->current_msc + 1);
 	pthread_mutex_lock(&self->vblank_requested_mtx);
 	assert(!base->vblank_event_requested);
 	base->vblank_event_requested = true;
@@ -250,16 +254,7 @@ static void sgi_video_sync_scheduler_sch
 }
 
 static void
-sgi_video_sync_scheduler_callback(EV_P attr_unused, ev_async *w, int attr_unused revents) {
-	auto sched = container_of(w, struct sgi_video_sync_vblank_scheduler, notify);
-	auto event = (struct vblank_event){
-	    .msc = atomic_load(&sched->last_msc),
-	    .ust = atomic_load(&sched->last_ust),
-	};
-	sched->base.vblank_event_requested = false;
-	log_verbose("Received vblank event for msc %lu", event.msc);
-	vblank_scheduler_invoke_callbacks(&sched->base, &event);
-}
+sgi_video_sync_scheduler_callback(EV_P attr_unused, ev_async *w, int attr_unused revents);
 
 static void sgi_video_sync_scheduler_init(struct vblank_scheduler *base) {
 	auto self = (struct sgi_video_sync_vblank_scheduler *)base;
@@ -287,7 +282,10 @@ static void sgi_video_sync_scheduler_ini
 		log_fatal("Failed to start sgi_video_sync_thread, error code: %d",
 		          args.start_status);
 		abort();
+	} else {
+		self->error = false;
 	}
+	self->last_msc = 0;
 	pthread_mutex_destroy(&args.start_mtx);
 	pthread_cond_destroy(&args.start_cnd);
 	log_info("Started sgi_video_sync_thread");
@@ -306,6 +304,32 @@ static void sgi_video_sync_scheduler_dei
 	pthread_mutex_destroy(&self->vblank_requested_mtx);
 	pthread_cond_destroy(&self->vblank_requested_cnd);
 }
+
+static void
+sgi_video_sync_scheduler_callback(EV_P attr_unused, ev_async *w, int attr_unused revents) {
+	auto sched = container_of(w, struct sgi_video_sync_vblank_scheduler, notify);
+	auto msc = atomic_load(&sched->current_msc);
+	if (sched->last_msc == msc) {
+		// NVIDIA spams us with duplicate vblank events after a suspend/resume
+		// cycle. Recreating the X connection and GLX context seems to fix this.
+		// Oh NVIDIA.
+		log_warn("Duplicate vblank event found with msc %d. Possible NVIDIA bug?", msc);
+		log_warn("Resetting the vblank scheduler");
+		sgi_video_sync_scheduler_deinit(&sched->base);
+		sched->base.vblank_event_requested = false;
+		sgi_video_sync_scheduler_init(&sched->base);
+		sgi_video_sync_scheduler_schedule(&sched->base);
+		return;
+	}
+	auto event = (struct vblank_event){
+	    .msc = msc,
+	    .ust = atomic_load(&sched->current_ust),
+	};
+	sched->base.vblank_event_requested = false;
+	sched->last_msc = msc;
+	log_verbose("Received vblank event for msc %lu", event.msc);
+	vblank_scheduler_invoke_callbacks(&sched->base, &event);
+}
 #endif
 
 static void present_vblank_scheduler_schedule(struct vblank_scheduler *base) {
