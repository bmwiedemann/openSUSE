
Index: pydicom-2.4.4/pydicom/pixel_data_handlers/pillow_handler.py
===================================================================
--- pydicom-2.4.4.orig/pydicom/pixel_data_handlers/pillow_handler.py
+++ pydicom-2.4.4/pydicom/pixel_data_handlers/pillow_handler.py
@@ -255,14 +255,14 @@ def get_pixeldata(ds: "Dataset") -> "num
                 if ds.PixelRepresentation == 1:
                     # Pillow converts signed data to unsigned
                     #   so we need to undo this conversion
-                    arr -= 2**(bits_allocated - 1)
+                    arr -= numpy.uint32(2**(bits_allocated - 1))
 
                 if shift:
                     arr = numpy.right_shift(arr, shift)
         else:
             # Corrections based on dataset elements
             if ds.PixelRepresentation == 1:
-                arr -= 2**(bits_allocated - 1)
+                arr -= numpy.uint32(2**(bits_allocated - 1))
 
             if shift:
                 arr = numpy.right_shift(arr, shift)
Index: pydicom-2.4.4/pydicom/pixel_data_handlers/pylibjpeg_handler.py
===================================================================
--- pydicom-2.4.4.orig/pydicom/pixel_data_handlers/pylibjpeg_handler.py
+++ pydicom-2.4.4/pydicom/pixel_data_handlers/pylibjpeg_handler.py
@@ -66,11 +66,7 @@ except ImportError:
     HAVE_PYLIBJPEG = False
 
 if HAVE_PYLIBJPEG:
-    try:
-        from pylibjpeg.utils import get_pixel_data_decoders
-    except ImportError:
-        # Old import, deprecated in 1.2, removal in 2.0
-        from pylibjpeg.pydicom.utils import get_pixel_data_decoders
+    from pylibjpeg.utils import get_pixel_data_decoders, Decoder
 
 try:
     import openjpeg
@@ -249,7 +245,7 @@ def generate_frames(
             "elements are missing from the dataset: " + ", ".join(missing)
         )
 
-    decoder = _DECODERS[tsyntax]
+    decoder = cast(Decoder, _DECODERS[tsyntax])
     LOGGER.debug(f"Decoding {tsyntax.name} encoded Pixel Data using {decoder}")
 
     nr_frames = getattr(ds, "NumberOfFrames", 1)
@@ -260,7 +256,7 @@ def generate_frames(
     bits_allocated = cast(int, ds.BitsAllocated)
 
     for frame in generate_pixel_data_frame(ds.PixelData, nr_frames):
-        arr = decoder(frame, pixel_module)
+        arr = decoder(frame, ds=pixel_module)
 
         if (
             tsyntax in [JPEG2000, JPEG2000Lossless]
Index: pydicom-2.4.4/pydicom/tests/test_encoders_pydicom.py
===================================================================
--- pydicom-2.4.4.orig/pydicom/tests/test_encoders_pydicom.py
+++ pydicom-2.4.4/pydicom/tests/test_encoders_pydicom.py
@@ -444,7 +444,7 @@ class TestRLEEncodeFrame:
         assert ds.SamplesPerPixel == 3
         assert ds.PixelRepresentation == 0
 
-        arr = ref.newbyteorder('>')
+        arr = ref.view(ref.dtype.newbyteorder('>'))
         assert id(arr) != id(ref)
         assert arr.dtype == '>u2'
         encoded = rle_encode_frame(arr)
Index: pydicom-2.4.4/pydicom/pixel_data_handlers/util.py
===================================================================
--- pydicom-2.4.4.orig/pydicom/pixel_data_handlers/util.py
+++ pydicom-2.4.4/pydicom/pixel_data_handlers/util.py
@@ -200,7 +200,7 @@ def apply_color_lut(
     # IVs >= `first_map` are mapped by the Palette Color LUTs
     # `first_map` may be negative, positive or 0
     mapped_pixels = arr >= first_map
-    clipped_iv[mapped_pixels] = arr[mapped_pixels] - first_map
+    clipped_iv[mapped_pixels] = arr[mapped_pixels] - np.int32(first_map)
     # IVs > number of entries get set to last entry
     np.clip(clipped_iv, 0, nr_entries - 1, out=clipped_iv)
 
@@ -276,7 +276,7 @@ def apply_modality_lut(arr: "np.ndarray"
         # IVs >= `first_map` are mapped by the Modality LUT
         # `first_map` may be negative, positive or 0
         mapped_pixels = arr >= first_map
-        clipped_iv[mapped_pixels] = arr[mapped_pixels] - first_map
+        clipped_iv[mapped_pixels] = arr[mapped_pixels] - np.int32(first_map)
         # IVs > number of entries get set to last entry
         np.clip(clipped_iv, 0, nr_entries - 1, out=clipped_iv)
 
@@ -458,7 +458,7 @@ def apply_voi(
     # IVs >= `first_map` are mapped by the VOI LUT
     # `first_map` may be negative, positive or 0
     mapped_pixels = arr >= first_map
-    clipped_iv[mapped_pixels] = arr[mapped_pixels] - first_map
+    clipped_iv[mapped_pixels] = arr[mapped_pixels] - np.int32(first_map)
     # IVs > number of entries get set to last entry
     np.clip(clipped_iv, 0, nr_entries - 1, out=clipped_iv)
 
