From 3e7888e59f239f66766904c6d8303ad04d8ff1a6 Mon Sep 17 00:00:00 2001
From: pgjones <philip.graham.jones@googlemail.com>
Date: Fri, 18 Feb 2022 13:32:42 +0000
Subject: [PATCH 1/5] Fix incompatibility in tests with the latest h11

The latest h11 events are frozen dataclasses and hence the headers
can't be overwritten.
---
 test/test_server.py | 32 +++++++++++++-------------------
 1 file changed, 13 insertions(+), 19 deletions(-)

Index: wsproto-1.0.0/test/test_server.py
===================================================================
--- wsproto-1.0.0.orig/test/test_server.py
+++ wsproto-1.0.0/test/test_server.py
@@ -5,13 +5,7 @@ import pytest
 
 from wsproto import WSConnection
 from wsproto.connection import SERVER
-from wsproto.events import (
-    AcceptConnection,
-    Event,
-    RejectConnection,
-    RejectData,
-    Request,
-)
+from wsproto.events import AcceptConnection, RejectConnection, RejectData, Request
 from wsproto.extensions import Extension
 from wsproto.typing import Headers
 from wsproto.utilities import (
@@ -199,36 +193,30 @@ def _make_handshake(
         )
     )
     event = client.next_event()
-    return event, nonce
+    return cast(h11.InformationalResponse, event), nonce
 
 
 def test_handshake() -> None:
     response, nonce = _make_handshake([])
 
-    response.headers = sorted(response.headers)  # For test determinism
-    assert response == h11.InformationalResponse(
-        status_code=101,
-        headers=[
-            (b"connection", b"Upgrade"),
-            (b"sec-websocket-accept", generate_accept_token(nonce)),
-            (b"upgrade", b"WebSocket"),
-        ],
-    )
+    assert response.status_code == 101
+    assert sorted(response.headers) == [
+        (b"connection", b"Upgrade"),
+        (b"sec-websocket-accept", generate_accept_token(nonce)),
+        (b"upgrade", b"WebSocket"),
+    ]
 
 
 def test_handshake_extra_headers() -> None:
     response, nonce = _make_handshake([], accept_headers=[(b"X-Foo", b"bar")])
 
-    response.headers = sorted(response.headers)  # For test determinism
-    assert response == h11.InformationalResponse(
-        status_code=101,
-        headers=[
-            (b"connection", b"Upgrade"),
-            (b"sec-websocket-accept", generate_accept_token(nonce)),
-            (b"upgrade", b"WebSocket"),
-            (b"x-foo", b"bar"),
-        ],
-    )
+    assert response.status_code == 101
+    assert sorted(response.headers) == [
+        (b"connection", b"Upgrade"),
+        (b"sec-websocket-accept", generate_accept_token(nonce)),
+        (b"upgrade", b"WebSocket"),
+        (b"x-foo", b"bar"),
+    ]
 
 
 @pytest.mark.parametrize("accept_subprotocol", ["one", "two"])
@@ -298,7 +286,7 @@ def test_protocol_error() -> None:
 
 def _make_handshake_rejection(
     status_code: int, body: Optional[bytes] = None
-) -> List[Event]:
+) -> List[h11.Event]:
     client = h11.Connection(h11.CLIENT)
     server = WSConnection(SERVER)
     nonce = generate_nonce()
@@ -333,7 +321,7 @@ def _make_handshake_rejection(
     events = []
     while True:
         event = client.next_event()
-        events.append(event)
+        events.append(cast(h11.Event, event))
         if isinstance(event, h11.EndOfMessage):
             return events
 
Index: wsproto-1.0.0/src/wsproto/handshake.py
===================================================================
--- wsproto-1.0.0.orig/src/wsproto/handshake.py
+++ wsproto-1.0.0/src/wsproto/handshake.py
@@ -119,7 +119,7 @@ class H11Handshake:
 
         :param bytes data: Data received from the WebSocket peer.
         """
-        self._h11_connection.receive_data(data)
+        self._h11_connection.receive_data(data or b"")
         while True:
             try:
                 event = self._h11_connection.next_event()
@@ -141,7 +141,7 @@ class H11Handshake:
                     else:
                         self._events.append(
                             RejectConnection(
-                                headers=event.headers,
+                                headers=list(event.headers),
                                 status_code=event.status_code,
                                 has_body=False,
                             )
@@ -151,7 +151,7 @@ class H11Handshake:
                     self._state = ConnectionState.REJECTING
                     self._events.append(
                         RejectConnection(
-                            headers=event.headers,
+                            headers=list(event.headers),
                             status_code=event.status_code,
                             has_body=True,
                         )
@@ -387,7 +387,7 @@ class H11Handshake:
                 accept = value
                 continue  # Skip appending to headers
             elif name == b"sec-websocket-protocol":
-                subprotocol = value
+                subprotocol = value.decode("ascii")
                 continue  # Skip appending to headers
             elif name == b"upgrade":
                 upgrade = value
@@ -408,7 +408,6 @@ class H11Handshake:
         if accept != accept_token:
             raise RemoteProtocolError("Bad accept token", event_hint=RejectConnection())
         if subprotocol is not None:
-            subprotocol = subprotocol.decode("ascii")
             if subprotocol not in self._initiating_request.subprotocols:
                 raise RemoteProtocolError(
                     f"unrecognized subprotocol {subprotocol}",
Index: wsproto-1.0.0/src/wsproto/utilities.py
===================================================================
--- wsproto-1.0.0.orig/src/wsproto/utilities.py
+++ wsproto-1.0.0/src/wsproto/utilities.py
@@ -7,7 +7,9 @@ Utility functions that do not belong in
 import base64
 import hashlib
 import os
-from typing import Dict, List, Optional
+from typing import Dict, List, Optional, Union
+
+from h11._headers import Headers as H11Headers
 
 from .events import Event
 from .typing import Headers
@@ -51,7 +53,7 @@ class RemoteProtocolError(ProtocolError)
 
 
 # Some convenience utilities for working with HTTP headers
-def normed_header_dict(h11_headers: Headers) -> Dict[bytes, bytes]:
+def normed_header_dict(h11_headers: Union[Headers, H11Headers]) -> Dict[bytes, bytes]:
     # This mangles Set-Cookie headers. But it happens that we don't care about
     # any of those, so it's OK. For every other HTTP header, if there are
     # multiple instances then you're allowed to join them together with
Index: wsproto-1.0.0/test/test_client.py
===================================================================
--- wsproto-1.0.0.orig/test/test_client.py
+++ wsproto-1.0.0/test/test_client.py
@@ -1,4 +1,4 @@
-from typing import List, Optional
+from typing import cast, List, Optional
 
 import h11
 import pytest
@@ -27,7 +27,7 @@ def _make_connection_request(request: Re
     client = WSConnection(CLIENT)
     server = h11.Connection(h11.SERVER)
     server.receive_data(client.send(request))
-    return server.next_event()
+    return cast(h11.Request, server.next_event())
 
 
 def test_connection_request() -> None:
@@ -114,7 +114,7 @@ def test_connection_send_state() -> None
             )
         )
     )
-    headers = normed_header_dict(server.next_event().headers)
+    headers = normed_header_dict(cast(h11.Request, server.next_event()).headers)
     response = h11.InformationalResponse(
         status_code=101,
         headers=[
@@ -158,7 +158,7 @@ def _make_handshake(
             )
         )
     )
-    request = server.next_event()
+    request = cast(h11.Request, server.next_event())
     if auto_accept_key:
         full_request_headers = normed_header_dict(request.headers)
         response_headers.append(
