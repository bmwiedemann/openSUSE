From 4a6a1972829a8430a40c81cd2fcd48981de56f86 Mon Sep 17 00:00:00 2001
From: Mingming Cao <mmc@linux.vnet.ibm.com>
Date: Tue, 15 Feb 2022 23:59:43 -0800
Subject: [PATCH 2/6] Factor out NetworkManager nmcli code

Move nmcli code to corresponding hcn command/functions for networkmanager

Signed-off-by: Mingming Cao <mmc@linux.vnet.ibm.com>
Signed-off-by: Marius Tomaschewski <mt@suse.com>
---
 scripts/hcnmgr | 192 ++++++++++++++++++++++++++++++++++---------------
 1 file changed, 135 insertions(+), 57 deletions(-)

diff --git a/scripts/hcnmgr b/scripts/hcnmgr
index 7a11bd9..1551724 100644
--- a/scripts/hcnmgr
+++ b/scripts/hcnmgr
@@ -282,13 +282,13 @@ get_dev_hcn() {
 }
 
 #
-# function do_config_vdevice
+# function do_config_vdevice_nm
 #	configure or create HCN (active-backup bonding)
 #	add device as bonding slave
 #
 #	On enter, the vdevice name, mode, hcnid and drcindex are set
-#
-do_config_vdevice() {
+#	Based on Network Manager nmcli
+do_config_vdevice_nm() {
 	hcnlog DEBUG "do_config_vdevice: enter"
 
 	BONDNAME=bond$HCNID
@@ -359,14 +359,22 @@ do_config_vdevice() {
 	return $E_SUCCESS
 }
 
+do_config_vdevice() {
+	case $SERVICE in
+		NetworkManager.service)
+			do_config_vdevice_nm
+			;;
+	esac
+}
+
 #
-# function cfghcn
+# function cfghcn_nm
 #	Given device DRC_INDEX, configure or create HCN (active-backup bonding)
 #	add device as bonding slave
 #
 # $1 DRC_INDEX of the hybrid network device
 #
-cfghcn() {
+cfghcn_nm() {
 	local retry=3
 
 	hcnlog DEBUG "cfghcn: enter $1"
@@ -392,6 +400,33 @@ cfghcn() {
 
 	return $E_SUCCESS
 }
+
+
+# function cfghcn
+#	Given device DRC_INDEX, configure or create HCN (active-backup bonding)
+#	add device as bonding slave
+#
+# $1 DRC_INDEX of the hybrid network device
+#
+cfghcn() {
+	hcnlog DEBUG "cfghcn: enter $1"
+
+	case $SERVICE in
+		NetworkManager.service)
+			cfghcn_nm $1
+			;;
+	esac
+
+	hcnlog DEBUG "cfghcn: exit"
+	return $E_SUCCESS
+}
+
+rmhcn_nm() {
+	for connection in $(nmcli -f NAME con show | grep "$BONDNAME"); do
+		hcnlog INFO "Delete bonding connection $connection"
+		nmcli con delete "$connection"
+	done
+}
 #
 # function rmhcn
 #	Given HCNID, remove HCN
@@ -410,14 +445,24 @@ rmhcn() {
 	fi
 
 	hcnlog INFO "rmhcn: delete bond $BONDNAME and slaves "
-	for connection in $(nmcli -f NAME con show | grep "$BONDNAME"); do
-		hcnlog INFO "Delete bonding connection $connection"
-		nmcli con delete "$connection"
-	done
+	case $SERVICE in
+		NetworkManager.service)
+			rmhcn_nm
+			;;
+	esac
 	hcnlog DEBUG "rmhcn: exit"
 	return $E_SUCCESS
 }
 
+qrydev_nm() {
+	if ! nmcli -f DEVICE con show --active | grep -q "$DEVNAME"; then
+		hcnlog DEBUG "network connection $BONDNAME-$DEVNAME is inactive or nonexist"
+		hcnlog DEBUG "HCNID $HCNID devname $DEVNAME mode $MODE physloc $PHYSLOC DEVPATH $DEVPATH"
+		hcnlog DEBUG "qryhcn: exit"
+		# In this case, tell HMC to do rmdev and okay to migrate
+		return $E_SUCCESS
+	fi
+}
 #
 #function qrydev
 #	Called by HMC right before migration, to see if it is safe to
@@ -445,13 +490,11 @@ qrydev() {
 	BOND_PATH=$BOND_BASEPATH/$BONDNAME/bonding
 
 	hcnlog DEBUG "check if the network interface for this SR_IOV is not up, return success"
-	if ! nmcli -f DEVICE con show --active | grep -q "$DEVNAME"; then
-		hcnlog DEBUG "network connection $BONDNAME-$DEVNAME is inactive or nonexist"
-		hcnlog DEBUG "HCNID $HCNID devname $DEVNAME mode $MODE physloc $PHYSLOC DEVPATH $DEVPATH"
-		hcnlog DEBUG "qryhcn: exit"
-		# In this case, tell HMC to do rmdev and okay to migrate
-		return $E_SUCCESS
-	fi
+	case $SERVICE in
+		NetworkManager.service)
+			qrydev_nm
+			;;
+	esac
 
 	hcnlog DEBUG "check if there is bond for this $HCNID"
 	if [ ! -d "$BOND_PATH" ]; then
@@ -484,8 +527,14 @@ qrydev() {
 #
 show_hcnstatus() {
 	hcnlog DEBUG "log connection and device status to $LOG_FILE"
-	nmcli connection show >>$LOG_FILE
-	nmcli device status >>$LOG_FILE
+
+	case $SERVICE in
+		NetworkManager.service)
+			nmcli connection show >>$LOG_FILE
+			nmcli device status >>$LOG_FILE
+			;;
+	esac
+
 	ip addr show >>$LOG_FILE
 }
 
@@ -498,6 +547,13 @@ check_eth() {
 	nmcli -f DEVICE con show | grep -q "$1"
 }
 
+rmdev_nm() {
+	hcnlog DEBUG "rmdev_nm: enter"
+	if check_eth "$DEVNAME"; then
+		hcnlog INFO "rmdev: delete $BONDNAME-$DEVNAME connection"
+		nmcli con delete "$BONDNAME-$DEVNAME"
+	fi
+}
 #
 #function rmdev
 #	this is called at pre-migration time, remove sr-iov from HCN
@@ -515,16 +571,42 @@ rmdev() {
 	if [[ $HCNID != "$2" ]]; then
 		hcnlog WARN "rmdev: mismatch drc index $1 HCNID $2"
 	fi
-	if check_eth "$DEVNAME"; then
-		hcnlog INFO "rmdev: delete $BONDNAME-$DEVNAME connection"
-		nmcli con delete "$BONDNAME-$DEVNAME"
-	fi
+
+	case $SERVICE in
+		NetworkManager.service)
+			rmdev_nm
+			;;
+	esac
+
 	hcnlog DEBUG "rmdev: exit"
 	return $E_SUCCESS
 }
 
+scanhcn_cleanup_old_hnv_nm() {
+	# After online from inactive migration, destination
+	# LPAR may have same mvf devname but associated with different
+	# bonding than from source LPAR
+	# clean up expired bonding SR_IOV connections
+
+
+	for cfg in $(ls $IFCONFIG_PATH | grep "$DEVNAME" | grep "bond"); do
+		hid=$(echo "$cfg" | sed -e 's/ifcfg-//' | cut -d '-' -f 1 | sed -e 's/bond//')
+		if [ -e "$IFCONFIG_PATH/ifcfg-$DEVNAME" ]; then
+			rm "$IFCONFIG_PATH/ifcfg-$DEVNAME"
+		fi
+		if [[ $hid != "" && $hid != "$HCNID" ]] ; then
+			hcnlog INFO "Delete dead bonding slave ifcfg file $IFCONFIG_PATH/$cfg"
+			rm $IFCONFIG_PATH/"$cfg"
+
+			if nmcli -f NAME con show | grep -q "bond$hid-$DEVNAME\s"; then
+				hcnlog INFO "Delete dead bonding connection $connection"
+				nmcli con delete "bond$hid-$DEVNAME"
+			fi
+		fi
+	done
+}
 #
-# function scanhcn
+# function scanhcn_nm
 #	HMC supports adding migratable sr-iov when LPAR is inactive. This allows LPAR
 #	can be migrated when inactive with SR_IOV VFS.	It will set the
 #	migratable sr-iov device and it's backup vdevice vnic or veth with
@@ -540,8 +622,8 @@ rmdev() {
 #	For each matching primary and backup virtual device with same ibm property
 #	ibm,hcn-id, if the hybrid network has not been created, create HCN
 #	(active-backup bonding) for them.
-#s
-scanhcn() {
+#
+scanhcn_nm() {
 	local HcnIds=()
 
 	hcnlog DEBUG "scanhcn: on boot scan for hybrid virtual network starts"
@@ -556,27 +638,11 @@ scanhcn() {
 			[ -d "$dev" ] || continue
 			if [ -e "$dev"/ibm,hcn-id ] && get_dev_hcn "$dev"; then
 				hcnlog DEBUG "scanhcn found sr-iov device with hcnid "
-
-				# After online from inactive migration, destination
-				# LPAR may have same mvf devname but associated with different
-				# bonding than from source LPAR
-				# clean up expired bonding SR_IOV connections
-
-				for cfg in $(ls $IFCONFIG_PATH | grep "$DEVNAME" | grep "bond"); do
-					hid=$(echo "$cfg" | sed -e 's/ifcfg-//' | cut -d '-' -f 1 | sed -e 's/bond//')
-					if [ -e "$IFCONFIG_PATH/ifcfg-$DEVNAME" ]; then
-						rm "$IFCONFIG_PATH/ifcfg-$DEVNAME"
-					fi
-					if [[ $hid != "" && $hid != "$HCNID" ]] ; then
-						hcnlog INFO "Delete dead bonding slave ifcfg file $IFCONFIG_PATH/$cfg"
-						rm $IFCONFIG_PATH/"$cfg"
-						if nmcli -f NAME con show | grep -q "bond$hid-$DEVNAME\s"; then
-							hcnlog INFO "Delete dead bonding connection $connection"
-							nmcli con delete "bond$hid-$DEVNAME"
-						fi
-					fi
-				done
-
+				case $SERVICE in
+					NetworkManager.service)
+						scanhcn_cleanup_old_hnv_nm
+						;;
+				esac
 				hcnlog INFO "scanhcn configure HCN and sr-iov device"
 				do_config_vdevice
 				# Save found HCN ids in array HcnIds
@@ -621,19 +687,31 @@ scanhcn() {
 
 	# list of all HCN ids
 	ids="${HcnIds[*]}"
-	# After inactive migration, LPAR may have old bonding connections
-	# with network device on original LPAR
-    # clean up dead bonding connections
-	for connection in $(nmcli -f NAME con show | grep "${ids// /\\|}"); do
-		dev=$(echo "$connection" | cut -d '-' -f 2)
-		if [[ $dev != "NAME" && ! -e /sys/class/net/"$dev" ]]; then
-			hcnlog INFO "Delete dead bonding connection $connection"
-			nmcli con delete "$connection"
-		fi
-	done
-
+	case $SERVICE in
+		NetworkManager.service)
+		# After inactive migration, LPAR may have old bonding connections
+		# with network device on original LPAR
+		# clean up dead bonding connections
+		for connection in $(nmcli -f NAME con show | grep "${ids// /\\|}"); do
+			dev=$(echo "$connection" | cut -d '-' -f 2)
+			if [[ $dev != "NAME" && ! -e /sys/class/net/"$dev" ]]; then
+				hcnlog INFO "Delete dead bonding connection $connection"
+				nmcli con delete "$connection"
+			fi
+		done
+		;;
+	esac
 	hcnlog DEBUG "scanhcn: scan for hybrid virtual network finished"
 }
+
+scanhcn() {
+	case $SERVICE in
+		NetworkManager.service)
+			scanhcn_nm
+			;;
+	esac
+}
+
 # function check_network_service
 #	Check what connection manager is used
 #	On SUSE, it's wicked.sevice (SLES) or NetworkManager.service (SLED)
-- 
2.34.1

