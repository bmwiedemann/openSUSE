From c015807d5bef0ebdeaf99883793173f2b636e740 Mon Sep 17 00:00:00 2001
From: Wen Xiong <wenxiong@linux.ibm.com>
Date: Wed, 15 Jun 2022 13:05:18 -0500
Subject: [PATCH] bootlist: Add install/boot support for nvmf devices

Patch-mainline: accepted, expected in 1.3.11
Git-commit: c015807d5bef0ebdeaf99883793173f2b636e740

This patch adds the boot/installation support for nvme-over-fc devices.
It can set nvmf device as boot device in both of logical device name
and open firmware device path name.

Signed-off-by: Wen Xiong <wenxiong@linux.ibm.com>
Signed-off-by: Tyrel Datwyler <tyreld@linux.ibm.com>
---
 scripts/bootlist | 86 +++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 85 insertions(+), 1 deletion(-)

diff --git a/scripts/bootlist b/scripts/bootlist
index b5cfbd9..1929f65 100755
--- a/scripts/bootlist
+++ b/scripts/bootlist
@@ -22,6 +22,7 @@
 
 OFPATHNAME=/usr/sbin/ofpathname
 NVRAM=/usr/sbin/nvram
+FIND=/usr/bin/find
 PSERIES_PLATFORM=$(dirname $0)/pseries_platform
 
 #
@@ -288,6 +289,63 @@ dm_to_part()
         done
 }
 
+# is_nvmf_device
+# Check to see if this is a nvmf device
+#
+is_nvmf_device()
+{
+	local res
+
+	res=`$FIND /sys/devices/virtual/nvme-fabrics -name $1 2>/dev/null`
+	if [[ ${#res} = 0 ]]; then
+		echo "no"
+	else
+		echo "yes"
+	fi
+}
+
+# get_link
+# return the directory path that a link points to.
+# The only parameter is the link name.
+#
+get_link()
+{
+	local ln_name=$1;
+
+	echo `ls -l $ln_name 2>/dev/null | awk -F"->" '{print $2}'`
+}
+
+add_nvmf()
+{
+	local DEVNAME=$1
+
+	ctrl_name=$DEVNAME
+	local startctr=$ctr
+
+	local dir
+	for dir in `$FIND /sys/devices/virtual/nvme-fabrics -name "$ctrl_name"`; do
+		cd $dir
+		link=`get_link "device"`
+		cd $link
+		for slave in $PWD/*; do
+			slavedev=${slave##*/}
+			if [[ "$slavedev" == nvme[0-9]* ]] ; then
+				cd $slave
+				res=`$FIND . -name "${ctrl_name}*"`
+				if [[ ${#res} != 0 ]]; then
+					LOGICAL_NAMES[$ctr]=${slavedev}
+					ctr=$[$ctr + 1]
+				fi
+			fi
+		done
+	done
+
+	if [[ "$startctr" = "$ctr" ]] ; then
+		LOGICAL_NAMES[$ctr]=$1
+		ctr=$[$ctr + 1]
+	fi
+}
+
 add_logical()
 {
     local DEVNAME=$1
@@ -432,7 +490,30 @@ while [[ -n $1 ]]; do
 	exit -1
     else
         # add this element to the array
-	add_logical $1
+        if [[ "$1" == *"dm-"* ]] ; then
+            add_logical $1
+        else
+            if [[ "$1" == *"nvme-of"* ]]; then
+                ctrl_name=`get_logical_device_name $1`
+            else
+            	ctrl_name=$1
+            	ctrl_name=${ctrl_name##*/}
+            fi
+            ctrl_name="${ctrl_name%n[0-9]*}"
+            is_nvmf=$(is_nvmf_device $ctrl_name)
+            if [[ $is_nvmf = "yes" ]]; then
+		if [[ "$1" == *"nvme-of"* ]]; then
+			master_of_path=$1
+		else
+			master_of_path=`get_of_device_name $1`
+		fi
+                namespace_base=${master_of_path##*/}
+                DEVTYPE="nvme-of"
+                add_nvmf $ctrl_name
+            else
+                add_logical $1
+            fi
+        fi
     fi
 
     shift
@@ -453,6 +534,9 @@ if [[ ${#LOGICAL_NAMES[*]} -ne 0 ]]; then
         if [[ -z ${OF_DEVPATH[$ctr]} ]]; then
 	    # See if this is an OF pathname
 	    OF_DEVPATH[$ctr]=`get_of_device_name ${LOGICAL_NAMES[$ctr]}`
+	    if [[ $DEVTYPE = "nvme-of" ]]; then
+		    OF_DEVPATH[$ctr]=${OF_DEVPATH[$ctr]}/$namespace_base
+	    fi
 	else
 	    OF_DEVPATH[$ctr]=${LOGICAL_NAMES[$ctr]}
         fi
-- 
2.38.0

