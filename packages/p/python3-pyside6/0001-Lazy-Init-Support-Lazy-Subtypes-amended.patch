From e67404e0715d9d6a27e52dbd0be9c34643a89a03 Mon Sep 17 00:00:00 2001
From: Christian Tismer <tismer@stackless.com>
Date: Sun, 13 Oct 2024 23:29:47 +0200
Subject: [PATCH] Lazy Init: Support Lazy Subtypes, amended

The addition of nested types made it necessary to filter
subtypes out of resolveLazyClasses because incarnateType
should be called for toplevel types, only.

Task-number: PYSIDE-2404
Change-Id: I4b95c0f65c055376defb6a8e9ea888285c82a8e2
Fixes: PYSIDE-2888
Pick-to: 6.8
---
 sources/shiboken6/libshiboken/sbkmodule.cpp | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/sources/shiboken6/libshiboken/sbkmodule.cpp b/sources/shiboken6/libshiboken/sbkmodule.cpp
index acadc60..bca7383 100644
--- a/sources/shiboken6/libshiboken/sbkmodule.cpp
+++ b/sources/shiboken6/libshiboken/sbkmodule.cpp
@@ -93,8 +93,10 @@ static void incarnateHelper(PyObject *module, const std::string_view names,
         startPos = dotPos + 1;
         dotPos = names.find('.', startPos);
     }
-    // now we have the type to create.
+    // now we have the type to create. (May be done already)
     auto funcIter = nameToFunc.find(std::string(names));
+    if (funcIter == nameToFunc.end())
+        return;
     // - call this function that returns a PyTypeObject
     auto tcStruct = funcIter->second;
     auto initFunc = tcStruct.func;
@@ -174,11 +176,15 @@ void resolveLazyClasses(PyObject *module)
     // - see if there are still unloaded elements
     auto &nameToFunc = tableIter->second;
 
-    // - incarnate all types.
+    // - incarnate all toplevel types. Subtypes will be handled there.
     while (!nameToFunc.empty()) {
         auto it = nameToFunc.begin();
         auto attrNameStr = it->first;
-        incarnateType(module, attrNameStr.c_str(), nameToFunc);
+        if (attrNameStr.find('.') == std::string::npos) {
+            incarnateType(module, attrNameStr.c_str(), nameToFunc);
+        } else {
+            nameToFunc.erase(it);
+        }
     }
 }
 
-- 
2.47.0

