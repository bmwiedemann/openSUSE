From 9f0b47464bc757813384de84029e25857a54cc62 Mon Sep 17 00:00:00 2001
From: Friedemann Kleint <Friedemann.Kleint@qt.io>
Date: Wed, 2 Feb 2022 18:22:44 +0100
Subject: [PATCH 2/2] Refactor code snippets for
 QByteArray::__msetitem__()/__mgetitem__()

Fix integer types, move variable declarations to initialization,
remove superfluous variables.

As a drive-by, fix spelling in the test.

Pick-to: 6.2
Task-number: PYSIDE-1804
Change-Id: I7ed4e69ae850a63d7e213a31cb078aa40e597fb2
---
 sources/pyside6/PySide6/glue/qtcore.cpp       | 49 ++++++++-----------
 .../pyside6/tests/QtCore/qbytearray_test.py   |  8 +--
 2 files changed, 25 insertions(+), 32 deletions(-)

diff --git a/sources/pyside6/PySide6/glue/qtcore.cpp b/sources/pyside6/PySide6/glue/qtcore.cpp
index 05b4e7d2d..693cad35c 100644
--- a/sources/pyside6/PySide6/glue/qtcore.cpp
+++ b/sources/pyside6/PySide6/glue/qtcore.cpp
@@ -523,8 +523,7 @@ if (ret > 0 && ((strcmp(%1, SIGNAL(destroyed())) == 0) || (strcmp(%1, SIGNAL(des
 
 // @snippet qbytearray-mgetitem
 if (PyIndex_Check(_key)) {
-    Py_ssize_t _i;
-    _i = PyNumber_AsSsize_t(_key, PyExc_IndexError);
+    const Py_ssize_t _i = PyNumber_AsSsize_t(_key, PyExc_IndexError);
     if (_i < 0 || _i >= %CPPSELF.size()) {
         PyErr_SetString(PyExc_IndexError, "index out of bounds");
         return 0;
@@ -535,10 +534,9 @@ if (PyIndex_Check(_key)) {
         return PyBytes_FromStringAndSize(res, 1);
     }
 } else if (PySlice_Check(_key)) {
-    Py_ssize_t start, stop, step, slicelength, cur;
-    if (PySlice_GetIndicesEx(_key, %CPPSELF.count(), &start, &stop, &step, &slicelength) < 0) {
+    Py_ssize_t start, stop, step, slicelength;
+    if (PySlice_GetIndicesEx(_key, %CPPSELF.count(), &start, &stop, &step, &slicelength) < 0)
         return nullptr;
-    }
 
     QByteArray ba;
     if (slicelength <= 0) {
@@ -547,15 +545,12 @@ if (PyIndex_Check(_key)) {
         Py_ssize_t max = %CPPSELF.count();
         start = qBound(Py_ssize_t(0), start, max);
         stop = qBound(Py_ssize_t(0), stop, max);
-        QByteArray ba;
         if (start < stop)
             ba = %CPPSELF.mid(start, stop - start);
         return %CONVERTTOPYTHON[QByteArray](ba);
     } else {
-        QByteArray ba;
-        for (cur = start; slicelength > 0; cur += static_cast<size_t>(step), slicelength--) {
+        for (Py_ssize_t cur = start; slicelength > 0; cur += step, --slicelength)
             ba.append(%CPPSELF.at(cur));
-        }
         return %CONVERTTOPYTHON[QByteArray](ba);
     }
 } else {
@@ -591,7 +586,7 @@ if (PyIndex_Check(_key)) {
             PyErr_SetString(PyExc_ValueError, "bytearray must be of size 1");
             return -1;
         }
-    } else if (reinterpret_cast<PyTypeObject *>(Py_TYPE(_value)) == reinterpret_cast<PyTypeObject *>(SbkPySide6_QtCoreTypes[SBK_QBYTEARRAY_IDX])) {
+    } else if (Py_TYPE(_value) == reinterpret_cast<PyTypeObject *>(SbkPySide6_QtCoreTypes[SBK_QBYTEARRAY_IDX])) {
         if (PyObject_Length(_value) != 1) {
             PyErr_SetString(PyExc_ValueError, "QByteArray must be of size 1");
             return -1;
@@ -607,26 +602,24 @@ if (PyIndex_Check(_key)) {
     PyObject *result = Sbk_QByteArrayFunc_insert(self, args);
     Py_DECREF(args);
     Py_XDECREF(result);
-    return !result ? -1 : 0;
+    return result != nullptr ? 0: -1;
 } else if (PySlice_Check(_key)) {
-    Py_ssize_t start, stop, step, slicelength, value_length;
-    if (PySlice_GetIndicesEx(_key, %CPPSELF.count(), &start, &stop, &step, &slicelength) < 0) {
+    Py_ssize_t start, stop, step, slicelength;
+    if (PySlice_GetIndicesEx(_key, %CPPSELF.count(), &start, &stop, &step, &slicelength) < 0)
         return -1;
-    }
     // The parameter candidates are: bytes/str, bytearray, QByteArray itself.
-    // Not support iterable which contains ints between 0~255
+    // Not supported are iterables containing ints between 0~255
 
     // case 1: value is nullpre, means delete the items within the range
-    // case 2: step is 1, means shrink or expanse
+    // case 2: step is 1, means shrink or expand
     // case 3: step is not 1, then the number of slots have to equal the number of items in _value
-    QByteArray ba;
-    if (_value == nullptr || _value == Py_None) {
-        ba = QByteArray();
-        value_length = 0;
-    } else if (!(PyBytes_Check(_value) || PyByteArray_Check(_value) || reinterpret_cast<PyTypeObject *>(Py_TYPE(_value)) == reinterpret_cast<PyTypeObject *>(SbkPySide6_QtCoreTypes[SBK_QBYTEARRAY_IDX]))) {
-        PyErr_Format(PyExc_TypeError, "bytes, bytearray or QByteArray is required, not %.200s", Py_TYPE(_value)->tp_name);
-        return -1;
-    } else {
+    Py_ssize_t value_length = 0;
+    if (_value != nullptr && _value != Py_None) {
+        if (!(PyBytes_Check(_value) || PyByteArray_Check(_value)
+              || Py_TYPE(_value) == reinterpret_cast<PyTypeObject *>(SbkPySide6_QtCoreTypes[SBK_QBYTEARRAY_IDX]))) {
+               PyErr_Format(PyExc_TypeError, "bytes, bytearray or QByteArray is required, not %.200s", Py_TYPE(_value)->tp_name);
+               return -1;
+        }
         value_length = PyObject_Length(_value);
     }
 
@@ -637,9 +630,9 @@ if (PyIndex_Check(_key)) {
     }
 
     if (step != 1) {
-        int i = start;
-        for (int j = 0; j < slicelength; j++) {
-            PyObject *item = PyObject_GetItem(_value, PyLong_FromLong(j));
+        Py_ssize_t i = start;
+        for (Py_ssize_t j = 0; j < slicelength; ++j) {
+            PyObject *item = PyObject_GetItem(_value, PyLong_FromSsize_t(j));
             QByteArray temp;
             if (PyLong_Check(item)) {
                 int overflow;
@@ -656,7 +649,7 @@ if (PyIndex_Check(_key)) {
         }
         return 0;
     } else {
-        ba = %CONVERTTOCPP[QByteArray](_value);
+        QByteArray ba = %CONVERTTOCPP[QByteArray](_value);
         %CPPSELF.replace(start, slicelength, ba);
         return 0;
     }
diff --git a/sources/pyside6/tests/QtCore/qbytearray_test.py b/sources/pyside6/tests/QtCore/qbytearray_test.py
index c347a6e4d..ad8dc5382 100644
--- a/sources/pyside6/tests/QtCore/qbytearray_test.py
+++ b/sources/pyside6/tests/QtCore/qbytearray_test.py
@@ -233,7 +233,7 @@ class QByteArraySliceAssignment(unittest.TestCase):
         # shrink
         b[2:8] = QByteArray(bytes('aaa', "UTF8"))
         self.assertEqual(b, bytes('01aaa89', "UTF8"))
-        # expanse
+        # expand
         b[2:5] = QByteArray(bytes('uvwxyz', "UTF8"))
         self.assertEqual(b, bytes('01uvwxyz89', "UTF8"))
         # Delete behavior
@@ -241,7 +241,7 @@ class QByteArraySliceAssignment(unittest.TestCase):
         self.assertEqual(b, bytes('0189', "UTF8"))
 
         b = QByteArray(bytes('0123456789', "UTF8"))
-        # reverse assginment
+        # reverse assignment
         b[5:2:-1] = QByteArray(bytes('ABC', "UTF8"))
         self.assertEqual(b, bytes('012CBA6789', "UTF8"))
         # step is not 1
@@ -259,7 +259,7 @@ class QByteArraySliceAssignment(unittest.TestCase):
         # shrink
         b[2:8] = bytearray(bytes('aaa', "UTF8"))
         self.assertEqual(b, bytes('01aaa89', "UTF8"))
-        # expanse
+        # expand
         b[2:5] = bytearray(bytes('uvwxyz', "UTF8"))
         self.assertEqual(b, bytes('01uvwxyz89', "UTF8"))
         # Delete behavior
@@ -267,7 +267,7 @@ class QByteArraySliceAssignment(unittest.TestCase):
         self.assertEqual(b, bytes('0189', "UTF8"))
 
         b = QByteArray(bytes('0123456789', "UTF8"))
-        # reverse assginment
+        # reverse assignment
         b[5:2:-1] = bytearray(bytes('ABC', "UTF8"))
         self.assertEqual(b, bytes('012CBA6789', "UTF8"))
         # step is not 1
-- 
2.35.1

