From f2ada8ea7939bc8f607d88a10c92d5bb96a700b8 Mon Sep 17 00:00:00 2001
From: Werner Fink <werner@suse.de>
Date: Fri, 7 May 2021 16:36:28 +0200
Subject: [PATCH] Use new statx(2) system call to avoid hangs on NFS

Signed-off-by: Werner Fink <werner@suse.de>
---
 Makefile.am  |    4 -
 configure.ac |   24 +++++----
 src/fuser.c  |  102 ++++++++++------------------------------
 src/statx.c  |  149 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/statx.h  |   68 ++++++++++++++++++++++++++
 5 files changed, 260 insertions(+), 87 deletions(-)

--- Makefile.am
+++ Makefile.am	2021-05-07 15:04:28.611513529 +0000
@@ -64,8 +64,8 @@ src_fuser_SOURCES = \
 		    src/fuser.h \
 		    src/lists.h
 
-if WANT_TIMEOUT_STAT
-src_fuser_SOURCES += src/timeout.c src/timeout.h
+if HAVE_SYSCALL_STATX
+src_fuser_SOURCES += src/statx.c src/statx.h
 endif
 src_fuser_LDADD = @LIBINTL@
 src_killall_SOURCES = src/killall.c src/comm.h src/signals.c src/signals.h src/i18n.h
--- configure.ac
+++ configure.ac	2021-05-07 15:04:28.623513310 +0000
@@ -57,16 +57,20 @@ fi
 AC_CHECK_FUNC([name_to_handle_at],[
   AC_DEFINE([HAS_NAME_TO_HANDLE_AT], [1], [System has name_to_handle_at(2) system call])])
 
-# Use string search for network based file systems but only if the system
-# has /proc/self/mountinfo
-AC_SUBST([WITH_MOUNTINFO_LIST])
-AC_ARG_ENABLE([mountinfo_list],
-  [AS_HELP_STRING([--enable-mountinfo-list], [Use the list in /proc/self/mountinfo to replace stat(2) syscall on network file systems shares])],
-  [enable_mountinfo_list="yes"],
-  [enable_mountinfo_list="no"])
-if test "$enable_mountinfo_list" = "yes" -a -e /proc/self/mountinfo ; then
-  AC_DEFINE([WITH_MOUNTINFO_LIST], [1], [Use list in /proc/self/mountinfo to replace stat calls])
-fi
+AC_CHECK_HEADERS([sys/syscall.h])
+AC_CHECK_DECLS([SYS_statx],
+  [has_syscall_statx="yes"],
+  [has_syscall_statx="no"],
+  [[#include <sys/syscall.h>]]
+)
+AC_CHECK_FUNCS([statx])
+# Check for linux specific statx(2) system call
+AC_SUBST([HAS_SYSCALL_STATX])
+AC_ARG_ENABLE([disable_statx],
+  [AS_HELP_STRING([--disable-statx], [Do not use linux specific statx(2) system call as replacement for stat(2), lstat(2), and fstat(2)])],
+  [enable_syscall_statx="no"],
+  [enable_syscall_statx=$has_syscall_statx])
+AM_CONDITIONAL([HAVE_SYSCALL_STATX], [test "$enable_syscall_statx" = "yes"])
 
 # Enable hardened compile and link flags
 AC_ARG_ENABLE([harden_flags],
--- src/fuser.c
+++ src/fuser.c	2021-05-07 15:04:28.627513237 +0000
@@ -61,7 +61,7 @@
 #include "fuser.h"
 #include "signals.h"
 #include "i18n.h"
-#include "timeout.h"
+#include "statx.h"
 #include "comm.h"
 
 //#define DEBUG 1
@@ -119,10 +119,6 @@ static int get_fdinfo(const pid_t pid, c
 static int get_mountid(const char *path);
 #endif
 static int find_mountpoint(const char *path, mntinfo_t **mountinfo);
-#if defined(WITH_MOUNTINFO_LIST)
-static int mntstat(const char *path, struct stat *buf);
-#endif
-static stat_t thestat = stat;
 static char *expandpath(const char *path);
 static struct unixsocket_list *unixsockets = NULL;
 static struct names *names_head = NULL, *names_tail = NULL;
@@ -510,7 +506,7 @@ int parse_file(struct names *this_name,
 			free(this_name->filename);
 		this_name->filename = strdup(new);
 	}
-	if (timeout(thestat, this_name->filename, &(this_name->st), 5) != 0 ||
+	if (statn(this_name->filename, STATX_INO|STATX_TYPE, &(this_name->st)) != 0 ||
 	    find_mountpoint(this_name->filename, &mountinfo) != 0) {
 		if (errno == ENOENT)
 			fprintf(stderr,
@@ -1244,9 +1240,7 @@ int main(int argc, char *argv[])
 					opts |= OPT_INTERACTIVE;
 					break;
 				case 'I':
-#if defined(WITH_MOUNTINFO_LIST)
 					opts |= OPT_ALWAYSSTAT;
-#endif
 					break;
 				case 'k':
 					opts |= OPT_KILL;
@@ -1312,10 +1306,11 @@ int main(int argc, char *argv[])
 			continue;
 		}
 
-#if defined(WITH_MOUNTINFO_LIST)
-		if ((opts & (OPT_MOUNTS|OPT_ALWAYSSTAT)) == OPT_MOUNTS)
-			thestat = mntstat;
+#if defined(HAVE_DECL_SYS_STATX) && HAVE_DECL_SYS_STATX == 1
+		if ((opts & OPT_ALWAYSSTAT))
+			stat_flags = 0;		/* Triggers sync with e.g. remote NFS server even on autofs */
 #endif
+
 		/* an option */
 		/* Not an option, must be a file specification */
 		if ((this_name = malloc(sizeof(struct names))) == NULL)
@@ -1635,7 +1630,7 @@ static struct stat *get_pidstat(const pi
 	if ((st = (struct stat *)malloc(sizeof(struct stat))) == NULL)
 		return NULL;
 	snprintf(pathname, 256, "/proc/%d/%s", pid, filename);
-	if (timeout(thestat, pathname, st, 5) != 0) {
+	if (statn(pathname, STATX_UID|STATX_INO|STATX_TYPE, st) != 0) {
 		free(st);
 		return NULL;
 	}
@@ -1681,7 +1676,7 @@ check_dir(const pid_t pid, const char *d
 		snprintf(filepath, sizeof filepath - 1, "/proc/%d/%s/%s",
 			 pid, dirname, direntry->d_name);
 
-		if (timeout(thestat, filepath, &st, 5) != 0) {
+		if (statn(filepath, STATX_INO, &st) != 0) {
 			if (errno != ENOENT && errno != ENOTDIR) {
 				fprintf(stderr, _("Cannot stat file %s: %s\n"),
 					filepath, strerror(errno));
@@ -1747,7 +1742,7 @@ check_dir(const pid_t pid, const char *d
 				if (thedev != ino_tmp->device)
 					continue;
 				if (!st.st_ino
-				    && timeout(thestat, filepath, &st, 5) != 0) {
+				    && statn(filepath, STATX_INO, &st) != 0) {
 					fprintf(stderr,
 						_("Cannot stat file %s: %s\n"),
 						filepath, strerror(errno));
@@ -1845,11 +1840,11 @@ static uid_t getpiduid(const pid_t pid)
 
 	if (asprintf(&pathname, "/proc/%d", pid) < 0)
 		return 0;
-	if (timeout(thestat, pathname, &st, 5) != 0) {
-        free(pathname);
+	if (statn(pathname, STATX_UID, &st) != 0) {
+		free(pathname);
 		return 0;
-    }
-    free(pathname);
+	}
+	free(pathname);
 	return st.st_uid;
 }
 
@@ -1887,7 +1882,7 @@ void fill_unix_cache(struct unixsocket_l
 		path = scanned_path;
 		if (*scanned_path == '@')
 			scanned_path++;
-		if (timeout(thestat, scanned_path, &st, 5) < 0) {
+		if (statn(scanned_path, STATX_INO, &st) < 0) {
 			free(path);
 			continue;
 		}
@@ -2022,7 +2017,7 @@ static dev_t find_net_dev(void)
 		fprintf(stderr, _("Cannot open a network socket.\n"));
 		return -1;
 	}
-	if (fstat(skt, &st) != 0) {
+	if (fstatn(skt, STATX_INO, &st) != 0) {
 		fprintf(stderr, _("Cannot find socket's device number.\n"));
 		close(skt);
 		return -1;
@@ -2059,7 +2054,7 @@ scan_knfsd(struct names *names_head, str
 		if ((find_space = strpbrk(line, " \t")) == NULL)
 			continue;
 		*find_space = '\0';
-		if (timeout(thestat, line, &st, 5) != 0) {
+		if (statn(line, STATX_INO, &st) != 0) {
 			continue;
 		}
 		/* Scan the devices */
@@ -2093,7 +2088,7 @@ scan_mounts(struct names *names_head, st
 		mntinfo_t *mnt = list_entry(ptr, mntinfo_t);
 		const char *find_mountp = mnt->mpoint;
 
-		if (timeout(thestat, find_mountp, &st, 5) != 0)
+		if (statn(find_mountp, STATX_INO, &st) != 0)
 			continue;
 
 		/* Scan the devices */
@@ -2143,7 +2138,7 @@ scan_swaps(struct names *names_head, str
 			if (*find_space == '\0')
 				continue;
 		}
-		if (timeout(thestat, line, &st, 5) != 0) {
+		if (statn(line, STATX_INO, &st) != 0) {
 			continue;
 		}
 		/* Scan the devices */
@@ -2240,10 +2235,10 @@ init_mntinfo(void)
 		&mid, &parid, &maj, &min, &mpoint[0], &type[0], &devname[0]) == 7) {
 		struct stat st;
 		mntinf = add_mntinfo(mpoint, type, mid, parid, makedev(maj, min));
-		if (mntinf && strncmp(devname, "/dev/", 5) == 0 && stat(devname, &st) == 0) {
+		if (mntinf && strncmp(devname, "/dev/", 5) == 0 && statn(devname, 0, &st) == 0) {
 			if (st.st_rdev != 0 && mntinf->dev != st.st_rdev) {
 				mntinf->vol = st.st_rdev;
-				stat(mpoint, &st);
+				statn(mpoint, 0, &st);
 				mntinf->dev = st.st_dev;	/* stat(2) on binary does not see subvol dev */
 			}
 		}
@@ -2255,7 +2250,7 @@ init_mntinfo(void)
 	parid = -1;
 	while (fscanf (mnt, "%s %s %s %*[^\n]", &devname[0], &mpoint[0], &type[0]) == 3) {
 		struct stat st;
-		if (stat(mpoint, &st) != 0) {
+		if (statn(mpoint, 0, &st) != 0) {
 			if (errno != EACCES) {
 				fprintf(stderr, _("Cannot stat %s: %s\n"),
 					mpoint, strerror(errno));
@@ -2264,7 +2259,7 @@ init_mntinfo(void)
 			st.st_dev = (dev_t)-1;
 		}
 		mntinf = add_mntinfo(mpoint, type, mid++, parid, st.st_dev);
-		if (mntinf && strncmp(devname, "/dev/", 5) == 0 && stat(devname, &st) == 0) {
+		if (mntinf && strncmp(devname, "/dev/", 5) == 0 && statn(devname, 0, &st) == 0) {
 			if (st.st_rdev != 0 && mntinf->dev != st.st_rdev)
 				mntinf->vol = st.st_rdev;
 		}
@@ -2288,7 +2283,7 @@ get_fdinfo(const pid_t pid, const char *
 	struct stat st;
  
 	if (!mynamespace) {
-		if (stat("/proc/self/ns/mnt", &st) != 0) {
+		if (statn("/proc/self/ns/mnt", STATX_INO, &st) != 0) {
 			fprintf(stderr, _("Cannot stat %s: %s\n"),
 				"/proc/self/ns/mnt", strerror(errno));
 			exit(1);
@@ -2323,7 +2318,7 @@ get_fdinfo(const pid_t pid, const char *
 out:
 # if defined(HAS_NAME_TO_HANDLE_AT)
 	snprintf(pathname, 256, "/proc/%d/ns/mnt", pid);
-	if (stat(pathname, &st) == 0 && mynamespace != st.st_ino) {
+	if (statn(pathname, STATX_INO, &st) == 0 && mynamespace != st.st_ino) {
 		char *realname;
 		snprintf(pathname, 256, "/proc/%d/fd/%s", pid, fd);
 		realname = expandpath(pathname);
@@ -2338,7 +2333,7 @@ out:
 		struct stat lst;
 
 		snprintf(pathname, 256, "/proc/%d/fd/%s", pid, fd);
-		if (!flags && lstat(pathname, &lst) == 0) {
+		if (!flags && lstatn(pathname, STATX_MODE, &lst) == 0) {
 			if (lst.st_mode & S_IWUSR)
 				info->flags |= O_WRONLY;
 			ret++;
@@ -2411,7 +2406,7 @@ find_mountpoint(const char *path, mntinf
 
 			/* could be a chroot or a container */
 
-			if (stat(path, &st) != 0) {
+			if (statn(path, 0, &st) != 0) {
 				if (errno != EACCES) {
 					fprintf(stderr, _("Cannot stat %s: %s\n"),
 						path, strerror(errno));
@@ -2443,7 +2438,7 @@ find_mountpoint(const char *path, mntinf
 
 					/* could be a chroot or a container */
 
-					if (stat(use, &st) != 0) {
+					if (statn(use, 0, &st) != 0) {
 						if (errno != EACCES) {
 							fprintf(stderr, _("Cannot stat %s: %s\n"),
 								use, strerror(errno));
@@ -2481,49 +2476,6 @@ out:
 	return ret;
 }
 
-#if defined(WITH_MOUNTINFO_LIST)
-/*
- * Determine device of links below /proc/
- */
-static int mntstat(const char *path, struct stat *buf)
-{
-	char name[PATH_MAX + 1];
-	const char *use;
-	mntinfo_t *mnt;
-
-	if ((use = realpath(path, name)) == NULL || *use != '/')
-	{
-		if (errno == ENOENT)
-			return -1;
-		/*
-		 * Could be a special file (socket, pipe, inotify)
-		 */
-		errno = 0;
-		return stat(path, buf);
-	}
-	if (strncmp("/dev/", use, 5) == 0) {
-		/*
-		 * Could be a special file (socket, pipe, inotify)
-		 */
-		errno = 0;
-		return stat(path, buf);
-	}
-
-	if (find_mountpoint(use, &mnt) < 0) {
-		errno = ENOENT;
-		return -1;
-	}
-
-	if (mnt->isremote) {
-		buf->st_dev = mnt->dev;
-		buf->st_ino = mnt->id;	    /* inode substitute */
-		return 0;		    /* found on NFS */
-	}
-
-	return stat(path, buf);
-}
-#endif				/* WITH_MOUNTINFO_LIST */
-
 /*
  * Somehow the realpath(3) glibc function call, nevertheless
  * it avoids lstat(2) system calls.
--- src/statx.c
+++ src/statx.c	2021-05-07 15:04:28.627513237 +0000
@@ -0,0 +1,149 @@
+/*
+ * statx.c - Map modern statx(2) system call to older stat(2), lstat(2),
+ *	     and fstat(2) replacements named {,l,f}statn()
+ *
+ * Copyright (C) 2018 Werner Fink
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifndef HAVE_STATX
+# define _ASM_GENERIC_FCNTL_H	/* Avoid collisions between asm/fcntl.h and bits/fcntl.h ! */
+# include <linux/fcntl.h>	/* Definition of AT_* and AT_STATX_* constants ! */
+#endif
+#include <fcntl.h>		/* Definition of AT_* constants */
+#include <sys/stat.h>
+#ifndef HAVE_STATX
+# ifndef STATX_TYPE
+#  include <linux/stat.h>	/* Provides 'struct statx' and STATX_* ! */
+# endif
+#endif
+#include <sys/sysmacros.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+int stat_flags = AT_NO_AUTOMOUNT|AT_STATX_DONT_SYNC;
+
+int statn(const char *pathname, unsigned int mask, struct stat *st)
+{
+    int flags = stat_flags;
+    int dirfd = pathname && *pathname == '/' ? 0 : AT_FDCWD;
+    int ret;
+    struct statx stx;
+
+#ifndef HAVE_STATX
+    ret = syscall(SYS_statx, dirfd, pathname, flags, mask, &stx);
+#else
+    ret = statx(dirfd, pathname, flags, mask, &stx);
+#endif
+    if (ret >= 0) {
+	st->st_dev  = makedev(stx.stx_dev_major,  stx.stx_dev_minor);
+	st->st_rdev = makedev(stx.stx_rdev_major, stx.stx_rdev_minor);
+
+	st->st_ino  = stx.stx_ino;
+	st->st_mode = stx.stx_mode;
+	st->st_nlink = stx.stx_nlink;
+	st->st_uid = stx.stx_uid;
+	st->st_gid = stx.stx_gid;
+	st->st_size = stx.stx_size;
+	st->st_blksize = stx.stx_blksize;
+	st->st_blocks = stx.stx_blocks;
+
+	st->st_atim.tv_sec = stx.stx_atime.tv_sec;
+	st->st_atim.tv_nsec = stx.stx_atime.tv_nsec;
+	st->st_mtim.tv_sec = stx.stx_mtime.tv_sec;
+	st->st_mtim.tv_nsec = stx.stx_mtime.tv_nsec;
+	st->st_ctim.tv_sec = stx.stx_ctime.tv_sec;
+	st->st_ctim.tv_nsec = stx.stx_ctime.tv_nsec;
+    }
+    return ret;
+}
+
+int fstatn(int fd, unsigned int mask, struct stat *st)
+{
+    int flags = AT_EMPTY_PATH|stat_flags;
+    int ret;
+    struct statx stx;
+
+#ifndef HAVE_STATX
+    ret = syscall(SYS_statx, fd, "", flags, mask, &stx);
+#else
+    ret = statx(fd, "", flags, mask, &stx);
+#endif
+    if (ret >= 0) {
+	st->st_dev  = makedev(stx.stx_dev_major,  stx.stx_dev_minor);
+	st->st_rdev = makedev(stx.stx_rdev_major, stx.stx_rdev_minor);
+
+	st->st_ino  = stx.stx_ino;
+	st->st_mode = stx.stx_mode;
+	st->st_nlink = stx.stx_nlink;
+	st->st_uid = stx.stx_uid;
+	st->st_gid = stx.stx_gid;
+	st->st_size = stx.stx_size;
+	st->st_blksize = stx.stx_blksize;
+	st->st_blocks = stx.stx_blocks;
+
+	st->st_atim.tv_sec = stx.stx_atime.tv_sec;
+	st->st_atim.tv_nsec = stx.stx_atime.tv_nsec;
+	st->st_mtim.tv_sec = stx.stx_mtime.tv_sec;
+	st->st_mtim.tv_nsec = stx.stx_mtime.tv_nsec;
+	st->st_ctim.tv_sec = stx.stx_ctime.tv_sec;
+	st->st_ctim.tv_nsec = stx.stx_ctime.tv_nsec;
+    }
+    return ret;
+}
+
+int lstatn(const char *pathname, unsigned int mask, struct stat *st)
+{
+    int flags = AT_SYMLINK_NOFOLLOW|stat_flags;
+    int dirfd = pathname && *pathname == '/' ? 0 : AT_FDCWD;
+    int ret;
+    struct statx stx;
+
+#ifndef HAVE_STATX
+    ret = syscall(SYS_statx, dirfd, pathname, flags, mask, &stx);
+#else
+    ret = statx(dirfd, pathname, flags, mask, &stx);
+#endif
+    if (ret >= 0) {
+	st->st_dev  = makedev(stx.stx_dev_major,  stx.stx_dev_minor);
+	st->st_rdev = makedev(stx.stx_rdev_major, stx.stx_rdev_minor);
+
+	st->st_ino  = stx.stx_ino;
+	st->st_mode = stx.stx_mode;
+	st->st_nlink = stx.stx_nlink;
+	st->st_uid = stx.stx_uid;
+	st->st_gid = stx.stx_gid;
+	st->st_size = stx.stx_size;
+	st->st_blksize = stx.stx_blksize;
+	st->st_blocks = stx.stx_blocks;
+
+	st->st_atim.tv_sec = stx.stx_atime.tv_sec;
+	st->st_atim.tv_nsec = stx.stx_atime.tv_nsec;
+	st->st_mtim.tv_sec = stx.stx_mtime.tv_sec;
+	st->st_mtim.tv_nsec = stx.stx_mtime.tv_nsec;
+	st->st_ctim.tv_sec = stx.stx_ctime.tv_sec;
+	st->st_ctim.tv_nsec = stx.stx_ctime.tv_nsec;
+    }
+    return ret;
+}
--- src/statx.h
+++ src/statx.h	2021-05-07 15:04:28.627513237 +0000
@@ -0,0 +1,68 @@
+/*
+ * statx.h - Map modern statx(2) system call to older stat(2), lstat(2),
+ *           and fstat(2) replacements named {,l,f}statn()
+ *
+ * Copyright (C) 2018 Werner Fink
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _STATX_H
+#define _STATX_H
+
+extern int stat_flags;
+#if defined(HAVE_DECL_SYS_STATX) && HAVE_DECL_SYS_STATX == 1
+# ifndef HAVE_STATX
+#  define _ASM_GENERIC_FCNTL_H	/* Avoid collisions between asm/fcntl.h and bits/fcntl.h ! */
+#  include <linux/fcntl.h>	/* Definition of AT_* and AT_STATX_* constants ! */
+#  ifndef STATX_TYPE
+#   include <linux/stat.h>	/* Provides 'struct statx' and STATX_* ! */
+#  endif
+# endif
+extern int statn(const char*, unsigned int, struct stat*);
+extern int fstatn(int, unsigned int, struct stat*);
+extern int lstatn(const char*, unsigned int, struct stat*);
+#else
+extern inline int
+statn(const char *path, unsigned int mask __attribute__((unused)), struct stat *st)
+{
+    return stat(path, st);
+}
+extern inline int
+fstatn(int fd, unsigned int mask __attribute__((unused)), struct stat *st)
+{
+    return fstat(fd, st);
+}
+extern inline int
+lstatn(const char *path, unsigned int mask __attribute__((unused)), struct stat *st)
+{
+    return lstat(path, st);
+}
+#define STATX_TYPE		0
+#define STATX_MODE		0
+#define STATX_NLINK		0
+#define STATX_UID		0
+#define STATX_GID		0
+#define STATX_ATIME		0
+#define STATX_MTIME		0
+#define STATX_CTIME		0
+#define STATX_INO		0
+#define STATX_SIZE		0
+#define STATX_BLOCKS		0
+#define STATX_BASIC_STATS	0
+#define STATX_BTIME		0
+#define STATX_ALL		0
+#endif
+#endif
