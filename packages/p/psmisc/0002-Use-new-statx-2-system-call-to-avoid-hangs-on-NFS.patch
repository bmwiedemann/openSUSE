From 9f3910df62bcc1f726b8e84f9ffc40c4d7916eac Mon Sep 17 00:00:00 2001
From: Werner Fink <werner@suse.de>
Date: Thu, 14 Jan 2021 11:37:46 +0100
Subject: [PATCH] Use new statx(2) system call to avoid hangs on NFS

Signed-off-by: Werner Fink <werner@suse.de>
---
 Makefile.am  |    4 -
 configure.ac |   38 +++++----------
 src/fuser.c  |   98 +++++++++-----------------------------
 src/statx.c  |  149 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/statx.h  |   68 ++++++++++++++++++++++++++
 5 files changed, 258 insertions(+), 99 deletions(-)

--- Makefile.am
+++ Makefile.am	2021-01-14 11:29:22.011223930 +0000
@@ -64,8 +64,8 @@ src_fuser_SOURCES = \
 		    src/fuser.h \
 		    src/lists.h
 
-if WANT_TIMEOUT_STAT
-src_fuser_SOURCES += src/timeout.c src/timeout.h
+if HAVE_SYSCALL_STATX
+src_fuser_SOURCES += src/statx.c src/statx.h
 endif
 src_fuser_LDADD = @LIBINTL@
 src_killall_SOURCES = src/killall.c src/comm.h src/signals.c src/signals.h src/i18n.h
--- configure.ac
+++ configure.ac	2021-01-14 11:29:22.011223930 +0000
@@ -30,20 +30,6 @@ if test "$enable_selinux" = "yes"; then
 fi
 AC_SUBST([SELINUX_LIB])
 
-# Call fork before all stat calls to stop hanging on NFS mounts
-AC_SUBST([WITH_TIMEOUT_STAT])
-AC_ARG_ENABLE([timeout_stat],
-  [AS_HELP_STRING([--enable-timeout-stat], [Use a timeout on stat calls (optional with argument "static" for a static background process)])],
-  [enable_timeout_stat=$enableval],
-  [enable_timeout_stat="no"])
-if test "$enable_timeout_stat" = "yes"; then
-  AC_DEFINE([WITH_TIMEOUT_STAT], [1], [Use timeout on stat calls])
-fi
-if test "$enable_timeout_stat" = "static"; then
-  AC_DEFINE([WITH_TIMEOUT_STAT], [2], [Use timeout on stat calls])
-fi
-AM_CONDITIONAL([WANT_TIMEOUT_STAT], [test "$enable_timeout_stat" = "static"])
-
 # Use /proc/self/mountinfo if available
 if test -e /proc/self/mountinfo ; then
   AC_DEFINE([HAS_MOUNTINFO], [1], [System has /proc/self/mountinfo which can used instead /proc(/self)/mounts])
@@ -57,16 +43,20 @@ fi
 AC_CHECK_FUNC([name_to_handle_at],[
   AC_DEFINE([HAS_NAME_TO_HANDLE_AT], [1], [System has name_to_handle_at(2) system call])])
 
-# Use string search for network based file systems but only if the system
-# has /proc/self/mountinfo
-AC_SUBST([WITH_MOUNTINFO_LIST])
-AC_ARG_ENABLE([mountinfo_list],
-  [AS_HELP_STRING([--enable-mountinfo-list], [Use the list in /proc/self/mountinfo to replace stat(2) syscall on network file systems shares])],
-  [enable_mountinfo_list="yes"],
-  [enable_mountinfo_list="no"])
-if test "$enable_mountinfo_list" = "yes" -a -e /proc/self/mountinfo ; then
-  AC_DEFINE([WITH_MOUNTINFO_LIST], [1], [Use list in /proc/self/mountinfo to replace stat calls])
-fi
+AC_CHECK_HEADERS([sys/syscall.h])
+AC_CHECK_DECLS([SYS_statx],
+  [has_syscall_statx="yes"],
+  [has_syscall_statx="no"],
+  [[#include <sys/syscall.h>]]
+)
+AC_CHECK_FUNCS([statx])
+# Check for linux specific statx(2) system call
+AC_SUBST([HAS_SYSCALL_STATX])
+AC_ARG_ENABLE([disable_statx],
+  [AS_HELP_STRING([--disable-statx], [Do not use linux specific statx(2) system call as replacement for stat(2), lstat(2), and fstat(2)])],
+  [enable_syscall_statx="no"],
+  [enable_syscall_statx=$has_syscall_statx])
+AM_CONDITIONAL([HAVE_SYSCALL_STATX], [test "$enable_syscall_statx" = "yes"])
 
 # Enable hardened compile and link flags
 AC_ARG_ENABLE([harden_flags],
--- src/fuser.c
+++ src/fuser.c	2021-01-14 11:30:10.750278604 +0000
@@ -63,7 +63,7 @@
 #include "fuser.h"
 #include "signals.h"
 #include "i18n.h"
-#include "timeout.h"
+#include "statx.h"
 #include "comm.h"
 
 //#define DEBUG 1
@@ -118,10 +118,6 @@ static void clear_mntinfo(void) __attrib
 static void init_mntinfo(void) __attribute__ ((__constructor__));
 static int get_fdinfo(const pid_t pid, const char *fd, struct fdinfo *info);
 static int find_mountpoint(const char *path, mntinfo_t **mountinfo);
-#if defined(WITH_MOUNTINFO_LIST)
-static int mntstat(const char *path, struct stat *buf);
-#endif
-static stat_t thestat = stat;
 static char *expandpath(const char *path);
 static struct unixsocket_list *unixsockets = NULL;
 static struct names *names_head = NULL, *names_tail = NULL;
@@ -509,7 +505,7 @@ int parse_file(struct names *this_name,
 			free(this_name->filename);
 		this_name->filename = strdup(new);
 	}
-	if (timeout(thestat, this_name->filename, &(this_name->st), 5) != 0 ||
+	if (statn(this_name->filename, STATX_INO|STATX_TYPE, &(this_name->st)) != 0 ||
 	    find_mountpoint(this_name->filename, &mountinfo) != 0) {
 		if (errno == ENOENT)
 			fprintf(stderr,
@@ -1245,9 +1241,7 @@ int main(int argc, char *argv[])
 					opts |= OPT_INTERACTIVE;
 					break;
 				case 'I':
-#if defined(WITH_MOUNTINFO_LIST)
 					opts |= OPT_ALWAYSSTAT;
-#endif
 					break;
 				case 'k':
 					opts |= OPT_KILL;
@@ -1313,10 +1307,11 @@ int main(int argc, char *argv[])
 			continue;
 		}
 
-#if defined(WITH_MOUNTINFO_LIST)
-		if ((opts & (OPT_MOUNTS|OPT_ALWAYSSTAT)) == OPT_MOUNTS)
-			thestat = mntstat;
+#if defined(HAVE_DECL_SYS_STATX) && HAVE_DECL_SYS_STATX == 1
+		if ((opts & OPT_ALWAYSSTAT))
+			stat_flags = 0;		/* Triggers sync with e.g. remote NFS server even on autofs */
 #endif
+
 		/* an option */
 		/* Not an option, must be a file specification */
 		if ((this_name = malloc(sizeof(struct names))) == NULL)
@@ -1636,7 +1631,7 @@ static struct stat *get_pidstat(const pi
 	if ((st = (struct stat *)malloc(sizeof(struct stat))) == NULL)
 		return NULL;
 	snprintf(pathname, 256, "/proc/%d/%s", pid, filename);
-	if (timeout(thestat, pathname, st, 5) != 0) {
+	if (statn(pathname, STATX_UID|STATX_INO|STATX_TYPE, st) != 0) {
 		free(st);
 		return NULL;
 	}
@@ -1683,7 +1678,7 @@ check_dir(const pid_t pid, const char *d
 		snprintf(filepath, sizeof filepath - 1, "/proc/%d/%s/%s",
 			 pid, dirname, direntry->d_name);
 
-		if (timeout(thestat, filepath, &st, 5) != 0) {
+		if (statn(filepath, STATX_INO, &st) != 0) {
 			if (errno != ENOENT && errno != ENOTDIR) {
 				fprintf(stderr, _("Cannot stat file %s: %s\n"),
 					filepath, strerror(errno));
@@ -1740,7 +1735,7 @@ check_dir(const pid_t pid, const char *d
 				if (thedev != ino_tmp->device)
 					continue;
 				if (!st.st_ino
-				    && timeout(thestat, filepath, &st, 5) != 0) {
+				    && statn(filepath, STATX_INO, &st) != 0) {
 					fprintf(stderr,
 						_("Cannot stat file %s: %s\n"),
 						filepath, strerror(errno));
@@ -1838,11 +1833,11 @@ static uid_t getpiduid(const pid_t pid)
 
 	if (asprintf(&pathname, "/proc/%d", pid) < 0)
 		return 0;
-	if (timeout(thestat, pathname, &st, 5) != 0) {
-        free(pathname);
+	if (statn(pathname, STATX_UID, &st) != 0) {
+		free(pathname);
 		return 0;
-    }
-    free(pathname);
+	}
+	free(pathname);
 	return st.st_uid;
 }
 
@@ -1880,7 +1875,7 @@ void fill_unix_cache(struct unixsocket_l
 		path = scanned_path;
 		if (*scanned_path == '@')
 			scanned_path++;
-		if (timeout(thestat, scanned_path, &st, 5) < 0) {
+		if (statn(scanned_path, STATX_INO, &st) < 0) {
 			free(path);
 			continue;
 		}
@@ -2015,7 +2010,7 @@ static dev_t find_net_dev(void)
 		fprintf(stderr, _("Cannot open a network socket.\n"));
 		return -1;
 	}
-	if (fstat(skt, &st) != 0) {
+	if (fstatn(skt, STATX_INO, &st) != 0) {
 		fprintf(stderr, _("Cannot find socket's device number.\n"));
 		close(skt);
 		return -1;
@@ -2052,7 +2047,7 @@ scan_knfsd(struct names *names_head, str
 		if ((find_space = strpbrk(line, " \t")) == NULL)
 			continue;
 		*find_space = '\0';
-		if (timeout(thestat, line, &st, 5) != 0) {
+		if (statn(line, STATX_INO, &st) != 0) {
 			continue;
 		}
 		/* Scan the devices */
@@ -2086,7 +2081,7 @@ scan_mounts(struct names *names_head, st
 		mntinfo_t *mnt = list_entry(ptr, mntinfo_t);
 		const char *find_mountp = mnt->mpoint;
 
-		if (timeout(thestat, find_mountp, &st, 5) != 0)
+		if (statn(find_mountp, STATX_INO, &st) != 0)
 			continue;
 
 		/* Scan the devices */
@@ -2136,7 +2131,7 @@ scan_swaps(struct names *names_head, str
 			if (*find_space == '\0')
 				continue;
 		}
-		if (timeout(thestat, line, &st, 5) != 0) {
+		if (statn(line, STATX_INO, &st) != 0) {
 			continue;
 		}
 		/* Scan the devices */
@@ -2228,10 +2223,10 @@ init_mntinfo(void)
 		&mid, &parid, &maj, &min, &mpoint[0], &type[0], &devname[0]) == 7) {
 		struct stat st;
 		mntinf = add_mntinfo(mpoint, type, mid, parid, makedev(maj, min));
-		if (mntinf && strncmp(devname, "/dev/", 5) == 0 && stat(devname, &st) == 0) {
+		if (mntinf && strncmp(devname, "/dev/", 5) == 0 && statn(devname, 0, &st) == 0) {
 			if (st.st_rdev != 0 && mntinf->dev != st.st_rdev) {
 				mntinf->vol = st.st_rdev;
-				stat(mpoint, &st);
+				statn(mpoint, 0, &st);
 				mntinf->dev = st.st_dev;	/* stat(2) on binary does not see subvol dev */
 			}
 		}
@@ -2243,7 +2238,7 @@ init_mntinfo(void)
 	parid = -1;
 	while (fscanf (mnt, "%s %s %s %*[^\n]", &devname[0], &mpoint[0], &type[0]) == 3) {
 		struct stat st;
-		if (stat(mpoint, &st) != 0) {
+		if (statn(mpoint, 0, &st) != 0) {
 			if (errno != EACCES) {
 				fprintf(stderr, _("Cannot stat %s: %s\n"),
 					mpoint, strerror(errno));
@@ -2252,7 +2247,7 @@ init_mntinfo(void)
 			st.st_dev = (dev_t)-1;
 		}
 		mntinf = add_mntinfo(mpoint, type, mid++, parid, st.st_dev);
-		if (mntinf && strncmp(devname, "/dev/", 5) == 0 && stat(devname, &st) == 0) {
+		if (mntinf && strncmp(devname, "/dev/", 5) == 0 && statn(devname, 0, &st) == 0) {
 			if (st.st_rdev != 0 && mntinf->dev != st.st_rdev)
 				mntinf->vol = st.st_rdev;
 		}
@@ -2302,7 +2297,7 @@ out:
 		struct stat lst;
 
 		snprintf(pathname, 256, "/proc/%d/fd/%s", pid, fd);
-		if (!flags && lstat(pathname, &lst) == 0) {
+		if (!flags && lstatn(pathname, STATX_MODE, &lst) == 0) {
 			if (lst.st_mode & S_IWUSR)
 				info->flags |= O_WRONLY;
 			ret++;
@@ -2375,7 +2370,7 @@ find_mountpoint(const char *path, mntinf
 
 			/* could be a chroot or a container */
 
-			if (stat(path, &st) != 0) {
+			if (statn(path, 0, &st) != 0) {
 				if (errno != EACCES) {
 					fprintf(stderr, _("Cannot stat %s: %s\n"),
 						path, strerror(errno));
@@ -2407,7 +2402,7 @@ find_mountpoint(const char *path, mntinf
 
 					/* could be a chroot or a container */
 
-					if (stat(use, &st) != 0) {
+					if (statn(use, 0, &st) != 0) {
 						if (errno != EACCES) {
 							fprintf(stderr, _("Cannot stat %s: %s\n"),
 								use, strerror(errno));
@@ -2445,49 +2440,6 @@ out:
 	return ret;
 }
 
-#if defined(WITH_MOUNTINFO_LIST)
-/*
- * Determine device of links below /proc/
- */
-static int mntstat(const char *path, struct stat *buf)
-{
-	char name[PATH_MAX + 1];
-	const char *use;
-	mntinfo_t *mnt;
-
-	if ((use = realpath(path, name)) == NULL || *use != '/')
-	{
-		if (errno == ENOENT)
-			return -1;
-		/*
-		 * Could be a special file (socket, pipe, inotify)
-		 */
-		errno = 0;
-		return stat(path, buf);
-	}
-	if (strncmp("/dev/", use, 5) == 0) {
-		/*
-		 * Could be a special file (socket, pipe, inotify)
-		 */
-		errno = 0;
-		return stat(path, buf);
-	}
-
-	if (find_mountpoint(use, &mnt) < 0) {
-		errno = ENOENT;
-		return -1;
-	}
-
-	if (mnt->isremote) {
-		buf->st_dev = mnt->dev;
-		buf->st_ino = mnt->id;	    /* inode substitute */
-		return 0;		    /* found on NFS */
-	}
-
-	return stat(path, buf);
-}
-#endif				/* WITH_MOUNTINFO_LIST */
-
 /*
  * Somehow the realpath(3) glibc function call, nevertheless
  * it avoids lstat(2) system calls.
--- src/statx.c
+++ src/statx.c	2021-01-14 11:29:22.015223853 +0000
@@ -0,0 +1,149 @@
+/*
+ * statx.c - Map modern statx(2) system call to older stat(2), lstat(2),
+ *	     and fstat(2) replacements named {,l,f}statn()
+ *
+ * Copyright (C) 2018 Werner Fink
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifndef HAVE_STATX
+# define _ASM_GENERIC_FCNTL_H	/* Avoid collisions between asm/fcntl.h and bits/fcntl.h ! */
+# include <linux/fcntl.h>	/* Definition of AT_* and AT_STATX_* constants ! */
+#endif
+#include <fcntl.h>		/* Definition of AT_* constants */
+#include <sys/stat.h>
+#ifndef HAVE_STATX
+# ifndef STATX_TYPE
+#  include <linux/stat.h>	/* Provides 'struct statx' and STATX_* ! */
+# endif
+#endif
+#include <sys/sysmacros.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+int stat_flags = AT_NO_AUTOMOUNT|AT_STATX_DONT_SYNC;
+
+int statn(const char *pathname, unsigned int mask, struct stat *st)
+{
+    int flags = stat_flags;
+    int dirfd = pathname && *pathname == '/' ? 0 : AT_FDCWD;
+    int ret;
+    struct statx stx;
+
+#ifndef HAVE_STATX
+    ret = syscall(SYS_statx, dirfd, pathname, flags, mask, &stx);
+#else
+    ret = statx(dirfd, pathname, flags, mask, &stx);
+#endif
+    if (ret >= 0) {
+	st->st_dev  = makedev(stx.stx_dev_major,  stx.stx_dev_minor);
+	st->st_rdev = makedev(stx.stx_rdev_major, stx.stx_rdev_minor);
+
+	st->st_ino  = stx.stx_ino;
+	st->st_mode = stx.stx_mode;
+	st->st_nlink = stx.stx_nlink;
+	st->st_uid = stx.stx_uid;
+	st->st_gid = stx.stx_gid;
+	st->st_size = stx.stx_size;
+	st->st_blksize = stx.stx_blksize;
+	st->st_blocks = stx.stx_blocks;
+
+	st->st_atim.tv_sec = stx.stx_atime.tv_sec;
+	st->st_atim.tv_nsec = stx.stx_atime.tv_nsec;
+	st->st_mtim.tv_sec = stx.stx_mtime.tv_sec;
+	st->st_mtim.tv_nsec = stx.stx_mtime.tv_nsec;
+	st->st_ctim.tv_sec = stx.stx_ctime.tv_sec;
+	st->st_ctim.tv_nsec = stx.stx_ctime.tv_nsec;
+    }
+    return ret;
+}
+
+int fstatn(int fd, unsigned int mask, struct stat *st)
+{
+    int flags = AT_EMPTY_PATH|stat_flags;
+    int ret;
+    struct statx stx;
+
+#ifndef HAVE_STATX
+    ret = syscall(SYS_statx, fd, "", flags, mask, &stx);
+#else
+    ret = statx(fd, "", flags, mask, &stx);
+#endif
+    if (ret >= 0) {
+	st->st_dev  = makedev(stx.stx_dev_major,  stx.stx_dev_minor);
+	st->st_rdev = makedev(stx.stx_rdev_major, stx.stx_rdev_minor);
+
+	st->st_ino  = stx.stx_ino;
+	st->st_mode = stx.stx_mode;
+	st->st_nlink = stx.stx_nlink;
+	st->st_uid = stx.stx_uid;
+	st->st_gid = stx.stx_gid;
+	st->st_size = stx.stx_size;
+	st->st_blksize = stx.stx_blksize;
+	st->st_blocks = stx.stx_blocks;
+
+	st->st_atim.tv_sec = stx.stx_atime.tv_sec;
+	st->st_atim.tv_nsec = stx.stx_atime.tv_nsec;
+	st->st_mtim.tv_sec = stx.stx_mtime.tv_sec;
+	st->st_mtim.tv_nsec = stx.stx_mtime.tv_nsec;
+	st->st_ctim.tv_sec = stx.stx_ctime.tv_sec;
+	st->st_ctim.tv_nsec = stx.stx_ctime.tv_nsec;
+    }
+    return ret;
+}
+
+int lstatn(const char *pathname, unsigned int mask, struct stat *st)
+{
+    int flags = AT_SYMLINK_NOFOLLOW|stat_flags;
+    int dirfd = pathname && *pathname == '/' ? 0 : AT_FDCWD;
+    int ret;
+    struct statx stx;
+
+#ifndef HAVE_STATX
+    ret = syscall(SYS_statx, dirfd, pathname, flags, mask, &stx);
+#else
+    ret = statx(dirfd, pathname, flags, mask, &stx);
+#endif
+    if (ret >= 0) {
+	st->st_dev  = makedev(stx.stx_dev_major,  stx.stx_dev_minor);
+	st->st_rdev = makedev(stx.stx_rdev_major, stx.stx_rdev_minor);
+
+	st->st_ino  = stx.stx_ino;
+	st->st_mode = stx.stx_mode;
+	st->st_nlink = stx.stx_nlink;
+	st->st_uid = stx.stx_uid;
+	st->st_gid = stx.stx_gid;
+	st->st_size = stx.stx_size;
+	st->st_blksize = stx.stx_blksize;
+	st->st_blocks = stx.stx_blocks;
+
+	st->st_atim.tv_sec = stx.stx_atime.tv_sec;
+	st->st_atim.tv_nsec = stx.stx_atime.tv_nsec;
+	st->st_mtim.tv_sec = stx.stx_mtime.tv_sec;
+	st->st_mtim.tv_nsec = stx.stx_mtime.tv_nsec;
+	st->st_ctim.tv_sec = stx.stx_ctime.tv_sec;
+	st->st_ctim.tv_nsec = stx.stx_ctime.tv_nsec;
+    }
+    return ret;
+}
--- src/statx.h
+++ src/statx.h	2021-01-14 11:29:22.019223776 +0000
@@ -0,0 +1,68 @@
+/*
+ * statx.h - Map modern statx(2) system call to older stat(2), lstat(2),
+ *           and fstat(2) replacements named {,l,f}statn()
+ *
+ * Copyright (C) 2018 Werner Fink
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _STATX_H
+#define _STATX_H
+
+extern int stat_flags;
+#if defined(HAVE_DECL_SYS_STATX) && HAVE_DECL_SYS_STATX == 1
+# ifndef HAVE_STATX
+#  define _ASM_GENERIC_FCNTL_H	/* Avoid collisions between asm/fcntl.h and bits/fcntl.h ! */
+#  include <linux/fcntl.h>	/* Definition of AT_* and AT_STATX_* constants ! */
+#  ifndef STATX_TYPE
+#   include <linux/stat.h>	/* Provides 'struct statx' and STATX_* ! */
+#  endif
+# endif
+extern int statn(const char*, unsigned int, struct stat*);
+extern int fstatn(int, unsigned int, struct stat*);
+extern int lstatn(const char*, unsigned int, struct stat*);
+#else
+extern inline int
+statn(const char *path, unsigned int mask __attribute__((unused)), struct stat *st)
+{
+    return stat(path, st);
+}
+extern inline int
+fstatn(int fd, unsigned int mask __attribute__((unused)), struct stat *st)
+{
+    return fstat(fd, st);
+}
+extern inline int
+lstatn(const char *path, unsigned int mask __attribute__((unused)), struct stat *st)
+{
+    return lstat(path, st);
+}
+#define STATX_TYPE		0
+#define STATX_MODE		0
+#define STATX_NLINK		0
+#define STATX_UID		0
+#define STATX_GID		0
+#define STATX_ATIME		0
+#define STATX_MTIME		0
+#define STATX_CTIME		0
+#define STATX_INO		0
+#define STATX_SIZE		0
+#define STATX_BLOCKS		0
+#define STATX_BASIC_STATS	0
+#define STATX_BTIME		0
+#define STATX_ALL		0
+#endif
+#endif
