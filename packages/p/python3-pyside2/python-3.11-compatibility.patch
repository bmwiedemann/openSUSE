Python 3.11 support backported to pyside2. Includes these commits:

https://code.qt.io/cgit/pyside/pyside-setup.git/patch/?id=73adefe22f
https://code.qt.io/cgit/pyside/pyside-setup.git/patch/?id=52df3b8f64
https://code.qt.io/cgit/pyside/pyside-setup.git/patch/?id=da2cf03152
https://code.qt.io/cgit/pyside/pyside-setup.git/patch/?id=a09a1db839
https://code.qt.io/cgit/pyside/pyside-setup.git/patch/?id=ace680f4c5

Note that upstream won't support these changes.

Index: pyside-setup-opensource-src-5.15.10/sources/shiboken2/libshiboken/basewrapper.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.10.orig/sources/shiboken2/libshiboken/basewrapper.cpp
+++ pyside-setup-opensource-src-5.15.10/sources/shiboken2/libshiboken/basewrapper.cpp
@@ -377,7 +377,7 @@ SbkObjectType *SbkObject_TypeF(void)
     static PyTypeObject *type = nullptr;
     if (!type) {
         type = reinterpret_cast<PyTypeObject *>(SbkType_FromSpec(&SbkObject_Type_spec));
-        Py_TYPE(type) = SbkObjectType_TypeF();
+        Py_SET_TYPE(type, SbkObjectType_TypeF());
         Py_INCREF(Py_TYPE(type));
         type->tp_weaklistoffset = offsetof(SbkObject, weakreflist);
         type->tp_dictoffset = offsetof(SbkObject, ob_dict);
@@ -1161,7 +1161,7 @@ introduceWrapperType(PyObject *enclosing
     typeSpec->slots[0].pfunc = reinterpret_cast<void *>(baseType ? baseType : SbkObject_TypeF());
 
     PyObject *heaptype = SbkType_FromSpecWithBases(typeSpec, baseTypes);
-    Py_TYPE(heaptype) = SbkObjectType_TypeF();
+    Py_SET_TYPE(heaptype, SbkObjectType_TypeF());
     Py_INCREF(Py_TYPE(heaptype));
     auto *type = reinterpret_cast<SbkObjectType *>(heaptype);
 #if PY_VERSION_HEX < 0x03000000
@@ -1526,6 +1526,7 @@ bool setCppPointer(SbkObject *sbkObj, Py
 bool isValid(PyObject *pyObj)
 {
     if (!pyObj || pyObj == Py_None
+        || PyType_Check(pyObj) != 0
         || Py_TYPE(Py_TYPE(pyObj)) != SbkObjectType_TypeF()) {
         return true;
     }
Index: pyside-setup-opensource-src-5.15.10/sources/pyside2/libpyside/pysideqflags.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.10.orig/sources/pyside2/libpyside/pysideqflags.cpp
+++ pyside-setup-opensource-src-5.15.10/sources/pyside2/libpyside/pysideqflags.cpp
@@ -192,7 +192,7 @@ namespace QFlags
         }
         newspec.slots = SbkNewQFlagsType_spec.slots;
         PyTypeObject *type = (PyTypeObject *)SbkType_FromSpec(&newspec);
-        Py_TYPE(type) = &PyType_Type;
+        Py_SET_TYPE(type, &PyType_Type);
 
         PySideQFlagsType *flagsType = reinterpret_cast<PySideQFlagsType *>(type);
         PepType_PFTP(flagsType)->converterPtr = &PepType_PFTP(flagsType)->converter;
Index: pyside-setup-opensource-src-5.15.10/sources/pyside2/libpyside/pysidesignal.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.10.orig/sources/pyside2/libpyside/pysidesignal.cpp
+++ pyside-setup-opensource-src-5.15.10/sources/pyside2/libpyside/pysidesignal.cpp
@@ -162,7 +162,7 @@ PyTypeObject *PySideSignalTypeF(void)
     if (!type) {
         type = reinterpret_cast<PyTypeObject *>(SbkType_FromSpec(&PySideSignalType_spec));
         PyTypeObject *hold = Py_TYPE(type);
-        Py_TYPE(type) = PySideMetaSignalTypeF();
+        Py_SET_TYPE(type, PySideMetaSignalTypeF());
         Py_INCREF(Py_TYPE(type));
         Py_DECREF(hold);
     }
Index: pyside-setup-opensource-src-5.15.10/sources/pyside2/libpyside/pysideweakref.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.10.orig/sources/pyside2/libpyside/pysideweakref.cpp
+++ pyside-setup-opensource-src-5.15.10/sources/pyside2/libpyside/pysideweakref.cpp
@@ -90,7 +90,7 @@ PyObject *create(PyObject *obj, PySideWe
 
     if (Py_TYPE(PySideCallableObjectTypeF()) == 0)
     {
-        Py_TYPE(PySideCallableObjectTypeF()) = &PyType_Type;
+        Py_SET_TYPE(PySideCallableObjectTypeF(), &PyType_Type);
         PyType_Ready(PySideCallableObjectTypeF());
     }
 
Index: pyside-setup-opensource-src-5.15.10/sources/shiboken2/libshiboken/sbkenum.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.10.orig/sources/shiboken2/libshiboken/sbkenum.cpp
+++ pyside-setup-opensource-src-5.15.10/sources/shiboken2/libshiboken/sbkenum.cpp
@@ -754,7 +754,7 @@ newTypeWithName(const char *name,
     PyTuple_SetItem(bases, 0, reinterpret_cast<PyObject *>(basetype));
     auto *type = reinterpret_cast<PyTypeObject *>(SbkType_FromSpecWithBases(&newspec, bases));
     PyErr_Print();
-    Py_TYPE(type) = SbkEnumType_TypeF();
+    Py_SET_TYPE(type, SbkEnumType_TypeF());
 
     auto *enumType = reinterpret_cast<SbkEnumType *>(type);
     PepType_SETP(enumType)->cppName = cppName;
Index: pyside-setup-opensource-src-5.15.10/sources/shiboken2/libshiboken/sbkstring.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.10.orig/sources/shiboken2/libshiboken/sbkstring.cpp
+++ pyside-setup-opensource-src-5.15.10/sources/shiboken2/libshiboken/sbkstring.cpp
@@ -41,8 +41,14 @@
 #include "sbkstaticstrings_p.h"
 #include "autodecref.h"
 
-#include <vector>
-#include <unordered_set>
+#if PY_VERSION_HEX >= 0x030B0000 || defined(Py_LIMITED_API)
+#  define USE_INTERN_STRINGS
+#endif
+
+#ifndef USE_INTERN_STRINGS
+#  include <vector>
+#  include <unordered_set>
+#endif
 
 namespace Shiboken
 {
@@ -233,6 +239,13 @@ Py_ssize_t len(PyObject *str)
 //     PyObject *attr = PyObject_GetAttr(obj, name());
 //
 
+#ifdef USE_INTERN_STRINGS
+PyObject *createStaticString(const char *str)
+{
+     return PyUnicode_InternFromString(str);
+}
+#else
+
 using StaticStrings = std::unordered_set<PyObject *>;
 
 static void finalizeStaticStrings();    // forward
@@ -283,6 +296,8 @@ PyObject *createStaticString(const char
     return result;
 }
 
+#endif // !USE_INTERN_STRINGS
+
 ///////////////////////////////////////////////////////////////////////
 //
 // PYSIDE-1019: Helper function for snake_case vs. camelCase names
Index: pyside-setup-opensource-src-5.15.10/build_scripts/config.py
===================================================================
--- pyside-setup-opensource-src-5.15.10.orig/build_scripts/config.py
+++ pyside-setup-opensource-src-5.15.10/build_scripts/config.py
@@ -94,6 +94,7 @@ class Config(object):
             'Programming Language :: Python :: 3.8',
             'Programming Language :: Python :: 3.9',
             'Programming Language :: Python :: 3.10',
+            'Programming Language :: Python :: 3.11',
         ]
 
         self.setup_script_dir = None
Index: pyside-setup-opensource-src-5.15.10/sources/shiboken2/shibokenmodule/files.dir/shibokensupport/signature/lib/enum_sig.py
===================================================================
--- pyside-setup-opensource-src-5.15.10.orig/sources/shiboken2/shibokenmodule/files.dir/shibokensupport/signature/lib/enum_sig.py
+++ pyside-setup-opensource-src-5.15.10/sources/shiboken2/shibokenmodule/files.dir/shibokensupport/signature/lib/enum_sig.py
@@ -139,7 +139,8 @@ class ExactEnumerator(object):
                     functions.append((func_name, thing))
             elif type(type(thing)) is EnumMeta:
                 # take the real enum name, not what is in the dict
-                enums.append((thing_name, type(thing).__qualname__, thing))
+                if not thing_name.startswith("_"):
+                    enums.append((thing_name, type(thing).__qualname__, thing))
         init_signature = getattr(klass, "__signature__", None)
         enums.sort(key=lambda tup: tup[1 : 3])  # sort by class then enum value
         self.fmt.have_body = bool(subclasses or functions or enums or init_signature)
Index: pyside-setup-opensource-src-5.15.10/sources/pyside2/tests/QtCore/qenum_test.py
===================================================================
--- pyside-setup-opensource-src-5.15.10.orig/sources/pyside2/tests/QtCore/qenum_test.py
+++ pyside-setup-opensource-src-5.15.10/sources/pyside2/tests/QtCore/qenum_test.py
@@ -195,16 +195,17 @@ class SomeClass(QObject):
     QEnum(SomeEnum)     # works even without the decorator assignment
 
 
-@unittest.skipUnless(HAVE_ENUM, "requires 'enum' module (use 'pip install enum34' for Python 2)")
 class TestQEnumMacro(unittest.TestCase):
+    meta_name = "EnumType" if sys.version_info[:2] >= (3, 11) else "EnumMeta"
+
     def testTopLevel(self):
         self.assertEqual(type(OuterEnum).__module__, "enum")
-        self.assertEqual(type(OuterEnum).__name__, "EnumMeta")
+        self.assertEqual(type(OuterEnum).__name__, self.meta_name)
         self.assertEqual(len(OuterEnum.__members__), 2)
 
     def testSomeClass(self):
         self.assertEqual(type(SomeClass.SomeEnum).__module__, "enum")
-        self.assertEqual(type(SomeClass.SomeEnum).__name__, "EnumMeta")
+        self.assertEqual(type(SomeClass.SomeEnum).__name__, self.meta_name)
         self.assertEqual(len(SomeClass.SomeEnum.__members__), 3)
         with self.assertRaises(TypeError):
             int(SomeClass.SomeEnum.C) == 6
Index: pyside-setup-opensource-src-5.15.10/sources/pyside2/libpyside/pysideproperty.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.10.orig/sources/pyside2/libpyside/pysideproperty.cpp
+++ pyside-setup-opensource-src-5.15.10/sources/pyside2/libpyside/pysideproperty.cpp
@@ -104,6 +104,7 @@ static PyType_Slot PySidePropertyType_sl
     {Py_tp_init, (void *)qpropertyTpInit},
     {Py_tp_new, (void *)qpropertyTpNew},
     {Py_tp_getset, PySidePropertyType_getset},
+    {Py_tp_del, reinterpret_cast<void *>(PyObject_GC_Del)},
     {0, 0}
 };
 // Dotted modulename is crucial for SbkType_FromSpec to work. Is this name right?
@@ -249,6 +250,7 @@ static void qpropertyDeAlloc(PyObject *s
         // This was not needed before Python 3.8 (Python issue 35810)
         Py_DECREF(Py_TYPE(self));
     }
+    PyObject_GC_UnTrack(self);
     Py_TYPE(self)->tp_free(self);
 }
