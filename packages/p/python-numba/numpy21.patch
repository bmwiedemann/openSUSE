From 5f2a3d60fc9c1e25bec9fd6de0b0b8bae6f142da Mon Sep 17 00:00:00 2001
From: kc611 <ckaustubhm06@gmail.com>
Date: Mon, 30 Sep 2024 23:08:18 +0530
Subject: [PATCH 01/22] Added NumPy 2.1 Support

---
 numba/cpython/randomimpl.py           |  6 ++-
 numba/cuda/tests/cudapy/test_debug.py |  2 +-
 numba/np/arrayobj.py                  |  6 +--
 numba/np/math/numbers.py              |  5 +++
 numba/np/npyfuncs.py                  | 58 +++++++++++++++++----------
 numba/np/old_arraymath.py             |  2 +
 numba/np/random/old_distributions.py  |  4 +-
 numba/np/ufunc_db.py                  | 36 +++++++++++++++++
 numba/tests/test_array_methods.py     | 19 ++++++---
 9 files changed, 105 insertions(+), 33 deletions(-)

Index: numba-0.60.0/numba/cpython/randomimpl.py
===================================================================
--- numba-0.60.0.orig/numba/cpython/randomimpl.py
+++ numba-0.60.0/numba/cpython/randomimpl.py
@@ -17,7 +17,7 @@ from numba.core.imputils import (Registr
 from numba.core.typing import signature
 from numba.core import types, cgutils
 from numba.core.errors import NumbaTypeError
-
+from numba.np.random._constants import LONG_MAX
 
 registry = Registry('randomimpl')
 lower = registry.lower
@@ -1798,6 +1798,10 @@ def zipf_impl(a):
                 U = 1.0 - np.random.random()
                 V = np.random.random()
                 X = int(math.floor(U ** (-1.0 / am1)))
+                
+                if (X > LONG_MAX or X < 1.0):
+                    continue
+
                 T = (1.0 + 1.0 / X) ** am1
                 if X >= 1 and V * X * (T - 1.0) / (b - 1.0) <= (T / b):
                     return X
Index: numba-0.60.0/numba/np/arrayobj.py
===================================================================
--- numba-0.60.0.orig/numba/np/arrayobj.py
+++ numba-0.60.0/numba/np/arrayobj.py
@@ -1932,17 +1932,23 @@ def numpy_geomspace(start, stop, num=50)
                 raise ValueError('Geometric sequence cannot include zero')
             start = result_dtype(start)
             stop = result_dtype(stop)
-            both_imaginary = (start.real == 0) & (stop.real == 0)
-            both_negative = (np.sign(start) == -1) & (np.sign(stop) == -1)
-            out_sign = 1
-            if both_imaginary:
-                start = start.imag
-                stop = stop.imag
-                out_sign = 1j
-            if both_negative:
-                start = -start
-                stop = -stop
-                out_sign = -out_sign
+            if numpy_version < (2, 0):
+                both_imaginary = (start.real == 0) & (stop.real == 0)
+                both_negative = (np.sign(start) == -1) & (np.sign(stop) == -1)
+                out_sign = 1
+                if both_imaginary:
+                    start = start.imag
+                    stop = stop.imag
+                    out_sign = 1j
+                if both_negative:
+                    start = -start
+                    stop = -stop
+                    out_sign = -out_sign
+            else:
+                out_sign = np.sign(start)
+                start /= out_sign
+                stop /= out_sign
+
             logstart = np.log10(start)
             logstop = np.log10(stop)
             result = np.logspace(logstart, logstop, num)
@@ -2144,11 +2150,18 @@ def array_reshape_vararg(context, builde
     return array_reshape(context, builder, new_sig, new_args)
 
 
-@overload(np.reshape)
-def np_reshape(a, newshape):
-    def np_reshape_impl(a, newshape):
-        return a.reshape(newshape)
-    return np_reshape_impl
+if numpy_version < (2, 1):
+    @overload(np.reshape)
+    def np_reshape(a, newshape):
+        def np_reshape_impl(a, newshape):
+            return a.reshape(newshape)
+        return np_reshape_impl
+else:
+    @overload(np.reshape)
+    def np_reshape(a, shape):
+        def np_reshape_impl(a, shape):
+            return a.reshape(shape)
+        return np_reshape_impl
 
 
 @overload(np.resize)
Index: numba-0.60.0/numba/np/math/numbers.py
===================================================================
--- numba-0.60.0.orig/numba/np/math/numbers.py
+++ numba-0.60.0/numba/np/math/numbers.py
@@ -397,6 +397,11 @@ def int_abs_impl(context, builder, sig,
     return impl_ret_untracked(context, builder, sig.return_type, res)
 
 
+def identity_impl(context, builder, sig, args):
+    [x] = args
+    return impl_ret_untracked(context, builder, sig.return_type, x)
+
+
 def uint_abs_impl(context, builder, sig, args):
     [x] = args
     return impl_ret_untracked(context, builder, sig.return_type, x)
Index: numba-0.60.0/numba/np/npyfuncs.py
===================================================================
--- numba-0.60.0.orig/numba/np/npyfuncs.py
+++ numba-0.60.0/numba/np/npyfuncs.py
@@ -16,6 +16,7 @@ from numba.core import typing, types, er
 from numba.core.extending import register_jitable
 from numba.np import npdatetime
 from numba.np.math import cmathimpl, mathimpl, numbers
+from numba.np.numpy_support import numpy_version
 
 # some NumPy constants. Note that we could generate some of them using
 # the math library, but having the values copied from npy_math seems to
@@ -580,29 +581,42 @@ def np_complex_sign_impl(context, builde
     # equivalent to complex sign in NumPy's sign
     # but implemented via selects, balancing the 4 cases.
     _check_arity_and_homogeneity(sig, args, 1)
-    op = args[0]
-    ty = sig.args[0]
-    float_ty = ty.underlying_float
 
-    ZERO = context.get_constant(float_ty, 0.0)
-    ONE  = context.get_constant(float_ty, 1.0)
-    MINUS_ONE = context.get_constant(float_ty, -1.0)
-    NAN = context.get_constant(float_ty, float('nan'))
-    result = context.make_complex(builder, ty)
-    result.real = ZERO
-    result.imag = ZERO
-
-    cmp_sig = typing.signature(types.boolean, *[ty] * 2)
-    cmp_args = [op, result._getvalue()]
-    arg1_ge_arg2 = np_complex_ge_impl(context, builder, cmp_sig, cmp_args)
-    arg1_eq_arg2 = np_complex_eq_impl(context, builder, cmp_sig, cmp_args)
-    arg1_lt_arg2 = np_complex_lt_impl(context, builder, cmp_sig, cmp_args)
-
-    real_when_ge = builder.select(arg1_eq_arg2, ZERO, ONE)
-    real_when_nge = builder.select(arg1_lt_arg2, MINUS_ONE, NAN)
-    result.real = builder.select(arg1_ge_arg2, real_when_ge, real_when_nge)
+    if numpy_version >= (2, 0):
+        # NumPy >= 2.0.0
+        def complex_sign(z):
+            abs = math.hypot(z.real, z.imag)
+            if abs == 0:
+                return 0 + 0j
+            else:
+                return z / abs
+
+        res = context.compile_internal(builder, complex_sign, sig, args)
+        return impl_ret_untracked(context, builder, sig.return_type, res) 
+    else:
+        op = args[0]
+        ty = sig.args[0]
+        result = context.make_complex(builder, ty)
+        float_ty = ty.underlying_float
+
+        ZERO = context.get_constant(float_ty, 0.0)
+        ONE  = context.get_constant(float_ty, 1.0)
+        MINUS_ONE = context.get_constant(float_ty, -1.0)
+        NAN = context.get_constant(float_ty, float('nan'))
+
+        result.real = ZERO
+        result.imag = ZERO
+        cmp_sig = typing.signature(types.boolean, *[ty] * 2)
+        cmp_args = [op, result._getvalue()]
+        arg1_ge_arg2 = np_complex_ge_impl(context, builder, cmp_sig, cmp_args)
+        arg1_eq_arg2 = np_complex_eq_impl(context, builder, cmp_sig, cmp_args)
+        arg1_lt_arg2 = np_complex_lt_impl(context, builder, cmp_sig, cmp_args)
+
+        real_when_ge = builder.select(arg1_eq_arg2, ZERO, ONE)
+        real_when_nge = builder.select(arg1_lt_arg2, MINUS_ONE, NAN)
+        result.real = builder.select(arg1_ge_arg2, real_when_ge, real_when_nge)
 
-    return result._getvalue()
+        return result._getvalue()
 
 
 ########################################################################
Index: numba-0.60.0/numba/np/ufunc_db.py
===================================================================
--- numba-0.60.0.orig/numba/np/ufunc_db.py
+++ numba-0.60.0/numba/np/ufunc_db.py
@@ -583,16 +583,58 @@ def _fill_ufunc_db(ufunc_db):
         'f->f': npyfuncs.np_real_floor_impl,
         'd->d': npyfuncs.np_real_floor_impl,
     }
+    if numpy_version >= (2, 1):
+        ufunc_db[np.floor].update({
+            '?->?': numbers.identity_impl,
+            'b->b': numbers.identity_impl,
+            'B->B': numbers.identity_impl,
+            'h->h': numbers.identity_impl,
+            'H->H': numbers.identity_impl,
+            'i->i': numbers.identity_impl,
+            'I->I': numbers.identity_impl,
+            'l->l': numbers.identity_impl,
+            'L->L': numbers.identity_impl,
+            'q->q': numbers.identity_impl,
+            'Q->Q': numbers.identity_impl,
+        })
 
     ufunc_db[np.ceil] = {
         'f->f': npyfuncs.np_real_ceil_impl,
         'd->d': npyfuncs.np_real_ceil_impl,
     }
+    if numpy_version >= (2, 1):
+        ufunc_db[np.ceil].update({
+            '?->?': numbers.identity_impl,
+            'b->b': numbers.identity_impl,
+            'B->B': numbers.identity_impl,
+            'h->h': numbers.identity_impl,
+            'H->H': numbers.identity_impl,
+            'i->i': numbers.identity_impl,
+            'I->I': numbers.identity_impl,
+            'l->l': numbers.identity_impl,
+            'L->L': numbers.identity_impl,
+            'q->q': numbers.identity_impl,
+            'Q->Q': numbers.identity_impl,
+        })
 
     ufunc_db[np.trunc] = {
         'f->f': npyfuncs.np_real_trunc_impl,
         'd->d': npyfuncs.np_real_trunc_impl,
     }
+    if numpy_version >= (2, 1):
+        ufunc_db[np.trunc].update({
+            '?->?': numbers.identity_impl,
+            'b->b': numbers.identity_impl,
+            'B->B': numbers.identity_impl,
+            'h->h': numbers.identity_impl,
+            'H->H': numbers.identity_impl,
+            'i->i': numbers.identity_impl,
+            'I->I': numbers.identity_impl,
+            'l->l': numbers.identity_impl,
+            'L->L': numbers.identity_impl,
+            'q->q': numbers.identity_impl,
+            'Q->Q': numbers.identity_impl,
+        })
 
     ufunc_db[np.fabs] = {
         'f->f': npyfuncs.np_real_fabs_impl,
Index: numba-0.60.0/numba/tests/test_array_methods.py
===================================================================
--- numba-0.60.0.orig/numba/tests/test_array_methods.py
+++ numba-0.60.0/numba/tests/test_array_methods.py
@@ -774,13 +774,20 @@ class TestArrayMethods(MemoryLeakMixin,
         check_arr(arr.reshape((2, 3, 4)))
         check_arr(arr.reshape((2, 3, 4)).T)
         check_arr(arr.reshape((2, 3, 4))[::2])
-        for v in (0.0, 1.5, float('nan')):
-            arr = np.array([v]).reshape(())
-            check_arr(arr)
 
         arr = np.array(["Hello", "", "world"])
         check_arr(arr)
 
+        for v in (0.0, 1.5, float('nan')):
+            arr = np.array([v]).reshape(())
+            if numpy_version < (2, 1):
+                check_arr(arr)
+            else:
+                with self.assertRaises(ValueError) as raises:
+                    njit((typeof(arr),))(pyfunc)
+                self.assertEqual(str(raises.exception),
+                                 "Calling nonzero on 0d arrays is not allowed. Use np.atleast_1d(scalar).nonzero() instead.")
+
     def test_array_nonzero(self):
         self.check_nonzero(array_nonzero)
 
Index: numba-0.60.0/docs/upcoming_changes/9741.highlight.rst
===================================================================
--- /dev/null
+++ numba-0.60.0/docs/upcoming_changes/9741.highlight.rst
@@ -0,0 +1,4 @@
+Added Support for NumPy 2.1
+---------------------------
+
+This release adds support for NumPy 2.1 (excluding the NEP-050 semantics).
Index: numba-0.60.0/numba/tests/test_ufuncs.py
===================================================================
--- numba-0.60.0.orig/numba/tests/test_ufuncs.py
+++ numba-0.60.0/numba/tests/test_ufuncs.py
@@ -18,7 +18,6 @@ from numba.np import numpy_support
 from numba.core.registry import cpu_target
 from numba.core.base import BaseContext
 from numba.np import ufunc_db
-from numba.tests.support import expected_failure_np2
 
 is32bits = tuple.__itemsize__ == 4
 iswindows = sys.platform.startswith('win32')
@@ -1696,8 +1695,6 @@ class TestLoopTypesComplex(_LoopTypesTes
 
 
 TestLoopTypesComplex.autogenerate()
-expected_failure_np2(TestLoopTypesComplex.test_sign_F_F)
-expected_failure_np2(TestLoopTypesComplex.test_sign_D_D)
 
 
 class TestLoopTypesDatetime(_LoopTypesTester):
Index: numba-0.60.0/numba/core/typing/arraydecl.py
===================================================================
--- numba-0.60.0.orig/numba/core/typing/arraydecl.py
+++ numba-0.60.0/numba/core/typing/arraydecl.py
@@ -415,6 +415,11 @@ class ArrayAttribute(AttributeTemplate):
     def resolve_nonzero(self, ary, args, kws):
         assert not args
         assert not kws
+        if ary.ndim == 0 and numpy_version >= (2, 1):
+            raise ValueError(
+                "Calling nonzero on 0d arrays is not allowed."
+                " Use np.atleast_1d(scalar).nonzero() instead."
+            )
         # 0-dim arrays return one result array
         ndim = max(ary.ndim, 1)
         retty = types.UniTuple(types.Array(types.intp, 1, 'C'), ndim)
Index: numba-0.60.0/numba/np/random/_constants.py
===================================================================
--- numba-0.60.0.orig/numba/np/random/_constants.py
+++ numba-0.60.0/numba/np/random/_constants.py
@@ -1,4 +1,5 @@
 import numpy as np
+import ctypes
 
 # These constants are directly obtained from:
 # https://github.com/numpy/numpy/blob/caccd283941b0bade7b71056138ded5379b1625f/numpy/random/src/distributions/ziggurat_constants.h
@@ -1222,6 +1223,7 @@ UINT8_MAX = 255
 UINT16_MAX = 65535
 UINT32_MAX = 4294967295
 UINT64_MAX = 18446744073709551615
+LONG_MAX = (1 << ( 8 * ctypes.sizeof(ctypes.c_long) - 1)) - 1
 
 LS2PI = 0.91893853320467267
 TWELFTH = 0.083333333333333333333333
Index: numba-0.60.0/numba/__init__.py
===================================================================
--- numba-0.60.0.orig/numba/__init__.py
+++ numba-0.60.0/numba/__init__.py
@@ -34,13 +34,13 @@ def _ensure_critical_deps():
     import numpy as np
     numpy_version = extract_version(np)
 
-    if numpy_version < (1, 22):
-        msg = (f"Numba needs NumPy 1.22 or greater. Got NumPy "
+    if numpy_version < (1, 24):
+        msg = (f"Numba needs NumPy 1.24 or greater. Got NumPy "
                f"{numpy_version[0]}.{numpy_version[1]}.")
         raise ImportError(msg)
 
-    if numpy_version > (2, 0):
-        msg = (f"Numba needs NumPy 2.0 or less. Got NumPy "
+    if numpy_version > (2, 1):
+        msg = (f"Numba needs NumPy 2.1 or less. Got NumPy "
                f"{numpy_version[0]}.{numpy_version[1]}.")
         raise ImportError(msg)
 
Index: numba-0.60.0/numba/np/random/distributions.py
===================================================================
--- a/numba/np/random/distributions.py
+++ b/numba/np/random/distributions.py
@@ -394,8 +394,10 @@ def random_geometric(bitgen, p):
 def random_zipf(bitgen, a):
     am1 = a - 1.0
     b = pow(2.0, am1)
+    Umin = pow(INT64_MAX, -am1)
     while 1:
-        U = 1.0 - next_double(bitgen)
+        U01 = next_double(bitgen)
+        U = U01*Umin + (1 - U01)
         V = next_double(bitgen)
         X = np.floor(pow(U, -1.0 / am1))
         if (X > INT64_MAX or X < 1.0):
