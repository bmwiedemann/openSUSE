From 3ee9419066c5d789854b55112472444053d4c7b5 Mon Sep 17 00:00:00 2001
From: Vasily Kuznetsov <kvas.it@gmail.com>
Date: Fri, 13 Mar 2020 16:18:24 +0100
Subject: [PATCH] Update the tests and make them compatible with virtualenv
 v.20 (#31)

---
 pytest_console_scripts.py |  5 ++++-
 tests/test_run_scripts.py | 33 +++++++++++++++++++++++++--------
 4 files changed, 42 insertions(+), 13 deletions(-)

diff --git a/pytest_console_scripts.py b/pytest_console_scripts.py
index dbeb5ee..a5c0c1e 100644
--- a/pytest_console_scripts.py
+++ b/pytest_console_scripts.py
@@ -146,7 +146,10 @@ def _restore_logger(self, config):
 
     def run_inprocess(self, command, *arguments, **options):
         cmdargs = [command] + list(arguments)
-        script = py.path.local(distutils.spawn.find_executable(command))
+        script_path = distutils.spawn.find_executable(command)
+        if script_path is None:
+            raise FileNotFoundError('Cannot execute ' + command)
+        script = py.path.local(script_path)
         stdin = options.get('stdin', StreamMock())
         stdout = StreamMock()
         stderr = StreamMock()
diff --git a/tests/test_run_scripts.py b/tests/test_run_scripts.py
index 2a0a9d2..3f76d5d 100644
--- a/tests/test_run_scripts.py
+++ b/tests/test_run_scripts.py
@@ -1,9 +1,8 @@
+import json
 import os
 import subprocess
 import sys
 
-import mock
-import py
 import pytest
 import virtualenv
 
@@ -32,6 +31,7 @@ def __init__(self, path):
         dpp = self._distpackages_path()
         if dpp is not None:
             self.path.mkdir(dpp)
+        self.sys_path = self._get_sys_path()
 
     def _distpackages_path(self):
         """Return (relative) path used for installing distribution packages.
@@ -51,18 +51,33 @@ def _distpackages_path(self):
                     parts = parts[parts.index('lib'):]
                     return os.path.join(*parts)
 
-    def _update_env(self, env):
+    def _get_sys_path(self):
+        """Return sys.path of this virtualenv."""
+        result = self.run([
+            'python', '-c',
+            'import json,sys; print(json.dumps(sys.path))',
+        ], skip_pythonpath=True)
+        assert result.returncode == 0
+        return json.loads(str(result.stdout.read(), encoding='utf-8'))
+
+    def _update_env(self, env, skip_pythonpath=False):
         bin_dir = self.path.join('bin').strpath
         env['PATH'] = bin_dir + ':' + env.get('PATH', '')
+        if 'PYTHONHOME' in env:
+            del env['PYTHONHOME']
         env['VIRTUAL_ENV'] = self.path.strpath
+        if skip_pythonpath:
+            return
         # Make installed packages of the Python installation that runs this
         # test accessible. This allows us to run tests in the virtualenv
         # without installing all the dependencies there.
-        env['PYTHONPATH'] = ':'.join(sys.path)
+        python_path = set(sys.path + self.sys_path)
+        env['PYTHONPATH'] = ':'.join(python_path)
 
-    def run(self, cmd, *args, **kw):
+    def run(self, cmd, skip_pythonpath=False, *args, **kw):
         """Run a command in the virtualenv, return terminated process."""
-        self._update_env(kw.setdefault('env', dict(os.environ)))
+        self._update_env(kw.setdefault('env', dict(os.environ)),
+                         skip_pythonpath=skip_pythonpath)
         kw.setdefault('stdout', subprocess.PIPE)
         kw.setdefault('stderr', subprocess.PIPE)
         proc = subprocess.Popen(cmd, *args, **kw)
@@ -75,14 +90,16 @@ def install_console_script(self, cmd, script_path):
         script_name = script_path.purebasename
         setup_py = script_dir.join('setup.py')
         setup_py.write(SETUP_TEMPLATE.format(cmd=cmd, script_name=script_name))
-        self.run(['python', 'setup.py', 'develop'], cwd=str(script_dir))
+        result = self.run(['python', 'setup.py', 'develop'],
+                          cwd=str(script_dir), skip_pythonpath=True)
+        assert result.returncode == 0
 
 
 @pytest.fixture(scope='session')
 def pcs_venv(tmpdir_factory):
     """Virtualenv for testing console scripts."""
     venv = tmpdir_factory.mktemp('venv')
-    virtualenv.create_environment(venv.strpath)
+    virtualenv.cli_run([venv.strpath])
     yield VEnvWrapper(venv)
 
