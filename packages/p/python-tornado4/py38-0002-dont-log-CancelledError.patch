Description: gen.with_timeout: Don't log CancelledError after timeout
  This patch originated with upstream commit 0684b61c1d4feaaf5ac3. The
  patch has been modified to handle Python 2 as version 5.1 still
  supports Python 2. Upstream dropped Python 2 support prior to when
  this patch landed.
Author: Petr Viktorin <encukou@gmail.com> (original author)
        Corey Bryant <corey.bryant@canonical.com> (modified original)

See also: commit a237a995a1d54ad6e07c1ecdf5103ff8f45073b5
---
 tornado/gen.py | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

Index: tornado-4.5.3/tornado/gen.py
===================================================================
--- tornado-4.5.3.orig/tornado/gen.py
+++ tornado-4.5.3/tornado/gen.py
@@ -876,8 +876,9 @@ def with_timeout(timeout, future, io_loo
     relative to `.IOLoop.time`)
 
     If the wrapped `.Future` fails after it has timed out, the exception
-    will be logged unless it is of a type contained in ``quiet_exceptions``
-    (which may be an exception type or a sequence of types).
+    will be logged unless it is either of a type contained in
+    ``quiet_exceptions`` (which may be an exception type or a sequence of
+    types), or a `CancelledError`.
 
     Does not support `YieldPoint` subclasses.
 
@@ -905,12 +906,23 @@ def with_timeout(timeout, future, io_loo
         io_loop = IOLoop.current()
 
     def error_callback(future):
-        try:
-            future.result()
-        except Exception as e:
-            if not isinstance(e, quiet_exceptions):
-                app_log.error("Exception in Future %r after timeout",
-                              future, exc_info=True)
+        if PY3:
+            import asyncio
+            try:
+                future.result()
+            except asyncio.CancelledError:
+                pass
+            except Exception as e:
+                if not isinstance(e, quiet_exceptions):
+                    app_log.error("Exception in Future %r after timeout",
+                                  future, exc_info=True)
+        else:
+            try:
+                future.result()
+            except Exception as e:
+                if not isinstance(e, quiet_exceptions):
+                    app_log.error("Exception in Future %r after timeout",
+                                  future, exc_info=True)
 
     def timeout_callback():
         result.set_exception(TimeoutError("Timeout"))
