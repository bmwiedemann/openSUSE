From: Andreas Stieger <Andreas.Stieger@gmx.de>
Date: Tue, 15 Apr 2025 16:35:42 +0000
Subject: disable pcre tests
References: boo#1241199 https://github.com/fish-shell/fish-shell/issues/11164

fish 3.7.1 fails to build with pcre2 10.45

[  150s]  81/247 Test  #80: re .......................................***Failed    0.28 sec
[  150s] Proceeding with target execution
[  150s] Testing low-level functionality
[  150s] Testing re
[  150s] [31mError: Test failed on line 7013: !res.has_value()[0m
[  150s] [31mError: Test failed on line 7014: error.code == -57[0m
[  150s] [31mError: Test failed on line 7015: error.message() == L"bad escape sequence in replacement string"[0m
[  150s] [31mError: Test failed on line 7016: error.offset == 5[0m
[  150s] [31mError: Test failed on line 7013: !res.has_value()[0m
[  150s] [31mError: Test failed on line 7014: error.code == -57[0m
[  150s] [31mError: Test failed on line 7015: error.message() == L"bad escape sequence in replacement string"[0m
[  150s] [31mError: Test failed on line 7016: error.offset == 5[0m
[  150s] Encountered 8 errors in low-level tests
[  150s] 
[...]
50s] 99% tests passed, 1 tests failed out of 247
[  150s] 
[  150s] Total Test time (real) =  13.36 sec
[  150s] 
[  150s] The following tests FAILED:
[  150s] 	 80 - re (Failed)
[  150s] Errors while running CTest
[  150s] make[3]: *** [CMakeFiles/fish_run_t

From https://github.com/fish-shell/fish-shell/issues/11164

"The test is no longer testing what it wants to, this has no impact on how the
code actually works, so it's safe to remove the test."

Drop it.

Index: fish-3.7.1/src/fish_tests.cpp
===================================================================
--- fish-3.7.1.orig/src/fish_tests.cpp
+++ fish-3.7.1/src/fish_tests.cpp
@@ -81,7 +81,6 @@
 #include "parser.h"
 #include "path.h"
 #include "proc.h"
-#include "re.h"
 #include "reader.h"
 #include "redirection.h"
 #include "screen.h"
@@ -6851,181 +6850,6 @@ static void test_killring() {
     do_test((kill_entries() == wcstring_list_t{L"a", L"c", L"b", L"d"}));
 }
 
-namespace {
-using namespace re;
-
-// Basic tests for re, which wraps PCRE2.
-static void test_re_errs() {
-    say(L"Testing re");
-    flags_t flags{};
-    re_error_t error{};
-    maybe_t<regex_t> re;
-    do_test(!regex_t::try_compile(L"abc[", flags, &error));
-    do_test(error.code != 0);
-    do_test(!error.message().empty());
-
-    error = re_error_t{};
-    do_test(!regex_t::try_compile(L"abc(", flags, &error).has_value());
-    do_test(error.code != 0);
-    do_test(!error.message().empty());
-}
-
-static void test_re_basic() {
-    // Match a character twice.
-    using namespace re;
-    wcstring subject = L"AAbCCd11e";
-    auto substr_from_range = [&](maybe_t<match_range_t> r) {
-        do_test(r.has_value());
-        do_test(r->begin <= r->end);
-        do_test(r->end <= subject.size());
-        return subject.substr(r->begin, r->end - r->begin);
-    };
-    auto re = regex_t::try_compile(L"(.)\\1");
-    do_test(re.has_value());
-    auto md = re->prepare();
-    wcstring_list_t matches;
-    wcstring_list_t captures;
-    while (auto r = re->match(md, subject)) {
-        matches.push_back(substr_from_range(r));
-        captures.push_back(substr_from_range(re->group(md, 1)));
-        do_test(!re->group(md, 2));
-    }
-    do_test(join_strings(matches, L',') == L"AA,CC,11");
-    do_test(join_strings(captures, L',') == L"A,C,1");
-
-    // Test make_anchored
-    re = regex_t::try_compile(make_anchored(L"ab(.+?)"));
-    do_test(re.has_value());
-    do_test(!re->match(L""));
-    do_test(!re->match(L"ab"));
-    do_test((re->match(L"abcd") == match_range_t{0, 4}));
-    do_test(!re->match(L"xabcd"));
-    do_test((re->match(L"abcdefghij") == match_range_t{0, 10}));
-
-    re = regex_t::try_compile(make_anchored(L"(a+)|(b+)"));
-    do_test(re.has_value());
-    do_test(!re->match(L""));
-    do_test(!re->match(L"aabb"));
-    do_test((re->match(L"aaaa") == match_range_t{0, 4}));
-    do_test((re->match(L"bbbb") == match_range_t{0, 4}));
-    do_test(!re->match(L"aaaax"));
-}
-
-static void test_re_reset() {
-    using namespace re;
-    auto re = regex_t::try_compile(L"([0-9])");
-    wcstring s = L"012345";
-    auto md = re->prepare();
-    for (size_t idx = 0; idx < s.size(); idx++) {
-        md.reset();
-        for (size_t j = 0; j <= idx; j++) {
-            auto m = re->match(md, s);
-            match_range_t expected{j, j + 1};
-            do_test(m == expected);
-            do_test(re->group(md, 1) == expected);
-        }
-    }
-}
-
-static void test_re_named() {
-    // Named capture groups.
-    using namespace re;
-    auto re = regex_t::try_compile(L"A(?<FOO>x+)?");
-    do_test(re->capture_group_count() == 1);
-
-    wcstring subject = L"AxxAAx";
-    auto md = re->prepare();
-
-    auto r = re->match(md, subject);
-    do_test((r == match_range_t{0, 3}));
-    do_test(re->substring_for_group(md, L"QQQ", subject) == none());
-    do_test(re->substring_for_group(md, L"FOO", subject) == L"xx");
-
-    r = re->match(md, subject);
-    do_test((r == match_range_t{3, 4}));
-    do_test(re->substring_for_group(md, L"QQQ", subject) == none());
-    do_test(re->substring_for_group(md, L"FOO", subject) == none());
-
-    r = re->match(md, subject);
-    do_test((r == match_range_t{4, 6}));
-    do_test(re->substring_for_group(md, L"QQQ", subject) == none());
-    do_test(re->substring_for_group(md, L"FOO", subject) == wcstring(L"x"));
-}
-
-static void test_re_name_extraction() {
-    // Names of capture groups can be extracted.
-    using namespace re;
-    auto re = regex_t::try_compile(L"(?<FOO>dd)ff(?<BAR>cc)aaa(?<alpha>)ff(?<BETA>)");
-    do_test(re.has_value());
-    do_test(re->capture_group_count() == 4);
-    // PCRE2 returns these sorted.
-    do_test(join_strings(re->capture_group_names(), L',') == L"BAR,BETA,FOO,alpha");
-
-    // Mixed named and positional captures.
-    re = regex_t::try_compile(L"(abc)(?<FOO>def)(ghi)(?<BAR>jkl)");
-    do_test(re.has_value());
-    do_test(re->capture_group_count() == 4);
-    do_test(join_strings(re->capture_group_names(), L',') == L"BAR,FOO");
-    auto md = re->prepare();
-    const wcstring subject = L"abcdefghijkl";
-    auto m = re->match(md, subject);
-    do_test((m == match_range_t{0, 12}));
-    do_test((re->group(md, 1) == match_range_t{0, 3}));
-    do_test((re->group(md, 2) == match_range_t{3, 6}));
-    do_test((re->group(md, 3) == match_range_t{6, 9}));
-    do_test((re->group(md, 4) == match_range_t{9, 12}));
-    do_test(re->substring_for_group(md, L"FOO", subject) == wcstring(L"def"));
-    do_test(re->substring_for_group(md, L"BAR", subject) == wcstring(L"jkl"));
-}
-
-static void test_re_substitute() {
-    // Names of capture groups can be extracted.
-    using namespace re;
-    auto re = regex_t::try_compile(L"[a-z]+(\\d+)");
-    do_test(re.has_value());
-    do_test(re->capture_group_count() == 1);
-    maybe_t<wcstring> res{};
-    int repl_count{};
-    sub_flags_t sflags{};
-    const wcstring subj = L"AAabc123ZZ AAabc123ZZ";
-    const wcstring repl = L"$1qqq";
-    res = re->substitute(subj, repl, sflags, 0, nullptr, &repl_count);
-    do_test(res && *res == L"AA123qqqZZ AAabc123ZZ");
-    do_test(repl_count == 1);
-
-    res = re->substitute(subj, repl, sflags, 5, nullptr, &repl_count);
-    do_test(res && *res == L"AAabc123ZZ AA123qqqZZ");
-    do_test(repl_count == 1);
-
-    sflags.global = true;
-    res = re->substitute(subj, repl, sflags, 0, nullptr, &repl_count);
-    do_test(res && *res == L"AA123qqqZZ AA123qqqZZ");
-    do_test(repl_count == 2);
-
-    sflags.extended = true;
-    res = re->substitute(subj, L"\\x21", sflags, 0, nullptr, &repl_count);  // \x21 = !
-    do_test(res && *res == L"AA!ZZ AA!ZZ");
-    do_test(repl_count == 2);
-
-    // Test with a bad escape; \b is unsupported.
-    re_error_t error{};
-    res = re->substitute(subj, L"AAA\\bZZZ", sflags, 0, &error);
-    do_test(!res.has_value());
-    do_test(error.code == -57 /* PCRE2_ERROR_BADREPESCAPE */);
-    do_test(error.message() == L"bad escape sequence in replacement string");
-    do_test(error.offset == 5 /* the b */);
-
-    // Test a very long replacement as we used a fixed-size buffer.
-    sflags = sub_flags_t{};
-    sflags.global = true;
-    re = regex_t::try_compile(L"A");
-    res =
-        re->substitute(wcstring(4096, L'A'), wcstring(4096, L'X'), sflags, 0, nullptr, &repl_count);
-    do_test(res && *res == wcstring(4096 * 4096, L'X'));
-    do_test(repl_count == 4096);
-}
-}  // namespace
-
 struct termsize_tester_t {
     static void test();
 };
@@ -7250,13 +7074,6 @@ static const test_t s_tests[]{
     {TEST_GROUP("timer_format"), test_timer_format},
     {TEST_GROUP("termsize"), termsize_tester_t::test},
     {TEST_GROUP("killring"), test_killring},
-    {TEST_GROUP("re"), test_re_errs},
-    {TEST_GROUP("re"), test_re_basic},
-    {TEST_GROUP("re"), test_re_reset},
-    {TEST_GROUP("re"), test_re_named},
-    {TEST_GROUP("re"), test_re_name_extraction},
-    {TEST_GROUP("re"), test_re_substitute},
-    {TEST_GROUP("re"), test_re_substitute},
     {TEST_GROUP("wgetopt"), test_wgetopt},
 };
 
