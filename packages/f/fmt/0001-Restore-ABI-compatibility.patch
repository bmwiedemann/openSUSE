From 21aa0956d43297667762cf79347e4cda76ea3521 Mon Sep 17 00:00:00 2001
From: Victor Zverovich <viz@meta.com>
Date: Fri, 10 Jan 2025 17:19:20 -0800
Subject: [PATCH] Restore ABI compatibility
References: https://github.com/fmtlib/fmt/issues/4292

---
 doc/api.md               |  6 +++---
 include/fmt/base.h       |  4 +---
 include/fmt/format-inl.h |  2 +-
 include/fmt/format.h     | 43 ++++++++++++++++++++++++++--------------
 include/fmt/xchar.h      | 27 +++++++++++++++----------
 5 files changed, 49 insertions(+), 33 deletions(-)

diff --git a/doc/api.md b/doc/api.md
index e86f0b06..80296ea4 100644
--- a/doc/api.md
+++ b/doc/api.md
@@ -413,11 +413,11 @@ locale:
 that take `std::locale` as a parameter. The locale type is a template
 parameter to avoid the expensive `<locale>` include.
 
-::: format(detail::locale_ref, format_string<T...>, T&&...)
+::: format(const Locale&, format_string<T...>, T&&...)
 
-::: format_to(OutputIt, detail::locale_ref, format_string<T...>, T&&...)
+::: format_to(OutputIt, const Locale&, format_string<T...>, T&&...)
 
-::: formatted_size(detail::locale_ref, format_string<T...>, T&&...)
+::: formatted_size(const Locale&, format_string<T...>, T&&...)
 
 <a id="legacy-checks"></a>
 ### Legacy Compile-Time Checks
diff --git a/include/fmt/base.h b/include/fmt/base.h
index a6948d40..e5773c87 100644
--- a/include/fmt/base.h
+++ b/include/fmt/base.h
@@ -2276,9 +2276,7 @@ struct locale_ref {
 
  public:
   constexpr locale_ref() : locale_(nullptr) {}
-
-  template <typename Locale, FMT_ENABLE_IF(sizeof(Locale::collate) != 0)>
-  locale_ref(const Locale& loc);
+  template <typename Locale> locale_ref(const Locale& loc);
 
   inline explicit operator bool() const noexcept { return locale_ != nullptr; }
 #endif  // FMT_USE_LOCALE
diff --git a/include/fmt/format-inl.h b/include/fmt/format-inl.h
index 14c65a09..a5b79dbe 100644
--- a/include/fmt/format-inl.h
+++ b/include/fmt/format-inl.h
@@ -84,7 +84,7 @@ using std::locale;
 using std::numpunct;
 using std::use_facet;
 
-template <typename Locale, enable_if_t<(sizeof(Locale::collate) != 0), int>>
+template <typename Locale>
 locale_ref::locale_ref(const Locale& loc) : locale_(&loc) {
   static_assert(std::is_same<Locale, locale>::value, "");
 }
diff --git a/include/fmt/format.h b/include/fmt/format.h
index c9a6054d..95b5bad0 100644
--- a/include/fmt/format.h
+++ b/include/fmt/format.h
@@ -1839,7 +1839,9 @@ template <typename Char> class digit_grouping {
   }
 
  public:
-  explicit digit_grouping(locale_ref loc, bool localized = true) {
+  template <typename Locale,
+            FMT_ENABLE_IF(std::is_same<Locale, locale_ref>::value)>
+  explicit digit_grouping(Locale loc, bool localized = true) {
     if (!localized) return;
     auto sep = thousands_sep<Char>(loc);
     grouping_ = sep.grouping;
@@ -3639,6 +3641,12 @@ FMT_CONSTEXPR auto native_formatter<T, Char, TYPE>::format(
   return write<Char>(ctx.out(), val, specs, ctx.locale());
 }
 
+// DEPRECATED! https://github.com/fmtlib/fmt/issues/4292.
+template <typename T, typename Enable = void>
+struct is_locale : std::false_type {};
+template <typename T>
+struct is_locale<T, void_t<decltype(T::classic())>> : std::true_type {};
+
 // DEPRECATED!
 template <typename Char = char> struct vformat_args {
   using type = basic_format_args<buffered_context<Char>>;
@@ -4120,41 +4128,46 @@ FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
 // Can be used to report errors from destructors.
 FMT_API void report_system_error(int error_code, const char* message) noexcept;
 
-inline auto vformat(detail::locale_ref loc, string_view fmt, format_args args)
+template <typename Locale, FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
+inline auto vformat(const Locale& loc, string_view fmt, format_args args)
     -> std::string {
   auto buf = memory_buffer();
-  detail::vformat_to(buf, fmt, args, loc);
+  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
   return {buf.data(), buf.size()};
 }
 
-template <typename... T>
-FMT_INLINE auto format(detail::locale_ref loc, format_string<T...> fmt,
-                       T&&... args) -> std::string {
+template <typename Locale, typename... T,
+          FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
+FMT_INLINE auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
+    -> std::string {
   return vformat(loc, fmt.str, vargs<T...>{{args...}});
 }
 
-template <typename OutputIt,
+template <typename OutputIt, typename Locale,
           FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
-auto vformat_to(OutputIt out, detail::locale_ref loc, string_view fmt,
+auto vformat_to(OutputIt out, const Locale& loc, string_view fmt,
                 format_args args) -> OutputIt {
   auto&& buf = detail::get_buffer<char>(out);
-  detail::vformat_to(buf, fmt, args, loc);
+  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
   return detail::get_iterator(buf, out);
 }
 
-template <typename OutputIt, typename... T,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
-FMT_INLINE auto format_to(OutputIt out, detail::locale_ref loc,
+template <typename OutputIt, typename Locale, typename... T,
+          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
+                            detail::is_locale<Locale>::value)>
+FMT_INLINE auto format_to(OutputIt out, const Locale& loc,
                           format_string<T...> fmt, T&&... args) -> OutputIt {
   return fmt::vformat_to(out, loc, fmt.str, vargs<T...>{{args...}});
 }
 
-template <typename... T>
-FMT_NODISCARD FMT_INLINE auto formatted_size(detail::locale_ref loc,
+template <typename Locale, typename... T,
+          FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
+FMT_NODISCARD FMT_INLINE auto formatted_size(const Locale& loc,
                                              format_string<T...> fmt,
                                              T&&... args) -> size_t {
   auto buf = detail::counting_buffer<>();
-  detail::vformat_to(buf, fmt.str, vargs<T...>{{args...}}, loc);
+  detail::vformat_to(buf, fmt.str, vargs<T...>{{args...}},
+                     detail::locale_ref(loc));
   return buf.count();
 }
 
diff --git a/include/fmt/xchar.h b/include/fmt/xchar.h
index 4cbda542..9f7f889d 100644
--- a/include/fmt/xchar.h
+++ b/include/fmt/xchar.h
@@ -191,9 +191,11 @@ auto format(const S& fmt, T&&... args) -> std::basic_string<Char> {
                  fmt::make_format_args<buffered_context<Char>>(args...));
 }
 
-template <typename S, typename Char = detail::format_string_char_t<S>,
-          FMT_ENABLE_IF(detail::is_exotic_char<Char>::value)>
-inline auto vformat(detail::locale_ref loc, const S& fmt,
+template <typename Locale, typename S,
+          typename Char = detail::format_string_char_t<S>,
+          FMT_ENABLE_IF(detail::is_locale<Locale>::value&&
+                            detail::is_exotic_char<Char>::value)>
+inline auto vformat(const Locale& loc, const S& fmt,
                     typename detail::vformat_args<Char>::type args)
     -> std::basic_string<Char> {
   auto buf = basic_memory_buffer<Char>();
@@ -202,10 +204,11 @@ inline auto vformat(detail::locale_ref loc, const S& fmt,
   return {buf.data(), buf.size()};
 }
 
-template <typename S, typename... T,
+template <typename Locale, typename S, typename... T,
           typename Char = detail::format_string_char_t<S>,
-          FMT_ENABLE_IF(detail::is_exotic_char<Char>::value)>
-inline auto format(detail::locale_ref loc, const S& fmt, T&&... args)
+          FMT_ENABLE_IF(detail::is_locale<Locale>::value&&
+                            detail::is_exotic_char<Char>::value)>
+inline auto format(const Locale& loc, const S& fmt, T&&... args)
     -> std::basic_string<Char> {
   return vformat(loc, detail::to_string_view(fmt),
                  fmt::make_format_args<buffered_context<Char>>(args...));
@@ -232,11 +235,12 @@ inline auto format_to(OutputIt out, const S& fmt, T&&... args) -> OutputIt {
                     fmt::make_format_args<buffered_context<Char>>(args...));
 }
 
-template <typename S, typename OutputIt, typename... Args,
+template <typename Locale, typename S, typename OutputIt, typename... Args,
           typename Char = detail::format_string_char_t<S>,
           FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
-                            detail::is_exotic_char<Char>::value)>
-inline auto vformat_to(OutputIt out, detail::locale_ref loc, const S& fmt,
+                            detail::is_locale<Locale>::value&&
+                                detail::is_exotic_char<Char>::value)>
+inline auto vformat_to(OutputIt out, const Locale& loc, const S& fmt,
                        typename detail::vformat_args<Char>::type args)
     -> OutputIt {
   auto&& buf = detail::get_buffer<Char>(out);
@@ -244,11 +248,12 @@ inline auto vformat_to(OutputIt out, detail::locale_ref loc, const S& fmt,
   return detail::get_iterator(buf, out);
 }
 
-template <typename OutputIt, typename S, typename... T,
+template <typename Locale, typename OutputIt, typename S, typename... T,
           typename Char = detail::format_string_char_t<S>,
           bool enable = detail::is_output_iterator<OutputIt, Char>::value &&
+                        detail::is_locale<Locale>::value &&
                         detail::is_exotic_char<Char>::value>
-inline auto format_to(OutputIt out, detail::locale_ref loc, const S& fmt,
+inline auto format_to(OutputIt out, const Locale& loc, const S& fmt,
                       T&&... args) ->
     typename std::enable_if<enable, OutputIt>::type {
   return vformat_to(out, loc, detail::to_string_view(fmt),
-- 
2.47.1

