diff --git a/cli/tools/run/mod.rs.1 b/cli/tools/run/mod.rs
index 4805ea7..57bb752 100644
--- a/cli/tools/run/mod.rs.1
+++ b/cli/tools/run/mod.rs
@@ -51,14 +51,6 @@ To grant permissions, set them before the script argument. For example:
     );
   }
 
-  // Run a background task that checks for available upgrades or output
-  // if an earlier run of this background task found a new version of Deno.
-  #[cfg(feature = "upgrade")]
-  super::upgrade::check_for_upgrades(
-    http_client.clone(),
-    deno_dir.upgrade_check_file_path(),
-  );
-
   let main_module = cli_options.resolve_main_module()?;
 
   maybe_npm_install(&factory).await?;
diff --git a/cli/main.rs.1 b/cli/main.rs
index 031ab07..4f3b05c 100644
--- a/cli/main.rs.1
+++ b/cli/main.rs
@@ -204,15 +204,6 @@ async fn run_subcommand(flags: Flags) -> Result<i32, AnyError> {
       let types = tsc::get_types_declaration_file_text();
       display::write_to_stdout_ignore_sigpipe(types.as_bytes())
     }),
-    #[cfg(feature = "upgrade")]
-    DenoSubcommand::Upgrade(upgrade_flags) => spawn_subcommand(async {
-      tools::upgrade::upgrade(flags, upgrade_flags).await
-    }),
-    #[cfg(not(feature = "upgrade"))]
-    DenoSubcommand::Upgrade(_) => exit_with_message(
-      "This deno was built without the \"upgrade\" feature. Please upgrade using the installation method originally used to install Deno.",
-      1,
-    ),
     DenoSubcommand::Vendor(vendor_flags) => spawn_subcommand(async {
       tools::vendor::vendor(flags, vendor_flags).await
     }),
diff --git a/cli/args/flags.rs.1 b/cli/args/flags.rs
index 72841df..1c93da1 100644
--- a/cli/args/flags.rs.1
+++ b/cli/args/flags.rs
@@ -397,7 +397,6 @@ pub enum DenoSubcommand {
   Task(TaskFlags),
   Test(TestFlags),
   Types,
-  Upgrade(UpgradeFlags),
   Vendor(VendorFlags),
   Publish(PublishFlags),
 }
@@ -917,7 +917,7 @@ impl Flags {
         Some(current_dir.to_path_buf())
       }
       Add(_) | Bundle(_) | Completions(_) | Doc(_) | Fmt(_) | Init(_)
-      | Uninstall(_) | Jupyter(_) | Lsp | Lint(_) | Types | Upgrade(_)
+      | Uninstall(_) | Jupyter(_) | Lsp | Lint(_) | Types
       | Vendor(_) => None,
       Install(_) => {
         if *DENO_FUTURE {
@@ -944,7 +934,6 @@ pub fn flags_from_vec(args: Vec<String>) -> clap::error::Result<Flags> {
       "test" => test_parse(&mut flags, &mut m),
       "types" => types_parse(&mut flags, &mut m),
       "uninstall" => uninstall_parse(&mut flags, &mut m),
-      "upgrade" => upgrade_parse(&mut flags, &mut m),
       "vendor" => vendor_parse(&mut flags, &mut m),
       "publish" => publish_parse(&mut flags, &mut m),
       _ => unreachable!(),
@@ -1099,7 +1088,6 @@ fn clap_root() -> Command {
         .subcommand(task_subcommand())
         .subcommand(test_subcommand())
         .subcommand(types_subcommand())
-        .subcommand(upgrade_subcommand())
         .subcommand(vendor_subcommand())
     })
     .long_about(DENO_HELP)
@@ -2413,60 +2404,6 @@ The declaration file could be saved and used for typing information.",
     )
 }
 
-fn upgrade_subcommand() -> Command {
-  Command::new("upgrade")
-    .about("Upgrade deno executable to given version")
-    .long_about(
-      "Upgrade deno executable to the given version.
-Defaults to latest.
-
-The version is downloaded from
-https://github.com/denoland/deno/releases
-and is used to replace the current executable.
-
-If you want to not replace the current Deno executable but instead download an
-update to a different location, use the --output flag
-
-  deno upgrade --output $HOME/my_deno",
-    )
-    .hide(cfg!(not(feature = "upgrade")))
-    .defer(|cmd| {
-      cmd
-        .arg(
-          Arg::new("version")
-            .long("version")
-            .help("The version to upgrade to"),
-        )
-        .arg(
-          Arg::new("output")
-            .long("output")
-            .help("The path to output the updated version to")
-            .value_parser(value_parser!(String))
-            .value_hint(ValueHint::FilePath),
-        )
-        .arg(
-          Arg::new("dry-run")
-            .long("dry-run")
-            .help("Perform all checks without replacing old exe")
-            .action(ArgAction::SetTrue),
-        )
-        .arg(
-          Arg::new("force")
-            .long("force")
-            .short('f')
-            .help("Replace current exe even if not out-of-date")
-            .action(ArgAction::SetTrue),
-        )
-        .arg(
-          Arg::new("canary")
-            .long("canary")
-            .help("Upgrade to canary builds")
-            .action(ArgAction::SetTrue),
-        )
-        .arg(ca_file_arg())
-    })
-}
-
 fn vendor_subcommand() -> Command {
   Command::new("vendor")
       .about("Vendor remote modules into a local directory")
@@ -3965,23 +3902,6 @@ fn types_parse(flags: &mut Flags, _matches: &mut ArgMatches) {
   flags.subcommand = DenoSubcommand::Types;
 }
 
-fn upgrade_parse(flags: &mut Flags, matches: &mut ArgMatches) {
-  ca_file_arg_parse(flags, matches);
-
-  let dry_run = matches.get_flag("dry-run");
-  let force = matches.get_flag("force");
-  let canary = matches.get_flag("canary");
-  let version = matches.remove_one::<String>("version");
-  let output = matches.remove_one::<String>("output");
-  flags.subcommand = DenoSubcommand::Upgrade(UpgradeFlags {
-    dry_run,
-    force,
-    canary,
-    version,
-    output,
-  });
-}
-
 fn vendor_parse(flags: &mut Flags, matches: &mut ArgMatches) {
   ca_file_arg_parse(flags, matches);
   config_args_parse(flags, matches);
@@ -4442,25 +4362,6 @@ mod tests {
     assert_eq!(flags2, flags);
   }
 
-  #[test]
-  fn upgrade() {
-    let r = flags_from_vec(svec!["deno", "upgrade", "--dry-run", "--force"]);
-    let flags = r.unwrap();
-    assert_eq!(
-      flags,
-      Flags {
-        subcommand: DenoSubcommand::Upgrade(UpgradeFlags {
-          force: true,
-          dry_run: true,
-          canary: false,
-          version: None,
-          output: None,
-        }),
-        ..Flags::default()
-      }
-    );
-  }
-
   #[test]
   fn upgrade_with_output_flag() {
     let r = flags_from_vec(svec!["deno", "upgrade", "--output", "example.txt"]);
@@ -7509,25 +7406,6 @@ mod tests {
     );
   }
 
-  #[test]
-  fn upgrade_with_ca_file() {
-    let r = flags_from_vec(svec!["deno", "upgrade", "--cert", "example.crt"]);
-    assert_eq!(
-      r.unwrap(),
-      Flags {
-        subcommand: DenoSubcommand::Upgrade(UpgradeFlags {
-          force: false,
-          dry_run: false,
-          canary: false,
-          version: None,
-          output: None,
-        }),
-        ca_data: Some(CaData::File("example.crt".to_owned())),
-        ..Flags::default()
-      }
-    );
-  }
-
   #[test]
   fn cache_with_cafile() {
     let r = flags_from_vec(svec![
diff --git a/cli/tools/mod.rs.1 b/cli/tools/mod.rs
index 4593092..3247915 100644
--- a/cli/tools/mod.rs.1
+++ b/cli/tools/mod.rs
@@ -17,5 +17,4 @@ pub mod repl;
 pub mod run;
 pub mod task;
 pub mod test;
-pub mod upgrade;
 pub mod vendor;
diff --git a/cli/standalone/binary.rs.1 b/cli/standalone/binary.rs
index 628922b..f8bb1e2 100644
--- a/cli/standalone/binary.rs.1
+++ b/cli/standalone/binary.rs
@@ -499,13 +499,7 @@ impl<'a> DenoCompileBinaryWriter<'a> {

     let archive_data = std::fs::read(binary_path)?;
     let temp_dir = tempfile::TempDir::new()?;
-    let base_binary_path = unpack_into_dir(
-      "denort",
-      &binary_name,
-      archive_data,
-      target.contains("windows"),
-      &temp_dir,
-    )?;
+    let base_binary_path = "/tmp";
     let base_binary = std::fs::read(base_binary_path)?;
     drop(temp_dir); // delete the temp dir
     Ok(base_binary)
diff --git a/cli/lsp/language_server.rs.1 b/cli/lsp/language_server.rs
index 573fb1e..158c136 100644
--- a/cli/lsp/language_server.rs.1
+++ b/cli/lsp/language_server.rs
@@ -99,8 +99,6 @@ use crate::lsp::tsc::file_text_changes_to_workspace_edit;
 use crate::lsp::urls::LspUrlKind;
 use crate::tools::fmt::format_file;
 use crate::tools::fmt::format_parsed_source;
-use crate::tools::upgrade::check_for_upgrades_for_lsp;
-use crate::tools::upgrade::upgrade_check_enabled;
 use crate::util::fs::remove_dir_all_if_exists;
 use crate::util::path::is_importable_ext;
 use crate::util::path::to_percent_decoded_str;
@@ -2982,28 +2980,6 @@ impl tower_lsp::LanguageServer for LanguageServer {
       }
     }
 
-    if upgrade_check_enabled() {
-      // spawn to avoid lsp send/sync requirement, but also just
-      // to ensure this initialized method returns quickly
-      spawn(async move {
-        match check_for_upgrades_for_lsp(http_client).await {
-          Ok(version_info) => {
-            client.send_did_upgrade_check_notification(
-              lsp_custom::DidUpgradeCheckNotificationParams {
-                upgrade_available: version_info.map(|info| {
-                  lsp_custom::UpgradeAvailable {
-                    latest_version: info.latest_version,
-                    is_canary: info.is_canary,
-                  }
-                }),
-              },
-            );
-          }
-          Err(err) => lsp_warn!("Failed to check for upgrades: {err}"),
-        }
-      });
-    }
-
     lsp_log!("Server ready.");
   }
 
