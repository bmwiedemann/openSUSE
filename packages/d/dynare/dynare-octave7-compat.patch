Index: dynare-5.1/doc/manual/source/installation-and-configuration.rst
===================================================================
--- dynare-5.1.orig/doc/manual/source/installation-and-configuration.rst
+++ dynare-5.1/doc/manual/source/installation-and-configuration.rst
@@ -15,10 +15,10 @@ compilation steps are necessary in that
 In order to run Dynare, you need one of the following:
 
 * MATLAB, any version ranging from 8.3 (R2014a) to 9.12 (R2022a);
-* GNU Octave, any version ranging from 5.2.0 to 6.4.0, with the statistics
-  package from `Octave-Forge`_. Note however that the Dynare installer for
-  Windows requires a more specific version of Octave, as indicated on the
-  download page.
+* GNU Octave version ranging from 6.2.0 to 7.1.0, with the statistics package
+  from `Octave-Forge`_. Note however that the Dynare installer for Windows
+  requires a more specific version of Octave, as indicated on the download
+  page.
 
 The following optional extensions are also useful to benefit from
 extra features, but are in no way required:
Index: dynare-5.1/matlab/+estimate/nls.m
===================================================================
--- dynare-5.1.orig/matlab/+estimate/nls.m
+++ dynare-5.1/matlab/+estimate/nls.m
@@ -253,9 +253,8 @@ fclose(fid);
 
 % Workaround for Octave bug https://savannah.gnu.org/bugs/?46282
 % Octave will randomly fail to read the ssr_* file generated in the +folder
-if isoctave
-    rename(['+' M_.fname], ['+' M_.fname '-tmp']);
-    rename(['+' M_.fname '-tmp'], ['+' M_.fname]);
+if isoctave && octave_ver_less_than('7')
+    path(path)
 end
 
 % Create a function handle returning the sum of square residuals for a given vector of parameters.
Index: dynare-5.1/matlab/+mom/run.m
===================================================================
--- dynare-5.1.orig/matlab/+mom/run.m
+++ dynare-5.1/matlab/+mom/run.m
@@ -63,7 +63,7 @@ function [oo_, options_mom_, M_] = run(b
 %  o set_all_parameters.m
 %  o test_for_deep_parameters_calibration.m
 % =========================================================================
-% Copyright (C) 2020-2021 Dynare Team
+% Copyright © 2020-2022 Dynare Team
 %
 % This file is part of Dynare.
 %
@@ -1017,11 +1017,7 @@ fprintf('\n==== Method of Moments Estima
 % Step 9: Clean up
 % -------------------------------------------------------------------------
 %reset warning state
-if isoctave
-    warning('on')
-else
-    warning on
-end
+warning_config;
 
 if isoctave && isfield(options_, 'prior_restrictions') && ...
    isfield(options_.prior_restrictions, 'routine')
Index: dynare-5.1/matlab/+occbin/kalman_update_algo_1.m
===================================================================
--- dynare-5.1.orig/matlab/+occbin/kalman_update_algo_1.m
+++ dynare-5.1/matlab/+occbin/kalman_update_algo_1.m
@@ -42,7 +42,7 @@ function [a, a1, P, P1, v, T, R, C, regi
 % Philipp Pfeiffer, Marco Ratto (2021), Efficient and robust inference of models with occasionally binding
 % constraints, Working Papers 2021-03, Joint Research Centre, European Commission 
 
-% Copyright (C) 2021 Dynare Team
+% Copyright © 2021-2022 Dynare Team
 %
 % This file is part of Dynare.
 %
@@ -323,7 +323,7 @@ P(:,:,2) = T(:,:,2)*P(:,:,1)*transpose(T
 regimes_=regimes_(1:3);
 etahat=etahat(:,2);
 
-warning on
+warning_config;
 end
 
 function [a, a1, P, P1, v, alphahat, etahat, lik] = occbin_kalman_update0(a,a1,P,P1,data_index,Z,v,Y,H,QQQ,TT,RR,CC,iF,L,mm, rescale_prediction_error_covariance, IF_likelihood)
@@ -424,5 +424,5 @@ while t > 1
     end
 end
 
-warning on
+warning_config;
 end
Index: dynare-5.1/matlab/+pac/+estimate/nls.m
===================================================================
--- dynare-5.1.orig/matlab/+pac/+estimate/nls.m
+++ dynare-5.1/matlab/+pac/+estimate/nls.m
@@ -166,9 +166,8 @@ fclose(fid);
 
 % Workaround for Octave bug https://savannah.gnu.org/bugs/?46282
 % Octave will randomly fail to read the ssr_* file generated in the +folder
-if isoctave
-    rename(['+' M_.fname], ['+' M_.fname '-tmp']);
-    rename(['+' M_.fname '-tmp'], ['+' M_.fname]);
+if isoctave && octave_ver_less_than('7')
+    path(path)
 end
 
 % Copy (sub)sample data in a matrix.
Index: dynare-5.1/matlab/WriteShockDecomp2Excel.m
===================================================================
--- dynare-5.1.orig/matlab/WriteShockDecomp2Excel.m
+++ dynare-5.1/matlab/WriteShockDecomp2Excel.m
@@ -11,7 +11,7 @@ function WriteShockDecomp2Excel(z,shock_
 %   DynareModel     [structure]                     Dynare model structure
 %   DynareOptions   [structure]                     Dynare options structure
 
-% Copyright (C) 2016-2021 Dynare Team
+% Copyright © 2016-2022 Dynare Team
 %
 % This file is part of Dynare.
 %
@@ -124,7 +124,7 @@ for j=1:nvar
     else
         writetable(cell2table(d0), [OutputDirectoryName,filesep,DynareModel.fname,'_shock_decomposition',fig_mode,fig_name1 '.xls'], 'Sheet', endo_names{i_var(j)},'WriteVariableNames',false);
     end
-    warning on
+    warning_config;
 
     clear d0
 
Index: dynare-5.1/matlab/dynare_estimation_1.m
===================================================================
--- dynare-5.1.orig/matlab/dynare_estimation_1.m
+++ dynare-5.1/matlab/dynare_estimation_1.m
@@ -12,7 +12,7 @@ function dynare_estimation_1(var_list_,d
 % SPECIAL REQUIREMENTS
 %   none
 
-% Copyright (C) 2003-2021 Dynare Team
+% Copyright © 2003-2022 Dynare Team
 %
 % This file is part of Dynare.
 %
@@ -32,7 +32,7 @@ function dynare_estimation_1(var_list_,d
 global M_ options_ oo_ estim_params_ bayestopt_ dataset_ dataset_info
 
 if ~exist([M_.dname filesep 'Output'],'dir')
-    if isoctave && ~exist(M_.dname)
+    if isoctave && octave_ver_less_than('7') && ~exist(M_.dname)
         % See https://savannah.gnu.org/bugs/index.php?61166
         % This workaround is needed for recursive estimation.
         mkdir(M_.dname)
Index: dynare-5.1/matlab/dynare_identification.m
===================================================================
--- dynare-5.1.orig/matlab/dynare_identification.m
+++ dynare-5.1/matlab/dynare_identification.m
@@ -46,7 +46,7 @@ function [pdraws, STO_REDUCEDFORM, STO_M
 %    * skipline
 %    * vnorm
 % =========================================================================
-% Copyright (C) 2010-2021 Dynare Team
+% Copyright © 2010-2022 Dynare Team
 %
 % This file is part of Dynare.
 %
@@ -968,11 +968,7 @@ if SampleSize > 1
 end
 
 %reset warning state
-if isoctave
-    warning('on')
-else
-    warning on
-end
+warning_config;
 
 fprintf('\n==== Identification analysis completed ====\n\n')
 
Index: dynare-5.1/matlab/dynare_solve.m
===================================================================
--- dynare-5.1.orig/matlab/dynare_solve.m
+++ dynare-5.1/matlab/dynare_solve.m
@@ -80,14 +80,14 @@ if ismember(options.solve_algo, [12, 14]
     isauxdiffloggedrhs = varargin{2};
     endo_names = varargin{3};
     lhs = varargin{4};
-    arguments = varargin(5:end);
+    args = varargin(5:end);
 else
-    arguments = varargin;
+    args = varargin;
 end
 
 % checking initial values
 if jacobian_flag
-    [fvec, fjac] = feval(f, x, arguments{:});
+    [fvec, fjac] = feval(f, x, args{:});
     wrong_initial_guess_flag = false;
     if ~all(isfinite(fvec)) || any(isinf(fjac(:))) || any(isnan((fjac(:)))) ...
             || any(~isreal(fvec)) || any(~isreal(fjac(:)))
@@ -103,7 +103,7 @@ if jacobian_flag
         while wrong_initial_guess_flag && tentative_number<=in0*10
             tentative_number = tentative_number+1;
             x(idx) = rand(in0, 1)*10;
-            [fvec, fjac] = feval(f, x, arguments{:});
+            [fvec, fjac] = feval(f, x, args{:});
             wrong_initial_guess_flag = ~all(isfinite(fvec)) || any(isinf(fjac(:))) || any(isnan((fjac(:))));
         end
         % If all previous attempts failed, try with real numbers.
@@ -111,7 +111,7 @@ if jacobian_flag
         while wrong_initial_guess_flag && tentative_number<=in0*10
             tentative_number = tentative_number+1;
             x(idx) = randn(in0, 1)*10;
-            [fvec, fjac] = feval(f, x, arguments{:});
+            [fvec, fjac] = feval(f, x, args{:});
             wrong_initial_guess_flag = ~all(isfinite(fvec)) || any(isinf(fjac(:))) || any(isnan((fjac(:))));
         end
         % Last tentative, ff all previous attempts failed, try with negative numbers.
@@ -119,12 +119,12 @@ if jacobian_flag
         while wrong_initial_guess_flag && tentative_number<=in0*10
             tentative_number = tentative_number+1;
             x(idx) = -rand(in0, 1)*10;
-            [fvec, fjac] = feval(f, x, arguments{:});
+            [fvec, fjac] = feval(f, x, args{:});
             wrong_initial_guess_flag = ~all(isfinite(fvec)) || any(isinf(fjac(:))) || any(isnan((fjac(:))));
         end
     end
 else
-    fvec = feval(f, x, arguments{:});
+    fvec = feval(f, x, args{:});
     fjac = zeros(nn, nn);
     wrong_initial_guess_flag = false;
     if ~all(isfinite(fvec))
@@ -135,7 +135,7 @@ else
         while wrong_initial_guess_flag && tentative_number<=in0*10
             tentative_number = tentative_number+1;
             x(idx) = rand(in0, 1)*10;
-            fvec = feval(f, x, arguments{:});
+            fvec = feval(f, x, args{:});
             wrong_initial_guess_flag = ~all(isfinite(fvec));
         end
         % If all previous attempts failed, try with real numbers.
@@ -143,7 +143,7 @@ else
         while wrong_initial_guess_flag && tentative_number<=in0*10
             tentative_number = tentative_number+1;
             x(idx) = randn(in0, 1)*10;
-            fvec = feval(f, x, arguments{:});
+            fvec = feval(f, x, args{:});
             wrong_initial_guess_flag = ~all(isfinite(fvec));
         end
         % Last tentative, ff all previous attempts failed, try with negative numbers.
@@ -151,7 +151,7 @@ else
         while wrong_initial_guess_flag && tentative_number<=in0*10
             tentative_number = tentative_number+1;
             x(idx) = -rand(in0, 1)*10;
-            fvec = feval(f, x, arguments{:});
+            fvec = feval(f, x, args{:});
             wrong_initial_guess_flag = ~all(isfinite(fvec));
         end
     end
@@ -191,7 +191,7 @@ if options.solve_algo == 0
         options4fsolve.Jacobian = 'off';
     end
     if ~isoctave
-        [x, ~, exitval] = fsolve(f, x, options4fsolve, arguments{:});
+        [x, ~, errorcode] = fsolve(f, x, options4fsolve, args{:});
     else
         % Under Octave, use a wrapper, since fsolve() does not have a 4th arg
         if ischar(f)
@@ -199,13 +199,19 @@ if options.solve_algo == 0
         else
             f2 = f;
         end
-        f = @(x) f2(x, arguments{:});
-        % The Octave version of fsolve does not converge when it starts from the solution
-        fvec = feval(f, x);
-        if max(abs(fvec)) >= tolf
-            [x, ~,exitval] = fsolve(f, x, options4fsolve);
-        else
-            exitval = 3;
+        f = @(x) f2(x, args{:});
+        [x, ~, errorcode] = fsolve(f, x, options4fsolve);
+    end
+    if errorcode==1
+        errorflag = false;
+    elseif errorcode>1
+        if ~isoctave
+            if ischar(f)
+                f2 = str2func(f);
+            else
+                f2 = f;
+            end
+            f = @(x) f2(x, args{:});
         end
     end
 
@@ -227,14 +233,13 @@ if options.solve_algo == 0
     else
         errorflag = true;
     end
+    [fvec, fjac] = feval(f, x, args{:});
 elseif options.solve_algo==1
-    [x, errorflag] = solve1(f, x, 1:nn, 1:nn, jacobian_flag, options.gstep, ...
-                            tolf, tolx, ...
-                            maxit, options.debug, arguments{:});
+    [x, errorflag, errorcode] = solve1(f, x, 1:nn, 1:nn, jacobian_flag, options.gstep, tolf, tolx, maxit, [], options.debug, args{:});
+    [fvec, fjac] = feval(f, x, args{:});
 elseif options.solve_algo==9
-    [x, errorflag] = trust_region(f, x, 1:nn, 1:nn, jacobian_flag, options.gstep, ...
-                             tolf, tolx, ...
-                             maxit, options.debug, arguments{:});
+    [x, errorflag, errorcode] = trust_region(f, x, 1:nn, 1:nn, jacobian_flag, options.gstep, tolf, tolx, maxit, options.trust_region_initial_step_bound_factor, options.debug, args{:});
+    [fvec, fjac] = feval(f, x, args{:});
 elseif ismember(options.solve_algo, [2, 12, 4])
     if ismember(options.solve_algo, [2, 12])
         solver = @solve1;
@@ -248,7 +253,7 @@ elseif ismember(options.solve_algo, [2,
         for j = 1:nn
             xdh = x ;
             xdh(j) = xdh(j)+dh(j) ;
-            fjac(:,j) = (feval(f, xdh, arguments{:})-fvec)./dh(j) ;
+            fjac(:,j) = (feval(f, xdh, args{:})-fvec)./dh(j) ;
         end
     end
     [j1,j2,r,s] = dmperm(fjac);
@@ -273,13 +278,13 @@ elseif ismember(options.solve_algo, [2,
                     if fre || any(JAC(r(i), s(i)+(1:l)))
                         % Reevaluation of the residuals is required because the current RHS depends on
                         % variables that potentially have been updated previously.
-                        z = feval(f, x, arguments{:});
+                        z = feval(f, x, args{:});
                         l = 0;
                         fre = false;
                     end
                 else
                     % First iteration requires the evaluation of the residuals.
-                    z = feval(f, x, arguments{:});
+                    z = feval(f, x, args{:});
                 end
                 l = l+1;
                 if isequal(lhs{j1(j)}, endo_names{j2(j)}) || isequal(lhs{j1(j)}, sprintf('log(%s)', endo_names{j2(j)}))
@@ -310,38 +315,47 @@ elseif ismember(options.solve_algo, [2,
                 dprintf('DYNARE_SOLVE (solve_algo=2|4|12): solving block %u with trust_region routine.', i);
             end
         end
-        [x, errorflag] = solver(f, x, j1(j), j2(j), jacobian_flag, ...
-                                options.gstep, ...
-                                tolf, options.solve_tolx, ...
-                                maxit, options.debug, arguments{:});
+        [x, errorflag, errorcode] = solver(f, x, j1(j), j2(j), jacobian_flag, ...
+                                           options.gstep, ...
+                                           tolf, options.solve_tolx, maxit, ...
+                                           options.trust_region_initial_step_bound_factor, ...
+                                           options.debug, args{:});
         fre = true;
         if errorflag
             return
         end
     end
-    fvec = feval(f, x, arguments{:});
+    fvec = feval(f, x, args{:});
     if max(abs(fvec))>tolf
         disp_verbose('Call solver on the full nonlinear problem.',options.verbosity)
-        [x, errorflag] = solver(f, x, 1:nn, 1:nn, jacobian_flag, ...
-                                options.gstep, tolf, options.solve_tolx, ...
-                                maxit, options.debug, arguments{:});
+        [x, errorflag, errorcode] = solver(f, x, 1:nn, 1:nn, jacobian_flag, ...
+                                           options.gstep, tolf, options.solve_tolx, maxit, ...
+                                           options.trust_region_initial_step_bound_factor, ...
+                                           options.debug, args{:});
     end
+    [fvec, fjac] = feval(f, x, args{:});
 elseif options.solve_algo==3
     if jacobian_flag
-        [x, errorflag] = csolve(f, x, f, tolf, maxit, arguments{:});
+        [x, errorcode] = csolve(f, x, f, tolf, maxit, args{:});
     else
-        [x, errorflag] = csolve(f, x, [], tolf, maxit, arguments{:});
+        [x, errorcode] = csolve(f, x, [], tolf, maxit, args{:});
+    end
+    if errorcode==0
+        errorflag = false;
+    else
+        errorflag = true;
     end
-    [fvec, fjac] = feval(f, x, arguments{:});
+    [fvec, fjac] = feval(f, x, args{:});
 elseif options.solve_algo==10
     % LMMCP
     olmmcp = options.lmmcp;
-    [x, ~, exitflag] = lmmcp(f, x, olmmcp.lb, olmmcp.ub, olmmcp, arguments{:});
-    if exitflag==1
+    [x, fvec, errorcode, ~, fjac] = lmmcp(f, x, olmmcp.lb, olmmcp.ub, olmmcp, args{:});
+    if errorcode==1
         errorflag = false;
     else
         errorflag = true;
     end
+    [fvec, fjac] = feval(f, x, args{:});
 elseif options.solve_algo == 11
     % PATH mixed complementary problem
     % PATH linear mixed complementary problem
@@ -353,12 +367,14 @@ elseif options.solve_algo == 11
     omcppath = options.mcppath;
     global mcp_data
     mcp_data.func = f;
-    mcp_data.args = arguments;
+    mcp_data.args = args;
     try
         [x, fval, jac, mu] = pathmcp(x,omcppath.lb,omcppath.ub,'mcp_func',omcppath.A,omcppath.b,omcppath.t,omcppath.mu0);
     catch
         errorflag = true;
     end
+    errorcode = nan; % There is no error code for this algorithm, as PATH is closed source it is unlikely we can fix that.
+    [fvec, fjac] = feval(f, x, args{:});
 elseif ismember(options.solve_algo, [13, 14])
     if ~jacobian_flag
         error('DYNARE_SOLVE: option solve_algo=13|14 needs computed Jacobian')
@@ -370,8 +386,8 @@ elseif ismember(options.solve_algo, [13,
         auxstruct.isloggedlhs = isloggedlhs;
         auxstruct.isauxdiffloggedrhs = isauxdiffloggedrhs;
     end
-    [x, errorflag] = block_trust_region(f, x, tolf, options.solve_tolx, maxit, options.debug, auxstruct, arguments{:});
-    [fvec, fjac] = feval(f, x, arguments{:});
+    [x, errorflag, errorcode] = block_trust_region(f, x, tolf, options.solve_tolx, maxit, options.trust_region_initial_step_bound_factor, options.debug, auxstruct, args{:});
+    [fvec, fjac] = feval(f, x, args{:});
 else
     error('DYNARE_SOLVE: option solve_algo must be one of [0,1,2,3,4,9,10,11,12,13,14]')
 end
Index: dynare-5.1/matlab/loadjson_.m
===================================================================
--- dynare-5.1.orig/matlab/loadjson_.m
+++ dynare-5.1/matlab/loadjson_.m
@@ -9,11 +9,10 @@ function o = loadjson_(jsonfilename)
 % - o              [struct]    content of the JSON file.
 %
 % REMARKS
-% jsondecode builtin was introduced in Matlab R2016b and is not
-% available under Octave. Old Matlab versions and Octave use
-% jsonlab as fallback. 
+% jsondecode builtin was introduced in MATLAB R2016b and in Octave 7.
+% Older MATLAB and Octave versions use jsonlab as fallback.
 
-% Copyright (C) 2020-2021 Dynare Team
+% Copyright © 2020-2022 Dynare Team
 %
 % This file is part of Dynare.
 %
@@ -30,7 +29,7 @@ function o = loadjson_(jsonfilename)
 % You should have received a copy of the GNU General Public License
 % along with Dynare.  If not, see <https://www.gnu.org/licenses/>.
 
-if isoctave() || matlab_ver_less_than('9.1')
+if (isoctave && octave_ver_less_than('7')) || (~isoctave && matlab_ver_less_than('9.1'))
     o = loadjson(jsonfilename);
     return
 end
Index: dynare-5.1/matlab/missing/mex/mjdgges/mjdgges.m
===================================================================
--- dynare-5.1.orig/matlab/missing/mex/mjdgges/mjdgges.m
+++ dynare-5.1/matlab/missing/mex/mjdgges/mjdgges.m
@@ -18,7 +18,7 @@ function [ss, tt, zz, sdim, eigval, info
 % SPECIAL REQUIREMENTS
 %   none.
 
-% Copyright (C) 1996-2020 Dynare Team
+% Copyright © 1996-2022 Dynare Team
 %
 % This file is part of Dynare.
 %
@@ -40,7 +40,7 @@ if nargin > 5 || nargin < 2 || nargout >
 end
 
 if isoctave
-    error('Octave unsupported, since it does not have real qz, ordqz and ordeig')
+    error('Octave unsupported, since it does not have real qz')
 end
 
 [me, ne] = size(e);
@@ -80,4 +80,4 @@ end
 %$     t(1) = 0;
 %$ end
 %$ T = all(t);
-%@eof:1
\ No newline at end of file
+%@eof:1
Index: dynare-5.1/matlab/warning_config.m
===================================================================
--- dynare-5.1.orig/matlab/warning_config.m
+++ dynare-5.1/matlab/warning_config.m
@@ -41,6 +41,7 @@ if isoctave
     warning('off', 'Octave:num-to-str');
     warning('off', 'Octave:resize-on-range-error');
     warning('off', 'Octave:str-to-num');
+    warning('off', 'Octave:array-as-logical');
     warning('off', 'Octave:array-to-scalar');
     warning('off', 'Octave:array-to-vector');
     warning('off', 'Octave:mixed-string-concat');
Index: dynare-5.1/mex/build/octave/configure.ac
===================================================================
--- dynare-5.1.orig/mex/build/octave/configure.ac
+++ dynare-5.1/mex/build/octave/configure.ac
@@ -34,7 +34,9 @@ AR=$($MKOCTFILE -p AR)
 RANLIB=$($MKOCTFILE -p RANLIB)
 CFLAGS=$($MKOCTFILE -p CFLAGS)
 CXXFLAGS=$($MKOCTFILE -p CXXFLAGS)
-LDFLAGS="$($MKOCTFILE -p LFLAGS) $($MKOCTFILE -p LDFLAGS)"
+# The --link-stand-alone is needed since Octave 7 to avoid inserting -shared, which
+# is undesirable for generic LDFLAGS.
+LDFLAGS=$($MKOCTFILE --link-stand-alone -p LDFLAGS)
 
 AC_CANONICAL_HOST
 
Index: dynare-5.1/tests/Makefile.am
===================================================================
--- dynare-5.1.orig/tests/Makefile.am
+++ dynare-5.1/tests/Makefile.am
@@ -1383,7 +1383,7 @@ check-matlab-ols: $(M_OLS_TRS_FILES)
 %.o.trs %.o.log: %.mod
 	@echo "`tput bold``tput setaf 8`OCTAVE: $(CURDIR)/$*... `tput sgr0`"
 	@DYNARE_VERSION="$(PACKAGE_VERSION)" TOP_TEST_DIR="$(CURDIR)" FILESTEM="$*" \
-		$(OCTAVE) --no-init-file --silent --no-history --path "$*.mod" run_test_octave.m > $*.o.log 2>&1 || \
+		xvfb-run -a $(OCTAVE) --no-init-file --silent --no-history --path "$*.mod" run_test_octave.m > $*.o.log 2>&1 || \
 	printf ":test-result: FAIL\n:number-tests: 1\n:number-failed-tests: 1\n:list-of-failed-tests: $*.mod\n:elapsed-time: 0.0\n" > $*.o.trs
 	@if test -z "$(filter $*.o.trs,$(O_XFAIL_TRS_FILES))"; then pass_color=2; fail_color=1; else pass_color=1; fail_color=2; fi; \
 	if grep -q ":test-result: PASS" $*.o.trs; then \
@@ -1398,7 +1398,7 @@ check-matlab-ols: $(M_OLS_TRS_FILES)
 %.o.trs %.o.log : %.m
 	@echo "`tput bold``tput setaf 8`OCTAVE: $(CURDIR)/$*... `tput sgr0`"
 	@DYNARE_VERSION="$(PACKAGE_VERSION)" TOP_TEST_DIR="$(CURDIR)" \
-		$(OCTAVE) --no-init-file --silent --no-history $< > $*.o.log 2>&1 || \
+		xvfb-run -a $(OCTAVE) --no-init-file --silent --no-history $< > $*.o.log 2>&1 || \
 		printf ":test-result: FAIL\n:number-tests: 1\n:number-failed-tests: 1\n:list-of-failed-tests: $*.m\n:elapsed-time: 0.0\n" > $*.o.trs
 	@echo "`tput bold``tput setaf 8`OCTAVE: $(CURDIR)/$* Done!`tput sgr0`"
 
@@ -1412,7 +1412,7 @@ check-matlab-ols: $(M_OLS_TRS_FILES)
 %.o.tls : %.m
 	@echo "`tput bold``tput setaf 8`OCTAVE: $(CURDIR)/$*... `tput sgr0`"
 	@TOP_TEST_DIR="$(CURDIR)"  FILESTEM="$*" \
-		$(OCTAVE) --no-init-file --silent --no-history run_o_script.m 2>&1
+		xvfb-run -a $(OCTAVE) --no-init-file --silent --no-history run_o_script.m 2>&1
 	@touch $*.o.tls
 	@echo "`tput bold``tput setaf 8`OCTAVE: $(CURDIR)/$* Done!`tput sgr0`"
 
Index: dynare-5.1/tests/external_function/no_deriv_given_dll.mod
===================================================================
--- dynare-5.1.orig/tests/external_function/no_deriv_given_dll.mod
+++ dynare-5.1/tests/external_function/no_deriv_given_dll.mod
@@ -55,7 +55,7 @@ end
 if max(max(abs(L.oo_.dr.ghxu - oo_.dr.ghxu))) > 1e-4
   error('Failure in external function')
 end
-if max(max(abs(L.oo_.dr.ghxx - oo_.dr.ghxx))) > 1e-3
+if max(max(abs(L.oo_.dr.ghxx - oo_.dr.ghxx))) > 2e-3
   error('Failure in external function')
 end
 if max(max(abs(L.oo_.dr.ghuu - oo_.dr.ghuu))) > 1e-5
Index: dynare-5.1/tests/run_all_unitary_tests.m
===================================================================
--- dynare-5.1.orig/tests/run_all_unitary_tests.m
+++ dynare-5.1/tests/run_all_unitary_tests.m
@@ -1,4 +1,4 @@
-% Copyright (C) 2013-2020 Dynare Team
+% Copyright © 2013-2022 Dynare Team
 %
 % This file is part of Dynare.
 %
@@ -39,7 +39,7 @@ if isoctave
 end
 
 % Set random seed, for reproducibility
-if isoctave
+if isoctave && octave_ver_less_than('7')
     randn('state',1);
     rand('state',1);
 else
Index: dynare-5.1/tests/run_block_byte_tests_octave.m
===================================================================
--- dynare-5.1.orig/tests/run_block_byte_tests_octave.m
+++ dynare-5.1/tests/run_block_byte_tests_octave.m
@@ -61,8 +61,10 @@ for blockFlag = 0:1
 
         # Workaround for strange race condition related to the static/dynamic
         # files (especially when we switch to/from use_dll)
-        rmdir('+ls2003_tmp', 's');
-        pause(1)
+        if exist('+ls2003_tmp')
+            rmdir('+ls2003_tmp', 's');
+            pause(1)
+        endif
 
         for i = 1:length(solve_algos)
             num_block_tests = num_block_tests + 1;
Index: dynare-5.1/windows/deps/mkoctfile64
===================================================================
--- dynare-5.1.orig/windows/deps/mkoctfile64
+++ dynare-5.1/windows/deps/mkoctfile64
@@ -1,10 +1,10 @@
 #! /bin/sh
 
-## Make sure to keep -static-libgcc, -static-libstdc++ and -static-libgfortran in LDFLAGS and
-## DL_LDFLAGS when updating this file.
-## This is needed to cope for differences between the MinGW libraries shipped by the official Octave
-## package for Windows, and the MinGW libraries from Debian used on the runners.
-## Also keep BINDIR in DEFAULT_LFLAGS (for UMFPACK)
+## Make sure to keep -static-libgcc, -static-libstdc++ and -static-libgfortran
+## in DL_LDFLAGS when updating this file.
+## Do not add -shared in LDFLAGS (i.e. this file should mimick “mkoctfile
+## --link-stand-alone”, see the top of mex/build/configure.ac).
+## Also keep BINDIR in DEFAULT_LDFLAGS (for UMFPACK).
 
 # Exit immediately on any error.
 set -e
