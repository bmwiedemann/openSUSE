From fecf0ef4609e6cd924ad299447e19c87eed908cb Mon Sep 17 00:00:00 2001
From: Jens Georg <mail@jensge.org>
Date: Sun, 22 May 2022 14:29:47 +0200
Subject: [PATCH] Add clang-format file.

---
 .clang-format | 137 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 137 insertions(+)
 create mode 100644 .clang-format

diff --git a/.clang-format b/.clang-format
new file mode 100644
index 0000000..5c2e597
--- /dev/null
+++ b/.clang-format
@@ -0,0 +1,137 @@
+---
+Language:        Cpp
+# BasedOnStyle:  Mozilla
+AccessModifierOffset: -2
+AlignAfterOpenBracket: Align
+AlignConsecutiveMacros: false
+AlignConsecutiveAssignments: false
+AlignConsecutiveDeclarations: false
+AlignEscapedNewlines: Right
+AlignOperands:   true
+AlignTrailingComments: true
+AllowAllArgumentsOnNextLine: false
+AllowAllConstructorInitializersOnNextLine: true
+AllowAllParametersOfDeclarationOnNextLine: false
+AllowShortBlocksOnASingleLine: Never
+AllowShortCaseLabelsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: Inline
+AllowShortLambdasOnASingleLine: All
+AllowShortIfStatementsOnASingleLine: Never
+AllowShortLoopsOnASingleLine: false
+AlwaysBreakAfterDefinitionReturnType: None
+AlwaysBreakAfterReturnType: None
+AlwaysBreakBeforeMultilineStrings: false
+AlwaysBreakTemplateDeclarations: Yes
+BinPackArguments: true
+BinPackParameters: true
+BraceWrapping:
+  AfterCaseLabel:  false
+  AfterClass:      false
+  AfterControlStatement: false
+  AfterEnum:       false
+  AfterFunction:   true
+  AfterNamespace:  false
+  AfterObjCDeclaration: false
+  AfterStruct:     false
+  AfterUnion:      true
+  AfterExternBlock: true
+  BeforeCatch:     false
+  BeforeElse:      false
+  IndentBraces:    false
+  SplitEmptyFunction: true
+  SplitEmptyRecord: false
+  SplitEmptyNamespace: true
+BreakBeforeBinaryOperators: None
+BreakBeforeBraces: Custom
+BreakBeforeInheritanceComma: false
+BreakInheritanceList: BeforeComma
+BreakBeforeTernaryOperators: true
+BreakConstructorInitializersBeforeComma: false
+BreakConstructorInitializers: BeforeComma
+BreakAfterJavaFieldAnnotations: false
+BreakStringLiterals: true
+ColumnLimit:     80
+CommentPragmas:  '^ IWYU pragma:'
+CompactNamespaces: false
+ConstructorInitializerAllOnOneLineOrOnePerLine: false
+ConstructorInitializerIndentWidth: 2
+ContinuationIndentWidth: 8
+Cpp11BracedListStyle: false
+DeriveLineEnding: true
+DerivePointerAlignment: false
+DisableFormat:   false
+ExperimentalAutoDetectBinPacking: false
+FixNamespaceComments: false
+ForEachMacros:
+  - foreach
+  - Q_FOREACH
+  - BOOST_FOREACH
+IncludeBlocks:   Preserve
+IncludeCategories:
+  - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
+    Priority:        2
+    SortPriority:    0
+  - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
+    Priority:        3
+    SortPriority:    0
+  - Regex:           '.*'
+    Priority:        1
+    SortPriority:    0
+IncludeIsMainRegex: '(Test)?$'
+IncludeIsMainSourceRegex: ''
+IndentCaseLabels: false
+IndentGotoLabels: false
+IndentPPDirectives: BeforeHash
+IndentWidth:     8
+IndentWrappedFunctionNames: false
+JavaScriptQuotes: Leave
+JavaScriptWrapImports: true
+KeepEmptyLinesAtTheStartOfBlocks: true
+MacroBlockBegin: ''
+MacroBlockEnd:   ''
+MaxEmptyLinesToKeep: 1
+NamespaceIndentation: None
+ObjCBinPackProtocolList: Auto
+ObjCBlockIndentWidth: 2
+ObjCSpaceAfterProperty: true
+ObjCSpaceBeforeProtocolList: false
+PenaltyBreakAssignment: 2
+PenaltyBreakBeforeFirstCallParameter: 19
+PenaltyBreakComment: 300
+PenaltyBreakFirstLessLess: 120
+PenaltyBreakString: 1000
+PenaltyBreakTemplateDeclaration: 10
+PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 200
+PointerAlignment: Right
+ReflowComments:  false
+SortIncludes:    true
+SortUsingDeclarations: true
+SpaceAfterCStyleCast: true
+SpaceAfterLogicalNot: false
+SpaceAfterTemplateKeyword: false
+SpaceBeforeAssignmentOperators: true
+SpaceBeforeCpp11BracedList: false
+SpaceBeforeCtorInitializerColon: true
+SpaceBeforeInheritanceColon: true
+SpaceBeforeParens: Never
+SpaceBeforeRangeBasedForLoopColon: true
+SpaceInEmptyBlock: false
+SpaceInEmptyParentheses: false
+SpacesBeforeTrailingComments: 1
+SpacesInAngles:  false
+SpacesInConditionalStatement: false
+SpacesInContainerLiterals: true
+SpacesInCStyleCastParentheses: false
+SpacesInParentheses: false
+SpacesInSquareBrackets: false
+SpaceBeforeSquareBrackets: false
+Standard:        Latest
+StatementMacros:
+  - Q_UNUSED
+  - QT_REQUIRE_VERSION
+TabWidth:        8
+UseCRLF:         false
+UseTab:          AlignWithSpaces
+...
+

From 4b64f15fdb21c57cc7f1a7e8a685b14b775d0033 Mon Sep 17 00:00:00 2001
From: Jens Georg <mail@jensge.org>
Date: Sun, 22 May 2022 15:03:51 +0200
Subject: [PATCH] [all] Remove deprecated GUPnP calls

---
 libdleyna/renderer/async.c        |   6 +-
 libdleyna/renderer/device.c       | 533 +++++++++++-----------
 libdleyna/renderer/gasync-task.c  |   2 +
 libdleyna/renderer/host-service.c |   1 +
 libdleyna/renderer/manager.c      |   2 +
 libdleyna/renderer/server.c       | 725 ++++++++++++++----------------
 libdleyna/renderer/task.c         |   2 +
 libdleyna/renderer/upnp.c         |   6 +-
 server/daemon.c                   |   2 +
 9 files changed, 624 insertions(+), 655 deletions(-)

diff --git a/libdleyna/renderer/async.c b/libdleyna/renderer/async.c
index dfbebce..e54e9a2 100644
--- a/libdleyna/renderer/async.c
+++ b/libdleyna/renderer/async.c
@@ -20,6 +20,8 @@
  *
  */
 
+#include <config.h>
+
 #include <libdleyna/core/error.h>
 #include <libdleyna/core/log.h>
 
@@ -54,10 +56,6 @@ void dlr_async_task_cancelled(GCancellable *cancellable, gpointer user_data)
 {
 	dlr_async_task_t *cb_data = user_data;
 
-	if (cb_data->proxy != NULL)
-		gupnp_service_proxy_cancel_action(cb_data->proxy,
-						  cb_data->action);
-
 	if (!cb_data->error)
 		cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
 					     DLEYNA_ERROR_CANCELLED,
diff --git a/libdleyna/renderer/device.c b/libdleyna/renderer/device.c
index e43d812..7c59503 100644
--- a/libdleyna/renderer/device.c
+++ b/libdleyna/renderer/device.c
@@ -20,6 +20,7 @@
  *
  */
 
+#include <config.h>
 
 #include <string.h>
 #include <math.h>
@@ -105,8 +106,8 @@ static void prv_add_player_speed_props(GHashTable *player_props,
 static gint prv_compare_rationals(const gchar *a, const gchar *b);
 
 static void prv_get_position_info(dlr_async_task_t *cb_data,
-				  const gchar *action_name,
-				  GUPnPServiceProxyActionCallback callback);
+                                  const gchar *action_name,
+                                  GAsyncReadyCallback callback);
 
 static void prv_unref_variant(gpointer variant)
 {
@@ -889,20 +890,19 @@ static void prv_introspect_rc_cb (GObject *target,
 	DLEYNA_LOG_DEBUG("Exit");
 }
 
-static gboolean prv_get_protocol_info(
-				dleyna_gasync_task_t *task,
-                        GObject *target)
+static gboolean prv_get_protocol_info(dleyna_gasync_task_t *task,
+                                      GObject *target)
 {
-    GUPnPServiceProxyAction *action;
+	GUPnPServiceProxyAction *action;
 
-    action = gupnp_service_proxy_action_new("GetProtocolInfo", NULL);
+	action = gupnp_service_proxy_action_new("GetProtocolInfo", NULL);
 
-    gupnp_service_proxy_call_action_async(GUPNP_SERVICE_PROXY (target), action,
-            dleyna_gasync_task_get_cancellable (task),
-            prv_get_protocol_info_cb,
-            task);
+	gupnp_service_proxy_call_action_async(
+		GUPNP_SERVICE_PROXY(target), action,
+		dleyna_gasync_task_get_cancellable(task),
+		prv_get_protocol_info_cb, task);
 
-    return FALSE;
+	return FALSE;
 }
 
 static gboolean prv_introspect_av(dleyna_gasync_task_t *task, GObject *target)
@@ -1994,32 +1994,41 @@ static void prv_sink_change_cb(GUPnPServiceProxy *proxy,
 		prv_process_protocol_info(device, sink);
 }
 
-static void prv_get_position_info_cb(GUPnPServiceProxy *proxy,
-				     GUPnPServiceProxyAction *action,
-				     gpointer user_data)
+static void prv_get_position_info_cb(GObject *source, GAsyncResult *res,
+                                     gpointer user_data)
 {
 	gchar *result = NULL;
 	const gchar *message;
-	gboolean end;
 	dlr_async_task_t *cb_data = user_data;
-	GError *error = NULL;
+	g_autoptr(GError) error = NULL;
 	GVariantBuilder *changed_props_vb;
 	GVariant *changed_props;
 
-	end = gupnp_service_proxy_end_action(
-					cb_data->proxy, cb_data->action, &error,
-					"RelTime", G_TYPE_STRING, &result,
-					NULL);
+	g_autoptr(GUPnPServiceProxyAction) action =
+		gupnp_service_proxy_call_action_finish(
+			GUPNP_SERVICE_PROXY(source), res, &error);
 
-	if (!end || (result == NULL)) {
-		message = (error != NULL) ? error->message : "Invalid result";
-		cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-					     DLEYNA_ERROR_OPERATION_FAILED,
-					     "GetPositionInfo operation failed: %s",
-					     message);
+	if(error == NULL) {
+		gupnp_service_proxy_action_get_result(action, &error, "RelTime",
+		                                      G_TYPE_STRING, &result,
+		                                      NULL);
+	}
 
-		if (error != NULL)
-			g_error_free(error);
+	if(error != NULL) {
+		if(error &&
+		   g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
+			                             DLEYNA_ERROR_CANCELLED,
+			                             "Operation cancelled.");
+		} else {
+			message = (error != NULL) ? error->message
+			                          : "Invalid result";
+			cb_data->error = g_error_new(
+				DLEYNA_SERVER_ERROR,
+				DLEYNA_ERROR_OPERATION_FAILED,
+				"GetPositionInfo operation failed: %s",
+				message);
+		}
 
 		goto on_error;
 	}
@@ -2045,35 +2054,45 @@ static void prv_get_position_info_cb(GUPnPServiceProxy *proxy,
 on_error:
 
 	(void) g_idle_add(dlr_async_task_complete, cb_data);
-	g_cancellable_disconnect(cb_data->cancellable, cb_data->cancel_id);
 }
 
-static void prv_get_byte_position_info_cb(GUPnPServiceProxy *proxy,
-					  GUPnPServiceProxyAction *action,
-					  gpointer user_data)
+static void prv_get_byte_position_info_cb(GObject *source, GAsyncResult *res,
+                                          gpointer user_data)
 {
 	gchar *result = NULL;
 	const gchar *message;
-	gboolean end;
 	dlr_async_task_t *cb_data = user_data;
-	GError *error = NULL;
+	g_autoptr(GError) error = NULL;
 	GVariantBuilder *changed_props_vb;
 	GVariant *changed_props;
 
-	end = gupnp_service_proxy_end_action(
-					cb_data->proxy, cb_data->action, &error,
-					"RelByte", G_TYPE_STRING, &result,
-					NULL);
+	g_autoptr(GUPnPServiceProxyAction) action =
+		gupnp_service_proxy_call_action_finish(
+			GUPNP_SERVICE_PROXY(source), res, &error);
+	(void) action;
 
-	if (!end || (result == NULL)) {
-		message = (error != NULL) ? error->message : "Invalid result";
-		cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-					     DLEYNA_ERROR_OPERATION_FAILED,
-					     "X_DLNA_GetBytePositionInfo operation failed: %s",
-					     message);
+	if(error == NULL) {
+		gupnp_service_proxy_action_get_result(action, &error, "RelByte",
+		                                      G_TYPE_STRING, &result,
+		                                      NULL);
+	}
 
-		if (error != NULL)
-			g_error_free(error);
+	if(error != NULL) {
+		if(error &&
+		   g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
+			                             DLEYNA_ERROR_CANCELLED,
+			                             "Operation cancelled.");
+		} else {
+			message = (error != NULL) ? error->message
+			                          : "Invalid result";
+			cb_data->error =
+				g_error_new(DLEYNA_SERVER_ERROR,
+			                    DLEYNA_ERROR_OPERATION_FAILED,
+			                    "X_DLNA_GetBytePositionInfo "
+			                    "operation failed: %s",
+			                    message);
+		}
 
 		goto on_error;
 	}
@@ -2082,13 +2101,12 @@ static void prv_get_byte_position_info_cb(GUPnPServiceProxy *proxy,
 
 	g_strstrip(result);
 
-	prv_add_relcount(cb_data->device, result, changed_props_vb);
+	prv_add_reltime(cb_data->device, result, changed_props_vb);
 
-	changed_props = g_variant_ref_sink(
-				g_variant_builder_end(changed_props_vb));
+	changed_props =
+		g_variant_ref_sink(g_variant_builder_end(changed_props_vb));
 	prv_emit_signal_properties_changed(cb_data->device,
-					   DLR_INTERFACE_PLAYER,
-					   changed_props);
+	                                   DLR_INTERFACE_PLAYER, changed_props);
 	g_variant_unref(changed_props);
 	g_variant_builder_unref(changed_props_vb);
 
@@ -2099,30 +2117,36 @@ static void prv_get_byte_position_info_cb(GUPnPServiceProxy *proxy,
 on_error:
 
 	(void) g_idle_add(dlr_async_task_complete, cb_data);
-	g_cancellable_disconnect(cb_data->cancellable, cb_data->cancel_id);
 }
 
-static void prv_get_all_position_info_cb(GUPnPServiceProxy *proxy,
-					 GUPnPServiceProxyAction *action,
-					 gpointer user_data)
+static void prv_get_all_position_info_cb(GObject *source, GAsyncResult *res,
+                                         gpointer user_data)
 {
 	gchar *result = NULL;
 	dlr_async_task_t *cb_data = user_data;
-	GError *error = NULL;
+	g_autoptr(GError) error = NULL;
 	dlr_device_data_t *device_data = cb_data->private;
 	GVariantBuilder *changed_props_vb;
 	GVariant *changed_props;
+	g_autoptr(GUPnPServiceProxyAction) action = NULL;
 
-	if (!gupnp_service_proxy_end_action(cb_data->proxy,
-					    cb_data->action, &error,
-					    "RelTime", G_TYPE_STRING, &result,
-					    NULL)) {
-		if (error != NULL) {
-			DLEYNA_LOG_WARNING(
-					"GetPositionInfo operation failed: %s",
-					error->message);
+	action = gupnp_service_proxy_call_action_finish(
+		GUPNP_SERVICE_PROXY(source), res, &error);
 
-			g_error_free(error);
+	if(error == NULL) {
+		gupnp_service_proxy_action_get_result(action, &error, "RelTime",
+		                                      G_TYPE_STRING, &result,
+		                                      NULL);
+	}
+
+	if(error != NULL) {
+		DLEYNA_LOG_WARNING("GetPositionInfo operation failed: %s",
+		                   error->message);
+		if(g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
+			                             DLEYNA_ERROR_CANCELLED,
+			                             "Operation cancelled.");
+			goto on_error;
 		}
 	}
 
@@ -2166,31 +2190,43 @@ static void prv_get_all_position_info_cb(GUPnPServiceProxy *proxy,
 on_complete:
 
 	prv_get_props(cb_data);
+
+on_error:
 	(void) g_idle_add(dlr_async_task_complete, cb_data);
-	g_cancellable_disconnect(cb_data->cancellable, cb_data->cancel_id);
 
 	return;
 }
 
-static void prv_get_all_byte_position_info_cb(GUPnPServiceProxy *proxy,
-					      GUPnPServiceProxyAction *action,
-					      gpointer user_data)
+static void prv_get_all_byte_position_info_cb(GObject *source,
+                                              GAsyncResult *res,
+                                              gpointer user_data)
 {
 	gchar *result = NULL;
 	dlr_async_task_t *cb_data = user_data;
-	GError *error = NULL;
+	g_autoptr(GError) error = NULL;
 	dlr_device_data_t *device_data = cb_data->private;
+	g_autoptr(GUPnPServiceProxyAction) action = NULL;
 
-	if (!gupnp_service_proxy_end_action(cb_data->proxy,
-					    cb_data->action, &error,
-					    "RelByte", G_TYPE_STRING, &result,
-					    NULL)) {
-		if (error != NULL) {
-			DLEYNA_LOG_WARNING(
-			      "X_DLNA_GetBytePositionInfo operation failed: %s",
-			      error->message);
+	action = gupnp_service_proxy_call_action_finish(
+		GUPNP_SERVICE_PROXY(source), res, &error);
+
+	if(error == NULL) {
+		gupnp_service_proxy_action_get_result(action, &error, "RelByte",
+		                                      G_TYPE_STRING, &result,
+		                                      NULL);
+	}
 
-			g_error_free(error);
+	if(error != NULL) {
+		DLEYNA_LOG_WARNING(
+			"X_DLNA_GetBytePositionInfo operation failed: %s",
+			error->message);
+		if(g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
+			                             DLEYNA_ERROR_CANCELLED,
+			                             "Operation cancelled.");
+			(void) g_idle_add(dlr_async_task_complete, cb_data);
+
+			return;
 		}
 	}
 
@@ -2204,41 +2240,35 @@ static void prv_get_all_byte_position_info_cb(GUPnPServiceProxy *proxy,
 
 	device_data->ut.get_all_position.rel_cnt = result;
 
-	cb_data->action = gupnp_service_proxy_begin_action(
-						cb_data->proxy,
-						"GetPositionInfo",
-						prv_get_all_position_info_cb,
-						cb_data,
-						"InstanceID", G_TYPE_INT, 0,
-						NULL);
+	cb_data->action = gupnp_service_proxy_action_new(
+		"GetPositionInfo", "InstanceID", G_TYPE_INT, 0, NULL);
+
+	gupnp_service_proxy_call_action_async(
+		GUPNP_SERVICE_PROXY(source), cb_data->action,
+		cb_data->cancellable, prv_get_all_position_info_cb, cb_data);
 
 	return;
 }
 
 static void prv_get_position_info(dlr_async_task_t *cb_data,
-				  const gchar *action_name,
-				  GUPnPServiceProxyActionCallback callback)
+                                  const gchar *action_name,
+                                  GAsyncReadyCallback callback)
 {
 	dlr_device_context_t *context;
 
 	context = dlr_device_get_context(cb_data->device);
 
-	cb_data->cancel_id =
-		g_cancellable_connect(cb_data->cancellable,
-				      G_CALLBACK(dlr_async_task_cancelled),
-				      cb_data, NULL);
 	cb_data->proxy = context->service_proxies.av_proxy;
 
 	g_object_add_weak_pointer((G_OBJECT(context->service_proxies.av_proxy)),
 				  (gpointer *)&cb_data->proxy);
 
-	cb_data->action = gupnp_service_proxy_begin_action(
-						cb_data->proxy,
-						action_name,
-						callback,
-						cb_data,
-						"InstanceID", G_TYPE_INT, 0,
-						NULL);
+	cb_data->action = gupnp_service_proxy_action_new(
+		action_name, "InstanceID", G_TYPE_INT, 0, NULL);
+
+	gupnp_service_proxy_call_action_async(cb_data->proxy, cb_data->action,
+	                                      cb_data->cancellable, callback,
+	                                      cb_data);
 }
 
 /***********************************************************************/
@@ -2452,7 +2482,6 @@ static gboolean prv_props_update(dlr_device_t *device, dlr_task_t *task)
 	GVariant *val;
 	GUPnPDeviceInfo *info;
 	dlr_device_context_t *context;
-	dlr_service_proxies_t *service_proxies;
 	dlr_props_t *props = &device->props;
 	GVariantBuilder *changed_props_vb;
 	GVariant *changed_props;
@@ -2502,29 +2531,41 @@ static gboolean prv_props_update(dlr_device_t *device, dlr_task_t *task)
 	g_variant_unref(changed_props);
 	g_variant_builder_unref(changed_props_vb);
 
-on_lost_device:
-
 	return device_alive;
 }
 
-static void prv_simple_call_cb(GUPnPServiceProxy *proxy,
-			       GUPnPServiceProxyAction *action,
-			       gpointer user_data)
+static void prv_simple_call_cb(GObject *source, GAsyncResult *res,
+                               gpointer user_data)
 {
 	dlr_async_task_t *cb_data = user_data;
-	GError *upnp_error = NULL;
+	g_autoptr(GError) upnp_error = NULL;
 
-	if (!gupnp_service_proxy_end_action(cb_data->proxy, cb_data->action,
-					    &upnp_error, NULL)) {
-		cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-					     DLEYNA_ERROR_OPERATION_FAILED,
-					     "Operation failed: %s",
-					     upnp_error->message);
-		g_error_free(upnp_error);
+	g_autoptr(GUPnPServiceProxyAction) action = NULL;
+
+	action = gupnp_service_proxy_call_action_finish(
+		GUPNP_SERVICE_PROXY(source), res, &upnp_error);
+
+	// TODO: Work-around to catch SOAP errors
+	if(upnp_error == NULL) {
+		gupnp_service_proxy_action_get_result(action, &upnp_error,
+		                                      NULL);
+	}
+
+	if(upnp_error != NULL) {
+		if(g_error_matches(upnp_error, G_IO_ERROR,
+		                   G_IO_ERROR_CANCELLED)) {
+			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
+			                             DLEYNA_ERROR_CANCELLED,
+			                             "Operation cancelled.");
+		} else {
+			cb_data->error = g_error_new(
+				DLEYNA_SERVER_ERROR,
+				DLEYNA_ERROR_OPERATION_FAILED,
+				"Operation failed: %s", upnp_error->message);
+		}
 	}
 
 	(void) g_idle_add(dlr_async_task_complete, cb_data);
-	g_cancellable_disconnect(cb_data->cancellable, cb_data->cancel_id);
 }
 
 static void prv_set_volume(dlr_async_task_t *cb_data, GVariant *params)
@@ -2536,15 +2577,14 @@ static void prv_set_volume(dlr_async_task_t *cb_data, GVariant *params)
 	DLEYNA_LOG_INFO("Set device volume to %d/%d", (guint)volume,
 			cb_data->device->max_volume);
 
-	cb_data->action =
-		gupnp_service_proxy_begin_action(cb_data->proxy, "SetVolume",
-						 prv_simple_call_cb, cb_data,
-						 "InstanceID", G_TYPE_INT, 0,
-						 "Channel",
-						 G_TYPE_STRING, "Master",
-						 "DesiredVolume",
-						 G_TYPE_UINT, (guint) volume,
-						 NULL);
+	cb_data->action = gupnp_service_proxy_action_new(
+		"SetVolume", "InstanceID", G_TYPE_INT, 0, "Channel",
+		G_TYPE_STRING, "Master", "DesiredVolume", G_TYPE_UINT,
+		(guint) volume, NULL);
+
+	gupnp_service_proxy_call_action_async(cb_data->proxy, cb_data->action,
+	                                      cb_data->cancellable,
+	                                      prv_simple_call_cb, cb_data);
 }
 
 static void prv_set_mute(dlr_async_task_t *cb_data, GVariant *params)
@@ -2555,15 +2595,14 @@ static void prv_set_mute(dlr_async_task_t *cb_data, GVariant *params)
 
 	DLEYNA_LOG_INFO("Set device mute state to %s", mute ? "TRUE" : "FALSE");
 
-	cb_data->action =
-		gupnp_service_proxy_begin_action(cb_data->proxy, "SetMute",
-						 prv_simple_call_cb, cb_data,
-						 "InstanceID", G_TYPE_INT, 0,
-						 "Channel",
-						 G_TYPE_STRING, "Master",
-						 "DesiredMute",
-						 G_TYPE_BOOLEAN, mute,
-						 NULL);
+	cb_data->action = gupnp_service_proxy_action_new(
+		"SetMute", "InstanceID", G_TYPE_INT, 0, "Channel",
+		G_TYPE_STRING, "Master", "DesiredMute", G_TYPE_BOOLEAN, mute,
+		NULL);
+
+	gupnp_service_proxy_call_action_async(cb_data->proxy, cb_data->action,
+	                                      cb_data->cancellable,
+	                                      prv_simple_call_cb, cb_data);
 }
 
 static GVariant *prv_get_rate_value_from_double(GVariant *params,
@@ -2721,10 +2760,6 @@ void dlr_device_set_prop(dlr_device_t *device, dlr_task_t *task,
 
 	context = dlr_device_get_context(device);
 
-	cb_data->cancel_id =
-		g_cancellable_connect(cb_data->cancellable,
-				      G_CALLBACK(dlr_async_task_cancelled),
-				      cb_data, NULL);
 	cb_data->proxy = context->service_proxies.rc_proxy;
 
 	g_object_add_weak_pointer((G_OBJECT(context->service_proxies.rc_proxy)),
@@ -2761,7 +2796,7 @@ void dlr_device_get_prop(dlr_device_t *device, dlr_task_t *task,
 	dlr_async_task_t *cb_data = (dlr_async_task_t *)task;
 	dlr_task_get_prop_t *get_prop = &task->ut.get_prop;
 	const gchar *get_position_action;
-	GUPnPServiceProxyActionCallback get_position_cb;
+	GAsyncReadyCallback get_position_cb;
 
 	cb_data->cb = cb;
 	cb_data->device = device;
@@ -2861,23 +2896,17 @@ void dlr_device_play(dlr_device_t *device, dlr_task_t *task,
 	cb_data->cb = cb;
 	cb_data->device = device;
 
-	cb_data->cancel_id =
-		g_cancellable_connect(cb_data->cancellable,
-				      G_CALLBACK(dlr_async_task_cancelled),
-				      cb_data, NULL);
 	cb_data->proxy = context->service_proxies.av_proxy;
 
 	g_object_add_weak_pointer((G_OBJECT(context->service_proxies.av_proxy)),
-				  (gpointer *)&cb_data->proxy);
+	                          (gpointer *) &cb_data->proxy);
 
-	cb_data->action =
-		gupnp_service_proxy_begin_action(cb_data->proxy,
-						 "Play",
-						 prv_simple_call_cb,
-						 cb_data,
-						 "InstanceID", G_TYPE_INT, 0,
-						 "Speed", G_TYPE_STRING,
-						 device->rate, NULL);
+	cb_data->action = gupnp_service_proxy_action_new(
+		"Play", "InstanceID", G_TYPE_INT, 0, "Speed", G_TYPE_STRING,
+		device->rate, NULL);
+	gupnp_service_proxy_call_action_async(cb_data->proxy, cb_data->action,
+	                                      cb_data->cancellable,
+	                                      prv_simple_call_cb, cb_data);
 }
 
 void dlr_device_play_pause(dlr_device_t *device, dlr_task_t *task,
@@ -2907,22 +2936,17 @@ static void prv_simple_command(dlr_device_t *device, dlr_task_t *task,
 	cb_data->cb = cb;
 	cb_data->device = device;
 
-	cb_data->cancel_id =
-		g_cancellable_connect(cb_data->cancellable,
-				      G_CALLBACK(dlr_async_task_cancelled),
-				      cb_data, NULL);
 	cb_data->proxy = context->service_proxies.av_proxy;
 
 	g_object_add_weak_pointer((G_OBJECT(context->service_proxies.av_proxy)),
 				  (gpointer *)&cb_data->proxy);
 
-	cb_data->action =
-		gupnp_service_proxy_begin_action(cb_data->proxy,
-						 command_name,
-						 prv_simple_call_cb,
-						 cb_data,
-						 "InstanceID", G_TYPE_INT, 0,
-						 NULL);
+	cb_data->action = gupnp_service_proxy_action_new(
+		command_name, "InstanceID", G_TYPE_INT, 0, NULL);
+
+	gupnp_service_proxy_call_action_async(cb_data->proxy, cb_data->action,
+	                                      cb_data->cancellable,
+	                                      prv_simple_call_cb, cb_data);
 }
 
 void dlr_device_pause(dlr_device_t *device, dlr_task_t *task,
@@ -3012,23 +3036,37 @@ static void prv_reset_transport_speed_props(dlr_device_t *device)
 	g_variant_builder_unref(changed_props_vb);
 }
 
-static void prv_open_uri_cb(GUPnPServiceProxy *proxy,
-			       GUPnPServiceProxyAction *action,
-			       gpointer user_data)
+static void prv_open_uri_cb(GObject *source, GAsyncResult *res,
+                            gpointer user_data)
 {
 	dlr_async_task_t *cb_data = user_data;
-	GError *upnp_error = NULL;
+	g_autoptr(GError) upnp_error = NULL;
 #if DLEYNA_LOG_LEVEL & DLEYNA_LOG_LEVEL_DEBUG
 	gchar *type;
 #endif
 
-	if (!gupnp_service_proxy_end_action(cb_data->proxy, cb_data->action,
-					    &upnp_error, NULL)) {
-		cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-					     DLEYNA_ERROR_OPERATION_FAILED,
-					     "Operation failed: %s",
-					     upnp_error->message);
-		g_error_free(upnp_error);
+	g_autoptr(GUPnPServiceProxyAction) action =
+		gupnp_service_proxy_call_action_finish(
+			GUPNP_SERVICE_PROXY(source), res, &upnp_error);
+
+	if(upnp_error == NULL) {
+		gupnp_service_proxy_action_get_result(action, &upnp_error,
+		                                      NULL);
+	}
+
+	if(upnp_error != NULL) {
+		if(g_error_matches(upnp_error, G_IO_ERROR,
+		                   G_IO_ERROR_CANCELLED)) {
+			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
+			                             DLEYNA_ERROR_CANCELLED,
+			                             "Operation cancelled.");
+
+		} else {
+			cb_data->error = g_error_new(
+				DLEYNA_SERVER_ERROR,
+				DLEYNA_ERROR_OPERATION_FAILED,
+				"Operation failed: %s", upnp_error->message);
+		}
 
 		goto on_error;
 	}
@@ -3049,22 +3087,19 @@ static void prv_open_uri_cb(GUPnPServiceProxy *proxy,
 #endif
 
 	if (cb_data->task.type == DLR_TASK_OPEN_URI) {
-		cb_data->action =
-			gupnp_service_proxy_begin_action(
-						cb_data->proxy,
-						"Play",
-						prv_simple_call_cb,
-						cb_data,
-						"InstanceID", G_TYPE_INT, 0,
-						"Speed", G_TYPE_STRING,
-						cb_data->device->rate, NULL);
+		cb_data->action = gupnp_service_proxy_action_new(
+			"Play", "InstanceID", G_TYPE_INT, 0, "Speed",
+			G_TYPE_STRING, cb_data->device->rate, NULL);
+		gupnp_service_proxy_call_action_async(
+			GUPNP_SERVICE_PROXY(source), cb_data->action,
+			cb_data->cancellable, prv_simple_call_cb, cb_data);
+
 		goto on_exit;
 	}
 
 on_error:
 
 	(void) g_idle_add(dlr_async_task_complete, cb_data);
-	g_cancellable_disconnect(cb_data->cancellable, cb_data->cancel_id);
 
 on_exit:
 	return;
@@ -3086,28 +3121,20 @@ void dlr_device_open_uri(dlr_device_t *device, dlr_task_t *task,
 	cb_data->cb = cb;
 	cb_data->device = device;
 
-	cb_data->cancel_id =
-		g_cancellable_connect(cb_data->cancellable,
-				      G_CALLBACK(dlr_async_task_cancelled),
-				      cb_data, NULL);
 	cb_data->proxy = context->service_proxies.av_proxy;
 
 	g_object_add_weak_pointer((G_OBJECT(context->service_proxies.av_proxy)),
-				  (gpointer *)&cb_data->proxy);
+	                          (gpointer *) &cb_data->proxy);
 
-	cb_data->action =
-		gupnp_service_proxy_begin_action(cb_data->proxy,
-						 open_uri_data->operation,
-						 prv_open_uri_cb,
-						 cb_data,
-						 "InstanceID", G_TYPE_INT, 0,
-						 open_uri_data->uri_type,
-						 G_TYPE_STRING,
-						 open_uri_data->uri,
-						 open_uri_data->metadata_type,
-						 G_TYPE_STRING,
-						 metadata ? metadata : "",
-						 NULL);
+	cb_data->action = gupnp_service_proxy_action_new(
+		open_uri_data->operation, "InstanceID", G_TYPE_INT, 0,
+		open_uri_data->uri_type, G_TYPE_STRING, open_uri_data->uri,
+		open_uri_data->metadata_type, G_TYPE_STRING,
+		metadata ? metadata : "", NULL);
+
+	gupnp_service_proxy_call_action_async(cb_data->proxy, cb_data->action,
+	                                      cb_data->cancellable,
+	                                      prv_open_uri_cb, cb_data);
 }
 
 static void prv_device_set_position(dlr_device_t *device, dlr_task_t *task,
@@ -3117,7 +3144,7 @@ static void prv_device_set_position(dlr_device_t *device, dlr_task_t *task,
 	dlr_device_context_t *context;
 	dlr_async_task_t *cb_data = (dlr_async_task_t *)task;
 	dlr_task_seek_t *seek_data = &task->ut.seek;
-	gchar *position;
+	g_autofree gchar *position = NULL;
 
 	context = dlr_device_get_context(device);
 	cb_data->cb = cb;
@@ -3133,27 +3160,19 @@ static void prv_device_set_position(dlr_device_t *device, dlr_task_t *task,
 
 	DLEYNA_LOG_INFO("set %s position : %s", pos_type, position);
 
-	cb_data->cancel_id =
-		g_cancellable_connect(cb_data->cancellable,
-				      G_CALLBACK(dlr_async_task_cancelled),
-				      cb_data, NULL);
 	cb_data->cancellable = cb_data->cancellable;
 	cb_data->proxy = context->service_proxies.av_proxy;
 
 	g_object_add_weak_pointer((G_OBJECT(context->service_proxies.av_proxy)),
 				  (gpointer *)&cb_data->proxy);
 
-	cb_data->action =
-		gupnp_service_proxy_begin_action(cb_data->proxy,
-						 "Seek",
-						 prv_simple_call_cb,
-						 cb_data,
-						 "InstanceID", G_TYPE_INT, 0,
-						 "Unit", G_TYPE_STRING,
-						 pos_type,
-						 "Target",
-						 G_TYPE_STRING, position,
-						 NULL);
+	cb_data->action = gupnp_service_proxy_action_new(
+		"Seek", "InstanceID", G_TYPE_INT, 0, "Unit", G_TYPE_STRING,
+		pos_type, "Target", G_TYPE_STRING, position, NULL);
+
+	gupnp_service_proxy_call_action_async(cb_data->proxy, cb_data->action,
+	                                      cb_data->cancellable,
+	                                      prv_simple_call_cb, cb_data);
 
 	g_free(position);
 }
@@ -3164,7 +3183,7 @@ static void prv_device_seek_set_position(dlr_device_t *device, dlr_task_t *task,
 {
 	dlr_async_task_t *cb_data = (dlr_async_task_t *)task;
 	dlr_task_seek_t *seek_data = &task->ut.seek;
-	gchar *position;
+	g_autofree gchar *position;
 
 	cb_data->cb = cb;
 	cb_data->device = device;
@@ -3177,54 +3196,56 @@ static void prv_device_seek_set_position(dlr_device_t *device, dlr_task_t *task,
 
 	DLEYNA_LOG_INFO("set %s position : %s", pos_type, position);
 
-	cb_data->action =
-		gupnp_service_proxy_begin_action(cb_data->proxy,
-						 "Seek",
-						 prv_simple_call_cb,
-						 cb_data,
-						 "InstanceID", G_TYPE_INT, 0,
-						 "Unit", G_TYPE_STRING,
-						 pos_type,
-						 "Target",
-						 G_TYPE_STRING, position,
-						 NULL);
+	cb_data->action = gupnp_service_proxy_action_new(
+		"Seek", "InstanceID", G_TYPE_INT, 0, "Unit", G_TYPE_STRING,
+		pos_type, "Target", G_TYPE_STRING, position, NULL);
 
-	g_free(position);
+	gupnp_service_proxy_call_action_async(cb_data->proxy, cb_data->action,
+	                                      cb_data->cancellable,
+	                                      prv_simple_call_cb, cb_data);
 }
 
-static void prv_complete_seek_get_position(GUPnPServiceProxy *proxy,
-					   GUPnPServiceProxyAction *action,
-					   gpointer user_data)
+static void prv_complete_seek_get_position(GObject *source, GAsyncResult *res,
+                                           gpointer user_data)
 {
-	gchar *result = NULL;
+	g_autofree gchar *result = NULL;
 	const gchar *message;
-	gboolean end;
-	GError *error = NULL;
+	g_autoptr(GError) error = NULL;
 	dlr_async_task_t *cb_data = user_data;
 	dlr_task_t *task = &cb_data->task;
 	dlr_task_seek_t *seek_data = &task->ut.seek;
 	guint64 count;
 
-	end = gupnp_service_proxy_end_action(
-					proxy, action, &error,
-					(task->type == DLR_TASK_SEEK) ?
-						"RelTime" : "RelByte",
-					G_TYPE_STRING, &result,
-					NULL);
+	g_autoptr(GUPnPServiceProxyAction) action =
+		gupnp_service_proxy_call_action_finish(
+			GUPNP_SERVICE_PROXY(source), res, &error);
 
-	if (!end || (result == NULL)) {
-		message = (error != NULL) ? error->message : "Invalid result";
-		cb_data->error =
-			g_error_new(
-			  DLEYNA_SERVER_ERROR,
-			  DLEYNA_ERROR_OPERATION_FAILED,
-			  "%s operation failed: %s",
-			  (task->type == DLR_TASK_SEEK) ?
-			      "GetPositionInfo" : "X_DLNA_GetBytePositionInfo",
-			  message);
+	if(error == NULL) {
+		gupnp_service_proxy_action_get_result(
+			action, &error,
+			(task->type == DLR_TASK_SEEK) ? "RelTime" : "RelByte",
+			G_TYPE_STRING, &result, NULL);
+	}
 
-		if (error != NULL)
-			g_error_free(error);
+	if(error != NULL) {
+		if(error &&
+		   g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
+			                             DLEYNA_ERROR_CANCELLED,
+			                             "Operation cancelled.");
+		} else {
+
+			message = (error != NULL) ? error->message
+			                          : "Invalid result";
+			cb_data->error = g_error_new(
+				DLEYNA_SERVER_ERROR,
+				DLEYNA_ERROR_OPERATION_FAILED,
+				"%s operation failed: %s",
+				(task->type == DLR_TASK_SEEK)
+					? "GetPositionInfo"
+					: "X_DLNA_GetBytePositionInfo",
+				message);
+		}
 
 		goto on_error;
 	}
@@ -3245,14 +3266,11 @@ static void prv_complete_seek_get_position(GUPnPServiceProxy *proxy,
 					     "X_DLNA_REL_BYTE", cb_data->cb);
 	}
 
-	g_free(result);
-
 	return;
 
 on_error:
 
 	(void) g_idle_add(dlr_async_task_complete, task);
-	g_cancellable_disconnect(cb_data->cancellable, cb_data->cancel_id);
 }
 
 void dlr_device_seek(dlr_device_t *device, dlr_task_t *task,
@@ -3396,7 +3414,6 @@ static void prv_get_icon_session_cb(SoupSession *session,
 	}
 
 	(void) g_idle_add(dlr_async_task_complete, cb_data);
-	g_cancellable_disconnect(cb_data->cancellable, cb_data->cancel_id);
 
 out:
 
diff --git a/libdleyna/renderer/gasync-task.c b/libdleyna/renderer/gasync-task.c
index 0c65a22..544c056 100644
--- a/libdleyna/renderer/gasync-task.c
+++ b/libdleyna/renderer/gasync-task.c
@@ -18,6 +18,8 @@
  *
  */
 
+#include <config.h>
+
 #include "gasync-task.h"
 #include <libdleyna/core/task-processor.h>
 
diff --git a/libdleyna/renderer/host-service.c b/libdleyna/renderer/host-service.c
index eeb0c46..2e7e315 100644
--- a/libdleyna/renderer/host-service.c
+++ b/libdleyna/renderer/host-service.c
@@ -20,6 +20,7 @@
  *
  */
 
+#include <config.h>
 
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/libdleyna/renderer/manager.c b/libdleyna/renderer/manager.c
index bea9935..1aa981c 100644
--- a/libdleyna/renderer/manager.c
+++ b/libdleyna/renderer/manager.c
@@ -20,6 +20,8 @@
  *
  */
 
+#include <config.h>
+
 #include <glib.h>
 #include <string.h>
 
diff --git a/libdleyna/renderer/server.c b/libdleyna/renderer/server.c
index ed552fa..23d3061 100644
--- a/libdleyna/renderer/server.c
+++ b/libdleyna/renderer/server.c
@@ -20,6 +20,7 @@
  *
  */
 
+#include <config.h>
 
 #include <signal.h>
 #include <stdbool.h>
@@ -138,358 +139,336 @@ static dlr_context_t g_context;
 
 static const gchar g_root_introspection[] =
 	"<node>"
-	"  <interface name='"DLEYNA_SERVER_INTERFACE_MANAGER"'>"
-	"    <method name='"DLR_INTERFACE_GET_VERSION"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_VERSION"'"
+	"  <interface name='" DLEYNA_SERVER_INTERFACE_MANAGER "'>"
+	"    <method name='" DLR_INTERFACE_GET_VERSION "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_VERSION "'"
 	"           direction='out'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_RELEASE"'>"
+	"    <method name='" DLR_INTERFACE_RELEASE "'>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_GET_RENDERERS"'>"
-	"      <arg type='ao' name='"DLR_INTERFACE_RENDERERS"'"
+	"    <method name='" DLR_INTERFACE_GET_RENDERERS "'>"
+	"      <arg type='ao' name='" DLR_INTERFACE_RENDERERS "'"
 	"           direction='out'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_RESCAN"'>"
+	"    <method name='" DLR_INTERFACE_RESCAN "'>"
 	"    </method>"
-	"    <signal name='"DLR_INTERFACE_FOUND_RENDERER"'>"
-	"      <arg type='o' name='"DLR_INTERFACE_PATH"'/>"
+	"    <signal name='" DLR_INTERFACE_FOUND_RENDERER "'>"
+	"      <arg type='o' name='" DLR_INTERFACE_PATH "'/>"
 	"    </signal>"
-	"    <signal name='"DLR_INTERFACE_LOST_RENDERER"'>"
-	"      <arg type='o' name='"DLR_INTERFACE_PATH"'/>"
+	"    <signal name='" DLR_INTERFACE_LOST_RENDERER "'>"
+	"      <arg type='o' name='" DLR_INTERFACE_PATH "'/>"
 	"    </signal>"
-	"    <property type='as' name='"DLR_INTERFACE_PROP_NEVER_QUIT"'"
+	"    <property type='as' name='" DLR_INTERFACE_PROP_NEVER_QUIT "'"
 	"       access='readwrite'/>"
-	"    <property type='as' name='"DLR_INTERFACE_PROP_WHITE_LIST_ENTRIES"'"
+	"    <property type='as' name='" DLR_INTERFACE_PROP_WHITE_LIST_ENTRIES
+	"'"
 	"       access='readwrite'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_WHITE_LIST_ENABLED"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_WHITE_LIST_ENABLED
+	"'"
 	"       access='readwrite'/>"
 	"  </interface>"
-	"  <interface name='"DLR_INTERFACE_PROPERTIES"'>"
-	"    <method name='"DLR_INTERFACE_GET"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_INTERFACE_NAME"'"
+	"  <interface name='" DLR_INTERFACE_PROPERTIES "'>"
+	"    <method name='" DLR_INTERFACE_GET "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_INTERFACE_NAME "'"
 	"           direction='in'/>"
-	"      <arg type='s' name='"DLR_INTERFACE_PROPERTY_NAME"'"
+	"      <arg type='s' name='" DLR_INTERFACE_PROPERTY_NAME "'"
 	"           direction='in'/>"
-	"      <arg type='v' name='"DLR_INTERFACE_VALUE"'"
+	"      <arg type='v' name='" DLR_INTERFACE_VALUE "'"
 	"           direction='out'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_GET_ALL"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_INTERFACE_NAME"'"
+	"    <method name='" DLR_INTERFACE_GET_ALL "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_INTERFACE_NAME "'"
 	"           direction='in'/>"
-	"      <arg type='a{sv}' name='"DLR_INTERFACE_PROPERTIES_VALUE"'"
+	"      <arg type='a{sv}' name='" DLR_INTERFACE_PROPERTIES_VALUE "'"
 	"           direction='out'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_SET"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_INTERFACE_NAME"'"
+	"    <method name='" DLR_INTERFACE_SET "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_INTERFACE_NAME "'"
 	"           direction='in'/>"
-	"      <arg type='s' name='"DLR_INTERFACE_PROPERTY_NAME"'"
+	"      <arg type='s' name='" DLR_INTERFACE_PROPERTY_NAME "'"
 	"           direction='in'/>"
-	"      <arg type='v' name='"DLR_INTERFACE_VALUE"'"
+	"      <arg type='v' name='" DLR_INTERFACE_VALUE "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <signal name='"DLR_INTERFACE_PROPERTIES_CHANGED"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_INTERFACE_NAME"'/>"
-	"      <arg type='a{sv}' name='"DLR_INTERFACE_CHANGED_PROPERTIES"'/>"
-	"      <arg type='as' name='"
-	DLR_INTERFACE_INVALIDATED_PROPERTIES"'/>"
+	"    <signal name='" DLR_INTERFACE_PROPERTIES_CHANGED "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_INTERFACE_NAME "'/>"
+	"      <arg type='a{sv}' name='" DLR_INTERFACE_CHANGED_PROPERTIES "'/>"
+	"      <arg type='as' name='" DLR_INTERFACE_INVALIDATED_PROPERTIES "'/>"
 	"    </signal>"
 	"  </interface>"
 	"</node>";
 
 static const gchar g_server_introspection[] =
 	"<node>"
-	"  <interface name='"DLR_INTERFACE_PROPERTIES"'>"
-	"    <method name='"DLR_INTERFACE_GET"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_INTERFACE_NAME"'"
+	"  <interface name='" DLR_INTERFACE_PROPERTIES "'>"
+	"    <method name='" DLR_INTERFACE_GET "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_INTERFACE_NAME "'"
 	"           direction='in'/>"
-	"      <arg type='s' name='"DLR_INTERFACE_PROPERTY_NAME"'"
+	"      <arg type='s' name='" DLR_INTERFACE_PROPERTY_NAME "'"
 	"           direction='in'/>"
-	"      <arg type='v' name='"DLR_INTERFACE_VALUE"'"
+	"      <arg type='v' name='" DLR_INTERFACE_VALUE "'"
 	"           direction='out'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_GET_ALL"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_INTERFACE_NAME"'"
+	"    <method name='" DLR_INTERFACE_GET_ALL "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_INTERFACE_NAME "'"
 	"           direction='in'/>"
-	"      <arg type='a{sv}' name='"DLR_INTERFACE_PROPERTIES_VALUE"'"
+	"      <arg type='a{sv}' name='" DLR_INTERFACE_PROPERTIES_VALUE "'"
 	"           direction='out'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_SET"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_INTERFACE_NAME"'"
+	"    <method name='" DLR_INTERFACE_SET "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_INTERFACE_NAME "'"
 	"           direction='in'/>"
-	"      <arg type='s' name='"DLR_INTERFACE_PROPERTY_NAME"'"
+	"      <arg type='s' name='" DLR_INTERFACE_PROPERTY_NAME "'"
 	"           direction='in'/>"
-	"      <arg type='v' name='"DLR_INTERFACE_VALUE"'"
+	"      <arg type='v' name='" DLR_INTERFACE_VALUE "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <signal name='"DLR_INTERFACE_PROPERTIES_CHANGED"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_INTERFACE_NAME"'/>"
-	"      <arg type='a{sv}' name='"DLR_INTERFACE_CHANGED_PROPERTIES"'/>"
-	"      <arg type='as' name='"DLR_INTERFACE_INVALIDATED_PROPERTIES"'/>"
+	"    <signal name='" DLR_INTERFACE_PROPERTIES_CHANGED "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_INTERFACE_NAME "'/>"
+	"      <arg type='a{sv}' name='" DLR_INTERFACE_CHANGED_PROPERTIES "'/>"
+	"      <arg type='as' name='" DLR_INTERFACE_INVALIDATED_PROPERTIES "'/>"
 	"    </signal>"
 	"  </interface>"
-	"  <interface name='"DLR_INTERFACE_SERVER"'>"
-	"    <method name='"DLR_INTERFACE_RAISE"'>"
+	"  <interface name='" DLR_INTERFACE_SERVER "'>"
+	"    <method name='" DLR_INTERFACE_RAISE "'>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_QUIT"'>"
+	"    <method name='" DLR_INTERFACE_QUIT "'>"
 	"    </method>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_CAN_QUIT"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_CAN_QUIT "'"
 	"       access='read'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_CAN_RAISE"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_CAN_RAISE "'"
 	"       access='read'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_CAN_SET_FULLSCREEN"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_CAN_SET_FULLSCREEN
+	"'"
 	"       access='read'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_HAS_TRACK_LIST"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_HAS_TRACK_LIST "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_IDENTITY"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_IDENTITY "'"
 	"       access='read'/>"
-	"    <property type='as' name='"DLR_INTERFACE_PROP_SUPPORTED_URIS"'"
+	"    <property type='as' name='" DLR_INTERFACE_PROP_SUPPORTED_URIS "'"
 	"       access='read'/>"
-	"    <property type='as' name='"DLR_INTERFACE_PROP_SUPPORTED_MIME"'"
+	"    <property type='as' name='" DLR_INTERFACE_PROP_SUPPORTED_MIME "'"
 	"       access='read'/>"
 	"  </interface>"
-	"  <interface name='"DLR_INTERFACE_PLAYER"'>"
-	"    <method name='"DLR_INTERFACE_PLAY"'>"
+	"  <interface name='" DLR_INTERFACE_PLAYER "'>"
+	"    <method name='" DLR_INTERFACE_PLAY "'>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_PAUSE"'>"
+	"    <method name='" DLR_INTERFACE_PAUSE "'>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_PLAY_PAUSE"'>"
+	"    <method name='" DLR_INTERFACE_PLAY_PAUSE "'>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_STOP"'>"
+	"    <method name='" DLR_INTERFACE_STOP "'>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_NEXT"'>"
+	"    <method name='" DLR_INTERFACE_NEXT "'>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_PREVIOUS"'>"
+	"    <method name='" DLR_INTERFACE_PREVIOUS "'>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_OPEN_URI"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_URI"'"
+	"    <method name='" DLR_INTERFACE_OPEN_URI "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_URI "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_OPEN_URI_EX"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_URI"'"
+	"    <method name='" DLR_INTERFACE_OPEN_URI_EX "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_URI "'"
 	"           direction='in'/>"
-	"      <arg type='s' name='"DLR_INTERFACE_METADATA"'"
+	"      <arg type='s' name='" DLR_INTERFACE_METADATA "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_OPEN_NEXT_URI"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_URI"'"
+	"    <method name='" DLR_INTERFACE_OPEN_NEXT_URI "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_URI "'"
 	"           direction='in'/>"
-	"      <arg type='s' name='"DLR_INTERFACE_METADATA"'"
+	"      <arg type='s' name='" DLR_INTERFACE_METADATA "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_SET_URI"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_URI"'"
+	"    <method name='" DLR_INTERFACE_SET_URI "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_URI "'"
 	"           direction='in'/>"
-	"      <arg type='s' name='"DLR_INTERFACE_METADATA"'"
+	"      <arg type='s' name='" DLR_INTERFACE_METADATA "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_SEEK"'>"
-	"      <arg type='x' name='"DLR_INTERFACE_OFFSET"'"
+	"    <method name='" DLR_INTERFACE_SEEK "'>"
+	"      <arg type='x' name='" DLR_INTERFACE_OFFSET "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_BYTE_SEEK"'>"
-	"      <arg type='x' name='"DLR_INTERFACE_OFFSET"'"
+	"    <method name='" DLR_INTERFACE_BYTE_SEEK "'>"
+	"      <arg type='x' name='" DLR_INTERFACE_OFFSET "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_SET_POSITION"'>"
-	"      <arg type='o' name='"DLR_INTERFACE_TRACKID"'"
+	"    <method name='" DLR_INTERFACE_SET_POSITION "'>"
+	"      <arg type='o' name='" DLR_INTERFACE_TRACKID "'"
 	"           direction='in'/>"
-	"      <arg type='x' name='"DLR_INTERFACE_POSITION"'"
+	"      <arg type='x' name='" DLR_INTERFACE_POSITION "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_SET_BYTE_POSITION"'>"
-	"      <arg type='o' name='"DLR_INTERFACE_TRACKID"'"
+	"    <method name='" DLR_INTERFACE_SET_BYTE_POSITION "'>"
+	"      <arg type='o' name='" DLR_INTERFACE_TRACKID "'"
 	"           direction='in'/>"
-	"      <arg type='x' name='"DLR_INTERFACE_BYTE_POSITION"'"
+	"      <arg type='x' name='" DLR_INTERFACE_BYTE_POSITION "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_GOTO_TRACK"'>"
-	"      <arg type='u' name='"DLR_INTERFACE_TRACK_NUMBER"'"
+	"    <method name='" DLR_INTERFACE_GOTO_TRACK "'>"
+	"      <arg type='u' name='" DLR_INTERFACE_TRACK_NUMBER "'"
 	"           direction='in'/>"
 	"    </method>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_PLAYBACK_STATUS"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_PLAYBACK_STATUS "'"
 	"       access='read'/>"
-	"    <property type='d' name='"DLR_INTERFACE_PROP_RATE"'"
+	"    <property type='d' name='" DLR_INTERFACE_PROP_RATE "'"
 	"       access='readwrite'/>"
-	"    <property type='d' name='"DLR_INTERFACE_PROP_MINIMUM_RATE"'"
+	"    <property type='d' name='" DLR_INTERFACE_PROP_MINIMUM_RATE "'"
 	"       access='read'/>"
-	"    <property type='d' name='"DLR_INTERFACE_PROP_MAXIMUM_RATE"'"
+	"    <property type='d' name='" DLR_INTERFACE_PROP_MAXIMUM_RATE "'"
 	"       access='read'/>"
 	"    <property type='ad'"
-	"       name='"DLR_INTERFACE_PROP_TRANSPORT_PLAY_SPEEDS"'"
+	"       name='" DLR_INTERFACE_PROP_TRANSPORT_PLAY_SPEEDS "'"
 	"       access='read'/>"
-	"    <property type='d' name='"DLR_INTERFACE_PROP_VOLUME"'"
+	"    <property type='d' name='" DLR_INTERFACE_PROP_VOLUME "'"
 	"       access='readwrite'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_CAN_PLAY"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_CAN_PLAY "'"
 	"       access='read'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_CAN_SEEK"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_CAN_SEEK "'"
 	"       access='read'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_CAN_BYTE_SEEK"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_CAN_BYTE_SEEK "'"
 	"       access='read'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_CAN_CONTROL"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_CAN_CONTROL "'"
 	"       access='read'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_CAN_PAUSE"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_CAN_PAUSE "'"
 	"       access='read'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_CAN_NEXT"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_CAN_NEXT "'"
 	"       access='read'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_CAN_PREVIOUS"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_CAN_PREVIOUS "'"
 	"       access='read'/>"
-	"    <property type='x' name='"DLR_INTERFACE_PROP_POSITION"'"
+	"    <property type='x' name='" DLR_INTERFACE_PROP_POSITION "'"
 	"       access='read'/>"
-	"    <property type='x' name='"DLR_INTERFACE_PROP_BYTE_POSITION"'"
+	"    <property type='x' name='" DLR_INTERFACE_PROP_BYTE_POSITION "'"
 	"       access='read'/>"
-	"    <property type='a{sv}' name='"DLR_INTERFACE_PROP_METADATA"'"
+	"    <property type='a{sv}' name='" DLR_INTERFACE_PROP_METADATA "'"
 	"       access='read'/>"
-	"    <property type='u' name='"DLR_INTERFACE_PROP_CURRENT_TRACK"'"
+	"    <property type='u' name='" DLR_INTERFACE_PROP_CURRENT_TRACK "'"
 	"       access='read'/>"
-	"    <property type='u' name='"DLR_INTERFACE_PROP_NUMBER_OF_TRACKS"'"
+	"    <property type='u' name='" DLR_INTERFACE_PROP_NUMBER_OF_TRACKS "'"
 	"       access='read'/>"
-	"    <property type='b' name='"DLR_INTERFACE_PROP_MUTE"'"
+	"    <property type='b' name='" DLR_INTERFACE_PROP_MUTE "'"
 	"       access='readwrite'/>"
 	"  </interface>"
-	"  <interface name='"DLEYNA_INTERFACE_PUSH_HOST"'>"
-	"    <method name='"DLR_INTERFACE_HOST_FILE"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_PATH"'"
+	"  <interface name='" DLEYNA_INTERFACE_PUSH_HOST "'>"
+	"    <method name='" DLR_INTERFACE_HOST_FILE "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_PATH "'"
 	"           direction='in'/>"
-	"      <arg type='s' name='"DLR_INTERFACE_URI"'"
+	"      <arg type='s' name='" DLR_INTERFACE_URI "'"
 	"           direction='out'/>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_REMOVE_FILE"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_PATH"'"
+	"    <method name='" DLR_INTERFACE_REMOVE_FILE "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_PATH "'"
 	"           direction='in'/>"
 	"    </method>"
 	"  </interface>"
-	"  <interface name='"DLEYNA_SERVER_INTERFACE_RENDERER_DEVICE"'>"
-	"    <method name='"DLR_INTERFACE_CANCEL"'>"
+	"  <interface name='" DLEYNA_SERVER_INTERFACE_RENDERER_DEVICE "'>"
+	"    <method name='" DLR_INTERFACE_CANCEL "'>"
 	"    </method>"
-	"    <method name='"DLR_INTERFACE_GET_ICON"'>"
-	"      <arg type='s' name='"DLR_INTERFACE_REQ_MIME_TYPE"'"
+	"    <method name='" DLR_INTERFACE_GET_ICON "'>"
+	"      <arg type='s' name='" DLR_INTERFACE_REQ_MIME_TYPE "'"
 	"           direction='in'/>"
-	"      <arg type='s' name='"DLR_INTERFACE_RESOLUTION"'"
+	"      <arg type='s' name='" DLR_INTERFACE_RESOLUTION "'"
 	"           direction='in'/>"
-	"      <arg type='ay' name='"DLR_INTERFACE_ICON_BYTES"'"
+	"      <arg type='ay' name='" DLR_INTERFACE_ICON_BYTES "'"
 	"           direction='out'/>"
-	"      <arg type='s' name='"DLR_INTERFACE_MIME_TYPE"'"
+	"      <arg type='s' name='" DLR_INTERFACE_MIME_TYPE "'"
 	"           direction='out'/>"
 	"    </method>"
 	"    <property type='as' "
-	"       name='"DLR_INTERFACE_PROP_DLNA_DEVICE_CLASSES"'"
+	"       name='" DLR_INTERFACE_PROP_DLNA_DEVICE_CLASSES "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_DEVICE_TYPE"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_DEVICE_TYPE "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_UDN"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_UDN "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_FRIENDLY_NAME"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_FRIENDLY_NAME "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_ICON_URL"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_ICON_URL "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_MANUFACTURER"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_MANUFACTURER "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_MANUFACTURER_URL"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_MANUFACTURER_URL "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_MODEL_DESCRIPTION"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_MODEL_DESCRIPTION "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_MODEL_NAME"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_MODEL_NAME "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_MODEL_NUMBER"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_MODEL_NUMBER "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_SERIAL_NUMBER"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_SERIAL_NUMBER "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_PRESENTATION_URL"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_PRESENTATION_URL "'"
 	"       access='read'/>"
-	"    <property type='s' name='"DLR_INTERFACE_PROP_PROTOCOL_INFO"'"
+	"    <property type='s' name='" DLR_INTERFACE_PROP_PROTOCOL_INFO "'"
 	"       access='read'/>"
 	"  </interface>"
 	"</node>";
 
 static const gchar *g_manager_interfaces[DLR_MANAGER_INTERFACE_INFO_MAX] = {
 	/* MUST be in the exact same order as g_root_introspection */
-	DLEYNA_SERVER_INTERFACE_MANAGER,
-	DLR_INTERFACE_PROPERTIES
+	DLEYNA_SERVER_INTERFACE_MANAGER, DLR_INTERFACE_PROPERTIES
 };
 
 static void prv_process_task(dleyna_task_atom_t *task, gpointer user_data);
 
-static void prv_manager_root_method_call(dleyna_connector_id_t conn,
-					 const gchar *sender,
-					 const gchar *object,
-					 const gchar *interface,
-					 const gchar *method,
-					 GVariant *parameters,
-					 dleyna_connector_msg_id_t invocation);
-
-static void prv_manager_props_method_call(dleyna_connector_id_t conn,
-					  const gchar *sender,
-					  const gchar *object,
-					  const gchar *interface,
-					  const gchar *method,
-					  GVariant *parameters,
-					  dleyna_connector_msg_id_t invocation);
+static void prv_manager_root_method_call(
+	dleyna_connector_id_t conn, const gchar *sender, const gchar *object,
+	const gchar *interface, const gchar *method, GVariant *parameters,
+	dleyna_connector_msg_id_t invocation);
+
+static void prv_manager_props_method_call(
+	dleyna_connector_id_t conn, const gchar *sender, const gchar *object,
+	const gchar *interface, const gchar *method, GVariant *parameters,
+	dleyna_connector_msg_id_t invocation);
 
 static void prv_dlr_device_method_call(dleyna_connector_id_t conn,
-				       const gchar *sender,
-				       const gchar *object,
-				       const gchar *interface,
-				       const gchar *method,
-				       GVariant *parameters,
-				       dleyna_connector_msg_id_t invocation);
+                                       const gchar *sender, const gchar *object,
+                                       const gchar *interface,
+                                       const gchar *method,
+                                       GVariant *parameters,
+                                       dleyna_connector_msg_id_t invocation);
 
 static void prv_props_method_call(dleyna_connector_id_t conn,
-				  const gchar *sender,
-				  const gchar *object,
-				  const gchar *interface,
-				  const gchar *method,
-				  GVariant *parameters,
-				  dleyna_connector_msg_id_t invocation);
+                                  const gchar *sender, const gchar *object,
+                                  const gchar *interface, const gchar *method,
+                                  GVariant *parameters,
+                                  dleyna_connector_msg_id_t invocation);
 
 static void prv_dlr_player_method_call(dleyna_connector_id_t conn,
-				       const gchar *sender,
-				       const gchar *object,
-				       const gchar *interface,
-				       const gchar *method,
-				       GVariant *parameters,
-				       dleyna_connector_msg_id_t invocation);
-
-static void prv_dlr_push_host_method_call(dleyna_connector_id_t conn,
-					  const gchar *sender,
-					  const gchar *object,
-					  const gchar *interface,
-					  const gchar *method,
-					  GVariant *parameters,
-					  dleyna_connector_msg_id_t invocation);
+                                       const gchar *sender, const gchar *object,
+                                       const gchar *interface,
+                                       const gchar *method,
+                                       GVariant *parameters,
+                                       dleyna_connector_msg_id_t invocation);
+
+static void prv_dlr_push_host_method_call(
+	dleyna_connector_id_t conn, const gchar *sender, const gchar *object,
+	const gchar *interface, const gchar *method, GVariant *parameters,
+	dleyna_connector_msg_id_t invocation);
 
 static void prv_renderer_device_method_call(
-					dleyna_connector_id_t conn,
-					const gchar *sender,
-					const gchar *object,
-					const gchar *interface,
-					const gchar *method,
-					GVariant *parameters,
-					dleyna_connector_msg_id_t invocation);
+	dleyna_connector_id_t conn, const gchar *sender, const gchar *object,
+	const gchar *interface, const gchar *method, GVariant *parameters,
+	dleyna_connector_msg_id_t invocation);
 
 static const dleyna_connector_dispatch_cb_t
-			g_root_vtables[DLR_MANAGER_INTERFACE_INFO_MAX] = {
-	/* MUST be in the exact same order as g_root_introspection */
-	prv_manager_root_method_call,
-	prv_manager_props_method_call
-};
+	g_root_vtables[DLR_MANAGER_INTERFACE_INFO_MAX] = {
+		/* MUST be in the exact same order as g_root_introspection */
+		prv_manager_root_method_call, prv_manager_props_method_call
+	};
 
 static const dleyna_connector_dispatch_cb_t
-				g_server_vtables[DLR_INTERFACE_INFO_MAX] = {
-	/* MUST be in the exact same order as g_server_introspection */
-	prv_props_method_call,
-	prv_dlr_device_method_call,
-	prv_dlr_player_method_call,
-	prv_dlr_push_host_method_call,
-	prv_renderer_device_method_call
-};
+	g_server_vtables[DLR_INTERFACE_INFO_MAX] = {
+		/* MUST be in the exact same order as g_server_introspection */
+		prv_props_method_call, prv_dlr_device_method_call,
+		prv_dlr_player_method_call, prv_dlr_push_host_method_call,
+		prv_renderer_device_method_call
+	};
 
 static const gchar *g_server_interfaces[DLR_INTERFACE_INFO_MAX] = {
 	/* MUST be in the exact same order as g_server_introspection */
-	DLR_INTERFACE_PROPERTIES,
-	DLR_INTERFACE_SERVER,
-	DLR_INTERFACE_PLAYER,
-	DLEYNA_INTERFACE_PUSH_HOST,
-	DLEYNA_SERVER_INTERFACE_RENDERER_DEVICE
+	DLR_INTERFACE_PROPERTIES, DLR_INTERFACE_SERVER, DLR_INTERFACE_PLAYER,
+	DLEYNA_INTERFACE_PUSH_HOST, DLEYNA_SERVER_INTERFACE_RENDERER_DEVICE
 };
 
 const gchar *dlr_renderer_get_interface_name(guint index)
@@ -516,10 +495,10 @@ static void prv_process_sync_task(dlr_task_t *task)
 {
 	GError *error;
 
-	switch (task->type) {
+	switch(task->type) {
 	case DLR_TASK_GET_VERSION:
-		task->result = g_variant_ref_sink(g_variant_new_string(
-								VERSION));
+		task->result =
+			g_variant_ref_sink(g_variant_new_string(VERSION));
 		dlr_task_complete(task);
 		break;
 	case DLR_TASK_GET_SERVERS:
@@ -533,8 +512,8 @@ static void prv_process_sync_task(dlr_task_t *task)
 	case DLR_TASK_RAISE:
 	case DLR_TASK_QUIT:
 		error = g_error_new(DLEYNA_SERVER_ERROR,
-				    DLEYNA_ERROR_NOT_SUPPORTED,
-				    "Command not supported.");
+		                    DLEYNA_ERROR_NOT_SUPPORTED,
+		                    "Command not supported.");
 		dlr_task_fail(task, error);
 		g_error_free(error);
 		break;
@@ -553,7 +532,7 @@ static void prv_async_task_complete(dlr_task_t *task, GError *error)
 {
 	DLEYNA_LOG_DEBUG("Enter");
 
-	if (!error) {
+	if(!error) {
 		dlr_task_complete(task);
 	} else {
 		dlr_task_fail(task, error);
@@ -567,92 +546,87 @@ static void prv_async_task_complete(dlr_task_t *task, GError *error)
 
 static void prv_process_async_task(dlr_task_t *task)
 {
-	dlr_async_task_t *async_task = (dlr_async_task_t *)task;
+	dlr_async_task_t *async_task = (dlr_async_task_t *) task;
 
 	DLEYNA_LOG_DEBUG("Enter");
 
 	async_task->cancellable = g_cancellable_new();
 
-	switch (task->type) {
+	switch(task->type) {
 	case DLR_TASK_GET_PROP:
 		dlr_upnp_get_prop(g_context.upnp, task,
-				  prv_async_task_complete);
+		                  prv_async_task_complete);
 		break;
 	case DLR_TASK_GET_ALL_PROPS:
 		dlr_upnp_get_all_props(g_context.upnp, task,
-				       prv_async_task_complete);
+		                       prv_async_task_complete);
 		break;
 	case DLR_TASK_SET_PROP:
 		dlr_upnp_set_prop(g_context.upnp, task,
-				  prv_async_task_complete);
+		                  prv_async_task_complete);
 		break;
 	case DLR_TASK_PLAY:
-		dlr_upnp_play(g_context.upnp, task,
-			      prv_async_task_complete);
+		dlr_upnp_play(g_context.upnp, task, prv_async_task_complete);
 		break;
 	case DLR_TASK_PAUSE:
-		dlr_upnp_pause(g_context.upnp, task,
-			       prv_async_task_complete);
+		dlr_upnp_pause(g_context.upnp, task, prv_async_task_complete);
 		break;
 	case DLR_TASK_PLAY_PAUSE:
 		dlr_upnp_play_pause(g_context.upnp, task,
-				    prv_async_task_complete);
+		                    prv_async_task_complete);
 		break;
 	case DLR_TASK_STOP:
-		dlr_upnp_stop(g_context.upnp, task,
-			      prv_async_task_complete);
+		dlr_upnp_stop(g_context.upnp, task, prv_async_task_complete);
 		break;
 	case DLR_TASK_NEXT:
-		dlr_upnp_next(g_context.upnp, task,
-			      prv_async_task_complete);
+		dlr_upnp_next(g_context.upnp, task, prv_async_task_complete);
 		break;
 	case DLR_TASK_PREVIOUS:
 		dlr_upnp_previous(g_context.upnp, task,
-				  prv_async_task_complete);
+		                  prv_async_task_complete);
 		break;
 	case DLR_TASK_OPEN_URI:
 	case DLR_TASK_OPEN_NEXT_URI:
 	case DLR_TASK_SET_URI:
 		dlr_upnp_open_uri(g_context.upnp, task,
-				  prv_async_task_complete);
+		                  prv_async_task_complete);
 		break;
 	case DLR_TASK_SEEK:
 	case DLR_TASK_BYTE_SEEK:
-		dlr_upnp_seek(g_context.upnp, task,
-			      prv_async_task_complete);
+		dlr_upnp_seek(g_context.upnp, task, prv_async_task_complete);
 		break;
 	case DLR_TASK_SET_POSITION:
 	case DLR_TASK_SET_BYTE_POSITION:
 		dlr_upnp_set_position(g_context.upnp, task,
-				      prv_async_task_complete);
+		                      prv_async_task_complete);
 		break;
 	case DLR_TASK_GOTO_TRACK:
 		dlr_upnp_goto_track(g_context.upnp, task,
-				    prv_async_task_complete);
+		                    prv_async_task_complete);
 		break;
 	case DLR_TASK_HOST_URI:
 		dlr_upnp_host_uri(g_context.upnp, task,
-				  prv_async_task_complete);
+		                  prv_async_task_complete);
 		break;
 	case DLR_TASK_REMOVE_URI:
 		dlr_upnp_remove_uri(g_context.upnp, task,
-				    prv_async_task_complete);
+		                    prv_async_task_complete);
 		break;
 	case DLR_TASK_GET_ICON:
 		dlr_upnp_get_icon(g_context.upnp, task,
-				  prv_async_task_complete);
+		                  prv_async_task_complete);
 		break;
 	case DLR_TASK_MANAGER_GET_PROP:
 		dlr_manager_get_prop(g_context.manager, g_context.settings,
-				     task, prv_async_task_complete);
+		                     task, prv_async_task_complete);
 		break;
 	case DLR_TASK_MANAGER_GET_ALL_PROPS:
 		dlr_manager_get_all_props(g_context.manager, g_context.settings,
-					  task, prv_async_task_complete);
+		                          task, prv_async_task_complete);
 		break;
 	case DLR_TASK_MANAGER_SET_PROP:
 		dlr_manager_set_prop(g_context.manager, g_context.settings,
-				     task, prv_async_task_complete);
+		                     task, prv_async_task_complete);
 		break;
 	default:
 		break;
@@ -663,9 +637,9 @@ static void prv_process_async_task(dlr_task_t *task)
 
 static void prv_process_task(dleyna_task_atom_t *task, gpointer user_data)
 {
-	dlr_task_t *client_task = (dlr_task_t *)task;
+	dlr_task_t *client_task = (dlr_task_t *) task;
 
-	if (client_task->synchronous)
+	if(client_task->synchronous)
 		prv_process_sync_task(client_task);
 	else
 		prv_process_async_task(client_task);
@@ -673,26 +647,26 @@ static void prv_process_task(dleyna_task_atom_t *task, gpointer user_data)
 
 static void prv_cancel_task(dleyna_task_atom_t *task, gpointer user_data)
 {
-	dlr_task_cancel((dlr_task_t *)task);
+	dlr_task_cancel((dlr_task_t *) task);
 }
 
 static void prv_delete_task(dleyna_task_atom_t *task, gpointer user_data)
 {
-	dlr_task_delete((dlr_task_t *)task);
+	dlr_task_delete((dlr_task_t *) task);
 }
 
 static void prv_remove_client(const gchar *name)
 {
 	dleyna_task_processor_remove_queues_for_source(g_context.processor,
-						       name);
+	                                               name);
 
 	dlr_upnp_lost_client(g_context.upnp, name);
 
-	if (g_context.watchers > 0)
+	if(g_context.watchers > 0)
 		g_context.watchers--;
 
-	if (g_context.watchers == 0)
-		if (!dleyna_settings_is_never_quit(g_context.settings))
+	if(g_context.watchers == 0)
+		if(!dleyna_settings_is_never_quit(g_context.settings))
 			dleyna_task_processor_set_quitting(g_context.processor);
 }
 
@@ -703,8 +677,8 @@ static void prv_lost_client(const gchar *name)
 }
 
 static void prv_control_point_initialize(const dleyna_connector_t *connector,
-					 dleyna_task_processor_t *processor,
-					 dleyna_settings_t *settings)
+                                         dleyna_task_processor_t *processor,
+                                         dleyna_settings_t *settings)
 {
 	memset(&g_context, 0, sizeof(g_context));
 
@@ -720,69 +694,61 @@ static void prv_control_point_stop_service(void)
 {
 	uint i;
 
-	if (g_context.upnp) {
+	if(g_context.upnp) {
 		dlr_upnp_unsubscribe(g_context.upnp);
 		dlr_upnp_delete(g_context.upnp);
 		g_context.upnp = NULL;
 	}
 
-	if (g_context.connection) {
-		for (i = 0; i < DLR_MANAGER_INTERFACE_INFO_MAX; i++)
-			if (g_context.dlr_id[i])
+	if(g_context.connection) {
+		for(i = 0; i < DLR_MANAGER_INTERFACE_INFO_MAX; i++)
+			if(g_context.dlr_id[i])
 				g_context.connector->unpublish_object(
-							g_context.connection,
-							g_context.dlr_id[i]);
+					g_context.connection,
+					g_context.dlr_id[i]);
 	}
 }
 
-static void prv_control_point_free(void)
-{
-}
+static void prv_control_point_free(void) {}
 
 static void prv_add_task(dlr_task_t *task, const gchar *source,
-			 const gchar *sink)
+                         const gchar *sink)
 {
 	const dleyna_task_queue_key_t *queue_id;
 
-	if (g_context.connector->watch_client(source))
+	if(g_context.connector->watch_client(source))
 		g_context.watchers++;
 
 	queue_id = dleyna_task_processor_lookup_queue(g_context.processor,
-						      source, sink);
-	if (!queue_id)
+	                                              source, sink);
+	if(!queue_id)
 		queue_id = dleyna_task_processor_add_queue(
-					g_context.processor,
-					source,
-					sink,
-					DLEYNA_TASK_QUEUE_FLAG_AUTO_START,
-					prv_process_task,
-					prv_cancel_task,
-					prv_delete_task);
+			g_context.processor, source, sink,
+			DLEYNA_TASK_QUEUE_FLAG_AUTO_START, prv_process_task,
+			prv_cancel_task, prv_delete_task);
 
 	dleyna_task_queue_add_task(queue_id, &task->atom);
 }
 
 static void prv_manager_root_method_call(
-				dleyna_connector_id_t conn,
-				const gchar *sender, const gchar *object,
-				const gchar *interface,
-				const gchar *method, GVariant *parameters,
-				dleyna_connector_msg_id_t invocation)
+	dleyna_connector_id_t conn, const gchar *sender, const gchar *object,
+	const gchar *interface, const gchar *method, GVariant *parameters,
+	dleyna_connector_msg_id_t invocation)
 {
 	dlr_task_t *task;
 
 	DLEYNA_LOG_INFO("Calling %s method", method);
 
-	if (!strcmp(method, DLR_INTERFACE_RELEASE)) {
+	if(!strcmp(method, DLR_INTERFACE_RELEASE)) {
 		g_context.connector->unwatch_client(sender);
 		prv_remove_client(sender);
 		g_context.connector->return_response(invocation, NULL);
 	} else {
-		if (!strcmp(method, DLR_INTERFACE_GET_VERSION))
+		if(!strcmp(method, DLR_INTERFACE_GET_VERSION))
 			task = dlr_task_get_version_new(invocation);
-		else if (!strcmp(method, DLR_INTERFACE_GET_RENDERERS))
+		else if(!strcmp(method, DLR_INTERFACE_GET_RENDERERS))
 			task = dlr_task_get_servers_new(invocation);
-		else if (!strcmp(method, DLR_INTERFACE_RESCAN))
+		else if(!strcmp(method, DLR_INTERFACE_RESCAN))
 			task = dlr_task_rescan_new(invocation);
 		else
 			goto finished;
@@ -795,30 +761,27 @@ static void prv_manager_root_method_call(
 	return;
 }
 
-static void prv_manager_props_method_call(dleyna_connector_id_t conn,
-					  const gchar *sender,
-					  const gchar *object,
-					  const gchar *interface,
-					  const gchar *method,
-					  GVariant *parameters,
-					  dleyna_connector_msg_id_t invocation)
+static void prv_manager_props_method_call(
+	dleyna_connector_id_t conn, const gchar *sender, const gchar *object,
+	const gchar *interface, const gchar *method, GVariant *parameters,
+	dleyna_connector_msg_id_t invocation)
 {
 	dlr_task_t *task;
 	GError *error = NULL;
 
-	if (!strcmp(method, DLR_INTERFACE_GET_ALL))
+	if(!strcmp(method, DLR_INTERFACE_GET_ALL))
 		task = dlr_task_manager_get_props_new(invocation, object,
-						      parameters, &error);
-	else if (!strcmp(method, DLR_INTERFACE_GET))
+		                                      parameters, &error);
+	else if(!strcmp(method, DLR_INTERFACE_GET))
 		task = dlr_task_manager_get_prop_new(invocation, object,
-						     parameters, &error);
-	else if (!strcmp(method, DLR_INTERFACE_SET))
+		                                     parameters, &error);
+	else if(!strcmp(method, DLR_INTERFACE_SET))
 		task = dlr_task_manager_set_prop_new(invocation, object,
-						     parameters, &error);
+		                                     parameters, &error);
 	else
 		goto finished;
 
-	if (!task) {
+	if(!task) {
 		g_context.connector->return_error(invocation, error);
 		g_error_free(error);
 
@@ -836,16 +799,16 @@ static const gchar *prv_get_device_id(const gchar *object, GError **error)
 {
 	dlr_device_t *device;
 
-	device = dlr_device_from_path(object,
-				dlr_upnp_get_server_udn_map(g_context.upnp));
-
+	device = dlr_device_from_path(
+		object, dlr_upnp_get_server_udn_map(g_context.upnp));
 
-	if (!device) {
+	if(!device) {
 		DLEYNA_LOG_WARNING("Cannot locate device for %s", object);
 
 		*error = g_error_new(DLEYNA_SERVER_ERROR,
-				     DLEYNA_ERROR_OBJECT_NOT_FOUND,
-				     "Cannot locate device corresponding to the specified path");
+		                     DLEYNA_ERROR_OBJECT_NOT_FOUND,
+		                     "Cannot locate device corresponding to "
+		                     "the specified path");
 		goto on_error;
 	}
 
@@ -857,30 +820,28 @@ static const gchar *prv_get_device_id(const gchar *object, GError **error)
 }
 
 static void prv_props_method_call(dleyna_connector_id_t conn,
-				  const gchar *sender,
-				  const gchar *object,
-				  const gchar *interface,
-				  const gchar *method,
-				  GVariant *parameters,
-				  dleyna_connector_msg_id_t invocation)
+                                  const gchar *sender, const gchar *object,
+                                  const gchar *interface, const gchar *method,
+                                  GVariant *parameters,
+                                  dleyna_connector_msg_id_t invocation)
 {
 	dlr_task_t *task;
 	const gchar *device_id;
 	GError *error = NULL;
 
 	device_id = prv_get_device_id(object, &error);
-	if (!device_id) {
+	if(!device_id) {
 		g_context.connector->return_error(invocation, error);
 		g_error_free(error);
 
 		goto finished;
 	}
 
-	if (!strcmp(method, DLR_INTERFACE_GET_ALL))
+	if(!strcmp(method, DLR_INTERFACE_GET_ALL))
 		task = dlr_task_get_props_new(invocation, object, parameters);
-	else if (!strcmp(method, DLR_INTERFACE_GET))
+	else if(!strcmp(method, DLR_INTERFACE_GET))
 		task = dlr_task_get_prop_new(invocation, object, parameters);
-	else if (!strcmp(method, DLR_INTERFACE_SET))
+	else if(!strcmp(method, DLR_INTERFACE_SET))
 		task = dlr_task_set_prop_new(invocation, object, parameters);
 	else
 		goto finished;
@@ -893,28 +854,27 @@ static void prv_props_method_call(dleyna_connector_id_t conn,
 }
 
 static void prv_dlr_device_method_call(dleyna_connector_id_t conn,
-				       const gchar *sender,
-				       const gchar *object,
-				       const gchar *interface,
-				       const gchar *method,
-				       GVariant *parameters,
-				       dleyna_connector_msg_id_t invocation)
+                                       const gchar *sender, const gchar *object,
+                                       const gchar *interface,
+                                       const gchar *method,
+                                       GVariant *parameters,
+                                       dleyna_connector_msg_id_t invocation)
 {
 	dlr_task_t *task;
 	const gchar *device_id;
 	GError *error = NULL;
 
 	device_id = prv_get_device_id(object, &error);
-	if (!device_id) {
+	if(!device_id) {
 		g_context.connector->return_error(invocation, error);
 		g_error_free(error);
 
 		goto finished;
 	}
 
-	if (!strcmp(method, DLR_INTERFACE_RAISE))
+	if(!strcmp(method, DLR_INTERFACE_RAISE))
 		task = dlr_task_raise_new(invocation);
-	else if (!strcmp(method, DLR_INTERFACE_QUIT))
+	else if(!strcmp(method, DLR_INTERFACE_QUIT))
 		task = dlr_task_quit_new(invocation);
 	else
 		goto finished;
@@ -927,57 +887,56 @@ static void prv_dlr_device_method_call(dleyna_connector_id_t conn,
 }
 
 static void prv_dlr_player_method_call(dleyna_connector_id_t conn,
-				       const gchar *sender,
-				       const gchar *object,
-				       const gchar *interface,
-				       const gchar *method,
-				       GVariant *parameters,
-				       dleyna_connector_msg_id_t invocation)
+                                       const gchar *sender, const gchar *object,
+                                       const gchar *interface,
+                                       const gchar *method,
+                                       GVariant *parameters,
+                                       dleyna_connector_msg_id_t invocation)
 {
 	dlr_task_t *task;
 	const gchar *device_id;
 	GError *error = NULL;
 
 	device_id = prv_get_device_id(object, &error);
-	if (!device_id) {
+	if(!device_id) {
 		g_context.connector->return_error(invocation, error);
 		g_error_free(error);
 
 		goto finished;
 	}
 
-	if (!strcmp(method, DLR_INTERFACE_PLAY))
+	if(!strcmp(method, DLR_INTERFACE_PLAY))
 		task = dlr_task_play_new(invocation, object);
-	else if (!strcmp(method, DLR_INTERFACE_PAUSE))
+	else if(!strcmp(method, DLR_INTERFACE_PAUSE))
 		task = dlr_task_pause_new(invocation, object);
-	else if (!strcmp(method, DLR_INTERFACE_PLAY_PAUSE))
+	else if(!strcmp(method, DLR_INTERFACE_PLAY_PAUSE))
 		task = dlr_task_play_pause_new(invocation, object);
-	else if (!strcmp(method, DLR_INTERFACE_STOP))
+	else if(!strcmp(method, DLR_INTERFACE_STOP))
 		task = dlr_task_stop_new(invocation, object);
-	else if (!strcmp(method, DLR_INTERFACE_NEXT))
+	else if(!strcmp(method, DLR_INTERFACE_NEXT))
 		task = dlr_task_next_new(invocation, object);
-	else if (!strcmp(method, DLR_INTERFACE_PREVIOUS))
+	else if(!strcmp(method, DLR_INTERFACE_PREVIOUS))
 		task = dlr_task_previous_new(invocation, object);
-	else if (!strcmp(method, DLR_INTERFACE_OPEN_URI))
+	else if(!strcmp(method, DLR_INTERFACE_OPEN_URI))
 		task = dlr_task_open_uri_new(invocation, object, parameters);
-	else if (!strcmp(method, DLR_INTERFACE_OPEN_URI_EX))
+	else if(!strcmp(method, DLR_INTERFACE_OPEN_URI_EX))
 		task = dlr_task_open_uri_ex_new(invocation, object, parameters);
-	else if (!strcmp(method, DLR_INTERFACE_OPEN_NEXT_URI))
+	else if(!strcmp(method, DLR_INTERFACE_OPEN_NEXT_URI))
 		task = dlr_task_open_next_uri_new(invocation, object,
-						  parameters);
-	else if (!strcmp(method, DLR_INTERFACE_SET_URI))
+		                                  parameters);
+	else if(!strcmp(method, DLR_INTERFACE_SET_URI))
 		task = dlr_task_set_uri_new(invocation, object, parameters);
-	else if (!strcmp(method, DLR_INTERFACE_SEEK))
+	else if(!strcmp(method, DLR_INTERFACE_SEEK))
 		task = dlr_task_seek_new(invocation, object, parameters);
-	else if (!strcmp(method, DLR_INTERFACE_BYTE_SEEK))
+	else if(!strcmp(method, DLR_INTERFACE_BYTE_SEEK))
 		task = dlr_task_byte_seek_new(invocation, object, parameters);
-	else if (!strcmp(method, DLR_INTERFACE_SET_POSITION))
+	else if(!strcmp(method, DLR_INTERFACE_SET_POSITION))
 		task = dlr_task_set_position_new(invocation, object,
-						 parameters);
-	else if (!strcmp(method, DLR_INTERFACE_SET_BYTE_POSITION))
+		                                 parameters);
+	else if(!strcmp(method, DLR_INTERFACE_SET_BYTE_POSITION))
 		task = dlr_task_set_byte_position_new(invocation, object,
-						      parameters);
-	else if (!strcmp(method, DLR_INTERFACE_GOTO_TRACK))
+		                                      parameters);
+	else if(!strcmp(method, DLR_INTERFACE_GOTO_TRACK))
 		task = dlr_task_goto_track_new(invocation, object, parameters);
 	else
 		goto finished;
@@ -989,32 +948,29 @@ static void prv_dlr_player_method_call(dleyna_connector_id_t conn,
 	return;
 }
 
-static void prv_dlr_push_host_method_call(dleyna_connector_id_t conn,
-					  const gchar *sender,
-					  const gchar *object,
-					  const gchar *interface,
-					  const gchar *method,
-					  GVariant *parameters,
-					  dleyna_connector_msg_id_t invocation)
+static void prv_dlr_push_host_method_call(
+	dleyna_connector_id_t conn, const gchar *sender, const gchar *object,
+	const gchar *interface, const gchar *method, GVariant *parameters,
+	dleyna_connector_msg_id_t invocation)
 {
 	dlr_task_t *task;
 	const gchar *device_id;
 	GError *error = NULL;
 
 	device_id = prv_get_device_id(object, &error);
-	if (!device_id) {
+	if(!device_id) {
 		g_context.connector->return_error(invocation, error);
 		g_error_free(error);
 
 		goto on_error;
 	}
 
-	if (!strcmp(method, DLR_INTERFACE_HOST_FILE))
+	if(!strcmp(method, DLR_INTERFACE_HOST_FILE))
 		task = dlr_task_host_uri_new(invocation, object, sender,
-					     parameters);
-	else if (!strcmp(method, DLR_INTERFACE_REMOVE_FILE))
+		                             parameters);
+	else if(!strcmp(method, DLR_INTERFACE_REMOVE_FILE))
 		task = dlr_task_remove_uri_new(invocation, object, sender,
-					       parameters);
+		                               parameters);
 	else
 		goto on_error;
 
@@ -1026,13 +982,9 @@ static void prv_dlr_push_host_method_call(dleyna_connector_id_t conn,
 }
 
 static void prv_renderer_device_method_call(
-					dleyna_connector_id_t conn,
-					const gchar *sender,
-					const gchar *object,
-					const gchar *interface,
-					const gchar *method,
-					GVariant *parameters,
-					dleyna_connector_msg_id_t invocation)
+	dleyna_connector_id_t conn, const gchar *sender, const gchar *object,
+	const gchar *interface, const gchar *method, GVariant *parameters,
+	dleyna_connector_msg_id_t invocation)
 {
 	dlr_task_t *task;
 	const gchar *device_id = NULL;
@@ -1040,22 +992,21 @@ static void prv_renderer_device_method_call(
 	const dleyna_task_queue_key_t *queue_id;
 
 	device_id = prv_get_device_id(object, &error);
-	if (!device_id) {
+	if(!device_id) {
 		g_context.connector->return_error(invocation, error);
 		g_error_free(error);
 
 		goto finished;
 	}
 
-	if (!strcmp(method, DLR_INTERFACE_CANCEL)) {
+	if(!strcmp(method, DLR_INTERFACE_CANCEL)) {
 		queue_id = dleyna_task_processor_lookup_queue(
-							g_context.processor,
-							sender, device_id);
-		if (queue_id)
+			g_context.processor, sender, device_id);
+		if(queue_id)
 			dleyna_task_processor_cancel_queue(queue_id);
 
 		g_context.connector->return_response(invocation, NULL);
-	} else if (!strcmp(method, DLR_INTERFACE_GET_ICON)) {
+	} else if(!strcmp(method, DLR_INTERFACE_GET_ICON)) {
 		task = dlr_task_get_icon_new(invocation, object, parameters);
 
 		prv_add_task(task, sender, device_id);
@@ -1070,24 +1021,20 @@ static void prv_found_media_server(const gchar *path)
 {
 	DLEYNA_LOG_INFO("New media server %s", path);
 
-	(void) g_context.connector->notify(g_context.connection,
-					   DLEYNA_SERVER_OBJECT,
-					   DLEYNA_SERVER_INTERFACE_MANAGER,
-					   DLR_INTERFACE_FOUND_RENDERER,
-					   g_variant_new("(o)", path),
-					   NULL);
+	(void) g_context.connector->notify(
+		g_context.connection, DLEYNA_SERVER_OBJECT,
+		DLEYNA_SERVER_INTERFACE_MANAGER, DLR_INTERFACE_FOUND_RENDERER,
+		g_variant_new("(o)", path), NULL);
 }
 
 static void prv_lost_media_server(const gchar *path)
 {
 	DLEYNA_LOG_INFO("Lost %s", path);
 
-	(void) g_context.connector->notify(g_context.connection,
-					   DLEYNA_SERVER_OBJECT,
-					   DLEYNA_SERVER_INTERFACE_MANAGER,
-					   DLR_INTERFACE_LOST_RENDERER,
-					   g_variant_new("(o)", path),
-					   NULL);
+	(void) g_context.connector->notify(
+		g_context.connection, DLEYNA_SERVER_OBJECT,
+		DLEYNA_SERVER_INTERFACE_MANAGER, DLR_INTERFACE_LOST_RENDERER,
+		g_variant_new("(o)", path), NULL);
 
 	dleyna_task_processor_remove_queues_for_sink(g_context.processor, path);
 }
@@ -1112,32 +1059,28 @@ static void prv_white_list_init(void)
 }
 
 static gboolean prv_control_point_start_service(
-					dleyna_connector_id_t connection)
+	dleyna_connector_id_t connection)
 {
 	gboolean retval = TRUE;
 	uint i;
 
 	g_context.connection = connection;
 
-	for (i = 0; i < DLR_MANAGER_INTERFACE_INFO_MAX; i++)
+	for(i = 0; i < DLR_MANAGER_INTERFACE_INFO_MAX; i++)
 		g_context.dlr_id[i] = g_context.connector->publish_object(
-						connection,
-						DLEYNA_SERVER_OBJECT,
-						TRUE,
-						g_manager_interfaces[i],
-						g_root_vtables + i);
-
-	if (g_context.dlr_id[DLR_MANAGER_INTERFACE_MANAGER]) {
-		g_context.upnp = dlr_upnp_new(connection,
-					     dleyna_settings_port(g_context.settings),
-					     dleyna_settings_push_host_port(g_context.settings),
-					     g_server_vtables,
-					     prv_found_media_server,
-					     prv_lost_media_server);
-
-		g_context.manager = dlr_manager_new(connection,
-					       dlr_upnp_get_context_manager(
-							g_context.upnp));
+			connection, DLEYNA_SERVER_OBJECT, TRUE,
+			g_manager_interfaces[i], g_root_vtables + i);
+
+	if(g_context.dlr_id[DLR_MANAGER_INTERFACE_MANAGER]) {
+		g_context.upnp = dlr_upnp_new(
+			connection, dleyna_settings_port(g_context.settings),
+			dleyna_settings_push_host_port(g_context.settings),
+			g_server_vtables, prv_found_media_server,
+			prv_lost_media_server);
+
+		g_context.manager = dlr_manager_new(
+			connection,
+			dlr_upnp_get_context_manager(g_context.upnp));
 		prv_white_list_init();
 	} else {
 		retval = FALSE;
diff --git a/libdleyna/renderer/task.c b/libdleyna/renderer/task.c
index 420ab2e..2737e3c 100644
--- a/libdleyna/renderer/task.c
+++ b/libdleyna/renderer/task.c
@@ -20,6 +20,8 @@
  *
  */
 
+#include <config.h>
+
 #include <libdleyna/core/error.h>
 #include <libdleyna/core/task-processor.h>
 
diff --git a/libdleyna/renderer/upnp.c b/libdleyna/renderer/upnp.c
index 0e9d483..771209b 100644
--- a/libdleyna/renderer/upnp.c
+++ b/libdleyna/renderer/upnp.c
@@ -20,6 +20,8 @@
  *
  */
 
+#include <config.h>
+
 #include <string.h>
 
 #include <libgssdp/gssdp-resource-browser.h>
@@ -162,7 +164,7 @@ static void prv_server_available_cb(GUPnPControlPoint *cp,
 	udn = gupnp_device_info_get_udn((GUPnPDeviceInfo *)proxy);
 
 	ip_address = gssdp_client_get_host_ip(
-		GSSDP_CLIENT(gupnp_control_point_get_context(cp)));
+		gssdp_resource_browser_get_client(GSSDP_RESOURCE_BROWSER(cp)));
 
 	if (!udn || !ip_address)
 		goto on_error;
@@ -244,7 +246,7 @@ static void prv_server_unavailable_cb(GUPnPControlPoint *cp,
 	udn = gupnp_device_info_get_udn((GUPnPDeviceInfo *)proxy);
 
 	ip_address = gssdp_client_get_host_ip(
-		GSSDP_CLIENT(gupnp_control_point_get_context(cp)));
+		gssdp_resource_browser_get_client(GSSDP_RESOURCE_BROWSER(cp)));
 
 	if (!udn || !ip_address)
 		goto on_error;
diff --git a/server/daemon.c b/server/daemon.c
index d06273b..b8b6e49 100644
--- a/server/daemon.c
+++ b/server/daemon.c
@@ -21,6 +21,8 @@
  *
  */
 
+#include <config.h>
+
 #include <glib.h>
 #include <glib-unix.h>


From 237dad7b89193cd8cf9a327265dc2b3be9c2994d Mon Sep 17 00:00:00 2001
From: Jens Georg <mail@jensge.org>
Date: Sun, 22 May 2022 15:16:27 +0200
Subject: [PATCH] [all] Remove deprecated libsoup calls

---
 libdleyna/renderer/host-service.c | 17 ++++++++++++-----
 1 file changed, 12 insertions(+), 5 deletions(-)

diff --git a/libdleyna/renderer/host-service.c b/libdleyna/renderer/host-service.c
index 2e7e315..9a05288 100644
--- a/libdleyna/renderer/host-service.c
+++ b/libdleyna/renderer/host-service.c
@@ -254,8 +254,7 @@ static void prv_host_server_delete(gpointer host_server)
 {
 	dlr_host_server_t *server = host_server;
 
-	if (server) {
-		soup_server_quit(server->soup_server);
+	if(server) {
 		g_object_unref(server->soup_server);
 		g_hash_table_unref(server->files);
 		g_free(server);
@@ -401,7 +400,14 @@ static dlr_host_server_t *prv_host_server_new(const gchar *device_if,
 					      NULL);
 	soup_server_add_handler(server->soup_server, DLR_HOST_SERVICE_ROOT,
 				prv_soup_server_cb, server, NULL);
-	soup_server_run_async(server->soup_server);
+	soup_server_listen_all(server->soup_server, 0,
+	                       (SoupServerListenOptions) 0, error);
+
+	if(error != NULL) {
+		g_clear_object(&server->soup_server);
+		goto on_error;
+	}
+
 	server->counter = 0;
 
 on_error:
@@ -430,6 +436,7 @@ static gchar *prv_add_new_file(dlr_host_server_t *server, const gchar *client,
 	unsigned int i;
 	dlr_host_file_t *hf;
 	gchar *str;
+	g_autoslist(SoupURI) uris = NULL;
 
 	hf = g_hash_table_lookup(server->files, file);
 
@@ -450,9 +457,9 @@ static gchar *prv_add_new_file(dlr_host_server_t *server, const gchar *client,
 			g_ptr_array_add(hf->clients, g_strdup(client));
 	}
 
+	uris = soup_server_get_uris(server->soup_server);
 	str = g_strdup_printf("http://%s:%d%s", device_if,
-			      soup_server_get_port(server->soup_server),
-			      hf->path);
+	                      soup_uri_get_port(uris->data), hf->path);
 
 	return str;
 

From ea3c6726b6aed369d96409b058ff14efd22ef0b2 Mon Sep 17 00:00:00 2001
From: Jens Georg <mail@jensge.org>
Date: Sun, 22 May 2022 15:20:14 +0200
Subject: [PATCH] [Build] Bump GUPnP version

---
 meson.build | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/meson.build b/meson.build
index 6be479f..e3156ad 100644
--- a/meson.build
+++ b/meson.build
@@ -70,8 +70,8 @@ config_h = declare_dependency(
 
 glib = dependency('glib-2.0', version: '>= 2.28')
 gio = dependency('gio-2.0', version: '>=2.28')
-gssdp = dependency('gssdp-1.2', version: '>= 1.2.0')
-gupnp = dependency('gupnp-1.2', version: '>= 1.2.0')
+gssdp = dependency('gssdp-1.2', version: '>= 1.4.0')
+gupnp = dependency('gupnp-1.2', version: '>= 1.4.0')
 gupnp_av = dependency('gupnp-av-1.0', version: '>= 0.12.9')
 gupnp_dlna = dependency('gupnp-dlna-2.0', version: '>= 0.9.4')
 soup = dependency('libsoup-2.4', version: '>= 2.42.0')
 
From c929141d44557a455100a1ddfebd40b657a62020 Mon Sep 17 00:00:00 2001
From: Jens Georg <mail@jensge.org>
Date: Fri, 27 May 2022 18:02:50 +0200
Subject: [PATCH] [device] call is cancelled, abort early

The task queue will delete the task immediately after cancelling it, but
the GTask will take longer to end up being preocessed, to it would
potentially access deleted data
---
 libdleyna/renderer/device.c | 157 +++++++++++++-----------------------
 1 file changed, 54 insertions(+), 103 deletions(-)

diff --git a/libdleyna/renderer/device.c b/libdleyna/renderer/device.c
index 7c59503..611115c 100644
--- a/libdleyna/renderer/device.c
+++ b/libdleyna/renderer/device.c
@@ -681,12 +681,12 @@ static void prv_get_protocol_info_cb(GObject *target,
                                      GAsyncResult *res,
 				     gpointer user_data)
 {
-	gchar *result = NULL;
+	g_autofree gchar *result = NULL;
 	gboolean end;
 	GError *error = NULL;
 	dleyna_gasync_task_t *task = NULL;
 	prv_new_device_ct_t *priv_t = NULL;
-	GUPnPServiceProxyAction *action;
+	g_autoptr(GUPnPServiceProxyAction) action = NULL;
 
 	DLEYNA_LOG_DEBUG("Enter");
 
@@ -723,15 +723,6 @@ static void prv_get_protocol_info_cb(GObject *target,
 	if (task)
 		dleyna_task_queue_task_completed (((dleyna_task_atom_t *) task)->queue_id);
 
-	if (action) {
-		gupnp_service_proxy_action_unref(action);
-	}
-
-	if (error)
-		g_error_free(error);
-
-	g_free(result);
-
 	DLEYNA_LOG_DEBUG("Exit");
 }
 
@@ -1998,7 +1989,6 @@ static void prv_get_position_info_cb(GObject *source, GAsyncResult *res,
                                      gpointer user_data)
 {
 	gchar *result = NULL;
-	const gchar *message;
 	dlr_async_task_t *cb_data = user_data;
 	g_autoptr(GError) error = NULL;
 	GVariantBuilder *changed_props_vb;
@@ -2008,6 +1998,11 @@ static void prv_get_position_info_cb(GObject *source, GAsyncResult *res,
 		gupnp_service_proxy_call_action_finish(
 			GUPNP_SERVICE_PROXY(source), res, &error);
 
+	if(g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+		// Do nothing. The task wil already be deleted by the queue
+		return;
+	}
+
 	if(error == NULL) {
 		gupnp_service_proxy_action_get_result(action, &error, "RelTime",
 		                                      G_TYPE_STRING, &result,
@@ -2015,20 +2010,9 @@ static void prv_get_position_info_cb(GObject *source, GAsyncResult *res,
 	}
 
 	if(error != NULL) {
-		if(error &&
-		   g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
-			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-			                             DLEYNA_ERROR_CANCELLED,
-			                             "Operation cancelled.");
-		} else {
-			message = (error != NULL) ? error->message
-			                          : "Invalid result";
-			cb_data->error = g_error_new(
-				DLEYNA_SERVER_ERROR,
-				DLEYNA_ERROR_OPERATION_FAILED,
-				"GetPositionInfo operation failed: %s",
-				message);
-		}
+		cb_data->error = g_error_new(
+			DLEYNA_SERVER_ERROR, DLEYNA_ERROR_OPERATION_FAILED,
+			"GetPositionInfo operation failed: %s", error->message);
 
 		goto on_error;
 	}
@@ -2059,8 +2043,7 @@ static void prv_get_position_info_cb(GObject *source, GAsyncResult *res,
 static void prv_get_byte_position_info_cb(GObject *source, GAsyncResult *res,
                                           gpointer user_data)
 {
-	gchar *result = NULL;
-	const gchar *message;
+	g_autofree gchar *result = NULL;
 	dlr_async_task_t *cb_data = user_data;
 	g_autoptr(GError) error = NULL;
 	GVariantBuilder *changed_props_vb;
@@ -2069,7 +2052,11 @@ static void prv_get_byte_position_info_cb(GObject *source, GAsyncResult *res,
 	g_autoptr(GUPnPServiceProxyAction) action =
 		gupnp_service_proxy_call_action_finish(
 			GUPNP_SERVICE_PROXY(source), res, &error);
-	(void) action;
+
+	if(g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+		// Do nothing. The task already was deleted
+		return;
+	}
 
 	if(error == NULL) {
 		gupnp_service_proxy_action_get_result(action, &error, "RelByte",
@@ -2078,21 +2065,11 @@ static void prv_get_byte_position_info_cb(GObject *source, GAsyncResult *res,
 	}
 
 	if(error != NULL) {
-		if(error &&
-		   g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
-			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-			                             DLEYNA_ERROR_CANCELLED,
-			                             "Operation cancelled.");
-		} else {
-			message = (error != NULL) ? error->message
-			                          : "Invalid result";
-			cb_data->error =
-				g_error_new(DLEYNA_SERVER_ERROR,
-			                    DLEYNA_ERROR_OPERATION_FAILED,
-			                    "X_DLNA_GetBytePositionInfo "
-			                    "operation failed: %s",
-			                    message);
-		}
+		cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
+		                             DLEYNA_ERROR_OPERATION_FAILED,
+		                             "X_DLNA_GetBytePositionInfo "
+		                             "operation failed: %s",
+		                             error->message);
 
 		goto on_error;
 	}
@@ -2110,8 +2087,6 @@ static void prv_get_byte_position_info_cb(GObject *source, GAsyncResult *res,
 	g_variant_unref(changed_props);
 	g_variant_builder_unref(changed_props_vb);
 
-	g_free(result);
-
 	prv_get_prop(cb_data);
 
 on_error:
@@ -2133,6 +2108,10 @@ static void prv_get_all_position_info_cb(GObject *source, GAsyncResult *res,
 	action = gupnp_service_proxy_call_action_finish(
 		GUPNP_SERVICE_PROXY(source), res, &error);
 
+	if(g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+		return;
+	}
+
 	if(error == NULL) {
 		gupnp_service_proxy_action_get_result(action, &error, "RelTime",
 		                                      G_TYPE_STRING, &result,
@@ -2142,12 +2121,6 @@ static void prv_get_all_position_info_cb(GObject *source, GAsyncResult *res,
 	if(error != NULL) {
 		DLEYNA_LOG_WARNING("GetPositionInfo operation failed: %s",
 		                   error->message);
-		if(g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
-			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-			                             DLEYNA_ERROR_CANCELLED,
-			                             "Operation cancelled.");
-			goto on_error;
-		}
 	}
 
 	if (result == NULL) {
@@ -2210,6 +2183,10 @@ static void prv_get_all_byte_position_info_cb(GObject *source,
 	action = gupnp_service_proxy_call_action_finish(
 		GUPNP_SERVICE_PROXY(source), res, &error);
 
+	if(g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+		return;
+	}
+
 	if(error == NULL) {
 		gupnp_service_proxy_action_get_result(action, &error, "RelByte",
 		                                      G_TYPE_STRING, &result,
@@ -2220,14 +2197,6 @@ static void prv_get_all_byte_position_info_cb(GObject *source,
 		DLEYNA_LOG_WARNING(
 			"X_DLNA_GetBytePositionInfo operation failed: %s",
 			error->message);
-		if(g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
-			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-			                             DLEYNA_ERROR_CANCELLED,
-			                             "Operation cancelled.");
-			(void) g_idle_add(dlr_async_task_complete, cb_data);
-
-			return;
-		}
 	}
 
 	if (result == NULL) {
@@ -2246,8 +2215,6 @@ static void prv_get_all_byte_position_info_cb(GObject *source,
 	gupnp_service_proxy_call_action_async(
 		GUPNP_SERVICE_PROXY(source), cb_data->action,
 		cb_data->cancellable, prv_get_all_position_info_cb, cb_data);
-
-	return;
 }
 
 static void prv_get_position_info(dlr_async_task_t *cb_data,
@@ -2545,6 +2512,10 @@ static void prv_simple_call_cb(GObject *source, GAsyncResult *res,
 	action = gupnp_service_proxy_call_action_finish(
 		GUPNP_SERVICE_PROXY(source), res, &upnp_error);
 
+	if(g_error_matches(upnp_error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+		return;
+	}
+
 	// TODO: Work-around to catch SOAP errors
 	if(upnp_error == NULL) {
 		gupnp_service_proxy_action_get_result(action, &upnp_error,
@@ -2552,17 +2523,9 @@ static void prv_simple_call_cb(GObject *source, GAsyncResult *res,
 	}
 
 	if(upnp_error != NULL) {
-		if(g_error_matches(upnp_error, G_IO_ERROR,
-		                   G_IO_ERROR_CANCELLED)) {
-			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-			                             DLEYNA_ERROR_CANCELLED,
-			                             "Operation cancelled.");
-		} else {
-			cb_data->error = g_error_new(
-				DLEYNA_SERVER_ERROR,
-				DLEYNA_ERROR_OPERATION_FAILED,
-				"Operation failed: %s", upnp_error->message);
-		}
+		cb_data->error = g_error_new(
+			DLEYNA_SERVER_ERROR, DLEYNA_ERROR_OPERATION_FAILED,
+			"Operation failed: %s", upnp_error->message);
 	}
 
 	(void) g_idle_add(dlr_async_task_complete, cb_data);
@@ -3049,24 +3012,19 @@ static void prv_open_uri_cb(GObject *source, GAsyncResult *res,
 		gupnp_service_proxy_call_action_finish(
 			GUPNP_SERVICE_PROXY(source), res, &upnp_error);
 
+	if(g_error_matches(upnp_error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+		return;
+	}
+
 	if(upnp_error == NULL) {
 		gupnp_service_proxy_action_get_result(action, &upnp_error,
 		                                      NULL);
 	}
 
 	if(upnp_error != NULL) {
-		if(g_error_matches(upnp_error, G_IO_ERROR,
-		                   G_IO_ERROR_CANCELLED)) {
-			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-			                             DLEYNA_ERROR_CANCELLED,
-			                             "Operation cancelled.");
-
-		} else {
-			cb_data->error = g_error_new(
-				DLEYNA_SERVER_ERROR,
-				DLEYNA_ERROR_OPERATION_FAILED,
-				"Operation failed: %s", upnp_error->message);
-		}
+		cb_data->error = g_error_new(
+			DLEYNA_SERVER_ERROR, DLEYNA_ERROR_OPERATION_FAILED,
+			"Operation failed: %s", upnp_error->message);
 
 		goto on_error;
 	}
@@ -3220,6 +3178,10 @@ static void prv_complete_seek_get_position(GObject *source, GAsyncResult *res,
 		gupnp_service_proxy_call_action_finish(
 			GUPNP_SERVICE_PROXY(source), res, &error);
 
+	if(g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+		return;
+	}
+
 	if(error == NULL) {
 		gupnp_service_proxy_action_get_result(
 			action, &error,
@@ -3228,24 +3190,13 @@ static void prv_complete_seek_get_position(GObject *source, GAsyncResult *res,
 	}
 
 	if(error != NULL) {
-		if(error &&
-		   g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
-			cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
-			                             DLEYNA_ERROR_CANCELLED,
-			                             "Operation cancelled.");
-		} else {
-
-			message = (error != NULL) ? error->message
-			                          : "Invalid result";
-			cb_data->error = g_error_new(
-				DLEYNA_SERVER_ERROR,
-				DLEYNA_ERROR_OPERATION_FAILED,
-				"%s operation failed: %s",
-				(task->type == DLR_TASK_SEEK)
-					? "GetPositionInfo"
-					: "X_DLNA_GetBytePositionInfo",
-				message);
-		}
+		cb_data->error = g_error_new(
+			DLEYNA_SERVER_ERROR, DLEYNA_ERROR_OPERATION_FAILED,
+			"%s operation failed: %s",
+			(task->type == DLR_TASK_SEEK)
+				? "GetPositionInfo"
+				: "X_DLNA_GetBytePositionInfo",
+			error->message);
 
 		goto on_error;
 	}

From b0f183d3fbc16d2980a8808236b049ceb545b829 Mon Sep 17 00:00:00 2001
From: Jens Georg <mail@jensge.org>
Date: Thu, 2 Jun 2022 22:38:18 +0200
Subject: [PATCH] white-list -> context-filter

---
 libdleyna/renderer/device.c  |  1 -
 libdleyna/renderer/manager.c | 90 +++++++++++++++++-------------------
 libdleyna/renderer/manager.h |  3 +-
 libdleyna/renderer/server.c  | 18 ++++----
 meson.build                  |  2 +-
 5 files changed, 54 insertions(+), 60 deletions(-)

diff --git a/libdleyna/renderer/device.c b/libdleyna/renderer/device.c
index 611115c..684d1f8 100644
--- a/libdleyna/renderer/device.c
+++ b/libdleyna/renderer/device.c
@@ -3167,7 +3167,6 @@ static void prv_complete_seek_get_position(GObject *source, GAsyncResult *res,
                                            gpointer user_data)
 {
 	g_autofree gchar *result = NULL;
-	const gchar *message;
 	g_autoptr(GError) error = NULL;
 	dlr_async_task_t *cb_data = user_data;
 	dlr_task_t *task = &cb_data->task;
diff --git a/libdleyna/renderer/manager.c b/libdleyna/renderer/manager.c
index 1aa981c..e0e825e 100644
--- a/libdleyna/renderer/manager.c
+++ b/libdleyna/renderer/manager.c
@@ -25,9 +25,9 @@
 #include <glib.h>
 #include <string.h>
 
+#include <libdleyna/core/context-filter.h>
 #include <libdleyna/core/error.h>
 #include <libdleyna/core/log.h>
-#include <libdleyna/core/white-list.h>
 
 #include "async.h"
 #include "manager.h"
@@ -37,14 +37,14 @@
 struct dlr_manager_t_ {
 	dleyna_connector_id_t connection;
 	GUPnPContextManager *cm;
-	dleyna_white_list_t *wl;
+	dleyna_context_filter_t *cf;
 };
 
-static GVariant *prv_build_wl_entries(dleyna_settings_t *settings)
+static GVariant *prv_build_cf_entries(dleyna_settings_t *settings)
 {
 	GVariant *result;
 
-	result = dleyna_settings_white_list_entries(settings);
+	result = dleyna_settings_context_filter_entries(settings);
 
 	if (result == NULL)
 		result = g_variant_new("as", NULL);
@@ -59,13 +59,13 @@ static void prv_add_all_props(dleyna_settings_t *settings, GVariantBuilder *vb)
 					dleyna_settings_is_never_quit(
 								settings)));
 
-	g_variant_builder_add(vb, "{sv}", DLR_INTERFACE_PROP_WHITE_LIST_ENABLED,
-			      g_variant_new_boolean(
-					dleyna_settings_is_white_list_enabled(
-								settings)));
+	g_variant_builder_add(
+		vb, "{sv}", DLR_INTERFACE_PROP_WHITE_LIST_ENABLED,
+		g_variant_new_boolean(
+			dleyna_settings_is_context_filter_enabled(settings)));
 
 	g_variant_builder_add(vb, "{sv}", DLR_INTERFACE_PROP_WHITE_LIST_ENTRIES,
-			      prv_build_wl_entries(settings));
+	                      prv_build_cf_entries(settings));
 }
 
 static GVariant *prv_get_prop(dleyna_settings_t *settings, const gchar *prop)
@@ -81,10 +81,9 @@ static GVariant *prv_get_prop(dleyna_settings_t *settings, const gchar *prop)
 								settings)));
 	else if (!strcmp(prop, DLR_INTERFACE_PROP_WHITE_LIST_ENABLED))
 		retval = g_variant_ref_sink(g_variant_new_boolean(
-					dleyna_settings_is_white_list_enabled(
-								settings)));
+			dleyna_settings_is_context_filter_enabled(settings)));
 	else if (!strcmp(prop, DLR_INTERFACE_PROP_WHITE_LIST_ENTRIES))
-		retval = g_variant_ref_sink(prv_build_wl_entries(settings));
+		retval = g_variant_ref_sink(prv_build_cf_entries(settings));
 
 #if DLEYNA_LOG_LEVEL & DLEYNA_LOG_LEVEL_DEBUG
 	if (retval) {
@@ -97,9 +96,8 @@ static GVariant *prv_get_prop(dleyna_settings_t *settings, const gchar *prop)
 	return retval;
 }
 
-static void prv_wl_notify_prop(dlr_manager_t *manager,
-			       const gchar *prop_name,
-			       GVariant *prop_val)
+static void prv_cf_notify_prop(dlr_manager_t *manager, const gchar *prop_name,
+                               GVariant *prop_val)
 {
 	GVariant *val;
 	GVariantBuilder array;
@@ -124,13 +122,13 @@ dlr_manager_t *dlr_manager_new(dleyna_connector_id_t connection,
 			       GUPnPContextManager *connection_manager)
 {
 	dlr_manager_t *manager = g_new0(dlr_manager_t, 1);
-	GUPnPWhiteList *gupnp_wl;
+	GUPnPContextFilter *gupnp_cf;
 
-	gupnp_wl = gupnp_context_manager_get_white_list(connection_manager);
+	gupnp_cf = gupnp_context_manager_get_context_filter(connection_manager);
 
 	manager->connection = connection;
 	manager->cm = connection_manager;
-	manager->wl = dleyna_white_list_new(gupnp_wl);
+	manager->cf = dleyna_context_filter_new(gupnp_cf);
 
 	return manager;
 }
@@ -138,14 +136,14 @@ dlr_manager_t *dlr_manager_new(dleyna_connector_id_t connection,
 void dlr_manager_delete(dlr_manager_t *manager)
 {
 	if (manager != NULL) {
-		dleyna_white_list_delete(manager->wl);
+		dleyna_context_filter_delete(manager->cf);
 		g_free(manager);
 	}
 }
 
-dleyna_white_list_t *dlr_manager_get_white_list(dlr_manager_t *manager)
+dleyna_context_filter_t *dlr_manager_get_context_filter(dlr_manager_t *manager)
 {
-	return manager->wl;
+	return manager->cf;
 }
 
 void dlr_manager_get_all_props(dlr_manager_t *manager,
@@ -245,9 +243,8 @@ static void prv_set_prop_never_quit(dlr_manager_t *manager,
 
 	if (*error == NULL) {
 		prop_val = g_variant_new_boolean(never_quit);
-		prv_wl_notify_prop(manager,
-				   DLR_INTERFACE_PROP_NEVER_QUIT,
-				   prop_val);
+		prv_cf_notify_prop(manager, DLR_INTERFACE_PROP_NEVER_QUIT,
+		                   prop_val);
 	}
 
 exit:
@@ -255,31 +252,30 @@ static void prv_set_prop_never_quit(dlr_manager_t *manager,
 	return;
 }
 
-static void prv_set_prop_wl_enabled(dlr_manager_t *manager,
-				    dleyna_settings_t *settings,
-				    gboolean enabled,
-				    GError **error)
+static void prv_set_prop_cf_enabled(dlr_manager_t *manager,
+                                    dleyna_settings_t *settings,
+                                    gboolean enabled, GError **error)
 {
 	GVariant *prop_val;
 	gboolean old_val;
 
 	DLEYNA_LOG_DEBUG("Enter %d", enabled);
 
-	old_val = dleyna_settings_is_white_list_enabled(settings);
+	old_val = dleyna_settings_is_context_filter_enabled(settings);
 
 	if (old_val == enabled)
 		goto exit;
 
 	/* If no error, the white list will be updated in the reload callack
 	 */
-	dleyna_settings_set_white_list_enabled(settings, enabled, error);
+	dleyna_settings_set_context_filter_enabled(settings, enabled, error);
 
 	if (*error == NULL) {
-		dleyna_white_list_enable(manager->wl, enabled);
+		dleyna_context_filter_enable(manager->cf, enabled);
 		prop_val = g_variant_new_boolean(enabled);
-		prv_wl_notify_prop(manager,
-				   DLR_INTERFACE_PROP_WHITE_LIST_ENABLED,
-				   prop_val);
+		prv_cf_notify_prop(manager,
+		                   DLR_INTERFACE_PROP_WHITE_LIST_ENABLED,
+		                   prop_val);
 	}
 
 exit:
@@ -287,10 +283,9 @@ static void prv_set_prop_wl_enabled(dlr_manager_t *manager,
 	return;
 }
 
-static void prv_set_prop_wl_entries(dlr_manager_t *manager,
-				    dleyna_settings_t *settings,
-				    GVariant *entries,
-				    GError **error)
+static void prv_set_prop_cf_entries(dlr_manager_t *manager,
+                                    dleyna_settings_t *settings,
+                                    GVariant *entries, GError **error)
 {
 	DLEYNA_LOG_DEBUG("Enter");
 
@@ -306,15 +301,15 @@ static void prv_set_prop_wl_entries(dlr_manager_t *manager,
 	/* If no error, the white list will be updated in the reload callack
 	 * callack
 	 */
-	dleyna_settings_set_white_list_entries(settings, entries, error);
+	dleyna_settings_set_context_filter_entries(settings, entries, error);
 
 	if (*error == NULL) {
-		dleyna_white_list_clear(manager->wl);
-		dleyna_white_list_add_entries(manager->wl, entries);
+		dleyna_context_filter_clear(manager->cf);
+		dleyna_context_filter_add_entries(manager->cf, entries);
 
-		prv_wl_notify_prop(manager,
-				   DLR_INTERFACE_PROP_WHITE_LIST_ENTRIES,
-				   entries);
+		prv_cf_notify_prop(manager,
+		                   DLR_INTERFACE_PROP_WHITE_LIST_ENTRIES,
+		                   entries);
 	}
 exit:
 	DLEYNA_LOG_DEBUG("Exit");
@@ -354,11 +349,10 @@ void dlr_manager_set_prop(dlr_manager_t *manager,
 					g_variant_get_boolean(param),
 					&error);
 	else if (!strcmp(name, DLR_INTERFACE_PROP_WHITE_LIST_ENABLED))
-		prv_set_prop_wl_enabled(manager, settings,
-					g_variant_get_boolean(param),
-					&error);
+		prv_set_prop_cf_enabled(manager, settings,
+		                        g_variant_get_boolean(param), &error);
 	else if (!strcmp(name, DLR_INTERFACE_PROP_WHITE_LIST_ENTRIES))
-		prv_set_prop_wl_entries(manager, settings, param, &error);
+		prv_set_prop_cf_entries(manager, settings, param, &error);
 	else
 		cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
 					     DLEYNA_ERROR_UNKNOWN_PROPERTY,
diff --git a/libdleyna/renderer/manager.h b/libdleyna/renderer/manager.h
index fdf1419..1b6587c 100644
--- a/libdleyna/renderer/manager.h
+++ b/libdleyna/renderer/manager.h
@@ -24,6 +24,7 @@
 #define DLR_MANAGER_H__
 
 #include <libdleyna/core/connector.h>
+#include <libdleyna/core/context-filter.h>
 #include <libdleyna/core/settings.h>
 #include <libgupnp/gupnp-context-manager.h>
 
@@ -37,7 +38,7 @@ dlr_manager_t *dlr_manager_new(dleyna_connector_id_t connection,
 
 void dlr_manager_delete(dlr_manager_t *manager);
 
-dleyna_white_list_t *dlr_manager_get_white_list(dlr_manager_t *manager);
+dleyna_context_filter_t *dlr_manager_get_context_filter(dlr_manager_t *manager);
 
 void dlr_manager_get_all_props(dlr_manager_t *manager,
 			       dleyna_settings_t *settings,
diff --git a/libdleyna/renderer/server.c b/libdleyna/renderer/server.c
index 23d3061..e56e44b 100644
--- a/libdleyna/renderer/server.c
+++ b/libdleyna/renderer/server.c
@@ -31,11 +31,11 @@
 #include <syslog.h>
 
 #include <libdleyna/core/connector.h>
+#include <libdleyna/core/context-filter.h>
 #include <libdleyna/core/control-point.h>
 #include <libdleyna/core/error.h>
 #include <libdleyna/core/log.h>
 #include <libdleyna/core/task-processor.h>
-#include <libdleyna/core/white-list.h>
 
 #include "async.h"
 #include "control-point-renderer.h"
@@ -1039,21 +1039,21 @@ static void prv_lost_media_server(const gchar *path)
 	dleyna_task_processor_remove_queues_for_sink(g_context.processor, path);
 }
 
-static void prv_white_list_init(void)
+static void prv_context_filter_init(void)
 {
 	gboolean enabled;
 	GVariant *entries;
-	dleyna_white_list_t *wl;
+	dleyna_context_filter_t *cf;
 
 	DLEYNA_LOG_DEBUG("Enter");
 
-	enabled = dleyna_settings_is_white_list_enabled(g_context.settings);
-	entries = dleyna_settings_white_list_entries(g_context.settings);
+	enabled = dleyna_settings_is_context_filter_enabled(g_context.settings);
+	entries = dleyna_settings_context_filter_entries(g_context.settings);
 
-	wl = dlr_manager_get_white_list(g_context.manager);
+	cf = dlr_manager_get_context_filter(g_context.manager);
 
-	dleyna_white_list_enable(wl, enabled);
-	dleyna_white_list_add_entries(wl, entries);
+	dleyna_context_filter_enable(cf, enabled);
+	dleyna_context_filter_add_entries(cf, entries);
 
 	DLEYNA_LOG_DEBUG("Exit");
 }
@@ -1081,7 +1081,7 @@ static gboolean prv_control_point_start_service(
 		g_context.manager = dlr_manager_new(
 			connection,
 			dlr_upnp_get_context_manager(g_context.upnp));
-		prv_white_list_init();
+		prv_context_filter_init();
 	} else {
 		retval = FALSE;
 	}
diff --git a/meson.build b/meson.build
index e3156ad..0a3539f 100644
--- a/meson.build
+++ b/meson.build
@@ -75,7 +75,7 @@ gupnp = dependency('gupnp-1.2', version: '>= 1.4.0')
 gupnp_av = dependency('gupnp-av-1.0', version: '>= 0.12.9')
 gupnp_dlna = dependency('gupnp-dlna-2.0', version: '>= 0.9.4')
 soup = dependency('libsoup-2.4', version: '>= 2.42.0')
-dleyna_core = dependency('dleyna-core-1.0', version: '>= 0.6.0', fallback: 'dleyna-core-1.0')
+dleyna_core = dependency('dleyna-core-1.0', version: '>= 0.8.0', fallback: 'dleyna-core-1.0')
 
 cc = meson.get_compiler('c')
 math = cc.find_library('m', required: false)

From b3a06c8bc4b91803d7bde312f49a68109b8ad8d4 Mon Sep 17 00:00:00 2001
From: Jens Georg <mail@jensge.org>
Date: Thu, 2 Jun 2022 23:20:47 +0200
Subject: [PATCH] Port to GUPnP 1.6

---
 libdleyna/renderer/device.c       | 117 +++++++++++-------------------
 libdleyna/renderer/device.h       |   3 +-
 libdleyna/renderer/host-service.c |  85 +++++++++++-----------
 meson.build                       |   6 +-
 4 files changed, 88 insertions(+), 123 deletions(-)

diff --git a/libdleyna/renderer/device.c b/libdleyna/renderer/device.c
index 684d1f8..1fc0a8a 100644
--- a/libdleyna/renderer/device.c
+++ b/libdleyna/renderer/device.c
@@ -73,6 +73,7 @@ typedef struct prv_download_info_t_ prv_download_info_t;
 struct prv_download_info_t_ {
 	SoupSession *session;
 	SoupMessage *msg;
+	GCancellable *cancellable;
 	dlr_async_task_t *task;
 };
 
@@ -419,7 +420,7 @@ void dlr_device_delete(void *device)
 		g_free(dev->rate);
 
 		g_free(dev->icon.mime_type);
-		g_free(dev->icon.bytes);
+		g_bytes_unref(dev->icon.bytes);
 
 		g_free(dev);
 	}
@@ -726,46 +727,6 @@ static void prv_get_protocol_info_cb(GObject *target,
 	DLEYNA_LOG_DEBUG("Exit");
 }
 
-static void prv_introspection_wrap_cb (GUPnPServiceInfo *info,
-				  GUPnPServiceIntrospection *introspection,
-				  const GError *error,
-				  gpointer user_data)
-{
-	if (error != NULL) {
-		g_task_return_error (G_TASK (user_data),
-				g_error_copy (error));
-	} else {
-		g_task_return_pointer (G_TASK (user_data),
-				introspection,
-				g_object_unref);
-	}
-
-	g_object_unref (G_OBJECT (user_data));
-}
-
-void prv_introspect_async (GUPnPServiceInfo    *info,
-			   GCancellable        *cancellable,
-			   GAsyncReadyCallback  callback,
-			   gpointer             user_data)
-{
-	GTask *task = g_task_new (info, cancellable, callback, user_data);
-
-	gupnp_service_info_get_introspection_async_full (info,
-			prv_introspection_wrap_cb,
-			cancellable,
-			task);
-}
-
-static GUPnPServiceIntrospection *prv_introspect_finish
-		(GUPnPServiceInfo   *info,
-		 GAsyncResult       *res,
-		 GError            **error)
-{
-	g_return_val_if_fail (g_task_is_valid (res, info), NULL);
-
-	return g_task_propagate_pointer (G_TASK (res), error);
-}
-
 static gint compare_speeds(gconstpointer a, gconstpointer b);
 
 static void prv_introspect_av_cb (GObject *target,
@@ -783,7 +744,8 @@ static void prv_introspect_av_cb (GObject *target,
 
 	DLEYNA_LOG_DEBUG("Enter");
 
-	introspection = prv_introspect_finish (GUPNP_SERVICE_INFO (target), res, &error);
+	introspection = gupnp_service_info_introspect_finish(
+		GUPNP_SERVICE_INFO(target), res, &error);
 
 	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
 		DLEYNA_LOG_WARNING("GetProtocolInfo operation cancelled");
@@ -847,7 +809,8 @@ static void prv_introspect_rc_cb (GObject *target,
 
 	DLEYNA_LOG_DEBUG("Enter");
 
-	introspection = prv_introspect_finish (GUPNP_SERVICE_INFO (target), res, &error);
+	introspection = gupnp_service_info_introspect_finish(
+		GUPNP_SERVICE_INFO(target), res, &error);
 
 	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
 		DLEYNA_LOG_WARNING("GetProtocolInfo operation cancelled");
@@ -898,20 +861,20 @@ static gboolean prv_get_protocol_info(dleyna_gasync_task_t *task,
 
 static gboolean prv_introspect_av(dleyna_gasync_task_t *task, GObject *target)
 {
-	prv_introspect_async (GUPNP_SERVICE_INFO (target),
-			      dleyna_gasync_task_get_cancellable (task),
-			      prv_introspect_av_cb,
-			      task);
+	gupnp_service_info_introspect_async(
+		GUPNP_SERVICE_INFO(target),
+		dleyna_gasync_task_get_cancellable(task), prv_introspect_av_cb,
+		task);
 
 	return FALSE;
 }
 
 static gboolean prv_introspect_rc(dleyna_gasync_task_t *task, GObject *target)
 {
-	prv_introspect_async (GUPNP_SERVICE_INFO (target),
-			      dleyna_gasync_task_get_cancellable (task),
-			      prv_introspect_rc_cb,
-			      task);
+	gupnp_service_info_introspect_async(
+		GUPNP_SERVICE_INFO(target),
+		dleyna_gasync_task_get_cancellable(task), prv_introspect_rc_cb,
+		task);
 
 	return FALSE;
 }
@@ -3306,10 +3269,10 @@ static void prv_build_icon_result(dlr_device_t *device, dlr_task_t *task)
 {
 	GVariant *out_p[2];
 
-	out_p[0] = g_variant_new_fixed_array(G_VARIANT_TYPE_BYTE,
-					     device->icon.bytes,
-					     device->icon.size,
-					     1);
+	gsize size;
+	gconstpointer data = g_bytes_get_data(device->icon.bytes, &size);
+	out_p[0] =
+		g_variant_new_fixed_array(G_VARIANT_TYPE_BYTE, data, size, 1);
 	out_p[1] = g_variant_new_string(device->icon.mime_type);
 	task->result = g_variant_ref_sink(g_variant_new_tuple(out_p, 2));
 }
@@ -3322,41 +3285,45 @@ static void prv_get_icon_cancelled(GCancellable *cancellable,
 	dlr_async_task_cancelled(cancellable, download->task);
 
 	if (download->msg) {
-		soup_session_cancel_message(download->session, download->msg,
-					    SOUP_STATUS_CANCELLED);
+		g_cancellable_cancel(download->cancellable);
 		DLEYNA_LOG_DEBUG("Cancelling device icon download");
 	}
 }
 
 static void prv_free_download_info(prv_download_info_t *download)
 {
-	if (download->msg)
-		g_object_unref(download->msg);
-	g_object_unref(download->session);
+	g_clear_object(&download->msg);
+	g_clear_object(&download->session);
+	g_clear_object(&download->cancellable);
 	g_free(download);
 }
 
-static void prv_get_icon_session_cb(SoupSession *session,
-				    SoupMessage *msg,
-				    gpointer user_data)
+static void prv_get_icon_session_cb(GObject *source, GAsyncResult *res,
+                                    gpointer user_data)
 {
 	prv_download_info_t *download = (prv_download_info_t *)user_data;
 	dlr_async_task_t *cb_data = (dlr_async_task_t *)download->task;
 	dlr_device_t *device = (dlr_device_t *)cb_data->device;
+	g_autoptr(GError) error = NULL;
+	GBytes *data;
 
-	if (msg->status_code == SOUP_STATUS_CANCELLED)
+	data = soup_session_send_and_read_finish(SOUP_SESSION(source), res,
+	                                         &error);
+
+	if(g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
 		goto out;
 
-	if (SOUP_STATUS_IS_SUCCESSFUL(msg->status_code)) {
-		device->icon.size = msg->response_body->length;
-		device->icon.bytes = g_malloc(device->icon.size);
-		memcpy(device->icon.bytes, msg->response_body->data,
-		       device->icon.size);
+	SoupStatus status = soup_message_get_status(download->msg);
+
+	if(SOUP_STATUS_IS_SUCCESSFUL(status)) {
+		device->icon.bytes = data;
 
 		prv_build_icon_result(device, &cb_data->task);
 	} else {
 		DLEYNA_LOG_DEBUG("Failed to GET device icon: %s",
-				 msg->reason_phrase);
+		                 error != NULL ? error->message
+		                               : soup_message_get_reason_phrase(
+							 download->msg));
 
 		cb_data->error = g_error_new(DLEYNA_SERVER_ERROR,
 					     DLEYNA_ERROR_OPERATION_FAILED,
@@ -3364,6 +3331,7 @@ static void prv_get_icon_session_cb(SoupSession *session,
 	}
 
 	(void) g_idle_add(dlr_async_task_complete, cb_data);
+	g_cancellable_disconnect(cb_data->cancellable, cb_data->cancel_id);
 
 out:
 
@@ -3382,7 +3350,7 @@ void dlr_device_get_icon(dlr_device_t *device, dlr_task_t *task,
 	cb_data->cb = cb;
 	cb_data->device = device;
 
-	if (device->icon.size != 0) {
+	if(device->icon.bytes != NULL) {
 		prv_build_icon_result(device, task);
 		goto end;
 	}
@@ -3404,6 +3372,7 @@ void dlr_device_get_icon(dlr_device_t *device, dlr_task_t *task,
 	download->session = soup_session_new();
 	download->msg = soup_message_new(SOUP_METHOD_GET, url);
 	download->task = cb_data;
+	download->cancellable = g_cancellable_new();
 
 	if (!download->msg) {
 		DLEYNA_LOG_WARNING("Invalid URL %s", url);
@@ -3422,9 +3391,9 @@ void dlr_device_get_icon(dlr_device_t *device, dlr_task_t *task,
 				      G_CALLBACK(prv_get_icon_cancelled),
 				      download, NULL);
 
-	g_object_ref(download->msg);
-	soup_session_queue_message(download->session, download->msg,
-				   prv_get_icon_session_cb, download);
+	soup_session_send_and_read_async(
+		download->session, download->msg, G_PRIORITY_DEFAULT,
+		download->cancellable, prv_get_icon_session_cb, download);
 
 	g_free(url);
 
diff --git a/libdleyna/renderer/device.h b/libdleyna/renderer/device.h
index f3dfa43..497946d 100644
--- a/libdleyna/renderer/device.h
+++ b/libdleyna/renderer/device.h
@@ -67,8 +67,7 @@ struct dlr_props_t_ {
 typedef struct dlr_device_icon_t_ dlr_device_icon_t;
 struct dlr_device_icon_t_ {
 	gchar *mime_type;
-	guchar *bytes;
-	gsize size;
+	GBytes *bytes;
 };
 
 struct dlr_device_t_ {
diff --git a/libdleyna/renderer/host-service.c b/libdleyna/renderer/host-service.c
index 9a05288..42ccbfc 100644
--- a/libdleyna/renderer/host-service.c
+++ b/libdleyna/renderer/host-service.c
@@ -296,41 +296,49 @@ static void prv_soup_message_finished_cb(SoupMessage *msg, gpointer user_data)
 	}
 }
 
-static void prv_soup_server_cb(SoupServer *server, SoupMessage *msg,
-			       const char *path, GHashTable *query,
-			       SoupClientContext *client, gpointer user_data)
+static void prv_soup_server_cb(SoupServer *server, SoupServerMessage *msg,
+                               const char *path, GHashTable *query,
+                               gpointer user_data)
 {
 	dlr_host_file_t *hf;
 	dlr_host_server_t *hs = user_data;
 	const gchar *file_name;
 	const char *hdr;
+	const char *method = soup_server_message_get_method(msg);
 
-	if ((msg->method != SOUP_METHOD_GET) &&
-	    (msg->method != SOUP_METHOD_HEAD)) {
-		soup_message_set_status(msg, SOUP_STATUS_NOT_IMPLEMENTED);
+	if((method != SOUP_METHOD_GET) && (method != SOUP_METHOD_HEAD)) {
+		soup_server_message_set_status(msg, SOUP_STATUS_NOT_IMPLEMENTED,
+		                               NULL);
 		goto on_error;
 	}
 
 	hf = prv_host_server_find_file(hs, path, &file_name);
 
 	if (!hf) {
-		soup_message_set_status(msg, SOUP_STATUS_NOT_FOUND);
+		soup_server_message_set_status(msg, SOUP_STATUS_NOT_FOUND,
+		                               NULL);
 		goto on_error;
 	}
 
-	hdr = soup_message_headers_get_one(msg->request_headers,
-					   "getContentFeatures.dlna.org");
+	SoupMessageHeaders *request_headers =
+		soup_server_message_get_request_headers(msg);
+	SoupMessageHeaders *response_headers =
+		soup_server_message_get_response_headers(msg);
+	hdr = soup_message_headers_get_one(request_headers,
+	                                   "getContentFeatures.dlna.org");
 
 	if (hdr) {
 		if (strcmp(hdr, "1") != 0) {
-			soup_message_set_status(msg, SOUP_STATUS_BAD_REQUEST);
+			soup_server_message_set_status(
+				msg, SOUP_STATUS_BAD_REQUEST, NULL);
 			goto on_error;
 		}
 
 		if ((hf->dlna_header) && strlen(hf->dlna_header) > 0)
-			soup_message_headers_append(msg->response_headers,
-						    "contentFeatures.dlna.org",
-						    hf->dlna_header);
+
+			soup_message_headers_append(response_headers,
+			                            "contentFeatures.dlna.org",
+			                            hf->dlna_header);
 	}
 
 	if (hf->mapped_file) {
@@ -342,33 +350,32 @@ static void prv_soup_server_cb(SoupServer *server, SoupMessage *msg,
 						    NULL);
 
 		if (!hf->mapped_file) {
-			soup_message_set_status(msg,
-						SOUP_STATUS_NOT_FOUND);
+			soup_server_message_set_status(
+				msg, SOUP_STATUS_NOT_FOUND, NULL);
 			goto on_error;
 		}
 
 		hf->mapped_count = 1;
 	}
 
-	if (msg->method == SOUP_METHOD_GET) {
+	if(method == SOUP_METHOD_GET) {
 		g_signal_connect(msg, "finished",
 				 G_CALLBACK(prv_soup_message_finished_cb), hf);
 
-		soup_message_set_response(
-				msg, hf->mime_type,
-				SOUP_MEMORY_STATIC,
-				g_mapped_file_get_contents(hf->mapped_file),
-				g_mapped_file_get_length(hf->mapped_file));
+		soup_server_message_set_response(
+			msg, hf->mime_type, SOUP_MEMORY_STATIC,
+			g_mapped_file_get_contents(hf->mapped_file),
+			g_mapped_file_get_length(hf->mapped_file));
 	} else {
-		soup_message_headers_set_content_type(msg->response_headers,
-						      hf->mime_type, NULL);
+		soup_message_headers_set_content_type(response_headers,
+		                                      hf->mime_type, NULL);
 
 		soup_message_headers_set_content_length(
-			msg->response_headers,
+			response_headers,
 			g_mapped_file_get_length(hf->mapped_file));
 	}
 
-	soup_message_set_status(msg, SOUP_STATUS_OK);
+	soup_server_message_set_status(msg, SOUP_STATUS_OK, NULL);
 
 on_error:
 
@@ -380,30 +387,20 @@ static dlr_host_server_t *prv_host_server_new(const gchar *device_if,
 					      GError **error)
 {
 	dlr_host_server_t *server = NULL;
-	SoupAddress *addr;
-
-	addr = soup_address_new(device_if, port);
-
-	if (soup_address_resolve_sync(addr, NULL) != SOUP_STATUS_OK) {
-		*error = g_error_new(DLEYNA_SERVER_ERROR,
-				     DLEYNA_ERROR_HOST_FAILED,
-				     "Unable to create host server on %s",
-				     device_if);
-		goto on_error;
-	}
 
 	server = g_new(dlr_host_server_t, 1);
 	server->files = g_hash_table_new_full(g_str_hash, g_str_equal,
 					      g_free, prv_host_file_delete);
 
-	server->soup_server = soup_server_new(SOUP_SERVER_INTERFACE, addr,
-					      NULL);
+	server->soup_server = soup_server_new(NULL, NULL);
+	GSocketAddress *addr =
+		g_inet_socket_address_new_from_string(device_if, port);
+	soup_server_listen(server->soup_server, addr,
+	                   (SoupServerListenOptions) 0, error);
 	soup_server_add_handler(server->soup_server, DLR_HOST_SERVICE_ROOT,
-				prv_soup_server_cb, server, NULL);
-	soup_server_listen_all(server->soup_server, 0,
-	                       (SoupServerListenOptions) 0, error);
+	                        prv_soup_server_cb, server, NULL);
 
-	if(error != NULL) {
+	if(error != NULL && *error != NULL) {
 		g_clear_object(&server->soup_server);
 		goto on_error;
 	}
@@ -436,7 +433,7 @@ static gchar *prv_add_new_file(dlr_host_server_t *server, const gchar *client,
 	unsigned int i;
 	dlr_host_file_t *hf;
 	gchar *str;
-	g_autoslist(SoupURI) uris = NULL;
+	g_autoslist(GUri) uris = NULL;
 
 	hf = g_hash_table_lookup(server->files, file);
 
@@ -459,7 +456,7 @@ static gchar *prv_add_new_file(dlr_host_server_t *server, const gchar *client,
 
 	uris = soup_server_get_uris(server->soup_server);
 	str = g_strdup_printf("http://%s:%d%s", device_if,
-	                      soup_uri_get_port(uris->data), hf->path);
+	                      g_uri_get_port(uris->data), hf->path);
 
 	return str;
 
diff --git a/meson.build b/meson.build
index 0a3539f..5b2e6f9 100644
--- a/meson.build
+++ b/meson.build
@@ -70,11 +70,11 @@ config_h = declare_dependency(
 
 glib = dependency('glib-2.0', version: '>= 2.28')
 gio = dependency('gio-2.0', version: '>=2.28')
-gssdp = dependency('gssdp-1.2', version: '>= 1.4.0')
-gupnp = dependency('gupnp-1.2', version: '>= 1.4.0')
+gssdp = dependency('gssdp-1.6', version: '>= 1.4.0')
+gupnp = dependency('gupnp-1.6', version: '>= 1.4.0')
 gupnp_av = dependency('gupnp-av-1.0', version: '>= 0.12.9')
 gupnp_dlna = dependency('gupnp-dlna-2.0', version: '>= 0.9.4')
-soup = dependency('libsoup-2.4', version: '>= 2.42.0')
+soup = dependency('libsoup-3.0', version: '>= 3.0')
 dleyna_core = dependency('dleyna-core-1.0', version: '>= 0.8.0', fallback: 'dleyna-core-1.0')
 
 cc = meson.get_compiler('c')
