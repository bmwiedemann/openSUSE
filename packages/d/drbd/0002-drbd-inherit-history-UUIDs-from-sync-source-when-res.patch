From f6613104a37c1d43cb50fd619afccba370db47a0 Mon Sep 17 00:00:00 2001
From: Joel Colledge <joel.colledge@linbit.com>
Date: Tue, 20 Aug 2024 12:28:09 +0100
Subject: [PATCH 02/32] drbd: inherit history UUIDs from sync source when
 resync finishes

This prevents unexpected "unrelated data" or "split-brain" situations
from occurring later. For example with nodes A, B and C:
* A diskless, B, C with disk, all connected, on UUID X
* Down B
* Write on C, new UUID Y generated
* Add disk on A, resyncs from C
* Down C
* Up B, connects to A, should resync from A

Without this change, "unrelated data" or "split-brain" occurs between A
and B.
Node A has current UUID Y, but knows nothing about X.
Node B has current UUID X, but knows nothing about Y.

This scenario is also possible with "quorum majority".

Fix this by adding the history and bitmap UUIDs from the sync source
into the history on the sync target when a resync finishes. In the above
scenario, this adds the UUID X into the history on A and so has the
effect that a full sync from A to B occurs in the final step.
---
 drbd/drbd_main.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/drbd/drbd_main.c b/drbd/drbd_main.c
index 7968be7c4c3f..862438885f35 100644
--- a/drbd/drbd_main.c
+++ b/drbd/drbd_main.c
@@ -5030,11 +5030,22 @@ u64 drbd_uuid_resync_finished(struct drbd_peer_device *peer_device) __must_hold(
 {
 	struct drbd_device *device = peer_device->device;
 	unsigned long flags;
+	int i;
 	u64 ss_nz_bm; /* sync_source has non zero bitmap for. expressed as nodemask */
 	u64 pwcu; /* peers with current uuid */
 	u64 newer;
 
 	spin_lock_irqsave(&device->ldev->md.uuid_lock, flags);
+	// Inherit history from the sync source
+	for (i = 0; i < ARRAY_SIZE(peer_device->history_uuids); i++)
+		_drbd_uuid_push_history(device, peer_device->history_uuids[i] & ~UUID_PRIMARY);
+
+	// Inherit history in bitmap UUIDs from the sync source
+	for (i = 0; i < DRBD_PEERS_MAX; i++)
+		if (peer_device->bitmap_uuids[i] != -1)
+			_drbd_uuid_push_history(device,
+					peer_device->bitmap_uuids[i] & ~UUID_PRIMARY);
+
 	ss_nz_bm = __test_bitmap_slots_of_peer(peer_device);
 	pwcu = peers_with_current_uuid(device, peer_device->current_uuid);
 
-- 
2.35.3

