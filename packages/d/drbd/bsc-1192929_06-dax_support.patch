/* {"version":"v5.15-rc1~45", "commit": "1b7646014e0d838b06be7288e2dec3262948cc56", "comment": "dax: mark dax_get_by_host static"} */

diff -Naru drbd-9.0.30~1+git.8e9c0812.orig/drbd/Kbuild drbd-9.0.30~1+git.8e9c0812/drbd/Kbuild
--- drbd-9.0.30~1+git.8e9c0812.orig/drbd/Kbuild	2021-11-22 10:12:32.660034839 +0800
+++ drbd-9.0.30~1+git.8e9c0812/drbd/Kbuild	2021-11-22 10:15:26.327117285 +0800
@@ -53,6 +53,11 @@
 endif
 endif
 
+ifeq ($(shell grep -e '\<dax_get_by_host\>' \
+		   $(objtree)/Module.symvers | wc -l),1)
+override EXTRA_CFLAGS += -DDAX_GET_BY_HOST_EXPORTED
+endif
+
 drbd-$(CONFIG_DEBUG_FS) += drbd_debugfs.o
 drbd-y += drbd_buildtag.o drbd_bitmap.o drbd_proc.o
 drbd-y += drbd_sender.o drbd_receiver.o drbd_req.o drbd_actlog.o
diff -Naru drbd-9.0.30~1+git.8e9c0812.orig/drbd/drbd_dax_pmem.c drbd-9.0.30~1+git.8e9c0812/drbd/drbd_dax_pmem.c
--- drbd-9.0.30~1+git.8e9c0812.orig/drbd/drbd_dax_pmem.c	2021-11-22 10:12:32.668034796 +0800
+++ drbd-9.0.30~1+git.8e9c0812/drbd/drbd_dax_pmem.c	2021-11-22 10:32:04.933864379 +0800
@@ -29,6 +29,53 @@
 #include "drbd_dax_pmem.h"
 #include "drbd_meta_data.h"
 
+#ifndef DAX_GET_BY_HOST_EXPORTED
+/* From drivers/dax/super.c */
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/radix-tree.h>
+
+#define DAX_HASH_SIZE (PAGE_SIZE / sizeof(struct hlist_head))
+static DEFINE_SPINLOCK(dax_host_lock);
+static struct hlist_head dax_host_list[DAX_HASH_SIZE];
+
+static int dax_host_hash(const char *host)
+{
+       return hashlen_hash(hashlen_string("DAX", host)) % DAX_HASH_SIZE;
+}
+
+/**
+ * dax_get_by_host() - temporary lookup mechanism for filesystem-dax
+ * @host: alternate name for the device registered by a dax driver
+ */
+struct dax_device *dax_get_by_host(const char *host)
+{
+       struct dax_device *dax_dev, *found = NULL;
+       int hash, id;
+
+       if (!host)
+               return NULL;
+
+       hash = dax_host_hash(host);
+
+       id = dax_read_lock();
+       spin_lock(&dax_host_lock);
+       hlist_for_each_entry(dax_dev, &dax_host_list[hash], list) {
+               if (!dax_alive(dax_dev)
+                               || strcmp(host, dax_dev->host) != 0)
+                       continue;
+
+               if (igrab(&dax_dev->inode))
+                       found = dax_dev;
+               break;
+       }
+       spin_unlock(&dax_host_lock);
+       dax_read_unlock(id);
+
+       return found;
+}
+#endif
+
 static int map_superblock_for_dax(struct drbd_backing_dev *bdev, struct dax_device *dax_dev)
 {
 	long want = 1;
diff -Naru drbd-9.0.30~1+git.8e9c0812.orig/drbd/drbd_dax_pmem.h drbd-9.0.30~1+git.8e9c0812/drbd/drbd_dax_pmem.h
--- drbd-9.0.30~1+git.8e9c0812.orig/drbd/drbd_dax_pmem.h	2021-11-22 10:12:32.668034796 +0800
+++ drbd-9.0.30~1+git.8e9c0812/drbd/drbd_dax_pmem.h	2021-11-22 10:32:22.449772726 +0800
@@ -36,4 +36,29 @@
 
 #endif /* IS_ENABLED(CONFIG_DEV_DAX_PMEM) */
 
+#ifndef DAX_GET_BY_HOST_EXPORTED
+#include <linux/cdev.h>
+/**
+ * struct dax_device - anchor object for dax services
+ * @inode: core vfs
+ * @cdev: optional character interface for "device dax"
+ * @host: optional name for lookups where the device path is not available
+ * @private: dax driver private data
+ * @flags: state and boolean properties
+ */
+struct dax_device {
+       struct hlist_node list;
+       struct inode inode;
+       struct cdev cdev;
+       const char *host;
+       void *private;
+       unsigned long flags;
+       const struct dax_operations *ops;
+};
+
+#define DAX_HASH_SIZE (PAGE_SIZE / sizeof(struct hlist_head))
+
+extern struct dax_device *dax_get_by_host(const char *);
+#endif
+
 #endif /* DRBD_DAX_H */
