diff -Nupr a/drbd/drbd-kernel-compat/tests/have_bdev_open_by_path.c b/drbd/drbd-kernel-compat/tests/have_bdev_open_by_path.c
--- a/drbd/drbd-kernel-compat/tests/have_bdev_open_by_path.c	2024-06-19 15:02:47.050694378 +0800
+++ b/drbd/drbd-kernel-compat/tests/have_bdev_open_by_path.c	2024-06-19 15:11:39.313298178 +0800
@@ -2,7 +2,7 @@
 
 #include <linux/blkdev.h>
 
-struct bdev_handle *foo(const char *path, blk_mode_t mode, void *holder,
-		const struct blk_holder_ops *hops) {
-	return bdev_open_by_path(path, mode, holder, hops);
+void foo(void)
+{
+	return;
 }
diff -Nupr a/drbd/drbd-kernel-compat/tests/have_blk_alloc_disk.c b/drbd/drbd-kernel-compat/tests/have_blk_alloc_disk.c
--- a/drbd/drbd-kernel-compat/tests/have_blk_alloc_disk.c	2024-06-19 11:35:39.957400039 +0800
+++ b/drbd/drbd-kernel-compat/tests/have_blk_alloc_disk.c	2024-06-19 11:36:43.594396686 +0800
@@ -2,7 +2,17 @@
 
 #include <linux/blkdev.h>
 
+#define DRBD_MAX_BIO_SIZE_SAFE (1U << 12)       /* Works always = 4k */
+
 struct gendisk *foo(int node)
 {
-	return blk_alloc_disk(node);
+        struct queue_limits lim = {                                                                          
+		/*
+		 * Setting the max_hw_sectors to an odd value of 8kibyte here.
+		 * This triggers a max_bio_size message upon first attach or
+		 * connect.
+		 */
+		.max_hw_sectors         = DRBD_MAX_BIO_SIZE_SAFE >> 8,
+	};
+	return blk_alloc_disk(&lim, node);
 }
diff -Nupr a/drbd/drbd_int.h b/drbd/drbd_int.h
--- a/drbd/drbd_int.h	2024-06-19 15:33:16.756027168 +0800
+++ b/drbd/drbd_int.h	2024-06-19 15:32:58.459276389 +0800
@@ -700,9 +700,9 @@ struct drbd_md {
 
 struct drbd_backing_dev {
 	struct block_device *backing_bdev;
-	struct bdev_handle *backing_bdev_handle;
+	struct file *backing_bdev_file;
 	struct block_device *md_bdev;
-	struct bdev_handle *md_bdev_handle;
+	struct file *md_bdev_file;
 	struct drbd_md md;
 	struct disk_conf __rcu *disk_conf; /* RCU, for updates: resource->conf_update */
 	sector_t known_size; /* last known size of that backing device */
diff -Nupr a/drbd/drbd_main.c b/drbd/drbd_main.c
--- a/drbd/drbd_main.c	2024-06-19 11:41:59.409367593 +0800
+++ b/drbd/drbd_main.c	2024-06-19 11:41:40.052600574 +0800
@@ -3752,6 +3752,7 @@ static int init_submitter(struct drbd_de
 	return 0;
 }
 
+#define DRBD_MAX_BIO_SIZE_SAFE (1U << 12)       /* Works always = 4k */
 enum drbd_ret_code drbd_create_device(struct drbd_config_context *adm_ctx, unsigned int minor,
 				      struct device_conf *device_conf, struct drbd_device **p_device)
 {
@@ -3767,6 +3768,15 @@ enum drbd_ret_code drbd_create_device(st
 	enum drbd_ret_code err = ERR_NOMEM;
 	bool locked = false;
 
+	struct queue_limits lim = {                                                                          
+		/*
+		 * Setting the max_hw_sectors to an odd value of 8kibyte here.
+		 * This triggers a max_bio_size message upon first attach or
+		 * connect.
+		 */
+		.max_hw_sectors         = DRBD_MAX_BIO_SIZE_SAFE >> 8,
+	};
+
 	lockdep_assert_held(&resource->conf_update);
 
 	device = minor_to_device(minor);
@@ -3824,7 +3834,7 @@ enum drbd_ret_code drbd_create_device(st
 
 	init_rwsem(&device->uuid_sem);
 
-	disk = blk_alloc_disk(NUMA_NO_NODE);
+	disk = blk_alloc_disk(&lim, NUMA_NO_NODE);
 	if (!disk)
 		goto out_no_disk;
 
diff -Nupr a/drbd/drbd_nl.c b/drbd/drbd_nl.c
--- a/drbd/drbd_nl.c	2024-06-19 15:16:28.118044330 +0800
+++ b/drbd/drbd_nl.c	2024-06-19 15:32:49.535902019 +0800
@@ -2536,13 +2536,13 @@ bool want_bitmap(struct drbd_peer_device
 }
 
 static void close_backing_dev(struct drbd_device *device,
-		struct bdev_handle *handle, bool do_bd_unlink)
+		struct file *bdev_file, bool do_bd_unlink)
 {
-	if (!handle)
+	if (!bdev_file)
 		return;
 	if (do_bd_unlink)
-		bd_unlink_disk_holder(handle->bdev, device->vdisk);
-	bdev_release(handle);
+		bd_unlink_disk_holder(file_bdev(bdev_file), device->vdisk);
+	fput(bdev_file);
 }
 
 void drbd_backing_dev_free(struct drbd_device *device, struct drbd_backing_dev *ldev)
@@ -2553,33 +2553,34 @@ void drbd_backing_dev_free(struct drbd_d
 	drbd_dax_close(ldev);
 
 	close_backing_dev(device,
-			  ldev->md_bdev_handle,
+			  ldev->md_bdev_file,
 			  ldev->md_bdev != ldev->backing_bdev);
-	close_backing_dev(device, ldev->backing_bdev_handle, true);
+	close_backing_dev(device, ldev->backing_bdev_file, true);
 
 	kfree(ldev->disk_conf);
 	kfree(ldev);
 }
 
-static struct bdev_handle *open_backing_dev(struct drbd_device *device,
+static struct file *open_backing_dev(struct drbd_device *device,
 		const char *bdev_path, void *claim_ptr)
 {
-	struct bdev_handle *handle = bdev_open_by_path(bdev_path,
-				  BLK_OPEN_READ | BLK_OPEN_WRITE,
-				  claim_ptr, NULL);
-	if (IS_ERR(handle)) {
+	struct file *file;
+
+	file = bdev_file_open_by_path(bdev_path, BLK_OPEN_READ | BLK_OPEN_WRITE,
+				      claim_ptr, NULL); 
+	if (IS_ERR(file)) {
 		drbd_err(device, "open(\"%s\") failed with %ld\n",
-				bdev_path, PTR_ERR(handle));
+				bdev_path, PTR_ERR(file));
 	}
-	return handle;
+	return file;
 }
 
 static int link_backing_dev(struct drbd_device *device,
-		const char *bdev_path, struct bdev_handle *handle)
+		const char *bdev_path, struct file *file)
 {
-	int err = bd_link_disk_holder(handle->bdev, device->vdisk);
+	int err = bd_link_disk_holder(file_bdev(file), device->vdisk);
 	if (err) {
-		bdev_release(handle);
+		fput(file);
 		drbd_err(device, "bd_link_disk_holder(\"%s\", ...) failed with %d\n",
 				bdev_path, err);
 	}
@@ -2590,22 +2591,22 @@ static int open_backing_devices(struct d
 		struct disk_conf *new_disk_conf,
 		struct drbd_backing_dev *nbc)
 {
-	struct bdev_handle *handle;
+	struct file *file;
 	void *meta_claim_ptr;
 	int err;
 
-	handle = open_backing_dev(device, new_disk_conf->backing_dev, device);
-	if (IS_ERR(handle))
+	file = open_backing_dev(device, new_disk_conf->backing_dev, device);
+	if (IS_ERR(file))
 		return ERR_OPEN_DISK;
 
-	err = link_backing_dev(device, new_disk_conf->backing_dev, handle);
+	err = link_backing_dev(device, new_disk_conf->backing_dev, file);
 	if (err) {
 		/* close without unlinking; otherwise error path will try to unlink */
-		close_backing_dev(device, handle, false);
+		close_backing_dev(device, file, false);
 		return ERR_OPEN_DISK;
 	}
-	nbc->backing_bdev = handle->bdev;
-	nbc->backing_bdev_handle = handle;
+	nbc->backing_bdev = file_bdev(file);
+	nbc->backing_bdev_file = file;
 
 	/* meta_claim_ptr: device, if claimed exclusively; shared drbd_m_holder,
 	 * if potentially shared with other drbd minors
@@ -2620,23 +2621,23 @@ static int open_backing_devices(struct d
 	 * should check it for you already; but if you don't, or
 	 * someone fooled it, we need to double check here)
 	 */
-	handle = open_backing_dev(device, new_disk_conf->meta_dev, meta_claim_ptr);
-	if (IS_ERR(handle))
+	file = open_backing_dev(device, new_disk_conf->meta_dev, meta_claim_ptr);
+	if (IS_ERR(file))
 		return ERR_OPEN_MD_DISK;
 
 	/* avoid double bd_claim_by_disk() for the same (source,target) tuple,
 	 * as would happen with internal metadata. */
-	if (handle != nbc->backing_bdev_handle) {
-		err = link_backing_dev(device, new_disk_conf->meta_dev, handle);
+	if (file != nbc->backing_bdev_file) {
+		err = link_backing_dev(device, new_disk_conf->meta_dev, file);
 		if (err) {
 			/* close without unlinking; otherwise error path will try to unlink */
-			close_backing_dev(device, handle, false);
+			close_backing_dev(device, file, false);
 			return ERR_OPEN_MD_DISK;
 		}
 	}
 
-	nbc->md_bdev = handle->bdev;
-	nbc->md_bdev_handle = handle;
+	nbc->md_bdev = file_bdev(file);
+	nbc->md_bdev_file = file;
 	return NO_ERROR;
 }
 
