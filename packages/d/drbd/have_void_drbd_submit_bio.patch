/* {"version":"v5.16-rc1~75", "commit": "3e08773c3841e9db7a520908cc2b136a77d275ff", "comment": "block: switch polling to be bio based"} */

diff -Naur drbd-9.0.30~1+git.8e9c0812.orig/drbd/drbd-kernel-compat/tests/have_void_drbd_submit_bio.c drbd-9.0.30~1+git.8e9c0812/drbd/drbd-kernel-compat/tests/have_void_drbd_submit_bio.c
--- drbd-9.0.30~1+git.8e9c0812.orig/drbd/drbd-kernel-compat/tests/have_void_drbd_submit_bio.c	1970-01-01 08:00:00.000000000 +0800
+++ drbd-9.0.30~1+git.8e9c0812/drbd/drbd-kernel-compat/tests/have_void_drbd_submit_bio.c	2021-11-19 16:52:39.349253992 +0800
@@ -0,0 +1,8 @@
+/* { "version": "v5.16-rc1", "commit": "3e08773c3841e9db7a520908cc2b136a77d275ff", "comment": "block: switch polling to be bio based", "author": "Christoph Hellwig <hch@lst.de>", "date": "Tue Oct 12 13:12:24 2021 +0200" } */
+
+#include <linux/bio.h>
+
+void foo(struct bio *b)
+{
+	b->bi_cookie = 0;
+}
diff -Naur drbd-9.0.30~1+git.8e9c0812.orig/drbd/drbd_int.h drbd-9.0.30~1+git.8e9c0812/drbd/drbd_int.h
--- drbd-9.0.30~1+git.8e9c0812.orig/drbd/drbd_int.h	2021-11-19 16:43:47.011257061 +0800
+++ drbd-9.0.30~1+git.8e9c0812/drbd/drbd_int.h	2021-11-19 16:57:32.204153502 +0800
@@ -1848,7 +1848,11 @@
 #define __drbd_make_request(d,b,k,j) __drbd_make_request(d,b,j)
 #endif
 extern void __drbd_make_request(struct drbd_device *, struct bio *, ktime_t, unsigned long);
+#ifdef COMPAT_HAVE_VOID_DRBD_SUBMIT_BIO
+extern void drbd_submit_bio(struct bio *bio);
+#else
 extern blk_qc_t drbd_submit_bio(struct bio *bio);
+#endif
 
 /* drbd_nl.c */
 enum suspend_scope {
diff -Naur drbd-9.0.30~1+git.8e9c0812.orig/drbd/drbd_req.c drbd-9.0.30~1+git.8e9c0812/drbd/drbd_req.c
--- drbd-9.0.30~1+git.8e9c0812.orig/drbd/drbd_req.c	2021-11-19 16:43:47.011257061 +0800
+++ drbd-9.0.30~1+git.8e9c0812/drbd/drbd_req.c	2021-11-19 16:54:34.460820836 +0800
@@ -2186,7 +2186,11 @@
 	return false;
 }
 
+#ifdef COMPAT_HAVE_VOID_DRBD_SUBMIT_BIO
+void drbd_submit_bio(struct bio *bio)
+#else
 blk_qc_t drbd_submit_bio(struct bio *bio)
+#endif
 {
 	struct drbd_device *device = bio->bi_bdev->bd_disk->private_data;
 #ifdef CONFIG_DRBD_TIMING_STATS
@@ -2197,7 +2201,9 @@
 	if (drbd_fail_request_early(device, bio)) {
 		bio->bi_status = BLK_STS_IOERR;
 		bio_endio(bio);
+#ifndef COMPAT_HAVE_VOID_DRBD_SUBMIT_BIO
 		return BLK_QC_T_NONE;
+#endif
 	}
 
 	blk_queue_split(&bio);
@@ -2205,7 +2211,9 @@
 	if (device->cached_err_io) {
 		bio->bi_status = BLK_STS_IOERR;
 		bio_endio(bio);
+#ifndef COMPAT_HAVE_VOID_DRBD_SUBMIT_BIO
 		return BLK_QC_T_NONE;
+#endif
 	}
 
 	/* This is both an optimization: READ of size 0, nothing to do
@@ -2217,7 +2225,9 @@
 	if (bio_op(bio) == REQ_OP_READ && bio->bi_iter.bi_size == 0) {
 		WARN_ONCE(1, "size zero read from upper layers");
 		bio_endio(bio);
+#ifndef COMPAT_HAVE_VOID_DRBD_SUBMIT_BIO
 		return BLK_QC_T_NONE;
+#endif
 	}
 
 	ktime_get_accounting(start_kt);
@@ -2225,7 +2235,9 @@
 
 	__drbd_make_request(device, bio, start_kt, start_jif);
 
+#ifndef COMPAT_HAVE_VOID_DRBD_SUBMIT_BIO
 	return BLK_QC_T_NONE;
+#endif
 }
 
 static unsigned long time_min_in_future(unsigned long now,
