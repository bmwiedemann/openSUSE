From cfa95bfaefdc2c4e91806fdeb810901015a42a36 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Christoph=20B=C3=B6hmwalder?=
 <christoph.boehmwalder@linbit.com>
Date: Thu, 27 Jun 2024 11:19:33 +0200
Subject: [PATCH] drbd: port block device access to file

Equivalent to upstream kernel commit 20e6a8d0dcdc
("drbd: port block device access to file").


---
by heming.zhao@suse.com

change this patch (ignore commit cdd3b8aa03f1a)
from:
```
 	/* avoid double bd_claim_by_disk() for the same (source,target) tuple,
 	 * as would happen with internal metadata. */
-	if (handle->bdev != nbc->backing_bdev) {
-		err = link_backing_dev(device, new_disk_conf->meta_dev, handle);
```
to:
```
 	/* avoid double bd_claim_by_disk() for the same (source,target) tuple,
 	 * as would happen with internal metadata. */
-	if (handle != nbc->backing_bdev_handle) {
-		err = link_backing_dev(device, new_disk_conf->meta_dev, handle);
```

---
 drbd/drbd_int.h |  4 ++--
 drbd/drbd_nl.c  | 56 ++++++++++++++++++++++++-------------------------
 2 files changed, 30 insertions(+), 30 deletions(-)

diff --git a/drbd/drbd_int.h b/drbd/drbd_int.h
index ae7b45b2f8df..0ebd79091af6 100644
--- a/drbd/drbd_int.h
+++ b/drbd/drbd_int.h
@@ -704,9 +704,9 @@ struct drbd_md {
 
 struct drbd_backing_dev {
 	struct block_device *backing_bdev;
-	struct bdev_handle *backing_bdev_handle;
+	struct file *backing_bdev_file;
 	struct block_device *md_bdev;
-	struct bdev_handle *md_bdev_handle;
+	struct file *f_md_bdev;
 	struct drbd_md md;
 	struct disk_conf __rcu *disk_conf; /* RCU, for updates: resource->conf_update */
 	sector_t known_size; /* last known size of that backing device */
diff --git a/drbd/drbd_nl.c b/drbd/drbd_nl.c
index 298db40b22ea..b732fa6f9d60 100644
--- a/drbd/drbd_nl.c
+++ b/drbd/drbd_nl.c
@@ -2710,13 +2710,13 @@ bool want_bitmap(struct drbd_peer_device *peer_device)
 }
 
 static void close_backing_dev(struct drbd_device *device,
-		struct bdev_handle *handle, bool do_bd_unlink)
+		struct file *bdev_file, bool do_bd_unlink)
 {
-	if (!handle)
+	if (!bdev_file)
 		return;
 	if (do_bd_unlink)
-		bd_unlink_disk_holder(handle->bdev, device->vdisk);
-	bdev_release(handle);
+		bd_unlink_disk_holder(file_bdev(bdev_file), device->vdisk);
+	fput(bdev_file);
 }
 
 void drbd_backing_dev_free(struct drbd_device *device, struct drbd_backing_dev *ldev)
@@ -2727,33 +2727,33 @@ void drbd_backing_dev_free(struct drbd_device *device, struct drbd_backing_dev *
 	drbd_dax_close(ldev);
 
 	close_backing_dev(device,
-			  ldev->md_bdev_handle,
+			  ldev->f_md_bdev,
 			  ldev->md_bdev != ldev->backing_bdev);
-	close_backing_dev(device, ldev->backing_bdev_handle, true);
+	close_backing_dev(device, ldev->backing_bdev_file, true);
 
 	kfree(ldev->disk_conf);
 	kfree(ldev);
 }
 
-static struct bdev_handle *open_backing_dev(struct drbd_device *device,
+static struct file *open_backing_dev(struct drbd_device *device,
 		const char *bdev_path, void *claim_ptr)
 {
-	struct bdev_handle *handle = bdev_open_by_path(bdev_path,
+	struct file *file = bdev_file_open_by_path(bdev_path,
 				  BLK_OPEN_READ | BLK_OPEN_WRITE,
 				  claim_ptr, NULL);
-	if (IS_ERR(handle)) {
+	if (IS_ERR(file)) {
 		drbd_err(device, "open(\"%s\") failed with %ld\n",
-				bdev_path, PTR_ERR(handle));
+				bdev_path, PTR_ERR(file));
 	}
-	return handle;
+	return file;
 }
 
 static int link_backing_dev(struct drbd_device *device,
-		const char *bdev_path, struct bdev_handle *handle)
+		const char *bdev_path, struct file *file)
 {
-	int err = bd_link_disk_holder(handle->bdev, device->vdisk);
+	int err = bd_link_disk_holder(file_bdev(file), device->vdisk);
 	if (err) {
-		bdev_release(handle);
+		fput(file);
 		drbd_err(device, "bd_link_disk_holder(\"%s\", ...) failed with %d\n",
 				bdev_path, err);
 	}
@@ -2764,22 +2764,22 @@ static int open_backing_devices(struct drbd_device *device,
 		struct disk_conf *new_disk_conf,
 		struct drbd_backing_dev *nbc)
 {
-	struct bdev_handle *handle;
+	struct file *file;
 	void *meta_claim_ptr;
 	int err;
 
-	handle = open_backing_dev(device, new_disk_conf->backing_dev, device);
-	if (IS_ERR(handle))
+	file = open_backing_dev(device, new_disk_conf->backing_dev, device);
+	if (IS_ERR(file))
 		return ERR_OPEN_DISK;
 
-	err = link_backing_dev(device, new_disk_conf->backing_dev, handle);
+	err = link_backing_dev(device, new_disk_conf->backing_dev, file);
 	if (err) {
 		/* close without unlinking; otherwise error path will try to unlink */
-		close_backing_dev(device, handle, false);
+		close_backing_dev(device, file, false);
 		return ERR_OPEN_DISK;
 	}
-	nbc->backing_bdev = handle->bdev;
-	nbc->backing_bdev_handle = handle;
+	nbc->backing_bdev = file_bdev(file);
+	nbc->backing_bdev_file = file;
 
 	/* meta_claim_ptr: device, if claimed exclusively; shared drbd_m_holder,
 	 * if potentially shared with other drbd minors
@@ -2794,23 +2794,23 @@ static int open_backing_devices(struct drbd_device *device,
 	 * should check it for you already; but if you don't, or
 	 * someone fooled it, we need to double check here)
 	 */
-	handle = open_backing_dev(device, new_disk_conf->meta_dev, meta_claim_ptr);
-	if (IS_ERR(handle))
+	file = open_backing_dev(device, new_disk_conf->meta_dev, meta_claim_ptr);
+	if (IS_ERR(file))
 		return ERR_OPEN_MD_DISK;
 
 	/* avoid double bd_claim_by_disk() for the same (source,target) tuple,
 	 * as would happen with internal metadata. */
-	if (handle != nbc->backing_bdev_handle) {
-		err = link_backing_dev(device, new_disk_conf->meta_dev, handle);
+	if (file_bdev(file) != nbc->backing_bdev) {
+		err = link_backing_dev(device, new_disk_conf->meta_dev, file);
 		if (err) {
 			/* close without unlinking; otherwise error path will try to unlink */
-			close_backing_dev(device, handle, false);
+			close_backing_dev(device, file, false);
 			return ERR_OPEN_MD_DISK;
 		}
 	}
 
-	nbc->md_bdev = handle->bdev;
-	nbc->md_bdev_handle = handle;
+	nbc->md_bdev = file_bdev(file);
+	nbc->f_md_bdev = file;
 	return NO_ERROR;
 }
 
-- 
2.35.3

