From 0943c006c7d900dfc0281639e992791d6c567438 Mon Sep 17 00:00:00 2001
From: Pierre Ossman <ossman@cendio.se>
Date: Mon, 23 Sep 2019 11:00:17 +0200
Subject: [PATCH] Use size_t for lengths in stream objects

Provides safety against them accidentally becoming negative because
of bugs in the calculations.

Also does the same to CharArray and friends as they were strongly
connection to the stream objects.
---
 common/rdr/FdInStream.cxx    | 20 ++++++++++----------
 common/rdr/FdInStream.h      | 17 +++++++++--------
 common/rdr/FdOutStream.cxx   | 20 ++++++++++----------
 common/rdr/FdOutStream.h     | 12 ++++++------
 common/rdr/FileInStream.cxx  |  8 ++++----
 common/rdr/FileInStream.h    |  4 ++--
 common/rdr/HexInStream.cxx   | 20 ++++++++++----------
 common/rdr/HexInStream.h     | 12 ++++++------
 common/rdr/HexOutStream.cxx  | 20 ++++++++++----------
 common/rdr/HexOutStream.h    | 12 ++++++------
 common/rdr/InStream.h        | 16 ++++++++--------
 common/rdr/MemInStream.h     |  8 ++++----
 common/rdr/MemOutStream.h    | 12 ++++++------
 common/rdr/OutStream.h       | 20 ++++++++++----------
 common/rdr/RandomStream.cxx  | 14 +++++++-------
 common/rdr/RandomStream.h    |  6 +++---
 common/rdr/TLSInStream.cxx   | 10 +++++-----
 common/rdr/TLSInStream.h     | 10 +++++-----
 common/rdr/TLSOutStream.cxx  | 10 +++++-----
 common/rdr/TLSOutStream.h    | 10 +++++-----
 common/rdr/ZlibInStream.cxx  | 16 ++++++++--------
 common/rdr/ZlibInStream.h    | 14 +++++++-------
 common/rdr/ZlibOutStream.cxx | 10 +++++-----
 common/rdr/ZlibOutStream.h   | 10 +++++-----
 common/rfb/Configuration.cxx |  6 +++---
 common/rfb/Configuration.h   | 13 +++++++------
 common/rfb/Password.cxx      |  6 +++---
 common/rfb/Password.h        |  6 +++---
 common/rfb/util.h            |  2 +-
 tests/perf/encperf.cxx       | 10 +++++-----
 win/rfb_win32/Registry.cxx   |  6 +++---
 win/rfb_win32/Registry.h     |  6 +++---
 32 files changed, 184 insertions(+), 182 deletions(-)

diff --git a/common/rdr/FdInStream.cxx b/common/rdr/FdInStream.cxx
index 1b9a322a..9e84ab7a 100644
--- a/common/rdr/FdInStream.cxx
+++ b/common/rdr/FdInStream.cxx
@@ -56,7 +56,7 @@ using namespace rdr;
 enum { DEFAULT_BUF_SIZE = 8192,
        MIN_BULK_SIZE = 1024 };
 
-FdInStream::FdInStream(int fd_, int timeoutms_, int bufSize_,
+FdInStream::FdInStream(int fd_, int timeoutms_, size_t bufSize_,
                        bool closeWhenDone_)
   : fd(fd_), closeWhenDone(closeWhenDone_),
     timeoutms(timeoutms_), blockCallback(0),
@@ -67,7 +67,7 @@ FdInStream::FdInStream(int fd_, int timeoutms_, int bufSize_,
 }
 
 FdInStream::FdInStream(int fd_, FdInStreamBlockCallback* blockCallback_,
-                       int bufSize_)
+                       size_t bufSize_)
   : fd(fd_), timeoutms(0), blockCallback(blockCallback_),
     timing(false), timeWaitedIn100us(5), timedKbits(0),
     bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)
@@ -92,12 +92,12 @@ void FdInStream::setBlockCallback(FdInStreamBlockCallback* blockCallback_)
   timeoutms = 0;
 }
 
-int FdInStream::pos()
+size_t FdInStream::pos()
 {
   return offset + ptr - start;
 }
 
-void FdInStream::readBytes(void* data, int length)
+void FdInStream::readBytes(void* data, size_t length)
 {
   if (length < MIN_BULK_SIZE) {
     InStream::readBytes(data, length);
@@ -106,7 +106,7 @@ void FdInStream::readBytes(void* data, int length)
 
   U8* dataPtr = (U8*)data;
 
-  int n = end - ptr;
+  size_t n = end - ptr;
   if (n > length) n = length;
 
   memcpy(dataPtr, ptr, n);
@@ -123,7 +123,7 @@ void FdInStream::readBytes(void* data, int length)
 }
 
 
-int FdInStream::overrun(int itemSize, int nItems, bool wait)
+size_t FdInStream::overrun(size_t itemSize, size_t nItems, bool wait)
 {
   if (itemSize > bufSize)
     throw Exception("FdInStream overrun: max itemSize exceeded");
@@ -135,7 +135,7 @@ int FdInStream::overrun(int itemSize, int nItems, bool wait)
   end -= ptr - start;
   ptr = start;
 
-  int bytes_to_read;
+  size_t bytes_to_read;
   while (end < start + itemSize) {
     bytes_to_read = start + bufSize - end;
     if (!timing) {
@@ -147,12 +147,12 @@ int FdInStream::overrun(int itemSize, int nItems, bool wait)
       // bytes is ineffecient.
       bytes_to_read = vncmin(bytes_to_read, vncmax(itemSize*nItems, 8));
     }
-    int n = readWithTimeoutOrCallback((U8*)end, bytes_to_read, wait);
+    size_t n = readWithTimeoutOrCallback((U8*)end, bytes_to_read, wait);
     if (n == 0) return 0;
     end += n;
   }
 
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
 
   return nItems;
@@ -171,7 +171,7 @@ int FdInStream::overrun(int itemSize, int nItems, bool wait)
 // returning EINTR.
 //
 
-int FdInStream::readWithTimeoutOrCallback(void* buf, int len, bool wait)
+size_t FdInStream::readWithTimeoutOrCallback(void* buf, size_t len, bool wait)
 {
   struct timeval before, after;
   if (timing)
diff --git a/common/rdr/FdInStream.h b/common/rdr/FdInStream.h
index b4c87653..d99ad3ce 100644
--- a/common/rdr/FdInStream.h
+++ b/common/rdr/FdInStream.h
@@ -37,16 +37,17 @@ namespace rdr {
 
   public:
 
-    FdInStream(int fd, int timeoutms=-1, int bufSize=0,
+    FdInStream(int fd, int timeoutms=-1, size_t bufSize=0,
                bool closeWhenDone_=false);
-    FdInStream(int fd, FdInStreamBlockCallback* blockCallback, int bufSize=0);
+    FdInStream(int fd, FdInStreamBlockCallback* blockCallback,
+               size_t bufSize=0);
     virtual ~FdInStream();
 
     void setTimeout(int timeoutms);
     void setBlockCallback(FdInStreamBlockCallback* blockCallback);
     int getFd() { return fd; }
-    int pos();
-    void readBytes(void* data, int length);
+    size_t pos();
+    void readBytes(void* data, size_t length);
 
     void startTiming();
     void stopTiming();
@@ -54,10 +55,10 @@ namespace rdr {
     unsigned int timeWaited() { return timeWaitedIn100us; }
 
   protected:
-    int overrun(int itemSize, int nItems, bool wait);
+    size_t overrun(size_t itemSize, size_t nItems, bool wait);
 
   private:
-    int readWithTimeoutOrCallback(void* buf, int len, bool wait=true);
+    size_t readWithTimeoutOrCallback(void* buf, size_t len, bool wait=true);
 
     int fd;
     bool closeWhenDone;
@@ -68,8 +69,8 @@ namespace rdr {
     unsigned int timeWaitedIn100us;
     unsigned int timedKbits;
 
-    int bufSize;
-    int offset;
+    size_t bufSize;
+    size_t offset;
     U8* start;
   };
 
diff --git a/common/rdr/FdOutStream.cxx b/common/rdr/FdOutStream.cxx
index cf857f85..1757dc35 100644
--- a/common/rdr/FdOutStream.cxx
+++ b/common/rdr/FdOutStream.cxx
@@ -51,7 +51,7 @@ using namespace rdr;
 
 enum { DEFAULT_BUF_SIZE = 16384 };
 
-FdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, int bufSize_)
+FdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, size_t bufSize_)
   : fd(fd_), blocking(blocking_), timeoutms(timeoutms_),
     bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)
 {
@@ -79,7 +79,7 @@ void FdOutStream::setBlocking(bool blocking_) {
   blocking = blocking_;
 }
 
-int FdOutStream::length()
+size_t FdOutStream::length()
 {
   return offset + ptr - sentUpTo;
 }
@@ -97,9 +97,9 @@ unsigned FdOutStream::getIdleTime()
 void FdOutStream::flush()
 {
   while (sentUpTo < ptr) {
-    int n = writeWithTimeout((const void*) sentUpTo,
-                             ptr - sentUpTo,
-                             blocking? timeoutms : 0);
+    size_t n = writeWithTimeout((const void*) sentUpTo,
+                                ptr - sentUpTo,
+                                blocking? timeoutms : 0);
 
     // Timeout?
     if (n == 0) {
@@ -120,7 +120,7 @@ void FdOutStream::flush()
 }
 
 
-int FdOutStream::overrun(int itemSize, int nItems)
+size_t FdOutStream::overrun(size_t itemSize, size_t nItems)
 {
   if (itemSize > bufSize)
     throw Exception("FdOutStream overrun: max itemSize exceeded");
@@ -129,10 +129,10 @@ int FdOutStream::overrun(int itemSize, int nItems)
   flush();
 
   // Still not enough space?
-  if (itemSize > end - ptr) {
+  if (itemSize > (size_t)(end - ptr)) {
     // Can we shuffle things around?
     // (don't do this if it gains us less than 25%)
-    if ((sentUpTo - start > bufSize / 4) &&
+    if (((size_t)(sentUpTo - start) > bufSize / 4) &&
         (itemSize < bufSize - (ptr - sentUpTo))) {
       memmove(start, sentUpTo, ptr - sentUpTo);
       ptr = start + (ptr - sentUpTo);
@@ -150,7 +150,7 @@ int FdOutStream::overrun(int itemSize, int nItems)
   }
 
   // Can we fit all the items asked for?
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
 
   return nItems;
@@ -166,7 +166,7 @@ int FdOutStream::overrun(int itemSize, int nItems)
 // select() and send() returning EINTR.
 //
 
-int FdOutStream::writeWithTimeout(const void* data, int length, int timeoutms)
+size_t FdOutStream::writeWithTimeout(const void* data, size_t length, int timeoutms)
 {
   int n;
 
diff --git a/common/rdr/FdOutStream.h b/common/rdr/FdOutStream.h
index b7f6cb01..ed84fdb5 100644
--- a/common/rdr/FdOutStream.h
+++ b/common/rdr/FdOutStream.h
@@ -34,7 +34,7 @@ namespace rdr {
 
   public:
 
-    FdOutStream(int fd, bool blocking=true, int timeoutms=-1, int bufSize=0);
+    FdOutStream(int fd, bool blocking=true, int timeoutms=-1, size_t bufSize=0);
     virtual ~FdOutStream();
 
     void setTimeout(int timeoutms);
@@ -42,20 +42,20 @@ namespace rdr {
     int getFd() { return fd; }
 
     void flush();
-    int length();
+    size_t length();
 
     int bufferUsage();
 
     unsigned getIdleTime();
 
   private:
-    int overrun(int itemSize, int nItems);
-    int writeWithTimeout(const void* data, int length, int timeoutms);
+    size_t overrun(size_t itemSize, size_t nItems);
+    size_t writeWithTimeout(const void* data, size_t length, int timeoutms);
     int fd;
     bool blocking;
     int timeoutms;
-    int bufSize;
-    int offset;
+    size_t bufSize;
+    size_t offset;
     U8* start;
     U8* sentUpTo;
     struct timeval lastWrite;
diff --git a/common/rdr/FileInStream.cxx b/common/rdr/FileInStream.cxx
index 3acdfd45..94f5db88 100644
--- a/common/rdr/FileInStream.cxx
+++ b/common/rdr/FileInStream.cxx
@@ -48,7 +48,7 @@ void FileInStream::reset(void) {
   ptr = end = b;
 }
 
-int FileInStream::pos()
+size_t FileInStream::pos()
 {
   if (!file)
     throw Exception("File is not open");
@@ -56,9 +56,9 @@ int FileInStream::pos()
   return ftell(file) + ptr - b;
 }
 
-int FileInStream::overrun(int itemSize, int nItems, bool wait)
+size_t FileInStream::overrun(size_t itemSize, size_t nItems, bool wait)
 {
-  if (itemSize > (int)sizeof(b))
+  if (itemSize > sizeof(b))
     throw Exception("FileInStream overrun: max itemSize exceeded");
 
   if (end - ptr != 0)
@@ -80,7 +80,7 @@ int FileInStream::overrun(int itemSize, int nItems, bool wait)
     end += b + sizeof(b) - end;
   }
 
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
 
   return nItems;
diff --git a/common/rdr/FileInStream.h b/common/rdr/FileInStream.h
index ace04f37..a33c765e 100644
--- a/common/rdr/FileInStream.h
+++ b/common/rdr/FileInStream.h
@@ -35,10 +35,10 @@ namespace rdr {
 
     void reset(void);
 
-    int pos();
+    size_t pos();
 
   protected:
-    int overrun(int itemSize, int nItems, bool wait = true);
+    size_t overrun(size_t itemSize, size_t nItems, bool wait = true);
 
   private:
     U8 b[131072];
diff --git a/common/rdr/HexInStream.cxx b/common/rdr/HexInStream.cxx
index 80f8a796..8f939889 100644
--- a/common/rdr/HexInStream.cxx
+++ b/common/rdr/HexInStream.cxx
@@ -28,7 +28,7 @@ const int DEFAULT_BUF_LEN = 16384;
 
 static inline int min(int a, int b) {return a<b ? a : b;}
 
-HexInStream::HexInStream(InStream& is, int bufSize_)
+HexInStream::HexInStream(InStream& is, size_t bufSize_)
 : bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is)
 {
   ptr = end = start = new U8[bufSize];
@@ -50,8 +50,8 @@ bool HexInStream::readHexAndShift(char c, int* v) {
   return true;
 }
 
-bool HexInStream::hexStrToBin(const char* s, char** data, int* length) {
-  int l=strlen(s);
+bool HexInStream::hexStrToBin(const char* s, char** data, size_t* length) {
+  size_t l=strlen(s);
   if ((l % 2) == 0) {
     delete [] *data;
     *data = 0; *length = 0;
@@ -59,7 +59,7 @@ bool HexInStream::hexStrToBin(const char* s, char** data, int* length) {
       return true;
     *data = new char[l/2];
     *length = l/2;
-    for(int i=0;i<l;i+=2) {
+    for(size_t i=0;i<l;i+=2) {
       int byte = 0;
       if (!readHexAndShift(s[i], &byte) ||
         !readHexAndShift(s[i+1], &byte))
@@ -76,11 +76,11 @@ decodeError:
 }
 
 
-int HexInStream::pos() {
+size_t HexInStream::pos() {
   return offset + ptr - start;
 }
 
-int HexInStream::overrun(int itemSize, int nItems, bool wait) {
+size_t HexInStream::overrun(size_t itemSize, size_t nItems, bool wait) {
   if (itemSize > bufSize)
     throw Exception("HexInStream overrun: max itemSize exceeded");
 
@@ -92,14 +92,14 @@ int HexInStream::overrun(int itemSize, int nItems, bool wait) {
   ptr = start;
 
   while (end < ptr + itemSize) {
-    int n = in_stream.check(2, 1, wait);
+    size_t n = in_stream.check(2, 1, wait);
     if (n == 0) return 0;
     const U8* iptr = in_stream.getptr();
     const U8* eptr = in_stream.getend();
-    int length = min((eptr - iptr)/2, start + bufSize - end);
+    size_t length = min((eptr - iptr)/2, start + bufSize - end);
 
     U8* optr = (U8*) end;
-    for (int i=0; i<length; i++) {
+    for (size_t i=0; i<length; i++) {
       int v = 0;
       readHexAndShift(iptr[i*2], &v);
       readHexAndShift(iptr[i*2+1], &v);
@@ -110,7 +110,7 @@ int HexInStream::overrun(int itemSize, int nItems, bool wait) {
     end += length;
   }
 
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
 
   return nItems;
diff --git a/common/rdr/HexInStream.h b/common/rdr/HexInStream.h
index 6bfb8433..8e495fbe 100644
--- a/common/rdr/HexInStream.h
+++ b/common/rdr/HexInStream.h
@@ -26,21 +26,21 @@ namespace rdr {
   class HexInStream : public InStream {
   public:
 
-    HexInStream(InStream& is, int bufSize=0);
+    HexInStream(InStream& is, size_t bufSize=0);
     virtual ~HexInStream();
 
-    int pos();
+    size_t pos();
 
     static bool readHexAndShift(char c, int* v);
-    static bool hexStrToBin(const char* s, char** data, int* length);
+    static bool hexStrToBin(const char* s, char** data, size_t* length);
 
   protected:
-    int overrun(int itemSize, int nItems, bool wait);
+    size_t overrun(size_t itemSize, size_t nItems, bool wait);
 
   private:
-    int bufSize;
+    size_t bufSize;
     U8* start;
-    int offset;
+    size_t offset;
 
     InStream& in_stream;
   };
diff --git a/common/rdr/HexOutStream.cxx b/common/rdr/HexOutStream.cxx
index 9b0b6c4d..7232514c 100644
--- a/common/rdr/HexOutStream.cxx
+++ b/common/rdr/HexOutStream.cxx
@@ -23,9 +23,9 @@ using namespace rdr;
 
 const int DEFAULT_BUF_LEN = 16384;
 
-static inline int min(int a, int b) {return a<b ? a : b;}
+static inline size_t min(size_t a, size_t b) {return a<b ? a : b;}
 
-HexOutStream::HexOutStream(OutStream& os, int buflen)
+HexOutStream::HexOutStream(OutStream& os, size_t buflen)
 : out_stream(os), offset(0), bufSize(buflen ? buflen : DEFAULT_BUF_LEN)
 {
   if (bufSize % 2)
@@ -48,9 +48,9 @@ char HexOutStream::intToHex(int i) {
     throw rdr::Exception("intToHex failed");
 }
 
-char* HexOutStream::binToHexStr(const char* data, int length) {
+char* HexOutStream::binToHexStr(const char* data, size_t length) {
   char* buffer = new char[length*2+1];
-  for (int i=0; i<length; i++) {
+  for (size_t i=0; i<length; i++) {
     buffer[i*2] = intToHex((data[i] >> 4) & 15);
     buffer[i*2+1] = intToHex((data[i] & 15));
     if (!buffer[i*2] || !buffer[i*2+1]) {
@@ -70,9 +70,9 @@ HexOutStream::writeBuffer() {
     out_stream.check(2);
     U8* optr = out_stream.getptr();
     U8* oend = out_stream.getend();
-    int length = min(ptr-pos, (oend-optr)/2);
+    size_t length = min(ptr-pos, (oend-optr)/2);
 
-    for (int i=0; i<length; i++) {
+    for (size_t i=0; i<length; i++) {
       optr[i*2] = intToHex((pos[i] >> 4) & 0xf);
       optr[i*2+1] = intToHex(pos[i] & 0xf);
     }
@@ -84,7 +84,7 @@ HexOutStream::writeBuffer() {
   ptr = start;
 }
 
-int HexOutStream::length()
+size_t HexOutStream::length()
 {
   return offset + ptr - start;
 }
@@ -95,14 +95,14 @@ HexOutStream::flush() {
   out_stream.flush();
 }
 
-int
-HexOutStream::overrun(int itemSize, int nItems) {
+size_t
+HexOutStream::overrun(size_t itemSize, size_t nItems) {
   if (itemSize > bufSize)
     throw Exception("HexOutStream overrun: max itemSize exceeded");
 
   writeBuffer();
 
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
 
   return nItems;
diff --git a/common/rdr/HexOutStream.h b/common/rdr/HexOutStream.h
index 10247e68..92442a72 100644
--- a/common/rdr/HexOutStream.h
+++ b/common/rdr/HexOutStream.h
@@ -26,24 +26,24 @@ namespace rdr {
   class HexOutStream : public OutStream {
   public:
 
-    HexOutStream(OutStream& os, int buflen=0);
+    HexOutStream(OutStream& os, size_t buflen=0);
     virtual ~HexOutStream();
 
     void flush();
-    int length();
+    size_t length();
 
     static char intToHex(int i);
-    static char* binToHexStr(const char* data, int length);
+    static char* binToHexStr(const char* data, size_t length);
 
   private:
     void writeBuffer();
-    int overrun(int itemSize, int nItems);
+    size_t overrun(size_t itemSize, size_t nItems);
 
     OutStream& out_stream;
 
     U8* start;
-    int offset;
-    int bufSize;
+    size_t offset;
+    size_t bufSize;
   };
 
 }
diff --git a/common/rdr/InStream.h b/common/rdr/InStream.h
index 212a2ec9..14ecf093 100644
--- a/common/rdr/InStream.h
+++ b/common/rdr/InStream.h
@@ -41,7 +41,7 @@ namespace rdr {
     // for the bytes, zero is returned if the bytes are not immediately
     // available.
 
-    inline int check(int itemSize, int nItems=1, bool wait=true)
+    inline size_t check(size_t itemSize, size_t nItems=1, bool wait=true)
     {
       if (ptr + itemSize * nItems > end) {
         if (ptr + itemSize > end)
@@ -56,7 +56,7 @@ namespace rdr {
     // be read without blocking.  It returns true if this is the case, false
     // otherwise.  The length must be "small" (less than the buffer size).
 
-    inline bool checkNoWait(int length) { return check(length, 1, false)!=0; }
+    inline bool checkNoWait(size_t length) { return check(length, 1, false)!=0; }
 
     // readU/SN() methods read unsigned and signed N-bit integers.
 
@@ -82,9 +82,9 @@ namespace rdr {
 
     static U32 maxStringLength;
 
-    inline void skip(int bytes) {
+    inline void skip(size_t bytes) {
       while (bytes > 0) {
-        int n = check(1, bytes);
+        size_t n = check(1, bytes);
         ptr += n;
         bytes -= n;
       }
@@ -92,11 +92,11 @@ namespace rdr {
 
     // readBytes() reads an exact number of bytes.
 
-    void readBytes(void* data, int length) {
+    void readBytes(void* data, size_t length) {
       U8* dataPtr = (U8*)data;
       U8* dataEnd = dataPtr + length;
       while (dataPtr < dataEnd) {
-        int n = check(1, dataEnd - dataPtr);
+        size_t n = check(1, dataEnd - dataPtr);
         memcpy(dataPtr, ptr, n);
         ptr += n;
         dataPtr += n;
@@ -114,7 +114,7 @@ namespace rdr {
 
     // pos() returns the position in the stream.
 
-    virtual int pos() = 0;
+    virtual size_t pos() = 0;
 
     // getptr(), getend() and setptr() are "dirty" methods which allow you to
     // manipulate the buffer directly.  This is useful for a stream which is a
@@ -133,7 +133,7 @@ namespace rdr {
     // instead of blocking to wait for the bytes, zero is returned if the bytes
     // are not immediately available.
 
-    virtual int overrun(int itemSize, int nItems, bool wait=true) = 0;
+    virtual size_t overrun(size_t itemSize, size_t nItems, bool wait=true) = 0;
 
   protected:
 
diff --git a/common/rdr/MemInStream.h b/common/rdr/MemInStream.h
index 1a6a7982..3e9e77bc 100644
--- a/common/rdr/MemInStream.h
+++ b/common/rdr/MemInStream.h
@@ -36,7 +36,7 @@ namespace rdr {
 
   public:
 
-    MemInStream(const void* data, int len, bool deleteWhenDone_=false)
+    MemInStream(const void* data, size_t len, bool deleteWhenDone_=false)
       : start((const U8*)data), deleteWhenDone(deleteWhenDone_)
     {
       ptr = start;
@@ -48,12 +48,12 @@ namespace rdr {
         delete [] start;
     }
 
-    int pos() { return ptr - start; }
-    void reposition(int pos) { ptr = start + pos; }
+    size_t pos() { return ptr - start; }
+    void reposition(size_t pos) { ptr = start + pos; }
 
   private:
 
-    int overrun(int itemSize, int nItems, bool wait) { throw EndOfStream(); }
+    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }
     const U8* start;
     bool deleteWhenDone;
   };
diff --git a/common/rdr/MemOutStream.h b/common/rdr/MemOutStream.h
index 3b17e555..4a815b30 100644
--- a/common/rdr/MemOutStream.h
+++ b/common/rdr/MemOutStream.h
@@ -40,16 +40,16 @@ namespace rdr {
       delete [] start;
     }
 
-    void writeBytes(const void* data, int length) {
+    void writeBytes(const void* data, size_t length) {
       check(length);
       memcpy(ptr, data, length);
       ptr += length;
     }
 
-    int length() { return ptr - start; }
+    size_t length() { return ptr - start; }
     void clear() { ptr = start; };
     void clearAndZero() { memset(start, 0, ptr-start); clear(); }
-    void reposition(int pos) { ptr = start + pos; }
+    void reposition(size_t pos) { ptr = start + pos; }
 
     // data() returns a pointer to the buffer.
 
@@ -60,9 +60,9 @@ namespace rdr {
     // overrun() either doubles the buffer or adds enough space for nItems of
     // size itemSize bytes.
 
-    int overrun(int itemSize, int nItems) {
-      int len = ptr - start + itemSize * nItems;
-      if (len < (end - start) * 2)
+    size_t overrun(size_t itemSize, size_t nItems) {
+      size_t len = ptr - start + itemSize * nItems;
+      if (len < (size_t)(end - start) * 2)
         len = (end - start) * 2;
 
       U8* newStart = new U8[len];
diff --git a/common/rdr/OutStream.h b/common/rdr/OutStream.h
index a749a208..11aafd2d 100644
--- a/common/rdr/OutStream.h
+++ b/common/rdr/OutStream.h
@@ -44,7 +44,7 @@ namespace rdr {
     // itemSize bytes.  Returns the number of items which fit (up to a maximum
     // of nItems).
 
-    inline int check(int itemSize, int nItems=1)
+    inline size_t check(size_t itemSize, size_t nItems=1)
     {
       if (ptr + itemSize * nItems > end) {
         if (ptr + itemSize > end)
@@ -76,13 +76,13 @@ namespace rdr {
       writeBytes(str, len);
     }
 
-    inline void pad(int bytes) {
+    inline void pad(size_t bytes) {
       while (bytes-- > 0) writeU8(0);
     }
 
-    inline void skip(int bytes) {
+    inline void skip(size_t bytes) {
       while (bytes > 0) {
-        int n = check(1, bytes);
+        size_t n = check(1, bytes);
         ptr += n;
         bytes -= n;
       }
@@ -90,11 +90,11 @@ namespace rdr {
 
     // writeBytes() writes an exact number of bytes.
 
-    void writeBytes(const void* data, int length) {
+    void writeBytes(const void* data, size_t length) {
       const U8* dataPtr = (const U8*)data;
       const U8* dataEnd = dataPtr + length;
       while (dataPtr < dataEnd) {
-        int n = check(1, dataEnd - dataPtr);
+        size_t n = check(1, dataEnd - dataPtr);
         memcpy(ptr, dataPtr, n);
         ptr += n;
         dataPtr += n;
@@ -103,9 +103,9 @@ namespace rdr {
 
     // copyBytes() efficiently transfers data between streams
 
-    void copyBytes(InStream* is, int length) {
+    void copyBytes(InStream* is, size_t length) {
       while (length > 0) {
-        int n = check(1, length);
+        size_t n = check(1, length);
         is->readBytes(ptr, n);
         ptr += n;
         length -= n;
@@ -124,7 +124,7 @@ namespace rdr {
 
     // length() returns the length of the stream.
 
-    virtual int length() = 0;
+    virtual size_t length() = 0;
 
     // flush() requests that the stream be flushed.
 
@@ -145,7 +145,7 @@ namespace rdr {
     // the number of items which fit (up to a maximum of nItems).  itemSize is
     // supposed to be "small" (a few bytes).
 
-    virtual int overrun(int itemSize, int nItems) = 0;
+    virtual size_t overrun(size_t itemSize, size_t nItems) = 0;
 
   protected:
 
diff --git a/common/rdr/RandomStream.cxx b/common/rdr/RandomStream.cxx
index e22da3d0..d5f1cc85 100644
--- a/common/rdr/RandomStream.cxx
+++ b/common/rdr/RandomStream.cxx
@@ -35,7 +35,7 @@ static rfb::LogWriter vlog("RandomStream");
 
 using namespace rdr;
 
-const int DEFAULT_BUF_LEN = 256;
+const size_t DEFAULT_BUF_LEN = 256;
 
 unsigned int RandomStream::seed;
 
@@ -86,11 +86,11 @@ RandomStream::~RandomStream() {
 #endif
 }
 
-int RandomStream::pos() {
+size_t RandomStream::pos() {
   return offset + ptr - start;
 }
 
-int RandomStream::overrun(int itemSize, int nItems, bool wait) {
+size_t RandomStream::overrun(size_t itemSize, size_t nItems, bool wait) {
   if (itemSize > DEFAULT_BUF_LEN)
     throw Exception("RandomStream overrun: max itemSize exceeded");
 
@@ -101,7 +101,7 @@ int RandomStream::overrun(int itemSize, int nItems, bool wait) {
   offset += ptr - start;
   ptr = start;
 
-  int length = start + DEFAULT_BUF_LEN - end;
+  size_t length = start + DEFAULT_BUF_LEN - end;
 
 #ifdef RFB_HAVE_WINCRYPT
   if (provider) {
@@ -112,7 +112,7 @@ int RandomStream::overrun(int itemSize, int nItems, bool wait) {
 #else
 #ifndef WIN32
   if (fp) {
-    int n = fread((U8*)end, length, 1, fp);
+    size_t n = fread((U8*)end, length, 1, fp);
     if (n != 1)
       throw rdr::SystemException("reading /dev/urandom or /dev/random failed",
                                  errno);
@@ -122,11 +122,11 @@ int RandomStream::overrun(int itemSize, int nItems, bool wait) {
   {
 #endif
 #endif
-    for (int i=0; i<length; i++)
+    for (size_t i=0; i<length; i++)
       *(U8*)end++ = (int) (256.0*rand()/(RAND_MAX+1.0));
   }
 
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
 
   return nItems;
diff --git a/common/rdr/RandomStream.h b/common/rdr/RandomStream.h
index c33360d7..80b389b2 100644
--- a/common/rdr/RandomStream.h
+++ b/common/rdr/RandomStream.h
@@ -39,14 +39,14 @@ namespace rdr {
     RandomStream();
     virtual ~RandomStream();
 
-    int pos();
+    size_t pos();
 
   protected:
-    int overrun(int itemSize, int nItems, bool wait);
+    size_t overrun(size_t itemSize, size_t nItems, bool wait);
 
   private:
     U8* start;
-    int offset;
+    size_t offset;
 
     static unsigned int seed;
 #ifdef RFB_HAVE_WINCRYPT
diff --git a/common/rdr/TLSInStream.cxx b/common/rdr/TLSInStream.cxx
index 77b16729..d0f94263 100644
--- a/common/rdr/TLSInStream.cxx
+++ b/common/rdr/TLSInStream.cxx
@@ -75,12 +75,12 @@ TLSInStream::~TLSInStream()
   delete[] start;
 }
 
-int TLSInStream::pos()
+size_t TLSInStream::pos()
 {
   return offset + ptr - start;
 }
 
-int TLSInStream::overrun(int itemSize, int nItems, bool wait)
+size_t TLSInStream::overrun(size_t itemSize, size_t nItems, bool wait)
 {
   if (itemSize > bufSize)
     throw Exception("TLSInStream overrun: max itemSize exceeded");
@@ -93,19 +93,19 @@ int TLSInStream::overrun(int itemSize, int nItems, bool wait)
   ptr = start;
 
   while (end < start + itemSize) {
-    int n = readTLS((U8*) end, start + bufSize - end, wait);
+    size_t n = readTLS((U8*) end, start + bufSize - end, wait);
     if (!wait && n == 0)
       return 0;
     end += n;
   }
 
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
 
   return nItems;
 }
 
-int TLSInStream::readTLS(U8* buf, int len, bool wait)
+size_t TLSInStream::readTLS(U8* buf, size_t len, bool wait)
 {
   int n;
 
diff --git a/common/rdr/TLSInStream.h b/common/rdr/TLSInStream.h
index b16d9f5a..5f9dee7f 100644
--- a/common/rdr/TLSInStream.h
+++ b/common/rdr/TLSInStream.h
@@ -36,17 +36,17 @@ namespace rdr {
     TLSInStream(InStream* in, gnutls_session_t session);
     virtual ~TLSInStream();
 
-    int pos();
+    size_t pos();
 
   private:
-    int overrun(int itemSize, int nItems, bool wait);
-    int readTLS(U8* buf, int len, bool wait);
+    size_t overrun(size_t itemSize, size_t nItems, bool wait);
+    size_t readTLS(U8* buf, size_t len, bool wait);
     static ssize_t pull(gnutls_transport_ptr_t str, void* data, size_t size);
 
     gnutls_session_t session;
     InStream* in;
-    int bufSize;
-    int offset;
+    size_t bufSize;
+    size_t offset;
     U8* start;
   };
 };
diff --git a/common/rdr/TLSOutStream.cxx b/common/rdr/TLSOutStream.cxx
index 44d2d9f3..30c456fe 100644
--- a/common/rdr/TLSOutStream.cxx
+++ b/common/rdr/TLSOutStream.cxx
@@ -75,7 +75,7 @@ TLSOutStream::~TLSOutStream()
   delete [] start;
 }
 
-int TLSOutStream::length()
+size_t TLSOutStream::length()
 {
   return offset + ptr - start;
 }
@@ -84,7 +84,7 @@ void TLSOutStream::flush()
 {
   U8* sentUpTo = start;
   while (sentUpTo < ptr) {
-    int n = writeTLS(sentUpTo, ptr - sentUpTo);
+    size_t n = writeTLS(sentUpTo, ptr - sentUpTo);
     sentUpTo += n;
     offset += n;
   }
@@ -93,20 +93,20 @@ void TLSOutStream::flush()
   out->flush();
 }
 
-int TLSOutStream::overrun(int itemSize, int nItems)
+size_t TLSOutStream::overrun(size_t itemSize, size_t nItems)
 {
   if (itemSize > bufSize)
     throw Exception("TLSOutStream overrun: max itemSize exceeded");
 
   flush();
 
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
 
   return nItems;
 }
 
-int TLSOutStream::writeTLS(const U8* data, int length)
+size_t TLSOutStream::writeTLS(const U8* data, size_t length)
 {
   int n;
 
diff --git a/common/rdr/TLSOutStream.h b/common/rdr/TLSOutStream.h
index 81dd237a..71a7f3bf 100644
--- a/common/rdr/TLSOutStream.h
+++ b/common/rdr/TLSOutStream.h
@@ -36,20 +36,20 @@ namespace rdr {
     virtual ~TLSOutStream();
 
     void flush();
-    int length();
+    size_t length();
 
   protected:
-    int overrun(int itemSize, int nItems);
+    size_t overrun(size_t itemSize, size_t nItems);
 
   private:
-    int writeTLS(const U8* data, int length);
+    size_t writeTLS(const U8* data, size_t length);
     static ssize_t push(gnutls_transport_ptr_t str, const void* data, size_t size);
 
     gnutls_session_t session;
     OutStream* out;
-    int bufSize;
+    size_t bufSize;
     U8* start;
-    int offset;
+    size_t offset;
   };
 };
 
diff --git a/common/rdr/ZlibInStream.cxx b/common/rdr/ZlibInStream.cxx
index a361010c..e2f971c7 100644
--- a/common/rdr/ZlibInStream.cxx
+++ b/common/rdr/ZlibInStream.cxx
@@ -26,7 +26,7 @@ using namespace rdr;
 
 enum { DEFAULT_BUF_SIZE = 16384 };
 
-ZlibInStream::ZlibInStream(int bufSize_)
+ZlibInStream::ZlibInStream(size_t bufSize_)
   : underlying(0), bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0),
     zs(NULL), bytesIn(0)
 {
@@ -40,14 +40,14 @@ ZlibInStream::~ZlibInStream()
   delete [] start;
 }
 
-void ZlibInStream::setUnderlying(InStream* is, int bytesIn_)
+void ZlibInStream::setUnderlying(InStream* is, size_t bytesIn_)
 {
   underlying = is;
   bytesIn = bytesIn_;
   ptr = end = start;
 }
 
-int ZlibInStream::pos()
+size_t ZlibInStream::pos()
 {
   return offset + ptr - start;
 }
@@ -96,7 +96,7 @@ void ZlibInStream::deinit()
   zs = NULL;
 }
 
-int ZlibInStream::overrun(int itemSize, int nItems, bool wait)
+size_t ZlibInStream::overrun(size_t itemSize, size_t nItems, bool wait)
 {
   if (itemSize > bufSize)
     throw Exception("ZlibInStream overrun: max itemSize exceeded");
@@ -108,12 +108,12 @@ int ZlibInStream::overrun(int itemSize, int nItems, bool wait)
   end -= ptr - start;
   ptr = start;
 
-  while (end - ptr < itemSize) {
+  while ((size_t)(end - ptr) < itemSize) {
     if (!decompress(wait))
       return 0;
   }
 
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
 
   return nItems;
@@ -131,11 +131,11 @@ bool ZlibInStream::decompress(bool wait)
   zs->next_out = (U8*)end;
   zs->avail_out = start + bufSize - end;
 
-  int n = underlying->check(1, 1, wait);
+  size_t n = underlying->check(1, 1, wait);
   if (n == 0) return false;
   zs->next_in = (U8*)underlying->getptr();
   zs->avail_in = underlying->getend() - underlying->getptr();
-  if ((int)zs->avail_in > bytesIn)
+  if (zs->avail_in > bytesIn)
     zs->avail_in = bytesIn;
 
   int rc = inflate(zs, Z_SYNC_FLUSH);
diff --git a/common/rdr/ZlibInStream.h b/common/rdr/ZlibInStream.h
index 86ba1ff1..08784b0f 100644
--- a/common/rdr/ZlibInStream.h
+++ b/common/rdr/ZlibInStream.h
@@ -34,12 +34,12 @@ namespace rdr {
 
   public:
 
-    ZlibInStream(int bufSize=0);
+    ZlibInStream(size_t bufSize=0);
     virtual ~ZlibInStream();
 
-    void setUnderlying(InStream* is, int bytesIn);
+    void setUnderlying(InStream* is, size_t bytesIn);
     void flushUnderlying();
-    int pos();
+    size_t pos();
     void reset();
 
   private:
@@ -47,14 +47,14 @@ namespace rdr {
     void init();
     void deinit();
 
-    int overrun(int itemSize, int nItems, bool wait);
+    size_t overrun(size_t itemSize, size_t nItems, bool wait);
     bool decompress(bool wait);
 
     InStream* underlying;
-    int bufSize;
-    int offset;
+    size_t bufSize;
+    size_t offset;
     z_stream_s* zs;
-    int bytesIn;
+    size_t bytesIn;
     U8* start;
   };
 
diff --git a/common/rdr/ZlibOutStream.cxx b/common/rdr/ZlibOutStream.cxx
index dd3c2367..26a11315 100644
--- a/common/rdr/ZlibOutStream.cxx
+++ b/common/rdr/ZlibOutStream.cxx
@@ -33,7 +33,7 @@ using namespace rdr;
 
 enum { DEFAULT_BUF_SIZE = 16384 };
 
-ZlibOutStream::ZlibOutStream(OutStream* os, int bufSize_, int compressLevel)
+ZlibOutStream::ZlibOutStream(OutStream* os, size_t bufSize_, int compressLevel)
   : underlying(os), compressionLevel(compressLevel), newLevel(compressLevel),
     bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)
 {
@@ -75,7 +75,7 @@ void ZlibOutStream::setCompressionLevel(int level)
   newLevel = level;
 }
 
-int ZlibOutStream::length()
+size_t ZlibOutStream::length()
 {
   return offset + ptr - start;
 }
@@ -98,7 +98,7 @@ void ZlibOutStream::flush()
   ptr = start;
 }
 
-int ZlibOutStream::overrun(int itemSize, int nItems)
+size_t ZlibOutStream::overrun(size_t itemSize, size_t nItems)
 {
 #ifdef ZLIBOUT_DEBUG
   vlog.debug("overrun");
@@ -109,7 +109,7 @@ int ZlibOutStream::overrun(int itemSize, int nItems)
 
   checkCompressionLevel();
 
-  while (end - ptr < itemSize) {
+  while ((size_t)(end - ptr) < itemSize) {
     zs->next_in = start;
     zs->avail_in = ptr - start;
 
@@ -130,7 +130,7 @@ int ZlibOutStream::overrun(int itemSize, int nItems)
     }
   }
 
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
 
   return nItems;
diff --git a/common/rdr/ZlibOutStream.h b/common/rdr/ZlibOutStream.h
index 2d82a13b..11bb0468 100644
--- a/common/rdr/ZlibOutStream.h
+++ b/common/rdr/ZlibOutStream.h
@@ -35,25 +35,25 @@ namespace rdr {
 
   public:
 
-    ZlibOutStream(OutStream* os=0, int bufSize=0, int compressionLevel=-1);
+    ZlibOutStream(OutStream* os=0, size_t bufSize=0, int compressionLevel=-1);
     virtual ~ZlibOutStream();
 
     void setUnderlying(OutStream* os);
     void setCompressionLevel(int level=-1);
     void flush();
-    int length();
+    size_t length();
 
   private:
 
-    int overrun(int itemSize, int nItems);
+    size_t overrun(size_t itemSize, size_t nItems);
     void deflate(int flush);
     void checkCompressionLevel();
 
     OutStream* underlying;
     int compressionLevel;
     int newLevel;
-    int bufSize;
-    int offset;
+    size_t bufSize;
+    size_t offset;
     z_stream_s* zs;
     U8* start;
   };
diff --git a/common/rfb/Configuration.cxx b/common/rfb/Configuration.cxx
index ea000600..ceaefccb 100644
--- a/common/rfb/Configuration.cxx
+++ b/common/rfb/Configuration.cxx
@@ -421,7 +421,7 @@ StringParameter::operator const char *() const {
 // -=- BinaryParameter
 
 BinaryParameter::BinaryParameter(const char* name_, const char* desc_,
-				 const void* v, int l, ConfigurationObject co)
+				 const void* v, size_t l, ConfigurationObject co)
 : VoidParameter(name_, desc_, co), value(0), length(0), def_value((char*)v), def_length(l) {
   if (l) {
     value = new char[l];
@@ -441,7 +441,7 @@ bool BinaryParameter::setParam(const char* v) {
   return rdr::HexInStream::hexStrToBin(v, &value, &length);
 }
 
-void BinaryParameter::setParam(const void* v, int len) {
+void BinaryParameter::setParam(const void* v, size_t len) {
   LOCK_CONFIG;
   if (immutable) return; 
   vlog.debug("set %s(Binary)", getName());
@@ -462,7 +462,7 @@ char* BinaryParameter::getValueStr() const {
   return rdr::HexOutStream::binToHexStr(value, length);
 }
 
-void BinaryParameter::getData(void** data_, int* length_) const {
+void BinaryParameter::getData(void** data_, size_t* length_) const {
   LOCK_CONFIG;
   if (length_) *length_ = length;
   if (data_) {
diff --git a/common/rfb/Configuration.h b/common/rfb/Configuration.h
index 6197317b..e23e8a51 100644
--- a/common/rfb/Configuration.h
+++ b/common/rfb/Configuration.h
@@ -256,24 +256,25 @@ namespace rfb {
 
   class BinaryParameter : public VoidParameter {
   public:
-    BinaryParameter(const char* name_, const char* desc_, const void* v, int l,
-		    ConfigurationObject co=ConfGlobal);
+    BinaryParameter(const char* name_, const char* desc_,
+                    const void* v, size_t l,
+                    ConfigurationObject co=ConfGlobal);
     using VoidParameter::setParam;
     virtual ~BinaryParameter();
     virtual bool setParam(const char* value);
-    virtual void setParam(const void* v, int l);
+    virtual void setParam(const void* v, size_t l);
     virtual char* getDefaultStr() const;
     virtual char* getValueStr() const;
 
     // getData() will return length zero if there is no data
     // NB: data may be set to zero, OR set to a zero-length buffer
-    void getData(void** data, int* length) const;
+    void getData(void** data, size_t* length) const;
 
   protected:
     char* value;
-    int length;
+    size_t length;
     char* def_value;
-    int def_length;
+    size_t def_length;
   };
 
   // -=- ParameterIterator
diff --git a/common/rfb/Password.cxx b/common/rfb/Password.cxx
index 240c9d4f..e4a508c8 100644
--- a/common/rfb/Password.cxx
+++ b/common/rfb/Password.cxx
@@ -38,7 +38,7 @@ PlainPasswd::PlainPasswd() {}
 PlainPasswd::PlainPasswd(char* pwd) : CharArray(pwd) {
 }
 
-PlainPasswd::PlainPasswd(int len) : CharArray(len) {
+PlainPasswd::PlainPasswd(size_t len) : CharArray(len) {
 }
 
 PlainPasswd::PlainPasswd(const ObfuscatedPasswd& obfPwd) : CharArray(9) {
@@ -63,11 +63,11 @@ void PlainPasswd::replaceBuf(char* b) {
 ObfuscatedPasswd::ObfuscatedPasswd() : length(0) {
 }
 
-ObfuscatedPasswd::ObfuscatedPasswd(int len) : CharArray(len), length(len) {
+ObfuscatedPasswd::ObfuscatedPasswd(size_t len) : CharArray(len), length(len) {
 }
 
 ObfuscatedPasswd::ObfuscatedPasswd(const PlainPasswd& plainPwd) : CharArray(8), length(8) {
-  int l = strlen(plainPwd.buf), i;
+  size_t l = strlen(plainPwd.buf), i;
   for (i=0; i<8; i++)
     buf[i] = i<l ? plainPwd.buf[i] : 0;
   deskey(d3desObfuscationKey, EN0);
diff --git a/common/rfb/Password.h b/common/rfb/Password.h
index e5196ee0..712bc813 100644
--- a/common/rfb/Password.h
+++ b/common/rfb/Password.h
@@ -28,7 +28,7 @@ namespace rfb {
   public:
     PlainPasswd();
     PlainPasswd(char* pwd);
-    PlainPasswd(int len);
+    PlainPasswd(size_t len);
     PlainPasswd(const ObfuscatedPasswd& obfPwd);
     ~PlainPasswd();
     void replaceBuf(char* b);
@@ -37,10 +37,10 @@ namespace rfb {
   class ObfuscatedPasswd : public CharArray {
   public:
     ObfuscatedPasswd();
-    ObfuscatedPasswd(int l);
+    ObfuscatedPasswd(size_t l);
     ObfuscatedPasswd(const PlainPasswd& plainPwd);
     ~ObfuscatedPasswd();
-    int length;
+    size_t length;
   };
 
 }
diff --git a/common/rfb/util.h b/common/rfb/util.h
index 8503519d..3100f90f 100644
--- a/common/rfb/util.h
+++ b/common/rfb/util.h
@@ -50,7 +50,7 @@ namespace rfb {
   public:
     CharArray() : buf(0) {}
     CharArray(char* str) : buf(str) {} // note: assumes ownership
-    CharArray(int len) {
+    CharArray(size_t len) {
       buf = new char[len]();
     }
     ~CharArray() {
diff --git a/tests/perf/encperf.cxx b/tests/perf/encperf.cxx
index e461197e..171564d1 100644
--- a/tests/perf/encperf.cxx
+++ b/tests/perf/encperf.cxx
@@ -71,11 +71,11 @@ class DummyOutStream : public rdr::OutStream {
 public:
   DummyOutStream();
 
-  virtual int length();
+  virtual size_t length();
   virtual void flush();
 
 private:
-  virtual int overrun(int itemSize, int nItems);
+  virtual size_t overrun(size_t itemSize, size_t nItems);
 
   int offset;
   rdr::U8 buf[131072];
@@ -141,7 +141,7 @@ DummyOutStream::DummyOutStream()
   end = buf + sizeof(buf);
 }
 
-int DummyOutStream::length()
+size_t DummyOutStream::length()
 {
   flush();
   return offset;
@@ -153,10 +153,10 @@ void DummyOutStream::flush()
   ptr = buf;
 }
 
-int DummyOutStream::overrun(int itemSize, int nItems)
+size_t DummyOutStream::overrun(size_t itemSize, size_t nItems)
 {
   flush();
-  if (itemSize * nItems > end - ptr)
+  if (itemSize * nItems > (size_t)(end - ptr))
     nItems = (end - ptr) / itemSize;
   return nItems;
 }
diff --git a/win/rfb_win32/Registry.cxx b/win/rfb_win32/Registry.cxx
index 9cd50184..5d78c4c4 100644
--- a/win/rfb_win32/Registry.cxx
+++ b/win/rfb_win32/Registry.cxx
@@ -146,7 +146,7 @@ void RegKey::setString(const TCHAR* valname, const TCHAR* value) const {
   if (result != ERROR_SUCCESS) throw rdr::SystemException("setString", result);
 }
 
-void RegKey::setBinary(const TCHAR* valname, const void* value, int length) const {
+void RegKey::setBinary(const TCHAR* valname, const void* value, size_t length) const {
   LONG result = RegSetValueEx(key, valname, 0, REG_BINARY, (const BYTE*)value, length);
   if (result != ERROR_SUCCESS) throw rdr::SystemException("setBinary", result);
 }
@@ -169,12 +169,12 @@ TCHAR* RegKey::getString(const TCHAR* valname, const TCHAR* def) const {
   }
 }
 
-void RegKey::getBinary(const TCHAR* valname, void** data, int* length) const {
+void RegKey::getBinary(const TCHAR* valname, void** data, size_t* length) const {
   TCharArray hex(getRepresentation(valname));
   if (!rdr::HexInStream::hexStrToBin(CStr(hex.buf), (char**)data, length))
     throw rdr::Exception("getBinary failed");
 }
-void RegKey::getBinary(const TCHAR* valname, void** data, int* length, void* def, int deflen) const {
+void RegKey::getBinary(const TCHAR* valname, void** data, size_t* length, void* def, size_t deflen) const {
   try {
     getBinary(valname, data, length);
   } catch(rdr::Exception&) {
diff --git a/win/rfb_win32/Registry.h b/win/rfb_win32/Registry.h
index 68d535cd..2bb16911 100644
--- a/win/rfb_win32/Registry.h
+++ b/win/rfb_win32/Registry.h
@@ -71,15 +71,15 @@ namespace rfb {
 
       void setExpandString(const TCHAR* valname, const TCHAR* s) const;
       void setString(const TCHAR* valname, const TCHAR* s) const;
-      void setBinary(const TCHAR* valname, const void* data, int length) const;
+      void setBinary(const TCHAR* valname, const void* data, size_t length) const;
       void setInt(const TCHAR* valname, int i) const;
       void setBool(const TCHAR* valname, bool b) const;
 
       TCHAR* getString(const TCHAR* valname) const;
       TCHAR* getString(const TCHAR* valname, const TCHAR* def) const;
 
-      void getBinary(const TCHAR* valname, void** data, int* length) const;
-      void getBinary(const TCHAR* valname, void** data, int* length, void* def, int deflength) const;
+      void getBinary(const TCHAR* valname, void** data, size_t* length) const;
+      void getBinary(const TCHAR* valname, void** data, size_t* length, void* def, size_t deflength) const;
 
       int getInt(const TCHAR* valname) const;
       int getInt(const TCHAR* valname, int def) const;
-- 
2.16.4

