[gdb/testsuite] Handle pipe2 syscall in gdb.base/catch-syscall.exp

When running test-case gdb.reverse/pipe-reverse.exp on openSUSE Tumbleweed,
I run into:
...
(gdb) continue^M
Continuing.^M
^M
Catchpoint 2 (returned from syscall pipe2), in pipe () from /lib64/libc.so.6^M
(gdb) FAIL: gdb.base/catch-syscall.exp: without arguments: \
  syscall pipe has returned
...

The current glibc on Tumbleweed is 2.35, which contains commit
"linux: Implement pipe in terms of __NR_pipe2", and consequently syscall pipe2
is used instead of syscall pipe.

Fix this by detecting whether syscall pipe or pipe2 is used before running the
tests.

Tested on x86_64-linux, specifically on:
- openSUSE Tumbleweed (with glibc 2.35), and
- openSUSE Leap 15.3 (with glibc 2.31).

On openSUSE Tumbleweed + target board unix/-m32, this exposes:
...
(gdb) catch syscall pipe2^M
Unknown syscall name 'pipe2'.^M
...
which will be fixed in a folllow-up patch.

Bug: https://sourceware.org/bugzilla/show_bug.cgi?id=29056

---
 gdb/testsuite/gdb.base/catch-syscall.c   |  3 +-
 gdb/testsuite/gdb.base/catch-syscall.exp | 69 ++++++++++++++++++++++++++++----
 2 files changed, 64 insertions(+), 8 deletions(-)

diff --git a/gdb/testsuite/gdb.base/catch-syscall.c b/gdb/testsuite/gdb.base/catch-syscall.c
index 0ab96318d3e..8c252a06b20 100644
--- a/gdb/testsuite/gdb.base/catch-syscall.c
+++ b/gdb/testsuite/gdb.base/catch-syscall.c
@@ -24,7 +24,8 @@ int chroot_syscall = SYS_chroot;
 int read_syscall = SYS_read;
 #ifdef SYS_pipe
 int pipe_syscall = SYS_pipe;
-#else
+#endif
+#ifdef SYS_pipe2
 int pipe2_syscall = SYS_pipe2;
 #endif
 int write_syscall = SYS_write;
diff --git a/gdb/testsuite/gdb.base/catch-syscall.exp b/gdb/testsuite/gdb.base/catch-syscall.exp
index a5dfd02411b..1427dfece6d 100644
--- a/gdb/testsuite/gdb.base/catch-syscall.exp
+++ b/gdb/testsuite/gdb.base/catch-syscall.exp
@@ -669,35 +669,90 @@ proc fill_all_syscalls_numbers {} {
     set unknown_syscall_number [get_integer_valueof "unknown_syscall" -1]
 }
 
-# Set up the vector all_syscalls.
+# Set up the vector all_syscalls.  Returns 1 upon success, 0 upon failure.
 
 proc setup_all_syscalls {} {
     global all_syscalls
     global gdb_prompt
+    global decimal
 
     # They are ordered according to the file, so do not change this.
     lappend all_syscalls "close"
     lappend all_syscalls "chroot"
 
+    if { ![runto_main] } {
+	return 0
+    }
+
     # SYS_pipe doesn't exist on aarch64 kernel.
     set test "check SYS_pipe"
+    set have_SYS_pipe 0
     gdb_test_multiple "p pipe_syscall" $test {
-	-re " = .*$gdb_prompt $" {
+	-re -wrap " = $decimal" {
 	    pass $test
-	    lappend all_syscalls "pipe"
+	    set have_SYS_pipe 1
 	}
-	-re "No symbol .*$gdb_prompt $" {
+	-re -wrap "No symbol .*" {
 	    pass $test
-	    # SYS_pipe isn't defined, use SYS_pipe2 instead.
-	    lappend all_syscalls "pipe2"
+	}
+    }
+
+    set test "check SYS_pipe2"
+    set have_SYS_pipe2 0
+    gdb_test_multiple "p pipe2_syscall" $test {
+	-re -wrap " = $decimal" {
+	    pass $test
+	    set have_SYS_pipe2 1
+	}
+	-re -wrap "No symbol .*" {
+	    pass $test
+	}
+    }
+
+    if { $have_SYS_pipe == 0 && $have_SYS_pipe2 == 0 } {
+	return 0
+    }
+
+    with_test_prefix "determine pipe syscall" {
+	set line [gdb_get_line_number "pipe (fd)"]
+	gdb_test "break $line"
+	gdb_continue_to_breakpoint "before pipe call"
+	if { $have_SYS_pipe } {
+	    gdb_test "catch syscall pipe"
+	}
+	if { $have_SYS_pipe2 } {
+	    gdb_test "catch syscall pipe2"
+	}
+	set ok 0
+	gdb_test_multiple "continue" "" {
+	    -re -wrap "Catchpoint $decimal \\(call to syscall pipe\\).*" {
+		lappend all_syscalls pipe
+		pass $gdb_test_name
+		set ok 1
+	    }
+	    -re -wrap "Catchpoint $decimal \\(call to syscall pipe2\\).*" {
+		lappend all_syscalls pipe2
+		pass $gdb_test_name
+		set ok 1
+	    }
+	    -re -wrap "" {
+		fail $gdb_test_name
+	    }
+	}
+	if { ! $ok } {
+	    return 0
 	}
     }
 
     lappend all_syscalls "write"
     lappend all_syscalls "read"
+
+    return 1
 }
 
-setup_all_syscalls
+if { ![setup_all_syscalls] } {
+    return -1
+}
 
 # Fill all the syscalls numbers before starting anything.
 fill_all_syscalls_numbers
