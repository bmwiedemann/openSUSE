diff --git a/Makefile.am b/Makefile.am
index b1aacdf..cd597d5 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,10 +1,10 @@
 RPM		= rpmbuild
 RPMFLAGS	= -ta
 
-SUBDIRS    = include utils lib unix $(GLIB_DIR) $(TCL_DIR) libedit cmdlang \
+SUBDIRS    = include utils lib unix $(GLIB_DIR) $(TCL_DIR) cmdlang \
 	     ui lanserv sample doc man $(SWIG_DIR)
 
-DIST_SUBDIRS = include utils lib unix glib tcl libedit cmdlang \
+DIST_SUBDIRS = include utils lib unix glib tcl cmdlang \
 	     ui lanserv sample doc man swig
 
 EXTRA_DIST = FAQ TODO README.Force README.MotorolaMXP OpenIPMI.spec.in \
@@ -29,10 +29,10 @@ uninstall-local:
 rpm: dist
 	$(RPM) $(RPMFLAGS) $(distdir).tar.gz < /dev/null
 
-PYPATH=$(top_builddir)/swig/python:$(top_builddir)/swig/python/.libs:$(srcdir)/openipmigui
+PYPATH=$(top_builddir)/swig/python:$(top_builddir)/swig/python/.libs
 
 rungui:
-	LD_LIBRARY_PATH=$(top_builddir)/glib/.libs LD_PRELOAD=$(OPENIPMI_SWIG_SO):$(top_builddir)/swig/python/.libs/_OpenIPMI.so PYTHONPATH=$(PYPATH) $(pythonprog) $(top_srcdir)/swig/python/openipmigui.py
+	LD_LIBRARY_PATH=$(top_builddir)/glib/.libs LD_PRELOAD=$(OPENIPMI_SWIG_SO):$(top_builddir)/swig/python/.libs/_OpenIPMI.so PYTHONPATH=$(PYPATH) $(PYTHON) $(top_srcdir)/swig/python/openipmigui.py
 
 DISTCLEANFILES=OpenIPMI.spec OpenIPMIcmdlang.pc OpenIPMI.pc OpenIPMItcl.pc \
 	OpenIPMIglib12.pc OpenIPMIposix.pc OpenIPMIui.pc OpenIPMIglib.pc \
diff --git a/cmdlang/Makefile.am b/cmdlang/Makefile.am
index 264ee12..0ca3827 100644
--- a/cmdlang/Makefile.am
+++ b/cmdlang/Makefile.am
@@ -4,7 +4,7 @@ LD_VERSION = 0:5:0
 
 AM_CFLAGS = -Wall -Wsign-compare -I$(top_builddir)/include \
 	-I$(top_srcdir)/include \
-	-I$(top_srcdir)/libedit -DIPMI_CHECK_LOCKS $(GLIB_CFLAGS) \
+	-DIPMI_CHECK_LOCKS $(GLIB_CFLAGS) \
 	$(TCL_CFLAGS)
 
 lib_LTLIBRARIES = libOpenIPMIcmdlang.la
@@ -25,7 +25,7 @@ openipmish_LDADD =  libOpenIPMIcmdlang.la \
 		$(top_builddir)/utils/libOpenIPMIutils.la \
 		$(top_builddir)/lib/libOpenIPMI.la \
 		$(top_builddir)/unix/libOpenIPMIposix.la \
-		$(top_builddir)/libedit/libedit.a \
+		-lreadline \
 		$(TERM_LIBS) \
 		$(SNMPLIBS) $(GLIB_LIB) $(GLIB_LIBS) \
 		$(TCL_LIB) $(TCL_LIBS) \
diff --git a/cmdlang/ipmish.c b/cmdlang/ipmish.c
index 906cf19..139da67 100644
--- a/cmdlang/ipmish.c
+++ b/cmdlang/ipmish.c
@@ -50,7 +50,7 @@
 #include <OpenIPMI/ipmi_tcl.h>
 #include <OpenIPMI/ipmi_cmdlang.h>
 #include <OpenIPMI/ipmi_debug.h>
-#include <editline/readline.h>
+#include <readline/readline.h>
 
 #ifdef HAVE_GLIB
 #include <glib.h>
@@ -1049,6 +1049,8 @@ main(int argc, char *argv[])
 	}
     }
 
+    rl_initialize();
+
     if (use_debug_os) {
 	os_hnd = &ipmi_debug_os_handlers;
 	rv = sel_alloc_selector_nothread(&debug_sel);
diff --git a/configure.ac b/configure.ac
index f8bb95f..173226c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -187,14 +187,18 @@ AC_ARG_WITH(perlusepthreads,
    fi,
 )
 
+pythonprog=
 trypython=yes
 AC_ARG_WITH(python,
 [  --with-python[[=yes|no|PATH]]     Look for python, with the optional path.],
-    if test "x$withval" = "xyes"; then
+    if test "x$withval" = "x"; then
+      trypython=yes
+    elif test "x$withval" = "xyes"; then
       trypython=yes
     elif test "x$withval" = "xno"; then
       trypython=no
-    elif test -d "$withval"; then
+    else
+      pythonprog="$withval"
       trypython=yes
     fi,
 )
@@ -340,33 +344,22 @@ if test "x$haveglib" = "xyes"; then
    GLIB_SO='$(top_builddir)/glib/.libs/libOpenIPMIglib.so'
    GLIB_PKGCONF=OpenIPMIglib.pc
    GLIB_TARGET=libOpenIPMIglib.la
+   GLIB_DIR=glib
 else
    GLIB_LIB=
    GLIB_SO=
    GLIB_PKGCONF=
    GLIB_TARGET=
+   GLIB_DIR=
 fi
 AC_SUBST(GLIB_VERSION)
 AC_SUBST(GLIB_CFLAGS)
 AC_SUBST(GLIB_LIBS)
-
 AC_SUBST(GLIB_LIB)
 AC_SUBST(GLIB_SO)
 AC_SUBST(GLIB_PKGCONF)
 AC_SUBST(GLIB_TARGET)
-
-if test "x$haveglib" = "xyes"; then
-   GLIB_DIR=glib
-   GLIB_SINGLE_LIB=$GLIB_LIB
-   GLIB_SINGLE_SO=$GLIB_SO
-else
-   GLIB_DIR=
-   GLIB_SINGLE_LIB=
-   GLIB_SINGLE_SO=
-fi
 AC_SUBST(GLIB_DIR)
-AC_SUBST(GLIB_SINGLE_LIB)
-AC_SUBST(GLIB_SINGLE_SO)
 
 # Handle TCL support
 TCL_LIBS=
@@ -523,87 +516,65 @@ AC_SUBST(PERL_POSIX_LIB)
 AC_SUBST(PERL_POSIX_SO)
 
 # Handle PYTHON support
-if test "x$pythoncflags" = "x" -o "x$pythoninstalldir" = "x"; then
-   pythonprog=
-   if test "x$trypython" != "xno"; then
-      AC_PATH_PROG(pythonprog, python)
-   fi
+PYTHON_DIR=
+PYTHON_INSTALL_DIR=
+PYTHON_INSTALL_LIB_DIR=
+PYTHON_SWIG_FLAGS=
+if test "x$trypython" = "xyes"; then
    if test "x$pythonprog" != "x"; then
-      # Now find a proper installation location.
-      if test "x$pythoninstalldir" = "x"; then
-	 pythoninstalldir=`$pythonprog -c 'import distutils.sysconfig; print(distutils.sysconfig.get_python_lib());'`
-	 if test "x$pythoninstalldir" = "x" -o ! -d "$pythoninstalldir"; then
-	    pythoninstalldir=
-	 fi
-      fi
+      PYTHON="$pythonprog"
    fi
-
-   if test "x$pythoncflags" = "x"; then
-      pythoninc=`$pythonprog -c 'import distutils.sysconfig; print(distutils.sysconfig.get_python_inc());'`
-      if test "x$pythoninc" != "x"; then
-         pythoncflags="-I$pythoninc"
-      else
-         pythoncflags=""
-      fi
-   else
-      PYTHON_CFLAGS="$pythoncflags"
+   if test "x$pythoncflags" != "x"; then
+      PYTHON_CPPFLAGS="$pythoncflags"
    fi
-
-   if test "x$pythoninstalldir" != "x"; then
-      if test "x$pythoninstalllibdir" = "x"; then
-	 pythoninstalllibdir=$pythoninstalldir
-      fi
-      AC_DEFINE([HAVE_PYTHON], [], [Have Python installed])
-      PYTHON_DIR=python
-      PYTHON_CFLAGS="$pythoncflags"
-      PYTHON_INSTALL_DIR="$pythoninstalldir"
-      PYTHON_INSTALL_LIB_DIR="$pythoninstalllibdir"
+   AX_PYTHON_DEVEL
+fi
+if test "x$PYTHON" != "x"; then
+   AX_PROG_PYTHON_VERSION([3.0.0], [PYTHON_SWIG_FLAGS=-py3], [])
+   AC_DEFINE([HAVE_PYTHON], [], [Have Python installed])
+   PYTHON_DIR=python
+   if test "x$pythoninstalldir" = "x"; then
+      PYTHON_INSTALL_DIR="$PYTHON_SITE_PKG"
    else
-      PYTHON_DIR=
-      PYTHON_CFLAGS=
-      PYTHON_INSTALL_DIR=
-      PYTHON_INSTALL_LIB_DIR=
+      PYTHON_INSTALL_DIR="$pythoninstalldir"
    fi
-else
    if test "x$pythoninstalllibdir" = "x"; then
-      pythoninstalllibdir=$pythoninstalldir
+      PYTHON_INSTALL_LIB_DIR="$PYTHON_INSTALL_DIR"
+   else
+      PYTHON_INSTALL_LIB_DIR="$pythoninstalllibdir"
    fi
-   AC_DEFINE([HAVE_PYTHON], [], [Have Python installed])
-   PYTHON_DIR=python
-   PYTHON_CFLAGS="$pythoncflags"
-   PYTHON_INSTALL_DIR="$pythoninstalldir"
-   PYTHON_INSTALL_LIB_DIR="$pythoninstalllibdir"
-fi
-if test "x$pythonprog" != "x"; then
+
    if test "x$pythonusepthreads" = "x"; then
       cat - <<_ACEOF >conftest.py
 try:
-  import thread
+  import threading
   print('yes')
 except:
   print('no')
 _ACEOF
-      pythonusepthreads=`python conftest.py`
+      pythonusepthreads=`$PYTHON conftest.py`
       rm -f conftest.py
    fi
    echo "checking for python threads... $pythonusepthreads"
+
+   if test "x$pythonusepthreads" = "xyes"; then
+      PYTHON_HAS_POSIX_THREADS=1
+      PYTHON_POSIX_LIB='$(top_builddir)/unix/libOpenIPMIpthread.la'
+      PYTHON_POSIX_SO='$(top_builddir)/unix/.libs/libOpenIPMIpthread.so'
+   else
+      PYTHON_HAS_POSIX_THREADS=0
+      PYTHON_POSIX_LIB='$(top_builddir)/unix/libOpenIPMIposix.la'
+      PYTHON_POSIX_SO='$(top_builddir)/unix/.libs/libOpenIPMIposix.so'
+   fi
 fi
-if test "x$pythonusepthreads" = "xyes"; then
-   PYTHON_HAS_POSIX_THREADS=1
-   PYTHON_POSIX_LIB='$(top_builddir)/unix/libOpenIPMIpthread.la'
-   PYTHON_POSIX_SO='$(top_builddir)/unix/.libs/libOpenIPMIpthread.so'
-else
-   PYTHON_HAS_POSIX_THREADS=0
-   PYTHON_POSIX_LIB='$(top_builddir)/unix/libOpenIPMIposix.la'
-   PYTHON_POSIX_SO='$(top_builddir)/unix/.libs/libOpenIPMIposix.so'
-fi
+
 AC_SUBST(PYTHON_DIR)
-AC_SUBST(PYTHON_CFLAGS)
 AC_SUBST(PYTHON_INSTALL_DIR)
 AC_SUBST(PYTHON_INSTALL_LIB_DIR)
 AC_SUBST(PYTHON_HAS_POSIX_THREADS)
 AC_SUBST(PYTHON_POSIX_LIB)
 AC_SUBST(PYTHON_POSIX_SO)
+AC_SUBST(PYTHON_SWIG_FLAGS)
 
 # Check for Tkinter/Tix
 if test "x$tkinter" = "x"; then
@@ -628,25 +599,17 @@ fi
 AC_SUBST(PYTHON_GUI_DIR)
 
 # Now check for swig
-if test "x$swigprog" = "x" -a "x$tryswig" = "xyes"; then
-   AC_PATH_PROG(swigprog, swig)
-fi
-if test "x$swigprog" != "x"; then
-   swigver=`$swigprog -version 2>&1 | grep 'SWIG Version' | sed 's/SWIG Version //'`
-   swigmajor=`echo $swigver | sed 's/\.[[0-9]]*\.[[0-9]]*$//'`
-   swigminor=`echo $swigver | sed 's/^[[0-9]]*\.\([[0-9]]*\)\.[[0-9]]*$/\1/'`
-   swigrel=`echo $swigver | sed 's/^[[0-9]]*\.[[0-9]]*\.//'`
-   if test '(' "$swigmajor" -lt 1 ')' -o '(' '(' "$swigmajor" -eq 1 ')' -a '(' "$swigminor" -lt 3 ')' ')' -o '(' '(' "$swigmajor" -eq 1 ')' -a '(' "$swigminor" -eq 3 ')' -a '(' "$swigrel" -lt 21 ')' ')'; then
-      echo "***swig must be version 1.3.21 or greater, disabling swig and perl/python"
-   else
-      echo "swig version $swigver"
+SWIG_DIR=
+SWIG=
+if test "x$tryswig" = "xyes"; then
+   if test "x$swigprog" != "x"; then
+      SWIG="$swigprog"
+   fi
+   AX_PKG_SWIG([1.3.21])
+   if test "x$SWIG" != "x"; then
       AC_DEFINE([HAVE_SWIG], [], [Have swig installed])
       SWIG_DIR=swig
-      SWIG=$swigprog
    fi
-else
-   SWIG_DIR=
-   SWIG=
 fi
 AC_SUBST(SWIG_DIR)
 AC_SUBST(SWIG)
@@ -788,8 +751,8 @@ AC_SUBST(LATEX)
 AC_SUBST(BIBTEX)
 AC_SUBST(DVIPDF)
 
-OPENIPMI_SWIG_LIBS="${PYTHON_POSIX_LIB} \$(top_builddir)/lib/libOpenIPMI.la \$(top_builddir)/utils/libOpenIPMIutils.la \$(top_builddir)/cmdlang/libOpenIPMIcmdlang.la ${GLIB_SINGLE_LIB} ${TCL_LIB}"
-OPENIPMI_SWIG_SO="${PYTHON_POSIX_SO}:\$(top_builddir)/lib/.libs/libOpenIPMI.so:\$(top_builddir)/utils/.libs/libOpenIPMIutils.so:\$(top_builddir)/cmdlang/.libs/libOpenIPMIcmdlang.so:${GLIB_SINGLE_SO}:${TCL_SO}"
+OPENIPMI_SWIG_LIBS="${PYTHON_POSIX_LIB} \$(top_builddir)/lib/libOpenIPMI.la \$(top_builddir)/utils/libOpenIPMIutils.la \$(top_builddir)/cmdlang/libOpenIPMIcmdlang.la ${GLIB_LIB} ${TCL_LIB}"
+OPENIPMI_SWIG_SO="${PYTHON_POSIX_SO}:\$(top_builddir)/lib/.libs/libOpenIPMI.so:\$(top_builddir)/utils/.libs/libOpenIPMIutils.so:\$(top_builddir)/cmdlang/.libs/libOpenIPMIcmdlang.so:${GLIB_SO}:${TCL_SO}"
 AC_SUBST(OPENIPMI_SWIG_LIBS)
 AC_SUBST(OPENIPMI_SWIG_SO)
 
diff --git a/include/OpenIPMI/selector.h b/include/OpenIPMI/selector.h
index 29c0f18..1e87b61 100644
--- a/include/OpenIPMI/selector.h
+++ b/include/OpenIPMI/selector.h
@@ -95,6 +95,11 @@ int sel_set_fd_handlers(struct selector_s *sel,
    sure to not be called again. */
 void sel_clear_fd_handlers(struct selector_s *sel,
 			   int        fd);
+/* Like above, but can only be called if no handlers are active.
+   If it detects a handler is active, it will assert.  This should
+   only be used at startup to clear the fd handler after an error
+   before any handlers are enabled. */
+void sel_clear_fd_handlers_imm(struct selector_s *sel, int fd);
 
 /* Turn on and off handling for I/O from a file descriptor. */
 #define SEL_FD_HANDLER_ENABLED	0
@@ -121,6 +126,11 @@ int sel_start_timer(sel_timer_t    *timer,
 		    struct timeval *timeout);
 
 int sel_stop_timer(sel_timer_t *timer);
+
+/* Stops the timer and calls the done handler when the stop is
+   complete.  This will return an error if the timer is not
+   running or if another done handler is pending running, and
+   the done handler will not be called. */
 int sel_stop_timer_with_done(sel_timer_t *timer,
 			     sel_timeout_handler_t done_handler,
 			     void *cb_data);
@@ -157,6 +167,15 @@ int sel_select(struct selector_s *sel,
 	       void            *cb_data,
 	       struct timeval  *timeout);
 
+/*
+ * Like the above call, but it will return EINTR if interrupted.
+ */
+int sel_select_intr(struct selector_s *sel,
+		    sel_send_sig_cb send_sig,
+		    long            thread_id,
+		    void            *cb_data,
+		    struct timeval  *timeout);
+
 /* This is the main loop for the program.  If NULL is passed in to
    send_sig, then the signal sender is not used.  If this encounters
    an unrecoverable problem with select(), it will return the errno.
@@ -166,6 +185,9 @@ int sel_select_loop(struct selector_s *sel,
 		    long            thread_id,
 		    void            *cb_data);
 
+/* Wake all threads in all select loops. */
+void sel_wake_all(struct selector_s *sel);
+
 typedef void (*ipmi_sel_add_read_fds_cb)(struct selector_s *sel,
 					 int            *num_fds,
 					 fd_set         *fdset,
diff --git a/lib/ipmi_smi.c b/lib/ipmi_smi.c
index 2094ebf..52408c4 100644
--- a/lib/ipmi_smi.c
+++ b/lib/ipmi_smi.c
@@ -901,7 +901,7 @@ ipmi_dev_data_handler(int            fd,
 		      os_hnd_fd_id_t *id)
 {
     ipmi_con_t       *ipmi = (ipmi_con_t *) cb_data;
-    unsigned char    data[MAX_IPMI_DATA_SIZE];
+    unsigned char    data[IPMI_MAX_MSG_LENGTH];
     ipmi_addr_t      addr;
     struct ipmi_recv recv;
     int              rv;
diff --git a/libedit/Makefile.am b/libedit/Makefile.am
deleted file mode 100644
index a8714ca..0000000
--- a/libedit/Makefile.am
+++ /dev/null
@@ -1,42 +0,0 @@
-
-BUILT_SOURCES = vi.h emacs.h common.h fcns.h help.h fcns.c help.c
-
-AHDR= vi.h emacs.h common.h 
-ASRC= $(srcdir)/vi.c $(srcdir)/emacs.c $(srcdir)/common.c
-
-vi.h: Makefile $(srcdir)/vi.c
-	sh $(srcdir)/makelist -h $(srcdir)/vi.c > $@
-
-emacs.h: Makefile $(srcdir)/emacs.c
-	sh $(srcdir)/makelist -h $(srcdir)/emacs.c > $@
-
-common.h: Makefile $(srcdir)/common.c
-	sh $(srcdir)/makelist -h $(srcdir)/common.c > $@
-
-fcns.h: Makefile $(AHDR)
-	sh $(srcdir)/makelist -fh $(AHDR) > $@
-
-help.h: Makefile $(ASRC)
-	sh $(srcdir)/makelist -bh $(ASRC) > $@
-
-fcns.c: Makefile $(AHDR)
-	sh $(srcdir)/makelist -fc $(AHDR) > $@
-
-help.c: Makefile $(ASRC)
-	sh $(srcdir)/makelist -bc $(ASRC) > $@
-
-
-CLEANFILES = $(BUILT_SOURCES)
-
-noinst_LIBRARIES    = libedit.a
-libedit_a_SOURCES = chared.c common.c el.c emacs.c hist.c key.c map.c parse.c \
-		prompt.c read.c refresh.c search.c sig.c term.c tty.c vi.c \
-		fgetln.c strlcat.c strlcpy.c unvis.c vis.c tokenizer.c \
-		history.c filecomplete.c readline.c chared.h el.h hist.h \
-		histedit.h key.h map.h parse.h prompt.h read.h refresh.h \
-		search.h sig.h sys.h el_term.h tty.h vis.h filecomplete.h \
-		editline/readline.h
-
-EXTRA_DIST = makelist orig_editline.diff orig_editline.diff2
-
-nodist_libedit_a_SOURCES = $(BUILT_SOURCES)
diff --git a/libedit/chared.c b/libedit/chared.c
deleted file mode 100644
index e68cb6d..0000000
--- a/libedit/chared.c
+++ /dev/null
@@ -1,777 +0,0 @@
-/*	$NetBSD: chared.c,v 1.25 2005/08/08 01:41:30 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)chared.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: chared.c,v 1.25 2005/08/08 01:41:30 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * chared.c: Character editor utilities
- */
-#include <stdlib.h>
-#include "el.h"
-
-private void ch__clearmacro __P((EditLine *));
-
-/* value to leave unused in line buffer */
-#define	EL_LEAVE	2
-
-/* cv_undo():
- *	Handle state for the vi undo command
- */
-protected void
-cv_undo(EditLine *el)
-{
-	c_undo_t *vu = &el->el_chared.c_undo;
-	c_redo_t *r = &el->el_chared.c_redo;
-	unsigned int size;
-
-	/* Save entire line for undo */
-	size = el->el_line.lastchar - el->el_line.buffer;
-	vu->len = size;
-	vu->cursor = el->el_line.cursor - el->el_line.buffer;
-	memcpy(vu->buf, el->el_line.buffer, size);
-
-	/* save command info for redo */
-	r->count = el->el_state.doingarg ? el->el_state.argument : 0;
-	r->action = el->el_chared.c_vcmd.action;
-	r->pos = r->buf;
-	r->cmd = el->el_state.thiscmd;
-	r->ch = el->el_state.thisch;
-}
-
-/* cv_yank():
- *	Save yank/delete data for paste
- */
-protected void
-cv_yank(EditLine *el, const char *ptr, int size)
-{
-	c_kill_t *k = &el->el_chared.c_kill;
-
-	memcpy(k->buf, ptr, size +0u);
-	k->last = k->buf + size;
-}
-
-
-/* c_insert():
- *	Insert num characters
- */
-protected void
-c_insert(EditLine *el, int num)
-{
-	char *cp;
-
-	if (el->el_line.lastchar + num >= el->el_line.limit) {
-		if (!ch_enlargebufs(el, num +0u))
-			return;		/* can't go past end of buffer */
-	}
-
-	if (el->el_line.cursor < el->el_line.lastchar) {
-		/* if I must move chars */
-		for (cp = el->el_line.lastchar; cp >= el->el_line.cursor; cp--)
-			cp[num] = *cp;
-	}
-	el->el_line.lastchar += num;
-}
-
-
-/* c_delafter():
- *	Delete num characters after the cursor
- */
-protected void
-c_delafter(EditLine *el, int num)
-{
-
-	if (el->el_line.cursor + num > el->el_line.lastchar)
-		num = el->el_line.lastchar - el->el_line.cursor;
-
-	if (el->el_map.current != el->el_map.emacs) {
-		cv_undo(el);
-		cv_yank(el, el->el_line.cursor, num);
-	}
-
-	if (num > 0) {
-		char *cp;
-
-		for (cp = el->el_line.cursor; cp <= el->el_line.lastchar; cp++)
-			*cp = cp[num];
-
-		el->el_line.lastchar -= num;
-	}
-}
-
-
-/* c_delafter1():
- *	Delete the character after the cursor, do not yank
- */
-protected void
-c_delafter1(EditLine *el)
-{
-	char *cp;
-
-	for (cp = el->el_line.cursor; cp <= el->el_line.lastchar; cp++)
-		*cp = cp[1];
-
-	el->el_line.lastchar--;
-}
-
-
-/* c_delbefore():
- *	Delete num characters before the cursor
- */
-protected void
-c_delbefore(EditLine *el, int num)
-{
-
-	if (el->el_line.cursor - num < el->el_line.buffer)
-		num = el->el_line.cursor - el->el_line.buffer;
-
-	if (el->el_map.current != el->el_map.emacs) {
-		cv_undo(el);
-		cv_yank(el, el->el_line.cursor - num, num);
-	}
-
-	if (num > 0) {
-		char *cp;
-
-		for (cp = el->el_line.cursor - num;
-		    cp <= el->el_line.lastchar;
-		    cp++)
-			*cp = cp[num];
-
-		el->el_line.lastchar -= num;
-	}
-}
-
-
-/* c_delbefore1():
- *	Delete the character before the cursor, do not yank
- */
-protected void
-c_delbefore1(EditLine *el)
-{
-	char *cp;
-
-	for (cp = el->el_line.cursor - 1; cp <= el->el_line.lastchar; cp++)
-		*cp = cp[1];
-
-	el->el_line.lastchar--;
-}
-
-
-/* ce__isword():
- *	Return if p is part of a word according to emacs
- */
-protected int
-ce__isword(int p)
-{
-	return (isalnum(p) || strchr("*?_-.[]~=", p) != NULL);
-}
-
-
-/* cv__isword():
- *	Return if p is part of a word according to vi
- */
-protected int
-cv__isword(int p)
-{
-	if (isalnum(p) || p == '_')
-		return 1;
-	if (isgraph(p))
-		return 2;
-	return 0;
-}
-
-
-/* cv__isWord():
- *	Return if p is part of a big word according to vi
- */
-protected int
-cv__isWord(int p)
-{
-	return (!isspace(p));
-}
-
-
-/* c__prev_word():
- *	Find the previous word
- */
-protected char *
-c__prev_word(char *p, char *low, int n, int (*wtest)(int))
-{
-	p--;
-
-	while (n--) {
-		while ((p >= low) && !(*wtest)((unsigned char) *p))
-			p--;
-		while ((p >= low) && (*wtest)((unsigned char) *p))
-			p--;
-	}
-
-	/* cp now points to one character before the word */
-	p++;
-	if (p < low)
-		p = low;
-	/* cp now points where we want it */
-	return (p);
-}
-
-
-/* c__next_word():
- *	Find the next word
- */
-protected char *
-c__next_word(char *p, char *high, int n, int (*wtest)(int))
-{
-	while (n--) {
-		while ((p < high) && !(*wtest)((unsigned char) *p))
-			p++;
-		while ((p < high) && (*wtest)((unsigned char) *p))
-			p++;
-	}
-	if (p > high)
-		p = high;
-	/* p now points where we want it */
-	return (p);
-}
-
-/* cv_next_word():
- *	Find the next word vi style
- */
-protected char *
-cv_next_word(EditLine *el, char *p, char *high, int n, int (*wtest)(int))
-{
-	int test;
-
-	while (n--) {
-		test = (*wtest)((unsigned char) *p);
-		while ((p < high) && (*wtest)((unsigned char) *p) == test)
-			p++;
-		/*
-		 * vi historically deletes with cw only the word preserving the
-		 * trailing whitespace! This is not what 'w' does..
-		 */
-		if (n || el->el_chared.c_vcmd.action != (DELETE|INSERT))
-			while ((p < high) && isspace((unsigned char) *p))
-				p++;
-	}
-
-	/* p now points where we want it */
-	if (p > high)
-		return (high);
-	else
-		return (p);
-}
-
-
-/* cv_prev_word():
- *	Find the previous word vi style
- */
-protected char *
-cv_prev_word(char *p, char *low, int n, int (*wtest)(int))
-{
-	int test;
-
-	p--;
-	while (n--) {
-		while ((p > low) && isspace((unsigned char) *p))
-			p--;
-		test = (*wtest)((unsigned char) *p);
-		while ((p >= low) && (*wtest)((unsigned char) *p) == test)
-			p--;
-	}
-	p++;
-
-	/* p now points where we want it */
-	if (p < low)
-		return (low);
-	else
-		return (p);
-}
-
-
-#ifdef notdef
-/* c__number():
- *	Ignore character p points to, return number appearing after that.
- * 	A '$' by itself means a big number; "$-" is for negative; '^' means 1.
- * 	Return p pointing to last char used.
- */
-protected char *
-c__number(
-    char *p,	/* character position */
-    int *num,	/* Return value	*/
-    int dval)	/* dval is the number to subtract from like $-3 */
-{
-	int i;
-	int sign = 1;
-
-	if (*++p == '^') {
-		*num = 1;
-		return (p);
-	}
-	if (*p == '$') {
-		if (*++p != '-') {
-			*num = 0x7fffffff;	/* Handle $ */
-			return (--p);
-		}
-		sign = -1;			/* Handle $- */
-		++p;
-	}
-	for (i = 0; isdigit((unsigned char) *p); i = 10 * i + *p++ - '0')
-		continue;
-	*num = (sign < 0 ? dval - i : i);
-	return (--p);
-}
-#endif
-
-/* cv_delfini():
- *	Finish vi delete action
- */
-protected void
-cv_delfini(EditLine *el)
-{
-	int size;
-	int action = el->el_chared.c_vcmd.action;
-
-	if (action & INSERT)
-		el->el_map.current = el->el_map.key;
-
-	if (el->el_chared.c_vcmd.pos == 0)
-		/* sanity */
-		return;
-
-	size = el->el_line.cursor - el->el_chared.c_vcmd.pos;
-	if (size == 0)
-		size = 1;
-	el->el_line.cursor = el->el_chared.c_vcmd.pos;
-	if (action & YANK) {
-		if (size > 0)
-			cv_yank(el, el->el_line.cursor, size);
-		else
-			cv_yank(el, el->el_line.cursor + size, -size);
-	} else {
-		if (size > 0) {
-			c_delafter(el, size);
-			re_refresh_cursor(el);
-		} else  {
-			c_delbefore(el, -size);
-			el->el_line.cursor += size;
-		}
-	}
-	el->el_chared.c_vcmd.action = NOP;
-}
-
-
-#ifdef notdef
-/* ce__endword():
- *	Go to the end of this word according to emacs
- */
-protected char *
-ce__endword(char *p, char *high, int n)
-{
-	p++;
-
-	while (n--) {
-		while ((p < high) && isspace((unsigned char) *p))
-			p++;
-		while ((p < high) && !isspace((unsigned char) *p))
-			p++;
-	}
-
-	p--;
-	return (p);
-}
-#endif
-
-
-/* cv__endword():
- *	Go to the end of this word according to vi
- */
-protected char *
-cv__endword(char *p, char *high, int n, int (*wtest)(int))
-{
-	int test;
-
-	p++;
-
-	while (n--) {
-		while ((p < high) && isspace((unsigned char) *p))
-			p++;
-
-		test = (*wtest)((unsigned char) *p);
-		while ((p < high) && (*wtest)((unsigned char) *p) == test)
-			p++;
-	}
-	p--;
-	return (p);
-}
-
-/* ch_init():
- *	Initialize the character editor
- */
-protected int
-ch_init(EditLine *el)
-{
-	c_macro_t *ma = &el->el_chared.c_macro;
-
-	el->el_line.buffer		= (char *) el_malloc(EL_BUFSIZ);
-	if (el->el_line.buffer == NULL)
-		return (-1);
-
-	(void) memset(el->el_line.buffer, 0, EL_BUFSIZ);
-	el->el_line.cursor		= el->el_line.buffer;
-	el->el_line.lastchar		= el->el_line.buffer;
-	el->el_line.limit		= &el->el_line.buffer[EL_BUFSIZ - EL_LEAVE];
-
-	el->el_chared.c_undo.buf	= (char *) el_malloc(EL_BUFSIZ);
-	if (el->el_chared.c_undo.buf == NULL)
-		return (-1);
-	(void) memset(el->el_chared.c_undo.buf, 0, EL_BUFSIZ);
-	el->el_chared.c_undo.len	= -1;
-	el->el_chared.c_undo.cursor	= 0;
-	el->el_chared.c_redo.buf	= (char *) el_malloc(EL_BUFSIZ);
-	if (el->el_chared.c_redo.buf == NULL)
-		return (-1);
-	el->el_chared.c_redo.pos	= el->el_chared.c_redo.buf;
-	el->el_chared.c_redo.lim	= el->el_chared.c_redo.buf + EL_BUFSIZ;
-	el->el_chared.c_redo.cmd	= ED_UNASSIGNED;
-
-	el->el_chared.c_vcmd.action	= NOP;
-	el->el_chared.c_vcmd.pos	= el->el_line.buffer;
-
-	el->el_chared.c_kill.buf	= (char *) el_malloc(EL_BUFSIZ);
-	if (el->el_chared.c_kill.buf == NULL)
-		return (-1);
-	(void) memset(el->el_chared.c_kill.buf, 0, EL_BUFSIZ);
-	el->el_chared.c_kill.mark	= el->el_line.buffer;
-	el->el_chared.c_kill.last	= el->el_chared.c_kill.buf;
-
-	el->el_map.current		= el->el_map.key;
-
-	el->el_state.inputmode		= MODE_INSERT; /* XXX: save a default */
-	el->el_state.doingarg		= 0;
-	el->el_state.metanext		= 0;
-	el->el_state.argument		= 1;
-	el->el_state.lastcmd		= ED_UNASSIGNED;
-
-	ma->level	= -1;
-	ma->offset	= 0;
-	ma->macro	= (char **) el_malloc(EL_MAXMACRO * sizeof(char *));
-	if (ma->macro == NULL)
-		return (-1);
-	return (0);
-}
-
-/* ch_reset():
- *	Reset the character editor
- */
-protected void
-ch_reset(EditLine *el, int mclear)
-{
-	el->el_line.cursor		= el->el_line.buffer;
-	el->el_line.lastchar		= el->el_line.buffer;
-
-	el->el_chared.c_undo.len	= -1;
-	el->el_chared.c_undo.cursor	= 0;
-
-	el->el_chared.c_vcmd.action	= NOP;
-	el->el_chared.c_vcmd.pos	= el->el_line.buffer;
-
-	el->el_chared.c_kill.mark	= el->el_line.buffer;
-
-	el->el_map.current		= el->el_map.key;
-
-	el->el_state.inputmode		= MODE_INSERT; /* XXX: save a default */
-	el->el_state.doingarg		= 0;
-	el->el_state.metanext		= 0;
-	el->el_state.argument		= 1;
-	el->el_state.lastcmd		= ED_UNASSIGNED;
-
-	el->el_history.eventno		= 0;
-
-	if (mclear)
-		ch__clearmacro(el);
-}
-
-private void
-ch__clearmacro(el)
-	EditLine *el;
-{
-	c_macro_t *ma = &el->el_chared.c_macro;
-	while (ma->level >= 0)
-		el_free((ptr_t)ma->macro[ma->level--]);
-}
-
-/* ch_enlargebufs():
- *	Enlarge line buffer to be able to hold twice as much characters.
- *	Returns 1 if successful, 0 if not.
- */
-protected int
-ch_enlargebufs(el, addlen)
-	EditLine *el;
-	size_t addlen;
-{
-	size_t sz, newsz;
-	char *newbuffer, *oldbuf, *oldkbuf;
-
-	sz = el->el_line.limit - el->el_line.buffer + EL_LEAVE;
-	newsz = sz * 2;
-	/*
-	 * If newly required length is longer than current buffer, we need
-	 * to make the buffer big enough to hold both old and new stuff.
-	 */
-	if (addlen > sz) {
-		while(newsz - sz < addlen)
-			newsz *= 2;
-	}
-
-	/*
-	 * Reallocate line buffer.
-	 */
-	newbuffer = el_realloc(el->el_line.buffer, newsz);
-	if (!newbuffer)
-		return 0;
-
-	/* zero the newly added memory, leave old data in */
-	(void) memset(&newbuffer[sz], 0, newsz - sz);
-	    
-	oldbuf = el->el_line.buffer;
-
-	el->el_line.buffer = newbuffer;
-	el->el_line.cursor = newbuffer + (el->el_line.cursor - oldbuf);
-	el->el_line.lastchar = newbuffer + (el->el_line.lastchar - oldbuf);
-	/* don't set new size until all buffers are enlarged */
-	el->el_line.limit  = &newbuffer[sz - EL_LEAVE];
-
-	/*
-	 * Reallocate kill buffer.
-	 */
-	newbuffer = el_realloc(el->el_chared.c_kill.buf, newsz);
-	if (!newbuffer)
-		return 0;
-
-	/* zero the newly added memory, leave old data in */
-	(void) memset(&newbuffer[sz], 0, newsz - sz);
-
-	oldkbuf = el->el_chared.c_kill.buf;
-
-	el->el_chared.c_kill.buf = newbuffer;
-	el->el_chared.c_kill.last = newbuffer +
-					(el->el_chared.c_kill.last - oldkbuf);
-	el->el_chared.c_kill.mark = el->el_line.buffer +
-					(el->el_chared.c_kill.mark - oldbuf);
-
-	/*
-	 * Reallocate undo buffer.
-	 */
-	newbuffer = el_realloc(el->el_chared.c_undo.buf, newsz);
-	if (!newbuffer)
-		return 0;
-
-	/* zero the newly added memory, leave old data in */
-	(void) memset(&newbuffer[sz], 0, newsz - sz);
-	el->el_chared.c_undo.buf = newbuffer;
-
-	newbuffer = el_realloc(el->el_chared.c_redo.buf, newsz);
-	if (!newbuffer)
-		return 0;
-	el->el_chared.c_redo.pos = newbuffer +
-			(el->el_chared.c_redo.pos - el->el_chared.c_redo.buf);
-	el->el_chared.c_redo.lim = newbuffer +
-			(el->el_chared.c_redo.lim - el->el_chared.c_redo.buf);
-	el->el_chared.c_redo.buf = newbuffer;
-	
-	if (!hist_enlargebuf(el, sz, newsz))
-		return 0;
-
-	/* Safe to set enlarged buffer size */
-	el->el_line.limit  = &el->el_line.buffer[newsz - EL_LEAVE];
-	return 1;
-}
-
-/* ch_end():
- *	Free the data structures used by the editor
- */
-protected void
-ch_end(EditLine *el)
-{
-	el_free((ptr_t) el->el_line.buffer);
-	el->el_line.buffer = NULL;
-	el->el_line.limit = NULL;
-	el_free((ptr_t) el->el_chared.c_undo.buf);
-	el->el_chared.c_undo.buf = NULL;
-	el_free((ptr_t) el->el_chared.c_redo.buf);
-	el->el_chared.c_redo.buf = NULL;
-	el->el_chared.c_redo.pos = NULL;
-	el->el_chared.c_redo.lim = NULL;
-	el->el_chared.c_redo.cmd = ED_UNASSIGNED;
-	el_free((ptr_t) el->el_chared.c_kill.buf);
-	el->el_chared.c_kill.buf = NULL;
-	ch_reset(el, 1);
-	el_free((ptr_t) el->el_chared.c_macro.macro);
-	el->el_chared.c_macro.macro = NULL;
-}
-
-
-/* el_insertstr():
- *	Insert string at cursorI
- */
-public int
-el_insertstr(EditLine *el, const char *s)
-{
-	size_t len;
-
-	if ((len = strlen(s)) == 0)
-		return (-1);
-	if (el->el_line.lastchar + len >= el->el_line.limit) {
-		if (!ch_enlargebufs(el, len))
-			return (-1);
-	}
-
-	c_insert(el, (int)len);
-	while (*s)
-		*el->el_line.cursor++ = *s++;
-	return (0);
-}
-
-
-/* el_deletestr():
- *	Delete num characters before the cursor
- */
-public void
-el_deletestr(EditLine *el, int n)
-{
-	if (n <= 0)
-		return;
-
-	if (el->el_line.cursor < &el->el_line.buffer[n])
-		return;
-
-	c_delbefore(el, n);		/* delete before dot */
-	el->el_line.cursor -= n;
-	if (el->el_line.cursor < el->el_line.buffer)
-		el->el_line.cursor = el->el_line.buffer;
-}
-
-/* c_gets():
- *	Get a string
- */
-protected int
-c_gets(EditLine *el, char *buf, const char *prompt)
-{
-	char ch;
-	int len;
-	char *cp = el->el_line.buffer;
-
-	if (prompt) {
-		len = strlen(prompt);
-		memcpy(cp, prompt, len + 0u);
-		cp += len;
-	}
-	len = 0;
-
-	for (;;) {
-		el->el_line.cursor = cp;
-		*cp = ' ';
-		el->el_line.lastchar = cp + 1;
-		re_refresh(el);
-
-		if (el_getc(el, &ch) != 1) {
-			ed_end_of_file(el, 0);
-			len = -1;
-			break;
-		}
-
-		switch (ch) {
-
-		case 0010:	/* Delete and backspace */
-		case 0177:
-			if (len <= 0) {
-				len = -1;
-				break;
-			}
-			cp--;
-			continue;
-
-		case 0033:	/* ESC */
-		case '\r':	/* Newline */
-		case '\n':
-			buf[len] = ch;
-			break;
-
-		default:
-			if (len >= EL_BUFSIZ - 16)
-				term_beep(el);
-			else {
-				buf[len++] = ch;
-				*cp++ = ch;
-			}
-			continue;
-		}
-		break;
-	}
-
-	el->el_line.buffer[0] = '\0';
-	el->el_line.lastchar = el->el_line.buffer;
-	el->el_line.cursor = el->el_line.buffer;
-	return len;
-}
-
-
-/* c_hpos():
- *	Return the current horizontal position of the cursor
- */
-protected int
-c_hpos(EditLine *el)
-{
-	char *ptr;
-
-	/*
-	 * Find how many characters till the beginning of this line.
-	 */
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (0);
-	else {
-		for (ptr = el->el_line.cursor - 1;
-		     ptr >= el->el_line.buffer && *ptr != '\n';
-		     ptr--)
-			continue;
-		return (el->el_line.cursor - ptr - 1);
-	}
-}
diff --git a/libedit/chared.h b/libedit/chared.h
deleted file mode 100644
index b835959..0000000
--- a/libedit/chared.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*	$NetBSD: chared.h,v 1.16 2005/08/08 14:05:37 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)chared.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.chared.h: Character editor interface
- */
-#ifndef _h_el_chared
-#define	_h_el_chared
-
-#include <ctype.h>
-#include <string.h>
-
-#include "histedit.h"
-
-#define	EL_MAXMACRO	10
-
-/*
- * This is an issue of basic "vi" look-and-feel. Defining VI_MOVE works
- * like real vi: i.e. the transition from command<->insert modes moves
- * the cursor.
- *
- * On the other hand we really don't want to move the cursor, because
- * all the editing commands don't include the character under the cursor.
- * Probably the best fix is to make all the editing commands aware of
- * this fact.
- */
-#define	VI_MOVE
-
-
-typedef struct c_macro_t {
-	int	  level;
-	int	  offset;
-	char	**macro;
-} c_macro_t;
-
-/*
- * Undo information for vi - no undo in emacs (yet)
- */
-typedef struct c_undo_t {
-	int	 len;			/* length of saved line */
-	int	 cursor;		/* position of saved cursor */
-	char	*buf;			/* full saved text */
-} c_undo_t;
-
-/* redo for vi */
-typedef struct c_redo_t {
-	char	*buf;			/* redo insert key sequence */
-	char	*pos;
-	char	*lim;
-	el_action_t	cmd;		/* command to redo */
-	char	ch;			/* char that invoked it */
-	int	count;
-	int	action;			/* from cv_action() */
-} c_redo_t;
-
-/*
- * Current action information for vi
- */
-typedef struct c_vcmd_t {
-	int	 action;
-	char	*pos;
-} c_vcmd_t;
-
-/*
- * Kill buffer for emacs
- */
-typedef struct c_kill_t {
-	char	*buf;
-	char	*last;
-	char	*mark;
-} c_kill_t;
-
-/*
- * Note that we use both data structures because the user can bind
- * commands from both editors!
- */
-typedef struct el_chared_t {
-	c_undo_t	c_undo;
-	c_kill_t	c_kill;
-	c_redo_t	c_redo;
-	c_vcmd_t	c_vcmd;
-	c_macro_t	c_macro;
-} el_chared_t;
-
-
-#define	STReof		"^D\b\b"
-#define	STRQQ		"\"\""
-
-#define	isglob(a)	(strchr("*[]?", (a)) != NULL)
-#define	isword(a)	(isprint(a))
-
-#define	NOP		0x00
-#define	DELETE		0x01
-#define	INSERT		0x02
-#define	YANK		0x04
-
-#define	CHAR_FWD	(+1)
-#define	CHAR_BACK	(-1)
-
-#define	MODE_INSERT	0
-#define	MODE_REPLACE	1
-#define	MODE_REPLACE_1	2
-
-#include "common.h"
-#include "vi.h"
-#include "emacs.h"
-#include "search.h"
-#include "fcns.h"
-
-
-protected int	 cv__isword(int);
-protected int	 cv__isWord(int);
-protected void	 cv_delfini(EditLine *);
-protected char	*cv__endword(char *, char *, int, int (*)(int));
-protected int	 ce__isword(int);
-protected void	 cv_undo(EditLine *);
-protected void	 cv_yank(EditLine *, const char *, int);
-protected char	*cv_next_word(EditLine*, char *, char *, int, int (*)(int));
-protected char	*cv_prev_word(char *, char *, int, int (*)(int));
-protected char	*c__next_word(char *, char *, int, int (*)(int));
-protected char	*c__prev_word(char *, char *, int, int (*)(int));
-protected void	 c_insert(EditLine *, int);
-protected void	 c_delbefore(EditLine *, int);
-protected void	 c_delbefore1(EditLine *);
-protected void	 c_delafter(EditLine *, int);
-protected void	 c_delafter1(EditLine *);
-protected int	 c_gets(EditLine *, char *, const char *);
-protected int	 c_hpos(EditLine *);
-
-protected int	 ch_init(EditLine *);
-protected void	 ch_reset(EditLine *, int);
-protected int	 ch_enlargebufs(EditLine *, size_t);
-protected void	 ch_end(EditLine *);
-
-#endif /* _h_el_chared */
diff --git a/libedit/common.c b/libedit/common.c
deleted file mode 100644
index cf25228..0000000
--- a/libedit/common.c
+++ /dev/null
@@ -1,922 +0,0 @@
-/*	$NetBSD: common.c,v 1.18 2005/08/08 14:05:37 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)common.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: common.c,v 1.18 2005/08/08 14:05:37 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * common.c: Common Editor functions
- */
-#include "el.h"
-
-/* ed_end_of_file():
- *	Indicate end of file
- *	[^D]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_end_of_file(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	re_goto_bottom(el);
-	*el->el_line.lastchar = '\0';
-	return (CC_EOF);
-}
-
-
-/* ed_insert():
- *	Add character to the line
- *	Insert a character [bound to all insert keys]
- */
-protected el_action_t
-ed_insert(EditLine *el, int c)
-{
-	int count = el->el_state.argument;
-
-	if (c == '\0')
-		return (CC_ERROR);
-
-	if (el->el_line.lastchar + el->el_state.argument >=
-	    el->el_line.limit) {
-		/* end of buffer space, try to allocate more */
-		if (!ch_enlargebufs(el, (size_t) count))
-			return CC_ERROR;	/* error allocating more */
-	}
-
-	if (count == 1) {
-		if (el->el_state.inputmode == MODE_INSERT
-		    || el->el_line.cursor >= el->el_line.lastchar)
-			c_insert(el, 1);
-
-		*el->el_line.cursor++ = c;
-		re_fastaddc(el);		/* fast refresh for one char. */
-	} else {
-		if (el->el_state.inputmode != MODE_REPLACE_1)
-			c_insert(el, el->el_state.argument);
-
-		while (count-- && el->el_line.cursor < el->el_line.lastchar)
-			*el->el_line.cursor++ = c;
-		re_refresh(el);
-	}
-
-	if (el->el_state.inputmode == MODE_REPLACE_1)
-		return vi_command_mode(el, 0);
-
-	return (CC_NORM);
-}
-
-
-/* ed_delete_prev_word():
- *	Delete from beginning of current word to cursor
- *	[M-^?] [^W]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_delete_prev_word(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *cp, *p, *kp;
-
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (CC_ERROR);
-
-	cp = c__prev_word(el->el_line.cursor, el->el_line.buffer,
-	    el->el_state.argument, ce__isword);
-
-	for (p = cp, kp = el->el_chared.c_kill.buf; p < el->el_line.cursor; p++)
-		*kp++ = *p;
-	el->el_chared.c_kill.last = kp;
-
-	c_delbefore(el, el->el_line.cursor - cp);	/* delete before dot */
-	el->el_line.cursor = cp;
-	if (el->el_line.cursor < el->el_line.buffer)
-		el->el_line.cursor = el->el_line.buffer; /* bounds check */
-	return (CC_REFRESH);
-}
-
-
-/* ed_delete_next_char():
- *	Delete character under cursor
- *	[^D] [x]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_delete_next_char(EditLine *el, int c __attribute__((__unused__)))
-{
-#ifdef notdef			/* XXX */
-#define	EL	el->el_line
-	(void) fprintf(el->el_errlfile,
-	    "\nD(b: %x(%s)  c: %x(%s) last: %x(%s) limit: %x(%s)\n",
-	    EL.buffer, EL.buffer, EL.cursor, EL.cursor, EL.lastchar,
-	    EL.lastchar, EL.limit, EL.limit);
-#endif
-	if (el->el_line.cursor == el->el_line.lastchar) {
-			/* if I'm at the end */
-		if (el->el_map.type == MAP_VI) {
-			if (el->el_line.cursor == el->el_line.buffer) {
-				/* if I'm also at the beginning */
-#ifdef KSHVI
-				return (CC_ERROR);
-#else
-				term_overwrite(el, STReof, 4);
-					/* then do an EOF */
-				term__flush();
-				return (CC_EOF);
-#endif
-			} else {
-#ifdef KSHVI
-				el->el_line.cursor--;
-#else
-				return (CC_ERROR);
-#endif
-			}
-		} else {
-			if (el->el_line.cursor != el->el_line.buffer)
-				el->el_line.cursor--;
-			else
-				return (CC_ERROR);
-		}
-	}
-	c_delafter(el, el->el_state.argument);	/* delete after dot */
-	if (el->el_line.cursor >= el->el_line.lastchar &&
-	    el->el_line.cursor > el->el_line.buffer)
-			/* bounds check */
-		el->el_line.cursor = el->el_line.lastchar - 1;
-	return (CC_REFRESH);
-}
-
-
-/* ed_kill_line():
- *	Cut to the end of line
- *	[^K] [^K]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_kill_line(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *kp, *cp;
-
-	cp = el->el_line.cursor;
-	kp = el->el_chared.c_kill.buf;
-	while (cp < el->el_line.lastchar)
-		*kp++ = *cp++;	/* copy it */
-	el->el_chared.c_kill.last = kp;
-			/* zap! -- delete to end */
-	el->el_line.lastchar = el->el_line.cursor;
-	return (CC_REFRESH);
-}
-
-
-/* ed_move_to_end():
- *	Move cursor to the end of line
- *	[^E] [^E]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_move_to_end(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_line.cursor = el->el_line.lastchar;
-	if (el->el_map.type == MAP_VI) {
-#ifdef VI_MOVE
-		el->el_line.cursor--;
-#endif
-		if (el->el_chared.c_vcmd.action != NOP) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	}
-	return (CC_CURSOR);
-}
-
-
-/* ed_move_to_beg():
- *	Move cursor to the beginning of line
- *	[^A] [^A]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_move_to_beg(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_line.cursor = el->el_line.buffer;
-
-	if (el->el_map.type == MAP_VI) {
-			/* We want FIRST non space character */
-		while (isspace((unsigned char) *el->el_line.cursor))
-			el->el_line.cursor++;
-		if (el->el_chared.c_vcmd.action != NOP) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	}
-	return (CC_CURSOR);
-}
-
-
-/* ed_transpose_chars():
- *	Exchange the character to the left of the cursor with the one under it
- *	[^T] [^T]
- */
-protected el_action_t
-ed_transpose_chars(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor < el->el_line.lastchar) {
-		if (el->el_line.lastchar <= &el->el_line.buffer[1])
-			return (CC_ERROR);
-		else
-			el->el_line.cursor++;
-	}
-	if (el->el_line.cursor > &el->el_line.buffer[1]) {
-		/* must have at least two chars entered */
-		c = el->el_line.cursor[-2];
-		el->el_line.cursor[-2] = el->el_line.cursor[-1];
-		el->el_line.cursor[-1] = c;
-		return (CC_REFRESH);
-	} else
-		return (CC_ERROR);
-}
-
-
-/* ed_next_char():
- *	Move to the right one character
- *	[^F] [^F]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_next_char(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *lim = el->el_line.lastchar;
-
-	if (el->el_line.cursor >= lim ||
-	    (el->el_line.cursor == lim - 1 &&
-	    el->el_map.type == MAP_VI &&
-	    el->el_chared.c_vcmd.action == NOP))
-		return (CC_ERROR);
-
-	el->el_line.cursor += el->el_state.argument;
-	if (el->el_line.cursor > lim)
-		el->el_line.cursor = lim;
-
-	if (el->el_map.type == MAP_VI)
-		if (el->el_chared.c_vcmd.action != NOP) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	return (CC_CURSOR);
-}
-
-
-/* ed_prev_word():
- *	Move to the beginning of the current word
- *	[M-b] [b]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_prev_word(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (CC_ERROR);
-
-	el->el_line.cursor = c__prev_word(el->el_line.cursor,
-	    el->el_line.buffer,
-	    el->el_state.argument,
-	    ce__isword);
-
-	if (el->el_map.type == MAP_VI)
-		if (el->el_chared.c_vcmd.action != NOP) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	return (CC_CURSOR);
-}
-
-
-/* ed_prev_char():
- *	Move to the left one character
- *	[^B] [^B]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_prev_char(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor > el->el_line.buffer) {
-		el->el_line.cursor -= el->el_state.argument;
-		if (el->el_line.cursor < el->el_line.buffer)
-			el->el_line.cursor = el->el_line.buffer;
-
-		if (el->el_map.type == MAP_VI)
-			if (el->el_chared.c_vcmd.action != NOP) {
-				cv_delfini(el);
-				return (CC_REFRESH);
-			}
-		return (CC_CURSOR);
-	} else
-		return (CC_ERROR);
-}
-
-
-/* ed_quoted_insert():
- *	Add the next character typed verbatim
- *	[^V] [^V]
- */
-protected el_action_t
-ed_quoted_insert(EditLine *el, int c)
-{
-	int num;
-	char tc;
-
-	tty_quotemode(el);
-	num = el_getc(el, &tc);
-	c = (unsigned char) tc;
-	tty_noquotemode(el);
-	if (num == 1)
-		return (ed_insert(el, c));
-	else
-		return (ed_end_of_file(el, 0));
-}
-
-
-/* ed_digit():
- *	Adds to argument or enters a digit
- */
-protected el_action_t
-ed_digit(EditLine *el, int c)
-{
-
-	if (!isdigit(c))
-		return (CC_ERROR);
-
-	if (el->el_state.doingarg) {
-			/* if doing an arg, add this in... */
-		if (el->el_state.lastcmd == EM_UNIVERSAL_ARGUMENT)
-			el->el_state.argument = c - '0';
-		else {
-			if (el->el_state.argument > 1000000)
-				return (CC_ERROR);
-			el->el_state.argument =
-			    (el->el_state.argument * 10) + (c - '0');
-		}
-		return (CC_ARGHACK);
-	}
-
-	return ed_insert(el, c);
-}
-
-
-/* ed_argument_digit():
- *	Digit that starts argument
- *	For ESC-n
- */
-protected el_action_t
-ed_argument_digit(EditLine *el, int c)
-{
-
-	if (!isdigit(c))
-		return (CC_ERROR);
-
-	if (el->el_state.doingarg) {
-		if (el->el_state.argument > 1000000)
-			return (CC_ERROR);
-		el->el_state.argument = (el->el_state.argument * 10) +
-		    (c - '0');
-	} else {		/* else starting an argument */
-		el->el_state.argument = c - '0';
-		el->el_state.doingarg = 1;
-	}
-	return (CC_ARGHACK);
-}
-
-
-/* ed_unassigned():
- *	Indicates unbound character
- *	Bound to keys that are not assigned
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_unassigned(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	return (CC_ERROR);
-}
-
-
-/**
- ** TTY key handling.
- **/
-
-/* ed_tty_sigint():
- *	Tty interrupt character
- *	[^C]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_sigint(EditLine *el __attribute__((__unused__)), 
-	      int c __attribute__((__unused__)))
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_dsusp():
- *	Tty delayed suspend character
- *	[^Y]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_dsusp(EditLine *el __attribute__((__unused__)), 
-	     int c __attribute__((__unused__)))
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_flush_output():
- *	Tty flush output characters
- *	[^O]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_flush_output(EditLine *el __attribute__((__unused__)), 
-		    int c __attribute__((__unused__)))
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_sigquit():
- *	Tty quit character
- *	[^\]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_sigquit(EditLine *el __attribute__((__unused__)), 
-	       int c __attribute__((__unused__)))
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_sigtstp():
- *	Tty suspend character
- *	[^Z]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_sigtstp(EditLine *el __attribute__((__unused__)), 
-	       int c __attribute__((__unused__)))
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_stop_output():
- *	Tty disallow output characters
- *	[^S]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_stop_output(EditLine *el __attribute__((__unused__)), 
-		   int c __attribute__((__unused__)))
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_tty_start_output():
- *	Tty allow output characters
- *	[^Q]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_tty_start_output(EditLine *el __attribute__((__unused__)), 
-		    int c __attribute__((__unused__)))
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_newline():
- *	Execute command
- *	[^J]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_newline(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	re_goto_bottom(el);
-	*el->el_line.lastchar++ = '\n';
-	*el->el_line.lastchar = '\0';
-	return (CC_NEWLINE);
-}
-
-
-/* ed_delete_prev_char():
- *	Delete the character to the left of the cursor
- *	[^?]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_delete_prev_char(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor <= el->el_line.buffer)
-		return (CC_ERROR);
-
-	c_delbefore(el, el->el_state.argument);
-	el->el_line.cursor -= el->el_state.argument;
-	if (el->el_line.cursor < el->el_line.buffer)
-		el->el_line.cursor = el->el_line.buffer;
-	return (CC_REFRESH);
-}
-
-
-/* ed_clear_screen():
- *	Clear screen leaving current line at the top
- *	[^L]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_clear_screen(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	term_clear_screen(el);	/* clear the whole real screen */
-	re_clear_display(el);	/* reset everything */
-	return (CC_REFRESH);
-}
-
-
-/* ed_redisplay():
- *	Redisplay everything
- *	^R
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_redisplay(EditLine *el __attribute__((__unused__)), 
-	     int c __attribute__((__unused__)))
-{
-
-	return (CC_REDISPLAY);
-}
-
-
-/* ed_start_over():
- *	Erase current line and start from scratch
- *	[^G]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_start_over(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	ch_reset(el, 0);
-	return (CC_REFRESH);
-}
-
-
-/* ed_sequence_lead_in():
- *	First character in a bound sequence
- *	Placeholder for external keys
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_sequence_lead_in(EditLine *el __attribute__((__unused__)), 
-		    int c __attribute__((__unused__)))
-{
-
-	return (CC_NORM);
-}
-
-
-/* ed_prev_history():
- *	Move to the previous history line
- *	[^P] [k]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_prev_history(EditLine *el, int c __attribute__((__unused__)))
-{
-	char beep = 0;
-	int sv_event = el->el_history.eventno;
-
-	el->el_chared.c_undo.len = -1;
-	*el->el_line.lastchar = '\0';		/* just in case */
-
-	if (el->el_history.eventno == 0) {	/* save the current buffer
-						 * away */
-		(void) strncpy(el->el_history.buf, el->el_line.buffer,
-		    EL_BUFSIZ);
-		el->el_history.last = el->el_history.buf +
-		    (el->el_line.lastchar - el->el_line.buffer);
-	}
-	el->el_history.eventno += el->el_state.argument;
-
-	if (hist_get(el) == CC_ERROR) {
-		if (el->el_map.type == MAP_VI) {
-			el->el_history.eventno = sv_event;
-			return CC_ERROR;
-		}
-		beep = 1;
-		/* el->el_history.eventno was fixed by first call */
-		(void) hist_get(el);
-	}
-	if (beep)
-		return CC_REFRESH_BEEP;
-	return CC_REFRESH;
-}
-
-
-/* ed_next_history():
- *	Move to the next history line
- *	[^N] [j]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_next_history(EditLine *el, int c __attribute__((__unused__)))
-{
-	el_action_t beep = CC_REFRESH, rval;
-
-	el->el_chared.c_undo.len = -1;
-	*el->el_line.lastchar = '\0';	/* just in case */
-
-	el->el_history.eventno -= el->el_state.argument;
-
-	if (el->el_history.eventno < 0) {
-		el->el_history.eventno = 0;
-		beep = CC_REFRESH_BEEP;
-	}
-	rval = hist_get(el);
-	if (rval == CC_REFRESH)
-		return beep;
-	return rval;
-
-}
-
-
-/* ed_search_prev_history():
- *	Search previous in history for a line matching the current
- *	next search history [M-P] [K]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_search_prev_history(EditLine *el, int c __attribute__((__unused__)))
-{
-	const char *hp;
-	int h;
-	bool_t found = 0;
-
-	el->el_chared.c_vcmd.action = NOP;
-	el->el_chared.c_undo.len = -1;
-	*el->el_line.lastchar = '\0';	/* just in case */
-	if (el->el_history.eventno < 0) {
-#ifdef DEBUG_EDIT
-		(void) fprintf(el->el_errfile,
-		    "e_prev_search_hist(): eventno < 0;\n");
-#endif
-		el->el_history.eventno = 0;
-		return (CC_ERROR);
-	}
-	if (el->el_history.eventno == 0) {
-		(void) strncpy(el->el_history.buf, el->el_line.buffer,
-		    EL_BUFSIZ);
-		el->el_history.last = el->el_history.buf +
-		    (el->el_line.lastchar - el->el_line.buffer);
-	}
-	if (el->el_history.ref == NULL)
-		return (CC_ERROR);
-
-	hp = HIST_FIRST(el);
-	if (hp == NULL)
-		return (CC_ERROR);
-
-	c_setpat(el);		/* Set search pattern !! */
-
-	for (h = 1; h <= el->el_history.eventno; h++)
-		hp = HIST_NEXT(el);
-
-	while (hp != NULL) {
-#ifdef SDEBUG
-		(void) fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
-#endif
-		if ((strncmp(hp, el->el_line.buffer, (size_t)
-			    (el->el_line.lastchar - el->el_line.buffer)) ||
-			hp[el->el_line.lastchar - el->el_line.buffer]) &&
-		    c_hmatch(el, hp)) {
-			found++;
-			break;
-		}
-		h++;
-		hp = HIST_NEXT(el);
-	}
-
-	if (!found) {
-#ifdef SDEBUG
-		(void) fprintf(el->el_errfile, "not found\n");
-#endif
-		return (CC_ERROR);
-	}
-	el->el_history.eventno = h;
-
-	return (hist_get(el));
-}
-
-
-/* ed_search_next_history():
- *	Search next in history for a line matching the current
- *	[M-N] [J]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_search_next_history(EditLine *el, int c __attribute__((__unused__)))
-{
-	const char *hp;
-	int h;
-	bool_t found = 0;
-
-	el->el_chared.c_vcmd.action = NOP;
-	el->el_chared.c_undo.len = -1;
-	*el->el_line.lastchar = '\0';	/* just in case */
-
-	if (el->el_history.eventno == 0)
-		return (CC_ERROR);
-
-	if (el->el_history.ref == NULL)
-		return (CC_ERROR);
-
-	hp = HIST_FIRST(el);
-	if (hp == NULL)
-		return (CC_ERROR);
-
-	c_setpat(el);		/* Set search pattern !! */
-
-	for (h = 1; h < el->el_history.eventno && hp; h++) {
-#ifdef SDEBUG
-		(void) fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
-#endif
-		if ((strncmp(hp, el->el_line.buffer, (size_t)
-			    (el->el_line.lastchar - el->el_line.buffer)) ||
-			hp[el->el_line.lastchar - el->el_line.buffer]) &&
-		    c_hmatch(el, hp))
-			found = h;
-		hp = HIST_NEXT(el);
-	}
-
-	if (!found) {		/* is it the current history number? */
-		if (!c_hmatch(el, el->el_history.buf)) {
-#ifdef SDEBUG
-			(void) fprintf(el->el_errfile, "not found\n");
-#endif
-			return (CC_ERROR);
-		}
-	}
-	el->el_history.eventno = found;
-
-	return (hist_get(el));
-}
-
-
-/* ed_prev_line():
- *	Move up one line
- *	Could be [k] [^p]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_prev_line(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *ptr;
-	int nchars = c_hpos(el);
-
-	/*
-         * Move to the line requested
-         */
-	if (*(ptr = el->el_line.cursor) == '\n')
-		ptr--;
-
-	for (; ptr >= el->el_line.buffer; ptr--)
-		if (*ptr == '\n' && --el->el_state.argument <= 0)
-			break;
-
-	if (el->el_state.argument > 0)
-		return (CC_ERROR);
-
-	/*
-         * Move to the beginning of the line
-         */
-	for (ptr--; ptr >= el->el_line.buffer && *ptr != '\n'; ptr--)
-		continue;
-
-	/*
-         * Move to the character requested
-         */
-	for (ptr++;
-	    nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n';
-	    ptr++)
-		continue;
-
-	el->el_line.cursor = ptr;
-	return (CC_CURSOR);
-}
-
-
-/* ed_next_line():
- *	Move down one line
- *	Could be [j] [^n]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_next_line(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *ptr;
-	int nchars = c_hpos(el);
-
-	/*
-         * Move to the line requested
-         */
-	for (ptr = el->el_line.cursor; ptr < el->el_line.lastchar; ptr++)
-		if (*ptr == '\n' && --el->el_state.argument <= 0)
-			break;
-
-	if (el->el_state.argument > 0)
-		return (CC_ERROR);
-
-	/*
-         * Move to the character requested
-         */
-	for (ptr++;
-	    nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n';
-	    ptr++)
-		continue;
-
-	el->el_line.cursor = ptr;
-	return (CC_CURSOR);
-}
-
-
-/* ed_command():
- *	Editline extended command
- *	[M-X] [:]
- */
-protected el_action_t
-/*ARGSUSED*/
-ed_command(EditLine *el, int c __attribute__((__unused__)))
-{
-	char tmpbuf[EL_BUFSIZ];
-	int tmplen;
-
-	tmplen = c_gets(el, tmpbuf, "\n: ");
-	term__putc('\n');
-
-	if (tmplen < 0 || (tmpbuf[tmplen] = 0, parse_line(el, tmpbuf)) == -1)
-		term_beep(el);
-
-	el->el_map.current = el->el_map.key;
-	re_clear_display(el);
-	return CC_REFRESH;
-}
diff --git a/libedit/editline/readline.h b/libedit/editline/readline.h
deleted file mode 100644
index d578d5d..0000000
--- a/libedit/editline/readline.h
+++ /dev/null
@@ -1,197 +0,0 @@
-/*	$NetBSD: readline.h,v 1.17 2005/07/14 15:00:58 christos Exp $	*/
-
-/*-
- * Copyright (c) 1997 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Jaromir Dolecek.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the NetBSD
- *	Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _READLINE_H_
-#define _READLINE_H_
-
-#include <sys/types.h>
-
-/* list of readline stuff supported by editline library's readline wrapper */
-
-/* typedefs */
-typedef int	  Function(const char *, int);
-typedef void	  VFunction(void);
-typedef void	  VCPFunction(char *);
-typedef char	 *CPFunction(const char *, int);
-typedef char	**CPPFunction(const char *, int, int);
-
-typedef void *histdata_t;
-
-typedef struct _hist_entry {
-	const char	*line;
-	histdata_t	*data;
-} HIST_ENTRY;
-
-typedef struct _keymap_entry {
-	char type;
-#define ISFUNC	0
-#define ISKMAP	1
-#define ISMACR	2
-	Function *function;
-} KEYMAP_ENTRY;
-
-#define KEYMAP_SIZE	256
-
-typedef KEYMAP_ENTRY KEYMAP_ENTRY_ARRAY[KEYMAP_SIZE];
-typedef KEYMAP_ENTRY *Keymap;
-
-#define control_character_threshold	0x20
-#define control_character_bit		0x40
-
-#ifndef CTRL
-#include <sys/ioctl.h>
-#ifdef __GLIBC__
-#include <sys/ttydefaults.h>
-#endif
-#ifndef CTRL
-#define CTRL(c)		((c) & 037)
-#endif
-#endif
-#ifndef UNCTRL
-#define UNCTRL(c)	(((c) - 'a' + 'A')|control_character_bit)
-#endif
-
-#define RUBOUT		0x7f
-#define ABORT_CHAR	CTRL('G')
-
-/* global variables used by readline enabled applications */
-#ifdef __cplusplus
-extern "C" {
-#endif
-extern const char	*rl_library_version;
-extern char		*rl_readline_name;
-extern FILE		*rl_instream;
-extern FILE		*rl_outstream;
-extern char		*rl_line_buffer;
-extern int		 rl_point, rl_end;
-extern int		 history_base, history_length;
-extern int		 max_input_history;
-extern char		*rl_basic_word_break_characters;
-extern char		*rl_completer_word_break_characters;
-extern char		*rl_completer_quote_characters;
-extern Function		*rl_completion_entry_function;
-extern CPPFunction	*rl_attempted_completion_function;
-extern int		 rl_attempted_completion_over;
-extern int		rl_completion_type;
-extern int		rl_completion_query_items;
-extern char		*rl_special_prefixes;
-extern int		rl_completion_append_character;
-extern int		rl_inhibit_completion;
-extern Function		*rl_pre_input_hook;
-extern Function		*rl_startup_hook;
-extern char		*rl_terminal_name;
-extern int		rl_already_prompted;
-extern char		*rl_prompt;
-/*
- * The following is not implemented
- */
-extern KEYMAP_ENTRY_ARRAY emacs_standard_keymap,
-			emacs_meta_keymap,
-			emacs_ctlx_keymap;
-extern int		rl_filename_completion_desired;
-extern int		rl_ignore_completion_duplicates;
-extern Function		*rl_getc_function;
-extern VFunction	*rl_redisplay_function;
-extern VFunction	*rl_completion_display_matches_hook;
-extern VFunction	*rl_prep_term_function;
-extern VFunction	*rl_deprep_term_function;
-
-/* supported functions */
-char		*readline(const char *);
-int		 rl_initialize(void);
-
-void		 using_history(void);
-int		 add_history(const char *);
-void		 clear_history(void);
-void		 stifle_history(int);
-int		 unstifle_history(void);
-int		 history_is_stifled(void);
-int		 where_history(void);
-HIST_ENTRY	*current_history(void);
-HIST_ENTRY	*history_get(int);
-HIST_ENTRY	*remove_history(int);
-int		 history_total_bytes(void);
-int		 history_set_pos(int);
-HIST_ENTRY	*previous_history(void);
-HIST_ENTRY	*next_history(void);
-int		 history_search(const char *, int);
-int		 history_search_prefix(const char *, int);
-int		 history_search_pos(const char *, int, int);
-int		 read_history(const char *);
-int		 write_history(const char *);
-int		 history_expand(char *, char **);
-char	       **history_tokenize(const char *);
-const char	*get_history_event(const char *, int *, int);
-char		*history_arg_extract(int, int, const char *);
-
-char		*tilde_expand(char *);
-char		*filename_completion_function(const char *, int);
-char		*username_completion_function(const char *, int);
-int		 rl_complete(int, int);
-int		 rl_read_key(void);
-char	       **completion_matches(const char *, CPFunction *);
-void		 rl_display_match_list(char **, int, int);
-
-int		 rl_insert(int, int);
-void		 rl_reset_terminal(const char *);
-int		 rl_bind_key(int, int (*)(int, int));
-int		 rl_newline(int, int);
-void		 rl_callback_read_char(void);
-void		 rl_callback_handler_install(const char *, VCPFunction *);
-void		 rl_callback_handler_remove(void);
-void		 rl_redisplay(void);
-int		 rl_get_previous_history(int, int);
-void		 rl_prep_terminal(int);
-void		 rl_deprep_terminal(void);
-int		 rl_read_init_file(const char *);
-int		 rl_parse_and_bind(const char *);
-int		 rl_variable_bind(const char *, const char *);
-void		 rl_stuff_char(int);
-int		 rl_add_defun(const char *, Function *, int);
-
-/*
- * The following are not implemented
- */
-Keymap		 rl_get_keymap(void);
-Keymap		 rl_make_bare_keymap(void);
-int		 rl_generic_bind(int, const char *, const char *, Keymap);
-int		 rl_bind_key_in_map(int, Function *, Keymap);
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _READLINE_H_ */
diff --git a/libedit/el.c b/libedit/el.c
deleted file mode 100644
index 298b24a..0000000
--- a/libedit/el.c
+++ /dev/null
@@ -1,534 +0,0 @@
-/*	$NetBSD: el.c,v 1.41 2005/08/19 04:21:47 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)el.c	8.2 (Berkeley) 1/3/94";
-#else
-__RCSID("$NetBSD: el.c,v 1.41 2005/08/19 04:21:47 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * el.c: EditLine interface functions
- */
-#include <sys/types.h>
-#include <sys/param.h>
-#include <string.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include "el.h"
-
-/* el_init():
- *	Initialize editline and set default parameters.
- */
-public EditLine *
-el_init(const char *prog, FILE *fin, FILE *fout, FILE *ferr)
-{
-
-	EditLine *el = (EditLine *) el_malloc(sizeof(EditLine));
-
-	if (el == NULL)
-		return (NULL);
-
-	memset(el, 0, sizeof(EditLine));
-
-	el->el_infd = fileno(fin);
-	el->el_outfile = fout;
-	el->el_errfile = ferr;
-	if ((el->el_prog = el_strdup(prog)) == NULL) {
-		el_free(el);
-		return NULL;
-	}
-
-	/*
-         * Initialize all the modules. Order is important!!!
-         */
-	el->el_flags = 0;
-
-	if (term_init(el) == -1) {
-		el_free(el->el_prog);
-		el_free(el);
-		return NULL;
-	}
-	(void) key_init(el);
-	(void) map_init(el);
-	if (tty_init(el) == -1)
-		el->el_flags |= NO_TTY;
-	(void) ch_init(el);
-	(void) search_init(el);
-	(void) hist_init(el);
-	(void) prompt_init(el);
-	(void) sig_init(el);
-	(void) read_init(el);
-
-	return (el);
-}
-
-
-/* el_end():
- *	Clean up.
- */
-public void
-el_end(EditLine *el)
-{
-
-	if (el == NULL)
-		return;
-
-	el_reset(el);
-
-	term_end(el);
-	key_end(el);
-	map_end(el);
-	tty_end(el);
-	ch_end(el);
-	search_end(el);
-	hist_end(el);
-	prompt_end(el);
-	sig_end(el);
-
-	el_free((ptr_t) el->el_prog);
-	el_free((ptr_t) el);
-}
-
-
-/* el_reset():
- *	Reset the tty and the parser
- */
-public void
-el_reset(EditLine *el)
-{
-
-	tty_cookedmode(el);
-	ch_reset(el, 0);		/* XXX: Do we want that? */
-}
-
-
-/* el_set():
- *	set the editline parameters
- */
-public int
-el_set(EditLine *el, int op, ...)
-{
-	va_list va;
-	int rv = 0;
-
-	if (el == NULL)
-		return (-1);
-	va_start(va, op);
-
-	switch (op) {
-	case EL_PROMPT:
-	case EL_RPROMPT:
-		rv = prompt_set(el, va_arg(va, el_pfunc_t), op);
-		break;
-
-	case EL_TERMINAL:
-		rv = term_set(el, va_arg(va, char *));
-		break;
-
-	case EL_EDITOR:
-		rv = map_set_editor(el, va_arg(va, char *));
-		break;
-
-	case EL_SIGNAL:
-		if (va_arg(va, int))
-			el->el_flags |= HANDLE_SIGNALS;
-		else
-			el->el_flags &= ~HANDLE_SIGNALS;
-		break;
-
-	case EL_BIND:
-	case EL_TELLTC:
-	case EL_SETTC:
-	case EL_ECHOTC:
-	case EL_SETTY:
-	{
-		const char *argv[20];
-		int i;
-
-		for (i = 1; i < 20; i++)
-			if ((argv[i] = va_arg(va, char *)) == NULL)
-				break;
-
-		switch (op) {
-		case EL_BIND:
-			argv[0] = "bind";
-			rv = map_bind(el, i, argv);
-			break;
-
-		case EL_TELLTC:
-			argv[0] = "telltc";
-			rv = term_telltc(el, i, argv);
-			break;
-
-		case EL_SETTC:
-			argv[0] = "settc";
-			rv = term_settc(el, i, argv);
-			break;
-
-		case EL_ECHOTC:
-			argv[0] = "echotc";
-			rv = term_echotc(el, i, argv);
-			break;
-
-		case EL_SETTY:
-			argv[0] = "setty";
-			rv = tty_stty(el, i, argv);
-			break;
-
-		default:
-			rv = -1;
-			EL_ABORT((el->el_errfile, "Bad op %d\n", op));
-			break;
-		}
-		break;
-	}
-
-	case EL_ADDFN:
-	{
-		char *name = va_arg(va, char *);
-		char *help = va_arg(va, char *);
-		el_func_t func = va_arg(va, el_func_t);
-
-		rv = map_addfunc(el, name, help, func);
-		break;
-	}
-
-	case EL_HIST:
-	{
-		hist_fun_t func = va_arg(va, hist_fun_t);
-		ptr_t ptr = va_arg(va, char *);
-
-		rv = hist_set(el, func, ptr);
-		break;
-	}
-
-	case EL_EDITMODE:
-		if (va_arg(va, int))
-			el->el_flags &= ~EDIT_DISABLED;
-		else
-			el->el_flags |= EDIT_DISABLED;
-		rv = 0;
-		break;
-
-	case EL_GETCFN:
-	{
-		el_rfunc_t rc = va_arg(va, el_rfunc_t);
-		rv = el_read_setfn(el, rc);
-		break;
-	}
-
-	case EL_CLIENTDATA:
-		el->el_data = va_arg(va, void *);
-		break;
-
-	case EL_UNBUFFERED:
-		rv = va_arg(va, int);
-		if (rv && !(el->el_flags & UNBUFFERED)) {
-			el->el_flags |= UNBUFFERED;
-			read_prepare(el);
-		} else if (!rv && (el->el_flags & UNBUFFERED)) {
-			el->el_flags &= ~UNBUFFERED;
-			read_finish(el);
-		}
-		rv = 0;
-		break;
-
-	case EL_PREP_TERM:
-		rv = va_arg(va, int);
-		if (rv)
-			(void) tty_rawmode(el);
-		else
-			(void) tty_cookedmode(el);
-		rv = 0;
-		break;
-
-	default:
-		rv = -1;
-		break;
-	}
-
-	va_end(va);
-	return (rv);
-}
-
-
-/* el_get():
- *	retrieve the editline parameters
- */
-public int
-el_get(EditLine *el, int op, void *ret)
-{
-	int rv;
-
-	if (el == NULL || ret == NULL)
-		return (-1);
-	switch (op) {
-	case EL_PROMPT:
-	case EL_RPROMPT:
-		rv = prompt_get(el, (el_pfunc_t *) ret, op);
-		break;
-
-	case EL_EDITOR:
-		rv = map_get_editor(el, (const char **)ret);
-		break;
-
-	case EL_SIGNAL:
-		*((int *) ret) = (el->el_flags & HANDLE_SIGNALS);
-		rv = 0;
-		break;
-
-	case EL_EDITMODE:
-		*((int *) ret) = (!(el->el_flags & EDIT_DISABLED));
-		rv = 0;
-		break;
-
-	case EL_TERMINAL:
-		term_get(el, (const char **)ret);
-		rv = 0;
-		break;
-
-#if 0				/* XXX */
-	case EL_BIND:
-	case EL_TELLTC:
-	case EL_SETTC:
-	case EL_ECHOTC:
-	case EL_SETTY:
-	{
-		const char *argv[20];
-		int i;
-
- 		for (i = 1; i < sizeof(argv) / sizeof(argv[0]); i++)
-			if ((argv[i] = va_arg(va, char *)) == NULL)
-				break;
-
-		switch (op) {
-		case EL_BIND:
-			argv[0] = "bind";
-			rv = map_bind(el, i, argv);
-			break;
-
-		case EL_TELLTC:
-			argv[0] = "telltc";
-			rv = term_telltc(el, i, argv);
-			break;
-
-		case EL_SETTC:
-			argv[0] = "settc";
-			rv = term_settc(el, i, argv);
-			break;
-
-		case EL_ECHOTC:
-			argv[0] = "echotc";
-			rv = term_echotc(el, i, argv);
-			break;
-
-		case EL_SETTY:
-			argv[0] = "setty";
-			rv = tty_stty(el, i, argv);
-			break;
-
-		default:
-			rv = -1;
-			EL_ABORT((el->errfile, "Bad op %d\n", op));
-			break;
-		}
-		break;
-	}
-
-	case EL_ADDFN:
-	{
-		char *name = va_arg(va, char *);
-		char *help = va_arg(va, char *);
-		el_func_t func = va_arg(va, el_func_t);
-
-		rv = map_addfunc(el, name, help, func);
-		break;
-	}
-
-	case EL_HIST:
-		{
-			hist_fun_t func = va_arg(va, hist_fun_t);
-			ptr_t ptr = va_arg(va, char *);
-			rv = hist_set(el, func, ptr);
-		}
-		break;
-#endif /* XXX */
-
-	case EL_GETCFN:
-		*((el_rfunc_t *)ret) = el_read_getfn(el);
-		rv = 0;
-		break;
-
-	case EL_CLIENTDATA:
-		*((void **)ret) = el->el_data;
-		rv = 0;
-		break;
-
-	case EL_UNBUFFERED:
-		*((int *) ret) = (!(el->el_flags & UNBUFFERED));
-		rv = 0;
-		break;
-
-	default:
-		rv = -1;
-	}
-
-	return (rv);
-}
-
-
-/* el_line():
- *	Return editing info
- */
-public const LineInfo *
-el_line(EditLine *el)
-{
-
-	return (const LineInfo *) (void *) &el->el_line;
-}
-
-
-/* el_source():
- *	Source a file
- */
-public int
-el_source(EditLine *el, const char *fname)
-{
-	FILE *fp;
-	size_t len;
-	char *ptr;
-
-	fp = NULL;
-	if (fname == NULL) {
-		static const char elpath[] = "/.editrc";
-#ifdef MAXPATHLEN
-		char path[MAXPATHLEN];
-#else
-		char path[4096];
-#endif
-
-#ifdef HAVE_ISSETUGID
-		if (issetugid())
-			return (-1);
-#endif
-		if ((ptr = getenv("HOME")) == NULL)
-			return (-1);
-		if (strlcpy(path, ptr, sizeof(path)) >= sizeof(path))
-			return (-1);
-		if (strlcat(path, elpath, sizeof(path)) >= sizeof(path))
-			return (-1);
-		fname = path;
-	}
-	if (fp == NULL)
-		fp = fopen(fname, "r");
-	if (fp == NULL)
-		return (-1);
-
-	while ((ptr = fgetln(fp, &len)) != NULL) {
-		if (len > 0 && ptr[len - 1] == '\n')
-			--len;
-		ptr[len] = '\0';
-		if (parse_line(el, ptr) == -1) {
-			(void) fclose(fp);
-			return (-1);
-		}
-	}
-
-	(void) fclose(fp);
-	return (0);
-}
-
-
-/* el_resize():
- *	Called from program when terminal is resized
- */
-public void
-el_resize(EditLine *el)
-{
-	int lins, cols;
-	sigset_t oset, nset;
-
-	(void) sigemptyset(&nset);
-	(void) sigaddset(&nset, SIGWINCH);
-	(void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-	/* get the correct window size */
-	if (term_get_size(el, &lins, &cols))
-		term_change_size(el, lins, cols);
-
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-}
-
-
-/* el_beep():
- *	Called from the program to beep
- */
-public void
-el_beep(EditLine *el)
-{
-
-	term_beep(el);
-}
-
-
-/* el_editmode()
- *	Set the state of EDIT_DISABLED from the `edit' command.
- */
-protected int
-/*ARGSUSED*/
-el_editmode(EditLine *el, int argc, const char **argv)
-{
-	const char *how;
-
-	if (argv == NULL || argc != 2 || argv[1] == NULL)
-		return (-1);
-
-	how = argv[1];
-	if (strcmp(how, "on") == 0) {
-		el->el_flags &= ~EDIT_DISABLED;
-		tty_rawmode(el);
-	} else if (strcmp(how, "off") == 0) {
-		tty_cookedmode(el);
-		el->el_flags |= EDIT_DISABLED;
-	}
-	else {
-		(void) fprintf(el->el_errfile, "edit: Bad value `%s'.\n", how);
-		return (-1);
-	}
-	return (0);
-}
diff --git a/libedit/el.h b/libedit/el.h
deleted file mode 100644
index c4b6cff..0000000
--- a/libedit/el.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/*	$NetBSD: el.h,v 1.16 2003/10/18 23:48:42 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)el.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.h: Internal structures.
- */
-#ifndef _h_el
-#define	_h_el
-/*
- * Local defaults
- */
-#define	KSHVI
-#define	VIDEFAULT
-#define	ANCHOR
-
-#include <stdio.h>
-#include <sys/types.h>
-
-#define	EL_BUFSIZ	1024		/* Maximum line size		*/
-
-#define	HANDLE_SIGNALS	0x01
-#define	NO_TTY		0x02
-#define	EDIT_DISABLED	0x04
-#define	UNBUFFERED	0x08
-
-typedef int bool_t;			/* True or not			*/
-
-typedef unsigned char el_action_t;	/* Index to command array	*/
-
-typedef struct coord_t {		/* Position on the screen	*/
-	int	h;
-	int	v;
-} coord_t;
-
-typedef struct el_line_t {
-	char	*buffer;		/* Input line			*/
-	char	*cursor;		/* Cursor position		*/
-	char	*lastchar;		/* Last character		*/
-	const char	*limit;		/* Max position			*/
-} el_line_t;
-
-/*
- * Editor state
- */
-typedef struct el_state_t {
-	int		inputmode;	/* What mode are we in?		*/
-	int		doingarg;	/* Are we getting an argument?	*/
-	int		argument;	/* Numeric argument		*/
-	int		metanext;	/* Is the next char a meta char */
-	el_action_t	lastcmd;	/* Previous command		*/
-	el_action_t	thiscmd;	/* this command 		*/
-	char		thisch;		/* char that generated it	*/
-} el_state_t;
-
-/*
- * Until we come up with something better...
- */
-#define	el_strdup(a)	strdup(a)
-#define	el_malloc(a)	malloc(a)
-#define	el_realloc(a,b)	realloc(a, b)
-#define	el_free(a)	free(a)
-
-#include "tty.h"
-#include "prompt.h"
-#include "key.h"
-#include "el_term.h"
-#include "refresh.h"
-#include "chared.h"
-#include "common.h"
-#include "search.h"
-#include "hist.h"
-#include "map.h"
-#include "parse.h"
-#include "sig.h"
-#include "help.h"
-#include "read.h"
-
-struct editline {
-	char		 *el_prog;	/* the program name		*/
-	FILE		 *el_outfile;	/* Stdio stuff			*/
-	FILE		 *el_errfile;	/* Stdio stuff			*/
-	int		  el_infd;	/* Input file descriptor	*/
-	int		  el_flags;	/* Various flags.		*/
-	coord_t		  el_cursor;	/* Cursor location		*/
-	char		**el_display;	/* Real screen image = what is there */
-	char		**el_vdisplay;	/* Virtual screen image = what we see */
-	void		 *el_data;	/* Client data			*/
-	el_line_t	  el_line;	/* The current line information	*/
-	el_state_t	  el_state;	/* Current editor state		*/
-	el_term_t	  el_term;	/* Terminal dependent stuff	*/
-	el_tty_t	  el_tty;	/* Tty dependent stuff		*/
-	el_refresh_t	  el_refresh;	/* Refresh stuff		*/
-	el_prompt_t	  el_prompt;	/* Prompt stuff			*/
-	el_prompt_t	  el_rprompt;	/* Prompt stuff			*/
-	el_chared_t	  el_chared;	/* Characted editor stuff	*/
-	el_map_t	  el_map;	/* Key mapping stuff		*/
-	el_key_t	  el_key;	/* Key binding stuff		*/
-	el_history_t	  el_history;	/* History stuff		*/
-	el_search_t	  el_search;	/* Search stuff			*/
-	el_signal_t	  el_signal;	/* Signal handling stuff	*/
-	el_read_t	  el_read;	/* Character reading stuff	*/
-};
-
-protected int	el_editmode(EditLine *, int, const char **);
-
-#ifdef DEBUG
-#define	EL_ABORT(a)	do { \
-				fprintf(el->el_errfile, "%s, %d: ", \
-					 __FILE__, __LINE__); \
-				fprintf a; \
-				abort(); \
-			} while( /*CONSTCOND*/0);
-#else
-#define EL_ABORT(a)	abort()
-#endif
-#endif /* _h_el */
diff --git a/libedit/el_term.h b/libedit/el_term.h
deleted file mode 100644
index 61f5389..0000000
--- a/libedit/el_term.h
+++ /dev/null
@@ -1,132 +0,0 @@
-/*	$NetBSD: term.h,v 1.16 2005/03/15 00:10:40 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)term.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.term.h: Termcap header
- */
-#ifndef _h_el_term
-#define	_h_el_term
-
-#include "histedit.h"
-
-typedef struct {		/* Symbolic function key bindings	*/
-	const char	*name;	/* name of the key			*/
-	int		 key;	/* Index in termcap table		*/
-	key_value_t	 fun;	/* Function bound to it			*/
-	int		 type;	/* Type of function			*/
-} fkey_t;
-
-typedef struct {
-	const char *t_name;		/* the terminal name	*/
-	coord_t	  t_size;		/* # lines and cols	*/
-	int	  t_flags;
-#define	TERM_CAN_INSERT		0x001	/* Has insert cap	*/
-#define	TERM_CAN_DELETE		0x002	/* Has delete cap	*/
-#define	TERM_CAN_CEOL		0x004	/* Has CEOL cap		*/
-#define	TERM_CAN_TAB		0x008	/* Can use tabs		*/
-#define	TERM_CAN_ME		0x010	/* Can turn all attrs.	*/
-#define	TERM_CAN_UP		0x020	/* Can move up		*/
-#define	TERM_HAS_META		0x040	/* Has a meta key	*/
-#define	TERM_HAS_AUTO_MARGINS	0x080	/* Has auto margins	*/
-#define	TERM_HAS_MAGIC_MARGINS	0x100	/* Has magic margins	*/
-	char	 *t_buf;		/* Termcap buffer	*/
-	int	  t_loc;		/* location used	*/
-	char	**t_str;		/* termcap strings	*/
-	int	 *t_val;		/* termcap values	*/
-	char	 *t_cap;		/* Termcap buffer	*/
-	fkey_t	 *t_fkey;		/* Array of keys	*/
-} el_term_t;
-
-/*
- * fKey indexes
- */
-#define	A_K_DN		0
-#define	A_K_UP		1
-#define	A_K_LT		2
-#define	A_K_RT		3
-#define	A_K_HO		4
-#define	A_K_EN		5
-#define	A_K_NKEYS	6
-
-#ifdef _SUNOS
-extern int tgetent(char *, const char *);
-extern int tgetflag(char *);
-extern int tgetnum(char *);
-extern int tputs(const char *, int, int (*)(int));
-extern char* tgoto(const char*, int, int);
-extern char* tgetstr(char*, char**);
-#endif
-
-protected void	term_move_to_line(EditLine *, int);
-protected void	term_move_to_char(EditLine *, int);
-protected void	term_clear_EOL(EditLine *, int);
-protected void	term_overwrite(EditLine *, const char *, int);
-protected void	term_insertwrite(EditLine *, char *, int);
-protected void	term_deletechars(EditLine *, int);
-protected void	term_clear_screen(EditLine *);
-protected void	term_beep(EditLine *);
-protected int	term_change_size(EditLine *, int, int);
-protected int	term_get_size(EditLine *, int *, int *);
-protected int	term_init(EditLine *);
-protected void	term_bind_arrow(EditLine *);
-protected void	term_print_arrow(EditLine *, const char *);
-protected int	term_clear_arrow(EditLine *, const char *);
-protected int	term_set_arrow(EditLine *, const char *, key_value_t *, int);
-protected void	term_end(EditLine *);
-protected void	term_get(EditLine *, const char **);
-protected int	term_set(EditLine *, const char *);
-protected int	term_settc(EditLine *, int, const char **);
-protected int	term_telltc(EditLine *, int, const char **);
-protected int	term_echotc(EditLine *, int, const char **);
-protected int	term__putc(int);
-protected void	term__flush(void);
-
-/*
- * Easy access macros
- */
-#define	EL_FLAGS	(el)->el_term.t_flags
-
-#define	EL_CAN_INSERT		(EL_FLAGS & TERM_CAN_INSERT)
-#define	EL_CAN_DELETE		(EL_FLAGS & TERM_CAN_DELETE)
-#define	EL_CAN_CEOL		(EL_FLAGS & TERM_CAN_CEOL)
-#define	EL_CAN_TAB		(EL_FLAGS & TERM_CAN_TAB)
-#define	EL_CAN_ME		(EL_FLAGS & TERM_CAN_ME)
-#define EL_CAN_UP		(EL_FLAGS & TERM_CAN_UP)
-#define	EL_HAS_META		(EL_FLAGS & TERM_HAS_META)
-#define	EL_HAS_AUTO_MARGINS	(EL_FLAGS & TERM_HAS_AUTO_MARGINS)
-#define	EL_HAS_MAGIC_MARGINS	(EL_FLAGS & TERM_HAS_MAGIC_MARGINS)
-
-#endif /* _h_el_term */
diff --git a/libedit/emacs.c b/libedit/emacs.c
deleted file mode 100644
index 5a8b6ee..0000000
--- a/libedit/emacs.c
+++ /dev/null
@@ -1,508 +0,0 @@
-/*	$NetBSD: emacs.c,v 1.20 2005/08/08 14:05:37 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)emacs.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: emacs.c,v 1.20 2005/08/08 14:05:37 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * emacs.c: Emacs functions
- */
-#include "el.h"
-
-/* em_delete_or_list():
- *	Delete character under cursor or list completions if at end of line
- *	[^D]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_delete_or_list(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor == el->el_line.lastchar) {
-					/* if I'm at the end */
-		if (el->el_line.cursor == el->el_line.buffer) {
-					/* and the beginning */
-			term_overwrite(el, STReof, 4);	/* then do an EOF */
-			term__flush();
-			return (CC_EOF);
-		} else {
-			/*
-			 * Here we could list completions, but it is an
-			 * error right now
-			 */
-			term_beep(el);
-			return (CC_ERROR);
-		}
-	} else {
-		if (el->el_state.doingarg)
-			c_delafter(el, el->el_state.argument);
-		else
-			c_delafter1(el);
-		if (el->el_line.cursor > el->el_line.lastchar)
-			el->el_line.cursor = el->el_line.lastchar;
-				/* bounds check */
-		return (CC_REFRESH);
-	}
-}
-
-
-/* em_delete_next_word():
- *	Cut from cursor to end of current word
- *	[M-d]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_delete_next_word(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *cp, *p, *kp;
-
-	if (el->el_line.cursor == el->el_line.lastchar)
-		return (CC_ERROR);
-
-	cp = c__next_word(el->el_line.cursor, el->el_line.lastchar,
-	    el->el_state.argument, ce__isword);
-
-	for (p = el->el_line.cursor, kp = el->el_chared.c_kill.buf; p < cp; p++)
-				/* save the text */
-		*kp++ = *p;
-	el->el_chared.c_kill.last = kp;
-
-	c_delafter(el, cp - el->el_line.cursor);	/* delete after dot */
-	if (el->el_line.cursor > el->el_line.lastchar)
-		el->el_line.cursor = el->el_line.lastchar;
-				/* bounds check */
-	return (CC_REFRESH);
-}
-
-
-/* em_yank():
- *	Paste cut buffer at cursor position
- *	[^Y]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_yank(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *kp, *cp;
-
-	if (el->el_chared.c_kill.last == el->el_chared.c_kill.buf)
-		return (CC_NORM);
-
-	if (el->el_line.lastchar +
-	    (el->el_chared.c_kill.last - el->el_chared.c_kill.buf) >=
-	    el->el_line.limit)
-		return (CC_ERROR);
-
-	el->el_chared.c_kill.mark = el->el_line.cursor;
-	cp = el->el_line.cursor;
-
-	/* open the space, */
-	c_insert(el, el->el_chared.c_kill.last - el->el_chared.c_kill.buf);
-	/* copy the chars */
-	for (kp = el->el_chared.c_kill.buf; kp < el->el_chared.c_kill.last; kp++)
-		*cp++ = *kp;
-
-	/* if an arg, cursor at beginning else cursor at end */
-	if (el->el_state.argument == 1)
-		el->el_line.cursor = cp;
-
-	return (CC_REFRESH);
-}
-
-
-/* em_kill_line():
- *	Cut the entire line and save in cut buffer
- *	[^U]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_kill_line(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *kp, *cp;
-
-	cp = el->el_line.buffer;
-	kp = el->el_chared.c_kill.buf;
-	while (cp < el->el_line.lastchar)
-		*kp++ = *cp++;	/* copy it */
-	el->el_chared.c_kill.last = kp;
-				/* zap! -- delete all of it */
-	el->el_line.lastchar = el->el_line.buffer;
-	el->el_line.cursor = el->el_line.buffer;
-	return (CC_REFRESH);
-}
-
-
-/* em_kill_region():
- *	Cut area between mark and cursor and save in cut buffer
- *	[^W]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_kill_region(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *kp, *cp;
-
-	if (!el->el_chared.c_kill.mark)
-		return (CC_ERROR);
-
-	if (el->el_chared.c_kill.mark > el->el_line.cursor) {
-		cp = el->el_line.cursor;
-		kp = el->el_chared.c_kill.buf;
-		while (cp < el->el_chared.c_kill.mark)
-			*kp++ = *cp++;	/* copy it */
-		el->el_chared.c_kill.last = kp;
-		c_delafter(el, cp - el->el_line.cursor);
-	} else {		/* mark is before cursor */
-		cp = el->el_chared.c_kill.mark;
-		kp = el->el_chared.c_kill.buf;
-		while (cp < el->el_line.cursor)
-			*kp++ = *cp++;	/* copy it */
-		el->el_chared.c_kill.last = kp;
-		c_delbefore(el, cp - el->el_chared.c_kill.mark);
-		el->el_line.cursor = el->el_chared.c_kill.mark;
-	}
-	return (CC_REFRESH);
-}
-
-
-/* em_copy_region():
- *	Copy area between mark and cursor to cut buffer
- *	[M-W]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_copy_region(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *kp, *cp;
-
-	if (!el->el_chared.c_kill.mark)
-		return (CC_ERROR);
-
-	if (el->el_chared.c_kill.mark > el->el_line.cursor) {
-		cp = el->el_line.cursor;
-		kp = el->el_chared.c_kill.buf;
-		while (cp < el->el_chared.c_kill.mark)
-			*kp++ = *cp++;	/* copy it */
-		el->el_chared.c_kill.last = kp;
-	} else {
-		cp = el->el_chared.c_kill.mark;
-		kp = el->el_chared.c_kill.buf;
-		while (cp < el->el_line.cursor)
-			*kp++ = *cp++;	/* copy it */
-		el->el_chared.c_kill.last = kp;
-	}
-	return (CC_NORM);
-}
-
-
-/* em_gosmacs_transpose():
- *	Exchange the two characters before the cursor
- *	Gosling emacs transpose chars [^T]
- */
-protected el_action_t
-em_gosmacs_transpose(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor > &el->el_line.buffer[1]) {
-		/* must have at least two chars entered */
-		c = el->el_line.cursor[-2];
-		el->el_line.cursor[-2] = el->el_line.cursor[-1];
-		el->el_line.cursor[-1] = c;
-		return (CC_REFRESH);
-	} else
-		return (CC_ERROR);
-}
-
-
-/* em_next_word():
- *	Move next to end of current word
- *	[M-f]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_next_word(EditLine *el, int c __attribute__((__unused__)))
-{
-	if (el->el_line.cursor == el->el_line.lastchar)
-		return (CC_ERROR);
-
-	el->el_line.cursor = c__next_word(el->el_line.cursor,
-	    el->el_line.lastchar,
-	    el->el_state.argument,
-	    ce__isword);
-
-	if (el->el_map.type == MAP_VI)
-		if (el->el_chared.c_vcmd.action != NOP) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	return (CC_CURSOR);
-}
-
-
-/* em_upper_case():
- *	Uppercase the characters from cursor to end of current word
- *	[M-u]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_upper_case(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *cp, *ep;
-
-	ep = c__next_word(el->el_line.cursor, el->el_line.lastchar,
-	    el->el_state.argument, ce__isword);
-
-	for (cp = el->el_line.cursor; cp < ep; cp++)
-		if (islower((unsigned char)*cp))
-			*cp = toupper((unsigned char)*cp);
-
-	el->el_line.cursor = ep;
-	if (el->el_line.cursor > el->el_line.lastchar)
-		el->el_line.cursor = el->el_line.lastchar;
-	return (CC_REFRESH);
-}
-
-
-/* em_capitol_case():
- *	Capitalize the characters from cursor to end of current word
- *	[M-c]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_capitol_case(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *cp, *ep;
-
-	ep = c__next_word(el->el_line.cursor, el->el_line.lastchar,
-	    el->el_state.argument, ce__isword);
-
-	for (cp = el->el_line.cursor; cp < ep; cp++) {
-		if (isalpha((unsigned char)*cp)) {
-			if (islower((unsigned char)*cp))
-				*cp = toupper((unsigned char)*cp);
-			cp++;
-			break;
-		}
-	}
-	for (; cp < ep; cp++)
-		if (isupper((unsigned char)*cp))
-			*cp = tolower((unsigned char)*cp);
-
-	el->el_line.cursor = ep;
-	if (el->el_line.cursor > el->el_line.lastchar)
-		el->el_line.cursor = el->el_line.lastchar;
-	return (CC_REFRESH);
-}
-
-
-/* em_lower_case():
- *	Lowercase the characters from cursor to end of current word
- *	[M-l]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_lower_case(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *cp, *ep;
-
-	ep = c__next_word(el->el_line.cursor, el->el_line.lastchar,
-	    el->el_state.argument, ce__isword);
-
-	for (cp = el->el_line.cursor; cp < ep; cp++)
-		if (isupper((unsigned char)*cp))
-			*cp = tolower((unsigned char)*cp);
-
-	el->el_line.cursor = ep;
-	if (el->el_line.cursor > el->el_line.lastchar)
-		el->el_line.cursor = el->el_line.lastchar;
-	return (CC_REFRESH);
-}
-
-
-/* em_set_mark():
- *	Set the mark at cursor
- *	[^@]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_set_mark(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_chared.c_kill.mark = el->el_line.cursor;
-	return (CC_NORM);
-}
-
-
-/* em_exchange_mark():
- *	Exchange the cursor and mark
- *	[^X^X]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_exchange_mark(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *cp;
-
-	cp = el->el_line.cursor;
-	el->el_line.cursor = el->el_chared.c_kill.mark;
-	el->el_chared.c_kill.mark = cp;
-	return (CC_CURSOR);
-}
-
-
-/* em_universal_argument():
- *	Universal argument (argument times 4)
- *	[^U]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_universal_argument(EditLine *el, int c __attribute__((__unused__)))
-{				/* multiply current argument by 4 */
-
-	if (el->el_state.argument > 1000000)
-		return (CC_ERROR);
-	el->el_state.doingarg = 1;
-	el->el_state.argument *= 4;
-	return (CC_ARGHACK);
-}
-
-
-/* em_meta_next():
- *	Add 8th bit to next character typed
- *	[<ESC>]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_meta_next(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_state.metanext = 1;
-	return (CC_ARGHACK);
-}
-
-
-/* em_toggle_overwrite():
- *	Switch from insert to overwrite mode or vice versa
- */
-protected el_action_t
-/*ARGSUSED*/
-em_toggle_overwrite(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_state.inputmode = (el->el_state.inputmode == MODE_INSERT) ?
-	    MODE_REPLACE : MODE_INSERT;
-	return (CC_NORM);
-}
-
-
-/* em_copy_prev_word():
- *	Copy current word to cursor
- */
-protected el_action_t
-/*ARGSUSED*/
-em_copy_prev_word(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *cp, *oldc, *dp;
-
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (CC_ERROR);
-
-	oldc = el->el_line.cursor;
-	/* does a bounds check */
-	cp = c__prev_word(el->el_line.cursor, el->el_line.buffer,
-	    el->el_state.argument, ce__isword);
-
-	c_insert(el, oldc - cp);
-	for (dp = oldc; cp < oldc && dp < el->el_line.lastchar; cp++)
-		*dp++ = *cp;
-
-	el->el_line.cursor = dp;/* put cursor at end */
-
-	return (CC_REFRESH);
-}
-
-
-/* em_inc_search_next():
- *	Emacs incremental next search
- */
-protected el_action_t
-/*ARGSUSED*/
-em_inc_search_next(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_search.patlen = 0;
-	return (ce_inc_search(el, ED_SEARCH_NEXT_HISTORY));
-}
-
-
-/* em_inc_search_prev():
- *	Emacs incremental reverse search
- */
-protected el_action_t
-/*ARGSUSED*/
-em_inc_search_prev(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_search.patlen = 0;
-	return (ce_inc_search(el, ED_SEARCH_PREV_HISTORY));
-}
-
-
-/* em_delete_prev_char():
- *	Delete the character to the left of the cursor
- *	[^?]
- */
-protected el_action_t
-/*ARGSUSED*/
-em_delete_prev_char(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor <= el->el_line.buffer)
-		return (CC_ERROR);
-
-	if (el->el_state.doingarg)
-		c_delbefore(el, el->el_state.argument);
-	else
-		c_delbefore1(el);
-	el->el_line.cursor -= el->el_state.argument;
-	if (el->el_line.cursor < el->el_line.buffer)
-		el->el_line.cursor = el->el_line.buffer;
-	return (CC_REFRESH);
-}
diff --git a/libedit/fgetln.c b/libedit/fgetln.c
deleted file mode 100644
index fcf18c1..0000000
--- a/libedit/fgetln.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/*	$NetBSD: fgetln.c,v 1.2 2003/12/10 01:30:27 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Christos Zoulas.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "sys.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <string.h>
-
-
-char *
-fgetln(FILE *fp, size_t *len)
-{
-	static char *buf = NULL;
-	static size_t bufsiz = 0;
-	char *ptr;
-
-
-	if (buf == NULL) {
-		bufsiz = BUFSIZ;
-		if ((buf = malloc(bufsiz)) == NULL)
-			return NULL;
-	}
-
-	if (fgets(buf, bufsiz, fp) == NULL)
-		return NULL;
-	*len = 0;
-
-	while ((ptr = strchr(&buf[*len], '\n')) == NULL) {
-		size_t nbufsiz = bufsiz + BUFSIZ;
-		char *nbuf = realloc(buf, nbufsiz);
-
-		if (nbuf == NULL) {
-			int oerrno = errno;
-			free(buf);
-			errno = oerrno;
-			buf = NULL;
-			return NULL;
-		} else
-			buf = nbuf;
-
-		*len = bufsiz;
-		if (fgets(&buf[bufsiz], BUFSIZ, fp) == NULL)
-			return buf;
-
-		bufsiz = nbufsiz;
-	}
-
-	*len = (ptr - buf) + 1;
-	return buf;
-}
-
diff --git a/libedit/filecomplete.c b/libedit/filecomplete.c
deleted file mode 100644
index bccb06c..0000000
--- a/libedit/filecomplete.c
+++ /dev/null
@@ -1,557 +0,0 @@
-/*	$NetBSD: filecomplete.c,v 1.8 2005/08/03 13:41:38 christos Exp $	*/
-
-/*-
- * Copyright (c) 1997 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Jaromir Dolecek.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the NetBSD
- *	Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-  
-/* AIX requires this to be the first thing in the file.  */
-#if defined (_AIX) && !defined (__GNUC__)
- #pragma alloca
-#endif
-
-#include "sys.h"
-
-#ifdef __GNUC__
-# undef alloca
-# define alloca(n) __builtin_alloca (n)
-#else
-# ifdef HAVE_ALLOCA_H
-#  include <alloca.h>
-# else
-#  ifndef _AIX
-extern char *alloca ();
-#  endif
-# endif
-#endif
-
-#if !defined(lint) && !defined(SCCSID)
-__RCSID("$NetBSD: filecomplete.c,v 1.8 2005/08/03 13:41:38 christos Exp $");
-#endif /* not lint && not SCCSID */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <stdio.h>
-#include <dirent.h>
-#include <string.h>
-#include <pwd.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <limits.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <vis.h>
-
-#include "el.h"
-#include "fcns.h"		/* for EL_NUM_FCNS */
-#include "histedit.h"
-#include "filecomplete.h"
-
-static char break_chars[] = { ' ', '\t', '\n', '"', '\\', '\'', '`', '@', '$',
-    '>', '<', '=', ';', '|', '&', '{', '(', '\0' };
-
-
-/********************************/
-/* completion functions */
-
-/*
- * does tilde expansion of strings of type ``~user/foo''
- * if ``user'' isn't valid user name or ``txt'' doesn't start
- * w/ '~', returns pointer to strdup()ed copy of ``txt''
- *
- * it's callers's responsibility to free() returned string
- */
-char *
-fn_tilde_expand(const char *txt)
-{
-	struct passwd pwres, *pass;
-	char *temp;
-	size_t len = 0;
-	char pwbuf[1024];
-
-	if (txt[0] != '~')
-		return (strdup(txt));
-
-	temp = strchr(txt + 1, '/');
-	if (temp == NULL) {
-		temp = strdup(txt + 1);
-		if (temp == NULL)
-			return NULL;
-	} else {
-		len = temp - txt + 1;	/* text until string after slash */
-		temp = malloc(len);
-		if (temp == NULL)
-			return NULL;
-		(void)strncpy(temp, txt + 1, len - 2);
-		temp[len - 2] = '\0';
-	}
-	if (temp[0] == 0) {
-#ifdef HAVE_GETPW_R_POSIX
-		if (getpwuid_r(getuid(), &pwres, pwbuf, sizeof(pwbuf), &pass) != 0)
-			pass = NULL;
-#elif HAVE_GETPW_R_DRAFT
-		pass = getpwuid_r(getuid(), &pwres, pwbuf, sizeof(pwbuf));
-#else 
-      pass = getpwuid(getuid());
-#endif
-	} else {
-#ifdef HAVE_GETPW_R_POSIX
-		if (getpwnam_r(temp, &pwres, pwbuf, sizeof(pwbuf), &pass) != 0)
-			pass = NULL;
-#elif HAVE_GETPW_R_DRAFT
-		pass = getpwnam_r(temp, &pwres, pwbuf, sizeof(pwbuf));
-#else
-		pass = getpwnam(temp);
-#endif
-	}
-	free(temp);		/* value no more needed */
-	if (pass == NULL)
-		return (strdup(txt));
-
-	/* update pointer txt to point at string immedially following */
-	/* first slash */
-	txt += len;
-
-	temp = malloc(strlen(pass->pw_dir) + 1 + strlen(txt) + 1);
-	if (temp == NULL)
-		return NULL;
-	(void)sprintf(temp, "%s/%s", pass->pw_dir, txt);
-
-	return (temp);
-}
-
-
-/*
- * return first found file name starting by the ``text'' or NULL if no
- * such file can be found
- * value of ``state'' is ignored
- *
- * it's caller's responsibility to free returned string
- */
-char *
-fn_filename_completion_function(const char *text, int state)
-{
-	static DIR *dir = NULL;
-	static char *filename = NULL, *dirname = NULL, *dirpath = NULL;
-	static size_t filename_len = 0;
-	struct dirent *entry;
-	char *temp;
-	size_t len;
-
-	if (state == 0 || dir == NULL) {
-		temp = strrchr(text, '/');
-		if (temp) {
-			char *nptr;
-			temp++;
-			nptr = realloc(filename, strlen(temp) + 1);
-			if (nptr == NULL) {
-				free(filename);
-				return NULL;
-			}
-			filename = nptr;
-			(void)strcpy(filename, temp);
-			len = temp - text;	/* including last slash */
-			nptr = realloc(dirname, len + 1);
-			if (nptr == NULL) {
-				free(filename);
-				return NULL;
-			}
-			dirname = nptr;
-			(void)strncpy(dirname, text, len);
-			dirname[len] = '\0';
-		} else {
-			if (*text == 0)
-				filename = NULL;
-			else {
-				filename = strdup(text);
-				if (filename == NULL)
-					return NULL;
-			}
-			dirname = NULL;
-		}
-
-		if (dir != NULL) {
-			(void)closedir(dir);
-			dir = NULL;
-		}
-
-		/* support for ``~user'' syntax */
-		free(dirpath);
-
-		if (dirname == NULL && (dirname = strdup("./")) == NULL)
-			return NULL;
-
-		if (*dirname == '~')
-			dirpath = fn_tilde_expand(dirname);
-		else
-			dirpath = strdup(dirname);
-
-		if (dirpath == NULL)
-			return NULL;
-
-		dir = opendir(dirpath);
-		if (!dir)
-			return (NULL);	/* cannot open the directory */
-
-		/* will be used in cycle */
-		filename_len = filename ? strlen(filename) : 0;
-	}
-
-	/* find the match */
-	while ((entry = readdir(dir)) != NULL) {
-		/* skip . and .. */
-		if (entry->d_name[0] == '.' && (!entry->d_name[1]
-		    || (entry->d_name[1] == '.' && !entry->d_name[2])))
-			continue;
-		if (filename_len == 0)
-			break;
-		/* otherwise, get first entry where first */
-		/* filename_len characters are equal	  */
-		if (entry->d_name[0] == filename[0]
-         /* Some dirents have d_namlen, but it is not portable. */
-		    && strlen(entry->d_name) >= filename_len
-		    && strncmp(entry->d_name, filename,
-			filename_len) == 0)
-			break;
-	}
-
-	if (entry) {		/* match found */
-
-      /* Some dirents have d_namlen, but it is not portable. */
-		len = strlen(entry->d_name);
-		temp = malloc(strlen(dirname) + len + 1);
-		if (temp == NULL)
-			return NULL;
-		(void)sprintf(temp, "%s%s", dirname, entry->d_name);
-	} else {
-		(void)closedir(dir);
-		dir = NULL;
-		temp = NULL;
-	}
-
-	return (temp);
-}
-
-
-static const char *
-append_char_function(const char *name)
-{
-	struct stat stbuf;
-	char *expname = *name == '~' ? fn_tilde_expand(name) : NULL;
-	const char *rs = "";
-
-	if (stat(expname ? expname : name, &stbuf) == -1)
-		goto out;
-	if (S_ISDIR(stbuf.st_mode))
-		rs = "/";
-out:
-	if (expname)
-		free(expname);
-	return rs;
-}
-/*
- * returns list of completions for text given
- * non-static for readline.
- */
-char ** completion_matches(const char *, char *(*)(const char *, int));
-char **
-completion_matches(const char *text, char *(*genfunc)(const char *, int))
-{
-	char **match_list = NULL, *retstr, *prevstr;
-	size_t match_list_len, max_equal, which, i;
-	size_t matches;
-
-	matches = 0;
-	match_list_len = 1;
-	while ((retstr = (*genfunc) (text, (int)matches)) != NULL) {
-		/* allow for list terminator here */
-		if (matches + 3 >= match_list_len) {
-			char **nmatch_list;
-			while (matches + 3 >= match_list_len)
-				match_list_len <<= 1;
-			nmatch_list = realloc(match_list,
-			    match_list_len * sizeof(char *));
-			if (nmatch_list == NULL) {
-				free(match_list);
-				return NULL;
-			}
-			match_list = nmatch_list;
-
-		}
-		match_list[++matches] = retstr;
-	}
-
-	if (!match_list)
-		return NULL;	/* nothing found */
-
-	/* find least denominator and insert it to match_list[0] */
-	which = 2;
-	prevstr = match_list[1];
-	max_equal = strlen(prevstr);
-	for (; which <= matches; which++) {
-		for (i = 0; i < max_equal &&
-		    prevstr[i] == match_list[which][i]; i++)
-			continue;
-		max_equal = i;
-	}
-
-	retstr = malloc(max_equal + 1);
-	if (retstr == NULL) {
-		free(match_list);
-		return NULL;
-	}
-	(void)strncpy(retstr, match_list[1], max_equal);
-	retstr[max_equal] = '\0';
-	match_list[0] = retstr;
-
-	/* add NULL as last pointer to the array */
-	match_list[matches + 1] = (char *) NULL;
-
-	return (match_list);
-}
-
-/*
- * Sort function for qsort(). Just wrapper around strcasecmp().
- */
-static int
-_fn_qsort_string_compare(const void *i1, const void *i2)
-{
-	const char *s1 = ((const char * const *)i1)[0];
-	const char *s2 = ((const char * const *)i2)[0];
-
-	return strcasecmp(s1, s2);
-}
-
-/*
- * Display list of strings in columnar format on readline's output stream.
- * 'matches' is list of strings, 'len' is number of strings in 'matches',
- * 'max' is maximum length of string in 'matches'.
- */
-void
-fn_display_match_list (EditLine *el, char **matches, int len, int max)
-{
-	int i, idx, limit, count;
-	int screenwidth = el->el_term.t_size.h;
-
-	/*
-	 * Find out how many entries can be put on one line, count
-	 * with two spaces between strings.
-	 */
-	limit = screenwidth / (max + 2);
-	if (limit == 0)
-		limit = 1;
-
-	/* how many lines of output */
-	count = len / limit;
-	if (count * limit < len)
-		count++;
-
-	/* Sort the items if they are not already sorted. */
-	qsort(&matches[1], (size_t)(len - 1), sizeof(char *),
-	    _fn_qsort_string_compare);
-
-	idx = 1;
-	for(; count > 0; count--) {
-		for(i = 0; i < limit && matches[idx]; i++, idx++)
-			(void)fprintf(el->el_outfile, "%-*s  ", max,
-			    matches[idx]);
-		(void)fprintf(el->el_outfile, "\n");
-	}
-}
-
-/*
- * Complete the word at or before point,
- * 'what_to_do' says what to do with the completion.
- * \t   means do standard completion.
- * `?' means list the possible completions.
- * `*' means insert all of the possible completions.
- * `!' means to do standard completion, and list all possible completions if
- * there is more than one.
- *
- * Note: '*' support is not implemented
- *       '!' could never be invoked
- */
-int
-fn_complete(EditLine *el,
-	char *(*complet_func)(const char *, int),
-	char **(*attempted_completion_function)(const char *, int, int),
-	const char *word_break, const char *special_prefixes,
-	const char *(*app_func)(const char *), int query_items,
-	int *completion_type, int *over, int *point, int *end)
-{
-	const LineInfo *li;
-	char *temp, **matches;
-	const char *ctemp;
-	size_t len;
-	int what_to_do = '\t';
-
-	if (el->el_state.lastcmd == el->el_state.thiscmd)
-		what_to_do = '?';
-
-	/* readline's rl_complete() has to be told what we did... */
-	if (completion_type != NULL)
-		*completion_type = what_to_do;
-
-	if (!complet_func)
-		complet_func = fn_filename_completion_function;
-	if (!app_func)
-		app_func = append_char_function;
-
-	/* We now look backwards for the start of a filename/variable word */
-	li = el_line(el);
-	ctemp = (const char *) li->cursor;
-	while (ctemp > li->buffer
-	    && !strchr(word_break, ctemp[-1])
-	    && (!special_prefixes || !strchr(special_prefixes, ctemp[-1]) ) )
-		ctemp--;
-
-	len = li->cursor - ctemp;
-	temp = alloca(len + 1);
-	(void)strncpy(temp, ctemp, len);
-	temp[len] = '\0';
-
-	/* these can be used by function called in completion_matches() */
-	/* or (*attempted_completion_function)() */
-	if (point != 0)
-		*point = li->cursor - li->buffer;
-	if (end != NULL)
-		*end = li->lastchar - li->buffer;
-
-	if (attempted_completion_function) {
-		int cur_off = li->cursor - li->buffer;
-		matches = (*attempted_completion_function) (temp,
-		    (int)(cur_off - len), cur_off);
-	} else
-		matches = 0;
-	if (!attempted_completion_function || 
-	    (over != NULL && !*over && !matches))
-		matches = completion_matches(temp, complet_func);
-
-	if (over != NULL)
-		*over = 0;
-
-	if (matches) {
-		int i, retval = CC_REFRESH;
-		int matches_num, maxlen, match_len, match_display=1;
-
-		/*
-		 * Only replace the completed string with common part of
-		 * possible matches if there is possible completion.
-		 */
-		if (matches[0][0] != '\0') {
-			el_deletestr(el, (int) len);
-			el_insertstr(el, matches[0]);
-		}
-
-		if (what_to_do == '?')
-			goto display_matches;
-
-		if (matches[2] == NULL && strcmp(matches[0], matches[1]) == 0) {
-			/*
-			 * We found exact match. Add a space after
-			 * it, unless we do filename completion and the
-			 * object is a directory.
-			 */
-			el_insertstr(el, (*append_char_function)(matches[0])); 
-		} else if (what_to_do == '!') {
-    display_matches:
-			/*
-			 * More than one match and requested to list possible
-			 * matches.
-			 */
-
-			for(i=1, maxlen=0; matches[i]; i++) {
-				match_len = strlen(matches[i]);
-				if (match_len > maxlen)
-					maxlen = match_len;
-			}
-			matches_num = i - 1;
-				
-			/* newline to get on next line from command line */
-			(void)fprintf(el->el_outfile, "\n");
-
-			/*
-			 * If there are too many items, ask user for display
-			 * confirmation.
-			 */
-			if (matches_num > query_items) {
-				(void)fprintf(el->el_outfile,
-				    "Display all %d possibilities? (y or n) ",
-				    matches_num);
-				(void)fflush(el->el_outfile);
-				if (getc(stdin) != 'y')
-					match_display = 0;
-				(void)fprintf(el->el_outfile, "\n");
-			}
-
-			if (match_display)
-				fn_display_match_list(el, matches, matches_num,
-					maxlen);
-			retval = CC_REDISPLAY;
-		} else if (matches[0][0]) {
-			/*
-			 * There was some common match, but the name was
-			 * not complete enough. Next tab will print possible
-			 * completions.
-			 */
-			el_beep(el);
-		} else {
-			/* lcd is not a valid object - further specification */
-			/* is needed */
-			el_beep(el);
-			retval = CC_NORM;
-		}
-
-		/* free elements of array and the array itself */
-		for (i = 0; matches[i]; i++)
-			free(matches[i]);
-		free(matches), matches = NULL;
-
-		return (retval);
-	}
-	return (CC_NORM);
-}
-
-/*
- * el-compatible wrapper around rl_complete; needed for key binding
- */
-/* ARGSUSED */
-unsigned char
-_el_fn_complete(EditLine *el, int ch __attribute__((__unused__)))
-{
-	return (unsigned char)fn_complete(el, NULL, NULL,
-	    break_chars, NULL, NULL, 100,
-	    NULL, NULL, NULL, NULL);
-}
diff --git a/libedit/filecomplete.h b/libedit/filecomplete.h
deleted file mode 100644
index 335ec72..0000000
--- a/libedit/filecomplete.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*	$NetBSD: filecomplete.h,v 1.4 2005/06/11 18:18:59 christos Exp $	*/
-
-/*-
- * Copyright (c) 1997 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Jaromir Dolecek.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the NetBSD
- *	Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _FILECOMPLETE_H_
-#define _FILECOMPLETE_H_
-
-int fn_complete(EditLine *,
-    char *(*)(const char *, int),
-    char **(*)(const char *, int, int),
-    const char *, const char *, const char *(*)(const char *), int,
-    int *, int *, int *, int *);
-
-void fn_display_match_list(EditLine *, char **, int, int);
-char *fn_tilde_expand(const char *);
-char *fn_filename_completion_function(const char *, int);
-
-#endif
diff --git a/libedit/hist.c b/libedit/hist.c
deleted file mode 100644
index 7f8b310..0000000
--- a/libedit/hist.c
+++ /dev/null
@@ -1,210 +0,0 @@
-/*	$NetBSD: hist.c,v 1.15 2003/11/01 23:36:39 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)hist.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: hist.c,v 1.15 2003/11/01 23:36:39 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * hist.c: History access functions
- */
-#include <stdlib.h>
-#include "el.h"
-
-/* hist_init():
- *	Initialization function.
- */
-protected int
-hist_init(EditLine *el)
-{
-
-	el->el_history.fun = NULL;
-	el->el_history.ref = NULL;
-	el->el_history.buf = (char *) el_malloc(EL_BUFSIZ);
-	el->el_history.sz  = EL_BUFSIZ;
-	if (el->el_history.buf == NULL)
-		return (-1);
-	el->el_history.last = el->el_history.buf;
-	return (0);
-}
-
-
-/* hist_end():
- *	clean up history;
- */
-protected void
-hist_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_history.buf);
-	el->el_history.buf = NULL;
-}
-
-
-/* hist_set():
- *	Set new history interface
- */
-protected int
-hist_set(EditLine *el, hist_fun_t fun, ptr_t ptr)
-{
-
-	el->el_history.ref = ptr;
-	el->el_history.fun = fun;
-	return (0);
-}
-
-
-/* hist_get():
- *	Get a history line and update it in the buffer.
- *	eventno tells us the event to get.
- */
-protected el_action_t
-hist_get(EditLine *el)
-{
-	const char *hp;
-	int h;
-
-	if (el->el_history.eventno == 0) {	/* if really the current line */
-		(void) strncpy(el->el_line.buffer, el->el_history.buf,
-		    el->el_history.sz);
-		el->el_line.lastchar = el->el_line.buffer +
-		    (el->el_history.last - el->el_history.buf);
-
-#ifdef KSHVI
-		if (el->el_map.type == MAP_VI)
-			el->el_line.cursor = el->el_line.buffer;
-		else
-#endif /* KSHVI */
-			el->el_line.cursor = el->el_line.lastchar;
-
-		return (CC_REFRESH);
-	}
-	if (el->el_history.ref == NULL)
-		return (CC_ERROR);
-
-	hp = HIST_FIRST(el);
-
-	if (hp == NULL)
-		return (CC_ERROR);
-
-	for (h = 1; h < el->el_history.eventno; h++)
-		if ((hp = HIST_NEXT(el)) == NULL) {
-			el->el_history.eventno = h;
-			return (CC_ERROR);
-		}
-	(void) strlcpy(el->el_line.buffer, hp,
-			(size_t)(el->el_line.limit - el->el_line.buffer));
-	el->el_line.lastchar = el->el_line.buffer + strlen(el->el_line.buffer);
-
-	if (el->el_line.lastchar > el->el_line.buffer
-	    && el->el_line.lastchar[-1] == '\n')
-		el->el_line.lastchar--;
-	if (el->el_line.lastchar > el->el_line.buffer
-	    && el->el_line.lastchar[-1] == ' ')
-		el->el_line.lastchar--;
-#ifdef KSHVI
-	if (el->el_map.type == MAP_VI)
-		el->el_line.cursor = el->el_line.buffer;
-	else
-#endif /* KSHVI */
-		el->el_line.cursor = el->el_line.lastchar;
-
-	return (CC_REFRESH);
-}
-
-
-/* hist_command()
- *	process a history command
- */
-protected int
-hist_command(EditLine *el, int argc, const char **argv)
-{
-	const char *str;
-	int num;
-	HistEvent ev;
-
-	if (el->el_history.ref == NULL)
-		return (-1);
-
-	if (argc == 1 || strcmp(argv[1], "list") == 0) {
-		 /* List history entries */
-
-		for (str = HIST_LAST(el); str != NULL; str = HIST_PREV(el))
-			(void) fprintf(el->el_outfile, "%d %s",
-			    el->el_history.ev.num, str);
-		return (0);
-	}
-
-	if (argc != 3)
-		return (-1);
-
-	num = (int)strtol(argv[2], NULL, 0);
-
-	if (strcmp(argv[1], "size") == 0)
-		return history(el->el_history.ref, &ev, H_SETSIZE, num);
-
-	if (strcmp(argv[1], "unique") == 0)
-		return history(el->el_history.ref, &ev, H_SETUNIQUE, num);
-
-	return -1;
-}
-
-/* hist_enlargebuf()
- *	Enlarge history buffer to specified value. Called from el_enlargebufs().
- *	Return 0 for failure, 1 for success.
- */
-protected int
-/*ARGSUSED*/
-hist_enlargebuf(EditLine *el, size_t oldsz, size_t newsz)
-{
-	char *newbuf;
-
-	newbuf = realloc(el->el_history.buf, newsz);
-	if (!newbuf)
-		return 0;
-
-	(void) memset(&newbuf[oldsz], '\0', newsz - oldsz);
-
-	el->el_history.last = newbuf +
-				(el->el_history.last - el->el_history.buf);
-	el->el_history.buf = newbuf;
-	el->el_history.sz  = newsz;
-
-	return 1;
-}
diff --git a/libedit/hist.h b/libedit/hist.h
deleted file mode 100644
index 46e1463..0000000
--- a/libedit/hist.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*	$NetBSD: hist.h,v 1.10 2003/08/07 16:44:31 agc Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)hist.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.hist.c: History functions
- */
-#ifndef _h_el_hist
-#define	_h_el_hist
-
-#include "histedit.h"
-
-typedef int (*hist_fun_t)(ptr_t, HistEvent *, int, ...);
-
-typedef struct el_history_t {
-	char		*buf;		/* The history buffer		*/
-	size_t		sz;		/* Size of history buffer	*/
-	char		*last;		/* The last character		*/
-	int		 eventno;	/* Event we are looking for	*/
-	ptr_t		 ref;		/* Argument for history fcns	*/
-	hist_fun_t	 fun;		/* Event access			*/
-	HistEvent	 ev;		/* Event cookie			*/
-} el_history_t;
-
-#define	HIST_FUN(el, fn, arg)	\
-    ((((*(el)->el_history.fun) ((el)->el_history.ref, &(el)->el_history.ev, \
-	fn, arg)) == -1) ? NULL : (el)->el_history.ev.str)
-
-#define	HIST_NEXT(el)		HIST_FUN(el, H_NEXT, NULL)
-#define	HIST_FIRST(el)		HIST_FUN(el, H_FIRST, NULL)
-#define	HIST_LAST(el)		HIST_FUN(el, H_LAST, NULL)
-#define	HIST_PREV(el)		HIST_FUN(el, H_PREV, NULL)
-#define	HIST_SET(el, num)	HIST_FUN(el, H_SET, num)
-#define	HIST_LOAD(el, fname)	HIST_FUN(el, H_LOAD fname)
-#define	HIST_SAVE(el, fname)	HIST_FUN(el, H_SAVE fname)
-
-protected int		hist_init(EditLine *);
-protected void		hist_end(EditLine *);
-protected el_action_t	hist_get(EditLine *);
-protected int		hist_set(EditLine *, hist_fun_t, ptr_t);
-protected int		hist_command(EditLine *, int, const char **);
-protected int		hist_enlargebuf(EditLine *, size_t, size_t);
-
-#endif /* _h_el_hist */
diff --git a/libedit/histedit.h b/libedit/histedit.h
deleted file mode 100644
index 40f0dd1..0000000
--- a/libedit/histedit.h
+++ /dev/null
@@ -1,224 +0,0 @@
-/*	$NetBSD: histedit.h,v 1.28 2005/07/14 15:00:58 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)histedit.h	8.2 (Berkeley) 1/3/94
- */
-
-/*
- * histedit.h: Line editor and history interface.
- */
-#ifndef _HISTEDIT_H_
-#define	_HISTEDIT_H_
-
-#define	LIBEDIT_MAJOR 2
-#define	LIBEDIT_MINOR 9
-
-#include <sys/types.h>
-#include <stdio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * ==== Editing ====
- */
-
-typedef struct editline EditLine;
-
-/*
- * For user-defined function interface
- */
-typedef struct lineinfo {
-	const char	*buffer;
-	const char	*cursor;
-	const char	*lastchar;
-} LineInfo;
-
-/*
- * EditLine editor function return codes.
- * For user-defined function interface
- */
-#define	CC_NORM		0
-#define	CC_NEWLINE	1
-#define	CC_EOF		2
-#define	CC_ARGHACK	3
-#define	CC_REFRESH	4
-#define	CC_CURSOR	5
-#define	CC_ERROR	6
-#define	CC_FATAL	7
-#define	CC_REDISPLAY	8
-#define	CC_REFRESH_BEEP	9
-
-/*
- * Initialization, cleanup, and resetting
- */
-EditLine	*el_init(const char *, FILE *, FILE *, FILE *);
-void		 el_end(EditLine *);
-void		 el_reset(EditLine *);
-
-/*
- * Get a line, a character or push a string back in the input queue
- */
-const char	*el_gets(EditLine *, int *);
-int		 el_getc(EditLine *, char *);
-void		 el_push(EditLine *, char *);
-
-/*
- * Beep!
- */
-void		 el_beep(EditLine *);
-
-/*
- * High level function internals control
- * Parses argc, argv array and executes builtin editline commands
- */
-int		 el_parse(EditLine *, int, const char **);
-
-/*
- * Low level editline access functions
- */
-int		 el_set(EditLine *, int, ...);
-int		 el_get(EditLine *, int, void *);
-unsigned char	_el_fn_complete(EditLine *, int);
-
-/*
- * el_set/el_get parameters
- */
-#define	EL_PROMPT	0	/* , el_pfunc_t);		*/
-#define	EL_TERMINAL	1	/* , const char *);		*/
-#define	EL_EDITOR	2	/* , const char *);		*/
-#define	EL_SIGNAL	3	/* , int);			*/
-#define	EL_BIND		4	/* , const char *, ..., NULL);	*/
-#define	EL_TELLTC	5	/* , const char *, ..., NULL);	*/
-#define	EL_SETTC	6	/* , const char *, ..., NULL);	*/
-#define	EL_ECHOTC	7	/* , const char *, ..., NULL);	*/
-#define	EL_SETTY	8	/* , const char *, ..., NULL);	*/
-#define	EL_ADDFN	9	/* , const char *, const char *	*/
-				/* , el_func_t);		*/
-#define	EL_HIST		10	/* , hist_fun_t, const char *);	*/
-#define	EL_EDITMODE	11	/* , int);			*/
-#define	EL_RPROMPT	12	/* , el_pfunc_t);		*/
-#define	EL_GETCFN	13	/* , el_rfunc_t);		*/
-#define	EL_CLIENTDATA	14	/* , void *);			*/
-#define	EL_UNBUFFERED	15	/* , int);			*/
-#define	EL_PREP_TERM    16      /* , int);                      */
-
-#define EL_BUILTIN_GETCFN	(NULL)
-
-/*
- * Source named file or $PWD/.editrc or $HOME/.editrc
- */
-int		el_source(EditLine *, const char *);
-
-/*
- * Must be called when the terminal changes size; If EL_SIGNAL
- * is set this is done automatically otherwise it is the responsibility
- * of the application
- */
-void		 el_resize(EditLine *);
-
-/*
- * User-defined function interface.
- */
-const LineInfo	*el_line(EditLine *);
-int		 el_insertstr(EditLine *, const char *);
-void		 el_deletestr(EditLine *, int);
-
-
-/*
- * ==== History ====
- */
-
-typedef struct history History;
-
-typedef struct HistEvent {
-	int		 num;
-	const char	*str;
-} HistEvent;
-
-/*
- * History access functions.
- */
-History *	history_init(void);
-void		history_end(History *);
-
-int		history(History *, HistEvent *, int, ...);
-
-#define	H_FUNC		 0	/* , UTSL		*/
-#define	H_SETSIZE	 1	/* , const int);	*/
-#define	H_GETSIZE	 2	/* , void);		*/
-#define	H_FIRST		 3	/* , void);		*/
-#define	H_LAST		 4	/* , void);		*/
-#define	H_PREV		 5	/* , void);		*/
-#define	H_NEXT		 6	/* , void);		*/
-#define	H_CURR		 8	/* , const int);	*/
-#define	H_SET		 7	/* , int);		*/
-#define	H_ADD		 9	/* , const char *);	*/
-#define	H_ENTER		10	/* , const char *);	*/
-#define	H_APPEND	11	/* , const char *);	*/
-#define	H_END		12	/* , void);		*/
-#define	H_NEXT_STR	13	/* , const char *);	*/
-#define	H_PREV_STR	14	/* , const char *);	*/
-#define	H_NEXT_EVENT	15	/* , const int);	*/
-#define	H_PREV_EVENT	16	/* , const int);	*/
-#define	H_LOAD		17	/* , const char *);	*/
-#define	H_SAVE		18	/* , const char *);	*/
-#define	H_CLEAR		19	/* , void);		*/
-#define	H_SETUNIQUE	20	/* , int);		*/
-#define	H_GETUNIQUE	21	/* , void);		*/
-#define	H_DEL		22	/* , int);		*/
-
-
-/*
- * ==== Tokenization ====
- */
-
-typedef struct tokenizer Tokenizer;
-
-/*
- * String tokenization functions, using simplified sh(1) quoting rules
- */
-Tokenizer	*tok_init(const char *);
-void		 tok_end(Tokenizer *);
-void		 tok_reset(Tokenizer *);
-int		 tok_line(Tokenizer *, const LineInfo *,
-		    int *, const char ***, int *, int *);
-int		 tok_str(Tokenizer *, const char *,
-		    int *, const char ***);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _HISTEDIT_H_ */
diff --git a/libedit/history.c b/libedit/history.c
deleted file mode 100644
index 77151cb..0000000
--- a/libedit/history.c
+++ /dev/null
@@ -1,986 +0,0 @@
-/*	$NetBSD: history.c,v 1.31 2005/08/01 14:34:06 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)history.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: history.c,v 1.31 2005/08/01 14:34:06 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * hist.c: History access functions
- */
-#include <string.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <vis.h>
-#include <sys/stat.h>
-
-static const char hist_cookie[] = "_HiStOrY_V2_\n";
-
-#include "histedit.h"
-
-typedef int (*history_gfun_t)(ptr_t, HistEvent *);
-typedef int (*history_efun_t)(ptr_t, HistEvent *, const char *);
-typedef void (*history_vfun_t)(ptr_t, HistEvent *);
-typedef int (*history_sfun_t)(ptr_t, HistEvent *, const int);
-
-struct history {
-	ptr_t h_ref;		/* Argument for history fcns	 */
-	int h_ent;		/* Last entry point for history	 */
-	history_gfun_t h_first;	/* Get the first element	 */
-	history_gfun_t h_next;	/* Get the next element		 */
-	history_gfun_t h_last;	/* Get the last element		 */
-	history_gfun_t h_prev;	/* Get the previous element	 */
-	history_gfun_t h_curr;	/* Get the current element	 */
-	history_sfun_t h_set;	/* Set the current element	 */
-	history_sfun_t h_del;	/* Set the given element	 */
-	history_vfun_t h_clear;	/* Clear the history list	 */
-	history_efun_t h_enter;	/* Add an element		 */
-	history_efun_t h_add;	/* Append to an element		 */
-};
-
-#define	HNEXT(h, ev)		(*(h)->h_next)((h)->h_ref, ev)
-#define	HFIRST(h, ev)		(*(h)->h_first)((h)->h_ref, ev)
-#define	HPREV(h, ev)		(*(h)->h_prev)((h)->h_ref, ev)
-#define	HLAST(h, ev)		(*(h)->h_last)((h)->h_ref, ev)
-#define	HCURR(h, ev)		(*(h)->h_curr)((h)->h_ref, ev)
-#define	HSET(h, ev, n)		(*(h)->h_set)((h)->h_ref, ev, n)
-#define	HCLEAR(h, ev)		(*(h)->h_clear)((h)->h_ref, ev)
-#define	HENTER(h, ev, str)	(*(h)->h_enter)((h)->h_ref, ev, str)
-#define	HADD(h, ev, str)	(*(h)->h_add)((h)->h_ref, ev, str)
-#define	HDEL(h, ev, n)		(*(h)->h_del)((h)->h_ref, ev, n)
-
-#define	h_strdup(a)	strdup(a)
-#define	h_malloc(a)	malloc(a)
-#define	h_realloc(a, b)	realloc((a), (b))
-#define	h_free(a)	free(a)
-
-typedef struct {
-    int		num;
-    char	*str;
-} HistEventPrivate;
-
-
-
-private int history_setsize(History *, HistEvent *, int);
-private int history_getsize(History *, HistEvent *);
-private int history_setunique(History *, HistEvent *, int);
-private int history_getunique(History *, HistEvent *);
-private int history_set_fun(History *, History *);
-private int history_load(History *, const char *);
-private int history_save(History *, const char *);
-private int history_prev_event(History *, HistEvent *, int);
-private int history_next_event(History *, HistEvent *, int);
-private int history_next_string(History *, HistEvent *, const char *);
-private int history_prev_string(History *, HistEvent *, const char *);
-
-
-/***********************************************************************/
-
-/*
- * Builtin- history implementation
- */
-typedef struct hentry_t {
-	HistEvent ev;		/* What we return		 */
-	struct hentry_t *next;	/* Next entry			 */
-	struct hentry_t *prev;	/* Previous entry		 */
-} hentry_t;
-
-typedef struct history_t {
-	hentry_t list;		/* Fake list header element	*/
-	hentry_t *cursor;	/* Current element in the list	*/
-	int max;		/* Maximum number of events	*/
-	int cur;		/* Current number of events	*/
-	int eventid;		/* For generation of unique event id	 */
-	int flags;		/* History flags		*/
-#define H_UNIQUE	1	/* Store only unique elements	*/
-} history_t;
-
-private int history_def_next(ptr_t, HistEvent *);
-private int history_def_first(ptr_t, HistEvent *);
-private int history_def_prev(ptr_t, HistEvent *);
-private int history_def_last(ptr_t, HistEvent *);
-private int history_def_curr(ptr_t, HistEvent *);
-private int history_def_set(ptr_t, HistEvent *, const int);
-private void history_def_clear(ptr_t, HistEvent *);
-private int history_def_enter(ptr_t, HistEvent *, const char *);
-private int history_def_add(ptr_t, HistEvent *, const char *);
-private int history_def_del(ptr_t, HistEvent *, const int);
-
-private int history_def_init(ptr_t *, HistEvent *, int);
-private int history_def_insert(history_t *, HistEvent *, const char *);
-private void history_def_delete(history_t *, HistEvent *, hentry_t *);
-
-#define	history_def_setsize(p, num)(void) (((history_t *)p)->max = (num))
-#define	history_def_getsize(p)  (((history_t *)p)->cur)
-#define	history_def_getunique(p) (((((history_t *)p)->flags) & H_UNIQUE) != 0)
-#define	history_def_setunique(p, uni) \
-    if (uni) \
-	(((history_t *)p)->flags) |= H_UNIQUE; \
-    else \
-	(((history_t *)p)->flags) &= ~H_UNIQUE
-
-#define	he_strerror(code)	he_errlist[code]
-#define	he_seterrev(evp, code)	{\
-				    evp->num = code;\
-				    evp->str = he_strerror(code);\
-				}
-
-/* error messages */
-static const char *const he_errlist[] = {
-	"OK",
-	"unknown error",
-	"malloc() failed",
-	"first event not found",
-	"last event not found",
-	"empty list",
-	"no next event",
-	"no previous event",
-	"current event is invalid",
-	"event not found",
-	"can't read history from file",
-	"can't write history",
-	"required parameter(s) not supplied",
-	"history size negative",
-	"function not allowed with other history-functions-set the default",
-	"bad parameters"
-};
-/* error codes */
-#define	_HE_OK                   0
-#define	_HE_UNKNOWN		 1
-#define	_HE_MALLOC_FAILED        2
-#define	_HE_FIRST_NOTFOUND       3
-#define	_HE_LAST_NOTFOUND        4
-#define	_HE_EMPTY_LIST           5
-#define	_HE_END_REACHED          6
-#define	_HE_START_REACHED	 7
-#define	_HE_CURR_INVALID	 8
-#define	_HE_NOT_FOUND		 9
-#define	_HE_HIST_READ		10
-#define	_HE_HIST_WRITE		11
-#define	_HE_PARAM_MISSING	12
-#define	_HE_SIZE_NEGATIVE	13
-#define	_HE_NOT_ALLOWED		14
-#define	_HE_BAD_PARAM		15
-
-/* history_def_first():
- *	Default function to return the first event in the history.
- */
-private int
-history_def_first(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	h->cursor = h->list.next;
-	if (h->cursor != &h->list)
-		*ev = h->cursor->ev;
-	else {
-		he_seterrev(ev, _HE_FIRST_NOTFOUND);
-		return (-1);
-	}
-
-	return (0);
-}
-
-
-/* history_def_last():
- *	Default function to return the last event in the history.
- */
-private int
-history_def_last(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	h->cursor = h->list.prev;
-	if (h->cursor != &h->list)
-		*ev = h->cursor->ev;
-	else {
-		he_seterrev(ev, _HE_LAST_NOTFOUND);
-		return (-1);
-	}
-
-	return (0);
-}
-
-
-/* history_def_next():
- *	Default function to return the next event in the history.
- */
-private int
-history_def_next(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	if (h->cursor == &h->list) {
-		he_seterrev(ev, _HE_EMPTY_LIST);
-		return (-1);
-	}
-
-	if (h->cursor->next == &h->list) {
-		he_seterrev(ev, _HE_END_REACHED);
-		return (-1);
-	}
-
-        h->cursor = h->cursor->next;
-        *ev = h->cursor->ev;
-
-	return (0);
-}
-
-
-/* history_def_prev():
- *	Default function to return the previous event in the history.
- */
-private int
-history_def_prev(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	if (h->cursor == &h->list) {
-		he_seterrev(ev,
-		    (h->cur > 0) ? _HE_END_REACHED : _HE_EMPTY_LIST);
-		return (-1);
-	}
-
-	if (h->cursor->prev == &h->list) {
-		he_seterrev(ev, _HE_START_REACHED);
-		return (-1);
-	}
-
-        h->cursor = h->cursor->prev;
-        *ev = h->cursor->ev;
-
-	return (0);
-}
-
-
-/* history_def_curr():
- *	Default function to return the current event in the history.
- */
-private int
-history_def_curr(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	if (h->cursor != &h->list)
-		*ev = h->cursor->ev;
-	else {
-		he_seterrev(ev,
-		    (h->cur > 0) ? _HE_CURR_INVALID : _HE_EMPTY_LIST);
-		return (-1);
-	}
-
-	return (0);
-}
-
-
-/* history_def_set():
- *	Default function to set the current event in the history to the
- *	given one.
- */
-private int
-history_def_set(ptr_t p, HistEvent *ev, const int n)
-{
-	history_t *h = (history_t *) p;
-
-	if (h->cur == 0) {
-		he_seterrev(ev, _HE_EMPTY_LIST);
-		return (-1);
-	}
-	if (h->cursor == &h->list || h->cursor->ev.num != n) {
-		for (h->cursor = h->list.next; h->cursor != &h->list;
-		    h->cursor = h->cursor->next)
-			if (h->cursor->ev.num == n)
-				break;
-	}
-	if (h->cursor == &h->list) {
-		he_seterrev(ev, _HE_NOT_FOUND);
-		return (-1);
-	}
-	return (0);
-}
-
-
-/* history_def_add():
- *	Append string to element
- */
-private int
-history_def_add(ptr_t p, HistEvent *ev, const char *str)
-{
-	history_t *h = (history_t *) p;
-	size_t len;
-	char *s;
-	HistEventPrivate *evp = (void *)&h->cursor->ev;
-
-	if (h->cursor == &h->list)
-		return (history_def_enter(p, ev, str));
-	len = strlen(evp->str) + strlen(str) + 1;
-	s = (char *) h_malloc(len);
-	if (s == NULL) {
-		he_seterrev(ev, _HE_MALLOC_FAILED);
-		return (-1);
-	}
-	(void) strlcpy(s, h->cursor->ev.str, len);
-	(void) strlcat(s, str, len);
-	h_free((ptr_t)evp->str);
-	evp->str = s;
-	*ev = h->cursor->ev;
-	return (0);
-}
-
-
-/* history_def_del():
- *	Delete element hp of the h list
- */
-/* ARGSUSED */
-private int
-history_def_del(ptr_t p, HistEvent *ev __attribute__((__unused__)),
-    const int num)
-{
-	history_t *h = (history_t *) p;
-	if (history_def_set(h, ev, num) != 0)
-		return (-1);
-	ev->str = strdup(h->cursor->ev.str);
-	ev->num = h->cursor->ev.num;
-	history_def_delete(h, ev, h->cursor);
-	return (0);
-}
-
-
-/* history_def_delete():
- *	Delete element hp of the h list
- */
-/* ARGSUSED */
-private void
-history_def_delete(history_t *h, 
-		   HistEvent *ev __attribute__((__unused__)), hentry_t *hp)
-{
-	HistEventPrivate *evp = (void *)&hp->ev;
-	if (hp == &h->list)
-		abort();
-	if (h->cursor == hp)
-		h->cursor = hp->prev;
-	hp->prev->next = hp->next;
-	hp->next->prev = hp->prev;
-	h_free((ptr_t) evp->str);
-	h_free(hp);
-	h->cur--;
-}
-
-
-/* history_def_insert():
- *	Insert element with string str in the h list
- */
-private int
-history_def_insert(history_t *h, HistEvent *ev, const char *str)
-{
-
-	h->cursor = (hentry_t *) h_malloc(sizeof(hentry_t));
-	if (h->cursor == NULL)
-		goto oomem;
-	if ((h->cursor->ev.str = h_strdup(str)) == NULL) {
-		h_free((ptr_t)h->cursor);
-		goto oomem;
-	}
-	h->cursor->ev.num = ++h->eventid;
-	h->cursor->next = h->list.next;
-	h->cursor->prev = &h->list;
-	h->list.next->prev = h->cursor;
-	h->list.next = h->cursor;
-	h->cur++;
-
-	*ev = h->cursor->ev;
-	return (0);
-oomem:
-	he_seterrev(ev, _HE_MALLOC_FAILED);
-	return (-1);
-}
-
-
-/* history_def_enter():
- *	Default function to enter an item in the history
- */
-private int
-history_def_enter(ptr_t p, HistEvent *ev, const char *str)
-{
-	history_t *h = (history_t *) p;
-
-	if ((h->flags & H_UNIQUE) != 0 && h->list.next != &h->list &&
-	    strcmp(h->list.next->ev.str, str) == 0)
-	    return (0); 
-
-	if (history_def_insert(h, ev, str) == -1)
-		return (-1);	/* error, keep error message */
-
-	/*
-         * Always keep at least one entry.
-         * This way we don't have to check for the empty list.
-         */
-	while (h->cur > h->max && h->cur > 0)
-		history_def_delete(h, ev, h->list.prev);
-
-	return (1);
-}
-
-
-/* history_def_init():
- *	Default history initialization function
- */
-/* ARGSUSED */
-private int
-history_def_init(ptr_t *p, HistEvent *ev __attribute__((__unused__)), int n)
-{
-	history_t *h = (history_t *) h_malloc(sizeof(history_t));
-	if (h == NULL)
-		return -1;
-
-	if (n <= 0)
-		n = 0;
-	h->eventid = 0;
-	h->cur = 0;
-	h->max = n;
-	h->list.next = h->list.prev = &h->list;
-	h->list.ev.str = NULL;
-	h->list.ev.num = 0;
-	h->cursor = &h->list;
-	h->flags = 0;
-	*p = (ptr_t) h;
-	return 0;
-}
-
-
-/* history_def_clear():
- *	Default history cleanup function
- */
-private void
-history_def_clear(ptr_t p, HistEvent *ev)
-{
-	history_t *h = (history_t *) p;
-
-	while (h->list.prev != &h->list)
-		history_def_delete(h, ev, h->list.prev);
-	h->eventid = 0;
-	h->cur = 0;
-}
-
-
-
-
-/************************************************************************/
-
-/* history_init():
- *	Initialization function.
- */
-public History *
-history_init(void)
-{
-	HistEvent ev;
-	History *h = (History *) h_malloc(sizeof(History));
-	if (h == NULL)
-		return NULL;
-
-	if (history_def_init(&h->h_ref, &ev, 0) == -1) {
-		h_free((ptr_t)h);
-		return NULL;
-	}
-	h->h_ent = -1;
-	h->h_next = history_def_next;
-	h->h_first = history_def_first;
-	h->h_last = history_def_last;
-	h->h_prev = history_def_prev;
-	h->h_curr = history_def_curr;
-	h->h_set = history_def_set;
-	h->h_clear = history_def_clear;
-	h->h_enter = history_def_enter;
-	h->h_add = history_def_add;
-	h->h_del = history_def_del;
-
-	return (h);
-}
-
-
-/* history_end():
- *	clean up history;
- */
-public void
-history_end(History *h)
-{
-	HistEvent ev;
-
-	if (h->h_next == history_def_next)
-		history_def_clear(h->h_ref, &ev);
-	h_free(h);
-}
-
-
-
-/* history_setsize():
- *	Set history number of events
- */
-private int
-history_setsize(History *h, HistEvent *ev, int num)
-{
-
-	if (h->h_next != history_def_next) {
-		he_seterrev(ev, _HE_NOT_ALLOWED);
-		return (-1);
-	}
-	if (num < 0) {
-		he_seterrev(ev, _HE_BAD_PARAM);
-		return (-1);
-	}
-	history_def_setsize(h->h_ref, num);
-	return (0);
-}
-
-
-/* history_getsize():
- *      Get number of events currently in history
- */
-private int
-history_getsize(History *h, HistEvent *ev)
-{
-	if (h->h_next != history_def_next) {
-		he_seterrev(ev, _HE_NOT_ALLOWED);
-		return (-1);
-	}
-	ev->num = history_def_getsize(h->h_ref);
-	if (ev->num < -1) {
-		he_seterrev(ev, _HE_SIZE_NEGATIVE);
-		return (-1);
-	}
-	return (0);
-}
-
-
-/* history_setunique():
- *	Set if adjacent equal events should not be entered in history.
- */
-private int
-history_setunique(History *h, HistEvent *ev, int uni)
-{
-
-	if (h->h_next != history_def_next) {
-		he_seterrev(ev, _HE_NOT_ALLOWED);
-		return (-1);
-	}
-	history_def_setunique(h->h_ref, uni);
-	return (0);
-}
-
-
-/* history_getunique():
- *	Get if adjacent equal events should not be entered in history.
- */
-private int
-history_getunique(History *h, HistEvent *ev)
-{
-	if (h->h_next != history_def_next) {
-		he_seterrev(ev, _HE_NOT_ALLOWED);
-		return (-1);
-	}
-	ev->num = history_def_getunique(h->h_ref);
-	return (0);
-}
-
-
-/* history_set_fun():
- *	Set history functions
- */
-private int
-history_set_fun(History *h, History *nh)
-{
-	HistEvent ev;
-
-	if (nh->h_first == NULL || nh->h_next == NULL || nh->h_last == NULL ||
-	    nh->h_prev == NULL || nh->h_curr == NULL || nh->h_set == NULL ||
-	    nh->h_enter == NULL || nh->h_add == NULL || nh->h_clear == NULL ||
-	    nh->h_del == NULL || nh->h_ref == NULL) {
-		if (h->h_next != history_def_next) {
-			history_def_init(&h->h_ref, &ev, 0);
-			h->h_first = history_def_first;
-			h->h_next = history_def_next;
-			h->h_last = history_def_last;
-			h->h_prev = history_def_prev;
-			h->h_curr = history_def_curr;
-			h->h_set = history_def_set;
-			h->h_clear = history_def_clear;
-			h->h_enter = history_def_enter;
-			h->h_add = history_def_add;
-			h->h_del = history_def_del;
-		}
-		return (-1);
-	}
-	if (h->h_next == history_def_next)
-		history_def_clear(h->h_ref, &ev);
-
-	h->h_ent = -1;
-	h->h_first = nh->h_first;
-	h->h_next = nh->h_next;
-	h->h_last = nh->h_last;
-	h->h_prev = nh->h_prev;
-	h->h_curr = nh->h_curr;
-	h->h_set = nh->h_set;
-	h->h_clear = nh->h_clear;
-	h->h_enter = nh->h_enter;
-	h->h_add = nh->h_add;
-	h->h_del = nh->h_del;
-
-	return (0);
-}
-
-
-/* history_load():
- *	History load function
- */
-private int
-history_load(History *h, const char *fname)
-{
-	FILE *fp;
-	char *line;
-	size_t sz, max_size;
-	char *ptr;
-	int i = -1;
-	HistEvent ev;
-
-	if ((fp = fopen(fname, "r")) == NULL)
-		return (i);
-
-	if ((line = fgetln(fp, &sz)) == NULL)
-		goto done;
-
-	if (strncmp(line, hist_cookie, sz) != 0)
-		goto done;
-
-	ptr = h_malloc(max_size = 1024);
-	if (ptr == NULL)
-		goto done;
-	for (i = 0; (line = fgetln(fp, &sz)) != NULL; i++) {
-		char c = line[sz];
-
-		if (sz != 0 && line[sz - 1] == '\n')
-			line[--sz] = '\0';
-		else
-			line[sz] = '\0';
-
-		if (max_size < sz) {
-			char *nptr;
-			max_size = (sz + 1024) & ~1023;
-			nptr = h_realloc(ptr, max_size);
-			if (nptr == NULL) {
-				i = -1;
-				goto oomem;
-			}
-			ptr = nptr;
-		}
-		(void) strunvis(ptr, line);
-		line[sz] = c;
-		if (HENTER(h, &ev, ptr) == -1) {
-			h_free((ptr_t)ptr);
-			return -1;
-		}
-	}
-oomem:
-	h_free((ptr_t)ptr);
-done:
-	(void) fclose(fp);
-	return (i);
-}
-
-
-/* history_save():
- *	History save function
- */
-private int
-history_save(History *h, const char *fname)
-{
-	FILE *fp;
-	HistEvent ev;
-	int i = -1, retval;
-	size_t len, max_size;
-	char *ptr;
-
-	if ((fp = fopen(fname, "w")) == NULL)
-		return (-1);
-
-	if (fchmod(fileno(fp), S_IRUSR|S_IWUSR) == -1)
-		goto done;
-	if (fputs(hist_cookie, fp) == EOF)
-		goto done;
-	ptr = h_malloc(max_size = 1024);
-	if (ptr == NULL)
-		goto done;
-	for (i = 0, retval = HLAST(h, &ev);
-	    retval != -1;
-	    retval = HPREV(h, &ev), i++) {
-		len = strlen(ev.str) * 4;
-		if (len >= max_size) {
-			char *nptr;
-			max_size = (len + 1024) & ~1023;
-			nptr = h_realloc(ptr, max_size);
-			if (nptr == NULL) {
-				i = -1;
-				goto oomem;
-			}
-			ptr = nptr;
-		}
-		(void) strvis(ptr, ev.str, VIS_WHITE);
-		(void) fprintf(fp, "%s\n", ptr);
-	}
-oomem:
-	h_free((ptr_t)ptr);
-done:
-	(void) fclose(fp);
-	return (i);
-}
-
-
-/* history_prev_event():
- *	Find the previous event, with number given
- */
-private int
-history_prev_event(History *h, HistEvent *ev, int num)
-{
-	int retval;
-
-	for (retval = HCURR(h, ev); retval != -1; retval = HPREV(h, ev))
-		if (ev->num == num)
-			return (0);
-
-	he_seterrev(ev, _HE_NOT_FOUND);
-	return (-1);
-}
-
-
-/* history_next_event():
- *	Find the next event, with number given
- */
-private int
-history_next_event(History *h, HistEvent *ev, int num)
-{
-	int retval;
-
-	for (retval = HCURR(h, ev); retval != -1; retval = HNEXT(h, ev))
-		if (ev->num == num)
-			return (0);
-
-	he_seterrev(ev, _HE_NOT_FOUND);
-	return (-1);
-}
-
-
-/* history_prev_string():
- *	Find the previous event beginning with string
- */
-private int
-history_prev_string(History *h, HistEvent *ev, const char *str)
-{
-	size_t len = strlen(str);
-	int retval;
-
-	for (retval = HCURR(h, ev); retval != -1; retval = HNEXT(h, ev))
-		if (strncmp(str, ev->str, len) == 0)
-			return (0);
-
-	he_seterrev(ev, _HE_NOT_FOUND);
-	return (-1);
-}
-
-
-/* history_next_string():
- *	Find the next event beginning with string
- */
-private int
-history_next_string(History *h, HistEvent *ev, const char *str)
-{
-	size_t len = strlen(str);
-	int retval;
-
-	for (retval = HCURR(h, ev); retval != -1; retval = HPREV(h, ev))
-		if (strncmp(str, ev->str, len) == 0)
-			return (0);
-
-	he_seterrev(ev, _HE_NOT_FOUND);
-	return (-1);
-}
-
-
-/* history():
- *	User interface to history functions.
- */
-int
-history(History *h, HistEvent *ev, int fun, ...)
-{
-	va_list va;
-	const char *str;
-	int retval;
-
-	va_start(va, fun);
-
-	he_seterrev(ev, _HE_OK);
-
-	switch (fun) {
-	case H_GETSIZE:
-		retval = history_getsize(h, ev);
-		break;
-
-	case H_SETSIZE:
-		retval = history_setsize(h, ev, va_arg(va, int));
-		break;
-
-	case H_GETUNIQUE:
-		retval = history_getunique(h, ev);
-		break;
-
-	case H_SETUNIQUE:
-		retval = history_setunique(h, ev, va_arg(va, int));
-		break;
-
-	case H_ADD:
-		str = va_arg(va, const char *);
-		retval = HADD(h, ev, str);
-		break;
-
-	case H_DEL:
-		retval = HDEL(h, ev, va_arg(va, const int));
-		break;
-
-	case H_ENTER:
-		str = va_arg(va, const char *);
-		if ((retval = HENTER(h, ev, str)) != -1)
-			h->h_ent = ev->num;
-		break;
-
-	case H_APPEND:
-		str = va_arg(va, const char *);
-		if ((retval = HSET(h, ev, h->h_ent)) != -1)
-			retval = HADD(h, ev, str);
-		break;
-
-	case H_FIRST:
-		retval = HFIRST(h, ev);
-		break;
-
-	case H_NEXT:
-		retval = HNEXT(h, ev);
-		break;
-
-	case H_LAST:
-		retval = HLAST(h, ev);
-		break;
-
-	case H_PREV:
-		retval = HPREV(h, ev);
-		break;
-
-	case H_CURR:
-		retval = HCURR(h, ev);
-		break;
-
-	case H_SET:
-		retval = HSET(h, ev, va_arg(va, const int));
-		break;
-
-	case H_CLEAR:
-		HCLEAR(h, ev);
-		retval = 0;
-		break;
-
-	case H_LOAD:
-		retval = history_load(h, va_arg(va, const char *));
-		if (retval == -1)
-			he_seterrev(ev, _HE_HIST_READ);
-		break;
-
-	case H_SAVE:
-		retval = history_save(h, va_arg(va, const char *));
-		if (retval == -1)
-			he_seterrev(ev, _HE_HIST_WRITE);
-		break;
-
-	case H_PREV_EVENT:
-		retval = history_prev_event(h, ev, va_arg(va, int));
-		break;
-
-	case H_NEXT_EVENT:
-		retval = history_next_event(h, ev, va_arg(va, int));
-		break;
-
-	case H_PREV_STR:
-		retval = history_prev_string(h, ev, va_arg(va, const char *));
-		break;
-
-	case H_NEXT_STR:
-		retval = history_next_string(h, ev, va_arg(va, const char *));
-		break;
-
-	case H_FUNC:
-	{
-		History hf;
-
-		hf.h_ref = va_arg(va, ptr_t);
-		h->h_ent = -1;
-		hf.h_first = va_arg(va, history_gfun_t);
-		hf.h_next = va_arg(va, history_gfun_t);
-		hf.h_last = va_arg(va, history_gfun_t);
-		hf.h_prev = va_arg(va, history_gfun_t);
-		hf.h_curr = va_arg(va, history_gfun_t);
-		hf.h_set = va_arg(va, history_sfun_t);
-		hf.h_clear = va_arg(va, history_vfun_t);
-		hf.h_enter = va_arg(va, history_efun_t);
-		hf.h_add = va_arg(va, history_efun_t);
-		hf.h_del = va_arg(va, history_sfun_t);
-
-		if ((retval = history_set_fun(h, &hf)) == -1)
-			he_seterrev(ev, _HE_PARAM_MISSING);
-		break;
-	}
-
-	case H_END:
-		history_end(h);
-		retval = 0;
-		break;
-
-	default:
-		retval = -1;
-		he_seterrev(ev, _HE_UNKNOWN);
-		break;
-	}
-	va_end(va);
-	return (retval);
-}
diff --git a/libedit/key.c b/libedit/key.c
deleted file mode 100644
index 37f5558..0000000
--- a/libedit/key.c
+++ /dev/null
@@ -1,691 +0,0 @@
-/*	$NetBSD: key.c,v 1.17 2005/08/08 14:05:37 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)key.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: key.c,v 1.17 2005/08/08 14:05:37 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * key.c: This module contains the procedures for maintaining
- *	  the extended-key map.
- *
- *      An extended-key (key) is a sequence of keystrokes introduced
- *	with a sequence introducer and consisting of an arbitrary
- *	number of characters.  This module maintains a map (the el->el_key.map)
- *	to convert these extended-key sequences into input strs
- *	(XK_STR), editor functions (XK_CMD), or unix commands (XK_EXE).
- *
- *      Warning:
- *	  If key is a substr of some other keys, then the longer
- *	  keys are lost!!  That is, if the keys "abcd" and "abcef"
- *	  are in el->el_key.map, adding the key "abc" will cause the first two
- *	  definitions to be lost.
- *
- *      Restrictions:
- *      -------------
- *      1) It is not possible to have one key that is a
- *	   substr of another.
- */
-#include <string.h>
-#include <stdlib.h>
-
-#include "el.h"
-
-/*
- * The Nodes of the el->el_key.map.  The el->el_key.map is a linked list
- * of these node elements
- */
-struct key_node_t {
-	char		ch;		/* single character of key 	 */
-	int		type;		/* node type			 */
-	key_value_t	val;		/* command code or pointer to str,  */
-					/* if this is a leaf 		 */
-	struct key_node_t *next;	/* ptr to next char of this key  */
-	struct key_node_t *sibling;	/* ptr to another key with same prefix*/
-};
-
-private int		 node_trav(EditLine *, key_node_t *, char *,
-    key_value_t *);
-private int		 node__try(EditLine *, key_node_t *, const char *,
-    key_value_t *, int);
-private key_node_t	*node__get(int);
-private void		 node__free(key_node_t *);
-private void		 node__put(EditLine *, key_node_t *);
-private int		 node__delete(EditLine *, key_node_t **, const char *);
-private int		 node_lookup(EditLine *, const char *, key_node_t *,
-    int);
-private int		 node_enum(EditLine *, key_node_t *, int);
-private int		 key__decode_char(char *, int, int);
-
-#define	KEY_BUFSIZ	EL_BUFSIZ
-
-
-/* key_init():
- *	Initialize the key maps
- */
-protected int
-key_init(EditLine *el)
-{
-
-	el->el_key.buf = (char *) el_malloc(KEY_BUFSIZ);
-	if (el->el_key.buf == NULL)
-		return (-1);
-	el->el_key.map = NULL;
-	key_reset(el);
-	return (0);
-}
-
-/* key_end():
- *	Free the key maps
- */
-protected void
-key_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_key.buf);
-	el->el_key.buf = NULL;
-	node__free(el->el_key.map);
-}
-
-
-/* key_map_cmd():
- *	Associate cmd with a key value
- */
-protected key_value_t *
-key_map_cmd(EditLine *el, int cmd)
-{
-
-	el->el_key.val.cmd = (el_action_t) cmd;
-	return (&el->el_key.val);
-}
-
-
-/* key_map_str():
- *	Associate str with a key value
- */
-protected key_value_t *
-key_map_str(EditLine *el, char *str)
-{
-
-	el->el_key.val.str = str;
-	return (&el->el_key.val);
-}
-
-
-/* key_reset():
- *	Takes all nodes on el->el_key.map and puts them on free list.  Then
- *	initializes el->el_key.map with arrow keys
- *	[Always bind the ansi arrow keys?]
- */
-protected void
-key_reset(EditLine *el)
-{
-
-	node__put(el, el->el_key.map);
-	el->el_key.map = NULL;
-	return;
-}
-
-
-/* key_get():
- *	Calls the recursive function with entry point el->el_key.map
- *      Looks up *ch in map and then reads characters until a
- *      complete match is found or a mismatch occurs. Returns the
- *      type of the match found (XK_STR, XK_CMD, or XK_EXE).
- *      Returns NULL in val.str and XK_STR for no match.
- *      The last character read is returned in *ch.
- */
-protected int
-key_get(EditLine *el, char *ch, key_value_t *val)
-{
-
-	return (node_trav(el, el->el_key.map, ch, val));
-}
-
-
-/* key_add():
- *      Adds key to the el->el_key.map and associates the value in val with it.
- *      If key is already is in el->el_key.map, the new code is applied to the
- *      existing key. Ntype specifies if code is a command, an
- *      out str or a unix command.
- */
-protected void
-key_add(EditLine *el, const char *key, key_value_t *val, int ntype)
-{
-
-	if (key[0] == '\0') {
-		(void) fprintf(el->el_errfile,
-		    "key_add: Null extended-key not allowed.\n");
-		return;
-	}
-	if (ntype == XK_CMD && val->cmd == ED_SEQUENCE_LEAD_IN) {
-		(void) fprintf(el->el_errfile,
-		    "key_add: sequence-lead-in command not allowed\n");
-		return;
-	}
-	if (el->el_key.map == NULL)
-		/* tree is initially empty.  Set up new node to match key[0] */
-		el->el_key.map = node__get(key[0]);
-			/* it is properly initialized */
-
-	/* Now recurse through el->el_key.map */
-	(void) node__try(el, el->el_key.map, key, val, ntype);
-	return;
-}
-
-
-/* key_clear():
- *
- */
-protected void
-key_clear(EditLine *el, el_action_t *map, const char *in)
-{
-
-	if ((map[(unsigned char)*in] == ED_SEQUENCE_LEAD_IN) &&
-	    ((map == el->el_map.key &&
-	    el->el_map.alt[(unsigned char)*in] != ED_SEQUENCE_LEAD_IN) ||
-	    (map == el->el_map.alt &&
-	    el->el_map.key[(unsigned char)*in] != ED_SEQUENCE_LEAD_IN)))
-		(void) key_delete(el, in);
-}
-
-
-/* key_delete():
- *      Delete the key and all longer keys staring with key, if
- *      they exists.
- */
-protected int
-key_delete(EditLine *el, const char *key)
-{
-
-	if (key[0] == '\0') {
-		(void) fprintf(el->el_errfile,
-		    "key_delete: Null extended-key not allowed.\n");
-		return (-1);
-	}
-	if (el->el_key.map == NULL)
-		return (0);
-
-	(void) node__delete(el, &el->el_key.map, key);
-	return (0);
-}
-
-
-/* key_print():
- *	Print the binding associated with key key.
- *	Print entire el->el_key.map if null
- */
-protected void
-key_print(EditLine *el, const char *key)
-{
-
-	/* do nothing if el->el_key.map is empty and null key specified */
-	if (el->el_key.map == NULL && *key == 0)
-		return;
-
-	el->el_key.buf[0] = '"';
-	if (node_lookup(el, key, el->el_key.map, 1) <= -1)
-		/* key is not bound */
-		(void) fprintf(el->el_errfile, "Unbound extended key \"%s\"\n",
-		    key);
-	return;
-}
-
-
-/* node_trav():
- *	recursively traverses node in tree until match or mismatch is
- * 	found.  May read in more characters.
- */
-private int
-node_trav(EditLine *el, key_node_t *ptr, char *ch, key_value_t *val)
-{
-
-	if (ptr->ch == *ch) {
-		/* match found */
-		if (ptr->next) {
-			/* key not complete so get next char */
-			if (el_getc(el, ch) != 1) {	/* if EOF or error */
-				val->cmd = ED_END_OF_FILE;
-				return (XK_CMD);
-				/* PWP: Pretend we just read an end-of-file */
-			}
-			return (node_trav(el, ptr->next, ch, val));
-		} else {
-			*val = ptr->val;
-			if (ptr->type != XK_CMD)
-				*ch = '\0';
-			return (ptr->type);
-		}
-	} else {
-		/* no match found here */
-		if (ptr->sibling) {
-			/* try next sibling */
-			return (node_trav(el, ptr->sibling, ch, val));
-		} else {
-			/* no next sibling -- mismatch */
-			val->str = NULL;
-			return (XK_STR);
-		}
-	}
-}
-
-
-/* node__try():
- * 	Find a node that matches *str or allocate a new one
- */
-private int
-node__try(EditLine *el, key_node_t *ptr, const char *str, key_value_t *val, int ntype)
-{
-
-	if (ptr->ch != *str) {
-		key_node_t *xm;
-
-		for (xm = ptr; xm->sibling != NULL; xm = xm->sibling)
-			if (xm->sibling->ch == *str)
-				break;
-		if (xm->sibling == NULL)
-			xm->sibling = node__get(*str);	/* setup new node */
-		ptr = xm->sibling;
-	}
-	if (*++str == '\0') {
-		/* we're there */
-		if (ptr->next != NULL) {
-			node__put(el, ptr->next);
-				/* lose longer keys with this prefix */
-			ptr->next = NULL;
-		}
-		switch (ptr->type) {
-		case XK_CMD:
-		case XK_NOD:
-			break;
-		case XK_STR:
-		case XK_EXE:
-			if (ptr->val.str)
-				el_free((ptr_t) ptr->val.str);
-			break;
-		default:
-			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n",
-			    ptr->type));
-			break;
-		}
-
-		switch (ptr->type = ntype) {
-		case XK_CMD:
-			ptr->val = *val;
-			break;
-		case XK_STR:
-		case XK_EXE:
-			if ((ptr->val.str = el_strdup(val->str)) == NULL)
-				return -1;
-			break;
-		default:
-			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ntype));
-			break;
-		}
-	} else {
-		/* still more chars to go */
-		if (ptr->next == NULL)
-			ptr->next = node__get(*str);	/* setup new node */
-		(void) node__try(el, ptr->next, str, val, ntype);
-	}
-	return (0);
-}
-
-
-/* node__delete():
- *	Delete node that matches str
- */
-private int
-node__delete(EditLine *el, key_node_t **inptr, const char *str)
-{
-	key_node_t *ptr;
-	key_node_t *prev_ptr = NULL;
-
-	ptr = *inptr;
-
-	if (ptr->ch != *str) {
-		key_node_t *xm;
-
-		for (xm = ptr; xm->sibling != NULL; xm = xm->sibling)
-			if (xm->sibling->ch == *str)
-				break;
-		if (xm->sibling == NULL)
-			return (0);
-		prev_ptr = xm;
-		ptr = xm->sibling;
-	}
-	if (*++str == '\0') {
-		/* we're there */
-		if (prev_ptr == NULL)
-			*inptr = ptr->sibling;
-		else
-			prev_ptr->sibling = ptr->sibling;
-		ptr->sibling = NULL;
-		node__put(el, ptr);
-		return (1);
-	} else if (ptr->next != NULL &&
-	    node__delete(el, &ptr->next, str) == 1) {
-		if (ptr->next != NULL)
-			return (0);
-		if (prev_ptr == NULL)
-			*inptr = ptr->sibling;
-		else
-			prev_ptr->sibling = ptr->sibling;
-		ptr->sibling = NULL;
-		node__put(el, ptr);
-		return (1);
-	} else {
-		return (0);
-	}
-}
-
-
-/* node__put():
- *	Puts a tree of nodes onto free list using free(3).
- */
-private void
-node__put(EditLine *el, key_node_t *ptr)
-{
-	if (ptr == NULL)
-		return;
-
-	if (ptr->next != NULL) {
-		node__put(el, ptr->next);
-		ptr->next = NULL;
-	}
-	node__put(el, ptr->sibling);
-
-	switch (ptr->type) {
-	case XK_CMD:
-	case XK_NOD:
-		break;
-	case XK_EXE:
-	case XK_STR:
-		if (ptr->val.str != NULL)
-			el_free((ptr_t) ptr->val.str);
-		break;
-	default:
-		EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ptr->type));
-		break;
-	}
-	el_free((ptr_t) ptr);
-}
-
-
-/* node__get():
- *	Returns pointer to a key_node_t for ch.
- */
-private key_node_t *
-node__get(int ch)
-{
-	key_node_t *ptr;
-
-	ptr = (key_node_t *) el_malloc((size_t) sizeof(key_node_t));
-	if (ptr == NULL)
-		return NULL;
-	ptr->ch = ch;
-	ptr->type = XK_NOD;
-	ptr->val.str = NULL;
-	ptr->next = NULL;
-	ptr->sibling = NULL;
-	return (ptr);
-}
-
-private void
-node__free(key_node_t *k)
-{
-	if (k == NULL)
-		return;
-	node__free(k->sibling);
-	node__free(k->next);
-	el_free((ptr_t) k);
-}
-
-/* node_lookup():
- *	look for the str starting at node ptr.
- *	Print if last node
- */
-private int
-node_lookup(EditLine *el, const char *str, key_node_t *ptr, int cnt)
-{
-	int ncnt;
-
-	if (ptr == NULL)
-		return (-1);	/* cannot have null ptr */
-
-	if (*str == 0) {
-		/* no more chars in str.  node_enum from here. */
-		(void) node_enum(el, ptr, cnt);
-		return (0);
-	} else {
-		/* If match put this char into el->el_key.buf.  Recurse */
-		if (ptr->ch == *str) {
-			/* match found */
-			ncnt = key__decode_char(el->el_key.buf, cnt,
-			    (unsigned char) ptr->ch);
-			if (ptr->next != NULL)
-				/* not yet at leaf */
-				return (node_lookup(el, str + 1, ptr->next,
-				    ncnt + 1));
-			else {
-			    /* next node is null so key should be complete */
-				if (str[1] == 0) {
-					el->el_key.buf[ncnt + 1] = '"';
-					el->el_key.buf[ncnt + 2] = '\0';
-					key_kprint(el, el->el_key.buf,
-					    &ptr->val, ptr->type);
-					return (0);
-				} else
-					return (-1);
-					/* mismatch -- str still has chars */
-			}
-		} else {
-			/* no match found try sibling */
-			if (ptr->sibling)
-				return (node_lookup(el, str, ptr->sibling,
-				    cnt));
-			else
-				return (-1);
-		}
-	}
-}
-
-
-/* node_enum():
- *	Traverse the node printing the characters it is bound in buffer
- */
-private int
-node_enum(EditLine *el, key_node_t *ptr, int cnt)
-{
-	int ncnt;
-
-	if (cnt >= KEY_BUFSIZ - 5) {	/* buffer too small */
-		el->el_key.buf[++cnt] = '"';
-		el->el_key.buf[++cnt] = '\0';
-		(void) fprintf(el->el_errfile,
-		    "Some extended keys too long for internal print buffer");
-		(void) fprintf(el->el_errfile, " \"%s...\"\n", el->el_key.buf);
-		return (0);
-	}
-	if (ptr == NULL) {
-#ifdef DEBUG_EDIT
-		(void) fprintf(el->el_errfile,
-		    "node_enum: BUG!! Null ptr passed\n!");
-#endif
-		return (-1);
-	}
-	/* put this char at end of str */
-	ncnt = key__decode_char(el->el_key.buf, cnt, (unsigned char) ptr->ch);
-	if (ptr->next == NULL) {
-		/* print this key and function */
-		el->el_key.buf[ncnt + 1] = '"';
-		el->el_key.buf[ncnt + 2] = '\0';
-		key_kprint(el, el->el_key.buf, &ptr->val, ptr->type);
-	} else
-		(void) node_enum(el, ptr->next, ncnt + 1);
-
-	/* go to sibling if there is one */
-	if (ptr->sibling)
-		(void) node_enum(el, ptr->sibling, cnt);
-	return (0);
-}
-
-
-/* key_kprint():
- *	Print the specified key and its associated
- *	function specified by val
- */
-protected void
-key_kprint(EditLine *el, const char *key, key_value_t *val, int ntype)
-{
-	el_bindings_t *fp;
-	char unparsbuf[EL_BUFSIZ];
-	static const char fmt[] = "%-15s->  %s\n";
-
-	if (val != NULL)
-		switch (ntype) {
-		case XK_STR:
-		case XK_EXE:
-			(void) fprintf(el->el_outfile, fmt, key,
-			    key__decode_str(val->str, unparsbuf,
-				ntype == XK_STR ? "\"\"" : "[]"));
-			break;
-		case XK_CMD:
-			for (fp = el->el_map.help; fp->name; fp++)
-				if (val->cmd == fp->func) {
-					(void) fprintf(el->el_outfile, fmt,
-					    key, fp->name);
-					break;
-				}
-#ifdef DEBUG_KEY
-			if (fp->name == NULL)
-				(void) fprintf(el->el_outfile,
-				    "BUG! Command not found.\n");
-#endif
-
-			break;
-		default:
-			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ntype));
-			break;
-		}
-	else
-		(void) fprintf(el->el_outfile, fmt, key, "no input");
-}
-
-
-/* key__decode_char():
- *	Put a printable form of char in buf.
- */
-private int
-key__decode_char(char *buf, int cnt, int ch)
-{
-	if (ch == 0) {
-		buf[cnt++] = '^';
-		buf[cnt] = '@';
-		return (cnt);
-	}
-	if (iscntrl(ch)) {
-		buf[cnt++] = '^';
-		if (ch == '\177')
-			buf[cnt] = '?';
-		else
-			buf[cnt] = ch | 0100;
-	} else if (ch == '^') {
-		buf[cnt++] = '\\';
-		buf[cnt] = '^';
-	} else if (ch == '\\') {
-		buf[cnt++] = '\\';
-		buf[cnt] = '\\';
-	} else if (ch == ' ' || (isprint(ch) && !isspace(ch))) {
-		buf[cnt] = ch;
-	} else {
-		buf[cnt++] = '\\';
-		buf[cnt++] = (((unsigned int) ch >> 6) & 7) + '0';
-		buf[cnt++] = (((unsigned int) ch >> 3) & 7) + '0';
-		buf[cnt] = (ch & 7) + '0';
-	}
-	return (cnt);
-}
-
-
-/* key__decode_str():
- *	Make a printable version of the ey
- */
-protected char *
-key__decode_str(const char *str, char *buf, const char *sep)
-{
-	char *b;
-	const char *p;
-
-	b = buf;
-	if (sep[0] != '\0')
-		*b++ = sep[0];
-	if (*str == 0) {
-		*b++ = '^';
-		*b++ = '@';
-		if (sep[0] != '\0' && sep[1] != '\0')
-			*b++ = sep[1];
-		*b++ = 0;
-		return (buf);
-	}
-	for (p = str; *p != 0; p++) {
-		if (iscntrl((unsigned char) *p)) {
-			*b++ = '^';
-			if (*p == '\177')
-				*b++ = '?';
-			else
-				*b++ = *p | 0100;
-		} else if (*p == '^' || *p == '\\') {
-			*b++ = '\\';
-			*b++ = *p;
-		} else if (*p == ' ' || (isprint((unsigned char) *p) &&
-			!isspace((unsigned char) *p))) {
-			*b++ = *p;
-		} else {
-			*b++ = '\\';
-			*b++ = (((unsigned int) *p >> 6) & 7) + '0';
-			*b++ = (((unsigned int) *p >> 3) & 7) + '0';
-			*b++ = (*p & 7) + '0';
-		}
-	}
-	if (sep[0] != '\0' && sep[1] != '\0')
-		*b++ = sep[1];
-	*b++ = 0;
-	return (buf);		/* should check for overflow */
-}
diff --git a/libedit/key.h b/libedit/key.h
deleted file mode 100644
index 39a075c..0000000
--- a/libedit/key.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/*	$NetBSD: key.h,v 1.8 2003/08/07 16:44:32 agc Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)key.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.key.h: Key macro header
- */
-#ifndef _h_el_key
-#define	_h_el_key
-
-typedef union key_value_t {
-	el_action_t	 cmd;	/* If it is a command the #	*/
-	char		*str;	/* If it is a string...		*/
-} key_value_t;
-
-typedef struct key_node_t key_node_t;
-
-typedef struct el_key_t {
-	char		*buf;	/* Key print buffer		*/
-	key_node_t	*map;	/* Key map			*/
-	key_value_t	 val;	/* Local conversion buffer	*/
-} el_key_t;
-
-#define	XK_CMD	0
-#define	XK_STR	1
-#define	XK_NOD	2
-#define	XK_EXE	3
-
-#undef key_end
-#undef key_clear
-#undef key_print
-
-protected int		 key_init(EditLine *);
-protected void		 key_end(EditLine *);
-protected key_value_t	*key_map_cmd(EditLine *, int);
-protected key_value_t	*key_map_str(EditLine *, char *);
-protected void		 key_reset(EditLine *);
-protected int		 key_get(EditLine *, char *, key_value_t *);
-protected void		 key_add(EditLine *, const char *, key_value_t *, int);
-protected void		 key_clear(EditLine *, el_action_t *, const char *);
-protected int		 key_delete(EditLine *, const char *);
-protected void		 key_print(EditLine *, const char *);
-protected void	         key_kprint(EditLine *, const char *, key_value_t *,
-    int);
-protected char		*key__decode_str(const char *, char *, const char *);
-
-#endif /* _h_el_key */
diff --git a/libedit/makelist b/libedit/makelist
deleted file mode 100644
index f88ccda..0000000
--- a/libedit/makelist
+++ /dev/null
@@ -1,255 +0,0 @@
-#!/bin/sh -
-#	$NetBSD: makelist,v 1.11 2005/10/22 16:45:03 christos Exp $
-#
-# Copyright (c) 1992, 1993
-#	The Regents of the University of California.  All rights reserved.
-#
-# This code is derived from software contributed to Berkeley by
-# Christos Zoulas of Cornell University.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright
-#    notice, this list of conditions and the following disclaimer in the
-#    documentation and/or other materials provided with the distribution.
-# 3. Neither the name of the University nor the names of its contributors
-#    may be used to endorse or promote products derived from this software
-#    without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
-# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
-# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-# SUCH DAMAGE.
-#
-#	@(#)makelist	5.3 (Berkeley) 6/4/93
-
-# makelist.sh: Automatically generate header files...
-
-AWK=awk
-USAGE="Usage: $0 -h|-e|-fc|-fh|-bc|-bh|-m <filenames>"
-
-# Avoid locale dependent case conversions and always use ascii.
-# (for example the script won't work in Turkish locale without this setting)
-LC_ALL=C; LANG=C
-export LC_ALL LANG
-
-
-if [ "x$1" = "x" ]
-then
-    echo $USAGE 1>&2
-    exit 1
-fi
-
-FLAG="$1"
-shift
-
-FILES="$@"
-
-case $FLAG in
-
-#	generate foo.h file from foo.c
-#
--h)
-    set - `echo $FILES | sed -e 's/\\./_/g'`
-    hdr="_h_`basename $1`"
-    cat $FILES | $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#ifndef %s\n#define %s\n", "'$hdr'", "'$hdr'");
-	}
-	/\(\):/ {
-	    pr = substr($2, 1, 2);
-	    if (pr == "vi" || pr == "em" || pr == "ed") {
-		name = substr($2, 1, length($2) - 3);
-#
-# XXX:	need a space between name and prototype so that -fc and -fh
-#	parsing is much easier
-#
-		printf("protected el_action_t\t%s (EditLine *, int);\n", name);
-	    }
-	}
-	END {
-	    printf("#endif /* %s */\n", "'$hdr'");
-	}'
-	;;
-
-#	generate help.c from various .c files
-#
--bc)
-    cat $FILES | $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#include \"sys.h\"\n#include \"el.h\"\n");
-	    printf("private const struct el_bindings_t el_func_help[] = {\n");
-	    low = "abcdefghijklmnopqrstuvwxyz_";
-	    high = "ABCDEFGHIJKLMNOPQRSTUVWXYZ_";
-	    for (i = 1; i <= length(low); i++)
-		tr[substr(low, i, 1)] = substr(high, i, 1);
-	}
-	/\(\):/ {
-	    pr = substr($2, 1, 2);
-	    if (pr == "vi" || pr == "em" || pr == "ed") {
-		name = substr($2, 1, length($2) - 3);
-		uname = "";
-		fname = "";
-		for (i = 1; i <= length(name); i++) {
-		    s = substr(name, i, 1);
-		    uname = uname tr[s];
-		    if (s == "_")
-			s = "-";
-		    fname = fname s;
-		}
-
-		printf("    { %-30.30s %-30.30s\n","\"" fname "\",", uname ",");
-		ok = 1;
-	    }
-	}
-	/^ \*/ {
-	    if (ok) {
-		printf("      \"");
-		for (i = 2; i < NF; i++)
-		    printf("%s ", $i);
-		printf("%s\" },\n", $i);
-		ok = 0;
-	    }
-	}
-	END {
-	    printf("};\n");
-	    printf("\nprotected const el_bindings_t* help__get()");
-	    printf("{ return el_func_help; }\n");
-	}'
-	;;
-
-#	generate help.h from various .c files
-#
--bh)
-    $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#ifndef _h_help_c\n#define _h_help_c\n");
-	    printf("protected const el_bindings_t *help__get(void);\n");
-	    printf("#endif /* _h_help_c */\n");
-	}' /dev/null
-	;;
-
-#	generate fcns.h from various .h files
-#
--fh)
-    cat $FILES | $AWK '/el_action_t/ { print $3 }' | \
-    sort | tr '[:lower:]' '[:upper:]' | $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#ifndef _h_fcns_c\n#define _h_fcns_c\n");
-	    count = 0;
-	}
-	{
-	    printf("#define\t%-30.30s\t%3d\n", $1, count++);
-	}
-	END {
-	    printf("#define\t%-30.30s\t%3d\n", "EL_NUM_FCNS", count);
-
-	    printf("typedef el_action_t (*el_func_t)(EditLine *, int);");
-	    printf("\nprotected const el_func_t* func__get(void);\n");
-	    printf("#endif /* _h_fcns_c */\n");
-	}'
-	;;
-
-#	generate fcns.c from various .h files
-#
--fc)
-    cat $FILES | $AWK '/el_action_t/ { print $3 }' | sort | $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#include \"sys.h\"\n#include \"el.h\"\n");
-	    printf("private const el_func_t el_func[] = {");
-	    maxlen = 80;
-	    needn = 1;
-	    len = 0;
-	}
-	{
-	    clen = 25 + 2;
-	    len += clen;
-	    if (len >= maxlen)
-		needn = 1;
-	    if (needn) {
-		printf("\n    ");
-		needn = 0;
-		len = 4 + clen;
-	    }
-	    s = $1 ",";
-	    printf("%-26.26s ", s);
-	}
-	END {
-	    printf("\n};\n");
-	    printf("\nprotected const el_func_t* func__get() { return el_func; }\n");
-	}'
-	;;
-
-#	generate editline.c from various .c files
-#
--e)
-	echo "$FILES" | tr ' ' '\012' | $AWK '
-	BEGIN {
-	    printf("/* Automatically generated file, do not edit */\n");
-	    printf("#define protected static\n");
-	    printf("#define SCCSID\n");
-	}
-	{
-	    printf("#include \"%s\"\n", $1);
-	}'
-	;;
-
-#	generate man page fragment from various .c files
-#
--m)
-    cat $FILES | $AWK '
-	BEGIN {
-	    printf(".\\\" Section automatically generated with makelist\n");
-	    printf(".Bl -tag -width 4n\n");
-	}
-	/\(\):/ {
-	    pr = substr($2, 1, 2);
-	    if (pr == "vi" || pr == "em" || pr == "ed") {
-		name = substr($2, 1, length($2) - 3);
-		fname = "";
-		for (i = 1; i <= length(name); i++) {
-		    s = substr(name, i, 1);
-		    if (s == "_")
-			s = "-";
-		    fname = fname s;
-		}
-
-		printf(".It Ic %s\n", fname);
-		ok = 1;
-	    }
-	}
-	/^ \*/ {
-	    if (ok) {
-		for (i = 2; i < NF; i++)
-		    printf("%s ", $i);
-		printf("%s.\n", $i);
-		ok = 0;
-	    }
-	}
-	END {
-	    printf(".El\n");
-	    printf(".\\\" End of section automatically generated with makelist\n");
-	}'
-	;;
-
-*)
-    echo $USAGE 1>&2
-    exit 1
-    ;;
-
-esac
diff --git a/libedit/map.c b/libedit/map.c
deleted file mode 100644
index 399aa30..0000000
--- a/libedit/map.c
+++ /dev/null
@@ -1,1415 +0,0 @@
-/*	$NetBSD: map.c,v 1.22 2005/08/09 13:58:44 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)map.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: map.c,v 1.22 2005/08/09 13:58:44 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * map.c: Editor function definitions
- */
-#include <stdlib.h>
-#include "el.h"
-
-#define	N_KEYS 256
-
-private void	map_print_key(EditLine *, el_action_t *, const char *);
-private void	map_print_some_keys(EditLine *, el_action_t *, int, int);
-private void	map_print_all_keys(EditLine *);
-private void	map_init_nls(EditLine *);
-private void	map_init_meta(EditLine *);
-
-/* keymap tables ; should be N_KEYS*sizeof(KEYCMD) bytes long */
-
-
-private const el_action_t  el_map_emacs[] = {
-	/*   0 */	EM_SET_MARK,		/* ^@ */
-	/*   1 */	ED_MOVE_TO_BEG,		/* ^A */
-	/*   2 */	ED_PREV_CHAR,		/* ^B */
-	/*   3 */	ED_TTY_SIGINT,		/* ^C */
-	/*   4 */	EM_DELETE_OR_LIST,	/* ^D */
-	/*   5 */	ED_MOVE_TO_END,		/* ^E */
-	/*   6 */	ED_NEXT_CHAR,		/* ^F */
-	/*   7 */	ED_UNASSIGNED,		/* ^G */
-	/*   8 */	EM_DELETE_PREV_CHAR,	/* ^H */
-	/*   9 */	ED_UNASSIGNED,		/* ^I */
-	/*  10 */	ED_NEWLINE,		/* ^J */
-	/*  11 */	ED_KILL_LINE,		/* ^K */
-	/*  12 */	ED_CLEAR_SCREEN,	/* ^L */
-	/*  13 */	ED_NEWLINE,		/* ^M */
-	/*  14 */	ED_NEXT_HISTORY,	/* ^N */
-	/*  15 */	ED_TTY_FLUSH_OUTPUT,	/* ^O */
-	/*  16 */	ED_PREV_HISTORY,	/* ^P */
-	/*  17 */	ED_TTY_START_OUTPUT,	/* ^Q */
-	/*  18 */	ED_REDISPLAY,		/* ^R */
-	/*  19 */	ED_TTY_STOP_OUTPUT,	/* ^S */
-	/*  20 */	ED_TRANSPOSE_CHARS,	/* ^T */
-	/*  21 */	EM_KILL_LINE,		/* ^U */
-	/*  22 */	ED_QUOTED_INSERT,	/* ^V */
-	/*  23 */	EM_KILL_REGION,		/* ^W */
-	/*  24 */	ED_SEQUENCE_LEAD_IN,	/* ^X */
-	/*  25 */	EM_YANK,		/* ^Y */
-	/*  26 */	ED_TTY_SIGTSTP,		/* ^Z */
-	/*  27 */	EM_META_NEXT,		/* ^[ */
-	/*  28 */	ED_TTY_SIGQUIT,		/* ^\ */
-	/*  29 */	ED_TTY_DSUSP,		/* ^] */
-	/*  30 */	ED_UNASSIGNED,		/* ^^ */
-	/*  31 */	ED_UNASSIGNED,		/* ^_ */
-	/*  32 */	ED_INSERT,		/* SPACE */
-	/*  33 */	ED_INSERT,		/* ! */
-	/*  34 */	ED_INSERT,		/* " */
-	/*  35 */	ED_INSERT,		/* # */
-	/*  36 */	ED_INSERT,		/* $ */
-	/*  37 */	ED_INSERT,		/* % */
-	/*  38 */	ED_INSERT,		/* & */
-	/*  39 */	ED_INSERT,		/* ' */
-	/*  40 */	ED_INSERT,		/* ( */
-	/*  41 */	ED_INSERT,		/* ) */
-	/*  42 */	ED_INSERT,		/* * */
-	/*  43 */	ED_INSERT,		/* + */
-	/*  44 */	ED_INSERT,		/* , */
-	/*  45 */	ED_INSERT,		/* - */
-	/*  46 */	ED_INSERT,		/* . */
-	/*  47 */	ED_INSERT,		/* / */
-	/*  48 */	ED_DIGIT,		/* 0 */
-	/*  49 */	ED_DIGIT,		/* 1 */
-	/*  50 */	ED_DIGIT,		/* 2 */
-	/*  51 */	ED_DIGIT,		/* 3 */
-	/*  52 */	ED_DIGIT,		/* 4 */
-	/*  53 */	ED_DIGIT,		/* 5 */
-	/*  54 */	ED_DIGIT,		/* 6 */
-	/*  55 */	ED_DIGIT,		/* 7 */
-	/*  56 */	ED_DIGIT,		/* 8 */
-	/*  57 */	ED_DIGIT,		/* 9 */
-	/*  58 */	ED_INSERT,		/* : */
-	/*  59 */	ED_INSERT,		/* ; */
-	/*  60 */	ED_INSERT,		/* < */
-	/*  61 */	ED_INSERT,		/* = */
-	/*  62 */	ED_INSERT,		/* > */
-	/*  63 */	ED_INSERT,		/* ? */
-	/*  64 */	ED_INSERT,		/* @ */
-	/*  65 */	ED_INSERT,		/* A */
-	/*  66 */	ED_INSERT,		/* B */
-	/*  67 */	ED_INSERT,		/* C */
-	/*  68 */	ED_INSERT,		/* D */
-	/*  69 */	ED_INSERT,		/* E */
-	/*  70 */	ED_INSERT,		/* F */
-	/*  71 */	ED_INSERT,		/* G */
-	/*  72 */	ED_INSERT,		/* H */
-	/*  73 */	ED_INSERT,		/* I */
-	/*  74 */	ED_INSERT,		/* J */
-	/*  75 */	ED_INSERT,		/* K */
-	/*  76 */	ED_INSERT,		/* L */
-	/*  77 */	ED_INSERT,		/* M */
-	/*  78 */	ED_INSERT,		/* N */
-	/*  79 */	ED_INSERT,		/* O */
-	/*  80 */	ED_INSERT,		/* P */
-	/*  81 */	ED_INSERT,		/* Q */
-	/*  82 */	ED_INSERT,		/* R */
-	/*  83 */	ED_INSERT,		/* S */
-	/*  84 */	ED_INSERT,		/* T */
-	/*  85 */	ED_INSERT,		/* U */
-	/*  86 */	ED_INSERT,		/* V */
-	/*  87 */	ED_INSERT,		/* W */
-	/*  88 */	ED_INSERT,		/* X */
-	/*  89 */	ED_INSERT,		/* Y */
-	/*  90 */	ED_INSERT,		/* Z */
-	/*  91 */	ED_INSERT,		/* [ */
-	/*  92 */	ED_INSERT,		/* \ */
-	/*  93 */	ED_INSERT,		/* ] */
-	/*  94 */	ED_INSERT,		/* ^ */
-	/*  95 */	ED_INSERT,		/* _ */
-	/*  96 */	ED_INSERT,		/* ` */
-	/*  97 */	ED_INSERT,		/* a */
-	/*  98 */	ED_INSERT,		/* b */
-	/*  99 */	ED_INSERT,		/* c */
-	/* 100 */	ED_INSERT,		/* d */
-	/* 101 */	ED_INSERT,		/* e */
-	/* 102 */	ED_INSERT,		/* f */
-	/* 103 */	ED_INSERT,		/* g */
-	/* 104 */	ED_INSERT,		/* h */
-	/* 105 */	ED_INSERT,		/* i */
-	/* 106 */	ED_INSERT,		/* j */
-	/* 107 */	ED_INSERT,		/* k */
-	/* 108 */	ED_INSERT,		/* l */
-	/* 109 */	ED_INSERT,		/* m */
-	/* 110 */	ED_INSERT,		/* n */
-	/* 111 */	ED_INSERT,		/* o */
-	/* 112 */	ED_INSERT,		/* p */
-	/* 113 */	ED_INSERT,		/* q */
-	/* 114 */	ED_INSERT,		/* r */
-	/* 115 */	ED_INSERT,		/* s */
-	/* 116 */	ED_INSERT,		/* t */
-	/* 117 */	ED_INSERT,		/* u */
-	/* 118 */	ED_INSERT,		/* v */
-	/* 119 */	ED_INSERT,		/* w */
-	/* 120 */	ED_INSERT,		/* x */
-	/* 121 */	ED_INSERT,		/* y */
-	/* 122 */	ED_INSERT,		/* z */
-	/* 123 */	ED_INSERT,		/* { */
-	/* 124 */	ED_INSERT,		/* | */
-	/* 125 */	ED_INSERT,		/* } */
-	/* 126 */	ED_INSERT,		/* ~ */
-	/* 127 */	EM_DELETE_PREV_CHAR,	/* ^? */
-	/* 128 */	ED_UNASSIGNED,		/* M-^@ */
-	/* 129 */	ED_UNASSIGNED,		/* M-^A */
-	/* 130 */	ED_UNASSIGNED,		/* M-^B */
-	/* 131 */	ED_UNASSIGNED,		/* M-^C */
-	/* 132 */	ED_UNASSIGNED,		/* M-^D */
-	/* 133 */	ED_UNASSIGNED,		/* M-^E */
-	/* 134 */	ED_UNASSIGNED,		/* M-^F */
-	/* 135 */	ED_UNASSIGNED,		/* M-^G */
-	/* 136 */	ED_DELETE_PREV_WORD,	/* M-^H */
-	/* 137 */	ED_UNASSIGNED,		/* M-^I */
-	/* 138 */	ED_UNASSIGNED,		/* M-^J */
-	/* 139 */	ED_UNASSIGNED,		/* M-^K */
-	/* 140 */	ED_CLEAR_SCREEN,	/* M-^L */
-	/* 141 */	ED_UNASSIGNED,		/* M-^M */
-	/* 142 */	ED_UNASSIGNED,		/* M-^N */
-	/* 143 */	ED_UNASSIGNED,		/* M-^O */
-	/* 144 */	ED_UNASSIGNED,		/* M-^P */
-	/* 145 */	ED_UNASSIGNED,		/* M-^Q */
-	/* 146 */	ED_UNASSIGNED,		/* M-^R */
-	/* 147 */	ED_UNASSIGNED,		/* M-^S */
-	/* 148 */	ED_UNASSIGNED,		/* M-^T */
-	/* 149 */	ED_UNASSIGNED,		/* M-^U */
-	/* 150 */	ED_UNASSIGNED,		/* M-^V */
-	/* 151 */	ED_UNASSIGNED,		/* M-^W */
-	/* 152 */	ED_UNASSIGNED,		/* M-^X */
-	/* 153 */	ED_UNASSIGNED,		/* M-^Y */
-	/* 154 */	ED_UNASSIGNED,		/* M-^Z */
-	/* 155 */	ED_UNASSIGNED,		/* M-^[ */
-	/* 156 */	ED_UNASSIGNED,		/* M-^\ */
-	/* 157 */	ED_UNASSIGNED,		/* M-^] */
-	/* 158 */	ED_UNASSIGNED,		/* M-^^ */
-	/* 159 */	EM_COPY_PREV_WORD,	/* M-^_ */
-	/* 160 */	ED_UNASSIGNED,		/* M-SPACE */
-	/* 161 */	ED_UNASSIGNED,		/* M-! */
-	/* 162 */	ED_UNASSIGNED,		/* M-" */
-	/* 163 */	ED_UNASSIGNED,		/* M-# */
-	/* 164 */	ED_UNASSIGNED,		/* M-$ */
-	/* 165 */	ED_UNASSIGNED,		/* M-% */
-	/* 166 */	ED_UNASSIGNED,		/* M-& */
-	/* 167 */	ED_UNASSIGNED,		/* M-' */
-	/* 168 */	ED_UNASSIGNED,		/* M-( */
-	/* 169 */	ED_UNASSIGNED,		/* M-) */
-	/* 170 */	ED_UNASSIGNED,		/* M-* */
-	/* 171 */	ED_UNASSIGNED,		/* M-+ */
-	/* 172 */	ED_UNASSIGNED,		/* M-, */
-	/* 173 */	ED_UNASSIGNED,		/* M-- */
-	/* 174 */	ED_UNASSIGNED,		/* M-. */
-	/* 175 */	ED_UNASSIGNED,		/* M-/ */
-	/* 176 */	ED_ARGUMENT_DIGIT,	/* M-0 */
-	/* 177 */	ED_ARGUMENT_DIGIT,	/* M-1 */
-	/* 178 */	ED_ARGUMENT_DIGIT,	/* M-2 */
-	/* 179 */	ED_ARGUMENT_DIGIT,	/* M-3 */
-	/* 180 */	ED_ARGUMENT_DIGIT,	/* M-4 */
-	/* 181 */	ED_ARGUMENT_DIGIT,	/* M-5 */
-	/* 182 */	ED_ARGUMENT_DIGIT,	/* M-6 */
-	/* 183 */	ED_ARGUMENT_DIGIT,	/* M-7 */
-	/* 184 */	ED_ARGUMENT_DIGIT,	/* M-8 */
-	/* 185 */	ED_ARGUMENT_DIGIT,	/* M-9 */
-	/* 186 */	ED_UNASSIGNED,		/* M-: */
-	/* 187 */	ED_UNASSIGNED,		/* M-; */
-	/* 188 */	ED_UNASSIGNED,		/* M-< */
-	/* 189 */	ED_UNASSIGNED,		/* M-= */
-	/* 190 */	ED_UNASSIGNED,		/* M-> */
-	/* 191 */	ED_UNASSIGNED,		/* M-? */
-	/* 192 */	ED_UNASSIGNED,		/* M-@ */
-	/* 193 */	ED_UNASSIGNED,		/* M-A */
-	/* 194 */	ED_PREV_WORD,		/* M-B */
-	/* 195 */	EM_CAPITOL_CASE,	/* M-C */
-	/* 196 */	EM_DELETE_NEXT_WORD,	/* M-D */
-	/* 197 */	ED_UNASSIGNED,		/* M-E */
-	/* 198 */	EM_NEXT_WORD,		/* M-F */
-	/* 199 */	ED_UNASSIGNED,		/* M-G */
-	/* 200 */	ED_UNASSIGNED,		/* M-H */
-	/* 201 */	ED_UNASSIGNED,		/* M-I */
-	/* 202 */	ED_UNASSIGNED,		/* M-J */
-	/* 203 */	ED_UNASSIGNED,		/* M-K */
-	/* 204 */	EM_LOWER_CASE,		/* M-L */
-	/* 205 */	ED_UNASSIGNED,		/* M-M */
-	/* 206 */	ED_SEARCH_NEXT_HISTORY,	/* M-N */
-	/* 207 */	ED_SEQUENCE_LEAD_IN,	/* M-O */
-	/* 208 */	ED_SEARCH_PREV_HISTORY,	/* M-P */
-	/* 209 */	ED_UNASSIGNED,		/* M-Q */
-	/* 210 */	ED_UNASSIGNED,		/* M-R */
-	/* 211 */	ED_UNASSIGNED,		/* M-S */
-	/* 212 */	ED_UNASSIGNED,		/* M-T */
-	/* 213 */	EM_UPPER_CASE,		/* M-U */
-	/* 214 */	ED_UNASSIGNED,		/* M-V */
-	/* 215 */	EM_COPY_REGION,		/* M-W */
-	/* 216 */	ED_COMMAND,		/* M-X */
-	/* 217 */	ED_UNASSIGNED,		/* M-Y */
-	/* 218 */	ED_UNASSIGNED,		/* M-Z */
-	/* 219 */	ED_SEQUENCE_LEAD_IN,	/* M-[ */
-	/* 220 */	ED_UNASSIGNED,		/* M-\ */
-	/* 221 */	ED_UNASSIGNED,		/* M-] */
-	/* 222 */	ED_UNASSIGNED,		/* M-^ */
-	/* 223 */	ED_UNASSIGNED,		/* M-_ */
-	/* 223 */	ED_UNASSIGNED,		/* M-` */
-	/* 224 */	ED_UNASSIGNED,		/* M-a */
-	/* 225 */	ED_PREV_WORD,		/* M-b */
-	/* 226 */	EM_CAPITOL_CASE,	/* M-c */
-	/* 227 */	EM_DELETE_NEXT_WORD,	/* M-d */
-	/* 228 */	ED_UNASSIGNED,		/* M-e */
-	/* 229 */	EM_NEXT_WORD,		/* M-f */
-	/* 230 */	ED_UNASSIGNED,		/* M-g */
-	/* 231 */	ED_UNASSIGNED,		/* M-h */
-	/* 232 */	ED_UNASSIGNED,		/* M-i */
-	/* 233 */	ED_UNASSIGNED,		/* M-j */
-	/* 234 */	ED_UNASSIGNED,		/* M-k */
-	/* 235 */	EM_LOWER_CASE,		/* M-l */
-	/* 236 */	ED_UNASSIGNED,		/* M-m */
-	/* 237 */	ED_SEARCH_NEXT_HISTORY,	/* M-n */
-	/* 238 */	ED_UNASSIGNED,		/* M-o */
-	/* 239 */	ED_SEARCH_PREV_HISTORY,	/* M-p */
-	/* 240 */	ED_UNASSIGNED,		/* M-q */
-	/* 241 */	ED_UNASSIGNED,		/* M-r */
-	/* 242 */	ED_UNASSIGNED,		/* M-s */
-	/* 243 */	ED_UNASSIGNED,		/* M-t */
-	/* 244 */	EM_UPPER_CASE,		/* M-u */
-	/* 245 */	ED_UNASSIGNED,		/* M-v */
-	/* 246 */	EM_COPY_REGION,		/* M-w */
-	/* 247 */	ED_COMMAND,		/* M-x */
-	/* 248 */	ED_UNASSIGNED,		/* M-y */
-	/* 249 */	ED_UNASSIGNED,		/* M-z */
-	/* 250 */	ED_UNASSIGNED,		/* M-{ */
-	/* 251 */	ED_UNASSIGNED,		/* M-| */
-	/* 252 */	ED_UNASSIGNED,		/* M-} */
-	/* 253 */	ED_UNASSIGNED,		/* M-~ */
-	/* 254 */	ED_DELETE_PREV_WORD	/* M-^? */
-	/* 255 */
-};
-
-
-/*
- * keymap table for vi.  Each index into above tbl; should be
- * N_KEYS entries long.  Vi mode uses a sticky-extend to do command mode:
- * insert mode characters are in the normal keymap, and command mode
- * in the extended keymap.
- */
-private const el_action_t  el_map_vi_insert[] = {
-#ifdef KSHVI
-	/*   0 */	ED_UNASSIGNED,		/* ^@ */
-	/*   1 */	ED_INSERT,		/* ^A */
-	/*   2 */	ED_INSERT,		/* ^B */
-	/*   3 */	ED_INSERT,		/* ^C */
-	/*   4 */	VI_LIST_OR_EOF,		/* ^D */
-	/*   5 */	ED_INSERT,		/* ^E */
-	/*   6 */	ED_INSERT,		/* ^F */
-	/*   7 */	ED_INSERT,		/* ^G */
-	/*   8 */	VI_DELETE_PREV_CHAR,	/* ^H */   /* BackSpace key */
-	/*   9 */	ED_INSERT,		/* ^I */   /* Tab Key  */
-	/*  10 */	ED_NEWLINE,		/* ^J */
-	/*  11 */	ED_INSERT,		/* ^K */
-	/*  12 */	ED_INSERT,		/* ^L */
-	/*  13 */	ED_NEWLINE,		/* ^M */
-	/*  14 */	ED_INSERT,		/* ^N */
-	/*  15 */	ED_INSERT,		/* ^O */
-	/*  16 */	ED_INSERT,		/* ^P */
-	/*  17 */	ED_TTY_START_OUTPUT,	/* ^Q */
-	/*  18 */	ED_INSERT,		/* ^R */
-	/*  19 */	ED_TTY_STOP_OUTPUT,	/* ^S */
-	/*  20 */	ED_INSERT,		/* ^T */
-	/*  21 */	VI_KILL_LINE_PREV,	/* ^U */
-	/*  22 */	ED_QUOTED_INSERT,	/* ^V */
-	/*  23 */	ED_DELETE_PREV_WORD,	/* ^W */
-		/* ED_DELETE_PREV_WORD: Only until strt edit pos */
-	/*  24 */	ED_INSERT,		/* ^X */
-	/*  25 */	ED_INSERT,		/* ^Y */
-	/*  26 */	ED_INSERT,		/* ^Z */
-	/*  27 */	VI_COMMAND_MODE,	/* ^[ */  /* [ Esc ] key */
-	/*  28 */	ED_TTY_SIGQUIT,		/* ^\ */
-	/*  29 */	ED_INSERT,		/* ^] */
-	/*  30 */	ED_INSERT,		/* ^^ */
-	/*  31 */	ED_INSERT,		/* ^_ */
-#else /* !KSHVI */
-				/*
-				 * NOTE: These mappings do NOT Correspond well
-				 * to the KSH VI editing assignments.
-				 * On the other and they are convenient and
-				 * many people have have gotten used to them.
-				 */
-	/*   0 */	ED_UNASSIGNED,		/* ^@ */
-	/*   1 */	ED_MOVE_TO_BEG,		/* ^A */
-	/*   2 */	ED_PREV_CHAR,		/* ^B */
-	/*   3 */	ED_TTY_SIGINT,		/* ^C */
-	/*   4 */	VI_LIST_OR_EOF,		/* ^D */
-	/*   5 */	ED_MOVE_TO_END,		/* ^E */
-	/*   6 */	ED_NEXT_CHAR,		/* ^F */
-	/*   7 */	ED_UNASSIGNED,		/* ^G */
-	/*   8 */	VI_DELETE_PREV_CHAR,	/* ^H */   /* BackSpace key */
-	/*   9 */	ED_UNASSIGNED,		/* ^I */   /* Tab Key */
-	/*  10 */	ED_NEWLINE,		/* ^J */
-	/*  11 */	ED_KILL_LINE,		/* ^K */
-	/*  12 */	ED_CLEAR_SCREEN,	/* ^L */
-	/*  13 */	ED_NEWLINE,		/* ^M */
-	/*  14 */	ED_NEXT_HISTORY,	/* ^N */
-	/*  15 */	ED_TTY_FLUSH_OUTPUT,	/* ^O */
-	/*  16 */	ED_PREV_HISTORY,	/* ^P */
-	/*  17 */	ED_TTY_START_OUTPUT,	/* ^Q */
-	/*  18 */	ED_REDISPLAY,		/* ^R */
-	/*  19 */	ED_TTY_STOP_OUTPUT,	/* ^S */
-	/*  20 */	ED_TRANSPOSE_CHARS,	/* ^T */
-	/*  21 */	VI_KILL_LINE_PREV,	/* ^U */
-	/*  22 */	ED_QUOTED_INSERT,	/* ^V */
-	/*  23 */	ED_DELETE_PREV_WORD,	/* ^W */
-	/*  24 */	ED_UNASSIGNED,		/* ^X */
-	/*  25 */	ED_TTY_DSUSP,		/* ^Y */
-	/*  26 */	ED_TTY_SIGTSTP,		/* ^Z */
-	/*  27 */	VI_COMMAND_MODE,	/* ^[ */
-	/*  28 */	ED_TTY_SIGQUIT,		/* ^\ */
-	/*  29 */	ED_UNASSIGNED,		/* ^] */
-	/*  30 */	ED_UNASSIGNED,		/* ^^ */
-	/*  31 */	ED_UNASSIGNED,		/* ^_ */
-#endif  /* KSHVI */
-	/*  32 */	ED_INSERT,		/* SPACE */
-	/*  33 */	ED_INSERT,		/* ! */
-	/*  34 */	ED_INSERT,		/* " */
-	/*  35 */	ED_INSERT,		/* # */
-	/*  36 */	ED_INSERT,		/* $ */
-	/*  37 */	ED_INSERT,		/* % */
-	/*  38 */	ED_INSERT,		/* & */
-	/*  39 */	ED_INSERT,		/* ' */
-	/*  40 */	ED_INSERT,		/* ( */
-	/*  41 */	ED_INSERT,		/* ) */
-	/*  42 */	ED_INSERT,		/* * */
-	/*  43 */	ED_INSERT,		/* + */
-	/*  44 */	ED_INSERT,		/* , */
-	/*  45 */	ED_INSERT,		/* - */
-	/*  46 */	ED_INSERT,		/* . */
-	/*  47 */	ED_INSERT,		/* / */
-	/*  48 */	ED_INSERT,		/* 0 */
-	/*  49 */	ED_INSERT,		/* 1 */
-	/*  50 */	ED_INSERT,		/* 2 */
-	/*  51 */	ED_INSERT,		/* 3 */
-	/*  52 */	ED_INSERT,		/* 4 */
-	/*  53 */	ED_INSERT,		/* 5 */
-	/*  54 */	ED_INSERT,		/* 6 */
-	/*  55 */	ED_INSERT,		/* 7 */
-	/*  56 */	ED_INSERT,		/* 8 */
-	/*  57 */	ED_INSERT,		/* 9 */
-	/*  58 */	ED_INSERT,		/* : */
-	/*  59 */	ED_INSERT,		/* ; */
-	/*  60 */	ED_INSERT,		/* < */
-	/*  61 */	ED_INSERT,		/* = */
-	/*  62 */	ED_INSERT,		/* > */
-	/*  63 */	ED_INSERT,		/* ? */
-	/*  64 */	ED_INSERT,		/* @ */
-	/*  65 */	ED_INSERT,		/* A */
-	/*  66 */	ED_INSERT,		/* B */
-	/*  67 */	ED_INSERT,		/* C */
-	/*  68 */	ED_INSERT,		/* D */
-	/*  69 */	ED_INSERT,		/* E */
-	/*  70 */	ED_INSERT,		/* F */
-	/*  71 */	ED_INSERT,		/* G */
-	/*  72 */	ED_INSERT,		/* H */
-	/*  73 */	ED_INSERT,		/* I */
-	/*  74 */	ED_INSERT,		/* J */
-	/*  75 */	ED_INSERT,		/* K */
-	/*  76 */	ED_INSERT,		/* L */
-	/*  77 */	ED_INSERT,		/* M */
-	/*  78 */	ED_INSERT,		/* N */
-	/*  79 */	ED_INSERT,		/* O */
-	/*  80 */	ED_INSERT,		/* P */
-	/*  81 */	ED_INSERT,		/* Q */
-	/*  82 */	ED_INSERT,		/* R */
-	/*  83 */	ED_INSERT,		/* S */
-	/*  84 */	ED_INSERT,		/* T */
-	/*  85 */	ED_INSERT,		/* U */
-	/*  86 */	ED_INSERT,		/* V */
-	/*  87 */	ED_INSERT,		/* W */
-	/*  88 */	ED_INSERT,		/* X */
-	/*  89 */	ED_INSERT,		/* Y */
-	/*  90 */	ED_INSERT,		/* Z */
-	/*  91 */	ED_INSERT,		/* [ */
-	/*  92 */	ED_INSERT,		/* \ */
-	/*  93 */	ED_INSERT,		/* ] */
-	/*  94 */	ED_INSERT,		/* ^ */
-	/*  95 */	ED_INSERT,		/* _ */
-	/*  96 */	ED_INSERT,		/* ` */
-	/*  97 */	ED_INSERT,		/* a */
-	/*  98 */	ED_INSERT,		/* b */
-	/*  99 */	ED_INSERT,		/* c */
-	/* 100 */	ED_INSERT,		/* d */
-	/* 101 */	ED_INSERT,		/* e */
-	/* 102 */	ED_INSERT,		/* f */
-	/* 103 */	ED_INSERT,		/* g */
-	/* 104 */	ED_INSERT,		/* h */
-	/* 105 */	ED_INSERT,		/* i */
-	/* 106 */	ED_INSERT,		/* j */
-	/* 107 */	ED_INSERT,		/* k */
-	/* 108 */	ED_INSERT,		/* l */
-	/* 109 */	ED_INSERT,		/* m */
-	/* 110 */	ED_INSERT,		/* n */
-	/* 111 */	ED_INSERT,		/* o */
-	/* 112 */	ED_INSERT,		/* p */
-	/* 113 */	ED_INSERT,		/* q */
-	/* 114 */	ED_INSERT,		/* r */
-	/* 115 */	ED_INSERT,		/* s */
-	/* 116 */	ED_INSERT,		/* t */
-	/* 117 */	ED_INSERT,		/* u */
-	/* 118 */	ED_INSERT,		/* v */
-	/* 119 */	ED_INSERT,		/* w */
-	/* 120 */	ED_INSERT,		/* x */
-	/* 121 */	ED_INSERT,		/* y */
-	/* 122 */	ED_INSERT,		/* z */
-	/* 123 */	ED_INSERT,		/* { */
-	/* 124 */	ED_INSERT,		/* | */
-	/* 125 */	ED_INSERT,		/* } */
-	/* 126 */	ED_INSERT,		/* ~ */
-	/* 127 */	VI_DELETE_PREV_CHAR,	/* ^? */
-	/* 128 */	ED_INSERT,		/* M-^@ */
-	/* 129 */	ED_INSERT,		/* M-^A */
-	/* 130 */	ED_INSERT,		/* M-^B */
-	/* 131 */	ED_INSERT,		/* M-^C */
-	/* 132 */	ED_INSERT,		/* M-^D */
-	/* 133 */	ED_INSERT,		/* M-^E */
-	/* 134 */	ED_INSERT,		/* M-^F */
-	/* 135 */	ED_INSERT,		/* M-^G */
-	/* 136 */	ED_INSERT,		/* M-^H */
-	/* 137 */	ED_INSERT,		/* M-^I */
-	/* 138 */	ED_INSERT,		/* M-^J */
-	/* 139 */	ED_INSERT,		/* M-^K */
-	/* 140 */	ED_INSERT,		/* M-^L */
-	/* 141 */	ED_INSERT,		/* M-^M */
-	/* 142 */	ED_INSERT,		/* M-^N */
-	/* 143 */	ED_INSERT,		/* M-^O */
-	/* 144 */	ED_INSERT,		/* M-^P */
-	/* 145 */	ED_INSERT,		/* M-^Q */
-	/* 146 */	ED_INSERT,		/* M-^R */
-	/* 147 */	ED_INSERT,		/* M-^S */
-	/* 148 */	ED_INSERT,		/* M-^T */
-	/* 149 */	ED_INSERT,		/* M-^U */
-	/* 150 */	ED_INSERT,		/* M-^V */
-	/* 151 */	ED_INSERT,		/* M-^W */
-	/* 152 */	ED_INSERT,		/* M-^X */
-	/* 153 */	ED_INSERT,		/* M-^Y */
-	/* 154 */	ED_INSERT,		/* M-^Z */
-	/* 155 */	ED_INSERT,		/* M-^[ */
-	/* 156 */	ED_INSERT,		/* M-^\ */
-	/* 157 */	ED_INSERT,		/* M-^] */
-	/* 158 */	ED_INSERT,		/* M-^^ */
-	/* 159 */	ED_INSERT,		/* M-^_ */
-	/* 160 */	ED_INSERT,		/* M-SPACE */
-	/* 161 */	ED_INSERT,		/* M-! */
-	/* 162 */	ED_INSERT,		/* M-" */
-	/* 163 */	ED_INSERT,		/* M-# */
-	/* 164 */	ED_INSERT,		/* M-$ */
-	/* 165 */	ED_INSERT,		/* M-% */
-	/* 166 */	ED_INSERT,		/* M-& */
-	/* 167 */	ED_INSERT,		/* M-' */
-	/* 168 */	ED_INSERT,		/* M-( */
-	/* 169 */	ED_INSERT,		/* M-) */
-	/* 170 */	ED_INSERT,		/* M-* */
-	/* 171 */	ED_INSERT,		/* M-+ */
-	/* 172 */	ED_INSERT,		/* M-, */
-	/* 173 */	ED_INSERT,		/* M-- */
-	/* 174 */	ED_INSERT,		/* M-. */
-	/* 175 */	ED_INSERT,		/* M-/ */
-	/* 176 */	ED_INSERT,		/* M-0 */
-	/* 177 */	ED_INSERT,		/* M-1 */
-	/* 178 */	ED_INSERT,		/* M-2 */
-	/* 179 */	ED_INSERT,		/* M-3 */
-	/* 180 */	ED_INSERT,		/* M-4 */
-	/* 181 */	ED_INSERT,		/* M-5 */
-	/* 182 */	ED_INSERT,		/* M-6 */
-	/* 183 */	ED_INSERT,		/* M-7 */
-	/* 184 */	ED_INSERT,		/* M-8 */
-	/* 185 */	ED_INSERT,		/* M-9 */
-	/* 186 */	ED_INSERT,		/* M-: */
-	/* 187 */	ED_INSERT,		/* M-; */
-	/* 188 */	ED_INSERT,		/* M-< */
-	/* 189 */	ED_INSERT,		/* M-= */
-	/* 190 */	ED_INSERT,		/* M-> */
-	/* 191 */	ED_INSERT,		/* M-? */
-	/* 192 */	ED_INSERT,		/* M-@ */
-	/* 193 */	ED_INSERT,		/* M-A */
-	/* 194 */	ED_INSERT,		/* M-B */
-	/* 195 */	ED_INSERT,		/* M-C */
-	/* 196 */	ED_INSERT,		/* M-D */
-	/* 197 */	ED_INSERT,		/* M-E */
-	/* 198 */	ED_INSERT,		/* M-F */
-	/* 199 */	ED_INSERT,		/* M-G */
-	/* 200 */	ED_INSERT,		/* M-H */
-	/* 201 */	ED_INSERT,		/* M-I */
-	/* 202 */	ED_INSERT,		/* M-J */
-	/* 203 */	ED_INSERT,		/* M-K */
-	/* 204 */	ED_INSERT,		/* M-L */
-	/* 205 */	ED_INSERT,		/* M-M */
-	/* 206 */	ED_INSERT,		/* M-N */
-	/* 207 */	ED_INSERT,		/* M-O */
-	/* 208 */	ED_INSERT,		/* M-P */
-	/* 209 */	ED_INSERT,		/* M-Q */
-	/* 210 */	ED_INSERT,		/* M-R */
-	/* 211 */	ED_INSERT,		/* M-S */
-	/* 212 */	ED_INSERT,		/* M-T */
-	/* 213 */	ED_INSERT,		/* M-U */
-	/* 214 */	ED_INSERT,		/* M-V */
-	/* 215 */	ED_INSERT,		/* M-W */
-	/* 216 */	ED_INSERT,		/* M-X */
-	/* 217 */	ED_INSERT,		/* M-Y */
-	/* 218 */	ED_INSERT,		/* M-Z */
-	/* 219 */	ED_INSERT,		/* M-[ */
-	/* 220 */	ED_INSERT,		/* M-\ */
-	/* 221 */	ED_INSERT,		/* M-] */
-	/* 222 */	ED_INSERT,		/* M-^ */
-	/* 223 */	ED_INSERT,		/* M-_ */
-	/* 224 */	ED_INSERT,		/* M-` */
-	/* 225 */	ED_INSERT,		/* M-a */
-	/* 226 */	ED_INSERT,		/* M-b */
-	/* 227 */	ED_INSERT,		/* M-c */
-	/* 228 */	ED_INSERT,		/* M-d */
-	/* 229 */	ED_INSERT,		/* M-e */
-	/* 230 */	ED_INSERT,		/* M-f */
-	/* 231 */	ED_INSERT,		/* M-g */
-	/* 232 */	ED_INSERT,		/* M-h */
-	/* 233 */	ED_INSERT,		/* M-i */
-	/* 234 */	ED_INSERT,		/* M-j */
-	/* 235 */	ED_INSERT,		/* M-k */
-	/* 236 */	ED_INSERT,		/* M-l */
-	/* 237 */	ED_INSERT,		/* M-m */
-	/* 238 */	ED_INSERT,		/* M-n */
-	/* 239 */	ED_INSERT,		/* M-o */
-	/* 240 */	ED_INSERT,		/* M-p */
-	/* 241 */	ED_INSERT,		/* M-q */
-	/* 242 */	ED_INSERT,		/* M-r */
-	/* 243 */	ED_INSERT,		/* M-s */
-	/* 244 */	ED_INSERT,		/* M-t */
-	/* 245 */	ED_INSERT,		/* M-u */
-	/* 246 */	ED_INSERT,		/* M-v */
-	/* 247 */	ED_INSERT,		/* M-w */
-	/* 248 */	ED_INSERT,		/* M-x */
-	/* 249 */	ED_INSERT,		/* M-y */
-	/* 250 */	ED_INSERT,		/* M-z */
-	/* 251 */	ED_INSERT,		/* M-{ */
-	/* 252 */	ED_INSERT,		/* M-| */
-	/* 253 */	ED_INSERT,		/* M-} */
-	/* 254 */	ED_INSERT,		/* M-~ */
-	/* 255 */	ED_INSERT		/* M-^? */
-};
-
-private const el_action_t el_map_vi_command[] = {
-	/*   0 */	ED_UNASSIGNED,		/* ^@ */
-	/*   1 */	ED_MOVE_TO_BEG,		/* ^A */
-	/*   2 */	ED_UNASSIGNED,		/* ^B */
-	/*   3 */	ED_TTY_SIGINT,		/* ^C */
-	/*   4 */	ED_UNASSIGNED,		/* ^D */
-	/*   5 */	ED_MOVE_TO_END,		/* ^E */
-	/*   6 */	ED_UNASSIGNED,		/* ^F */
-	/*   7 */	ED_UNASSIGNED,		/* ^G */
-	/*   8 */	ED_DELETE_PREV_CHAR,	/* ^H */
-	/*   9 */	ED_UNASSIGNED,		/* ^I */
-	/*  10 */	ED_NEWLINE,		/* ^J */
-	/*  11 */	ED_KILL_LINE,		/* ^K */
-	/*  12 */	ED_CLEAR_SCREEN,	/* ^L */
-	/*  13 */	ED_NEWLINE,		/* ^M */
-	/*  14 */	ED_NEXT_HISTORY,	/* ^N */
-	/*  15 */	ED_TTY_FLUSH_OUTPUT,	/* ^O */
-	/*  16 */	ED_PREV_HISTORY,	/* ^P */
-	/*  17 */	ED_TTY_START_OUTPUT,	/* ^Q */
-	/*  18 */	ED_REDISPLAY,		/* ^R */
-	/*  19 */	ED_TTY_STOP_OUTPUT,	/* ^S */
-	/*  20 */	ED_UNASSIGNED,		/* ^T */
-	/*  21 */	VI_KILL_LINE_PREV,	/* ^U */
-	/*  22 */	ED_UNASSIGNED,		/* ^V */
-	/*  23 */	ED_DELETE_PREV_WORD,	/* ^W */
-	/*  24 */	ED_UNASSIGNED,		/* ^X */
-	/*  25 */	ED_UNASSIGNED,		/* ^Y */
-	/*  26 */	ED_UNASSIGNED,		/* ^Z */
-	/*  27 */	EM_META_NEXT,		/* ^[ */
-	/*  28 */	ED_TTY_SIGQUIT,		/* ^\ */
-	/*  29 */	ED_UNASSIGNED,		/* ^] */
-	/*  30 */	ED_UNASSIGNED,		/* ^^ */
-	/*  31 */	ED_UNASSIGNED,		/* ^_ */
-	/*  32 */	ED_NEXT_CHAR,		/* SPACE */
-	/*  33 */	ED_UNASSIGNED,		/* ! */
-	/*  34 */	ED_UNASSIGNED,		/* " */
-	/*  35 */	VI_COMMENT_OUT,		/* # */
-	/*  36 */	ED_MOVE_TO_END,		/* $ */
-	/*  37 */	VI_MATCH,		/* % */
-	/*  38 */	ED_UNASSIGNED,		/* & */
-	/*  39 */	ED_UNASSIGNED,		/* ' */
-	/*  40 */	ED_UNASSIGNED,		/* ( */
-	/*  41 */	ED_UNASSIGNED,		/* ) */
-	/*  42 */	ED_UNASSIGNED,		/* * */
-	/*  43 */	ED_NEXT_HISTORY,	/* + */
-	/*  44 */	VI_REPEAT_PREV_CHAR,	/* , */
-	/*  45 */	ED_PREV_HISTORY,	/* - */
-	/*  46 */	VI_REDO,		/* . */
-	/*  47 */	VI_SEARCH_PREV,		/* / */
-	/*  48 */	VI_ZERO,		/* 0 */
-	/*  49 */	ED_ARGUMENT_DIGIT,	/* 1 */
-	/*  50 */	ED_ARGUMENT_DIGIT,	/* 2 */
-	/*  51 */	ED_ARGUMENT_DIGIT,	/* 3 */
-	/*  52 */	ED_ARGUMENT_DIGIT,	/* 4 */
-	/*  53 */	ED_ARGUMENT_DIGIT,	/* 5 */
-	/*  54 */	ED_ARGUMENT_DIGIT,	/* 6 */
-	/*  55 */	ED_ARGUMENT_DIGIT,	/* 7 */
-	/*  56 */	ED_ARGUMENT_DIGIT,	/* 8 */
-	/*  57 */	ED_ARGUMENT_DIGIT,	/* 9 */
-	/*  58 */	ED_COMMAND,		/* : */
-	/*  59 */	VI_REPEAT_NEXT_CHAR,	/* ; */
-	/*  60 */	ED_UNASSIGNED,		/* < */
-	/*  61 */	ED_UNASSIGNED,		/* = */
-	/*  62 */	ED_UNASSIGNED,		/* > */
-	/*  63 */	VI_SEARCH_NEXT,		/* ? */
-	/*  64 */	VI_ALIAS,		/* @ */
-	/*  65 */	VI_ADD_AT_EOL,		/* A */
-	/*  66 */	VI_PREV_BIG_WORD,	/* B */
-	/*  67 */	VI_CHANGE_TO_EOL,	/* C */
-	/*  68 */	ED_KILL_LINE,		/* D */
-	/*  69 */	VI_END_BIG_WORD,	/* E */
-	/*  70 */	VI_PREV_CHAR,		/* F */
-	/*  71 */	VI_TO_HISTORY_LINE,	/* G */
-	/*  72 */	ED_UNASSIGNED,		/* H */
-	/*  73 */	VI_INSERT_AT_BOL,	/* I */
-	/*  74 */	ED_SEARCH_NEXT_HISTORY,	/* J */
-	/*  75 */	ED_SEARCH_PREV_HISTORY,	/* K */
-	/*  76 */	ED_UNASSIGNED,		/* L */
-	/*  77 */	ED_UNASSIGNED,		/* M */
-	/*  78 */	VI_REPEAT_SEARCH_PREV,	/* N */
-	/*  79 */	ED_SEQUENCE_LEAD_IN,	/* O */
-	/*  80 */	VI_PASTE_PREV,		/* P */
-	/*  81 */	ED_UNASSIGNED,		/* Q */
-	/*  82 */	VI_REPLACE_MODE,	/* R */
-	/*  83 */	VI_SUBSTITUTE_LINE,	/* S */
-	/*  84 */	VI_TO_PREV_CHAR,	/* T */
-	/*  85 */	VI_UNDO_LINE,		/* U */
-	/*  86 */	ED_UNASSIGNED,		/* V */
-	/*  87 */	VI_NEXT_BIG_WORD,	/* W */
-	/*  88 */	ED_DELETE_PREV_CHAR,	/* X */
-	/*  89 */	VI_YANK_END,		/* Y */
-	/*  90 */	ED_UNASSIGNED,		/* Z */
-	/*  91 */	ED_SEQUENCE_LEAD_IN,	/* [ */
-	/*  92 */	ED_UNASSIGNED,		/* \ */
-	/*  93 */	ED_UNASSIGNED,		/* ] */
-	/*  94 */	ED_MOVE_TO_BEG,		/* ^ */
-	/*  95 */	VI_HISTORY_WORD,	/* _ */
-	/*  96 */	ED_UNASSIGNED,		/* ` */
-	/*  97 */	VI_ADD,			/* a */
-	/*  98 */	VI_PREV_WORD,		/* b */
-	/*  99 */	VI_CHANGE_META,		/* c */
-	/* 100 */	VI_DELETE_META,		/* d */
-	/* 101 */	VI_END_WORD,		/* e */
-	/* 102 */	VI_NEXT_CHAR,		/* f */
-	/* 103 */	ED_UNASSIGNED,		/* g */
-	/* 104 */	ED_PREV_CHAR,		/* h */
-	/* 105 */	VI_INSERT,		/* i */
-	/* 106 */	ED_NEXT_HISTORY,	/* j */
-	/* 107 */	ED_PREV_HISTORY,	/* k */
-	/* 108 */	ED_NEXT_CHAR,		/* l */
-	/* 109 */	ED_UNASSIGNED,		/* m */
-	/* 110 */	VI_REPEAT_SEARCH_NEXT,	/* n */
-	/* 111 */	ED_UNASSIGNED,		/* o */
-	/* 112 */	VI_PASTE_NEXT,		/* p */
-	/* 113 */	ED_UNASSIGNED,		/* q */
-	/* 114 */	VI_REPLACE_CHAR,	/* r */
-	/* 115 */	VI_SUBSTITUTE_CHAR,	/* s */
-	/* 116 */	VI_TO_NEXT_CHAR,	/* t */
-	/* 117 */	VI_UNDO,		/* u */
-	/* 118 */	VI_HISTEDIT,		/* v */
-	/* 119 */	VI_NEXT_WORD,		/* w */
-	/* 120 */	ED_DELETE_NEXT_CHAR,	/* x */
-	/* 121 */	VI_YANK,		/* y */
-	/* 122 */	ED_UNASSIGNED,		/* z */
-	/* 123 */	ED_UNASSIGNED,		/* { */
-	/* 124 */	VI_TO_COLUMN,		/* | */
-	/* 125 */	ED_UNASSIGNED,		/* } */
-	/* 126 */	VI_CHANGE_CASE,		/* ~ */
-	/* 127 */	ED_DELETE_PREV_CHAR,	/* ^? */
-	/* 128 */	ED_UNASSIGNED,		/* M-^@ */
-	/* 129 */	ED_UNASSIGNED,		/* M-^A */
-	/* 130 */	ED_UNASSIGNED,		/* M-^B */
-	/* 131 */	ED_UNASSIGNED,		/* M-^C */
-	/* 132 */	ED_UNASSIGNED,		/* M-^D */
-	/* 133 */	ED_UNASSIGNED,		/* M-^E */
-	/* 134 */	ED_UNASSIGNED,		/* M-^F */
-	/* 135 */	ED_UNASSIGNED,		/* M-^G */
-	/* 136 */	ED_UNASSIGNED,		/* M-^H */
-	/* 137 */	ED_UNASSIGNED,		/* M-^I */
-	/* 138 */	ED_UNASSIGNED,		/* M-^J */
-	/* 139 */	ED_UNASSIGNED,		/* M-^K */
-	/* 140 */	ED_UNASSIGNED,		/* M-^L */
-	/* 141 */	ED_UNASSIGNED,		/* M-^M */
-	/* 142 */	ED_UNASSIGNED,		/* M-^N */
-	/* 143 */	ED_UNASSIGNED,		/* M-^O */
-	/* 144 */	ED_UNASSIGNED,		/* M-^P */
-	/* 145 */	ED_UNASSIGNED,		/* M-^Q */
-	/* 146 */	ED_UNASSIGNED,		/* M-^R */
-	/* 147 */	ED_UNASSIGNED,		/* M-^S */
-	/* 148 */	ED_UNASSIGNED,		/* M-^T */
-	/* 149 */	ED_UNASSIGNED,		/* M-^U */
-	/* 150 */	ED_UNASSIGNED,		/* M-^V */
-	/* 151 */	ED_UNASSIGNED,		/* M-^W */
-	/* 152 */	ED_UNASSIGNED,		/* M-^X */
-	/* 153 */	ED_UNASSIGNED,		/* M-^Y */
-	/* 154 */	ED_UNASSIGNED,		/* M-^Z */
-	/* 155 */	ED_UNASSIGNED,		/* M-^[ */
-	/* 156 */	ED_UNASSIGNED,		/* M-^\ */
-	/* 157 */	ED_UNASSIGNED,		/* M-^] */
-	/* 158 */	ED_UNASSIGNED,		/* M-^^ */
-	/* 159 */	ED_UNASSIGNED,		/* M-^_ */
-	/* 160 */	ED_UNASSIGNED,		/* M-SPACE */
-	/* 161 */	ED_UNASSIGNED,		/* M-! */
-	/* 162 */	ED_UNASSIGNED,		/* M-" */
-	/* 163 */	ED_UNASSIGNED,		/* M-# */
-	/* 164 */	ED_UNASSIGNED,		/* M-$ */
-	/* 165 */	ED_UNASSIGNED,		/* M-% */
-	/* 166 */	ED_UNASSIGNED,		/* M-& */
-	/* 167 */	ED_UNASSIGNED,		/* M-' */
-	/* 168 */	ED_UNASSIGNED,		/* M-( */
-	/* 169 */	ED_UNASSIGNED,		/* M-) */
-	/* 170 */	ED_UNASSIGNED,		/* M-* */
-	/* 171 */	ED_UNASSIGNED,		/* M-+ */
-	/* 172 */	ED_UNASSIGNED,		/* M-, */
-	/* 173 */	ED_UNASSIGNED,		/* M-- */
-	/* 174 */	ED_UNASSIGNED,		/* M-. */
-	/* 175 */	ED_UNASSIGNED,		/* M-/ */
-	/* 176 */	ED_UNASSIGNED,		/* M-0 */
-	/* 177 */	ED_UNASSIGNED,		/* M-1 */
-	/* 178 */	ED_UNASSIGNED,		/* M-2 */
-	/* 179 */	ED_UNASSIGNED,		/* M-3 */
-	/* 180 */	ED_UNASSIGNED,		/* M-4 */
-	/* 181 */	ED_UNASSIGNED,		/* M-5 */
-	/* 182 */	ED_UNASSIGNED,		/* M-6 */
-	/* 183 */	ED_UNASSIGNED,		/* M-7 */
-	/* 184 */	ED_UNASSIGNED,		/* M-8 */
-	/* 185 */	ED_UNASSIGNED,		/* M-9 */
-	/* 186 */	ED_UNASSIGNED,		/* M-: */
-	/* 187 */	ED_UNASSIGNED,		/* M-; */
-	/* 188 */	ED_UNASSIGNED,		/* M-< */
-	/* 189 */	ED_UNASSIGNED,		/* M-= */
-	/* 190 */	ED_UNASSIGNED,		/* M-> */
-	/* 191 */	ED_UNASSIGNED,		/* M-? */
-	/* 192 */	ED_UNASSIGNED,		/* M-@ */
-	/* 193 */	ED_UNASSIGNED,		/* M-A */
-	/* 194 */	ED_UNASSIGNED,		/* M-B */
-	/* 195 */	ED_UNASSIGNED,		/* M-C */
-	/* 196 */	ED_UNASSIGNED,		/* M-D */
-	/* 197 */	ED_UNASSIGNED,		/* M-E */
-	/* 198 */	ED_UNASSIGNED,		/* M-F */
-	/* 199 */	ED_UNASSIGNED,		/* M-G */
-	/* 200 */	ED_UNASSIGNED,		/* M-H */
-	/* 201 */	ED_UNASSIGNED,		/* M-I */
-	/* 202 */	ED_UNASSIGNED,		/* M-J */
-	/* 203 */	ED_UNASSIGNED,		/* M-K */
-	/* 204 */	ED_UNASSIGNED,		/* M-L */
-	/* 205 */	ED_UNASSIGNED,		/* M-M */
-	/* 206 */	ED_UNASSIGNED,		/* M-N */
-	/* 207 */	ED_SEQUENCE_LEAD_IN,	/* M-O */
-	/* 208 */	ED_UNASSIGNED,		/* M-P */
-	/* 209 */	ED_UNASSIGNED,		/* M-Q */
-	/* 210 */	ED_UNASSIGNED,		/* M-R */
-	/* 211 */	ED_UNASSIGNED,		/* M-S */
-	/* 212 */	ED_UNASSIGNED,		/* M-T */
-	/* 213 */	ED_UNASSIGNED,		/* M-U */
-	/* 214 */	ED_UNASSIGNED,		/* M-V */
-	/* 215 */	ED_UNASSIGNED,		/* M-W */
-	/* 216 */	ED_UNASSIGNED,		/* M-X */
-	/* 217 */	ED_UNASSIGNED,		/* M-Y */
-	/* 218 */	ED_UNASSIGNED,		/* M-Z */
-	/* 219 */	ED_SEQUENCE_LEAD_IN,	/* M-[ */
-	/* 220 */	ED_UNASSIGNED,		/* M-\ */
-	/* 221 */	ED_UNASSIGNED,		/* M-] */
-	/* 222 */	ED_UNASSIGNED,		/* M-^ */
-	/* 223 */	ED_UNASSIGNED,		/* M-_ */
-	/* 224 */	ED_UNASSIGNED,		/* M-` */
-	/* 225 */	ED_UNASSIGNED,		/* M-a */
-	/* 226 */	ED_UNASSIGNED,		/* M-b */
-	/* 227 */	ED_UNASSIGNED,		/* M-c */
-	/* 228 */	ED_UNASSIGNED,		/* M-d */
-	/* 229 */	ED_UNASSIGNED,		/* M-e */
-	/* 230 */	ED_UNASSIGNED,		/* M-f */
-	/* 231 */	ED_UNASSIGNED,		/* M-g */
-	/* 232 */	ED_UNASSIGNED,		/* M-h */
-	/* 233 */	ED_UNASSIGNED,		/* M-i */
-	/* 234 */	ED_UNASSIGNED,		/* M-j */
-	/* 235 */	ED_UNASSIGNED,		/* M-k */
-	/* 236 */	ED_UNASSIGNED,		/* M-l */
-	/* 237 */	ED_UNASSIGNED,		/* M-m */
-	/* 238 */	ED_UNASSIGNED,		/* M-n */
-	/* 239 */	ED_UNASSIGNED,		/* M-o */
-	/* 240 */	ED_UNASSIGNED,		/* M-p */
-	/* 241 */	ED_UNASSIGNED,		/* M-q */
-	/* 242 */	ED_UNASSIGNED,		/* M-r */
-	/* 243 */	ED_UNASSIGNED,		/* M-s */
-	/* 244 */	ED_UNASSIGNED,		/* M-t */
-	/* 245 */	ED_UNASSIGNED,		/* M-u */
-	/* 246 */	ED_UNASSIGNED,		/* M-v */
-	/* 247 */	ED_UNASSIGNED,		/* M-w */
-	/* 248 */	ED_UNASSIGNED,		/* M-x */
-	/* 249 */	ED_UNASSIGNED,		/* M-y */
-	/* 250 */	ED_UNASSIGNED,		/* M-z */
-	/* 251 */	ED_UNASSIGNED,		/* M-{ */
-	/* 252 */	ED_UNASSIGNED,		/* M-| */
-	/* 253 */	ED_UNASSIGNED,		/* M-} */
-	/* 254 */	ED_UNASSIGNED,		/* M-~ */
-	/* 255 */	ED_UNASSIGNED		/* M-^? */
-};
-
-
-/* map_init():
- *	Initialize and allocate the maps
- */
-protected int
-map_init(EditLine *el)
-{
-
-	/*
-         * Make sure those are correct before starting.
-         */
-#ifdef MAP_DEBUG
-	if (sizeof(el_map_emacs) != N_KEYS * sizeof(el_action_t))
-		EL_ABORT((el->errfile, "Emacs map incorrect\n"));
-	if (sizeof(el_map_vi_command) != N_KEYS * sizeof(el_action_t))
-		EL_ABORT((el->errfile, "Vi command map incorrect\n"));
-	if (sizeof(el_map_vi_insert) != N_KEYS * sizeof(el_action_t))
-		EL_ABORT((el->errfile, "Vi insert map incorrect\n"));
-#endif
-
-	el->el_map.alt = (el_action_t *)el_malloc(sizeof(el_action_t) * N_KEYS);
-	if (el->el_map.alt == NULL)
-		return (-1);
-	el->el_map.key = (el_action_t *)el_malloc(sizeof(el_action_t) * N_KEYS);
-	if (el->el_map.key == NULL)
-		return (-1);
-	el->el_map.emacs = el_map_emacs;
-	el->el_map.vic = el_map_vi_command;
-	el->el_map.vii = el_map_vi_insert;
-	el->el_map.help = (el_bindings_t *) el_malloc(sizeof(el_bindings_t) *
-	    EL_NUM_FCNS);
-	if (el->el_map.help == NULL)
-		return (-1);
-	(void) memcpy(el->el_map.help, help__get(),
-	    sizeof(el_bindings_t) * EL_NUM_FCNS);
-	el->el_map.func = (el_func_t *)el_malloc(sizeof(el_func_t) *
-	    EL_NUM_FCNS);
-	if (el->el_map.func == NULL)
-		return (-1);
-	memcpy(el->el_map.func, func__get(), sizeof(el_func_t) * EL_NUM_FCNS);
-	el->el_map.nfunc = EL_NUM_FCNS;
-
-#ifdef VIDEFAULT
-	map_init_vi(el);
-#else
-	map_init_emacs(el);
-#endif /* VIDEFAULT */
-	return (0);
-}
-
-
-/* map_end():
- *	Free the space taken by the editor maps
- */
-protected void
-map_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_map.alt);
-	el->el_map.alt = NULL;
-	el_free((ptr_t) el->el_map.key);
-	el->el_map.key = NULL;
-	el->el_map.emacs = NULL;
-	el->el_map.vic = NULL;
-	el->el_map.vii = NULL;
-	el_free((ptr_t) el->el_map.help);
-	el->el_map.help = NULL;
-	el_free((ptr_t) el->el_map.func);
-	el->el_map.func = NULL;
-}
-
-
-/* map_init_nls():
- *	Find all the printable keys and bind them to self insert
- */
-private void
-map_init_nls(EditLine *el)
-{
-	int i;
-
-	el_action_t *map = el->el_map.key;
-
-	for (i = 0200; i <= 0377; i++)
-		if (isprint(i))
-			map[i] = ED_INSERT;
-}
-
-
-/* map_init_meta():
- *	Bind all the meta keys to the appropriate ESC-<key> sequence
- */
-private void
-map_init_meta(EditLine *el)
-{
-	char buf[3];
-	int i;
-	el_action_t *map = el->el_map.key;
-	el_action_t *alt = el->el_map.alt;
-
-	for (i = 0; i <= 0377 && map[i] != EM_META_NEXT; i++)
-		continue;
-
-	if (i > 0377) {
-		for (i = 0; i <= 0377 && alt[i] != EM_META_NEXT; i++)
-			continue;
-		if (i > 0377) {
-			i = 033;
-			if (el->el_map.type == MAP_VI)
-				map = alt;
-		} else
-			map = alt;
-	}
-	buf[0] = (char) i;
-	buf[2] = 0;
-	for (i = 0200; i <= 0377; i++)
-		switch (map[i]) {
-		case ED_INSERT:
-		case ED_UNASSIGNED:
-		case ED_SEQUENCE_LEAD_IN:
-			break;
-		default:
-			buf[1] = i & 0177;
-			key_add(el, buf, key_map_cmd(el, (int) map[i]), XK_CMD);
-			break;
-		}
-	map[(int) buf[0]] = ED_SEQUENCE_LEAD_IN;
-}
-
-
-/* map_init_vi():
- *	Initialize the vi bindings
- */
-protected void
-map_init_vi(EditLine *el)
-{
-	int i;
-	el_action_t *key = el->el_map.key;
-	el_action_t *alt = el->el_map.alt;
-	const el_action_t *vii = el->el_map.vii;
-	const el_action_t *vic = el->el_map.vic;
-
-	el->el_map.type = MAP_VI;
-	el->el_map.current = el->el_map.key;
-
-	key_reset(el);
-
-	for (i = 0; i < N_KEYS; i++) {
-		key[i] = vii[i];
-		alt[i] = vic[i];
-	}
-
-	map_init_meta(el);
-	map_init_nls(el);
-
-	tty_bind_char(el, 1);
-	term_bind_arrow(el);
-}
-
-
-/* map_init_emacs():
- *	Initialize the emacs bindings
- */
-protected void
-map_init_emacs(EditLine *el)
-{
-	int i;
-	char buf[3];
-	el_action_t *key = el->el_map.key;
-	el_action_t *alt = el->el_map.alt;
-	const el_action_t *emacs = el->el_map.emacs;
-
-	el->el_map.type = MAP_EMACS;
-	el->el_map.current = el->el_map.key;
-	key_reset(el);
-
-	for (i = 0; i < N_KEYS; i++) {
-		key[i] = emacs[i];
-		alt[i] = ED_UNASSIGNED;
-	}
-
-	map_init_meta(el);
-	map_init_nls(el);
-
-	buf[0] = CONTROL('X');
-	buf[1] = CONTROL('X');
-	buf[2] = 0;
-	key_add(el, buf, key_map_cmd(el, EM_EXCHANGE_MARK), XK_CMD);
-
-	tty_bind_char(el, 1);
-	term_bind_arrow(el);
-}
-
-
-/* map_set_editor():
- *	Set the editor
- */
-protected int
-map_set_editor(EditLine *el, char *editor)
-{
-
-	if (strcmp(editor, "emacs") == 0) {
-		map_init_emacs(el);
-		return (0);
-	}
-	if (strcmp(editor, "vi") == 0) {
-		map_init_vi(el);
-		return (0);
-	}
-	return (-1);
-}
-
-
-/* map_get_editor():
- *	Retrieve the editor
- */
-protected int
-map_get_editor(EditLine *el, const char **editor)
-{
-
-	if (editor == NULL)
-		return (-1);
-	switch (el->el_map.type) {
-	case MAP_EMACS:
-		*editor = "emacs";
-		return (0);
-	case MAP_VI:
-		*editor = "vi";
-		return (0);
-	}
-	return (-1);
-}
-
-
-/* map_print_key():
- *	Print the function description for 1 key
- */
-private void
-map_print_key(EditLine *el, el_action_t *map, const char *in)
-{
-	char outbuf[EL_BUFSIZ];
-	el_bindings_t *bp, *ep;
-
-	if (in[0] == '\0' || in[1] == '\0') {
-		(void) key__decode_str(in, outbuf, "");
-		ep = &el->el_map.help[el->el_map.nfunc];
-		for (bp = el->el_map.help; bp < ep; bp++)
-			if (bp->func == map[(unsigned char) *in]) {
-				(void) fprintf(el->el_outfile,
-				    "%s\t->\t%s\n", outbuf, bp->name);
-				return;
-			}
-	} else
-		key_print(el, in);
-}
-
-
-/* map_print_some_keys():
- *	Print keys from first to last
- */
-private void
-map_print_some_keys(EditLine *el, el_action_t *map, int first, int last)
-{
-	el_bindings_t *bp, *ep;
-	char firstbuf[2], lastbuf[2];
-	char unparsbuf[EL_BUFSIZ], extrabuf[EL_BUFSIZ];
-
-	firstbuf[0] = first;
-	firstbuf[1] = 0;
-	lastbuf[0] = last;
-	lastbuf[1] = 0;
-	if (map[first] == ED_UNASSIGNED) {
-		if (first == last)
-			(void) fprintf(el->el_outfile,
-			    "%-15s->  is undefined\n",
-			    key__decode_str(firstbuf, unparsbuf, STRQQ));
-		return;
-	}
-	ep = &el->el_map.help[el->el_map.nfunc];
-	for (bp = el->el_map.help; bp < ep; bp++) {
-		if (bp->func == map[first]) {
-			if (first == last) {
-				(void) fprintf(el->el_outfile, "%-15s->  %s\n",
-				    key__decode_str(firstbuf, unparsbuf, STRQQ),
-				    bp->name);
-			} else {
-				(void) fprintf(el->el_outfile,
-				    "%-4s to %-7s->  %s\n",
-				    key__decode_str(firstbuf, unparsbuf, STRQQ),
-				    key__decode_str(lastbuf, extrabuf, STRQQ),
-				    bp->name);
-			}
-			return;
-		}
-	}
-#ifdef MAP_DEBUG
-	if (map == el->el_map.key) {
-		(void) fprintf(el->el_outfile,
-		    "BUG!!! %s isn't bound to anything.\n",
-		    key__decode_str(firstbuf, unparsbuf, STRQQ));
-		(void) fprintf(el->el_outfile, "el->el_map.key[%d] == %d\n",
-		    first, el->el_map.key[first]);
-	} else {
-		(void) fprintf(el->el_outfile,
-		    "BUG!!! %s isn't bound to anything.\n",
-		    key__decode_str(firstbuf, unparsbuf, STRQQ));
-		(void) fprintf(el->el_outfile, "el->el_map.alt[%d] == %d\n",
-		    first, el->el_map.alt[first]);
-	}
-#endif
-	EL_ABORT((el->el_errfile, "Error printing keys\n"));
-}
-
-
-/* map_print_all_keys():
- *	Print the function description for all keys.
- */
-private void
-map_print_all_keys(EditLine *el)
-{
-	int prev, i;
-
-	(void) fprintf(el->el_outfile, "Standard key bindings\n");
-	prev = 0;
-	for (i = 0; i < N_KEYS; i++) {
-		if (el->el_map.key[prev] == el->el_map.key[i])
-			continue;
-		map_print_some_keys(el, el->el_map.key, prev, i - 1);
-		prev = i;
-	}
-	map_print_some_keys(el, el->el_map.key, prev, i - 1);
-
-	(void) fprintf(el->el_outfile, "Alternative key bindings\n");
-	prev = 0;
-	for (i = 0; i < N_KEYS; i++) {
-		if (el->el_map.alt[prev] == el->el_map.alt[i])
-			continue;
-		map_print_some_keys(el, el->el_map.alt, prev, i - 1);
-		prev = i;
-	}
-	map_print_some_keys(el, el->el_map.alt, prev, i - 1);
-
-	(void) fprintf(el->el_outfile, "Multi-character bindings\n");
-	key_print(el, "");
-	(void) fprintf(el->el_outfile, "Arrow key bindings\n");
-	term_print_arrow(el, "");
-}
-
-
-/* map_bind():
- *	Add/remove/change bindings
- */
-protected int
-map_bind(EditLine *el, int argc, const char **argv)
-{
-	el_action_t *map;
-	int ntype, rem;
-	const char *p;
-	char inbuf[EL_BUFSIZ];
-	char outbuf[EL_BUFSIZ];
-	const char *in = NULL;
-	char *out = NULL;
-	el_bindings_t *bp, *ep;
-	int cmd;
-	int key;
-
-	if (argv == NULL)
-		return (-1);
-
-	map = el->el_map.key;
-	ntype = XK_CMD;
-	key = rem = 0;
-	for (argc = 1; (p = argv[argc]) != NULL; argc++)
-		if (p[0] == '-')
-			switch (p[1]) {
-			case 'a':
-				map = el->el_map.alt;
-				break;
-
-			case 's':
-				ntype = XK_STR;
-				break;
-#ifdef notyet
-			case 'c':
-				ntype = XK_EXE;
-				break;
-#endif
-			case 'k':
-				key = 1;
-				break;
-
-			case 'r':
-				rem = 1;
-				break;
-
-			case 'v':
-				map_init_vi(el);
-				return (0);
-
-			case 'e':
-				map_init_emacs(el);
-				return (0);
-
-			case 'l':
-				ep = &el->el_map.help[el->el_map.nfunc];
-				for (bp = el->el_map.help; bp < ep; bp++)
-					(void) fprintf(el->el_outfile,
-					    "%s\n\t%s\n",
-					    bp->name, bp->description);
-				return (0);
-			default:
-				(void) fprintf(el->el_errfile,
-				    "%s: Invalid switch `%c'.\n",
-				    argv[0], p[1]);
-			}
-		else
-			break;
-
-	if (argv[argc] == NULL) {
-		map_print_all_keys(el);
-		return (0);
-	}
-	if (key)
-		in = argv[argc++];
-	else if ((in = parse__string(inbuf, argv[argc++])) == NULL) {
-		(void) fprintf(el->el_errfile,
-		    "%s: Invalid \\ or ^ in instring.\n",
-		    argv[0]);
-		return (-1);
-	}
-	if (rem) {
-		if (key) {
-			(void) term_clear_arrow(el, in);
-			return (-1);
-		}
-		if (in[1])
-			(void) key_delete(el, in);
-		else if (map[(unsigned char) *in] == ED_SEQUENCE_LEAD_IN)
-			(void) key_delete(el, in);
-		else
-			map[(unsigned char) *in] = ED_UNASSIGNED;
-		return (0);
-	}
-	if (argv[argc] == NULL) {
-		if (key)
-			term_print_arrow(el, in);
-		else
-			map_print_key(el, map, in);
-		return (0);
-	}
-#ifdef notyet
-	if (argv[argc + 1] != NULL) {
-		bindkey_usage();
-		return (-1);
-	}
-#endif
-
-	switch (ntype) {
-	case XK_STR:
-	case XK_EXE:
-		if ((out = parse__string(outbuf, argv[argc])) == NULL) {
-			(void) fprintf(el->el_errfile,
-			    "%s: Invalid \\ or ^ in outstring.\n", argv[0]);
-			return (-1);
-		}
-		if (key)
-			term_set_arrow(el, in, key_map_str(el, out), ntype);
-		else
-			key_add(el, in, key_map_str(el, out), ntype);
-		map[(unsigned char) *in] = ED_SEQUENCE_LEAD_IN;
-		break;
-
-	case XK_CMD:
-		if ((cmd = parse_cmd(el, argv[argc])) == -1) {
-			(void) fprintf(el->el_errfile,
-			    "%s: Invalid command `%s'.\n", argv[0], argv[argc]);
-			return (-1);
-		}
-		if (key)
-			term_set_arrow(el, in, key_map_str(el, out), ntype);
-		else {
-			if (in[1]) {
-				key_add(el, in, key_map_cmd(el, cmd), ntype);
-				map[(unsigned char) *in] = ED_SEQUENCE_LEAD_IN;
-			} else {
-				key_clear(el, map, in);
-				map[(unsigned char) *in] = cmd;
-			}
-		}
-		break;
-
-	default:
-		EL_ABORT((el->el_errfile, "Bad XK_ type\n", ntype));
-		break;
-	}
-	return (0);
-}
-
-
-/* map_addfunc():
- *	add a user defined function
- */
-protected int
-map_addfunc(EditLine *el, const char *name, const char *help, el_func_t func)
-{
-	void *p;
-	int nf = el->el_map.nfunc + 1;
-
-	if (name == NULL || help == NULL || func == NULL)
-		return (-1);
-
-	if ((p = el_realloc(el->el_map.func, nf * sizeof(el_func_t))) == NULL)
-		return (-1);
-	el->el_map.func = (el_func_t *) p;
-	if ((p = el_realloc(el->el_map.help, nf * sizeof(el_bindings_t)))
-	    == NULL)
-		return (-1);
-	el->el_map.help = (el_bindings_t *) p;
-
-	nf = el->el_map.nfunc;
-	el->el_map.func[nf] = func;
-
-	el->el_map.help[nf].name = name;
-	el->el_map.help[nf].func = nf;
-	el->el_map.help[nf].description = help;
-	el->el_map.nfunc++;
-
-	return (0);
-}
diff --git a/libedit/map.h b/libedit/map.h
deleted file mode 100644
index 3b08f48..0000000
--- a/libedit/map.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*	$NetBSD: map.h,v 1.8 2003/08/07 16:44:32 agc Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)map.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.map.h:	Editor maps
- */
-#ifndef _h_el_map
-#define	_h_el_map
-
-typedef struct el_bindings_t {	/* for the "bind" shell command */
-	const char	*name;		/* function name for bind command */
-	int		 func;		/* function numeric value */
-	const char	*description;	/* description of function */
-} el_bindings_t;
-
-
-typedef struct el_map_t {
-	el_action_t	*alt;		/* The current alternate key map */
-	el_action_t	*key;		/* The current normal key map	*/
-	el_action_t	*current;	/* The keymap we are using	*/
-	const el_action_t *emacs;	/* The default emacs key map	*/
-	const el_action_t *vic;		/* The vi command mode key map	*/
-	const el_action_t *vii;		/* The vi insert mode key map	*/
-	int		 type;		/* Emacs or vi			*/
-	el_bindings_t	*help;		/* The help for the editor functions */
-	el_func_t	*func;		/* List of available functions	*/
-	int		 nfunc;		/* The number of functions/help items */
-} el_map_t;
-
-#define	MAP_EMACS	0
-#define	MAP_VI		1
-
-protected int	map_bind(EditLine *, int, const char **);
-protected int	map_init(EditLine *);
-protected void	map_end(EditLine *);
-protected void	map_init_vi(EditLine *);
-protected void	map_init_emacs(EditLine *);
-protected int	map_set_editor(EditLine *, char *);
-protected int	map_get_editor(EditLine *, const char **);
-protected int	map_addfunc(EditLine *, const char *, const char *, el_func_t);
-
-#endif /* _h_el_map */
diff --git a/libedit/orig_editline.diff b/libedit/orig_editline.diff
deleted file mode 100644
index 841d6ea..0000000
--- a/libedit/orig_editline.diff
+++ /dev/null
@@ -1,344 +0,0 @@
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/chared.c ./chared.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/chared.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./chared.c	2006-02-10 09:57:21.156927844 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)chared.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/common.c ./common.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/common.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./common.c	2006-02-10 09:58:01.643795376 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)common.c	8.1 (Berkeley) 6/4/93";
-Common subdirectories: /home/cminyard/m1/libedit-20060103-2.9/src/editline and ./editline
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/el.c ./el.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/el.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./el.c	2006-02-10 09:58:10.348691834 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)el.c	8.2 (Berkeley) 1/3/94";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/emacs.c ./emacs.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/emacs.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./emacs.c	2006-02-10 09:58:19.192570662 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)emacs.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/fgetln.c ./fgetln.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/fgetln.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./fgetln.c	2006-02-10 10:19:03.644802468 -0600
-@@ -36,7 +36,7 @@
-  * POSSIBILITY OF SUCH DAMAGE.
-  */
- 
--#include <config.h>
-+#include "sys.h"
- #include <stdio.h>
- #include <stdlib.h>
- #include <unistd.h>
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/filecomplete.c ./filecomplete.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/filecomplete.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./filecomplete.c	2006-02-10 10:01:13.792433574 -0600
-@@ -41,7 +41,7 @@
-  #pragma alloca
- #endif
- 
--#include <config.h>
-+#include "sys.h"
- 
- #ifdef __GNUC__
- # undef alloca
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/hist.c ./hist.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/hist.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./hist.c	2006-02-10 09:58:32.439891227 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)hist.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/history.c ./history.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/history.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./history.c	2006-02-10 10:00:37.375051211 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)history.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/key.c ./key.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/key.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./key.c	2006-02-10 09:58:57.894664113 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)key.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/Makefile.am ./Makefile.am
---- /home/cminyard/m1/libedit-20060103-2.9/src/Makefile.am	2005-09-11 12:55:32.000000000 -0500
-+++ ./Makefile.am	2006-02-10 09:41:42.805887067 -0600
-@@ -28,19 +28,15 @@
- 
- CLEANFILES = $(BUILT_SOURCES)
- 
--lib_LTLIBRARIES    = libedit.la
--libedit_la_SOURCES = chared.c common.c el.c emacs.c hist.c key.c map.c parse.c \
--							prompt.c read.c refresh.c search.c sig.c term.c tty.c vi.c \
--							fgetln.c strlcat.c strlcpy.c unvis.c vis.c tokenizer.c \
--							history.c filecomplete.c readline.c chared.h el.h hist.h \
--							histedit.h key.h map.h parse.h prompt.h read.h refresh.h \
--							search.h sig.h sys.h el_term.h tty.h vis.h filecomplete.h \
--							editline/readline.h
-+noinst_LIBRARIES    = libedit.a
-+libedit_a_SOURCES = chared.c common.c el.c emacs.c hist.c key.c map.c parse.c \
-+		prompt.c read.c refresh.c search.c sig.c term.c tty.c vi.c \
-+		fgetln.c strlcat.c strlcpy.c unvis.c vis.c tokenizer.c \
-+		history.c filecomplete.c readline.c chared.h el.h hist.h \
-+		histedit.h key.h map.h parse.h prompt.h read.h refresh.h \
-+		search.h sig.h sys.h el_term.h tty.h vis.h filecomplete.h \
-+		editline/readline.h
- 
--EXTRA_DIST = makelist shlib_version
--nobase_include_HEADERS = histedit.h editline/readline.h
--
--nodist_libedit_la_SOURCES = $(BUILT_SOURCES)
--
--libedit_la_LDFLAGS = -no-undefined -version-info $(LT_VERSION)
-+EXTRA_DIST = makelist
- 
-+nodist_libedit_a_SOURCES = $(BUILT_SOURCES)
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/map.c ./map.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/map.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./map.c	2006-02-10 09:59:04.419836847 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)map.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/parse.c ./parse.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/parse.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./parse.c	2006-02-10 09:59:13.284712941 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)parse.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/prompt.c ./prompt.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/prompt.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./prompt.c	2006-02-10 09:59:20.872750903 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)prompt.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/read.c ./read.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/read.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./read.c	2006-02-10 09:59:32.905225367 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)read.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/readline.c ./readline.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/readline.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./readline.c	2006-02-10 10:01:23.005265379 -0600
-@@ -41,7 +41,7 @@
-  #pragma alloca
- #endif
- 
--#include <config.h>
-+#include "sys.h"
- 
- #ifdef __GNUC__
- # undef alloca
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/refresh.c ./refresh.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/refresh.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./refresh.c	2006-02-10 09:59:41.130182554 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)refresh.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/search.c ./search.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/search.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./search.c	2006-02-10 09:59:48.194286914 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)search.c	8.1 (Berkeley) 6/4/93";
---- /home/cminyard/m1/libedit-20060103-2.9/src/sig.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./sig.c	2006-02-10 09:59:54.268516772 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)sig.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/strlcat.c ./strlcat.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/strlcat.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./strlcat.c	2006-02-10 10:18:55.072889319 -0600
-@@ -17,7 +17,7 @@
-  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
--#include <config.h>
-+#include "sys.h"
- 
- #if defined(LIBC_SCCS) && !defined(lint)
- __RCSID("$NetBSD: strlcat.c,v 1.1 2005/12/20 19:28:52 christos Exp $");
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/strlcpy.c ./strlcpy.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/strlcpy.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./strlcpy.c	2006-02-10 10:19:14.251457614 -0600
-@@ -17,7 +17,7 @@
-  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
--#include <config.h>
-+#include "sys.h"
- 
- #if defined(LIBC_SCCS) && !defined(lint)
- __RCSID("$NetBSD: strlcpy.c,v 1.1 2005/12/20 19:28:52 christos Exp $");
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/sys.h ./sys.h
---- /home/cminyard/m1/libedit-20060103-2.9/src/sys.h	2006-01-03 06:41:24.000000000 -0600
-+++ ./sys.h	2006-02-10 09:57:51.724052912 -0600
-@@ -151,4 +151,7 @@
- extern char    *fgetline(FILE *, int *);
- #endif
- 
-+#define SCCSID
-+#undef LIBC_SCCS
-+
- #endif /* _h_sys */
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/term.c ./term.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/term.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./term.c	2006-02-10 10:00:02.258503726 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)term.c	8.2 (Berkeley) 4/30/95";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/tokenizer.c ./tokenizer.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/tokenizer.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./tokenizer.c	2006-02-10 10:00:28.114225431 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)tokenizer.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/tty.c ./tty.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/tty.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./tty.c	2006-02-10 10:00:09.316608825 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #if !defined(lint) && !defined(SCCSID)
- #if 0
- static char sccsid[] = "@(#)tty.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/unvis.c ./unvis.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/unvis.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./unvis.c	2006-02-10 10:20:11.476201625 -0600
-@@ -29,7 +29,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include <config.h>
-+#include "sys.h"
- #if defined(LIBC_SCCS) && !defined(lint)
- #if 0
- static char sccsid[] = "@(#)unvis.c	8.1 (Berkeley) 6/4/93";
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/vi.c ./vi.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/vi.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./vi.c	2006-02-10 10:00:15.555817746 -0600
-@@ -32,7 +32,7 @@
-  * SUCH DAMAGE.
-  */
- 
--#include "config.h"
-+#include "sys.h"
- #include <stdlib.h>
- #include <unistd.h>
- #include <sys/wait.h>
-diff -u /home/cminyard/m1/libedit-20060103-2.9/src/vis.c ./vis.c
---- /home/cminyard/m1/libedit-20060103-2.9/src/vis.c	2006-01-03 06:41:24.000000000 -0600
-+++ ./vis.c	2006-02-10 10:19:53.879432910 -0600
-@@ -67,7 +67,7 @@
-  #pragma alloca
- #endif
- 
--#include <config.h>
-+#include "sys.h"
- 
- #ifdef __GNUC__
- # undef alloca
diff --git a/libedit/orig_editline.diff2 b/libedit/orig_editline.diff2
deleted file mode 100644
index cf485d4..0000000
--- a/libedit/orig_editline.diff2
+++ /dev/null
@@ -1,628 +0,0 @@
-? common.h
-? emacs.h
-? fcns.c
-? fcns.h
-? help.c
-? help.h
-? orig_editline.diff2
-? vi.h
-Index: read.c
-===================================================================
-RCS file: /cvsroot/openipmi/OpenIPMI/libedit/read.c,v
-retrieving revision 1.1
-diff -u -r1.1 read.c
---- read.c	10 Feb 2006 16:38:52 -0000	1.1
-+++ read.c	28 Feb 2006 15:38:28 -0000
-@@ -1,612 +0,0 @@
--/*	$NetBSD: read.c,v 1.39 2005/08/02 12:11:14 christos Exp $	*/
--
--/*-
-- * Copyright (c) 1992, 1993
-- *	The Regents of the University of California.  All rights reserved.
-- *
-- * This code is derived from software contributed to Berkeley by
-- * Christos Zoulas of Cornell University.
-- *
-- * Redistribution and use in source and binary forms, with or without
-- * modification, are permitted provided that the following conditions
-- * are met:
-- * 1. Redistributions of source code must retain the above copyright
-- *    notice, this list of conditions and the following disclaimer.
-- * 2. Redistributions in binary form must reproduce the above copyright
-- *    notice, this list of conditions and the following disclaimer in the
-- *    documentation and/or other materials provided with the distribution.
-- * 3. Neither the name of the University nor the names of its contributors
-- *    may be used to endorse or promote products derived from this software
-- *    without specific prior written permission.
-- *
-- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
-- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
-- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-- * SUCH DAMAGE.
-- */
--
--#include "sys.h"
--#if !defined(lint) && !defined(SCCSID)
--#if 0
--static char sccsid[] = "@(#)read.c	8.1 (Berkeley) 6/4/93";
--#else
--__RCSID("$NetBSD: read.c,v 1.39 2005/08/02 12:11:14 christos Exp $");
--#endif
--#endif /* not lint && not SCCSID */
--
--/*
-- * read.c: Clean this junk up! This is horrible code.
-- *	   Terminal read functions
-- */
--#include <errno.h>
--#include <fcntl.h>
--#include <unistd.h>
--#include <stdlib.h>
--#include "el.h"
--
--#define	OKCMD	-1
--
--private int	read__fixio(int, int);
--private int	read_preread(EditLine *);
--private int	read_char(EditLine *, char *);
--private int	read_getcmd(EditLine *, el_action_t *, char *);
--
--/* read_init():
-- *	Initialize the read stuff
-- */
--protected int
--read_init(EditLine *el)
--{
--	/* builtin read_char */
--	el->el_read.read_char = read_char;
--	return 0;
--}
--
--
--/* el_read_setfn():
-- *	Set the read char function to the one provided.
-- *	If it is set to EL_BUILTIN_GETCFN, then reset to the builtin one.
-- */
--protected int
--el_read_setfn(EditLine *el, el_rfunc_t rc)
--{
--	el->el_read.read_char = (rc == EL_BUILTIN_GETCFN) ? read_char : rc;
--	return 0;
--}
--
--
--/* el_read_getfn():
-- *	return the current read char function, or EL_BUILTIN_GETCFN
-- *	if it is the default one
-- */
--protected el_rfunc_t
--el_read_getfn(EditLine *el)
--{
--       return (el->el_read.read_char == read_char) ?
--	    EL_BUILTIN_GETCFN : el->el_read.read_char;
--}
--
--
--#ifndef MIN
--#define MIN(A,B) ((A) < (B) ? (A) : (B))
--#endif
--
--#ifdef DEBUG_EDIT
--private void
--read_debug(EditLine *el)
--{
--
--	if (el->el_line.cursor > el->el_line.lastchar)
--		(void) fprintf(el->el_errfile, "cursor > lastchar\r\n");
--	if (el->el_line.cursor < el->el_line.buffer)
--		(void) fprintf(el->el_errfile, "cursor < buffer\r\n");
--	if (el->el_line.cursor > el->el_line.limit)
--		(void) fprintf(el->el_errfile, "cursor > limit\r\n");
--	if (el->el_line.lastchar > el->el_line.limit)
--		(void) fprintf(el->el_errfile, "lastchar > limit\r\n");
--	if (el->el_line.limit != &el->el_line.buffer[EL_BUFSIZ - 2])
--		(void) fprintf(el->el_errfile, "limit != &buffer[EL_BUFSIZ-2]\r\n");
--}
--#endif /* DEBUG_EDIT */
--
--
--/* read__fixio():
-- *	Try to recover from a read error
-- */
--/* ARGSUSED */
--private int
--read__fixio(int fd __attribute__((__unused__)), int e)
--{
--
--	switch (e) {
--	case -1:		/* Make sure that the code is reachable */
--
--#ifdef EWOULDBLOCK
--	case EWOULDBLOCK:
--#ifndef TRY_AGAIN
--#define	TRY_AGAIN
--#endif
--#endif /* EWOULDBLOCK */
--
--#if defined(POSIX) && defined(EAGAIN)
--#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
--	case EAGAIN:
--#ifndef TRY_AGAIN
--#define	TRY_AGAIN
--#endif
--#endif /* EWOULDBLOCK && EWOULDBLOCK != EAGAIN */
--#endif /* POSIX && EAGAIN */
--
--		e = 0;
--#ifdef TRY_AGAIN
--#if defined(F_SETFL) && defined(O_NDELAY)
--		if ((e = fcntl(fd, F_GETFL, 0)) == -1)
--			return (-1);
--
--		if (fcntl(fd, F_SETFL, e & ~O_NDELAY) == -1)
--			return (-1);
--		else
--			e = 1;
--#endif /* F_SETFL && O_NDELAY */
--
--#ifdef FIONBIO
--		{
--			int zero = 0;
--
--			if (ioctl(fd, FIONBIO, (ioctl_t) & zero) == -1)
--				return (-1);
--			else
--				e = 1;
--		}
--#endif /* FIONBIO */
--
--#endif /* TRY_AGAIN */
--		return (e ? 0 : -1);
--
--	case EINTR:
--		return (0);
--
--	default:
--		return (-1);
--	}
--}
--
--
--/* read_preread():
-- *	Try to read the stuff in the input queue;
-- */
--private int
--read_preread(EditLine *el)
--{
--	int chrs = 0;
--
--	if (el->el_tty.t_mode == ED_IO)
--		return (0);
--
--#ifdef FIONREAD
--	(void) ioctl(el->el_infd, FIONREAD, (ioctl_t) & chrs);
--	if (chrs > 0) {
--		char buf[EL_BUFSIZ];
--
--		chrs = read(el->el_infd, buf,
--		    (size_t) MIN(chrs, EL_BUFSIZ - 1));
--		if (chrs > 0) {
--			buf[chrs] = '\0';
--			el_push(el, buf);
--		}
--	}
--#endif /* FIONREAD */
--
--	return (chrs > 0);
--}
--
--
--/* el_push():
-- *	Push a macro
-- */
--public void
--el_push(EditLine *el, char *str)
--{
--	c_macro_t *ma = &el->el_chared.c_macro;
--
--	if (str != NULL && ma->level + 1 < EL_MAXMACRO) {
--		ma->level++;
--		if ((ma->macro[ma->level] = el_strdup(str)) != NULL)
--			return;
--		ma->level--;
--	}
--	term_beep(el);
--	term__flush();
--}
--
--
--/* read_getcmd():
-- *	Return next command from the input stream.
-- */
--private int
--read_getcmd(EditLine *el, el_action_t *cmdnum, char *ch)
--{
--	el_action_t cmd;
--	int num;
--
--	do {
--		if ((num = el_getc(el, ch)) != 1)	/* if EOF or error */
--			return (num);
--
--#ifdef	KANJI
--		if ((*ch & 0200)) {
--			el->el_state.metanext = 0;
--			cmd = CcViMap[' '];
--			break;
--		} else
--#endif /* KANJI */
--
--		if (el->el_state.metanext) {
--			el->el_state.metanext = 0;
--			*ch |= 0200;
--		}
--		cmd = el->el_map.current[(unsigned char) *ch];
--		if (cmd == ED_SEQUENCE_LEAD_IN) {
--			key_value_t val;
--			switch (key_get(el, ch, &val)) {
--			case XK_CMD:
--				cmd = val.cmd;
--				break;
--			case XK_STR:
--				el_push(el, val.str);
--				break;
--#ifdef notyet
--			case XK_EXE:
--				/* XXX: In the future to run a user function */
--				RunCommand(val.str);
--				break;
--#endif
--			default:
--				EL_ABORT((el->el_errfile, "Bad XK_ type \n"));
--				break;
--			}
--		}
--		if (el->el_map.alt == NULL)
--			el->el_map.current = el->el_map.key;
--	} while (cmd == ED_SEQUENCE_LEAD_IN);
--	*cmdnum = cmd;
--	return (OKCMD);
--}
--
--
--/* read_char():
-- *	Read a character from the tty.
-- */
--private int
--read_char(EditLine *el, char *cp)
--{
--	int num_read;
--	int tried = 0;
--
--	while ((num_read = read(el->el_infd, cp, 1)) == -1)
--		if (!tried && read__fixio(el->el_infd, errno) == 0)
--			tried = 1;
--		else {
--			*cp = '\0';
--			return (-1);
--		}
--
--	return (num_read);
--}
--
--
--/* el_getc():
-- *	Read a character
-- */
--public int
--el_getc(EditLine *el, char *cp)
--{
--	int num_read;
--	c_macro_t *ma = &el->el_chared.c_macro;
--
--	term__flush();
--	for (;;) {
--		if (ma->level < 0) {
--			if (!read_preread(el))
--				break;
--		}
--		if (ma->level < 0)
--			break;
--
--		if (ma->macro[ma->level][ma->offset] == '\0') {
--			el_free(ma->macro[ma->level--]);
--			ma->offset = 0;
--			continue;
--		}
--		*cp = ma->macro[ma->level][ma->offset++] & 0377;
--		if (ma->macro[ma->level][ma->offset] == '\0') {
--			/* Needed for QuoteMode On */
--			el_free(ma->macro[ma->level--]);
--			ma->offset = 0;
--		}
--		return (1);
--	}
--
--#ifdef DEBUG_READ
--	(void) fprintf(el->el_errfile, "Turning raw mode on\n");
--#endif /* DEBUG_READ */
--	if (tty_rawmode(el) < 0)/* make sure the tty is set up correctly */
--		return (0);
--
--#ifdef DEBUG_READ
--	(void) fprintf(el->el_errfile, "Reading a character\n");
--#endif /* DEBUG_READ */
--	num_read = (*el->el_read.read_char)(el, cp);
--#ifdef DEBUG_READ
--	(void) fprintf(el->el_errfile, "Got it %c\n", *cp);
--#endif /* DEBUG_READ */
--	return (num_read);
--}
--
--protected void
--read_prepare(EditLine *el)
--{
--	if (el->el_flags & HANDLE_SIGNALS)
--		sig_set(el);
--	if (el->el_flags & NO_TTY)
--		return;
--	if ((el->el_flags & (UNBUFFERED|EDIT_DISABLED)) == UNBUFFERED)
--		tty_rawmode(el);
--
--	/* This is relatively cheap, and things go terribly wrong if
--	   we have the wrong size. */
--	el_resize(el);
--	re_clear_display(el);	/* reset the display stuff */
--	ch_reset(el, 0);
--	re_refresh(el);		/* print the prompt */
--
--	if (el->el_flags & UNBUFFERED)
--		term__flush();
--}
--
--protected void
--read_finish(EditLine *el)
--{
--	if ((el->el_flags & UNBUFFERED) == 0)
--		(void) tty_cookedmode(el);
--	if (el->el_flags & HANDLE_SIGNALS)
--		sig_clr(el);
--}
--
--public const char *
--el_gets(EditLine *el, int *nread)
--{
--	int retval;
--	el_action_t cmdnum = 0;
--	int num;		/* how many chars we have read at NL */
--	char ch;
--	int crlf = 0;
--#ifdef FIONREAD
--	c_macro_t *ma = &el->el_chared.c_macro;
--#endif /* FIONREAD */
--
--	if (el->el_flags & NO_TTY) {
--		char *cp = el->el_line.buffer;
--		size_t idx;
--
--		while ((*el->el_read.read_char)(el, cp) == 1) {
--			/* make sure there is space for next character */
--			if (cp + 1 >= el->el_line.limit) {
--				idx = (cp - el->el_line.buffer);
--				if (!ch_enlargebufs(el, 2))
--					break;
--				cp = &el->el_line.buffer[idx];
--			}
--			cp++;
--			if (el->el_flags & UNBUFFERED)
--				break;
--			if (cp[-1] == '\r' || cp[-1] == '\n')
--				break;
--		}
--
--		el->el_line.cursor = el->el_line.lastchar = cp;
--		*cp = '\0';
--		if (nread)
--			*nread = el->el_line.cursor - el->el_line.buffer;
--		return (el->el_line.buffer);
--	}
--
--
--#ifdef FIONREAD
--	if (el->el_tty.t_mode == EX_IO && ma->level < 0) {
--		long chrs = 0;
--
--		(void) ioctl(el->el_infd, FIONREAD, (ioctl_t) & chrs);
--		if (chrs == 0) {
--			if (tty_rawmode(el) < 0) {
--				if (nread)
--					*nread = 0;
--				return (NULL);
--			}
--		}
--	}
--#endif /* FIONREAD */
--
--	if ((el->el_flags & UNBUFFERED) == 0)
--		read_prepare(el);
--
--	if (el->el_flags & EDIT_DISABLED) {
--		char *cp;
--		size_t idx;
--		if ((el->el_flags & UNBUFFERED) == 0)
--			cp = el->el_line.buffer;
--		else
--			cp = el->el_line.lastchar;
--
--		term__flush();
--
--		while ((*el->el_read.read_char)(el, cp) == 1) {
--			/* make sure there is space next character */
--			if (cp + 1 >= el->el_line.limit) {
--				idx = (cp - el->el_line.buffer);
--				if (!ch_enlargebufs(el, 2))
--					break;
--				cp = &el->el_line.buffer[idx];
--			}
--			if (*cp == 4)	/* ought to be stty eof */
--				break;
--			cp++;
--			crlf = cp[-1] == '\r' || cp[-1] == '\n';
--			if (el->el_flags & UNBUFFERED)
--				break;
--			if (crlf)
--				break;
--		}
--
--		el->el_line.cursor = el->el_line.lastchar = cp;
--		*cp = '\0';
--		if (nread)
--			*nread = el->el_line.cursor - el->el_line.buffer;
--		return (el->el_line.buffer);
--	}
--
--	for (num = OKCMD; num == OKCMD;) {	/* while still editing this
--						 * line */
--#ifdef DEBUG_EDIT
--		read_debug(el);
--#endif /* DEBUG_EDIT */
--		/* if EOF or error */
--		if ((num = read_getcmd(el, &cmdnum, &ch)) != OKCMD) {
--#ifdef DEBUG_READ
--			(void) fprintf(el->el_errfile,
--			    "Returning from el_gets %d\n", num);
--#endif /* DEBUG_READ */
--			break;
--		}
--		if ((unsigned int)cmdnum >= el->el_map.nfunc) {	/* BUG CHECK command */
--#ifdef DEBUG_EDIT
--			(void) fprintf(el->el_errfile,
--			    "ERROR: illegal command from key 0%o\r\n", ch);
--#endif /* DEBUG_EDIT */
--			continue;	/* try again */
--		}
--		/* now do the real command */
--#ifdef DEBUG_READ
--		{
--			el_bindings_t *b;
--			for (b = el->el_map.help; b->name; b++)
--				if (b->func == cmdnum)
--					break;
--			if (b->name)
--				(void) fprintf(el->el_errfile,
--				    "Executing %s\n", b->name);
--			else
--				(void) fprintf(el->el_errfile,
--				    "Error command = %d\n", cmdnum);
--		}
--#endif /* DEBUG_READ */
--		/* vi redo needs these way down the levels... */
--		el->el_state.thiscmd = cmdnum;
--		el->el_state.thisch = ch;
--		if (el->el_map.type == MAP_VI &&
--		    el->el_map.current == el->el_map.key &&
--		    el->el_chared.c_redo.pos < el->el_chared.c_redo.lim) {
--			if (cmdnum == VI_DELETE_PREV_CHAR &&
--			    el->el_chared.c_redo.pos != el->el_chared.c_redo.buf
--			    && isprint((unsigned char)el->el_chared.c_redo.pos[-1]))
--				el->el_chared.c_redo.pos--;
--			else
--				*el->el_chared.c_redo.pos++ = ch;
--		}
--		retval = (*el->el_map.func[cmdnum]) (el, ch);
--#ifdef DEBUG_READ
--		(void) fprintf(el->el_errfile,
--			"Returned state %d\n", retval );
--#endif /* DEBUG_READ */
--
--		/* save the last command here */
--		el->el_state.lastcmd = cmdnum;
--
--		/* use any return value */
--		switch (retval) {
--		case CC_CURSOR:
--			re_refresh_cursor(el);
--			break;
--
--		case CC_REDISPLAY:
--			re_clear_lines(el);
--			re_clear_display(el);
--			/* FALLTHROUGH */
--
--		case CC_REFRESH:
--			re_refresh(el);
--			break;
--
--		case CC_REFRESH_BEEP:
--			re_refresh(el);
--			term_beep(el);
--			break;
--
--		case CC_NORM:	/* normal char */
--			break;
--
--		case CC_ARGHACK:	/* Suggested by Rich Salz */
--			/* <rsalz@pineapple.bbn.com> */
--			continue;	/* keep going... */
--
--		case CC_EOF:	/* end of file typed */
--			if ((el->el_flags & UNBUFFERED) == 0)
--				num = 0;
--			else if (num == -1) {
--				*el->el_line.lastchar++ = CONTROL('d');
--				el->el_line.cursor = el->el_line.lastchar;
--				num = 1;
--			}
--			break;
--
--		case CC_NEWLINE:	/* normal end of line */
--			num = el->el_line.lastchar - el->el_line.buffer;
--			break;
--
--		case CC_FATAL:	/* fatal error, reset to known state */
--#ifdef DEBUG_READ
--			(void) fprintf(el->el_errfile,
--			    "*** editor fatal ERROR ***\r\n\n");
--#endif /* DEBUG_READ */
--			/* put (real) cursor in a known place */
--			re_clear_display(el);	/* reset the display stuff */
--			ch_reset(el, 1);	/* reset the input pointers */
--			re_refresh(el);	/* print the prompt again */
--			break;
--
--		case CC_ERROR:
--		default:	/* functions we don't know about */
--#ifdef DEBUG_READ
--			(void) fprintf(el->el_errfile,
--			    "*** editor ERROR ***\r\n\n");
--#endif /* DEBUG_READ */
--			term_beep(el);
--			term__flush();
--			break;
--		}
--		el->el_state.argument = 1;
--		el->el_state.doingarg = 0;
--		el->el_chared.c_vcmd.action = NOP;
--		if (el->el_flags & UNBUFFERED)
--			break;
--	}
--
--	term__flush();		/* flush any buffered output */
--	/* make sure the tty is set up correctly */
--	if ((el->el_flags & UNBUFFERED) == 0) {
--		read_finish(el);
--		if (nread)
--			*nread = num;
--	} else {
--		if (nread)
--			*nread = el->el_line.lastchar - el->el_line.buffer;
--	}
--	return (num ? el->el_line.buffer : NULL);
--}
diff --git a/libedit/parse.c b/libedit/parse.c
deleted file mode 100644
index 3b98ea9..0000000
--- a/libedit/parse.c
+++ /dev/null
@@ -1,263 +0,0 @@
-/*	$NetBSD: parse.c,v 1.22 2005/05/29 04:58:15 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)parse.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: parse.c,v 1.22 2005/05/29 04:58:15 lukem Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * parse.c: parse an editline extended command
- *
- * commands are:
- *
- *	bind
- *	echotc
- *	edit
- *	gettc
- *	history
- *	settc
- *	setty
- */
-#include "el.h"
-#include <stdlib.h>
-
-private const struct {
-	const char *name;
-	int (*func)(EditLine *, int, const char **);
-} cmds[] = {
-	{ "bind",	map_bind	},
-	{ "echotc",	term_echotc	},
-	{ "edit",	el_editmode	},
-	{ "history",	hist_command	},
-	{ "telltc",	term_telltc	},
-	{ "settc",	term_settc	},
-	{ "setty",	tty_stty	},
-	{ NULL,		NULL		}
-};
-
-
-/* parse_line():
- *	Parse a line and dispatch it
- */
-protected int
-parse_line(EditLine *el, const char *line)
-{
-	const char **argv;
-	int argc;
-	Tokenizer *tok;
-
-	tok = tok_init(NULL);
-	tok_str(tok, line, &argc, &argv);
-	argc = el_parse(el, argc, argv);
-	tok_end(tok);
-	return (argc);
-}
-
-
-/* el_parse():
- *	Command dispatcher
- */
-public int
-el_parse(EditLine *el, int argc, const char *argv[])
-{
-	const char *ptr;
-	int i;
-
-	if (argc < 1)
-		return (-1);
-	ptr = strchr(argv[0], ':');
-	if (ptr != NULL) {
-		char *tprog;
-		size_t l;
-
-		if (ptr == argv[0])
-			return (0);
-		l = ptr - argv[0] - 1;
-		tprog = (char *) el_malloc(l + 1);
-		if (tprog == NULL)
-			return (0);
-		(void) strncpy(tprog, argv[0], l);
-		tprog[l] = '\0';
-		ptr++;
-		l = el_match(el->el_prog, tprog);
-		el_free(tprog);
-		if (!l)
-			return (0);
-	} else
-		ptr = argv[0];
-
-	for (i = 0; cmds[i].name != NULL; i++)
-		if (strcmp(cmds[i].name, ptr) == 0) {
-			i = (*cmds[i].func) (el, argc, argv);
-			return (-i);
-		}
-	return (-1);
-}
-
-
-/* parse__escape():
- *	Parse a string of the form ^<char> \<odigit> \<char> and return
- *	the appropriate character or -1 if the escape is not valid
- */
-protected int
-parse__escape(const char **ptr)
-{
-	const char *p;
-	int c;
-
-	p = *ptr;
-
-	if (p[1] == 0)
-		return (-1);
-
-	if (*p == '\\') {
-		p++;
-		switch (*p) {
-		case 'a':
-			c = '\007';	/* Bell */
-			break;
-		case 'b':
-			c = '\010';	/* Backspace */
-			break;
-		case 't':
-			c = '\011';	/* Horizontal Tab */
-			break;
-		case 'n':
-			c = '\012';	/* New Line */
-			break;
-		case 'v':
-			c = '\013';	/* Vertical Tab */
-			break;
-		case 'f':
-			c = '\014';	/* Form Feed */
-			break;
-		case 'r':
-			c = '\015';	/* Carriage Return */
-			break;
-		case 'e':
-			c = '\033';	/* Escape */
-			break;
-		case '0':
-		case '1':
-		case '2':
-		case '3':
-		case '4':
-		case '5':
-		case '6':
-		case '7':
-		{
-			int cnt, ch;
-
-			for (cnt = 0, c = 0; cnt < 3; cnt++) {
-				ch = *p++;
-				if (ch < '0' || ch > '7') {
-					p--;
-					break;
-				}
-				c = (c << 3) | (ch - '0');
-			}
-			if ((c & 0xffffff00) != 0)
-				return (-1);
-			--p;
-			break;
-		}
-		default:
-			c = *p;
-			break;
-		}
-	} else if (*p == '^') {
-		p++;
-		c = (*p == '?') ? '\177' : (*p & 0237);
-	} else
-		c = *p;
-	*ptr = ++p;
-	return (c);
-}
-
-/* parse__string():
- *	Parse the escapes from in and put the raw string out
- */
-protected char *
-parse__string(char *out, const char *in)
-{
-	char *rv = out;
-	int n;
-
-	for (;;)
-		switch (*in) {
-		case '\0':
-			*out = '\0';
-			return (rv);
-
-		case '\\':
-		case '^':
-			if ((n = parse__escape(&in)) == -1)
-				return (NULL);
-			*out++ = n;
-			break;
-
-		case 'M':
-			if (in[1] == '-' && in[2] != '\0') {
-				*out++ = '\033';
-				in += 2;
-				break;
-			}
-			/*FALLTHROUGH*/
-
-		default:
-			*out++ = *in++;
-			break;
-		}
-}
-
-
-/* parse_cmd():
- *	Return the command number for the command string given
- *	or -1 if one is not found
- */
-protected int
-parse_cmd(EditLine *el, const char *cmd)
-{
-	el_bindings_t *b;
-
-	for (b = el->el_map.help; b->name != NULL; b++)
-		if (strcmp(b->name, cmd) == 0)
-			return (b->func);
-	return (-1);
-}
diff --git a/libedit/parse.h b/libedit/parse.h
deleted file mode 100644
index 58dced1..0000000
--- a/libedit/parse.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*	$NetBSD: parse.h,v 1.6 2005/05/29 04:58:15 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)parse.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.parse.h: Parser functions
- */
-#ifndef _h_el_parse
-#define	_h_el_parse
-
-protected int	 parse_line(EditLine *, const char *);
-protected int	 parse__escape(const char **);
-protected char	*parse__string(char *, const char *);
-protected int	 parse_cmd(EditLine *, const char *);
-
-#endif /* _h_el_parse */
diff --git a/libedit/prompt.c b/libedit/prompt.c
deleted file mode 100644
index 647f9c7..0000000
--- a/libedit/prompt.c
+++ /dev/null
@@ -1,170 +0,0 @@
-/*	$NetBSD: prompt.c,v 1.11 2003/08/07 16:44:32 agc Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)prompt.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: prompt.c,v 1.11 2003/08/07 16:44:32 agc Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * prompt.c: Prompt printing functions
- */
-#include <stdio.h>
-#include "el.h"
-
-private char	*prompt_default(EditLine *);
-private char	*prompt_default_r(EditLine *);
-
-/* prompt_default():
- *	Just a default prompt, in case the user did not provide one
- */
-private char *
-/*ARGSUSED*/
-prompt_default(EditLine *el __attribute__((__unused__)))
-{
-	static char a[3] = {'?', ' ', '\0'};
-
-	return (a);
-}
-
-
-/* prompt_default_r():
- *	Just a default rprompt, in case the user did not provide one
- */
-private char *
-/*ARGSUSED*/
-prompt_default_r(EditLine *el __attribute__((__unused__)))
-{
-	static char a[1] = {'\0'};
-
-	return (a);
-}
-
-
-/* prompt_print():
- *	Print the prompt and update the prompt position.
- *	We use an array of integers in case we want to pass
- * 	literal escape sequences in the prompt and we want a
- *	bit to flag them
- */
-protected void
-prompt_print(EditLine *el, int op)
-{
-	el_prompt_t *elp;
-	char *p;
-
-	if (op == EL_PROMPT)
-		elp = &el->el_prompt;
-	else
-		elp = &el->el_rprompt;
-	p = (elp->p_func) (el);
-	while (*p)
-		re_putc(el, *p++, 1);
-
-	elp->p_pos.v = el->el_refresh.r_cursor.v;
-	elp->p_pos.h = el->el_refresh.r_cursor.h;
-}
-
-
-/* prompt_init():
- *	Initialize the prompt stuff
- */
-protected int
-prompt_init(EditLine *el)
-{
-
-	el->el_prompt.p_func = prompt_default;
-	el->el_prompt.p_pos.v = 0;
-	el->el_prompt.p_pos.h = 0;
-	el->el_rprompt.p_func = prompt_default_r;
-	el->el_rprompt.p_pos.v = 0;
-	el->el_rprompt.p_pos.h = 0;
-	return (0);
-}
-
-
-/* prompt_end():
- *	Clean up the prompt stuff
- */
-protected void
-/*ARGSUSED*/
-prompt_end(EditLine *el __attribute__((__unused__)))
-{
-}
-
-
-/* prompt_set():
- *	Install a prompt printing function
- */
-protected int
-prompt_set(EditLine *el, el_pfunc_t prf, int op)
-{
-	el_prompt_t *p;
-
-	if (op == EL_PROMPT)
-		p = &el->el_prompt;
-	else
-		p = &el->el_rprompt;
-	if (prf == NULL) {
-		if (op == EL_PROMPT)
-			p->p_func = prompt_default;
-		else
-			p->p_func = prompt_default_r;
-	} else
-		p->p_func = prf;
-	p->p_pos.v = 0;
-	p->p_pos.h = 0;
-	return (0);
-}
-
-
-/* prompt_get():
- *	Retrieve the prompt printing function
- */
-protected int
-prompt_get(EditLine *el, el_pfunc_t *prf, int op)
-{
-
-	if (prf == NULL)
-		return (-1);
-	if (op == EL_PROMPT)
-		*prf = el->el_prompt.p_func;
-	else
-		*prf = el->el_rprompt.p_func;
-	return (0);
-}
diff --git a/libedit/prompt.h b/libedit/prompt.h
deleted file mode 100644
index d181108..0000000
--- a/libedit/prompt.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*	$NetBSD: prompt.h,v 1.6 2003/08/07 16:44:32 agc Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)prompt.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.prompt.h: Prompt printing stuff
- */
-#ifndef _h_el_prompt
-#define	_h_el_prompt
-
-#include "histedit.h"
-
-typedef char * (*el_pfunc_t)(EditLine*);
-
-typedef struct el_prompt_t {
-	el_pfunc_t	p_func;	/* Function to return the prompt	*/
-	coord_t		p_pos;	/* position in the line after prompt	*/
-} el_prompt_t;
-
-protected void	prompt_print(EditLine *, int);
-protected int	prompt_set(EditLine *, el_pfunc_t, int);
-protected int	prompt_get(EditLine *, el_pfunc_t *, int);
-protected int	prompt_init(EditLine *);
-protected void	prompt_end(EditLine *);
-
-#endif /* _h_el_prompt */
diff --git a/libedit/read.c b/libedit/read.c
deleted file mode 100644
index 8cbbdde..0000000
--- a/libedit/read.c
+++ /dev/null
@@ -1,614 +0,0 @@
-/*	$NetBSD: read.c,v 1.39 2005/08/02 12:11:14 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)read.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: read.c,v 1.39 2005/08/02 12:11:14 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * read.c: Clean this junk up! This is horrible code.
- *	   Terminal read functions
- */
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include "el.h"
-
-#define	OKCMD	-1
-
-private int	read__fixio(int, int);
-private int	read_preread(EditLine *);
-private int	read_char(EditLine *, char *);
-private int	read_getcmd(EditLine *, el_action_t *, char *);
-
-/* read_init():
- *	Initialize the read stuff
- */
-protected int
-read_init(EditLine *el)
-{
-	/* builtin read_char */
-	el->el_read.read_char = read_char;
-	return 0;
-}
-
-
-/* el_read_setfn():
- *	Set the read char function to the one provided.
- *	If it is set to EL_BUILTIN_GETCFN, then reset to the builtin one.
- */
-protected int
-el_read_setfn(EditLine *el, el_rfunc_t rc)
-{
-	el->el_read.read_char = (rc == EL_BUILTIN_GETCFN) ? read_char : rc;
-	return 0;
-}
-
-
-/* el_read_getfn():
- *	return the current read char function, or EL_BUILTIN_GETCFN
- *	if it is the default one
- */
-protected el_rfunc_t
-el_read_getfn(EditLine *el)
-{
-       return (el->el_read.read_char == read_char) ?
-	    EL_BUILTIN_GETCFN : el->el_read.read_char;
-}
-
-
-#ifndef MIN
-#define MIN(A,B) ((A) < (B) ? (A) : (B))
-#endif
-
-#ifdef DEBUG_EDIT
-private void
-read_debug(EditLine *el)
-{
-
-	if (el->el_line.cursor > el->el_line.lastchar)
-		(void) fprintf(el->el_errfile, "cursor > lastchar\r\n");
-	if (el->el_line.cursor < el->el_line.buffer)
-		(void) fprintf(el->el_errfile, "cursor < buffer\r\n");
-	if (el->el_line.cursor > el->el_line.limit)
-		(void) fprintf(el->el_errfile, "cursor > limit\r\n");
-	if (el->el_line.lastchar > el->el_line.limit)
-		(void) fprintf(el->el_errfile, "lastchar > limit\r\n");
-	if (el->el_line.limit != &el->el_line.buffer[EL_BUFSIZ - 2])
-		(void) fprintf(el->el_errfile, "limit != &buffer[EL_BUFSIZ-2]\r\n");
-}
-#endif /* DEBUG_EDIT */
-
-
-/* read__fixio():
- *	Try to recover from a read error
- */
-/* ARGSUSED */
-private int
-read__fixio(int fd __attribute__((__unused__)), int e)
-{
-
-	switch (e) {
-	case -1:		/* Make sure that the code is reachable */
-
-#ifdef EWOULDBLOCK
-	case EWOULDBLOCK:
-#ifndef TRY_AGAIN
-#define	TRY_AGAIN
-#endif
-#endif /* EWOULDBLOCK */
-
-#if defined(POSIX) && defined(EAGAIN)
-#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
-	case EAGAIN:
-#ifndef TRY_AGAIN
-#define	TRY_AGAIN
-#endif
-#endif /* EWOULDBLOCK && EWOULDBLOCK != EAGAIN */
-#endif /* POSIX && EAGAIN */
-
-		e = 0;
-#ifdef TRY_AGAIN
-#if defined(F_SETFL) && defined(O_NDELAY)
-		if ((e = fcntl(fd, F_GETFL, 0)) == -1)
-			return (-1);
-
-		if (fcntl(fd, F_SETFL, e & ~O_NDELAY) == -1)
-			return (-1);
-		else
-			e = 1;
-#endif /* F_SETFL && O_NDELAY */
-
-#ifdef FIONBIO
-		{
-			int zero = 0;
-
-			if (ioctl(fd, FIONBIO, (ioctl_t) & zero) == -1)
-				return (-1);
-			else
-				e = 1;
-		}
-#endif /* FIONBIO */
-
-#endif /* TRY_AGAIN */
-		return (e ? 0 : -1);
-
-	case EINTR:
-		return (0);
-
-	default:
-		return (-1);
-	}
-}
-
-
-/* read_preread():
- *	Try to read the stuff in the input queue;
- */
-private int
-read_preread(EditLine *el)
-{
-	int chrs = 0;
-
-	if (el->el_tty.t_mode == ED_IO)
-		return (0);
-
-#ifdef FIONREAD
-	(void) ioctl(el->el_infd, FIONREAD, (ioctl_t) & chrs);
-	if (chrs > 0) {
-		char buf[EL_BUFSIZ];
-
-		chrs = read(el->el_infd, buf,
-		    (size_t) MIN(chrs, EL_BUFSIZ - 1));
-		if (chrs > 0) {
-			buf[chrs] = '\0';
-			el_push(el, buf);
-		}
-	}
-#endif /* FIONREAD */
-
-	return (chrs > 0);
-}
-
-
-/* el_push():
- *	Push a macro
- */
-public void
-el_push(EditLine *el, char *str)
-{
-	c_macro_t *ma = &el->el_chared.c_macro;
-
-	if (str != NULL && ma->level + 1 < EL_MAXMACRO) {
-		ma->level++;
-		if ((ma->macro[ma->level] = el_strdup(str)) != NULL)
-			return;
-		ma->level--;
-	}
-#if 0 /* TCM - why on earth would you beep here? */
-	term_beep(el);
-#endif
-	term__flush();
-}
-
-
-/* read_getcmd():
- *	Return next command from the input stream.
- */
-private int
-read_getcmd(EditLine *el, el_action_t *cmdnum, char *ch)
-{
-	el_action_t cmd;
-	int num;
-
-	do {
-		if ((num = el_getc(el, ch)) != 1)	/* if EOF or error */
-			return (num);
-
-#ifdef	KANJI
-		if ((*ch & 0200)) {
-			el->el_state.metanext = 0;
-			cmd = CcViMap[' '];
-			break;
-		} else
-#endif /* KANJI */
-
-		if (el->el_state.metanext) {
-			el->el_state.metanext = 0;
-			*ch |= 0200;
-		}
-		cmd = el->el_map.current[(unsigned char) *ch];
-		if (cmd == ED_SEQUENCE_LEAD_IN) {
-			key_value_t val;
-			switch (key_get(el, ch, &val)) {
-			case XK_CMD:
-				cmd = val.cmd;
-				break;
-			case XK_STR:
-				el_push(el, val.str);
-				break;
-#ifdef notyet
-			case XK_EXE:
-				/* XXX: In the future to run a user function */
-				RunCommand(val.str);
-				break;
-#endif
-			default:
-				EL_ABORT((el->el_errfile, "Bad XK_ type \n"));
-				break;
-			}
-		}
-		if (el->el_map.alt == NULL)
-			el->el_map.current = el->el_map.key;
-	} while (cmd == ED_SEQUENCE_LEAD_IN);
-	*cmdnum = cmd;
-	return (OKCMD);
-}
-
-
-/* read_char():
- *	Read a character from the tty.
- */
-private int
-read_char(EditLine *el, char *cp)
-{
-	int num_read;
-	int tried = 0;
-
-	while ((num_read = read(el->el_infd, cp, 1)) == -1)
-		if (!tried && read__fixio(el->el_infd, errno) == 0)
-			tried = 1;
-		else {
-			*cp = '\0';
-			return (-1);
-		}
-
-	return (num_read);
-}
-
-
-/* el_getc():
- *	Read a character
- */
-public int
-el_getc(EditLine *el, char *cp)
-{
-	int num_read;
-	c_macro_t *ma = &el->el_chared.c_macro;
-
-	term__flush();
-	for (;;) {
-		if (ma->level < 0) {
-			if (!read_preread(el))
-				break;
-		}
-		if (ma->level < 0)
-			break;
-
-		if (ma->macro[ma->level][ma->offset] == '\0') {
-			el_free(ma->macro[ma->level--]);
-			ma->offset = 0;
-			continue;
-		}
-		*cp = ma->macro[ma->level][ma->offset++] & 0377;
-		if (ma->macro[ma->level][ma->offset] == '\0') {
-			/* Needed for QuoteMode On */
-			el_free(ma->macro[ma->level--]);
-			ma->offset = 0;
-		}
-		return (1);
-	}
-
-#ifdef DEBUG_READ
-	(void) fprintf(el->el_errfile, "Turning raw mode on\n");
-#endif /* DEBUG_READ */
-	if (tty_rawmode(el) < 0)/* make sure the tty is set up correctly */
-		return (0);
-
-#ifdef DEBUG_READ
-	(void) fprintf(el->el_errfile, "Reading a character\n");
-#endif /* DEBUG_READ */
-	num_read = (*el->el_read.read_char)(el, cp);
-#ifdef DEBUG_READ
-	(void) fprintf(el->el_errfile, "Got it %c\n", *cp);
-#endif /* DEBUG_READ */
-	return (num_read);
-}
-
-protected void
-read_prepare(EditLine *el)
-{
-	if (el->el_flags & HANDLE_SIGNALS)
-		sig_set(el);
-	if (el->el_flags & NO_TTY)
-		return;
-	if ((el->el_flags & (UNBUFFERED|EDIT_DISABLED)) == UNBUFFERED)
-		tty_rawmode(el);
-
-	/* This is relatively cheap, and things go terribly wrong if
-	   we have the wrong size. */
-	el_resize(el);
-	re_clear_display(el);	/* reset the display stuff */
-	ch_reset(el, 0);
-	re_refresh(el);		/* print the prompt */
-
-	if (el->el_flags & UNBUFFERED)
-		term__flush();
-}
-
-protected void
-read_finish(EditLine *el)
-{
-	if ((el->el_flags & UNBUFFERED) == 0)
-		(void) tty_cookedmode(el);
-	if (el->el_flags & HANDLE_SIGNALS)
-		sig_clr(el);
-}
-
-public const char *
-el_gets(EditLine *el, int *nread)
-{
-	int retval;
-	el_action_t cmdnum = 0;
-	int num;		/* how many chars we have read at NL */
-	char ch;
-	int crlf = 0;
-#ifdef FIONREAD
-	c_macro_t *ma = &el->el_chared.c_macro;
-#endif /* FIONREAD */
-
-	if (el->el_flags & NO_TTY) {
-		char *cp = el->el_line.buffer;
-		size_t idx;
-
-		while ((*el->el_read.read_char)(el, cp) == 1) {
-			/* make sure there is space for next character */
-			if (cp + 1 >= el->el_line.limit) {
-				idx = (cp - el->el_line.buffer);
-				if (!ch_enlargebufs(el, 2))
-					break;
-				cp = &el->el_line.buffer[idx];
-			}
-			cp++;
-			if (el->el_flags & UNBUFFERED)
-				break;
-			if (cp[-1] == '\r' || cp[-1] == '\n')
-				break;
-		}
-
-		el->el_line.cursor = el->el_line.lastchar = cp;
-		*cp = '\0';
-		if (nread)
-			*nread = el->el_line.cursor - el->el_line.buffer;
-		return (el->el_line.buffer);
-	}
-
-
-#ifdef FIONREAD
-	if (el->el_tty.t_mode == EX_IO && ma->level < 0) {
-		long chrs = 0;
-
-		(void) ioctl(el->el_infd, FIONREAD, (ioctl_t) & chrs);
-		if (chrs == 0) {
-			if (tty_rawmode(el) < 0) {
-				if (nread)
-					*nread = 0;
-				return (NULL);
-			}
-		}
-	}
-#endif /* FIONREAD */
-
-	if ((el->el_flags & UNBUFFERED) == 0)
-		read_prepare(el);
-
-	if (el->el_flags & EDIT_DISABLED) {
-		char *cp;
-		size_t idx;
-		if ((el->el_flags & UNBUFFERED) == 0)
-			cp = el->el_line.buffer;
-		else
-			cp = el->el_line.lastchar;
-
-		term__flush();
-
-		while ((*el->el_read.read_char)(el, cp) == 1) {
-			/* make sure there is space next character */
-			if (cp + 1 >= el->el_line.limit) {
-				idx = (cp - el->el_line.buffer);
-				if (!ch_enlargebufs(el, 2))
-					break;
-				cp = &el->el_line.buffer[idx];
-			}
-			if (*cp == 4)	/* ought to be stty eof */
-				break;
-			cp++;
-			crlf = cp[-1] == '\r' || cp[-1] == '\n';
-			if (el->el_flags & UNBUFFERED)
-				break;
-			if (crlf)
-				break;
-		}
-
-		el->el_line.cursor = el->el_line.lastchar = cp;
-		*cp = '\0';
-		if (nread)
-			*nread = el->el_line.cursor - el->el_line.buffer;
-		return (el->el_line.buffer);
-	}
-
-	for (num = OKCMD; num == OKCMD;) {	/* while still editing this
-						 * line */
-#ifdef DEBUG_EDIT
-		read_debug(el);
-#endif /* DEBUG_EDIT */
-		/* if EOF or error */
-		if ((num = read_getcmd(el, &cmdnum, &ch)) != OKCMD) {
-#ifdef DEBUG_READ
-			(void) fprintf(el->el_errfile,
-			    "Returning from el_gets %d\n", num);
-#endif /* DEBUG_READ */
-			break;
-		}
-		if (cmdnum >= el->el_map.nfunc) {	/* BUG CHECK command */
-#ifdef DEBUG_EDIT
-			(void) fprintf(el->el_errfile,
-			    "ERROR: illegal command from key 0%o\r\n", ch);
-#endif /* DEBUG_EDIT */
-			continue;	/* try again */
-		}
-		/* now do the real command */
-#ifdef DEBUG_READ
-		{
-			el_bindings_t *b;
-			for (b = el->el_map.help; b->name; b++)
-				if (b->func == cmdnum)
-					break;
-			if (b->name)
-				(void) fprintf(el->el_errfile,
-				    "Executing %s\n", b->name);
-			else
-				(void) fprintf(el->el_errfile,
-				    "Error command = %d\n", cmdnum);
-		}
-#endif /* DEBUG_READ */
-		/* vi redo needs these way down the levels... */
-		el->el_state.thiscmd = cmdnum;
-		el->el_state.thisch = ch;
-		if (el->el_map.type == MAP_VI &&
-		    el->el_map.current == el->el_map.key &&
-		    el->el_chared.c_redo.pos < el->el_chared.c_redo.lim) {
-			if (cmdnum == VI_DELETE_PREV_CHAR &&
-			    el->el_chared.c_redo.pos != el->el_chared.c_redo.buf
-			    && isprint((unsigned char)el->el_chared.c_redo.pos[-1]))
-				el->el_chared.c_redo.pos--;
-			else
-				*el->el_chared.c_redo.pos++ = ch;
-		}
-		retval = (*el->el_map.func[cmdnum]) (el, ch);
-#ifdef DEBUG_READ
-		(void) fprintf(el->el_errfile,
-			"Returned state %d\n", retval );
-#endif /* DEBUG_READ */
-
-		/* save the last command here */
-		el->el_state.lastcmd = cmdnum;
-
-		/* use any return value */
-		switch (retval) {
-		case CC_CURSOR:
-			re_refresh_cursor(el);
-			break;
-
-		case CC_REDISPLAY:
-			re_clear_lines(el);
-			re_clear_display(el);
-			/* FALLTHROUGH */
-
-		case CC_REFRESH:
-			re_refresh(el);
-			break;
-
-		case CC_REFRESH_BEEP:
-			re_refresh(el);
-			term_beep(el);
-			break;
-
-		case CC_NORM:	/* normal char */
-			break;
-
-		case CC_ARGHACK:	/* Suggested by Rich Salz */
-			/* <rsalz@pineapple.bbn.com> */
-			continue;	/* keep going... */
-
-		case CC_EOF:	/* end of file typed */
-			if ((el->el_flags & UNBUFFERED) == 0)
-				num = 0;
-			else if (num == -1) {
-				*el->el_line.lastchar++ = CONTROL('d');
-				el->el_line.cursor = el->el_line.lastchar;
-				num = 1;
-			}
-			break;
-
-		case CC_NEWLINE:	/* normal end of line */
-			num = el->el_line.lastchar - el->el_line.buffer;
-			break;
-
-		case CC_FATAL:	/* fatal error, reset to known state */
-#ifdef DEBUG_READ
-			(void) fprintf(el->el_errfile,
-			    "*** editor fatal ERROR ***\r\n\n");
-#endif /* DEBUG_READ */
-			/* put (real) cursor in a known place */
-			re_clear_display(el);	/* reset the display stuff */
-			ch_reset(el, 1);	/* reset the input pointers */
-			re_refresh(el);	/* print the prompt again */
-			break;
-
-		case CC_ERROR:
-		default:	/* functions we don't know about */
-#ifdef DEBUG_READ
-			(void) fprintf(el->el_errfile,
-			    "*** editor ERROR ***\r\n\n");
-#endif /* DEBUG_READ */
-			term_beep(el);
-			term__flush();
-			break;
-		}
-		el->el_state.argument = 1;
-		el->el_state.doingarg = 0;
-		el->el_chared.c_vcmd.action = NOP;
-		if (el->el_flags & UNBUFFERED)
-			break;
-	}
-
-	term__flush();		/* flush any buffered output */
-	/* make sure the tty is set up correctly */
-	if ((el->el_flags & UNBUFFERED) == 0) {
-		read_finish(el);
-		if (nread)
-			*nread = num;
-	} else {
-		if (nread)
-			*nread = el->el_line.lastchar - el->el_line.buffer;
-	}
-	return (num ? el->el_line.buffer : NULL);
-}
diff --git a/libedit/read.h b/libedit/read.h
deleted file mode 100644
index 1982f47..0000000
--- a/libedit/read.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*	$NetBSD: read.h,v 1.4 2004/02/27 14:52:18 christos Exp $	*/
-
-/*-
- * Copyright (c) 2001 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Anthony Mallet.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * el.read.h: Character reading functions
- */
-#ifndef	_h_el_read
-#define	_h_el_read
-
-typedef int (*el_rfunc_t)(EditLine *, char *);
-
-typedef struct el_read_t {
-	el_rfunc_t	read_char;	/* Function to read a character */
-} el_read_t;
- 
-protected int		read_init(EditLine *);
-protected void		read_prepare(EditLine *);
-protected void		read_finish(EditLine *);
-protected int		el_read_setfn(EditLine *, el_rfunc_t);
-protected el_rfunc_t	el_read_getfn(EditLine *);
-
-#endif /* _h_el_read */
diff --git a/libedit/readline.c b/libedit/readline.c
deleted file mode 100644
index c70f8e4..0000000
--- a/libedit/readline.c
+++ /dev/null
@@ -1,1795 +0,0 @@
-/*	$NetBSD: readline.c,v 1.58 2005/07/14 15:00:58 christos Exp $	*/
-
-/*-
- * Copyright (c) 1997 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Jaromir Dolecek.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the NetBSD
- *	Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* AIX requires this to be the first thing in the file.  */
-#if defined (_AIX) && !defined (__GNUC__)
- #pragma alloca
-#endif
-
-#include "sys.h"
-
-#ifdef __GNUC__
-# undef alloca
-# define alloca(n) __builtin_alloca (n)
-#else
-# ifdef HAVE_ALLOCA_H
-#  include <alloca.h>
-# else
-#  ifndef _AIX
-extern char *alloca ();
-#  endif
-# endif
-#endif
-
-#if !defined(lint) && !defined(SCCSID)
-__RCSID("$NetBSD: readline.c,v 1.58 2005/07/14 15:00:58 christos Exp $");
-#endif /* not lint && not SCCSID */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <stdio.h>
-#include <dirent.h>
-#include <string.h>
-#include <pwd.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <limits.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <vis.h>
-
-#include "el.h"
-#include "fcns.h"		/* for EL_NUM_FCNS */
-#include "histedit.h"
-#include "editline/readline.h"
-#include "filecomplete.h"
-
-/* for rl_complete() */
-#define TAB		'\r'
-
-/* see comment at the #ifdef for sense of this */
-/* #define GDB_411_HACK */
-
-/* readline compatibility stuff - look at readline sources/documentation */
-/* to see what these variables mean */
-const char *rl_library_version = "EditLine wrapper";
-static char empty[] = { '\0' };
-static char expand_chars[] = { ' ', '\t', '\n', '=', '(', '\0' };
-static char break_chars[] = { ' ', '\t', '\n', '"', '\\', '\'', '`', '@', '$',
-    '>', '<', '=', ';', '|', '&', '{', '(', '\0' };
-char *rl_readline_name = empty;
-FILE *rl_instream = NULL;
-FILE *rl_outstream = NULL;
-int rl_point = 0;
-int rl_end = 0;
-char *rl_line_buffer = NULL;
-VCPFunction *rl_linefunc = NULL;
-int rl_done = 0;
-VFunction *rl_event_hook = NULL;
-
-int history_base = 1;		/* probably never subject to change */
-int history_length = 0;
-int max_input_history = 0;
-char history_expansion_char = '!';
-char history_subst_char = '^';
-char *history_no_expand_chars = expand_chars;
-Function *history_inhibit_expansion_function = NULL;
-char *history_arg_extract(int start, int end, const char *str);
-
-int rl_inhibit_completion = 0;
-int rl_attempted_completion_over = 0;
-char *rl_basic_word_break_characters = break_chars;
-char *rl_completer_word_break_characters = NULL;
-char *rl_completer_quote_characters = NULL;
-Function *rl_completion_entry_function = NULL;
-CPPFunction *rl_attempted_completion_function = NULL;
-Function *rl_pre_input_hook = NULL;
-Function *rl_startup1_hook = NULL;
-Function *rl_getc_function = NULL;
-char *rl_terminal_name = NULL;
-int rl_already_prompted = 0;
-int rl_filename_completion_desired = 0;
-int rl_ignore_completion_duplicates = 0;
-int rl_catch_signals = 1;
-VFunction *rl_redisplay_function = NULL;
-Function *rl_startup_hook = NULL;
-VFunction *rl_completion_display_matches_hook = NULL;
-VFunction *rl_prep_term_function = NULL;
-VFunction *rl_deprep_term_function = NULL;
-
-/*
- * The current prompt string.
- */
-char *rl_prompt = NULL;
-/*
- * This is set to character indicating type of completion being done by
- * rl_complete_internal(); this is available for application completion
- * functions.
- */
-int rl_completion_type = 0;
-
-/*
- * If more than this number of items results from query for possible
- * completions, we ask user if they are sure to really display the list.
- */
-int rl_completion_query_items = 100;
-
-/*
- * List of characters which are word break characters, but should be left
- * in the parsed text when it is passed to the completion function.
- * Shell uses this to help determine what kind of completing to do.
- */
-char *rl_special_prefixes = NULL;
-
-/*
- * This is the character appended to the completed words if at the end of
- * the line. Default is ' ' (a space).
- */
-int rl_completion_append_character = ' ';
-
-/* stuff below is used internally by libedit for readline emulation */
-
-static History *h = NULL;
-static EditLine *e = NULL;
-static Function *map[256];
-
-/* internal functions */
-static unsigned char	 _el_rl_complete(EditLine *, int);
-static unsigned char	 _el_rl_tstp(EditLine *, int);
-static char		*_get_prompt(EditLine *);
-static HIST_ENTRY	*_move_history(int);
-static int		 _history_expand_command(const char *, size_t, size_t,
-    char **);
-static char		*_rl_compat_sub(const char *, const char *,
-    const char *, int);
-static int		 _rl_event_read_char(EditLine *, char *);
-static void		 _rl_update_pos(void);
-
-
-/* ARGSUSED */
-static char *
-_get_prompt(EditLine *el __attribute__((__unused__)))
-{
-	rl_already_prompted = 1;
-	return (rl_prompt);
-}
-
-
-/*
- * generic function for moving around history
- */
-static HIST_ENTRY *
-_move_history(int op)
-{
-	HistEvent ev;
-	static HIST_ENTRY rl_he;
-
-	if (history(h, &ev, op) != 0)
-		return (HIST_ENTRY *) NULL;
-
-	rl_he.line = ev.str;
-	rl_he.data = (histdata_t) &(ev.num);
-
-	return (&rl_he);
-}
-
-
-/*
- * READLINE compatibility stuff
- */
-
-/*
- * initialize rl compat stuff
- */
-int
-rl_initialize(void)
-{
-	HistEvent ev;
-	const LineInfo *li;
-	int editmode = 1;
-	struct termios t;
-
-	if (e != NULL)
-		el_end(e);
-	if (h != NULL)
-		history_end(h);
-
-	if (!rl_instream)
-		rl_instream = stdin;
-	if (!rl_outstream)
-		rl_outstream = stdout;
-
-	/*
-	 * See if we don't really want to run the editor
-	 */
-	if (tcgetattr(fileno(rl_instream), &t) != -1 && (t.c_lflag & ECHO) == 0)
-		editmode = 0;
-
-	e = el_init(rl_readline_name, rl_instream, rl_outstream, stderr);
-
-	if (!editmode)
-		el_set(e, EL_EDITMODE, 0);
-
-	h = history_init();
-	if (!e || !h)
-		return (-1);
-
-	history(h, &ev, H_SETSIZE, INT_MAX);	/* unlimited */
-	history_length = 0;
-	max_input_history = INT_MAX;
-	el_set(e, EL_HIST, history, h);
-
-	/* for proper prompt printing in readline() */
-	rl_prompt = strdup("");
-	if (rl_prompt == NULL) {
-		history_end(h);
-		el_end(e);
-		return -1;
-	}
-	el_set(e, EL_PROMPT, _get_prompt);
-	el_set(e, EL_SIGNAL, rl_catch_signals);
-
-	/* set default mode to "emacs"-style and read setting afterwards */
-	/* so this can be overriden */
-	el_set(e, EL_EDITOR, "emacs");
-	if (rl_terminal_name != NULL)
-		el_set(e, EL_TERMINAL, rl_terminal_name);
-	else
-		el_get(e, EL_TERMINAL, &rl_terminal_name);
-
-	/*
-	 * Word completion - this has to go AFTER rebinding keys
-	 * to emacs-style.
-	 */
-	el_set(e, EL_ADDFN, "rl_complete",
-	    "ReadLine compatible completion function",
-	    _el_rl_complete);
-	el_set(e, EL_BIND, "^I", "rl_complete", NULL);
-
-	/*
-	 * Send TSTP when ^Z is pressed.
-	 */
-	el_set(e, EL_ADDFN, "rl_tstp",
-	    "ReadLine compatible suspend function",
-	    _el_rl_tstp);
-	el_set(e, EL_BIND, "^Z", "rl_tstp", NULL);
-		
-	/* read settings from configuration file */
-	el_source(e, NULL);
-
-	/*
-	 * Unfortunately, some applications really do use rl_point
-	 * and rl_line_buffer directly.
-	 */
-	li = el_line(e);
-	/* a cheesy way to get rid of const cast. */
-	rl_line_buffer = memchr(li->buffer, *li->buffer, 1);
-	_rl_update_pos();
-
-	if (rl_startup_hook)
-		(*rl_startup_hook)(NULL, 0);
-
-	return (0);
-}
-
-
-/*
- * read one line from input stream and return it, chomping
- * trailing newline (if there is any)
- */
-char *
-readline(const char *prompt)
-{
-	HistEvent ev;
-	int count;
-	const char *ret;
-	char *buf;
-	static int used_event_hook;
-
-	if (e == NULL || h == NULL)
-		rl_initialize();
-
-	rl_done = 0;
-
-	/* update prompt accordingly to what has been passed */
-	if (!prompt)
-		prompt = "";
-	if (strcmp(rl_prompt, prompt) != 0) {
-		free(rl_prompt);
-		rl_prompt = strdup(prompt);
-		if (rl_prompt == NULL)
-			return NULL;
-	}
-
-	if (rl_pre_input_hook)
-		(*rl_pre_input_hook)(NULL, 0);
-
-	if (rl_event_hook && !(e->el_flags&NO_TTY)) {
-		el_set(e, EL_GETCFN, _rl_event_read_char);
-		used_event_hook = 1;
-	}
-
-	if (!rl_event_hook && used_event_hook) {
-		el_set(e, EL_GETCFN, EL_BUILTIN_GETCFN);
-		used_event_hook = 0;
-	}
-
-	rl_already_prompted = 0;
-
-	/* get one line from input stream */
-	ret = el_gets(e, &count);
-
-	if (ret && count > 0) {
-		int lastidx;
-
-		buf = strdup(ret);
-		if (buf == NULL)
-			return NULL;
-		lastidx = count - 1;
-		if (buf[lastidx] == '\n')
-			buf[lastidx] = '\0';
-	} else
-		buf = NULL;
-
-	history(h, &ev, H_GETSIZE);
-	history_length = ev.num;
-
-	return buf;
-}
-
-/*
- * history functions
- */
-
-/*
- * is normally called before application starts to use
- * history expansion functions
- */
-void
-using_history(void)
-{
-	if (h == NULL || e == NULL)
-		rl_initialize();
-}
-
-
-/*
- * substitute ``what'' with ``with'', returning resulting string; if
- * globally == 1, substitutes all occurrences of what, otherwise only the
- * first one
- */
-static char *
-_rl_compat_sub(const char *str, const char *what, const char *with,
-    int globally)
-{
-	const	char	*s;
-	char	*r, *result;
-	size_t	len, with_len, what_len;
-
-	len = strlen(str);
-	with_len = strlen(with);
-	what_len = strlen(what);
-
-	/* calculate length we need for result */
-	s = str;
-	while (*s) {
-		if (*s == *what && !strncmp(s, what, what_len)) {
-			len += with_len - what_len;
-			if (!globally)
-				break;
-			s += what_len;
-		} else
-			s++;
-	}
-	r = result = malloc(len + 1);
-	if (result == NULL)
-		return NULL;
-	s = str;
-	while (*s) {
-		if (*s == *what && !strncmp(s, what, what_len)) {
-			(void)strncpy(r, with, with_len);
-			r += with_len;
-			s += what_len;
-			if (!globally) {
-				(void)strcpy(r, s);
-				return(result);
-			}
-		} else
-			*r++ = *s++;
-	}
-	*r = 0;
-	return(result);
-}
-
-static	char	*last_search_pat;	/* last !?pat[?] search pattern */
-static	char	*last_search_match;	/* last !?pat[?] that matched */
-
-const char *
-get_history_event(const char *cmd, int *cindex, int qchar)
-{
-	int idx, sign, sub, num, begin, ret;
-	size_t len;
-	char	*pat;
-	const char *rptr;
-	HistEvent ev;
-
-	idx = *cindex;
-	if (cmd[idx++] != history_expansion_char)
-		return(NULL);
-
-	/* find out which event to take */
-	if (cmd[idx] == history_expansion_char || cmd[idx] == 0) {
-		if (history(h, &ev, H_FIRST) != 0)
-			return(NULL);
-		*cindex = cmd[idx]? (idx + 1):idx;
-		return(ev.str);
-	}
-	sign = 0;
-	if (cmd[idx] == '-') {
-		sign = 1;
-		idx++;
-	}
-
-	if ('0' <= cmd[idx] && cmd[idx] <= '9') {
-		HIST_ENTRY *rl_he;
-
-		num = 0;
-		while (cmd[idx] && '0' <= cmd[idx] && cmd[idx] <= '9') {
-			num = num * 10 + cmd[idx] - '0';
-			idx++;
-		}
-		if (sign)
-			num = history_length - num + 1;
-
-		if (!(rl_he = history_get(num)))
-			return(NULL);
-
-		*cindex = idx;
-		return(rl_he->line);
-	}
-	sub = 0;
-	if (cmd[idx] == '?') {
-		sub = 1;
-		idx++;
-	}
-	begin = idx;
-	while (cmd[idx]) {
-		if (cmd[idx] == '\n')
-			break;
-		if (sub && cmd[idx] == '?')
-			break;
-		if (!sub && (cmd[idx] == ':' || cmd[idx] == ' '
-				    || cmd[idx] == '\t' || cmd[idx] == qchar))
-			break;
-		idx++;
-	}
-	len = idx - begin;
-	if (sub && cmd[idx] == '?')
-		idx++;
-	if (sub && len == 0 && last_search_pat && *last_search_pat)
-		pat = last_search_pat;
-	else if (len == 0)
-		return(NULL);
-	else {
-		if ((pat = malloc(len + 1)) == NULL)
-			return NULL;
-		(void)strncpy(pat, cmd + begin, len);
-		pat[len] = '\0';
-	}
-
-	if (history(h, &ev, H_CURR) != 0) {
-		if (pat != last_search_pat)
-			free(pat);
-		return (NULL);
-	}
-	num = ev.num;
-
-	if (sub) {
-		if (pat != last_search_pat) {
-			if (last_search_pat)
-				free(last_search_pat);
-			last_search_pat = pat;
-		}
-		ret = history_search(pat, -1);
-	} else
-		ret = history_search_prefix(pat, -1);
-
-	if (ret == -1) {
-		/* restore to end of list on failed search */
-		history(h, &ev, H_FIRST);
-		(void)fprintf(rl_outstream, "%s: Event not found\n", pat);
-		if (pat != last_search_pat)
-			free(pat);
-		return(NULL);
-	}
-
-	if (sub && len) {
-		if (last_search_match && last_search_match != pat)
-			free(last_search_match);
-		last_search_match = pat;
-	}
-
-	if (pat != last_search_pat)
-		free(pat);
-
-	if (history(h, &ev, H_CURR) != 0)
-		return(NULL);
-	*cindex = idx;
-	rptr = ev.str;
-
-	/* roll back to original position */
-	(void)history(h, &ev, H_SET, num);
-
-	return rptr;
-}
-
-/*
- * the real function doing history expansion - takes as argument command
- * to do and data upon which the command should be executed
- * does expansion the way I've understood readline documentation
- *
- * returns 0 if data was not modified, 1 if it was and 2 if the string
- * should be only printed and not executed; in case of error,
- * returns -1 and *result points to NULL
- * it's callers responsibility to free() string returned in *result
- */
-static int
-_history_expand_command(const char *command, size_t offs, size_t cmdlen,
-    char **result)
-{
-	char *tmp, *search = NULL, *aptr;
-	const char *ptr, *cmd;
-	static char *from = NULL, *to = NULL;
-	int start, end, idx, has_mods = 0;
-	int p_on = 0, g_on = 0;
-
-	*result = NULL;
-	aptr = NULL;
-	ptr = NULL;
-
-	/* First get event specifier */
-	idx = 0;
-
-	if (strchr(":^*$", command[offs + 1])) {
-		char str[4];
-		/*
-		* "!:" is shorthand for "!!:".
-		* "!^", "!*" and "!$" are shorthand for
-		* "!!:^", "!!:*" and "!!:$" respectively.
-		*/
-		str[0] = str[1] = '!';
-		str[2] = '0';
-		ptr = get_history_event(str, &idx, 0);
-		idx = (command[offs + 1] == ':')? 1:0;
-		has_mods = 1;
-	} else {
-		if (command[offs + 1] == '#') {
-			/* use command so far */
-			if ((aptr = malloc(offs + 1)) == NULL)
-				return -1;
-			(void)strncpy(aptr, command, offs);
-			aptr[offs] = '\0';
-			idx = 1;
-		} else {
-			int	qchar;
-
-			qchar = (offs > 0 && command[offs - 1] == '"')? '"':0;
-			ptr = get_history_event(command + offs, &idx, qchar);
-		}
-		has_mods = command[offs + idx] == ':';
-	}
-
-	if (ptr == NULL && aptr == NULL)
-		return(-1);
-
-	if (!has_mods) {
-		*result = strdup(aptr? aptr : ptr);
-		if (aptr)
-			free(aptr);
-		return(1);
-	}
-
-	cmd = command + offs + idx + 1;
-
-	/* Now parse any word designators */
-
-	if (*cmd == '%')	/* last word matched by ?pat? */
-		tmp = strdup(last_search_match? last_search_match:"");
-	else if (strchr("^*$-0123456789", *cmd)) {
-		start = end = -1;
-		if (*cmd == '^')
-			start = end = 1, cmd++;
-		else if (*cmd == '$')
-			start = -1, cmd++;
-		else if (*cmd == '*')
-			start = 1, cmd++;
-	       else if (*cmd == '-' || isdigit((unsigned char) *cmd)) {
-			start = 0;
-			while (*cmd && '0' <= *cmd && *cmd <= '9')
-				start = start * 10 + *cmd++ - '0';
-
-			if (*cmd == '-') {
-				if (isdigit((unsigned char) cmd[1])) {
-					cmd++;
-					end = 0;
-					while (*cmd && '0' <= *cmd && *cmd <= '9')
-						end = end * 10 + *cmd++ - '0';
-				} else if (cmd[1] == '$') {
-					cmd += 2;
-					end = -1;
-				} else {
-					cmd++;
-					end = -2;
-				}
-			} else if (*cmd == '*')
-				end = -1, cmd++;
-			else
-				end = start;
-		}
-		tmp = history_arg_extract(start, end, aptr? aptr:ptr);
-		if (tmp == NULL) {
-			(void)fprintf(rl_outstream, "%s: Bad word specifier",
-			    command + offs + idx);
-			if (aptr)
-				free(aptr);
-			return(-1);
-		}
-	} else
-		tmp = strdup(aptr? aptr:ptr);
-
-	if (aptr)
-		free(aptr);
-
-	if (*cmd == 0 || (cmd - (command + offs) >= ((unsigned int) cmdlen))) {
-		*result = tmp;
-		return(1);
-	}
-
-	for (; *cmd; cmd++) {
-		if (*cmd == ':')
-			continue;
-		else if (*cmd == 'h') {		/* remove trailing path */
-			if ((aptr = strrchr(tmp, '/')) != NULL)
-				*aptr = 0;
-		} else if (*cmd == 't') {	/* remove leading path */
-			if ((aptr = strrchr(tmp, '/')) != NULL) {
-				aptr = strdup(aptr + 1);
-				free(tmp);
-				tmp = aptr;
-			}
-		} else if (*cmd == 'r') {	/* remove trailing suffix */
-			if ((aptr = strrchr(tmp, '.')) != NULL)
-				*aptr = 0;
-		} else if (*cmd == 'e') {	/* remove all but suffix */
-			if ((aptr = strrchr(tmp, '.')) != NULL) {
-				aptr = strdup(aptr);
-				free(tmp);
-				tmp = aptr;
-			}
-		} else if (*cmd == 'p')		/* print only */
-			p_on = 1;
-		else if (*cmd == 'g')
-			g_on = 2;
-		else if (*cmd == 's' || *cmd == '&') {
-			char *what, *with, delim;
-			size_t len, from_len;
-			size_t size;
-
-			if (*cmd == '&' && (from == NULL || to == NULL))
-				continue;
-			else if (*cmd == 's') {
-				delim = *(++cmd), cmd++;
-				size = 16;
-				what = realloc(from, size);
-				if (what == NULL) {
-					free(from);
-					return 0;
-				}
-				len = 0;
-				for (; *cmd && *cmd != delim; cmd++) {
-					if (*cmd == '\\' && cmd[1] == delim)
-						cmd++;
-					if (len >= size) {
-						char *nwhat;
-						nwhat = realloc(what,
-								(size <<= 1));
-						if (nwhat == NULL) {
-							free(what);
-							return 0;
-						}
-						what = nwhat;
-					}
-					what[len++] = *cmd;
-				}
-				what[len] = '\0';
-				from = what;
-				if (*what == '\0') {
-					free(what);
-					if (search) {
-						from = strdup(search);
-						if (from == NULL)
-							return 0;
-					} else {
-						from = NULL;
-						return (-1);
-					}
-				}
-				cmd++;	/* shift after delim */
-				if (!*cmd)
-					continue;
-
-				size = 16;
-				with = realloc(to, size);
-				if (with == NULL) {
-					free(to);
-					return -1;
-				}
-				len = 0;
-				from_len = strlen(from);
-				for (; *cmd && *cmd != delim; cmd++) {
-					if (len + from_len + 1 >= size) {
-						char *nwith;
-						size += from_len + 1;
-						nwith = realloc(with, size);
-						if (nwith == NULL) {
-							free(with);
-							return -1;
-						}
-						with = nwith;
-					}
-					if (*cmd == '&') {
-						/* safe */
-						(void)strcpy(&with[len], from);
-						len += from_len;
-						continue;
-					}
-					if (*cmd == '\\'
-					    && (*(cmd + 1) == delim
-						|| *(cmd + 1) == '&'))
-						cmd++;
-					with[len++] = *cmd;
-				}
-				with[len] = '\0';
-				to = with;
-			}
-
-			aptr = _rl_compat_sub(tmp, from, to, g_on);
-			if (aptr) {
-				free(tmp);
-				tmp = aptr;
-			}
-			g_on = 0;
-		}
-	}
-	*result = tmp;
-	return (p_on? 2:1);
-}
-
-
-/*
- * csh-style history expansion
- */
-int
-history_expand(char *str, char **output)
-{
-	int ret = 0;
-	size_t idx, i, size;
-	char *tmp, *result;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	if (history_expansion_char == 0) {
-		*output = strdup(str);
-		return(0);
-	}
-
-	*output = NULL;
-	if (str[0] == history_subst_char) {
-		/* ^foo^foo2^ is equivalent to !!:s^foo^foo2^ */
-		*output = malloc(strlen(str) + 4 + 1);
-		if (*output == NULL)
-			return 0;
-		(*output)[0] = (*output)[1] = history_expansion_char;
-		(*output)[2] = ':';
-		(*output)[3] = 's';
-		(void)strcpy((*output) + 4, str);
-		str = *output;
-	} else {
-		*output = strdup(str);
-		if (*output == NULL)
-			return 0;
-	}
-
-#define ADD_STRING(what, len)						\
-	{								\
-		if (idx + len + 1 > size) {				\
-			char *nresult = realloc(result, (size += len + 1));\
-			if (nresult == NULL) {				\
-				free(*output);				\
-				return 0;				\
-			}						\
-			result = nresult;				\
-		}							\
-		(void)strncpy(&result[idx], what, len);			\
-		idx += len;						\
-		result[idx] = '\0';					\
-	}
-
-	result = NULL;
-	size = idx = 0;
-	for (i = 0; str[i];) {
-		int qchar, loop_again;
-		size_t len, start, j;
-
-		qchar = 0;
-		loop_again = 1;
-		start = j = i;
-loop:
-		for (; str[j]; j++) {
-			if (str[j] == '\\' &&
-			    str[j + 1] == history_expansion_char) {
-				(void)strcpy(&str[j], &str[j + 1]);
-				continue;
-			}
-			if (!loop_again) {
-				if (isspace((unsigned char) str[j])
-				    || str[j] == qchar)
-					break;
-			}
-			if (str[j] == history_expansion_char
-			    && !strchr(history_no_expand_chars, str[j + 1])
-			    && (!history_inhibit_expansion_function ||
-			    (*history_inhibit_expansion_function)(str,
-			    (int)j) == 0))
-				break;
-		}
-
-		if (str[j] && loop_again) {
-			i = j;
-			qchar = (j > 0 && str[j - 1] == '"' )? '"':0;
-			j++;
-			if (str[j] == history_expansion_char)
-				j++;
-			loop_again = 0;
-			goto loop;
-		}
-		len = i - start;
-		tmp = &str[start];
-		ADD_STRING(tmp, len);
-
-		if (str[i] == '\0' || str[i] != history_expansion_char) {
-			len = j - i;
-			tmp = &str[i];
-			ADD_STRING(tmp, len);
-			if (start == 0)
-				ret = 0;
-			else
-				ret = 1;
-			break;
-		}
-		ret = _history_expand_command (str, i, (j - i), &tmp);
-		if (ret > 0 && tmp) {
-			len = strlen(tmp);
-			ADD_STRING(tmp, len);
-			free(tmp);
-		}
-		i = j;
-	}
-
-	/* ret is 2 for "print only" option */
-	if (ret == 2) {
-		add_history(result);
-#ifdef GDB_411_HACK
-		/* gdb 4.11 has been shipped with readline, where */
-		/* history_expand() returned -1 when the line	  */
-		/* should not be executed; in readline 2.1+	  */
-		/* it should return 2 in such a case		  */
-		ret = -1;
-#endif
-	}
-	free(*output);
-	*output = result;
-
-	return (ret);
-}
-
-/*
-* Return a string consisting of arguments of "str" from "start" to "end".
-*/
-char *
-history_arg_extract(int start, int end, const char *str)
-{
-	int  i, len, max;
-	char **arr, *result;
-
-	arr = history_tokenize(str);
-	if (!arr)
-		return(NULL);
-	if (arr && *arr == NULL) {
-		free(arr);
-		return(NULL);
-	}
-
-	for (max = 0; arr[max]; max++)
-		continue;
-	max--;
-
-	if (start == '$')
-		start = max;
-	if (end == '$')
-		end = max;
-	if (end < 0)
-		end = max + end + 1;
-	if (start < 0)
-		start = end;
-
-	if (start < 0 || end < 0 || start > max || end > max || start > end)
-		return(NULL);
-
-	for (i = start, len = 0; i <= end; i++)
-		len += strlen(arr[i]) + 1;
-	len++;
-	result = malloc(len);
-	if (result == NULL)
-		return NULL;
-
-	for (i = start, len = 0; i <= end; i++) {
-		(void)strcpy(result + len, arr[i]);
-		len += strlen(arr[i]);
-		if (i < end)
-			result[len++] = ' ';
-	}
-	result[len] = 0;
-
-	for (i = 0; arr[i]; i++)
-		free(arr[i]);
-	free(arr);
-
-	return(result);
-}
-
-/*
- * Parse the string into individual tokens,
- * similar to how shell would do it.
- */
-char **
-history_tokenize(const char *str)
-{
-	int size = 1, idx = 0, i, start;
-	size_t len;
-	char **result = NULL, *temp, delim = '\0';
-
-	for (i = 0; str[i];) {
-		while (isspace((unsigned char) str[i]))
-			i++;
-		start = i;
-		for (; str[i];) {
-			if (str[i] == '\\') {
-				if (str[i+1] != '\0')
-					i++;
-			} else if (str[i] == delim)
-				delim = '\0';
-			else if (!delim &&
-				    (isspace((unsigned char) str[i]) ||
-				strchr("()<>;&|$", str[i])))
-				break;
-			else if (!delim && strchr("'`\"", str[i]))
-				delim = str[i];
-			if (str[i])
-				i++;
-		}
-
-		if (idx + 2 >= size) {
-			char **nresult;
-			size <<= 1;
-			nresult = realloc(result, size * sizeof(char *));
-			if (nresult == NULL) {
-				free(result);
-				return NULL;
-			}
-			result = nresult;
-		}
-		len = i - start;
-		temp = malloc(len + 1);
-		if (temp == NULL) {
-			for (i = 0; i < idx; i++)
-				free(result[i]);
-			free(result);
-			return NULL;
-		}
-		(void)strncpy(temp, &str[start], len);
-		temp[len] = '\0';
-		result[idx++] = temp;
-		result[idx] = NULL;
-		if (str[i])
-			i++;
-	}
-	return (result);
-}
-
-
-/*
- * limit size of history record to ``max'' events
- */
-void
-stifle_history(int max)
-{
-	HistEvent ev;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	if (history(h, &ev, H_SETSIZE, max) == 0)
-		max_input_history = max;
-}
-
-
-/*
- * "unlimit" size of history - set the limit to maximum allowed int value
- */
-int
-unstifle_history(void)
-{
-	HistEvent ev;
-	int omax;
-
-	history(h, &ev, H_SETSIZE, INT_MAX);
-	omax = max_input_history;
-	max_input_history = INT_MAX;
-	return (omax);		/* some value _must_ be returned */
-}
-
-
-int
-history_is_stifled(void)
-{
-
-	/* cannot return true answer */
-	return (max_input_history != INT_MAX);
-}
-
-
-/*
- * read history from a file given
- */
-int
-read_history(const char *filename)
-{
-	HistEvent ev;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-	return (history(h, &ev, H_LOAD, filename));
-}
-
-
-/*
- * write history to a file given
- */
-int
-write_history(const char *filename)
-{
-	HistEvent ev;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-	return (history(h, &ev, H_SAVE, filename));
-}
-
-
-/*
- * returns history ``num''th event
- *
- * returned pointer points to static variable
- */
-HIST_ENTRY *
-history_get(int num)
-{
-	static HIST_ENTRY she;
-	HistEvent ev;
-	int curr_num;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	/* save current position */
-	if (history(h, &ev, H_CURR) != 0)
-		return (NULL);
-	curr_num = ev.num;
-
-	/* start from most recent */
-	if (history(h, &ev, H_FIRST) != 0)
-		return (NULL);	/* error */
-
-	/* look backwards for event matching specified offset */
-	if (history(h, &ev, H_NEXT_EVENT, num))
-		return (NULL);
-
-	she.line = ev.str;
-	she.data = NULL;
-
-	/* restore pointer to where it was */
-	(void)history(h, &ev, H_SET, curr_num);
-
-	return (&she);
-}
-
-
-/*
- * add the line to history table
- */
-int
-add_history(const char *line)
-{
-	HistEvent ev;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	(void)history(h, &ev, H_ENTER, line);
-	if (history(h, &ev, H_GETSIZE) == 0)
-		history_length = ev.num;
-
-	return (!(history_length > 0)); /* return 0 if all is okay */
-}
-
-
-/*
- * remove the specified entry from the history list and return it.
- */
-HIST_ENTRY *
-remove_history(int num)
-{
-	static HIST_ENTRY she;
-	HistEvent ev;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	if (history(h, &ev, H_DEL, num) != 0)
-		return NULL;
-
-	she.line = ev.str;
-	she.data = NULL;
-
-	return &she;
-}
-
-
-/*
- * clear the history list - delete all entries
- */
-void
-clear_history(void)
-{
-	HistEvent ev;
-
-	history(h, &ev, H_CLEAR);
-}
-
-
-/*
- * returns offset of the current history event
- */
-int
-where_history(void)
-{
-	HistEvent ev;
-	int curr_num, off;
-
-	if (history(h, &ev, H_CURR) != 0)
-		return (0);
-	curr_num = ev.num;
-
-	history(h, &ev, H_FIRST);
-	off = 1;
-	while (ev.num != curr_num && history(h, &ev, H_NEXT) == 0)
-		off++;
-
-	return (off);
-}
-
-
-/*
- * returns current history event or NULL if there is no such event
- */
-HIST_ENTRY *
-current_history(void)
-{
-
-	return (_move_history(H_CURR));
-}
-
-
-/*
- * returns total number of bytes history events' data are using
- */
-int
-history_total_bytes(void)
-{
-	HistEvent ev;
-	int curr_num, size;
-
-	if (history(h, &ev, H_CURR) != 0)
-		return (-1);
-	curr_num = ev.num;
-
-	history(h, &ev, H_FIRST);
-	size = 0;
-	do
-		size += strlen(ev.str);
-	while (history(h, &ev, H_NEXT) == 0);
-
-	/* get to the same position as before */
-	history(h, &ev, H_PREV_EVENT, curr_num);
-
-	return (size);
-}
-
-
-/*
- * sets the position in the history list to ``pos''
- */
-int
-history_set_pos(int pos)
-{
-	HistEvent ev;
-	int curr_num;
-
-	if (pos > history_length || pos < 0)
-		return (-1);
-
-	history(h, &ev, H_CURR);
-	curr_num = ev.num;
-
-	if (history(h, &ev, H_SET, pos)) {
-		history(h, &ev, H_SET, curr_num);
-		return(-1);
-	}
-	return (0);
-}
-
-
-/*
- * returns previous event in history and shifts pointer accordingly
- */
-HIST_ENTRY *
-previous_history(void)
-{
-
-	return (_move_history(H_PREV));
-}
-
-
-/*
- * returns next event in history and shifts pointer accordingly
- */
-HIST_ENTRY *
-next_history(void)
-{
-
-	return (_move_history(H_NEXT));
-}
-
-
-/*
- * searches for first history event containing the str
- */
-int
-history_search(const char *str, int direction)
-{
-	HistEvent ev;
-	const char *strp;
-	int curr_num;
-
-	if (history(h, &ev, H_CURR) != 0)
-		return (-1);
-	curr_num = ev.num;
-
-	for (;;) {
-		if ((strp = strstr(ev.str, str)) != NULL)
-			return (int) (strp - ev.str);
-		if (history(h, &ev, direction < 0 ? H_NEXT:H_PREV) != 0)
-			break;
-	}
-	history(h, &ev, H_SET, curr_num);
-	return (-1);
-}
-
-
-/*
- * searches for first history event beginning with str
- */
-int
-history_search_prefix(const char *str, int direction)
-{
-	HistEvent ev;
-
-	return (history(h, &ev, direction < 0? H_PREV_STR:H_NEXT_STR, str));
-}
-
-
-/*
- * search for event in history containing str, starting at offset
- * abs(pos); continue backward, if pos<0, forward otherwise
- */
-/* ARGSUSED */
-int
-history_search_pos(const char *str,
-		   int direction __attribute__((__unused__)), int pos)
-{
-	HistEvent ev;
-	int curr_num, off;
-
-	off = (pos > 0) ? pos : -pos;
-	pos = (pos > 0) ? 1 : -1;
-
-	if (history(h, &ev, H_CURR) != 0)
-		return (-1);
-	curr_num = ev.num;
-
-	if (history_set_pos(off) != 0 || history(h, &ev, H_CURR) != 0)
-		return (-1);
-
-
-	for (;;) {
-		if (strstr(ev.str, str))
-			return (off);
-		if (history(h, &ev, (pos < 0) ? H_PREV : H_NEXT) != 0)
-			break;
-	}
-
-	/* set "current" pointer back to previous state */
-	history(h, &ev, (pos < 0) ? H_NEXT_EVENT : H_PREV_EVENT, curr_num);
-
-	return (-1);
-}
-
-
-/********************************/
-/* completion functions */
-
-char *
-tilde_expand(char *name)
-{
-	return fn_tilde_expand(name);
-}
-
-char *
-filename_completion_function(const char *name, int state)
-{
-	return fn_filename_completion_function(name, state);
-}
-
-/*
- * a completion generator for usernames; returns _first_ username
- * which starts with supplied text
- * text contains a partial username preceded by random character
- * (usually '~'); state is ignored
- * it's callers responsibility to free returned value
- */
-char *
-username_completion_function(const char *text, int state)
-{
-	struct passwd *pwd;
-
-	if (text[0] == '\0')
-		return (NULL);
-
-	if (*text == '~')
-		text++;
-
-	if (state == 0)
-		setpwent();
-
-   while ((pwd = getpwent())
-		&& pwd != NULL && text[0] == pwd->pw_name[0]
-		&& strcmp(text, pwd->pw_name) == 0);
-
-	if (pwd == NULL) {
-		endpwent();
-		return (NULL);
-	}
-	return (strdup(pwd->pw_name));
-}
-
-
-/*
- * el-compatible wrapper to send TSTP on ^Z
- */
-/* ARGSUSED */
-static unsigned char
-_el_rl_tstp(EditLine *el __attribute__((__unused__)), int ch __attribute__((__unused__)))
-{
-	(void)kill(0, SIGTSTP);
-	return CC_NORM;
-}
-
-/*
- * Display list of strings in columnar format on readline's output stream.
- * 'matches' is list of strings, 'len' is number of strings in 'matches',
- * 'max' is maximum length of string in 'matches'.
- */
-void
-rl_display_match_list(char **matches, int len, int max)
-{
-
-	fn_display_match_list(e, matches, len, max);
-}
-
-static const char *
-/*ARGSUSED*/
-_rl_completion_append_character_function(const char *dummy
-    __attribute__((__unused__)))
-{
-	static char buf[2];
-	buf[1] = rl_completion_append_character;
-	return buf;
-}
-
-
-/*
- * complete word at current point
- */
-/* ARGSUSED */
-int
-rl_complete(int ignore __attribute__((__unused__)), int invoking_key)
-{
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	if (rl_inhibit_completion) {
-		char arr[2];
-		arr[0] = (char)invoking_key;
-		arr[1] = '\0';
-		el_insertstr(e, arr);
-		return (CC_REFRESH);
-	}
-
-	/* Just look at how many global variables modify this operation! */
-	return fn_complete(e,
-	    (CPFunction *)rl_completion_entry_function,
-	    rl_attempted_completion_function,
-	    rl_basic_word_break_characters, rl_special_prefixes,
-	    _rl_completion_append_character_function, rl_completion_query_items,
-	    &rl_completion_type, &rl_attempted_completion_over,
-	    &rl_point, &rl_end);
-}
-
-
-/* ARGSUSED */
-static unsigned char
-_el_rl_complete(EditLine *el __attribute__((__unused__)), int ch)
-{
-	return (unsigned char)rl_complete(0, ch);
-}
-
-/*
- * misc other functions
- */
-
-/*
- * bind key c to readline-type function func
- */
-int
-rl_bind_key(int c, int func(int, int))
-{
-	int retval = -1;
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	if (func == rl_insert) {
-		/* XXX notice there is no range checking of ``c'' */
-		e->el_map.key[c] = ED_INSERT;
-		retval = 0;
-	}
-	return (retval);
-}
-
-
-/*
- * read one key from input - handles chars pushed back
- * to input stream also
- */
-int
-rl_read_key(void)
-{
-	char fooarr[2 * sizeof(int)];
-
-	if (e == NULL || h == NULL)
-		rl_initialize();
-
-	return (el_getc(e, fooarr));
-}
-
-
-/*
- * reset the terminal
- */
-/* ARGSUSED */
-void
-rl_reset_terminal(const char *p __attribute__((__unused__)))
-{
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-	el_reset(e);
-}
-
-
-/*
- * insert character ``c'' back into input stream, ``count'' times
- */
-int
-rl_insert(int count, int c)
-{
-	char arr[2];
-
-	if (h == NULL || e == NULL)
-		rl_initialize();
-
-	/* XXX - int -> char conversion can lose on multichars */
-	arr[0] = c;
-	arr[1] = '\0';
-
-	for (; count > 0; count--)
-		el_push(e, arr);
-
-	return (0);
-}
-
-/*ARGSUSED*/
-int
-rl_newline(int count, int c)
-{
-	/*
-	 * Readline-4.0 appears to ignore the args.
-	 */
-	return rl_insert(1, '\n');
-}
-
-/*ARGSUSED*/
-static unsigned char
-rl_bind_wrapper(EditLine *el, unsigned char c)
-{
-	if (map[c] == NULL)
-	    return CC_ERROR;
-
-	_rl_update_pos();
-
-	(*map[c])(NULL, c);
-
-	/* If rl_done was set by the above call, deal with it here */
-	if (rl_done)
-		return CC_EOF;
-
-	return CC_NORM;
-}
-
-int
-rl_add_defun(const char *name, Function *fun, int c)
-{
-	char dest[8];
-	if (((unsigned int) c) >= sizeof(map) / sizeof(map[0]) || c < 0)
-		return -1;
-	map[(unsigned char)c] = fun;
-	el_set(e, EL_ADDFN, name, name, rl_bind_wrapper);
-	vis(dest, c, VIS_WHITE|VIS_NOSLASH, 0);
-	el_set(e, EL_BIND, dest, name);
-	return 0;
-}
-
-void
-rl_callback_read_char()
-{
-	int count = 0, done = 0;
-	const char *buf = el_gets(e, &count);
-	char *wbuf;
-
-	if (buf == NULL || count-- <= 0)
-		return;
-#ifdef CTRL2 /* _AIX */
-	if (count == 0 && buf[0] == CTRL2('d'))
-#else
-	if (count == 0 && buf[0] == CTRL('d'))
-#endif
-		done = 1;
-	if (buf[count] == '\n' || buf[count] == '\r')
-		done = 2;
-
-	if (done && rl_linefunc != NULL) {
-		el_set(e, EL_UNBUFFERED, 0);
-		if (done == 2) {
-		    if ((wbuf = strdup(buf)) != NULL)
-			wbuf[count] = '\0';
-		} else
-			wbuf = NULL;
-		(*(void (*)(const char *))rl_linefunc)(wbuf);
-		el_set(e, EL_UNBUFFERED, 1);
-	}
-}
-
-void 
-rl_callback_handler_install (const char *prompt, VCPFunction *linefunc)
-{
-	if (e == NULL) {
-		rl_initialize();
-	}
-	if (rl_prompt)
-		free(rl_prompt);
-	rl_prompt = prompt ? strdup(strchr(prompt, *prompt)) : NULL;
-	rl_linefunc = linefunc;
-	el_set(e, EL_UNBUFFERED, 1);
-}   
-
-void 
-rl_callback_handler_remove(void)
-{
-	el_set(e, EL_UNBUFFERED, 0);
-}
-
-void
-rl_redisplay(void)
-{
-	char a[2];
-#ifdef CTRL2 /* _AIX */
-	a[0] = CTRL2('r');
-#else
-	a[0] = CTRL('r');
-#endif
-	a[1] = '\0';
-	el_push(e, a);
-}
-
-int
-rl_get_previous_history(int count, int key)
-{
-	char a[2];
-	a[0] = key;
-	a[1] = '\0';
-	while (count--)
-		el_push(e, a);
-	return 0;
-}
-
-void
-/*ARGSUSED*/
-rl_prep_terminal(int meta_flag)
-{
-	el_set(e, EL_PREP_TERM, 1);
-}
-
-void
-rl_deprep_terminal()
-{
-	el_set(e, EL_PREP_TERM, 0);
-}
-
-int
-rl_read_init_file(const char *s)
-{
-	return(el_source(e, s));
-}
-
-int
-rl_parse_and_bind(const char *line)
-{
-	const char **argv;
-	int argc;
-	Tokenizer *tok;
-
-	tok = tok_init(NULL);
-	tok_str(tok, line, &argc, &argv);
-	argc = el_parse(e, argc, argv);
-	tok_end(tok);
-	return (argc ? 1 : 0);
-}
-
-int
-rl_variable_bind(const char *var, const char *value)
-{
-	/*
-	 * The proper return value is undocument, but this is what the
-	 * readline source seems to do.
-	 */
-	return ((el_set(e, EL_BIND, "", var, value) == -1) ? 1 : 0);
-}
-
-void
-rl_stuff_char(int c)
-{
-	char buf[2];
-
-	buf[0] = c;
-	buf[1] = '\0';
-	el_insertstr(e, buf);
-}
-
-static int
-_rl_event_read_char(EditLine *el, char *cp)
-{
-	int	n, num_read = 0;
-
-	*cp = 0;
-	while (rl_event_hook) {
-
-		(*rl_event_hook)();
-
-#if defined(FIONREAD)
-		if (ioctl(el->el_infd, FIONREAD, &n) < 0)
-			return(-1);
-		if (n)
-			num_read = read(el->el_infd, cp, 1);
-		else
-			num_read = 0;
-#elif defined(F_SETFL) && defined(O_NDELAY)
-		if ((n = fcntl(el->el_infd, F_GETFL, 0)) < 0)
-			return(-1);
-		if (fcntl(el->el_infd, F_SETFL, n|O_NDELAY) < 0)
-			return(-1);
-		num_read = read(el->el_infd, cp, 1);
-		if (fcntl(el->el_infd, F_SETFL, n))
-			return(-1);
-#else
-		/* not non-blocking, but what you gonna do? */
-		num_read = read(el->el_infd, cp, 1);
-		return(-1);
-#endif
-
-		if (num_read < 0 && errno == EAGAIN)
-			continue;
-		if (num_read == 0)
-			continue;
-		break;
-	}
-	if (!rl_event_hook)
-		el_set(el, EL_GETCFN, EL_BUILTIN_GETCFN);
-	return(num_read);
-}
-
-static void
-_rl_update_pos(void)
-{
-	const LineInfo *li = el_line(e);
-
-	rl_point = li->cursor - li->buffer;
-	rl_end = li->lastchar - li->buffer;
-}
diff --git a/libedit/refresh.c b/libedit/refresh.c
deleted file mode 100644
index 969a36d..0000000
--- a/libedit/refresh.c
+++ /dev/null
@@ -1,1139 +0,0 @@
-/*	$NetBSD: refresh.c,v 1.27 2005/11/09 22:11:10 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)refresh.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: refresh.c,v 1.27 2005/11/09 22:11:10 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * refresh.c: Lower level screen refreshing functions
- */
-#include <stdio.h>
-#include <ctype.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "el.h"
-
-private void	re_addc(EditLine *, int);
-private void	re_update_line(EditLine *, char *, char *, int);
-private void	re_insert (EditLine *, char *, int, int, char *, int);
-private void	re_delete(EditLine *, char *, int, int, int);
-private void	re_fastputc(EditLine *, int);
-private void	re_clear_eol(EditLine *, int, int, int);
-private void	re__strncopy(char *, char *, size_t);
-private void	re__copy_and_pad(char *, const char *, size_t);
-
-#ifdef DEBUG_REFRESH
-private void	re_printstr(EditLine *, const char *, char *, char *);
-#define	__F el->el_errfile
-#define	ELRE_ASSERT(a, b, c)	do 				\
-				    if (/*CONSTCOND*/ a) {	\
-					(void) fprintf b;	\
-					c;			\
-				    }				\
-				while (/*CONSTCOND*/0)
-#define	ELRE_DEBUG(a, b)	ELRE_ASSERT(a,b,;)
-
-/* re_printstr():
- *	Print a string on the debugging pty
- */
-private void
-re_printstr(EditLine *el, const char *str, char *f, char *t)
-{
-
-	ELRE_DEBUG(1, (__F, "%s:\"", str));
-	while (f < t)
-		ELRE_DEBUG(1, (__F, "%c", *f++ & 0177));
-	ELRE_DEBUG(1, (__F, "\"\r\n"));
-}
-#else
-#define	ELRE_ASSERT(a, b, c)
-#define	ELRE_DEBUG(a, b)
-#endif
-
-
-/* re_addc():
- *	Draw c, expanding tabs, control chars etc.
- */
-private void
-re_addc(EditLine *el, int c)
-{
-
-	if (isprint(c)) {
-		re_putc(el, c, 1);
-		return;
-	}
-	if (c == '\n') {				/* expand the newline */
-		int oldv = el->el_refresh.r_cursor.v;
-		re_putc(el, '\0', 0);			/* assure end of line */
-		if (oldv == el->el_refresh.r_cursor.v) { /* XXX */
-			el->el_refresh.r_cursor.h = 0;	/* reset cursor pos */
-			el->el_refresh.r_cursor.v++;
-		}
-		return;
-	}
-	if (c == '\t') {				/* expand the tab */
-		for (;;) {
-			re_putc(el, ' ', 1);
-			if ((el->el_refresh.r_cursor.h & 07) == 0)
-				break;			/* go until tab stop */
-		}
-	} else if (iscntrl(c)) {
-		re_putc(el, '^', 1);
-		if (c == '\177')
-			re_putc(el, '?', 1);
-		else
-		    /* uncontrolify it; works only for iso8859-1 like sets */
-			re_putc(el, (c | 0100), 1);
-	} else {
-		re_putc(el, '\\', 1);
-		re_putc(el, (int) ((((unsigned int) c >> 6) & 07) + '0'), 1);
-		re_putc(el, (int) ((((unsigned int) c >> 3) & 07) + '0'), 1);
-		re_putc(el, (c & 07) + '0', 1);
-	}
-}
-
-
-/* re_putc():
- *	Draw the character given
- */
-protected void
-re_putc(EditLine *el, int c, int shift)
-{
-
-	ELRE_DEBUG(1, (__F, "printing %3.3o '%c'\r\n", c, c));
-
-	el->el_vdisplay[el->el_refresh.r_cursor.v][el->el_refresh.r_cursor.h] = c;
-	if (!shift)
-		return;
-
-	el->el_refresh.r_cursor.h++;	/* advance to next place */
-	if (el->el_refresh.r_cursor.h >= el->el_term.t_size.h) {
-		el->el_vdisplay[el->el_refresh.r_cursor.v][el->el_term.t_size.h] = '\0';
-		/* assure end of line */
-		el->el_refresh.r_cursor.h = 0;	/* reset it. */
-
-		/*
-		 * If we would overflow (input is longer than terminal size),
-		 * emulate scroll by dropping first line and shuffling the rest.
-		 * We do this via pointer shuffling - it's safe in this case
-		 * and we avoid memcpy().
-		 */
-		if (el->el_refresh.r_cursor.v + 1 >= el->el_term.t_size.v) {
-			int i, lins = el->el_term.t_size.v;
-			char *firstline = el->el_vdisplay[0];
-
-			for(i=1; i < lins; i++)
-				el->el_vdisplay[i-1] = el->el_vdisplay[i];
-
-			firstline[0] = '\0';		/* empty the string */	
-			el->el_vdisplay[i-1] = firstline;
-		} else
-			el->el_refresh.r_cursor.v++;
-
-		ELRE_ASSERT(el->el_refresh.r_cursor.v >= el->el_term.t_size.v,
-		    (__F, "\r\nre_putc: overflow! r_cursor.v == %d > %d\r\n",
-		    el->el_refresh.r_cursor.v, el->el_term.t_size.v),
-		    abort());
-	}
-}
-
-
-/* re_refresh():
- *	draws the new virtual screen image from the current input
- *  	line, then goes line-by-line changing the real image to the new
- *	virtual image. The routine to re-draw a line can be replaced
- *	easily in hopes of a smarter one being placed there.
- */
-protected void
-re_refresh(EditLine *el)
-{
-	int i, rhdiff;
-	char *cp, *st;
-	coord_t cur;
-#ifdef notyet
-	size_t termsz;
-#endif
-
-	ELRE_DEBUG(1, (__F, "el->el_line.buffer = :%s:\r\n",
-	    el->el_line.buffer));
-
-	/* reset the Drawing cursor */
-	el->el_refresh.r_cursor.h = 0;
-	el->el_refresh.r_cursor.v = 0;
-
-	/* temporarily draw rprompt to calculate its size */
-	prompt_print(el, EL_RPROMPT);
-
-	/* reset the Drawing cursor */
-	el->el_refresh.r_cursor.h = 0;
-	el->el_refresh.r_cursor.v = 0;
-
-	if (el->el_line.cursor >= el->el_line.lastchar) {
-		if (el->el_map.current == el->el_map.alt
-		    && el->el_line.lastchar != el->el_line.buffer)
-			el->el_line.cursor = el->el_line.lastchar - 1;
-		else
-			el->el_line.cursor = el->el_line.lastchar;
-	}
-
-	cur.h = -1;		/* set flag in case I'm not set */
-	cur.v = 0;
-
-	prompt_print(el, EL_PROMPT);
-
-	/* draw the current input buffer */
-#if notyet
-	termsz = el->el_term.t_size.h * el->el_term.t_size.v;
-	if (el->el_line.lastchar - el->el_line.buffer > termsz) {
-		/*
-		 * If line is longer than terminal, process only part
-		 * of line which would influence display.
-		 */
-		size_t rem = (el->el_line.lastchar-el->el_line.buffer)%termsz;
-
-		st = el->el_line.lastchar - rem
-			- (termsz - (((rem / el->el_term.t_size.v) - 1)
-					* el->el_term.t_size.v));
-	} else
-#endif
-		st = el->el_line.buffer;
-
-	for (cp = st; cp < el->el_line.lastchar; cp++) {
-		if (cp == el->el_line.cursor) {
-			/* save for later */
-			cur.h = el->el_refresh.r_cursor.h;
-			cur.v = el->el_refresh.r_cursor.v;
-		}
-		re_addc(el, (unsigned char) *cp);
-	}
-
-	if (cur.h == -1) {	/* if I haven't been set yet, I'm at the end */
-		cur.h = el->el_refresh.r_cursor.h;
-		cur.v = el->el_refresh.r_cursor.v;
-	}
-	rhdiff = el->el_term.t_size.h - el->el_refresh.r_cursor.h -
-	    el->el_rprompt.p_pos.h;
-	if (el->el_rprompt.p_pos.h && !el->el_rprompt.p_pos.v &&
-	    !el->el_refresh.r_cursor.v && rhdiff > 1) {
-		/*
-		 * have a right-hand side prompt that will fit
-		 * on the end of the first line with at least
-		 * one character gap to the input buffer.
-		 */
-		while (--rhdiff > 0)	/* pad out with spaces */
-			re_putc(el, ' ', 1);
-		prompt_print(el, EL_RPROMPT);
-	} else {
-		el->el_rprompt.p_pos.h = 0;	/* flag "not using rprompt" */
-		el->el_rprompt.p_pos.v = 0;
-	}
-
-	re_putc(el, '\0', 0);	/* make line ended with NUL, no cursor shift */
-
-	el->el_refresh.r_newcv = el->el_refresh.r_cursor.v;
-
-	ELRE_DEBUG(1, (__F,
-		"term.h=%d vcur.h=%d vcur.v=%d vdisplay[0]=\r\n:%80.80s:\r\n",
-		el->el_term.t_size.h, el->el_refresh.r_cursor.h,
-		el->el_refresh.r_cursor.v, el->el_vdisplay[0]));
-
-	ELRE_DEBUG(1, (__F, "updating %d lines.\r\n", el->el_refresh.r_newcv));
-	for (i = 0; i <= el->el_refresh.r_newcv; i++) {
-		/* NOTE THAT re_update_line MAY CHANGE el_display[i] */
-		re_update_line(el, el->el_display[i], el->el_vdisplay[i], i);
-
-		/*
-		 * Copy the new line to be the current one, and pad out with
-		 * spaces to the full width of the terminal so that if we try
-		 * moving the cursor by writing the character that is at the
-		 * end of the screen line, it won't be a NUL or some old
-		 * leftover stuff.
-		 */
-		re__copy_and_pad(el->el_display[i], el->el_vdisplay[i],
-		    (size_t) el->el_term.t_size.h);
-	}
-	ELRE_DEBUG(1, (__F,
-	"\r\nel->el_refresh.r_cursor.v=%d,el->el_refresh.r_oldcv=%d i=%d\r\n",
-	    el->el_refresh.r_cursor.v, el->el_refresh.r_oldcv, i));
-
-	if (el->el_refresh.r_oldcv > el->el_refresh.r_newcv)
-		for (; i <= el->el_refresh.r_oldcv; i++) {
-			term_move_to_line(el, i);
-			term_move_to_char(el, 0);
-			term_clear_EOL(el, (int) strlen(el->el_display[i]));
-#ifdef DEBUG_REFRESH
-			term_overwrite(el, "C\b", 2);
-#endif /* DEBUG_REFRESH */
-			el->el_display[i][0] = '\0';
-		}
-
-	el->el_refresh.r_oldcv = el->el_refresh.r_newcv; /* set for next time */
-	ELRE_DEBUG(1, (__F,
-	    "\r\ncursor.h = %d, cursor.v = %d, cur.h = %d, cur.v = %d\r\n",
-	    el->el_refresh.r_cursor.h, el->el_refresh.r_cursor.v,
-	    cur.h, cur.v));
-	term_move_to_line(el, cur.v);	/* go to where the cursor is */
-	term_move_to_char(el, cur.h);
-}
-
-
-/* re_goto_bottom():
- *	 used to go to last used screen line
- */
-protected void
-re_goto_bottom(EditLine *el)
-{
-
-	term_move_to_line(el, el->el_refresh.r_oldcv);
-	term__putc('\n');
-	re_clear_display(el);
-	term__flush();
-}
-
-
-/* re_insert():
- *	insert num characters of s into d (in front of the character)
- *	at dat, maximum length of d is dlen
- */
-private void
-/*ARGSUSED*/
-re_insert(EditLine *el __attribute__((__unused__)),
-    char *d, int dat, int dlen, char *s, int num)
-{
-	char *a, *b;
-
-	if (num <= 0)
-		return;
-	if (num > dlen - dat)
-		num = dlen - dat;
-
-	ELRE_DEBUG(1,
-	    (__F, "re_insert() starting: %d at %d max %d, d == \"%s\"\n",
-	    num, dat, dlen, d));
-	ELRE_DEBUG(1, (__F, "s == \"%s\"\n", s));
-
-	/* open up the space for num chars */
-	if (num > 0) {
-		b = d + dlen - 1;
-		a = b - num;
-		while (a >= &d[dat])
-			*b-- = *a--;
-		d[dlen] = '\0';	/* just in case */
-	}
-	ELRE_DEBUG(1, (__F,
-		"re_insert() after insert: %d at %d max %d, d == \"%s\"\n",
-		num, dat, dlen, d));
-	ELRE_DEBUG(1, (__F, "s == \"%s\"\n", s));
-
-	/* copy the characters */
-	for (a = d + dat; (a < d + dlen) && (num > 0); num--)
-		*a++ = *s++;
-
-	ELRE_DEBUG(1,
-	    (__F, "re_insert() after copy: %d at %d max %d, %s == \"%s\"\n",
-	    num, dat, dlen, d, s));
-	ELRE_DEBUG(1, (__F, "s == \"%s\"\n", s));
-}
-
-
-/* re_delete():
- *	delete num characters d at dat, maximum length of d is dlen
- */
-private void
-/*ARGSUSED*/
-re_delete(EditLine *el __attribute__((__unused__)),
-    char *d, int dat, int dlen, int num)
-{
-	char *a, *b;
-
-	if (num <= 0)
-		return;
-	if (dat + num >= dlen) {
-		d[dat] = '\0';
-		return;
-	}
-	ELRE_DEBUG(1,
-	    (__F, "re_delete() starting: %d at %d max %d, d == \"%s\"\n",
-	    num, dat, dlen, d));
-
-	/* open up the space for num chars */
-	if (num > 0) {
-		b = d + dat;
-		a = b + num;
-		while (a < &d[dlen])
-			*b++ = *a++;
-		d[dlen] = '\0';	/* just in case */
-	}
-	ELRE_DEBUG(1,
-	    (__F, "re_delete() after delete: %d at %d max %d, d == \"%s\"\n",
-	    num, dat, dlen, d));
-}
-
-
-/* re__strncopy():
- *	Like strncpy without padding.
- */
-private void
-re__strncopy(char *a, char *b, size_t n)
-{
-
-	while (n-- && *b)
-		*a++ = *b++;
-}
-
-/* re_clear_eol():
- *	Find the number of characters we need to clear till the end of line
- *	in order to make sure that we have cleared the previous contents of
- *	the line. fx and sx is the number of characters inserted or deleted
- *	int the first or second diff, diff is the difference between the
- * 	number of characters between the new and old line.
- */
-private void
-re_clear_eol(EditLine *el, int fx, int sx, int diff)
-{
-
-	ELRE_DEBUG(1, (__F, "re_clear_eol sx %d, fx %d, diff %d\n",
-	    sx, fx, diff));
-
-	if (fx < 0)
-		fx = -fx;
-	if (sx < 0)
-		sx = -sx;
-	if (fx > diff)
-		diff = fx;
-	if (sx > diff)
-		diff = sx;
-
-	ELRE_DEBUG(1, (__F, "re_clear_eol %d\n", diff));
-	term_clear_EOL(el, diff);
-}
-
-/*****************************************************************
-    re_update_line() is based on finding the middle difference of each line
-    on the screen; vis:
-
-			     /old first difference
-	/beginning of line   |              /old last same       /old EOL
-	v		     v              v                    v
-old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as
-new:	eddie> Oh, my little buggy says to me, as lurgid as
-	^		     ^        ^			   ^
-	\beginning of line   |        \new last same	   \new end of line
-			     \new first difference
-
-    all are character pointers for the sake of speed.  Special cases for
-    no differences, as well as for end of line additions must be handled.
-**************************************************************** */
-
-/* Minimum at which doing an insert it "worth it".  This should be about
- * half the "cost" of going into insert mode, inserting a character, and
- * going back out.  This should really be calculated from the termcap
- * data...  For the moment, a good number for ANSI terminals.
- */
-#define	MIN_END_KEEP	4
-
-private void
-re_update_line(EditLine *el, char *old, char *new, int i)
-{
-	char *o, *n, *p, c;
-	char *ofd, *ols, *oe, *nfd, *nls, *ne;
-	char *osb, *ose, *nsb, *nse;
-	int fx, sx;
-
-	/*
-         * find first diff
-         */
-	for (o = old, n = new; *o && (*o == *n); o++, n++)
-		continue;
-	ofd = o;
-	nfd = n;
-
-	/*
-         * Find the end of both old and new
-         */
-	while (*o)
-		o++;
-	/*
-         * Remove any trailing blanks off of the end, being careful not to
-         * back up past the beginning.
-         */
-	while (ofd < o) {
-		if (o[-1] != ' ')
-			break;
-		o--;
-	}
-	oe = o;
-	*oe = '\0';
-
-	while (*n)
-		n++;
-
-	/* remove blanks from end of new */
-	while (nfd < n) {
-		if (n[-1] != ' ')
-			break;
-		n--;
-	}
-	ne = n;
-	*ne = '\0';
-
-	/*
-         * if no diff, continue to next line of redraw
-         */
-	if (*ofd == '\0' && *nfd == '\0') {
-		ELRE_DEBUG(1, (__F, "no difference.\r\n"));
-		return;
-	}
-	/*
-         * find last same pointer
-         */
-	while ((o > ofd) && (n > nfd) && (*--o == *--n))
-		continue;
-	ols = ++o;
-	nls = ++n;
-
-	/*
-         * find same begining and same end
-         */
-	osb = ols;
-	nsb = nls;
-	ose = ols;
-	nse = nls;
-
-	/*
-         * case 1: insert: scan from nfd to nls looking for *ofd
-         */
-	if (*ofd) {
-		for (c = *ofd, n = nfd; n < nls; n++) {
-			if (c == *n) {
-				for (o = ofd, p = n;
-				    p < nls && o < ols && *o == *p;
-				    o++, p++)
-					continue;
-				/*
-				 * if the new match is longer and it's worth
-				 * keeping, then we take it
-				 */
-				if (((nse - nsb) < (p - n)) &&
-				    (2 * (p - n) > n - nfd)) {
-					nsb = n;
-					nse = p;
-					osb = ofd;
-					ose = o;
-				}
-			}
-		}
-	}
-	/*
-         * case 2: delete: scan from ofd to ols looking for *nfd
-         */
-	if (*nfd) {
-		for (c = *nfd, o = ofd; o < ols; o++) {
-			if (c == *o) {
-				for (n = nfd, p = o;
-				    p < ols && n < nls && *p == *n;
-				    p++, n++)
-					continue;
-				/*
-				 * if the new match is longer and it's worth
-				 * keeping, then we take it
-				 */
-				if (((ose - osb) < (p - o)) &&
-				    (2 * (p - o) > o - ofd)) {
-					nsb = nfd;
-					nse = n;
-					osb = o;
-					ose = p;
-				}
-			}
-		}
-	}
-	/*
-         * Pragmatics I: If old trailing whitespace or not enough characters to
-         * save to be worth it, then don't save the last same info.
-         */
-	if ((oe - ols) < MIN_END_KEEP) {
-		ols = oe;
-		nls = ne;
-	}
-	/*
-         * Pragmatics II: if the terminal isn't smart enough, make the data
-         * dumber so the smart update doesn't try anything fancy
-         */
-
-	/*
-         * fx is the number of characters we need to insert/delete: in the
-         * beginning to bring the two same begins together
-         */
-	fx = (nsb - nfd) - (osb - ofd);
-	/*
-         * sx is the number of characters we need to insert/delete: in the
-         * end to bring the two same last parts together
-         */
-	sx = (nls - nse) - (ols - ose);
-
-	if (!EL_CAN_INSERT) {
-		if (fx > 0) {
-			osb = ols;
-			ose = ols;
-			nsb = nls;
-			nse = nls;
-		}
-		if (sx > 0) {
-			ols = oe;
-			nls = ne;
-		}
-		if ((ols - ofd) < (nls - nfd)) {
-			ols = oe;
-			nls = ne;
-		}
-	}
-	if (!EL_CAN_DELETE) {
-		if (fx < 0) {
-			osb = ols;
-			ose = ols;
-			nsb = nls;
-			nse = nls;
-		}
-		if (sx < 0) {
-			ols = oe;
-			nls = ne;
-		}
-		if ((ols - ofd) > (nls - nfd)) {
-			ols = oe;
-			nls = ne;
-		}
-	}
-	/*
-         * Pragmatics III: make sure the middle shifted pointers are correct if
-         * they don't point to anything (we may have moved ols or nls).
-         */
-	/* if the change isn't worth it, don't bother */
-	/* was: if (osb == ose) */
-	if ((ose - osb) < MIN_END_KEEP) {
-		osb = ols;
-		ose = ols;
-		nsb = nls;
-		nse = nls;
-	}
-	/*
-         * Now that we are done with pragmatics we recompute fx, sx
-         */
-	fx = (nsb - nfd) - (osb - ofd);
-	sx = (nls - nse) - (ols - ose);
-
-	ELRE_DEBUG(1, (__F, "fx %d, sx %d\n", fx, sx));
-	ELRE_DEBUG(1, (__F, "ofd %d, osb %d, ose %d, ols %d, oe %d\n",
-		ofd - old, osb - old, ose - old, ols - old, oe - old));
-	ELRE_DEBUG(1, (__F, "nfd %d, nsb %d, nse %d, nls %d, ne %d\n",
-		nfd - new, nsb - new, nse - new, nls - new, ne - new));
-	ELRE_DEBUG(1, (__F,
-		"xxx-xxx:\"00000000001111111111222222222233333333334\"\r\n"));
-	ELRE_DEBUG(1, (__F,
-		"xxx-xxx:\"01234567890123456789012345678901234567890\"\r\n"));
-#ifdef DEBUG_REFRESH
-	re_printstr(el, "old- oe", old, oe);
-	re_printstr(el, "new- ne", new, ne);
-	re_printstr(el, "old-ofd", old, ofd);
-	re_printstr(el, "new-nfd", new, nfd);
-	re_printstr(el, "ofd-osb", ofd, osb);
-	re_printstr(el, "nfd-nsb", nfd, nsb);
-	re_printstr(el, "osb-ose", osb, ose);
-	re_printstr(el, "nsb-nse", nsb, nse);
-	re_printstr(el, "ose-ols", ose, ols);
-	re_printstr(el, "nse-nls", nse, nls);
-	re_printstr(el, "ols- oe", ols, oe);
-	re_printstr(el, "nls- ne", nls, ne);
-#endif /* DEBUG_REFRESH */
-
-	/*
-         * el_cursor.v to this line i MUST be in this routine so that if we
-         * don't have to change the line, we don't move to it. el_cursor.h to
-         * first diff char
-         */
-	term_move_to_line(el, i);
-
-	/*
-         * at this point we have something like this:
-         *
-         * /old                  /ofd    /osb               /ose    /ols     /oe
-         * v.....................v       v..................v       v........v
-         * eddie> Oh, my fredded gruntle-buggy is to me, as foo var lurgid as
-         * eddie> Oh, my fredded quiux buggy is to me, as gruntle-lurgid as
-         * ^.....................^     ^..................^       ^........^
-         * \new                  \nfd  \nsb               \nse     \nls    \ne
-         *
-         * fx is the difference in length between the chars between nfd and
-         * nsb, and the chars between ofd and osb, and is thus the number of
-         * characters to delete if < 0 (new is shorter than old, as above),
-         * or insert (new is longer than short).
-         *
-         * sx is the same for the second differences.
-         */
-
-	/*
-         * if we have a net insert on the first difference, AND inserting the
-         * net amount ((nsb-nfd) - (osb-ofd)) won't push the last useful
-         * character (which is ne if nls != ne, otherwise is nse) off the edge
-	 * of the screen (el->el_term.t_size.h) else we do the deletes first
-	 * so that we keep everything we need to.
-         */
-
-	/*
-         * if the last same is the same like the end, there is no last same
-         * part, otherwise we want to keep the last same part set p to the
-         * last useful old character
-         */
-	p = (ols != oe) ? oe : ose;
-
-	/*
-         * if (There is a diffence in the beginning) && (we need to insert
-         *   characters) && (the number of characters to insert is less than
-         *   the term width)
-	 *	We need to do an insert!
-	 * else if (we need to delete characters)
-	 *	We need to delete characters!
-	 * else
-	 *	No insert or delete
-         */
-	if ((nsb != nfd) && fx > 0 &&
-	    ((p - old) + fx <= el->el_term.t_size.h)) {
-		ELRE_DEBUG(1,
-		    (__F, "first diff insert at %d...\r\n", nfd - new));
-		/*
-		 * Move to the first char to insert, where the first diff is.
-		 */
-		term_move_to_char(el, nfd - new);
-		/*
-		 * Check if we have stuff to keep at end
-		 */
-		if (nsb != ne) {
-			ELRE_DEBUG(1, (__F, "with stuff to keep at end\r\n"));
-			/*
-		         * insert fx chars of new starting at nfd
-		         */
-			if (fx > 0) {
-				ELRE_DEBUG(!EL_CAN_INSERT, (__F,
-				"ERROR: cannot insert in early first diff\n"));
-				term_insertwrite(el, nfd, fx);
-				re_insert(el, old, ofd - old,
-				    el->el_term.t_size.h, nfd, fx);
-			}
-			/*
-		         * write (nsb-nfd) - fx chars of new starting at
-		         * (nfd + fx)
-			 */
-			term_overwrite(el, nfd + fx, (nsb - nfd) - fx);
-			re__strncopy(ofd + fx, nfd + fx,
-			    (size_t) ((nsb - nfd) - fx));
-		} else {
-			ELRE_DEBUG(1, (__F, "without anything to save\r\n"));
-			term_overwrite(el, nfd, (nsb - nfd));
-			re__strncopy(ofd, nfd, (size_t) (nsb - nfd));
-			/*
-		         * Done
-		         */
-			return;
-		}
-	} else if (fx < 0) {
-		ELRE_DEBUG(1,
-		    (__F, "first diff delete at %d...\r\n", ofd - old));
-		/*
-		 * move to the first char to delete where the first diff is
-		 */
-		term_move_to_char(el, ofd - old);
-		/*
-		 * Check if we have stuff to save
-		 */
-		if (osb != oe) {
-			ELRE_DEBUG(1, (__F, "with stuff to save at end\r\n"));
-			/*
-		         * fx is less than zero *always* here but we check
-		         * for code symmetry
-		         */
-			if (fx < 0) {
-				ELRE_DEBUG(!EL_CAN_DELETE, (__F,
-				    "ERROR: cannot delete in first diff\n"));
-				term_deletechars(el, -fx);
-				re_delete(el, old, ofd - old,
-				    el->el_term.t_size.h, -fx);
-			}
-			/*
-		         * write (nsb-nfd) chars of new starting at nfd
-		         */
-			term_overwrite(el, nfd, (nsb - nfd));
-			re__strncopy(ofd, nfd, (size_t) (nsb - nfd));
-
-		} else {
-			ELRE_DEBUG(1, (__F,
-			    "but with nothing left to save\r\n"));
-			/*
-		         * write (nsb-nfd) chars of new starting at nfd
-		         */
-			term_overwrite(el, nfd, (nsb - nfd));
-			re_clear_eol(el, fx, sx, (oe - old) - (ne - new));
-			/*
-		         * Done
-		         */
-			return;
-		}
-	} else
-		fx = 0;
-
-	if (sx < 0 && (ose - old) + fx < el->el_term.t_size.h) {
-		ELRE_DEBUG(1, (__F,
-		    "second diff delete at %d...\r\n", (ose - old) + fx));
-		/*
-		 * Check if we have stuff to delete
-		 */
-		/*
-		 * fx is the number of characters inserted (+) or deleted (-)
-		 */
-
-		term_move_to_char(el, (ose - old) + fx);
-		/*
-		 * Check if we have stuff to save
-		 */
-		if (ols != oe) {
-			ELRE_DEBUG(1, (__F, "with stuff to save at end\r\n"));
-			/*
-		         * Again a duplicate test.
-		         */
-			if (sx < 0) {
-				ELRE_DEBUG(!EL_CAN_DELETE, (__F,
-				    "ERROR: cannot delete in second diff\n"));
-				term_deletechars(el, -sx);
-			}
-			/*
-		         * write (nls-nse) chars of new starting at nse
-		         */
-			term_overwrite(el, nse, (nls - nse));
-		} else {
-			ELRE_DEBUG(1, (__F,
-			    "but with nothing left to save\r\n"));
-			term_overwrite(el, nse, (nls - nse));
-			re_clear_eol(el, fx, sx, (oe - old) - (ne - new));
-		}
-	}
-	/*
-         * if we have a first insert AND WE HAVEN'T ALREADY DONE IT...
-         */
-	if ((nsb != nfd) && (osb - ofd) <= (nsb - nfd) && (fx == 0)) {
-		ELRE_DEBUG(1, (__F, "late first diff insert at %d...\r\n",
-		    nfd - new));
-
-		term_move_to_char(el, nfd - new);
-		/*
-		 * Check if we have stuff to keep at the end
-		 */
-		if (nsb != ne) {
-			ELRE_DEBUG(1, (__F, "with stuff to keep at end\r\n"));
-			/*
-		         * We have to recalculate fx here because we set it
-		         * to zero above as a flag saying that we hadn't done
-		         * an early first insert.
-		         */
-			fx = (nsb - nfd) - (osb - ofd);
-			if (fx > 0) {
-				/*
-				 * insert fx chars of new starting at nfd
-				 */
-				ELRE_DEBUG(!EL_CAN_INSERT, (__F,
-				 "ERROR: cannot insert in late first diff\n"));
-				term_insertwrite(el, nfd, fx);
-				re_insert(el, old, ofd - old,
-				    el->el_term.t_size.h, nfd, fx);
-			}
-			/*
-		         * write (nsb-nfd) - fx chars of new starting at
-		         * (nfd + fx)
-			 */
-			term_overwrite(el, nfd + fx, (nsb - nfd) - fx);
-			re__strncopy(ofd + fx, nfd + fx,
-			    (size_t) ((nsb - nfd) - fx));
-		} else {
-			ELRE_DEBUG(1, (__F, "without anything to save\r\n"));
-			term_overwrite(el, nfd, (nsb - nfd));
-			re__strncopy(ofd, nfd, (size_t) (nsb - nfd));
-		}
-	}
-	/*
-         * line is now NEW up to nse
-         */
-	if (sx >= 0) {
-		ELRE_DEBUG(1, (__F,
-		    "second diff insert at %d...\r\n", nse - new));
-		term_move_to_char(el, nse - new);
-		if (ols != oe) {
-			ELRE_DEBUG(1, (__F, "with stuff to keep at end\r\n"));
-			if (sx > 0) {
-				/* insert sx chars of new starting at nse */
-				ELRE_DEBUG(!EL_CAN_INSERT, (__F,
-				    "ERROR: cannot insert in second diff\n"));
-				term_insertwrite(el, nse, sx);
-			}
-			/*
-		         * write (nls-nse) - sx chars of new starting at
-			 * (nse + sx)
-		         */
-			term_overwrite(el, nse + sx, (nls - nse) - sx);
-		} else {
-			ELRE_DEBUG(1, (__F, "without anything to save\r\n"));
-			term_overwrite(el, nse, (nls - nse));
-
-			/*
-	                 * No need to do a clear-to-end here because we were
-	                 * doing a second insert, so we will have over
-	                 * written all of the old string.
-		         */
-		}
-	}
-	ELRE_DEBUG(1, (__F, "done.\r\n"));
-}
-
-
-/* re__copy_and_pad():
- *	Copy string and pad with spaces
- */
-private void
-re__copy_and_pad(char *dst, const char *src, size_t width)
-{
-	size_t i;
-
-	for (i = 0; i < width; i++) {
-		if (*src == '\0')
-			break;
-		*dst++ = *src++;
-	}
-
-	for (; i < width; i++)
-		*dst++ = ' ';
-
-	*dst = '\0';
-}
-
-
-/* re_refresh_cursor():
- *	Move to the new cursor position
- */
-protected void
-re_refresh_cursor(EditLine *el)
-{
-	char *cp, c;
-	int h, v, th;
-
-	if (el->el_line.cursor >= el->el_line.lastchar) {
-		if (el->el_map.current == el->el_map.alt
-		    && el->el_line.lastchar != el->el_line.buffer)
-			el->el_line.cursor = el->el_line.lastchar - 1;
-		else
-			el->el_line.cursor = el->el_line.lastchar;
-	}
-
-	/* first we must find where the cursor is... */
-	h = el->el_prompt.p_pos.h;
-	v = el->el_prompt.p_pos.v;
-	th = el->el_term.t_size.h;	/* optimize for speed */
-
-	/* do input buffer to el->el_line.cursor */
-	for (cp = el->el_line.buffer; cp < el->el_line.cursor; cp++) {
-		c = *cp;
-		h++;		/* all chars at least this long */
-
-		if (c == '\n') {/* handle newline in data part too */
-			h = 0;
-			v++;
-		} else {
-			if (c == '\t') {	/* if a tab, to next tab stop */
-				while (h & 07) {
-					h++;
-				}
-			} else if (iscntrl((unsigned char) c)) {
-						/* if control char */
-				h++;
-				if (h > th) {	/* if overflow, compensate */
-					h = 1;
-					v++;
-				}
-			} else if (!isprint((unsigned char) c)) {
-				h += 3;
-				if (h > th) {	/* if overflow, compensate */
-					h = h - th;
-					v++;
-				}
-			}
-		}
-
-		if (h >= th) {	/* check, extra long tabs picked up here also */
-			h = 0;
-			v++;
-		}
-	}
-
-	/* now go there */
-	term_move_to_line(el, v);
-	term_move_to_char(el, h);
-	term__flush();
-}
-
-
-/* re_fastputc():
- *	Add a character fast.
- */
-private void
-re_fastputc(EditLine *el, int c)
-{
-
-	term__putc(c);
-	el->el_display[el->el_cursor.v][el->el_cursor.h++] = c;
-	if (el->el_cursor.h >= el->el_term.t_size.h) {
-		/* if we must overflow */
-		el->el_cursor.h = 0;
-
-		/*
-		 * If we would overflow (input is longer than terminal size),
-		 * emulate scroll by dropping first line and shuffling the rest.
-		 * We do this via pointer shuffling - it's safe in this case
-		 * and we avoid memcpy().
-		 */
-		if (el->el_cursor.v + 1 >= el->el_term.t_size.v) {
-			int i, lins = el->el_term.t_size.v;
-			char *firstline = el->el_display[0];
-	
-			for(i=1; i < lins; i++)
-				el->el_display[i-1] = el->el_display[i];
-
-			re__copy_and_pad(firstline, "", 0);
-			el->el_display[i-1] = firstline;
-		} else {
-			el->el_cursor.v++;
-			el->el_refresh.r_oldcv++;
-		}
-		if (EL_HAS_AUTO_MARGINS) {
-			if (EL_HAS_MAGIC_MARGINS) {
-				term__putc(' ');
-				term__putc('\b');
-			}
-		} else {
-			term__putc('\r');
-			term__putc('\n');
-		}
-	}
-}
-
-
-/* re_fastaddc():
- *	we added just one char, handle it fast.
- *	Assumes that screen cursor == real cursor
- */
-protected void
-re_fastaddc(EditLine *el)
-{
-	char c;
-	int rhdiff;
-
-	c = el->el_line.cursor[-1];
-
-	if (c == '\t' || el->el_line.cursor != el->el_line.lastchar) {
-		re_refresh(el);	/* too hard to handle */
-		return;
-	}
-	rhdiff = el->el_term.t_size.h - el->el_cursor.h -
-	    el->el_rprompt.p_pos.h;
-	if (el->el_rprompt.p_pos.h && rhdiff < 3) {
-		re_refresh(el);	/* clear out rprompt if less than 1 char gap */
-		return;
-	}			/* else (only do at end of line, no TAB) */
-	if (iscntrl((unsigned char) c)) {	/* if control char, do caret */
-		char mc = (c == '\177') ? '?' : (c | 0100);
-		re_fastputc(el, '^');
-		re_fastputc(el, mc);
-	} else if (isprint((unsigned char) c)) {	/* normal char */
-		re_fastputc(el, c);
-	} else {
-		re_fastputc(el, '\\');
-		re_fastputc(el, (int)(((((unsigned int)c) >> 6) & 3) + '0'));
-		re_fastputc(el, (int)(((((unsigned int)c) >> 3) & 7) + '0'));
-		re_fastputc(el, (c & 7) + '0');
-	}
-	term__flush();
-}
-
-
-/* re_clear_display():
- *	clear the screen buffers so that new new prompt starts fresh.
- */
-protected void
-re_clear_display(EditLine *el)
-{
-	int i;
-
-	el->el_cursor.v = 0;
-	el->el_cursor.h = 0;
-	for (i = 0; i < el->el_term.t_size.v; i++)
-		el->el_display[i][0] = '\0';
-	el->el_refresh.r_oldcv = 0;
-}
-
-
-/* re_clear_lines():
- *	Make sure all lines are *really* blank
- */
-protected void
-re_clear_lines(EditLine *el)
-{
-
-	if (EL_CAN_CEOL) {
-		int i;
-		term_move_to_char(el, 0);
-		for (i = 0; i <= el->el_refresh.r_oldcv; i++) {
-			/* for each line on the screen */
-			term_move_to_line(el, i);
-			term_clear_EOL(el, el->el_term.t_size.h);
-		}
-		term_move_to_line(el, 0);
-	} else {
-		term_move_to_line(el, el->el_refresh.r_oldcv);
-					/* go to last line */
-		term__putc('\r');	/* go to BOL */
-		term__putc('\n');	/* go to new line */
-	}
-}
diff --git a/libedit/refresh.h b/libedit/refresh.h
deleted file mode 100644
index dd2bd02..0000000
--- a/libedit/refresh.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*	$NetBSD: refresh.h,v 1.5 2003/08/07 16:44:33 agc Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)refresh.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.refresh.h: Screen refresh functions
- */
-#ifndef _h_el_refresh
-#define	_h_el_refresh
-
-#include "histedit.h"
-
-typedef struct {
-	coord_t	r_cursor;	/* Refresh cursor position	*/
-	int	r_oldcv;	/* Vertical locations		*/
-	int	r_newcv;
-} el_refresh_t;
-
-protected void	re_putc(EditLine *, int, int);
-protected void	re_clear_lines(EditLine *);
-protected void	re_clear_display(EditLine *);
-protected void	re_refresh(EditLine *);
-protected void	re_refresh_cursor(EditLine *);
-protected void	re_fastaddc(EditLine *);
-protected void	re_goto_bottom(EditLine *);
-
-#endif /* _h_el_refresh */
diff --git a/libedit/search.c b/libedit/search.c
deleted file mode 100644
index be2f377..0000000
--- a/libedit/search.c
+++ /dev/null
@@ -1,634 +0,0 @@
-/*	$NetBSD: search.c,v 1.20 2004/11/04 01:16:03 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)search.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: search.c,v 1.20 2004/11/04 01:16:03 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * search.c: History and character search functions
- */
-#include <stdlib.h>
-#include <sys/types.h>
-#if defined(REGEX)
-#include <regex.h>
-#elif defined(REGEXP)
-#include <regexp.h>
-#endif
-#include "el.h"
-
-/*
- * Adjust cursor in vi mode to include the character under it
- */
-#define	EL_CURSOR(el) \
-    ((el)->el_line.cursor + (((el)->el_map.type == MAP_VI) && \
-			    ((el)->el_map.current == (el)->el_map.alt)))
-
-/* search_init():
- *	Initialize the search stuff
- */
-protected int
-search_init(EditLine *el)
-{
-
-	el->el_search.patbuf = (char *) el_malloc(EL_BUFSIZ);
-	if (el->el_search.patbuf == NULL)
-		return (-1);
-	el->el_search.patlen = 0;
-	el->el_search.patdir = -1;
-	el->el_search.chacha = '\0';
-	el->el_search.chadir = CHAR_FWD;
-	el->el_search.chatflg = 0;
-	return (0);
-}
-
-
-/* search_end():
- *	Initialize the search stuff
- */
-protected void
-search_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_search.patbuf);
-	el->el_search.patbuf = NULL;
-}
-
-
-#ifdef REGEXP
-/* regerror():
- *	Handle regular expression errors
- */
-public void
-/*ARGSUSED*/
-regerror(const char *msg)
-{
-}
-#endif
-
-
-/* el_match():
- *	Return if string matches pattern
- */
-protected int
-el_match(const char *str, const char *pat)
-{
-#if defined (REGEX)
-	regex_t re;
-	int rv;
-#elif defined (REGEXP)
-	regexp *rp;
-	int rv;
-#else
-	extern char	*re_comp(const char *);
-	extern int	 re_exec(const char *);
-#endif
-
-	if (strstr(str, pat) != NULL)
-		return (1);
-
-#if defined(REGEX)
-	if (regcomp(&re, pat, 0) == 0) {
-		rv = regexec(&re, str, 0, NULL, 0) == 0;
-		regfree(&re);
-	} else {
-		rv = 0;
-	}
-	return (rv);
-#elif defined(REGEXP)
-	if ((re = regcomp(pat)) != NULL) {
-		rv = regexec(re, str);
-		free((ptr_t) re);
-	} else {
-		rv = 0;
-	}
-	return (rv);
-#else
-	if (re_comp(pat) != NULL)
-		return (0);
-	else
-		return (re_exec(str) == 1);
-#endif
-}
-
-
-/* c_hmatch():
- *	 return True if the pattern matches the prefix
- */
-protected int
-c_hmatch(EditLine *el, const char *str)
-{
-#ifdef SDEBUG
-	(void) fprintf(el->el_errfile, "match `%s' with `%s'\n",
-	    el->el_search.patbuf, str);
-#endif /* SDEBUG */
-
-	return (el_match(str, el->el_search.patbuf));
-}
-
-
-/* c_setpat():
- *	Set the history seatch pattern
- */
-protected void
-c_setpat(EditLine *el)
-{
-	if (el->el_state.lastcmd != ED_SEARCH_PREV_HISTORY &&
-	    el->el_state.lastcmd != ED_SEARCH_NEXT_HISTORY) {
-		el->el_search.patlen = EL_CURSOR(el) - el->el_line.buffer;
-		if (el->el_search.patlen >= EL_BUFSIZ)
-			el->el_search.patlen = EL_BUFSIZ - 1;
-		if (el->el_search.patlen != 0) {
-			(void) strncpy(el->el_search.patbuf, el->el_line.buffer,
-			    el->el_search.patlen);
-			el->el_search.patbuf[el->el_search.patlen] = '\0';
-		} else
-			el->el_search.patlen = strlen(el->el_search.patbuf);
-	}
-#ifdef SDEBUG
-	(void) fprintf(el->el_errfile, "\neventno = %d\n",
-	    el->el_history.eventno);
-	(void) fprintf(el->el_errfile, "patlen = %d\n", el->el_search.patlen);
-	(void) fprintf(el->el_errfile, "patbuf = \"%s\"\n",
-	    el->el_search.patbuf);
-	(void) fprintf(el->el_errfile, "cursor %d lastchar %d\n",
-	    EL_CURSOR(el) - el->el_line.buffer,
-	    el->el_line.lastchar - el->el_line.buffer);
-#endif
-}
-
-
-/* ce_inc_search():
- *	Emacs incremental search
- */
-protected el_action_t
-ce_inc_search(EditLine *el, int dir)
-{
-	static const char STRfwd[] = {'f', 'w', 'd', '\0'},
-	     STRbck[] = {'b', 'c', 'k', '\0'};
-	static char pchar = ':';/* ':' = normal, '?' = failed */
-	static char endcmd[2] = {'\0', '\0'};
-	char ch, *ocursor = el->el_line.cursor, oldpchar = pchar;
-	const char *cp;
-
-	el_action_t ret = CC_NORM;
-
-	int ohisteventno = el->el_history.eventno;
-	int oldpatlen = el->el_search.patlen;
-	int newdir = dir;
-	int done, redo;
-
-	if (el->el_line.lastchar + sizeof(STRfwd) / sizeof(char) + 2 +
-	    el->el_search.patlen >= el->el_line.limit)
-		return (CC_ERROR);
-
-	for (;;) {
-
-		if (el->el_search.patlen == 0) {	/* first round */
-			pchar = ':';
-#ifdef ANCHOR
-#define	LEN	2
-			el->el_search.patbuf[el->el_search.patlen++] = '.';
-			el->el_search.patbuf[el->el_search.patlen++] = '*';
-#else
-#define	LEN	0
-#endif
-		}
-		done = redo = 0;
-		*el->el_line.lastchar++ = '\n';
-		for (cp = (newdir == ED_SEARCH_PREV_HISTORY) ? STRbck : STRfwd;
-		    *cp; *el->el_line.lastchar++ = *cp++)
-			continue;
-		*el->el_line.lastchar++ = pchar;
-		for (cp = &el->el_search.patbuf[LEN];
-		    cp < &el->el_search.patbuf[el->el_search.patlen];
-		    *el->el_line.lastchar++ = *cp++)
-			continue;
-		*el->el_line.lastchar = '\0';
-		re_refresh(el);
-
-		if (el_getc(el, &ch) != 1)
-			return (ed_end_of_file(el, 0));
-
-		switch (el->el_map.current[(unsigned char) ch]) {
-		case ED_INSERT:
-		case ED_DIGIT:
-			if (el->el_search.patlen >= EL_BUFSIZ - LEN)
-				term_beep(el);
-			else {
-				el->el_search.patbuf[el->el_search.patlen++] =
-				    ch;
-				*el->el_line.lastchar++ = ch;
-				*el->el_line.lastchar = '\0';
-				re_refresh(el);
-			}
-			break;
-
-		case EM_INC_SEARCH_NEXT:
-			newdir = ED_SEARCH_NEXT_HISTORY;
-			redo++;
-			break;
-
-		case EM_INC_SEARCH_PREV:
-			newdir = ED_SEARCH_PREV_HISTORY;
-			redo++;
-			break;
-
-		case EM_DELETE_PREV_CHAR:
-		case ED_DELETE_PREV_CHAR:
-			if (el->el_search.patlen > LEN)
-				done++;
-			else
-				term_beep(el);
-			break;
-
-		default:
-			switch (ch) {
-			case 0007:	/* ^G: Abort */
-				ret = CC_ERROR;
-				done++;
-				break;
-
-			case 0027:	/* ^W: Append word */
-			/* No can do if globbing characters in pattern */
-				for (cp = &el->el_search.patbuf[LEN];; cp++)
-				    if (cp >= &el->el_search.patbuf[
-					el->el_search.patlen]) {
-					el->el_line.cursor +=
-					    el->el_search.patlen - LEN - 1;
-					cp = c__next_word(el->el_line.cursor,
-					    el->el_line.lastchar, 1,
-					    ce__isword);
-					while (el->el_line.cursor < cp &&
-					    *el->el_line.cursor != '\n') {
-						if (el->el_search.patlen >=
-						    EL_BUFSIZ - LEN) {
-							term_beep(el);
-							break;
-						}
-						el->el_search.patbuf[el->el_search.patlen++] =
-						    *el->el_line.cursor;
-						*el->el_line.lastchar++ =
-						    *el->el_line.cursor++;
-					}
-					el->el_line.cursor = ocursor;
-					*el->el_line.lastchar = '\0';
-					re_refresh(el);
-					break;
-				    } else if (isglob(*cp)) {
-					    term_beep(el);
-					    break;
-				    }
-				break;
-
-			default:	/* Terminate and execute cmd */
-				endcmd[0] = ch;
-				el_push(el, endcmd);
-				/* FALLTHROUGH */
-
-			case 0033:	/* ESC: Terminate */
-				ret = CC_REFRESH;
-				done++;
-				break;
-			}
-			break;
-		}
-
-		while (el->el_line.lastchar > el->el_line.buffer &&
-		    *el->el_line.lastchar != '\n')
-			*el->el_line.lastchar-- = '\0';
-		*el->el_line.lastchar = '\0';
-
-		if (!done) {
-
-			/* Can't search if unmatched '[' */
-			for (cp = &el->el_search.patbuf[el->el_search.patlen-1],
-			    ch = ']';
-			    cp >= &el->el_search.patbuf[LEN];
-			    cp--)
-				if (*cp == '[' || *cp == ']') {
-					ch = *cp;
-					break;
-				}
-			if (el->el_search.patlen > LEN && ch != '[') {
-				if (redo && newdir == dir) {
-					if (pchar == '?') { /* wrap around */
-						el->el_history.eventno =
-						    newdir == ED_SEARCH_PREV_HISTORY ? 0 : 0x7fffffff;
-						if (hist_get(el) == CC_ERROR)
-							/* el->el_history.event
-							 * no was fixed by
-							 * first call */
-							(void) hist_get(el);
-						el->el_line.cursor = newdir ==
-						    ED_SEARCH_PREV_HISTORY ?
-						    el->el_line.lastchar :
-						    el->el_line.buffer;
-					} else
-						el->el_line.cursor +=
-						    newdir ==
-						    ED_SEARCH_PREV_HISTORY ?
-						    -1 : 1;
-				}
-#ifdef ANCHOR
-				el->el_search.patbuf[el->el_search.patlen++] =
-				    '.';
-				el->el_search.patbuf[el->el_search.patlen++] =
-				    '*';
-#endif
-				el->el_search.patbuf[el->el_search.patlen] =
-				    '\0';
-				if (el->el_line.cursor < el->el_line.buffer ||
-				    el->el_line.cursor > el->el_line.lastchar ||
-				    (ret = ce_search_line(el, newdir))
-				    == CC_ERROR) {
-					/* avoid c_setpat */
-					el->el_state.lastcmd =
-					    (el_action_t) newdir;
-					ret = newdir == ED_SEARCH_PREV_HISTORY ?
-					    ed_search_prev_history(el, 0) :
-					    ed_search_next_history(el, 0);
-					if (ret != CC_ERROR) {
-						el->el_line.cursor = newdir ==
-						    ED_SEARCH_PREV_HISTORY ?
-						    el->el_line.lastchar :
-						    el->el_line.buffer;
-						(void) ce_search_line(el,
-						    newdir);
-					}
-				}
-				el->el_search.patlen -= LEN;
-				el->el_search.patbuf[el->el_search.patlen] =
-				    '\0';
-				if (ret == CC_ERROR) {
-					term_beep(el);
-					if (el->el_history.eventno !=
-					    ohisteventno) {
-						el->el_history.eventno =
-						    ohisteventno;
-						if (hist_get(el) == CC_ERROR)
-							return (CC_ERROR);
-					}
-					el->el_line.cursor = ocursor;
-					pchar = '?';
-				} else {
-					pchar = ':';
-				}
-			}
-			ret = ce_inc_search(el, newdir);
-
-			if (ret == CC_ERROR && pchar == '?' && oldpchar == ':')
-				/*
-				 * break abort of failed search at last
-				 * non-failed
-				 */
-				ret = CC_NORM;
-
-		}
-		if (ret == CC_NORM || (ret == CC_ERROR && oldpatlen == 0)) {
-			/* restore on normal return or error exit */
-			pchar = oldpchar;
-			el->el_search.patlen = oldpatlen;
-			if (el->el_history.eventno != ohisteventno) {
-				el->el_history.eventno = ohisteventno;
-				if (hist_get(el) == CC_ERROR)
-					return (CC_ERROR);
-			}
-			el->el_line.cursor = ocursor;
-			if (ret == CC_ERROR)
-				re_refresh(el);
-		}
-		if (done || ret != CC_NORM)
-			return (ret);
-	}
-}
-
-
-/* cv_search():
- *	Vi search.
- */
-protected el_action_t
-cv_search(EditLine *el, int dir)
-{
-	char ch;
-	char tmpbuf[EL_BUFSIZ];
-	int tmplen;
-
-#ifdef ANCHOR
-	tmpbuf[0] = '.';
-	tmpbuf[1] = '*';
-#endif
-	tmplen = LEN;
-
-	el->el_search.patdir = dir;
-
-	tmplen = c_gets(el, &tmpbuf[LEN],
-		dir == ED_SEARCH_PREV_HISTORY ? "\n/" : "\n?" );
-	if (tmplen == -1)
-		return CC_REFRESH;
-
-	tmplen += LEN;
-	ch = tmpbuf[tmplen];
-	tmpbuf[tmplen] = '\0';
-
-	if (tmplen == LEN) {
-		/*
-		 * Use the old pattern, but wild-card it.
-		 */
-		if (el->el_search.patlen == 0) {
-			re_refresh(el);
-			return (CC_ERROR);
-		}
-#ifdef ANCHOR
-		if (el->el_search.patbuf[0] != '.' &&
-		    el->el_search.patbuf[0] != '*') {
-			(void) strncpy(tmpbuf, el->el_search.patbuf,
-			    sizeof(tmpbuf) - 1);
-			el->el_search.patbuf[0] = '.';
-			el->el_search.patbuf[1] = '*';
-			(void) strncpy(&el->el_search.patbuf[2], tmpbuf,
-			    EL_BUFSIZ - 3);
-			el->el_search.patlen++;
-			el->el_search.patbuf[el->el_search.patlen++] = '.';
-			el->el_search.patbuf[el->el_search.patlen++] = '*';
-			el->el_search.patbuf[el->el_search.patlen] = '\0';
-		}
-#endif
-	} else {
-#ifdef ANCHOR
-		tmpbuf[tmplen++] = '.';
-		tmpbuf[tmplen++] = '*';
-#endif
-		tmpbuf[tmplen] = '\0';
-		(void) strncpy(el->el_search.patbuf, tmpbuf, EL_BUFSIZ - 1);
-		el->el_search.patlen = tmplen;
-	}
-	el->el_state.lastcmd = (el_action_t) dir;	/* avoid c_setpat */
-	el->el_line.cursor = el->el_line.lastchar = el->el_line.buffer;
-	if ((dir == ED_SEARCH_PREV_HISTORY ? ed_search_prev_history(el, 0) :
-	    ed_search_next_history(el, 0)) == CC_ERROR) {
-		re_refresh(el);
-		return (CC_ERROR);
-	}
-	if (ch == 0033) {
-		re_refresh(el);
-		return ed_newline(el, 0);
-	}
-	return (CC_REFRESH);
-}
-
-
-/* ce_search_line():
- *	Look for a pattern inside a line
- */
-protected el_action_t
-ce_search_line(EditLine *el, int dir)
-{
-	char *cp = el->el_line.cursor;
-	char *pattern = el->el_search.patbuf;
-	char oc, *ocp;
-#ifdef ANCHOR
-	ocp = &pattern[1];
-	oc = *ocp;
-	*ocp = '^';
-#else
-	ocp = pattern;
-	oc = *ocp;
-#endif
-
-	if (dir == ED_SEARCH_PREV_HISTORY) {
-		for (; cp >= el->el_line.buffer; cp--) {
-			if (el_match(cp, ocp)) {
-				*ocp = oc;
-				el->el_line.cursor = cp;
-				return (CC_NORM);
-			}
-		}
-		*ocp = oc;
-		return (CC_ERROR);
-	} else {
-		for (; *cp != '\0' && cp < el->el_line.limit; cp++) {
-			if (el_match(cp, ocp)) {
-				*ocp = oc;
-				el->el_line.cursor = cp;
-				return (CC_NORM);
-			}
-		}
-		*ocp = oc;
-		return (CC_ERROR);
-	}
-}
-
-
-/* cv_repeat_srch():
- *	Vi repeat search
- */
-protected el_action_t
-cv_repeat_srch(EditLine *el, int c)
-{
-
-#ifdef SDEBUG
-	(void) fprintf(el->el_errfile, "dir %d patlen %d patbuf %s\n",
-	    c, el->el_search.patlen, el->el_search.patbuf);
-#endif
-
-	el->el_state.lastcmd = (el_action_t) c;	/* Hack to stop c_setpat */
-	el->el_line.lastchar = el->el_line.buffer;
-
-	switch (c) {
-	case ED_SEARCH_NEXT_HISTORY:
-		return (ed_search_next_history(el, 0));
-	case ED_SEARCH_PREV_HISTORY:
-		return (ed_search_prev_history(el, 0));
-	default:
-		return (CC_ERROR);
-	}
-}
-
-
-/* cv_csearch():
- *	Vi character search
- */
-protected el_action_t
-cv_csearch(EditLine *el, int direction, int ch, int count, int tflag)
-{
-	char *cp;
-
-	if (ch == 0)
-		return CC_ERROR;
-
-	if (ch == -1) {
-		char c;
-		if (el_getc(el, &c) != 1)
-			return ed_end_of_file(el, 0);
-		ch = c;
-	}
-
-	/* Save for ';' and ',' commands */
-	el->el_search.chacha = ch;
-	el->el_search.chadir = direction;
-	el->el_search.chatflg = tflag;
-
-	cp = el->el_line.cursor;
-	while (count--) {
-		if (*cp == ch)
-			cp += direction;
-		for (;;cp += direction) {
-			if (cp >= el->el_line.lastchar)
-				return CC_ERROR;
-			if (cp < el->el_line.buffer)
-				return CC_ERROR;
-			if (*cp == ch)
-				break;
-		}
-	}
-
-	if (tflag)
-		cp -= direction;
-
-	el->el_line.cursor = cp;
-
-	if (el->el_chared.c_vcmd.action != NOP) {
-		if (direction > 0)
-			el->el_line.cursor++;
-		cv_delfini(el);
-		return CC_REFRESH;
-	}
-	return CC_CURSOR;
-}
diff --git a/libedit/search.h b/libedit/search.h
deleted file mode 100644
index 2aa8f98..0000000
--- a/libedit/search.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*	$NetBSD: search.h,v 1.8 2003/10/18 23:27:36 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)search.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.search.h: Line and history searching utilities
- */
-#ifndef _h_el_search
-#define	_h_el_search
-
-#include "histedit.h"
-
-typedef struct el_search_t {
-	char	*patbuf;		/* The pattern buffer		*/
-	size_t	 patlen;		/* Length of the pattern buffer	*/
-	int	 patdir;		/* Direction of the last search	*/
-	int	 chadir;		/* Character search direction	*/
-	char	 chacha;		/* Character we are looking for	*/
-	char	 chatflg;		/* 0 if f, 1 if t */
-} el_search_t;
-
-
-protected int		el_match(const char *, const char *);
-protected int		search_init(EditLine *);
-protected void		search_end(EditLine *);
-protected int		c_hmatch(EditLine *, const char *);
-protected void		c_setpat(EditLine *);
-protected el_action_t	ce_inc_search(EditLine *, int);
-protected el_action_t	cv_search(EditLine *, int);
-protected el_action_t	ce_search_line(EditLine *, int);
-protected el_action_t	cv_repeat_srch(EditLine *, int);
-protected el_action_t	cv_csearch(EditLine *, int, int, int, int);
-
-#endif /* _h_el_search */
diff --git a/libedit/sig.c b/libedit/sig.c
deleted file mode 100644
index 9662b99..0000000
--- a/libedit/sig.c
+++ /dev/null
@@ -1,194 +0,0 @@
-/*	$NetBSD: sig.c,v 1.11 2003/08/07 16:44:33 agc Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)sig.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: sig.c,v 1.11 2003/08/07 16:44:33 agc Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * sig.c: Signal handling stuff.
- *	  our policy is to trap all signals, set a good state
- *	  and pass the ball to our caller.
- */
-#include "el.h"
-#include <stdlib.h>
-
-private EditLine *sel = NULL;
-
-private const int sighdl[] = {
-#define	_DO(a)	(a),
-	ALLSIGS
-#undef	_DO
-	- 1
-};
-
-private void sig_handler(int);
-
-/* sig_handler():
- *	This is the handler called for all signals
- *	XXX: we cannot pass any data so we just store the old editline
- *	state in a private variable
- */
-private void
-sig_handler(int signo)
-{
-	int i;
-	sigset_t nset, oset;
-
-	(void) sigemptyset(&nset);
-	(void) sigaddset(&nset, signo);
-	(void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-	switch (signo) {
-	case SIGCONT:
-		tty_rawmode(sel);
-		if (ed_redisplay(sel, 0) == CC_REFRESH)
-			re_refresh(sel);
-		term__flush();
-		break;
-
-	case SIGWINCH:
-		el_resize(sel);
-		break;
-
-	default:
-		tty_cookedmode(sel);
-		break;
-	}
-
-	for (i = 0; sighdl[i] != -1; i++)
-		if (signo == sighdl[i])
-			break;
-
-	(void) signal(signo, sel->el_signal[i]);
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-	(void) kill(0, signo);
-}
-
-
-/* sig_init():
- *	Initialize all signal stuff
- */
-protected int
-sig_init(EditLine *el)
-{
-	int i;
-	sigset_t nset, oset;
-
-	(void) sigemptyset(&nset);
-#define	_DO(a) (void) sigaddset(&nset, a);
-	ALLSIGS
-#undef	_DO
-	    (void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-#define	SIGSIZE (sizeof(sighdl) / sizeof(sighdl[0]) * sizeof(el_signalhandler_t))
-
-	el->el_signal = (el_signalhandler_t *) el_malloc(SIGSIZE);
-	if (el->el_signal == NULL)
-		return (-1);
-	for (i = 0; sighdl[i] != -1; i++)
-		el->el_signal[i] = SIG_ERR;
-
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-
-	return (0);
-}
-
-
-/* sig_end():
- *	Clear all signal stuff
- */
-protected void
-sig_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_signal);
-	el->el_signal = NULL;
-}
-
-
-/* sig_set():
- *	set all the signal handlers
- */
-protected void
-sig_set(EditLine *el)
-{
-	int i;
-	sigset_t nset, oset;
-
-	(void) sigemptyset(&nset);
-#define	_DO(a) (void) sigaddset(&nset, a);
-	ALLSIGS
-#undef	_DO
-	    (void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-	for (i = 0; sighdl[i] != -1; i++) {
-		el_signalhandler_t s;
-		/* This could happen if we get interrupted */
-		if ((s = signal(sighdl[i], sig_handler)) != sig_handler)
-			el->el_signal[i] = s;
-	}
-	sel = el;
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-}
-
-
-/* sig_clr():
- *	clear all the signal handlers
- */
-protected void
-sig_clr(EditLine *el)
-{
-	int i;
-	sigset_t nset, oset;
-
-	(void) sigemptyset(&nset);
-#define	_DO(a) (void) sigaddset(&nset, a);
-	ALLSIGS
-#undef	_DO
-	    (void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-	for (i = 0; sighdl[i] != -1; i++)
-		if (el->el_signal[i] != SIG_ERR)
-			(void) signal(sighdl[i], el->el_signal[i]);
-
-	sel = NULL;		/* we are going to die if the handler is
-				 * called */
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-}
diff --git a/libedit/sig.h b/libedit/sig.h
deleted file mode 100644
index 0bf1fc3..0000000
--- a/libedit/sig.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*	$NetBSD: sig.h,v 1.5 2003/08/07 16:44:33 agc Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)sig.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.sig.h: Signal handling functions
- */
-#ifndef _h_el_sig
-#define	_h_el_sig
-
-#include <signal.h>
-
-#include "histedit.h"
-
-/*
- * Define here all the signals we are going to handle
- * The _DO macro is used to iterate in the source code
- */
-#define	ALLSIGS		\
-	_DO(SIGINT)	\
-	_DO(SIGTSTP)	\
-	_DO(SIGSTOP)	\
-	_DO(SIGQUIT)	\
-	_DO(SIGHUP)	\
-	_DO(SIGTERM)	\
-	_DO(SIGCONT)	\
-	_DO(SIGWINCH)
-
-typedef void (*el_signalhandler_t)(int);
-typedef el_signalhandler_t *el_signal_t;
-
-protected void	sig_end(EditLine*);
-protected int	sig_init(EditLine*);
-protected void	sig_set(EditLine*);
-protected void	sig_clr(EditLine*);
-
-#endif /* _h_el_sig */
diff --git a/libedit/strlcat.c b/libedit/strlcat.c
deleted file mode 100644
index 7541ba4..0000000
--- a/libedit/strlcat.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/*	$NetBSD: strlcat.c,v 1.1 2005/12/20 19:28:52 christos Exp $	*/
-/*	$OpenBSD: strlcat.c,v 1.10 2003/04/12 21:56:39 millert Exp $	*/
-
-/*
- * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
- * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
- * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#include "sys.h"
-
-#if defined(LIBC_SCCS) && !defined(lint)
-__RCSID("$NetBSD: strlcat.c,v 1.1 2005/12/20 19:28:52 christos Exp $");
-#endif /* LIBC_SCCS and not lint */
-
-#include <sys/types.h>
-#include <assert.h>
-#include <string.h>
-
-#ifdef _LIBC
-# ifdef __weak_alias
-__weak_alias(strlcat, _strlcat)
-# endif
-#endif
-
-#if !HAVE_STRLCAT
-/*
- * Appends src to string dst of size siz (unlike strncat, siz is the
- * full size of dst, not space left).  At most siz-1 characters
- * will be copied.  Always NUL terminates (unless siz <= strlen(dst)).
- * Returns strlen(src) + MIN(siz, strlen(initial dst)).
- * If retval >= siz, truncation occurred.
- */
-size_t
-#ifdef _LIBC
-_strlcat(dst, src, siz)
-#else
-strlcat(dst, src, siz)
-#endif
-	char *dst;
-	const char *src;
-	size_t siz;
-{
-	char *d = dst;
-	const char *s = src;
-	size_t n = siz;
-	size_t dlen;
-
-	_DIAGASSERT(dst != NULL);
-	_DIAGASSERT(src != NULL);
-
-	/* Find the end of dst and adjust bytes left but don't go past end */
-	while (n-- != 0 && *d != '\0')
-		d++;
-	dlen = d - dst;
-	n = siz - dlen;
-
-	if (n == 0)
-		return(dlen + strlen(s));
-	while (*s != '\0') {
-		if (n != 1) {
-			*d++ = *s;
-			n--;
-		}
-		s++;
-	}
-	*d = '\0';
-
-	return(dlen + (s - src));	/* count does not include NUL */
-}
-#endif
diff --git a/libedit/strlcpy.c b/libedit/strlcpy.c
deleted file mode 100644
index cd72ff8..0000000
--- a/libedit/strlcpy.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*	$NetBSD: strlcpy.c,v 1.1 2005/12/20 19:28:52 christos Exp $	*/
-/*	$OpenBSD: strlcpy.c,v 1.7 2003/04/12 21:56:39 millert Exp $	*/
-
-/*
- * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
- * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
- * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#include "sys.h"
-
-#if defined(LIBC_SCCS) && !defined(lint)
-__RCSID("$NetBSD: strlcpy.c,v 1.1 2005/12/20 19:28:52 christos Exp $");
-#endif /* LIBC_SCCS and not lint */
-
-#include <sys/types.h>
-#include <assert.h>
-#include <string.h>
-
-#ifdef _LIBC
-# ifdef __weak_alias
-__weak_alias(strlcpy, _strlcpy)
-# endif
-#endif
-
-#if !HAVE_STRLCPY
-/*
- * Copy src to string dst of size siz.  At most siz-1 characters
- * will be copied.  Always NUL terminates (unless siz == 0).
- * Returns strlen(src); if retval >= siz, truncation occurred.
- */
-size_t
-#ifdef _LIBC
-_strlcpy(dst, src, siz)
-#else
-strlcpy(dst, src, siz)
-#endif
-	char *dst;
-	const char *src;
-	size_t siz;
-{
-	char *d = dst;
-	const char *s = src;
-	size_t n = siz;
-
-	_DIAGASSERT(dst != NULL);
-	_DIAGASSERT(src != NULL);
-
-	/* Copy as many bytes as will fit */
-	if (n != 0 && --n != 0) {
-		do {
-			if ((*d++ = *s++) == 0)
-				break;
-		} while (--n != 0);
-	}
-
-	/* Not enough room in dst, add NUL and traverse rest of src */
-	if (n == 0) {
-		if (siz != 0)
-			*d = '\0';		/* NUL-terminate dst */
-		while (*s++)
-			;
-	}
-
-	return(s - src - 1);	/* count does not include NUL */
-}
-#endif
diff --git a/libedit/sys.h b/libedit/sys.h
deleted file mode 100644
index 8e33aeb..0000000
--- a/libedit/sys.h
+++ /dev/null
@@ -1,157 +0,0 @@
-/*	$NetBSD: sys.h,v 1.9 2004/01/17 17:57:40 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)sys.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * sys.h: Put all the stupid compiler and system dependencies here...
- */
-#ifndef _h_sys
-#define	_h_sys
-
-#include <config.h>
-
-#ifdef HAVE_SYS_CDEFS_H
-#include <sys/cdefs.h>
-#endif
-
-#if !defined(__attribute__) && (defined(__cplusplus) || !defined(__GNUC__)  || __GNUC__ == 2 && __GNUC_MINOR__ < 8)
-# define __attribute__(A)
-#endif
-
-#ifndef __P
-# define __P(x) x
-#endif
-
-#ifndef _DIAGASSERT
-# define _DIAGASSERT(x)
-#endif
-
-#ifndef __BEGIN_DECLS
-# ifdef  __cplusplus
-#  define __BEGIN_DECLS  extern "C" {
-#  define __END_DECLS    }
-# else
-#  define __BEGIN_DECLS
-#  define __END_DECLS
-# endif
-#endif
- 
-#ifndef public
-# define public		/* Externally visible functions/variables */
-#endif
-
-#ifndef private
-# define private	static	/* Always hidden internals */
-#endif
-
-#ifndef protected
-# define protected	/* Redefined from elsewhere to "static" */
-			/* When we want to hide everything	*/
-#endif
-
-#ifndef HAVE_U_INT32_T
-typedef unsigned int  u_int32_t;
-#endif
-
-#ifndef _PTR_T
-# define _PTR_T
-typedef void	*ptr_t;
-#endif
-
-#ifndef _IOCTL_T
-# define _IOCTL_T
-typedef void	*ioctl_t;
-#endif
-
-#include <stdio.h>
-
-#ifndef HAVE_STRLCAT
-#define	strlcat libedit_strlcat
-size_t	strlcat(char *dst, const char *src, size_t size);
-#endif
-
-#ifndef HAVE_STRLCPY
-#define	strlcpy libedit_strlcpy
-size_t	strlcpy(char *dst, const char *src, size_t size);
-#endif
-
-#ifndef HAVE_FGETLN
-#define	fgetln libedit_fgetln
-char	*fgetln(FILE *fp, size_t *len);
-#endif
-
-#define	REGEX		/* Use POSIX.2 regular expression functions */
-#undef	REGEXP		/* Use UNIX V8 regular expression functions */
-
-#ifdef notdef
-# undef REGEX
-# undef REGEXP
-# include <malloc.h>
-# ifdef __GNUC__
-/*
- * Broken hdrs.
- */
-extern int	tgetent(const char *bp, char *name);
-extern int	tgetflag(const char *id);
-extern int	tgetnum(const char *id);
-extern char    *tgetstr(const char *id, char **area);
-extern char    *tgoto(const char *cap, int col, int row);
-extern int	tputs(const char *str, int affcnt, int (*putc)(int));
-extern char    *getenv(const char *);
-extern int	fprintf(FILE *, const char *, ...);
-extern int	sigsetmask(int);
-extern int	sigblock(int);
-extern int	fputc(int, FILE *);
-extern int	fgetc(FILE *);
-extern int	fflush(FILE *);
-extern int	tolower(int);
-extern int	toupper(int);
-extern int	errno, sys_nerr;
-extern char	*sys_errlist[];
-extern void	perror(const char *);
-#  include <string.h>
-#  define strerror(e)	sys_errlist[e]
-# endif
-# ifdef SABER
-extern ptr_t    memcpy(ptr_t, const ptr_t, size_t);
-extern ptr_t    memset(ptr_t, int, size_t);
-# endif
-extern char    *fgetline(FILE *, int *);
-#endif
-
-#define SCCSID
-#undef LIBC_SCCS
-
-#endif /* _h_sys */
diff --git a/libedit/term.c b/libedit/term.c
deleted file mode 100644
index bf10f69..0000000
--- a/libedit/term.c
+++ /dev/null
@@ -1,1593 +0,0 @@
-/*	$NetBSD: term.c,v 1.41 2005/08/08 14:05:37 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)term.c	8.2 (Berkeley) 4/30/95";
-#else
-__RCSID("$NetBSD: term.c,v 1.41 2005/08/08 14:05:37 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * term.c: Editor/termcap-curses interface
- *	   We have to declare a static variable here, since the
- *	   termcap putchar routine does not take an argument!
- */
-#include <stdio.h>
-#include <signal.h>
-#include <string.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-#ifdef HAVE_CURSES_H
-# include <curses.h>
-#elif HAVE_NCURSES_H
-# include <ncurses.h>
-#endif
-
-/* Solaris's term.h does horrid things. */
-#if (defined(HAVE_TERM_H) && !defined(_SUNOS))
-# include <term.h>
-#endif
-
-#include <sys/types.h>
-#include <sys/ioctl.h>
-
-#include "el.h"
-
-/*
- * IMPORTANT NOTE: these routines are allowed to look at the current screen
- * and the current possition assuming that it is correct.  If this is not
- * true, then the update will be WRONG!  This is (should be) a valid
- * assumption...
- */
-
-#define	TC_BUFSIZE	2048
-
-#define	GoodStr(a)	(el->el_term.t_str[a] != NULL && \
-			    el->el_term.t_str[a][0] != '\0')
-#define	Str(a)		el->el_term.t_str[a]
-#define	Val(a)		el->el_term.t_val[a]
-
-#ifdef notdef
-private const struct {
-	const char *b_name;
-	int b_rate;
-} baud_rate[] = {
-#ifdef B0
-	{ "0", B0 },
-#endif
-#ifdef B50
-	{ "50", B50 },
-#endif
-#ifdef B75
-	{ "75", B75 },
-#endif
-#ifdef B110
-	{ "110", B110 },
-#endif
-#ifdef B134
-	{ "134", B134 },
-#endif
-#ifdef B150
-	{ "150", B150 },
-#endif
-#ifdef B200
-	{ "200", B200 },
-#endif
-#ifdef B300
-	{ "300", B300 },
-#endif
-#ifdef B600
-	{ "600", B600 },
-#endif
-#ifdef B900
-	{ "900", B900 },
-#endif
-#ifdef B1200
-	{ "1200", B1200 },
-#endif
-#ifdef B1800
-	{ "1800", B1800 },
-#endif
-#ifdef B2400
-	{ "2400", B2400 },
-#endif
-#ifdef B3600
-	{ "3600", B3600 },
-#endif
-#ifdef B4800
-	{ "4800", B4800 },
-#endif
-#ifdef B7200
-	{ "7200", B7200 },
-#endif
-#ifdef B9600
-	{ "9600", B9600 },
-#endif
-#ifdef EXTA
-	{ "19200", EXTA },
-#endif
-#ifdef B19200
-	{ "19200", B19200 },
-#endif
-#ifdef EXTB
-	{ "38400", EXTB },
-#endif
-#ifdef B38400
-	{ "38400", B38400 },
-#endif
-	{ NULL, 0 }
-};
-#endif
-
-private const struct termcapstr {
-	const char *name;
-	const char *long_name;
-} tstr[] = {
-#define	T_al	0
-	{ "al", "add new blank line" },
-#define	T_bl	1
-	{ "bl", "audible bell" },
-#define	T_cd	2
-	{ "cd", "clear to bottom" },
-#define	T_ce	3
-	{ "ce", "clear to end of line" },
-#define	T_ch	4
-	{ "ch", "cursor to horiz pos" },
-#define	T_cl	5
-	{ "cl", "clear screen" },
-#define	T_dc	6
-	{ "dc", "delete a character" },
-#define	T_dl	7
-	{ "dl", "delete a line" },
-#define	T_dm	8
-	{ "dm", "start delete mode" },
-#define	T_ed	9
-	{ "ed", "end delete mode" },
-#define	T_ei	10
-	{ "ei", "end insert mode" },
-#define	T_fs	11
-	{ "fs", "cursor from status line" },
-#define	T_ho	12
-	{ "ho", "home cursor" },
-#define	T_ic	13
-	{ "ic", "insert character" },
-#define	T_im	14
-	{ "im", "start insert mode" },
-#define	T_ip	15
-	{ "ip", "insert padding" },
-#define	T_kd	16
-	{ "kd", "sends cursor down" },
-#define	T_kl	17
-	{ "kl", "sends cursor left" },
-#define	T_kr	18
-	{ "kr", "sends cursor right" },
-#define	T_ku	19
-	{ "ku", "sends cursor up" },
-#define	T_md	20
-	{ "md", "begin bold" },
-#define	T_me	21
-	{ "me", "end attributes" },
-#define	T_nd	22
-	{ "nd", "non destructive space" },
-#define	T_se	23
-	{ "se", "end standout" },
-#define	T_so	24
-	{ "so", "begin standout" },
-#define	T_ts	25
-	{ "ts", "cursor to status line" },
-#define	T_up	26
-	{ "up", "cursor up one" },
-#define	T_us	27
-	{ "us", "begin underline" },
-#define	T_ue	28
-	{ "ue", "end underline" },
-#define	T_vb	29
-	{ "vb", "visible bell" },
-#define	T_DC	30
-	{ "DC", "delete multiple chars" },
-#define	T_DO	31
-	{ "DO", "cursor down multiple" },
-#define	T_IC	32
-	{ "IC", "insert multiple chars" },
-#define	T_LE	33
-	{ "LE", "cursor left multiple" },
-#define	T_RI	34
-	{ "RI", "cursor right multiple" },
-#define	T_UP	35
-	{ "UP", "cursor up multiple" },
-#define	T_kh	36
-	{ "kh", "send cursor home" },
-#define	T_at7	37
-	{ "@7", "send cursor end" },
-#define	T_str	38
-	{ NULL, NULL }
-};
-
-private const struct termcapval {
-	const char *name;
-	const char *long_name;
-} tval[] = {
-#define	T_am	0
-	{ "am", "has automatic margins" },
-#define	T_pt	1
-	{ "pt", "has physical tabs" },
-#define	T_li	2
-	{ "li", "Number of lines" },
-#define	T_co	3
-	{ "co", "Number of columns" },
-#define	T_km	4
-	{ "km", "Has meta key" },
-#define	T_xt	5
-	{ "xt", "Tab chars destructive" },
-#define	T_xn	6
-	{ "xn", "newline ignored at right margin" },
-#define	T_MT	7
-	{ "MT", "Has meta key" },			/* XXX? */
-#define	T_val	8
-	{ NULL, NULL, }
-};
-/* do two or more of the attributes use me */
-
-private void	term_setflags(EditLine *);
-private int	term_rebuffer_display(EditLine *);
-private void	term_free_display(EditLine *);
-private int	term_alloc_display(EditLine *);
-private void	term_alloc(EditLine *, const struct termcapstr *, const char *);
-private void	term_init_arrow(EditLine *);
-private void	term_reset_arrow(EditLine *);
-
-
-private FILE *term_outfile = NULL;	/* XXX: How do we fix that? */
-
-
-/* term_setflags():
- *	Set the terminal capability flags
- */
-private void
-term_setflags(EditLine *el)
-{
-	EL_FLAGS = 0;
-	if (el->el_tty.t_tabs)
-		EL_FLAGS |= (Val(T_pt) && !Val(T_xt)) ? TERM_CAN_TAB : 0;
-
-	EL_FLAGS |= (Val(T_km) || Val(T_MT)) ? TERM_HAS_META : 0;
-	EL_FLAGS |= GoodStr(T_ce) ? TERM_CAN_CEOL : 0;
-	EL_FLAGS |= (GoodStr(T_dc) || GoodStr(T_DC)) ? TERM_CAN_DELETE : 0;
-	EL_FLAGS |= (GoodStr(T_im) || GoodStr(T_ic) || GoodStr(T_IC)) ?
-	    TERM_CAN_INSERT : 0;
-	EL_FLAGS |= (GoodStr(T_up) || GoodStr(T_UP)) ? TERM_CAN_UP : 0;
-	EL_FLAGS |= Val(T_am) ? TERM_HAS_AUTO_MARGINS : 0;
-	EL_FLAGS |= Val(T_xn) ? TERM_HAS_MAGIC_MARGINS : 0;
-
-	if (GoodStr(T_me) && GoodStr(T_ue))
-		EL_FLAGS |= (strcmp(Str(T_me), Str(T_ue)) == 0) ?
-		    TERM_CAN_ME : 0;
-	else
-		EL_FLAGS &= ~TERM_CAN_ME;
-	if (GoodStr(T_me) && GoodStr(T_se))
-		EL_FLAGS |= (strcmp(Str(T_me), Str(T_se)) == 0) ?
-		    TERM_CAN_ME : 0;
-
-
-#ifdef DEBUG_SCREEN
-	if (!EL_CAN_UP) {
-		(void) fprintf(el->el_errfile,
-		    "WARNING: Your terminal cannot move up.\n");
-		(void) fprintf(el->el_errfile,
-		    "Editing may be odd for long lines.\n");
-	}
-	if (!EL_CAN_CEOL)
-		(void) fprintf(el->el_errfile, "no clear EOL capability.\n");
-	if (!EL_CAN_DELETE)
-		(void) fprintf(el->el_errfile, "no delete char capability.\n");
-	if (!EL_CAN_INSERT)
-		(void) fprintf(el->el_errfile, "no insert char capability.\n");
-#endif /* DEBUG_SCREEN */
-}
-
-
-/* term_init():
- *	Initialize the terminal stuff
- */
-protected int
-term_init(EditLine *el)
-{
-
-	el->el_term.t_buf = (char *) el_malloc(TC_BUFSIZE);
-	if (el->el_term.t_buf == NULL)
-		return (-1);
-	el->el_term.t_cap = (char *) el_malloc(TC_BUFSIZE);
-	if (el->el_term.t_cap == NULL)
-		return (-1);
-	el->el_term.t_fkey = (fkey_t *) el_malloc(A_K_NKEYS * sizeof(fkey_t));
-	if (el->el_term.t_fkey == NULL)
-		return (-1);
-	el->el_term.t_loc = 0;
-	el->el_term.t_str = (char **) el_malloc(T_str * sizeof(char *));
-	if (el->el_term.t_str == NULL)
-		return (-1);
-	(void) memset(el->el_term.t_str, 0, T_str * sizeof(char *));
-	el->el_term.t_val = (int *) el_malloc(T_val * sizeof(int));
-	if (el->el_term.t_val == NULL)
-		return (-1);
-	(void) memset(el->el_term.t_val, 0, T_val * sizeof(int));
-	term_outfile = el->el_outfile;
-	(void) term_set(el, NULL);
-	term_init_arrow(el);
-	return (0);
-}
-
-/* term_end():
- *	Clean up the terminal stuff
- */
-protected void
-term_end(EditLine *el)
-{
-
-	el_free((ptr_t) el->el_term.t_buf);
-	el->el_term.t_buf = NULL;
-	el_free((ptr_t) el->el_term.t_cap);
-	el->el_term.t_cap = NULL;
-	el->el_term.t_loc = 0;
-	el_free((ptr_t) el->el_term.t_str);
-	el->el_term.t_str = NULL;
-	el_free((ptr_t) el->el_term.t_val);
-	el->el_term.t_val = NULL;
-	el_free((ptr_t) el->el_term.t_fkey);
-	el->el_term.t_fkey = NULL;
-	term_free_display(el);
-}
-
-
-/* term_alloc():
- *	Maintain a string pool for termcap strings
- */
-private void
-term_alloc(EditLine *el, const struct termcapstr *t, const char *cap)
-{
-	char termbuf[TC_BUFSIZE];
-	int tlen, clen;
-	char **tlist = el->el_term.t_str;
-	char **tmp, **str = &tlist[t - tstr];
-
-	if (cap == NULL || *cap == '\0') {
-		*str = NULL;
-		return;
-	} else
-		clen = strlen(cap);
-
-	tlen = *str == NULL ? 0 : strlen(*str);
-
-	/*
-         * New string is shorter; no need to allocate space
-         */
-	if (clen <= tlen) {
-		(void) strcpy(*str, cap);	/* XXX strcpy is safe */
-		return;
-	}
-	/*
-         * New string is longer; see if we have enough space to append
-         */
-	if (el->el_term.t_loc + 3 < TC_BUFSIZE) {
-						/* XXX strcpy is safe */
-		(void) strcpy(*str = &el->el_term.t_buf[el->el_term.t_loc],
-		    cap);
-		el->el_term.t_loc += clen + 1;	/* one for \0 */
-		return;
-	}
-	/*
-         * Compact our buffer; no need to check compaction, cause we know it
-         * fits...
-         */
-	tlen = 0;
-	for (tmp = tlist; tmp < &tlist[T_str]; tmp++)
-		if (*tmp != NULL && *tmp != '\0' && *tmp != *str) {
-			char *ptr;
-
-			for (ptr = *tmp; *ptr != '\0'; termbuf[tlen++] = *ptr++)
-				continue;
-			termbuf[tlen++] = '\0';
-		}
-	memcpy(el->el_term.t_buf, termbuf, TC_BUFSIZE);
-	el->el_term.t_loc = tlen;
-	if (el->el_term.t_loc + 3 >= TC_BUFSIZE) {
-		(void) fprintf(el->el_errfile,
-		    "Out of termcap string space.\n");
-		return;
-	}
-					/* XXX strcpy is safe */
-	(void) strcpy(*str = &el->el_term.t_buf[el->el_term.t_loc], cap);
-	el->el_term.t_loc += clen + 1;	/* one for \0 */
-	return;
-}
-
-
-/* term_rebuffer_display():
- *	Rebuffer the display after the screen changed size
- */
-private int
-term_rebuffer_display(EditLine *el)
-{
-	coord_t *c = &el->el_term.t_size;
-
-	term_free_display(el);
-
-	c->h = Val(T_co);
-	c->v = Val(T_li);
-
-	if (term_alloc_display(el) == -1)
-		return (-1);
-	return (0);
-}
-
-
-/* term_alloc_display():
- *	Allocate a new display.
- */
-private int
-term_alloc_display(EditLine *el)
-{
-	int i;
-	char **b;
-	coord_t *c = &el->el_term.t_size;
-
-	b = (char **) el_malloc((size_t) (sizeof(char *) * (c->v + 1)));
-	if (b == NULL)
-		return (-1);
-	for (i = 0; i < c->v; i++) {
-		b[i] = (char *) el_malloc((size_t) (sizeof(char) * (c->h + 1)));
-		if (b[i] == NULL)
-			return (-1);
-	}
-	b[c->v] = NULL;
-	el->el_display = b;
-
-	b = (char **) el_malloc((size_t) (sizeof(char *) * (c->v + 1)));
-	if (b == NULL)
-		return (-1);
-	for (i = 0; i < c->v; i++) {
-		b[i] = (char *) el_malloc((size_t) (sizeof(char) * (c->h + 1)));
-		if (b[i] == NULL)
-			return (-1);
-	}
-	b[c->v] = NULL;
-	el->el_vdisplay = b;
-	return (0);
-}
-
-
-/* term_free_display():
- *	Free the display buffers
- */
-private void
-term_free_display(EditLine *el)
-{
-	char **b;
-	char **bufp;
-
-	b = el->el_display;
-	el->el_display = NULL;
-	if (b != NULL) {
-		for (bufp = b; *bufp != NULL; bufp++)
-			el_free((ptr_t) * bufp);
-		el_free((ptr_t) b);
-	}
-	b = el->el_vdisplay;
-	el->el_vdisplay = NULL;
-	if (b != NULL) {
-		for (bufp = b; *bufp != NULL; bufp++)
-			el_free((ptr_t) * bufp);
-		el_free((ptr_t) b);
-	}
-}
-
-
-/* term_move_to_line():
- *	move to line <where> (first line == 0)
- * 	as efficiently as possible
- */
-protected void
-term_move_to_line(EditLine *el, int where)
-{
-	int del;
-
-	if (where == el->el_cursor.v)
-		return;
-
-	if (where > el->el_term.t_size.v) {
-#ifdef DEBUG_SCREEN
-		(void) fprintf(el->el_errfile,
-		    "term_move_to_line: where is ridiculous: %d\r\n", where);
-#endif /* DEBUG_SCREEN */
-		return;
-	}
-	if ((del = where - el->el_cursor.v) > 0) {
-		while (del > 0) {
-			if (EL_HAS_AUTO_MARGINS &&
-			    el->el_display[el->el_cursor.v][0] != '\0') {
-				/* move without newline */
-				term_move_to_char(el, el->el_term.t_size.h - 1);
-				term_overwrite(el,
-				    &el->el_display[el->el_cursor.v][el->el_cursor.h],
-				    1);
-				/* updates Cursor */
-				del--;
-			} else {
-				if ((del > 1) && GoodStr(T_DO)) {
-					(void) tputs(tgoto(Str(T_DO), del, del),
-					    del, term__putc);
-					del = 0;
-				} else {
-					for (; del > 0; del--)
-						term__putc('\n');
-					/* because the \n will become \r\n */
-					el->el_cursor.h = 0;
-				}
-			}
-		}
-	} else {		/* del < 0 */
-		if (GoodStr(T_UP) && (-del > 1 || !GoodStr(T_up)))
-			(void) tputs(tgoto(Str(T_UP), -del, -del), -del,
-			    term__putc);
-		else {
-			if (GoodStr(T_up))
-				for (; del < 0; del++)
-					(void) tputs(Str(T_up), 1, term__putc);
-		}
-	}
-	el->el_cursor.v = where;/* now where is here */
-}
-
-
-/* term_move_to_char():
- *	Move to the character position specified
- */
-protected void
-term_move_to_char(EditLine *el, int where)
-{
-	int del, i;
-
-mc_again:
-	if (where == el->el_cursor.h)
-		return;
-
-	if (where > el->el_term.t_size.h) {
-#ifdef DEBUG_SCREEN
-		(void) fprintf(el->el_errfile,
-		    "term_move_to_char: where is riduculous: %d\r\n", where);
-#endif /* DEBUG_SCREEN */
-		return;
-	}
-	if (!where) {		/* if where is first column */
-		term__putc('\r');	/* do a CR */
-		el->el_cursor.h = 0;
-		return;
-	}
-	del = where - el->el_cursor.h;
-
-	if ((del < -4 || del > 4) && GoodStr(T_ch))
-		/* go there directly */
-		(void) tputs(tgoto(Str(T_ch), where, where), where, term__putc);
-	else {
-		if (del > 0) {	/* moving forward */
-			if ((del > 4) && GoodStr(T_RI))
-				(void) tputs(tgoto(Str(T_RI), del, del),
-				    del, term__putc);
-			else {
-					/* if I can do tabs, use them */
-				if (EL_CAN_TAB) {
-					if ((el->el_cursor.h & 0370) !=
-					    (where & 0370)) {
-						/* if not within tab stop */
-						for (i =
-						    (el->el_cursor.h & 0370);
-						    i < (where & 0370);
-						    i += 8)
-							term__putc('\t');	
-							/* then tab over */
-						el->el_cursor.h = where & 0370;
-					}
-				}
-				/*
-				 * it's usually cheaper to just write the
-				 * chars, so we do.
-				 */
-				/*
-				 * NOTE THAT term_overwrite() WILL CHANGE
-				 * el->el_cursor.h!!!
-				 */
-				term_overwrite(el,
-				    &el->el_display[el->el_cursor.v][el->el_cursor.h],
-				    where - el->el_cursor.h);
-
-			}
-		} else {	/* del < 0 := moving backward */
-			if ((-del > 4) && GoodStr(T_LE))
-				(void) tputs(tgoto(Str(T_LE), -del, -del),
-				    -del, term__putc);
-			else {	/* can't go directly there */
-				/*
-				 * if the "cost" is greater than the "cost"
-				 * from col 0
-				 */
-				if (EL_CAN_TAB ?
-				    ((unsigned int)-del >
-				    (((unsigned int) where >> 3) +
-				     (where & 07)))
-				    : (-del > where)) {
-					term__putc('\r');	/* do a CR */
-					el->el_cursor.h = 0;
-					goto mc_again;	/* and try again */
-				}
-				for (i = 0; i < -del; i++)
-					term__putc('\b');
-			}
-		}
-	}
-	el->el_cursor.h = where;		/* now where is here */
-}
-
-
-/* term_overwrite():
- *	Overstrike num characters
- */
-protected void
-term_overwrite(EditLine *el, const char *cp, int n)
-{
-	if (n <= 0)
-		return;		/* catch bugs */
-
-	if (n > el->el_term.t_size.h) {
-#ifdef DEBUG_SCREEN
-		(void) fprintf(el->el_errfile,
-		    "term_overwrite: n is riduculous: %d\r\n", n);
-#endif /* DEBUG_SCREEN */
-		return;
-	}
-	do {
-		term__putc(*cp++);
-		el->el_cursor.h++;
-	} while (--n);
-
-	if (el->el_cursor.h >= el->el_term.t_size.h) {	/* wrap? */
-		if (EL_HAS_AUTO_MARGINS) {	/* yes */
-			el->el_cursor.h = 0;
-			el->el_cursor.v++;
-			if (EL_HAS_MAGIC_MARGINS) {
-				/* force the wrap to avoid the "magic"
-				 * situation */
-				char c;
-				if ((c = el->el_display[el->el_cursor.v][el->el_cursor.h])
-				    != '\0')
-					term_overwrite(el, &c, 1);
-				else
-					term__putc(' ');
-				el->el_cursor.h = 1;
-			}
-		} else		/* no wrap, but cursor stays on screen */
-			el->el_cursor.h = el->el_term.t_size.h;
-	}
-}
-
-
-/* term_deletechars():
- *	Delete num characters
- */
-protected void
-term_deletechars(EditLine *el, int num)
-{
-	if (num <= 0)
-		return;
-
-	if (!EL_CAN_DELETE) {
-#ifdef DEBUG_EDIT
-		(void) fprintf(el->el_errfile, "   ERROR: cannot delete   \n");
-#endif /* DEBUG_EDIT */
-		return;
-	}
-	if (num > el->el_term.t_size.h) {
-#ifdef DEBUG_SCREEN
-		(void) fprintf(el->el_errfile,
-		    "term_deletechars: num is riduculous: %d\r\n", num);
-#endif /* DEBUG_SCREEN */
-		return;
-	}
-	if (GoodStr(T_DC))	/* if I have multiple delete */
-		if ((num > 1) || !GoodStr(T_dc)) {	/* if dc would be more
-							 * expen. */
-			(void) tputs(tgoto(Str(T_DC), num, num),
-			    num, term__putc);
-			return;
-		}
-	if (GoodStr(T_dm))	/* if I have delete mode */
-		(void) tputs(Str(T_dm), 1, term__putc);
-
-	if (GoodStr(T_dc))	/* else do one at a time */
-		while (num--)
-			(void) tputs(Str(T_dc), 1, term__putc);
-
-	if (GoodStr(T_ed))	/* if I have delete mode */
-		(void) tputs(Str(T_ed), 1, term__putc);
-}
-
-
-/* term_insertwrite():
- *	Puts terminal in insert character mode or inserts num
- *	characters in the line
- */
-protected void
-term_insertwrite(EditLine *el, char *cp, int num)
-{
-	if (num <= 0)
-		return;
-	if (!EL_CAN_INSERT) {
-#ifdef DEBUG_EDIT
-		(void) fprintf(el->el_errfile, "   ERROR: cannot insert   \n");
-#endif /* DEBUG_EDIT */
-		return;
-	}
-	if (num > el->el_term.t_size.h) {
-#ifdef DEBUG_SCREEN
-		(void) fprintf(el->el_errfile,
-		    "StartInsert: num is riduculous: %d\r\n", num);
-#endif /* DEBUG_SCREEN */
-		return;
-	}
-	if (GoodStr(T_IC))	/* if I have multiple insert */
-		if ((num > 1) || !GoodStr(T_ic)) {
-				/* if ic would be more expensive */
-			(void) tputs(tgoto(Str(T_IC), num, num),
-			    num, term__putc);
-			term_overwrite(el, cp, num);
-				/* this updates el_cursor.h */
-			return;
-		}
-	if (GoodStr(T_im) && GoodStr(T_ei)) {	/* if I have insert mode */
-		(void) tputs(Str(T_im), 1, term__putc);
-
-		el->el_cursor.h += num;
-		do
-			term__putc(*cp++);
-		while (--num);
-
-		if (GoodStr(T_ip))	/* have to make num chars insert */
-			(void) tputs(Str(T_ip), 1, term__putc);
-
-		(void) tputs(Str(T_ei), 1, term__putc);
-		return;
-	}
-	do {
-		if (GoodStr(T_ic))	/* have to make num chars insert */
-			(void) tputs(Str(T_ic), 1, term__putc);
-					/* insert a char */
-
-		term__putc(*cp++);
-
-		el->el_cursor.h++;
-
-		if (GoodStr(T_ip))	/* have to make num chars insert */
-			(void) tputs(Str(T_ip), 1, term__putc);
-					/* pad the inserted char */
-
-	} while (--num);
-}
-
-
-/* term_clear_EOL():
- *	clear to end of line.  There are num characters to clear
- */
-protected void
-term_clear_EOL(EditLine *el, int num)
-{
-	int i;
-
-	if (EL_CAN_CEOL && GoodStr(T_ce))
-		(void) tputs(Str(T_ce), 1, term__putc);
-	else {
-		for (i = 0; i < num; i++)
-			term__putc(' ');
-		el->el_cursor.h += num;	/* have written num spaces */
-	}
-}
-
-
-/* term_clear_screen():
- *	Clear the screen
- */
-protected void
-term_clear_screen(EditLine *el)
-{				/* clear the whole screen and home */
-
-	if (GoodStr(T_cl))
-		/* send the clear screen code */
-		(void) tputs(Str(T_cl), Val(T_li), term__putc);
-	else if (GoodStr(T_ho) && GoodStr(T_cd)) {
-		(void) tputs(Str(T_ho), Val(T_li), term__putc);	/* home */
-		/* clear to bottom of screen */
-		(void) tputs(Str(T_cd), Val(T_li), term__putc);
-	} else {
-		term__putc('\r');
-		term__putc('\n');
-	}
-}
-
-
-/* term_beep():
- *	Beep the way the terminal wants us
- */
-protected void
-term_beep(EditLine *el)
-{
-	if (GoodStr(T_bl))
-		/* what termcap says we should use */
-		(void) tputs(Str(T_bl), 1, term__putc);
-	else
-		term__putc('\007');	/* an ASCII bell; ^G */
-}
-
-
-#ifdef notdef
-/* term_clear_to_bottom():
- *	Clear to the bottom of the screen
- */
-protected void
-term_clear_to_bottom(EditLine *el)
-{
-	if (GoodStr(T_cd))
-		(void) tputs(Str(T_cd), Val(T_li), term__putc);
-	else if (GoodStr(T_ce))
-		(void) tputs(Str(T_ce), Val(T_li), term__putc);
-}
-#endif
-
-protected void
-term_get(EditLine *el, const char **term)
-{
-	*term = el->el_term.t_name;
-}
-
-
-/* term_set():
- *	Read in the terminal capabilities from the requested terminal
- */
-protected int
-term_set(EditLine *el, const char *term)
-{
-	int i;
-	char buf[TC_BUFSIZE];
-	char *area;
-	const struct termcapstr *t;
-	sigset_t oset, nset;
-	int lins, cols;
-
-	(void) sigemptyset(&nset);
-	(void) sigaddset(&nset, SIGWINCH);
-	(void) sigprocmask(SIG_BLOCK, &nset, &oset);
-
-	area = buf;
-
-
-	if (term == NULL)
-		term = getenv("TERM");
-
-	if (!term || !term[0])
-		term = "dumb";
-
-	if (strcmp(term, "emacs") == 0)
-		el->el_flags |= EDIT_DISABLED;
-
-	memset(el->el_term.t_cap, 0, TC_BUFSIZE);
-
-	i = tgetent(el->el_term.t_cap, term);
-
-	if (i <= 0) {
-		if (i == -1)
-			(void) fprintf(el->el_errfile,
-			    "Cannot read termcap database;\n");
-		else if (i == 0)
-			(void) fprintf(el->el_errfile,
-			    "No entry for terminal type \"%s\";\n", term);
-		(void) fprintf(el->el_errfile,
-		    "using dumb terminal settings.\n");
-		Val(T_co) = 80;	/* do a dumb terminal */
-		Val(T_pt) = Val(T_km) = Val(T_li) = 0;
-		Val(T_xt) = Val(T_MT);
-		for (t = tstr; t->name != NULL; t++)
-			term_alloc(el, t, NULL);
-	} else {
-		/* auto/magic margins */
-		Val(T_am) = tgetflag("am");
-		Val(T_xn) = tgetflag("xn");
-		/* Can we tab */
-		Val(T_pt) = tgetflag("pt");
-		Val(T_xt) = tgetflag("xt");
-		/* do we have a meta? */
-		Val(T_km) = tgetflag("km");
-		Val(T_MT) = tgetflag("MT");
-		/* Get the size */
-		Val(T_co) = tgetnum("co");
-		Val(T_li) = tgetnum("li");
-		for (t = tstr; t->name != NULL; t++) {
-			/* XXX: some systems' tgetstr needs non const */
-			term_alloc(el, t, tgetstr(strchr(t->name, *t->name),
-			    &area));
-		}
-	}
-
-	if (Val(T_co) < 2)
-		Val(T_co) = 80;	/* just in case */
-	if (Val(T_li) < 1)
-		Val(T_li) = 24;
-
-	el->el_term.t_size.v = Val(T_co);
-	el->el_term.t_size.h = Val(T_li);
-
-	term_setflags(el);
-
-				/* get the correct window size */
-	(void) term_get_size(el, &lins, &cols);
-	if (term_change_size(el, lins, cols) == -1)
-		return (-1);
-	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
-	term_bind_arrow(el);
-	el->el_term.t_name = term;
-	return (i <= 0 ? -1 : 0);
-}
-
-
-/* term_get_size():
- *	Return the new window size in lines and cols, and
- *	true if the size was changed.
- */
-protected int
-term_get_size(EditLine *el, int *lins, int *cols)
-{
-
-	*cols = Val(T_co);
-	*lins = Val(T_li);
-
-#ifdef TIOCGWINSZ
-	{
-		struct winsize ws;
-		if (ioctl(el->el_infd, TIOCGWINSZ, (ioctl_t) & ws) != -1) {
-			if (ws.ws_col)
-				*cols = ws.ws_col;
-			if (ws.ws_row)
-				*lins = ws.ws_row;
-		}
-	}
-#endif
-#ifdef TIOCGSIZE
-	{
-		struct ttysize ts;
-		if (ioctl(el->el_infd, TIOCGSIZE, (ioctl_t) & ts) != -1) {
-			if (ts.ts_cols)
-				*cols = ts.ts_cols;
-			if (ts.ts_lines)
-				*lins = ts.ts_lines;
-		}
-	}
-#endif
-	return (Val(T_co) != *cols || Val(T_li) != *lins);
-}
-
-
-/* term_change_size():
- *	Change the size of the terminal
- */
-protected int
-term_change_size(EditLine *el, int lins, int cols)
-{
-	/*
-         * Just in case
-         */
-	Val(T_co) = (cols < 2) ? 80 : cols;
-	Val(T_li) = (lins < 1) ? 24 : lins;
-
-	/* re-make display buffers */
-	if (term_rebuffer_display(el) == -1)
-		return (-1);
-	re_clear_display(el);
-	return (0);
-}
-
-
-/* term_init_arrow():
- *	Initialize the arrow key bindings from termcap
- */
-private void
-term_init_arrow(EditLine *el)
-{
-	fkey_t *arrow = el->el_term.t_fkey;
-
-	arrow[A_K_DN].name = "down";
-	arrow[A_K_DN].key = T_kd;
-	arrow[A_K_DN].fun.cmd = ED_NEXT_HISTORY;
-	arrow[A_K_DN].type = XK_CMD;
-
-	arrow[A_K_UP].name = "up";
-	arrow[A_K_UP].key = T_ku;
-	arrow[A_K_UP].fun.cmd = ED_PREV_HISTORY;
-	arrow[A_K_UP].type = XK_CMD;
-
-	arrow[A_K_LT].name = "left";
-	arrow[A_K_LT].key = T_kl;
-	arrow[A_K_LT].fun.cmd = ED_PREV_CHAR;
-	arrow[A_K_LT].type = XK_CMD;
-
-	arrow[A_K_RT].name = "right";
-	arrow[A_K_RT].key = T_kr;
-	arrow[A_K_RT].fun.cmd = ED_NEXT_CHAR;
-	arrow[A_K_RT].type = XK_CMD;
-
-	arrow[A_K_HO].name = "home";
-	arrow[A_K_HO].key = T_kh;
-	arrow[A_K_HO].fun.cmd = ED_MOVE_TO_BEG;
-	arrow[A_K_HO].type = XK_CMD;
-
-	arrow[A_K_EN].name = "end";
-	arrow[A_K_EN].key = T_at7;
-	arrow[A_K_EN].fun.cmd = ED_MOVE_TO_END;
-	arrow[A_K_EN].type = XK_CMD;
-}
-
-
-/* term_reset_arrow():
- *	Reset arrow key bindings
- */
-private void
-term_reset_arrow(EditLine *el)
-{
-	fkey_t *arrow = el->el_term.t_fkey;
-	static const char strA[] = {033, '[', 'A', '\0'};
-	static const char strB[] = {033, '[', 'B', '\0'};
-	static const char strC[] = {033, '[', 'C', '\0'};
-	static const char strD[] = {033, '[', 'D', '\0'};
-	static const char strH[] = {033, '[', 'H', '\0'};
-	static const char strF[] = {033, '[', 'F', '\0'};
-	static const char stOA[] = {033, 'O', 'A', '\0'};
-	static const char stOB[] = {033, 'O', 'B', '\0'};
-	static const char stOC[] = {033, 'O', 'C', '\0'};
-	static const char stOD[] = {033, 'O', 'D', '\0'};
-	static const char stOH[] = {033, 'O', 'H', '\0'};
-	static const char stOF[] = {033, 'O', 'F', '\0'};
-
-	key_add(el, strA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
-	key_add(el, strB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
-	key_add(el, strC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
-	key_add(el, strD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
-	key_add(el, strH, &arrow[A_K_HO].fun, arrow[A_K_HO].type);
-	key_add(el, strF, &arrow[A_K_EN].fun, arrow[A_K_EN].type);
-	key_add(el, stOA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
-	key_add(el, stOB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
-	key_add(el, stOC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
-	key_add(el, stOD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
-	key_add(el, stOH, &arrow[A_K_HO].fun, arrow[A_K_HO].type);
-	key_add(el, stOF, &arrow[A_K_EN].fun, arrow[A_K_EN].type);
-
-	if (el->el_map.type == MAP_VI) {
-		key_add(el, &strA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
-		key_add(el, &strB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
-		key_add(el, &strC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
-		key_add(el, &strD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
-		key_add(el, &strH[1], &arrow[A_K_HO].fun, arrow[A_K_HO].type);
-		key_add(el, &strF[1], &arrow[A_K_EN].fun, arrow[A_K_EN].type);
-		key_add(el, &stOA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
-		key_add(el, &stOB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
-		key_add(el, &stOC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
-		key_add(el, &stOD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
-		key_add(el, &stOH[1], &arrow[A_K_HO].fun, arrow[A_K_HO].type);
-		key_add(el, &stOF[1], &arrow[A_K_EN].fun, arrow[A_K_EN].type);
-	}
-}
-
-
-/* term_set_arrow():
- *	Set an arrow key binding
- */
-protected int
-term_set_arrow(EditLine *el, const char *name, key_value_t *fun, int type)
-{
-	fkey_t *arrow = el->el_term.t_fkey;
-	int i;
-
-	for (i = 0; i < A_K_NKEYS; i++)
-		if (strcmp(name, arrow[i].name) == 0) {
-			arrow[i].fun = *fun;
-			arrow[i].type = type;
-			return (0);
-		}
-	return (-1);
-}
-
-
-/* term_clear_arrow():
- *	Clear an arrow key binding
- */
-protected int
-term_clear_arrow(EditLine *el, const char *name)
-{
-	fkey_t *arrow = el->el_term.t_fkey;
-	int i;
-
-	for (i = 0; i < A_K_NKEYS; i++)
-		if (strcmp(name, arrow[i].name) == 0) {
-			arrow[i].type = XK_NOD;
-			return (0);
-		}
-	return (-1);
-}
-
-
-/* term_print_arrow():
- *	Print the arrow key bindings
- */
-protected void
-term_print_arrow(EditLine *el, const char *name)
-{
-	int i;
-	fkey_t *arrow = el->el_term.t_fkey;
-
-	for (i = 0; i < A_K_NKEYS; i++)
-		if (*name == '\0' || strcmp(name, arrow[i].name) == 0)
-			if (arrow[i].type != XK_NOD)
-				key_kprint(el, arrow[i].name, &arrow[i].fun,
-				    arrow[i].type);
-}
-
-
-/* term_bind_arrow():
- *	Bind the arrow keys
- */
-protected void
-term_bind_arrow(EditLine *el)
-{
-	el_action_t *map;
-	const el_action_t *dmap;
-	int i, j;
-	char *p;
-	fkey_t *arrow = el->el_term.t_fkey;
-
-	/* Check if the components needed are initialized */
-	if (el->el_term.t_buf == NULL || el->el_map.key == NULL)
-		return;
-
-	map = el->el_map.type == MAP_VI ? el->el_map.alt : el->el_map.key;
-	dmap = el->el_map.type == MAP_VI ? el->el_map.vic : el->el_map.emacs;
-
-	term_reset_arrow(el);
-
-	for (i = 0; i < A_K_NKEYS; i++) {
-		p = el->el_term.t_str[arrow[i].key];
-		if (p && *p) {
-			j = (unsigned char) *p;
-			/*
-		         * Assign the arrow keys only if:
-		         *
-		         * 1. They are multi-character arrow keys and the user
-		         *    has not re-assigned the leading character, or
-		         *    has re-assigned the leading character to be
-		         *	  ED_SEQUENCE_LEAD_IN
-		         * 2. They are single arrow keys pointing to an
-			 *    unassigned key.
-		         */
-			if (arrow[i].type == XK_NOD)
-				key_clear(el, map, p);
-			else {
-				if (p[1] && (dmap[j] == map[j] ||
-					map[j] == ED_SEQUENCE_LEAD_IN)) {
-					key_add(el, p, &arrow[i].fun,
-					    arrow[i].type);
-					map[j] = ED_SEQUENCE_LEAD_IN;
-				} else if (map[j] == ED_UNASSIGNED) {
-					key_clear(el, map, p);
-					if (arrow[i].type == XK_CMD)
-						map[j] = arrow[i].fun.cmd;
-					else
-						key_add(el, p, &arrow[i].fun,
-						    arrow[i].type);
-				}
-			}
-		}
-	}
-}
-
-
-/* term__putc():
- *	Add a character
- */
-protected int
-term__putc(int c)
-{
-
-	return (fputc(c, term_outfile));
-}
-
-
-/* term__flush():
- *	Flush output
- */
-protected void
-term__flush(void)
-{
-
-	(void) fflush(term_outfile);
-}
-
-
-/* term_telltc():
- *	Print the current termcap characteristics
- */
-protected int
-/*ARGSUSED*/
-term_telltc(EditLine *el, int argc __attribute__((__unused__)), 
-    const char **argv __attribute__((__unused__)))
-{
-	const struct termcapstr *t;
-	char **ts;
-	char upbuf[EL_BUFSIZ];
-
-	(void) fprintf(el->el_outfile, "\n\tYour terminal has the\n");
-	(void) fprintf(el->el_outfile, "\tfollowing characteristics:\n\n");
-	(void) fprintf(el->el_outfile, "\tIt has %d columns and %d lines\n",
-	    Val(T_co), Val(T_li));
-	(void) fprintf(el->el_outfile,
-	    "\tIt has %s meta key\n", EL_HAS_META ? "a" : "no");
-	(void) fprintf(el->el_outfile,
-	    "\tIt can%suse tabs\n", EL_CAN_TAB ? " " : "not ");
-	(void) fprintf(el->el_outfile, "\tIt %s automatic margins\n",
-	    EL_HAS_AUTO_MARGINS ? "has" : "does not have");
-	if (EL_HAS_AUTO_MARGINS)
-		(void) fprintf(el->el_outfile, "\tIt %s magic margins\n",
-		    EL_HAS_MAGIC_MARGINS ? "has" : "does not have");
-
-	for (t = tstr, ts = el->el_term.t_str; t->name != NULL; t++, ts++)
-		(void) fprintf(el->el_outfile, "\t%25s (%s) == %s\n",
-		    t->long_name,
-		    t->name, *ts && **ts ?
-		    key__decode_str(*ts, upbuf, "") : "(empty)");
-	(void) fputc('\n', el->el_outfile);
-	return (0);
-}
-
-
-/* term_settc():
- *	Change the current terminal characteristics
- */
-protected int
-/*ARGSUSED*/
-term_settc(EditLine *el, int argc __attribute__((__unused__)),
-    const char **argv)
-{
-	const struct termcapstr *ts;
-	const struct termcapval *tv;
-	const char *what, *how;
-
-	if (argv == NULL || argv[1] == NULL || argv[2] == NULL)
-		return (-1);
-
-	what = argv[1];
-	how = argv[2];
-
-	/*
-         * Do the strings first
-         */
-	for (ts = tstr; ts->name != NULL; ts++)
-		if (strcmp(ts->name, what) == 0)
-			break;
-
-	if (ts->name != NULL) {
-		term_alloc(el, ts, how);
-		term_setflags(el);
-		return (0);
-	}
-	/*
-         * Do the numeric ones second
-         */
-	for (tv = tval; tv->name != NULL; tv++)
-		if (strcmp(tv->name, what) == 0)
-			break;
-
-	if (tv->name != NULL) {
-		if (tv == &tval[T_pt] || tv == &tval[T_km] ||
-		    tv == &tval[T_am] || tv == &tval[T_xn]) {
-			if (strcmp(how, "yes") == 0)
-				el->el_term.t_val[tv - tval] = 1;
-			else if (strcmp(how, "no") == 0)
-				el->el_term.t_val[tv - tval] = 0;
-			else {
-				(void) fprintf(el->el_errfile,
-				    "settc: Bad value `%s'.\n", how);
-				return (-1);
-			}
-			term_setflags(el);
-			if (term_change_size(el, Val(T_li), Val(T_co)) == -1)
-				return (-1);
-			return (0);
-		} else {
-			long i;
-			char *ep;
-
-			i = strtol(how, &ep, 10);
-			if (*ep != '\0') {
-				(void) fprintf(el->el_errfile,
-				    "settc: Bad value `%s'.\n", how);
-				return (-1);
-			}
-			el->el_term.t_val[tv - tval] = (int) i;
-			el->el_term.t_size.v = Val(T_co);
-			el->el_term.t_size.h = Val(T_li);
-			if (tv == &tval[T_co] || tv == &tval[T_li])
-				if (term_change_size(el, Val(T_li), Val(T_co))
-				    == -1)
-					return (-1);
-			return (0);
-		}
-	}
-	return (-1);
-}
-
-
-/* term_echotc():
- *	Print the termcap string out with variable substitution
- */
-protected int
-/*ARGSUSED*/
-term_echotc(EditLine *el, int argc __attribute__((__unused__)),
-    const char **argv)
-{
-	char *cap, *scap, *ep;
-	int arg_need, arg_cols, arg_rows;
-	int verbose = 0, silent = 0;
-	char *area;
-	static const char fmts[] = "%s\n", fmtd[] = "%d\n";
-	const struct termcapstr *t;
-	char buf[TC_BUFSIZE];
-	long i;
-
-	area = buf;
-
-	if (argv == NULL || argv[1] == NULL)
-		return (-1);
-	argv++;
-
-	if (argv[0][0] == '-') {
-		switch (argv[0][1]) {
-		case 'v':
-			verbose = 1;
-			break;
-		case 's':
-			silent = 1;
-			break;
-		default:
-			/* stderror(ERR_NAME | ERR_TCUSAGE); */
-			break;
-		}
-		argv++;
-	}
-	if (!*argv || *argv[0] == '\0')
-		return (0);
-	if (strcmp(*argv, "tabs") == 0) {
-		(void) fprintf(el->el_outfile, fmts, EL_CAN_TAB ? "yes" : "no");
-		return (0);
-	} else if (strcmp(*argv, "meta") == 0) {
-		(void) fprintf(el->el_outfile, fmts, Val(T_km) ? "yes" : "no");
-		return (0);
-	} else if (strcmp(*argv, "xn") == 0) {
-		(void) fprintf(el->el_outfile, fmts, EL_HAS_MAGIC_MARGINS ?
-		    "yes" : "no");
-		return (0);
-	} else if (strcmp(*argv, "am") == 0) {
-		(void) fprintf(el->el_outfile, fmts, EL_HAS_AUTO_MARGINS ?
-		    "yes" : "no");
-		return (0);
-	} else if (strcmp(*argv, "baud") == 0) {
-#ifdef notdef
-		int i;
-
-		for (i = 0; baud_rate[i].b_name != NULL; i++)
-			if (el->el_tty.t_speed == baud_rate[i].b_rate) {
-				(void) fprintf(el->el_outfile, fmts,
-				    baud_rate[i].b_name);
-				return (0);
-			}
-		(void) fprintf(el->el_outfile, fmtd, 0);
-#else
-		(void) fprintf(el->el_outfile, fmtd, (int)el->el_tty.t_speed);
-#endif
-		return (0);
-	} else if (strcmp(*argv, "rows") == 0 || strcmp(*argv, "lines") == 0) {
-		(void) fprintf(el->el_outfile, fmtd, Val(T_li));
-		return (0);
-	} else if (strcmp(*argv, "cols") == 0) {
-		(void) fprintf(el->el_outfile, fmtd, Val(T_co));
-		return (0);
-	}
-	/*
-         * Try to use our local definition first
-         */
-	scap = NULL;
-	for (t = tstr; t->name != NULL; t++)
-		if (strcmp(t->name, *argv) == 0) {
-			scap = el->el_term.t_str[t - tstr];
-			break;
-		}
-	if (t->name == NULL) {
-		/* XXX: some systems' tgetstr needs non const */
-		scap = tgetstr(strchr(*argv, **argv), &area);
-	}
-	if (!scap || scap[0] == '\0') {
-		if (!silent)
-			(void) fprintf(el->el_errfile,
-			    "echotc: Termcap parameter `%s' not found.\n",
-			    *argv);
-		return (-1);
-	}
-	/*
-         * Count home many values we need for this capability.
-         */
-	for (cap = scap, arg_need = 0; *cap; cap++)
-		if (*cap == '%')
-			switch (*++cap) {
-			case 'd':
-			case '2':
-			case '3':
-			case '.':
-			case '+':
-				arg_need++;
-				break;
-			case '%':
-			case '>':
-			case 'i':
-			case 'r':
-			case 'n':
-			case 'B':
-			case 'D':
-				break;
-			default:
-				/*
-				 * hpux has lot's of them...
-				 */
-				if (verbose)
-					(void) fprintf(el->el_errfile,
-				"echotc: Warning: unknown termcap %% `%c'.\n",
-					    *cap);
-				/* This is bad, but I won't complain */
-				break;
-			}
-
-	switch (arg_need) {
-	case 0:
-		argv++;
-		if (*argv && *argv[0]) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Extra argument `%s'.\n",
-				    *argv);
-			return (-1);
-		}
-		(void) tputs(scap, 1, term__putc);
-		break;
-	case 1:
-		argv++;
-		if (!*argv || *argv[0] == '\0') {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Missing argument.\n");
-			return (-1);
-		}
-		arg_cols = 0;
-		i = strtol(*argv, &ep, 10);
-		if (*ep != '\0' || i < 0) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Bad value `%s' for rows.\n",
-				    *argv);
-			return (-1);
-		}
-		arg_rows = (int) i;
-		argv++;
-		if (*argv && *argv[0]) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Extra argument `%s'.\n",
-				    *argv);
-			return (-1);
-		}
-		(void) tputs(tgoto(scap, arg_cols, arg_rows), 1, term__putc);
-		break;
-	default:
-		/* This is wrong, but I will ignore it... */
-		if (verbose)
-			(void) fprintf(el->el_errfile,
-			 "echotc: Warning: Too many required arguments (%d).\n",
-			    arg_need);
-		/* FALLTHROUGH */
-	case 2:
-		argv++;
-		if (!*argv || *argv[0] == '\0') {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Missing argument.\n");
-			return (-1);
-		}
-		i = strtol(*argv, &ep, 10);
-		if (*ep != '\0' || i < 0) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Bad value `%s' for cols.\n",
-				    *argv);
-			return (-1);
-		}
-		arg_cols = (int) i;
-		argv++;
-		if (!*argv || *argv[0] == '\0') {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Missing argument.\n");
-			return (-1);
-		}
-		i = strtol(*argv, &ep, 10);
-		if (*ep != '\0' || i < 0) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Bad value `%s' for rows.\n",
-				    *argv);
-			return (-1);
-		}
-		arg_rows = (int) i;
-		if (*ep != '\0') {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Bad value `%s'.\n", *argv);
-			return (-1);
-		}
-		argv++;
-		if (*argv && *argv[0]) {
-			if (!silent)
-				(void) fprintf(el->el_errfile,
-				    "echotc: Warning: Extra argument `%s'.\n",
-				    *argv);
-			return (-1);
-		}
-		(void) tputs(tgoto(scap, arg_cols, arg_rows), arg_rows,
-		    term__putc);
-		break;
-	}
-	return (0);
-}
diff --git a/libedit/tokenizer.c b/libedit/tokenizer.c
deleted file mode 100644
index 72c6813..0000000
--- a/libedit/tokenizer.c
+++ /dev/null
@@ -1,447 +0,0 @@
-/*	$NetBSD: tokenizer.c,v 1.14 2003/12/05 13:37:48 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)tokenizer.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: tokenizer.c,v 1.14 2003/12/05 13:37:48 lukem Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * tokenize.c: Bourne shell like tokenizer
- */
-#include <string.h>
-#include <stdlib.h>
-#include "histedit.h"
-
-typedef enum {
-	Q_none, Q_single, Q_double, Q_one, Q_doubleone
-} quote_t;
-
-#define	IFS		"\t \n"
-
-#define	TOK_KEEP	1
-#define	TOK_EAT		2
-
-#define	WINCR		20
-#define	AINCR		10
-
-#define	tok_strdup(a)		strdup(a)
-#define	tok_malloc(a)		malloc(a)
-#define	tok_free(a)		free(a)
-#define	tok_realloc(a, b)	realloc(a, b)
-
-
-struct tokenizer {
-	char	*ifs;		/* In field separator			 */
-	int	 argc, amax;	/* Current and maximum number of args	 */
-	char   **argv;		/* Argument list			 */
-	char	*wptr, *wmax;	/* Space and limit on the word buffer	 */
-	char	*wstart;	/* Beginning of next word		 */
-	char	*wspace;	/* Space of word buffer			 */
-	quote_t	 quote;		/* Quoting state			 */
-	int	 flags;		/* flags;				 */
-};
-
-
-private void tok_finish(Tokenizer *);
-
-
-/* tok_finish():
- *	Finish a word in the tokenizer.
- */
-private void
-tok_finish(Tokenizer *tok)
-{
-
-	*tok->wptr = '\0';
-	if ((tok->flags & TOK_KEEP) || tok->wptr != tok->wstart) {
-		tok->argv[tok->argc++] = tok->wstart;
-		tok->argv[tok->argc] = NULL;
-		tok->wstart = ++tok->wptr;
-	}
-	tok->flags &= ~TOK_KEEP;
-}
-
-
-/* tok_init():
- *	Initialize the tokenizer
- */
-public Tokenizer *
-tok_init(const char *ifs)
-{
-	Tokenizer *tok = (Tokenizer *) tok_malloc(sizeof(Tokenizer));
-
-	if (tok == NULL)
-		return NULL;
-	tok->ifs = tok_strdup(ifs ? ifs : IFS);
-	if (tok->ifs == NULL) {
-		tok_free((ptr_t)tok);
-		return NULL;
-	}
-	tok->argc = 0;
-	tok->amax = AINCR;
-	tok->argv = (char **) tok_malloc(sizeof(char *) * tok->amax);
-	if (tok->argv == NULL) {
-		tok_free((ptr_t)tok->ifs);
-		tok_free((ptr_t)tok);
-		return NULL;
-	}
-	tok->argv[0] = NULL;
-	tok->wspace = (char *) tok_malloc(WINCR);
-	if (tok->wspace == NULL) {
-		tok_free((ptr_t)tok->argv);
-		tok_free((ptr_t)tok->ifs);
-		tok_free((ptr_t)tok);
-		return NULL;
-	}
-	tok->wmax = tok->wspace + WINCR;
-	tok->wstart = tok->wspace;
-	tok->wptr = tok->wspace;
-	tok->flags = 0;
-	tok->quote = Q_none;
-
-	return (tok);
-}
-
-
-/* tok_reset():
- *	Reset the tokenizer
- */
-public void
-tok_reset(Tokenizer *tok)
-{
-
-	tok->argc = 0;
-	tok->wstart = tok->wspace;
-	tok->wptr = tok->wspace;
-	tok->flags = 0;
-	tok->quote = Q_none;
-}
-
-
-/* tok_end():
- *	Clean up
- */
-public void
-tok_end(Tokenizer *tok)
-{
-
-	tok_free((ptr_t) tok->ifs);
-	tok_free((ptr_t) tok->wspace);
-	tok_free((ptr_t) tok->argv);
-	tok_free((ptr_t) tok);
-}
-
-
-
-/* tok_line():
- *	Bourne shell (sh(1)) like tokenizing
- *	Arguments:
- *		tok	current tokenizer state (setup with tok_init())
- *		line	line to parse
- *	Returns:
- *		-1	Internal error
- *		 3	Quoted return
- *		 2	Unmatched double quote
- *		 1	Unmatched single quote
- *		 0	Ok
- *	Modifies (if return value is 0):
- *		argc	number of arguments
- *		argv	argument array
- *		cursorc	if !NULL, argv element containing cursor
- *		cursorv	if !NULL, offset in argv[cursorc] of cursor
- */
-public int
-tok_line(Tokenizer *tok, const LineInfo *line,
-    int *argc, const char ***argv, int *cursorc, int *cursoro)
-{
-	const char *ptr;
-	int cc, co;
-
-	cc = co = -1;
-	ptr = line->buffer;
-	for (ptr = line->buffer; ;ptr++) {
-		if (ptr >= line->lastchar)
-			ptr = "";
-		if (ptr == line->cursor) {
-			cc = tok->argc;
-			co = tok->wptr - tok->wstart;
-		}
-		switch (*ptr) {
-		case '\'':
-			tok->flags |= TOK_KEEP;
-			tok->flags &= ~TOK_EAT;
-			switch (tok->quote) {
-			case Q_none:
-				tok->quote = Q_single;	/* Enter single quote
-							 * mode */
-				break;
-
-			case Q_single:	/* Exit single quote mode */
-				tok->quote = Q_none;
-				break;
-
-			case Q_one:	/* Quote this ' */
-				tok->quote = Q_none;
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_double:	/* Stay in double quote mode */
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_doubleone:	/* Quote this ' */
-				tok->quote = Q_double;
-				*tok->wptr++ = *ptr;
-				break;
-
-			default:
-				return (-1);
-			}
-			break;
-
-		case '"':
-			tok->flags &= ~TOK_EAT;
-			tok->flags |= TOK_KEEP;
-			switch (tok->quote) {
-			case Q_none:	/* Enter double quote mode */
-				tok->quote = Q_double;
-				break;
-
-			case Q_double:	/* Exit double quote mode */
-				tok->quote = Q_none;
-				break;
-
-			case Q_one:	/* Quote this " */
-				tok->quote = Q_none;
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_single:	/* Stay in single quote mode */
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_doubleone:	/* Quote this " */
-				tok->quote = Q_double;
-				*tok->wptr++ = *ptr;
-				break;
-
-			default:
-				return (-1);
-			}
-			break;
-
-		case '\\':
-			tok->flags |= TOK_KEEP;
-			tok->flags &= ~TOK_EAT;
-			switch (tok->quote) {
-			case Q_none:	/* Quote next character */
-				tok->quote = Q_one;
-				break;
-
-			case Q_double:	/* Quote next character */
-				tok->quote = Q_doubleone;
-				break;
-
-			case Q_one:	/* Quote this, restore state */
-				*tok->wptr++ = *ptr;
-				tok->quote = Q_none;
-				break;
-
-			case Q_single:	/* Stay in single quote mode */
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_doubleone:	/* Quote this \ */
-				tok->quote = Q_double;
-				*tok->wptr++ = *ptr;
-				break;
-
-			default:
-				return (-1);
-			}
-			break;
-
-		case '\n':
-			tok->flags &= ~TOK_EAT;
-			switch (tok->quote) {
-			case Q_none:
-				goto tok_line_outok;
-
-			case Q_single:
-			case Q_double:
-				*tok->wptr++ = *ptr;	/* Add the return */
-				break;
-
-			case Q_doubleone:   /* Back to double, eat the '\n' */
-				tok->flags |= TOK_EAT;
-				tok->quote = Q_double;
-				break;
-
-			case Q_one:	/* No quote, more eat the '\n' */
-				tok->flags |= TOK_EAT;
-				tok->quote = Q_none;
-				break;
-
-			default:
-				return (0);
-			}
-			break;
-
-		case '\0':
-			switch (tok->quote) {
-			case Q_none:
-				/* Finish word and return */
-				if (tok->flags & TOK_EAT) {
-					tok->flags &= ~TOK_EAT;
-					return (3);
-				}
-				goto tok_line_outok;
-
-			case Q_single:
-				return (1);
-
-			case Q_double:
-				return (2);
-
-			case Q_doubleone:
-				tok->quote = Q_double;
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_one:
-				tok->quote = Q_none;
-				*tok->wptr++ = *ptr;
-				break;
-
-			default:
-				return (-1);
-			}
-			break;
-
-		default:
-			tok->flags &= ~TOK_EAT;
-			switch (tok->quote) {
-			case Q_none:
-				if (strchr(tok->ifs, *ptr) != NULL)
-					tok_finish(tok);
-				else
-					*tok->wptr++ = *ptr;
-				break;
-
-			case Q_single:
-			case Q_double:
-				*tok->wptr++ = *ptr;
-				break;
-
-
-			case Q_doubleone:
-				*tok->wptr++ = '\\';
-				tok->quote = Q_double;
-				*tok->wptr++ = *ptr;
-				break;
-
-			case Q_one:
-				tok->quote = Q_none;
-				*tok->wptr++ = *ptr;
-				break;
-
-			default:
-				return (-1);
-
-			}
-			break;
-		}
-
-		if (tok->wptr >= tok->wmax - 4) {
-			size_t size = tok->wmax - tok->wspace + WINCR;
-			char *s = (char *) tok_realloc(tok->wspace, size);
-			if (s == NULL)
-				return (-1);
-
-			if (s != tok->wspace) {
-				int i;
-				for (i = 0; i < tok->argc; i++) {
-				    tok->argv[i] =
-					(tok->argv[i] - tok->wspace) + s;
-				}
-				tok->wptr = (tok->wptr - tok->wspace) + s;
-				tok->wstart = (tok->wstart - tok->wspace) + s;
-				tok->wspace = s;
-			}
-			tok->wmax = s + size;
-		}
-		if (tok->argc >= tok->amax - 4) {
-			char **p;
-			tok->amax += AINCR;
-			p = (char **) tok_realloc(tok->argv,
-			    tok->amax * sizeof(char *));
-			if (p == NULL)
-				return (-1);
-			tok->argv = p;
-		}
-	}
- tok_line_outok:
-	if (cc == -1 && co == -1) {
-		cc = tok->argc;
-		co = tok->wptr - tok->wstart;
-	}
-	if (cursorc != NULL)
-		*cursorc = cc;
-	if (cursoro != NULL)
-		*cursoro = co;
-	tok_finish(tok);
-	*argv = (const char **)tok->argv;
-	*argc = tok->argc;
-	return (0);
-}
-
-/* tok_str():
- *	Simpler version of tok_line, taking a NUL terminated line
- *	and splitting into words, ignoring cursor state.
- */
-public int
-tok_str(Tokenizer *tok, const char *line, int *argc, const char ***argv)
-{
-	LineInfo li;
-
-	memset(&li, 0, sizeof(li));
-	li.buffer = line;
-	li.cursor = li.lastchar = strchr(line, '\0');
-	return (tok_line(tok, &li, argc, argv, NULL, NULL));
-}
diff --git a/libedit/tty.c b/libedit/tty.c
deleted file mode 100644
index 3fe83c4..0000000
--- a/libedit/tty.c
+++ /dev/null
@@ -1,1305 +0,0 @@
-/*	$NetBSD: tty.c,v 1.23 2005/06/01 11:37:52 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)tty.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: tty.c,v 1.23 2005/06/01 11:37:52 lukem Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * tty.c: tty interface stuff
- */
-#include <assert.h>
-#include "tty.h"
-#include "el.h"
-
-typedef struct ttymodes_t {
-	const char *m_name;
-	unsigned int m_value;
-	int m_type;
-}          ttymodes_t;
-
-typedef struct ttymap_t {
-	int nch, och;		/* Internal and termio rep of chars */
-	el_action_t bind[3];	/* emacs, vi, and vi-cmd */
-} ttymap_t;
-
-
-private const ttyperm_t ttyperm = {
-	{
-		{"iflag:", ICRNL, (INLCR | IGNCR)},
-		{"oflag:", (OPOST | ONLCR), ONLRET},
-		{"cflag:", 0, 0},
-		{"lflag:", (ISIG | ICANON | ECHO | ECHOE | ECHOCTL | IEXTEN),
-		(NOFLSH | ECHONL | EXTPROC | FLUSHO)},
-		{"chars:", 0, 0},
-	},
-	{
-		{"iflag:", (INLCR | ICRNL), IGNCR},
-		{"oflag:", (OPOST | ONLCR), ONLRET},
-		{"cflag:", 0, 0},
-		{"lflag:", ISIG,
-		(NOFLSH | ICANON | ECHO | ECHOK | ECHONL | EXTPROC | IEXTEN | FLUSHO)},
-		{"chars:", (C_SH(C_MIN) | C_SH(C_TIME) | C_SH(C_SWTCH) | C_SH(C_DSWTCH) |
-			    C_SH(C_SUSP) | C_SH(C_DSUSP) | C_SH(C_EOL) | C_SH(C_DISCARD) |
-		    C_SH(C_PGOFF) | C_SH(C_PAGE) | C_SH(C_STATUS)), 0}
-	},
-	{
-		{"iflag:", 0, IXON | IXOFF | INLCR | ICRNL},
-		{"oflag:", 0, 0},
-		{"cflag:", 0, 0},
-		{"lflag:", 0, ISIG | IEXTEN},
-		{"chars:", 0, 0},
-	}
-};
-
-private const ttychar_t ttychar = {
-	{
-		CINTR, CQUIT, CERASE, CKILL,
-		CEOF, CEOL, CEOL2, CSWTCH,
-		CDSWTCH, CERASE2, CSTART, CSTOP,
-		CWERASE, CSUSP, CDSUSP, CREPRINT,
-		CDISCARD, CLNEXT, CSTATUS, CPAGE,
-		CPGOFF, CKILL2, CBRK, CMIN,
-		CTIME
-	},
-	{
-		CINTR, CQUIT, CERASE, CKILL,
-		_POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE,
-		_POSIX_VDISABLE, CERASE2, CSTART, CSTOP,
-		_POSIX_VDISABLE, CSUSP, _POSIX_VDISABLE, _POSIX_VDISABLE,
-		CDISCARD, _POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE,
-		_POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE, 1,
-		0
-	},
-	{
-		0, 0, 0, 0,
-		0, 0, 0, 0,
-		0, 0, 0, 0,
-		0, 0, 0, 0,
-		0, 0, 0, 0,
-		0, 0, 0, 0,
-		0
-	}
-};
-
-private const ttymap_t tty_map[] = {
-#ifdef VERASE
-	{C_ERASE, VERASE,
-	{EM_DELETE_PREV_CHAR, VI_DELETE_PREV_CHAR, ED_PREV_CHAR}},
-#endif /* VERASE */
-#ifdef VERASE2
-	{C_ERASE2, VERASE2,
-	{EM_DELETE_PREV_CHAR, VI_DELETE_PREV_CHAR, ED_PREV_CHAR}},
-#endif /* VERASE2 */
-#ifdef VKILL
-	{C_KILL, VKILL,
-	{EM_KILL_LINE, VI_KILL_LINE_PREV, ED_UNASSIGNED}},
-#endif /* VKILL */
-#ifdef VKILL2
-	{C_KILL2, VKILL2,
-	{EM_KILL_LINE, VI_KILL_LINE_PREV, ED_UNASSIGNED}},
-#endif /* VKILL2 */
-#ifdef VEOF
-	{C_EOF, VEOF,
-	{EM_DELETE_OR_LIST, VI_LIST_OR_EOF, ED_UNASSIGNED}},
-#endif /* VEOF */
-#ifdef VWERASE
-	{C_WERASE, VWERASE,
-	{ED_DELETE_PREV_WORD, ED_DELETE_PREV_WORD, ED_PREV_WORD}},
-#endif /* VWERASE */
-#ifdef VREPRINT
-	{C_REPRINT, VREPRINT,
-	{ED_REDISPLAY, ED_INSERT, ED_REDISPLAY}},
-#endif /* VREPRINT */
-#ifdef VLNEXT
-	{C_LNEXT, VLNEXT,
-	{ED_QUOTED_INSERT, ED_QUOTED_INSERT, ED_UNASSIGNED}},
-#endif /* VLNEXT */
-	{-1, -1,
-	{ED_UNASSIGNED, ED_UNASSIGNED, ED_UNASSIGNED}}
-};
-
-private const ttymodes_t ttymodes[] = {
-#ifdef	IGNBRK
-	{"ignbrk", IGNBRK, MD_INP},
-#endif /* IGNBRK */
-#ifdef	BRKINT
-	{"brkint", BRKINT, MD_INP},
-#endif /* BRKINT */
-#ifdef	IGNPAR
-	{"ignpar", IGNPAR, MD_INP},
-#endif /* IGNPAR */
-#ifdef	PARMRK
-	{"parmrk", PARMRK, MD_INP},
-#endif /* PARMRK */
-#ifdef	INPCK
-	{"inpck", INPCK, MD_INP},
-#endif /* INPCK */
-#ifdef	ISTRIP
-	{"istrip", ISTRIP, MD_INP},
-#endif /* ISTRIP */
-#ifdef	INLCR
-	{"inlcr", INLCR, MD_INP},
-#endif /* INLCR */
-#ifdef	IGNCR
-	{"igncr", IGNCR, MD_INP},
-#endif /* IGNCR */
-#ifdef	ICRNL
-	{"icrnl", ICRNL, MD_INP},
-#endif /* ICRNL */
-#ifdef	IUCLC
-	{"iuclc", IUCLC, MD_INP},
-#endif /* IUCLC */
-#ifdef	IXON
-	{"ixon", IXON, MD_INP},
-#endif /* IXON */
-#ifdef	IXANY
-	{"ixany", IXANY, MD_INP},
-#endif /* IXANY */
-#ifdef	IXOFF
-	{"ixoff", IXOFF, MD_INP},
-#endif /* IXOFF */
-#ifdef  IMAXBEL
-	{"imaxbel", IMAXBEL, MD_INP},
-#endif /* IMAXBEL */
-
-#ifdef	OPOST
-	{"opost", OPOST, MD_OUT},
-#endif /* OPOST */
-#ifdef	OLCUC
-	{"olcuc", OLCUC, MD_OUT},
-#endif /* OLCUC */
-#ifdef	ONLCR
-	{"onlcr", ONLCR, MD_OUT},
-#endif /* ONLCR */
-#ifdef	OCRNL
-	{"ocrnl", OCRNL, MD_OUT},
-#endif /* OCRNL */
-#ifdef	ONOCR
-	{"onocr", ONOCR, MD_OUT},
-#endif /* ONOCR */
-#ifdef ONOEOT
-	{"onoeot", ONOEOT, MD_OUT},
-#endif /* ONOEOT */
-#ifdef	ONLRET
-	{"onlret", ONLRET, MD_OUT},
-#endif /* ONLRET */
-#ifdef	OFILL
-	{"ofill", OFILL, MD_OUT},
-#endif /* OFILL */
-#ifdef	OFDEL
-	{"ofdel", OFDEL, MD_OUT},
-#endif /* OFDEL */
-#ifdef	NLDLY
-	{"nldly", NLDLY, MD_OUT},
-#endif /* NLDLY */
-#ifdef	CRDLY
-	{"crdly", CRDLY, MD_OUT},
-#endif /* CRDLY */
-#ifdef	TABDLY
-	{"tabdly", TABDLY, MD_OUT},
-#endif /* TABDLY */
-#ifdef	XTABS
-	{"xtabs", XTABS, MD_OUT},
-#endif /* XTABS */
-#ifdef	BSDLY
-	{"bsdly", BSDLY, MD_OUT},
-#endif /* BSDLY */
-#ifdef	VTDLY
-	{"vtdly", VTDLY, MD_OUT},
-#endif /* VTDLY */
-#ifdef	FFDLY
-	{"ffdly", FFDLY, MD_OUT},
-#endif /* FFDLY */
-#ifdef	PAGEOUT
-	{"pageout", PAGEOUT, MD_OUT},
-#endif /* PAGEOUT */
-#ifdef	WRAP
-	{"wrap", WRAP, MD_OUT},
-#endif /* WRAP */
-
-#ifdef	CIGNORE
-	{"cignore", CIGNORE, MD_CTL},
-#endif /* CBAUD */
-#ifdef	CBAUD
-	{"cbaud", CBAUD, MD_CTL},
-#endif /* CBAUD */
-#ifdef	CSTOPB
-	{"cstopb", CSTOPB, MD_CTL},
-#endif /* CSTOPB */
-#ifdef	CREAD
-	{"cread", CREAD, MD_CTL},
-#endif /* CREAD */
-#ifdef	PARENB
-	{"parenb", PARENB, MD_CTL},
-#endif /* PARENB */
-#ifdef	PARODD
-	{"parodd", PARODD, MD_CTL},
-#endif /* PARODD */
-#ifdef	HUPCL
-	{"hupcl", HUPCL, MD_CTL},
-#endif /* HUPCL */
-#ifdef	CLOCAL
-	{"clocal", CLOCAL, MD_CTL},
-#endif /* CLOCAL */
-#ifdef	LOBLK
-	{"loblk", LOBLK, MD_CTL},
-#endif /* LOBLK */
-#ifdef	CIBAUD
-	{"cibaud", CIBAUD, MD_CTL},
-#endif /* CIBAUD */
-#ifdef CRTSCTS
-#ifdef CCTS_OFLOW
-	{"ccts_oflow", CCTS_OFLOW, MD_CTL},
-#else
-	{"crtscts", CRTSCTS, MD_CTL},
-#endif /* CCTS_OFLOW */
-#endif /* CRTSCTS */
-#ifdef CRTS_IFLOW
-	{"crts_iflow", CRTS_IFLOW, MD_CTL},
-#endif /* CRTS_IFLOW */
-#ifdef CDTRCTS
-	{"cdtrcts", CDTRCTS, MD_CTL},
-#endif /* CDTRCTS */
-#ifdef MDMBUF
-	{"mdmbuf", MDMBUF, MD_CTL},
-#endif /* MDMBUF */
-#ifdef RCV1EN
-	{"rcv1en", RCV1EN, MD_CTL},
-#endif /* RCV1EN */
-#ifdef XMT1EN
-	{"xmt1en", XMT1EN, MD_CTL},
-#endif /* XMT1EN */
-
-#ifdef	ISIG
-	{"isig", ISIG, MD_LIN},
-#endif /* ISIG */
-#ifdef	ICANON
-	{"icanon", ICANON, MD_LIN},
-#endif /* ICANON */
-#ifdef	XCASE
-	{"xcase", XCASE, MD_LIN},
-#endif /* XCASE */
-#ifdef	ECHO
-	{"echo", ECHO, MD_LIN},
-#endif /* ECHO */
-#ifdef	ECHOE
-	{"echoe", ECHOE, MD_LIN},
-#endif /* ECHOE */
-#ifdef	ECHOK
-	{"echok", ECHOK, MD_LIN},
-#endif /* ECHOK */
-#ifdef	ECHONL
-	{"echonl", ECHONL, MD_LIN},
-#endif /* ECHONL */
-#ifdef	NOFLSH
-	{"noflsh", NOFLSH, MD_LIN},
-#endif /* NOFLSH */
-#ifdef	TOSTOP
-	{"tostop", TOSTOP, MD_LIN},
-#endif /* TOSTOP */
-#ifdef	ECHOCTL
-	{"echoctl", ECHOCTL, MD_LIN},
-#endif /* ECHOCTL */
-#ifdef	ECHOPRT
-	{"echoprt", ECHOPRT, MD_LIN},
-#endif /* ECHOPRT */
-#ifdef	ECHOKE
-	{"echoke", ECHOKE, MD_LIN},
-#endif /* ECHOKE */
-#ifdef	DEFECHO
-	{"defecho", DEFECHO, MD_LIN},
-#endif /* DEFECHO */
-#ifdef	FLUSHO
-	{"flusho", FLUSHO, MD_LIN},
-#endif /* FLUSHO */
-#ifdef	PENDIN
-	{"pendin", PENDIN, MD_LIN},
-#endif /* PENDIN */
-#ifdef	IEXTEN
-	{"iexten", IEXTEN, MD_LIN},
-#endif /* IEXTEN */
-#ifdef	NOKERNINFO
-	{"nokerninfo", NOKERNINFO, MD_LIN},
-#endif /* NOKERNINFO */
-#ifdef	ALTWERASE
-	{"altwerase", ALTWERASE, MD_LIN},
-#endif /* ALTWERASE */
-#ifdef	EXTPROC
-	{"extproc", EXTPROC, MD_LIN},
-#endif /* EXTPROC */
-
-#if defined(VINTR)
-	{"intr", C_SH(C_INTR), MD_CHAR},
-#endif /* VINTR */
-#if defined(VQUIT)
-	{"quit", C_SH(C_QUIT), MD_CHAR},
-#endif /* VQUIT */
-#if defined(VERASE)
-	{"erase", C_SH(C_ERASE), MD_CHAR},
-#endif /* VERASE */
-#if defined(VKILL)
-	{"kill", C_SH(C_KILL), MD_CHAR},
-#endif /* VKILL */
-#if defined(VEOF)
-	{"eof", C_SH(C_EOF), MD_CHAR},
-#endif /* VEOF */
-#if defined(VEOL)
-	{"eol", C_SH(C_EOL), MD_CHAR},
-#endif /* VEOL */
-#if defined(VEOL2)
-	{"eol2", C_SH(C_EOL2), MD_CHAR},
-#endif /* VEOL2 */
-#if defined(VSWTCH)
-	{"swtch", C_SH(C_SWTCH), MD_CHAR},
-#endif /* VSWTCH */
-#if defined(VDSWTCH)
-	{"dswtch", C_SH(C_DSWTCH), MD_CHAR},
-#endif /* VDSWTCH */
-#if defined(VERASE2)
-	{"erase2", C_SH(C_ERASE2), MD_CHAR},
-#endif /* VERASE2 */
-#if defined(VSTART)
-	{"start", C_SH(C_START), MD_CHAR},
-#endif /* VSTART */
-#if defined(VSTOP)
-	{"stop", C_SH(C_STOP), MD_CHAR},
-#endif /* VSTOP */
-#if defined(VWERASE)
-	{"werase", C_SH(C_WERASE), MD_CHAR},
-#endif /* VWERASE */
-#if defined(VSUSP)
-	{"susp", C_SH(C_SUSP), MD_CHAR},
-#endif /* VSUSP */
-#if defined(VDSUSP)
-	{"dsusp", C_SH(C_DSUSP), MD_CHAR},
-#endif /* VDSUSP */
-#if defined(VREPRINT)
-	{"reprint", C_SH(C_REPRINT), MD_CHAR},
-#endif /* VREPRINT */
-#if defined(VDISCARD)
-	{"discard", C_SH(C_DISCARD), MD_CHAR},
-#endif /* VDISCARD */
-#if defined(VLNEXT)
-	{"lnext", C_SH(C_LNEXT), MD_CHAR},
-#endif /* VLNEXT */
-#if defined(VSTATUS)
-	{"status", C_SH(C_STATUS), MD_CHAR},
-#endif /* VSTATUS */
-#if defined(VPAGE)
-	{"page", C_SH(C_PAGE), MD_CHAR},
-#endif /* VPAGE */
-#if defined(VPGOFF)
-	{"pgoff", C_SH(C_PGOFF), MD_CHAR},
-#endif /* VPGOFF */
-#if defined(VKILL2)
-	{"kill2", C_SH(C_KILL2), MD_CHAR},
-#endif /* VKILL2 */
-#if defined(VBRK)
-	{"brk", C_SH(C_BRK), MD_CHAR},
-#endif /* VBRK */
-#if defined(VMIN)
-	{"min", C_SH(C_MIN), MD_CHAR},
-#endif /* VMIN */
-#if defined(VTIME)
-	{"time", C_SH(C_TIME), MD_CHAR},
-#endif /* VTIME */
-	{NULL, 0, -1},
-};
-
-
-
-#define	tty_getty(el, td)	tcgetattr((el)->el_infd, (td))
-#define	tty_setty(el, td)	tcsetattr((el)->el_infd, TCSADRAIN, (td))
-
-#define	tty__gettabs(td)	((((td)->c_oflag & TAB3) == TAB3) ? 0 : 1)
-#define	tty__geteightbit(td)	(((td)->c_cflag & CSIZE) == CS8)
-#define	tty__cooked_mode(td)	((td)->c_lflag & ICANON)
-
-private int	tty__getcharindex(int);
-private void	tty__getchar(struct termios *, unsigned char *);
-private void	tty__setchar(struct termios *, unsigned char *);
-private speed_t	tty__getspeed(struct termios *);
-private int	tty_setup(EditLine *);
-
-#define	t_qu	t_ts
-
-
-/* tty_setup():
- *	Get the tty parameters and initialize the editing state
- */
-private int
-tty_setup(EditLine *el)
-{
-	int rst = 1;
-
-	if (el->el_flags & EDIT_DISABLED)
-		return (0);
-
-	if (tty_getty(el, &el->el_tty.t_ed) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile,
-		    "tty_setup: tty_getty: %s\n", strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	el->el_tty.t_ts = el->el_tty.t_ex = el->el_tty.t_ed;
-
-	el->el_tty.t_speed = tty__getspeed(&el->el_tty.t_ex);
-	el->el_tty.t_tabs = tty__gettabs(&el->el_tty.t_ex);
-	el->el_tty.t_eight = tty__geteightbit(&el->el_tty.t_ex);
-
-	el->el_tty.t_ex.c_iflag &= ~el->el_tty.t_t[EX_IO][MD_INP].t_clrmask;
-	el->el_tty.t_ex.c_iflag |= el->el_tty.t_t[EX_IO][MD_INP].t_setmask;
-
-	el->el_tty.t_ex.c_oflag &= ~el->el_tty.t_t[EX_IO][MD_OUT].t_clrmask;
-	el->el_tty.t_ex.c_oflag |= el->el_tty.t_t[EX_IO][MD_OUT].t_setmask;
-
-	el->el_tty.t_ex.c_cflag &= ~el->el_tty.t_t[EX_IO][MD_CTL].t_clrmask;
-	el->el_tty.t_ex.c_cflag |= el->el_tty.t_t[EX_IO][MD_CTL].t_setmask;
-
-	el->el_tty.t_ex.c_lflag &= ~el->el_tty.t_t[EX_IO][MD_LIN].t_clrmask;
-	el->el_tty.t_ex.c_lflag |= el->el_tty.t_t[EX_IO][MD_LIN].t_setmask;
-
-	/*
-         * Reset the tty chars to reasonable defaults
-         * If they are disabled, then enable them.
-         */
-	if (rst) {
-		if (tty__cooked_mode(&el->el_tty.t_ts)) {
-			tty__getchar(&el->el_tty.t_ts, el->el_tty.t_c[TS_IO]);
-			/*
-	                 * Don't affect CMIN and CTIME for the editor mode
-	                 */
-			for (rst = 0; rst < C_NCC - 2; rst++)
-				if (el->el_tty.t_c[TS_IO][rst] !=
-				      el->el_tty.t_vdisable
-				    && el->el_tty.t_c[ED_IO][rst] !=
-				      el->el_tty.t_vdisable)
-					el->el_tty.t_c[ED_IO][rst] =
-					    el->el_tty.t_c[TS_IO][rst];
-			for (rst = 0; rst < C_NCC; rst++)
-				if (el->el_tty.t_c[TS_IO][rst] !=
-				    el->el_tty.t_vdisable)
-					el->el_tty.t_c[EX_IO][rst] =
-					    el->el_tty.t_c[TS_IO][rst];
-		}
-		tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
-		if (tty_setty(el, &el->el_tty.t_ex) == -1) {
-#ifdef DEBUG_TTY
-			(void) fprintf(el->el_errfile,
-			    "tty_setup: tty_setty: %s\n",
-			    strerror(errno));
-#endif /* DEBUG_TTY */
-			return (-1);
-		}
-	} else
-		tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
-
-	el->el_tty.t_ed.c_iflag &= ~el->el_tty.t_t[ED_IO][MD_INP].t_clrmask;
-	el->el_tty.t_ed.c_iflag |= el->el_tty.t_t[ED_IO][MD_INP].t_setmask;
-
-	el->el_tty.t_ed.c_oflag &= ~el->el_tty.t_t[ED_IO][MD_OUT].t_clrmask;
-	el->el_tty.t_ed.c_oflag |= el->el_tty.t_t[ED_IO][MD_OUT].t_setmask;
-
-	el->el_tty.t_ed.c_cflag &= ~el->el_tty.t_t[ED_IO][MD_CTL].t_clrmask;
-	el->el_tty.t_ed.c_cflag |= el->el_tty.t_t[ED_IO][MD_CTL].t_setmask;
-
-	el->el_tty.t_ed.c_lflag &= ~el->el_tty.t_t[ED_IO][MD_LIN].t_clrmask;
-	el->el_tty.t_ed.c_lflag |= el->el_tty.t_t[ED_IO][MD_LIN].t_setmask;
-
-	tty__setchar(&el->el_tty.t_ed, el->el_tty.t_c[ED_IO]);
-	tty_bind_char(el, 1);
-	return (0);
-}
-
-protected int
-tty_init(EditLine *el)
-{
-
-	el->el_tty.t_mode = EX_IO;
-	el->el_tty.t_vdisable = _POSIX_VDISABLE;
-	(void) memcpy(el->el_tty.t_t, ttyperm, sizeof(ttyperm_t));
-	(void) memcpy(el->el_tty.t_c, ttychar, sizeof(ttychar_t));
-	return (tty_setup(el));
-}
-
-
-/* tty_end():
- *	Restore the tty to its original settings
- */
-protected void
-/*ARGSUSED*/
-tty_end(EditLine *el __attribute__((__unused__)))
-{
-
-	/* XXX: Maybe reset to an initial state? */
-}
-
-
-/* tty__getspeed():
- *	Get the tty speed
- */
-private speed_t
-tty__getspeed(struct termios *td)
-{
-	speed_t spd;
-
-	if ((spd = cfgetispeed(td)) == 0)
-		spd = cfgetospeed(td);
-	return (spd);
-}
-
-/* tty__getspeed():
- *	Return the index of the asked char in the c_cc array
- */
-private int
-tty__getcharindex(int i)
-{
-	switch (i) {
-#ifdef VINTR
-	case C_INTR:
-		return VINTR;
-#endif /* VINTR */
-#ifdef VQUIT
-	case C_QUIT:
-		return VQUIT;
-#endif /* VQUIT */
-#ifdef VERASE
-	case C_ERASE:
-		return VERASE;
-#endif /* VERASE */
-#ifdef VKILL
-	case C_KILL:
-		return VKILL;
-#endif /* VKILL */
-#ifdef VEOF
-	case C_EOF:
-		return VEOF;
-#endif /* VEOF */
-#ifdef VEOL
-	case C_EOL:
-		return VEOL;
-#endif /* VEOL */
-#ifdef VEOL2
-	case C_EOL2:
-		return VEOL2;
-#endif /* VEOL2 */
-#ifdef VSWTCH
-	case C_SWTCH:
-		return VSWTCH;
-#endif /* VSWTCH */
-#ifdef VDSWTCH
-	case C_DSWTCH:
-		return VDSWTCH;
-#endif /* VDSWTCH */
-#ifdef VERASE2
-	case C_ERASE2:
-		return VERASE2;
-#endif /* VERASE2 */
-#ifdef VSTART
-	case C_START:
-		return VSTART;
-#endif /* VSTART */
-#ifdef VSTOP
-	case C_STOP:
-		return VSTOP;
-#endif /* VSTOP */
-#ifdef VWERASE
-	case C_WERASE:
-		return VWERASE;
-#endif /* VWERASE */
-#ifdef VSUSP
-	case C_SUSP:
-		return VSUSP;
-#endif /* VSUSP */
-#ifdef VDSUSP
-	case C_DSUSP:
-		return VDSUSP;
-#endif /* VDSUSP */
-#ifdef VREPRINT
-	case C_REPRINT:
-		return VREPRINT;
-#endif /* VREPRINT */
-#ifdef VDISCARD
-	case C_DISCARD:
-		return VDISCARD;
-#endif /* VDISCARD */
-#ifdef VLNEXT
-	case C_LNEXT:
-		return VLNEXT;
-#endif /* VLNEXT */
-#ifdef VSTATUS
-	case C_STATUS:
-		return VSTATUS;
-#endif /* VSTATUS */
-#ifdef VPAGE
-	case C_PAGE:
-		return VPAGE;
-#endif /* VPAGE */
-#ifdef VPGOFF
-	case C_PGOFF:
-		return VPGOFF;
-#endif /* VPGOFF */
-#ifdef VKILL2
-	case C_KILL2:
-		return VKILL2;
-#endif /* KILL2 */
-#ifdef VMIN
-	case C_MIN:
-		return VMIN;
-#endif /* VMIN */
-#ifdef VTIME
-	case C_TIME:
-		return VTIME;
-#endif /* VTIME */
-	default:
-		return -1;
-	}
-}
-
-/* tty__getchar():
- *	Get the tty characters
- */
-private void
-tty__getchar(struct termios *td, unsigned char *s)
-{
-
-#ifdef VINTR
-	s[C_INTR] = td->c_cc[VINTR];
-#endif /* VINTR */
-#ifdef VQUIT
-	s[C_QUIT] = td->c_cc[VQUIT];
-#endif /* VQUIT */
-#ifdef VERASE
-	s[C_ERASE] = td->c_cc[VERASE];
-#endif /* VERASE */
-#ifdef VKILL
-	s[C_KILL] = td->c_cc[VKILL];
-#endif /* VKILL */
-#ifdef VEOF
-	s[C_EOF] = td->c_cc[VEOF];
-#endif /* VEOF */
-#ifdef VEOL
-	s[C_EOL] = td->c_cc[VEOL];
-#endif /* VEOL */
-#ifdef VEOL2
-	s[C_EOL2] = td->c_cc[VEOL2];
-#endif /* VEOL2 */
-#ifdef VSWTCH
-	s[C_SWTCH] = td->c_cc[VSWTCH];
-#endif /* VSWTCH */
-#ifdef VDSWTCH
-	s[C_DSWTCH] = td->c_cc[VDSWTCH];
-#endif /* VDSWTCH */
-#ifdef VERASE2
-	s[C_ERASE2] = td->c_cc[VERASE2];
-#endif /* VERASE2 */
-#ifdef VSTART
-	s[C_START] = td->c_cc[VSTART];
-#endif /* VSTART */
-#ifdef VSTOP
-	s[C_STOP] = td->c_cc[VSTOP];
-#endif /* VSTOP */
-#ifdef VWERASE
-	s[C_WERASE] = td->c_cc[VWERASE];
-#endif /* VWERASE */
-#ifdef VSUSP
-	s[C_SUSP] = td->c_cc[VSUSP];
-#endif /* VSUSP */
-#ifdef VDSUSP
-	s[C_DSUSP] = td->c_cc[VDSUSP];
-#endif /* VDSUSP */
-#ifdef VREPRINT
-	s[C_REPRINT] = td->c_cc[VREPRINT];
-#endif /* VREPRINT */
-#ifdef VDISCARD
-	s[C_DISCARD] = td->c_cc[VDISCARD];
-#endif /* VDISCARD */
-#ifdef VLNEXT
-	s[C_LNEXT] = td->c_cc[VLNEXT];
-#endif /* VLNEXT */
-#ifdef VSTATUS
-	s[C_STATUS] = td->c_cc[VSTATUS];
-#endif /* VSTATUS */
-#ifdef VPAGE
-	s[C_PAGE] = td->c_cc[VPAGE];
-#endif /* VPAGE */
-#ifdef VPGOFF
-	s[C_PGOFF] = td->c_cc[VPGOFF];
-#endif /* VPGOFF */
-#ifdef VKILL2
-	s[C_KILL2] = td->c_cc[VKILL2];
-#endif /* KILL2 */
-#ifdef VMIN
-	s[C_MIN] = td->c_cc[VMIN];
-#endif /* VMIN */
-#ifdef VTIME
-	s[C_TIME] = td->c_cc[VTIME];
-#endif /* VTIME */
-}				/* tty__getchar */
-
-
-/* tty__setchar():
- *	Set the tty characters
- */
-private void
-tty__setchar(struct termios *td, unsigned char *s)
-{
-
-#ifdef VINTR
-	td->c_cc[VINTR] = s[C_INTR];
-#endif /* VINTR */
-#ifdef VQUIT
-	td->c_cc[VQUIT] = s[C_QUIT];
-#endif /* VQUIT */
-#ifdef VERASE
-	td->c_cc[VERASE] = s[C_ERASE];
-#endif /* VERASE */
-#ifdef VKILL
-	td->c_cc[VKILL] = s[C_KILL];
-#endif /* VKILL */
-#ifdef VEOF
-	td->c_cc[VEOF] = s[C_EOF];
-#endif /* VEOF */
-#ifdef VEOL
-	td->c_cc[VEOL] = s[C_EOL];
-#endif /* VEOL */
-#ifdef VEOL2
-	td->c_cc[VEOL2] = s[C_EOL2];
-#endif /* VEOL2 */
-#ifdef VSWTCH
-	td->c_cc[VSWTCH] = s[C_SWTCH];
-#endif /* VSWTCH */
-#ifdef VDSWTCH
-	td->c_cc[VDSWTCH] = s[C_DSWTCH];
-#endif /* VDSWTCH */
-#ifdef VERASE2
-	td->c_cc[VERASE2] = s[C_ERASE2];
-#endif /* VERASE2 */
-#ifdef VSTART
-	td->c_cc[VSTART] = s[C_START];
-#endif /* VSTART */
-#ifdef VSTOP
-	td->c_cc[VSTOP] = s[C_STOP];
-#endif /* VSTOP */
-#ifdef VWERASE
-	td->c_cc[VWERASE] = s[C_WERASE];
-#endif /* VWERASE */
-#ifdef VSUSP
-	td->c_cc[VSUSP] = s[C_SUSP];
-#endif /* VSUSP */
-#ifdef VDSUSP
-	td->c_cc[VDSUSP] = s[C_DSUSP];
-#endif /* VDSUSP */
-#ifdef VREPRINT
-	td->c_cc[VREPRINT] = s[C_REPRINT];
-#endif /* VREPRINT */
-#ifdef VDISCARD
-	td->c_cc[VDISCARD] = s[C_DISCARD];
-#endif /* VDISCARD */
-#ifdef VLNEXT
-	td->c_cc[VLNEXT] = s[C_LNEXT];
-#endif /* VLNEXT */
-#ifdef VSTATUS
-	td->c_cc[VSTATUS] = s[C_STATUS];
-#endif /* VSTATUS */
-#ifdef VPAGE
-	td->c_cc[VPAGE] = s[C_PAGE];
-#endif /* VPAGE */
-#ifdef VPGOFF
-	td->c_cc[VPGOFF] = s[C_PGOFF];
-#endif /* VPGOFF */
-#ifdef VKILL2
-	td->c_cc[VKILL2] = s[C_KILL2];
-#endif /* VKILL2 */
-#ifdef VMIN
-	td->c_cc[VMIN] = s[C_MIN];
-#endif /* VMIN */
-#ifdef VTIME
-	td->c_cc[VTIME] = s[C_TIME];
-#endif /* VTIME */
-}				/* tty__setchar */
-
-
-/* tty_bind_char():
- *	Rebind the editline functions
- */
-protected void
-tty_bind_char(EditLine *el, int force)
-{
-
-	unsigned char *t_n = el->el_tty.t_c[ED_IO];
-	unsigned char *t_o = el->el_tty.t_ed.c_cc;
-	unsigned char new[2], old[2];
-	const ttymap_t *tp;
-	el_action_t *map, *alt;
-	const el_action_t *dmap, *dalt;
-	new[1] = old[1] = '\0';
-
-	map = el->el_map.key;
-	alt = el->el_map.alt;
-	if (el->el_map.type == MAP_VI) {
-		dmap = el->el_map.vii;
-		dalt = el->el_map.vic;
-	} else {
-		dmap = el->el_map.emacs;
-		dalt = NULL;
-	}
-
-	for (tp = tty_map; tp->nch != -1; tp++) {
-		new[0] = t_n[tp->nch];
-		old[0] = t_o[tp->och];
-		if (new[0] == old[0] && !force)
-			continue;
-		/* Put the old default binding back, and set the new binding */
-		key_clear(el, map, (char *)old);
-		map[old[0]] = dmap[old[0]];
-		key_clear(el, map, (char *)new);
-		/* MAP_VI == 1, MAP_EMACS == 0... */
-		map[new[0]] = tp->bind[el->el_map.type];
-		if (dalt) {
-			key_clear(el, alt, (char *)old);
-			alt[old[0]] = dalt[old[0]];
-			key_clear(el, alt, (char *)new);
-			alt[new[0]] = tp->bind[el->el_map.type + 1];
-		}
-	}
-}
-
-
-/* tty_rawmode():
- * 	Set terminal into 1 character at a time mode.
- */
-protected int
-tty_rawmode(EditLine *el)
-{
-
-	if (el->el_tty.t_mode == ED_IO || el->el_tty.t_mode == QU_IO)
-		return (0);
-
-	if (el->el_flags & EDIT_DISABLED)
-		return (0);
-
-	if (tty_getty(el, &el->el_tty.t_ts) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile, "tty_rawmode: tty_getty: %s\n",
-		    strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	/*
-         * We always keep up with the eight bit setting and the speed of the
-         * tty. But only we only believe changes that are made to cooked mode!
-         */
-	el->el_tty.t_eight = tty__geteightbit(&el->el_tty.t_ts);
-	el->el_tty.t_speed = tty__getspeed(&el->el_tty.t_ts);
-
-	if (tty__getspeed(&el->el_tty.t_ex) != el->el_tty.t_speed ||
-	    tty__getspeed(&el->el_tty.t_ed) != el->el_tty.t_speed) {
-		(void) cfsetispeed(&el->el_tty.t_ex, el->el_tty.t_speed);
-		(void) cfsetospeed(&el->el_tty.t_ex, el->el_tty.t_speed);
-		(void) cfsetispeed(&el->el_tty.t_ed, el->el_tty.t_speed);
-		(void) cfsetospeed(&el->el_tty.t_ed, el->el_tty.t_speed);
-	}
-	if (tty__cooked_mode(&el->el_tty.t_ts)) {
-		if (el->el_tty.t_ts.c_cflag != el->el_tty.t_ex.c_cflag) {
-			el->el_tty.t_ex.c_cflag =
-			    el->el_tty.t_ts.c_cflag;
-			el->el_tty.t_ex.c_cflag &=
-			    ~el->el_tty.t_t[EX_IO][MD_CTL].t_clrmask;
-			el->el_tty.t_ex.c_cflag |=
-			    el->el_tty.t_t[EX_IO][MD_CTL].t_setmask;
-
-			el->el_tty.t_ed.c_cflag =
-			    el->el_tty.t_ts.c_cflag;
-			el->el_tty.t_ed.c_cflag &=
-			    ~el->el_tty.t_t[ED_IO][MD_CTL].t_clrmask;
-			el->el_tty.t_ed.c_cflag |=
-			    el->el_tty.t_t[ED_IO][MD_CTL].t_setmask;
-		}
-		if ((el->el_tty.t_ts.c_lflag != el->el_tty.t_ex.c_lflag) &&
-		    (el->el_tty.t_ts.c_lflag != el->el_tty.t_ed.c_lflag)) {
-			el->el_tty.t_ex.c_lflag =
-			    el->el_tty.t_ts.c_lflag;
-			el->el_tty.t_ex.c_lflag &=
-			    ~el->el_tty.t_t[EX_IO][MD_LIN].t_clrmask;
-			el->el_tty.t_ex.c_lflag |=
-			    el->el_tty.t_t[EX_IO][MD_LIN].t_setmask;
-
-			el->el_tty.t_ed.c_lflag =
-			    el->el_tty.t_ts.c_lflag;
-			el->el_tty.t_ed.c_lflag &=
-			    ~el->el_tty.t_t[ED_IO][MD_LIN].t_clrmask;
-			el->el_tty.t_ed.c_lflag |=
-			    el->el_tty.t_t[ED_IO][MD_LIN].t_setmask;
-		}
-		if ((el->el_tty.t_ts.c_iflag != el->el_tty.t_ex.c_iflag) &&
-		    (el->el_tty.t_ts.c_iflag != el->el_tty.t_ed.c_iflag)) {
-			el->el_tty.t_ex.c_iflag =
-			    el->el_tty.t_ts.c_iflag;
-			el->el_tty.t_ex.c_iflag &=
-			    ~el->el_tty.t_t[EX_IO][MD_INP].t_clrmask;
-			el->el_tty.t_ex.c_iflag |=
-			    el->el_tty.t_t[EX_IO][MD_INP].t_setmask;
-
-			el->el_tty.t_ed.c_iflag =
-			    el->el_tty.t_ts.c_iflag;
-			el->el_tty.t_ed.c_iflag &=
-			    ~el->el_tty.t_t[ED_IO][MD_INP].t_clrmask;
-			el->el_tty.t_ed.c_iflag |=
-			    el->el_tty.t_t[ED_IO][MD_INP].t_setmask;
-		}
-		if ((el->el_tty.t_ts.c_oflag != el->el_tty.t_ex.c_oflag) &&
-		    (el->el_tty.t_ts.c_oflag != el->el_tty.t_ed.c_oflag)) {
-			el->el_tty.t_ex.c_oflag =
-			    el->el_tty.t_ts.c_oflag;
-			el->el_tty.t_ex.c_oflag &=
-			    ~el->el_tty.t_t[EX_IO][MD_OUT].t_clrmask;
-			el->el_tty.t_ex.c_oflag |=
-			    el->el_tty.t_t[EX_IO][MD_OUT].t_setmask;
-
-			el->el_tty.t_ed.c_oflag =
-			    el->el_tty.t_ts.c_oflag;
-			el->el_tty.t_ed.c_oflag &=
-			    ~el->el_tty.t_t[ED_IO][MD_OUT].t_clrmask;
-			el->el_tty.t_ed.c_oflag |=
-			    el->el_tty.t_t[ED_IO][MD_OUT].t_setmask;
-		}
-		if (tty__gettabs(&el->el_tty.t_ex) == 0)
-			el->el_tty.t_tabs = 0;
-		else
-			el->el_tty.t_tabs = EL_CAN_TAB ? 1 : 0;
-
-		{
-			int i;
-
-			tty__getchar(&el->el_tty.t_ts, el->el_tty.t_c[TS_IO]);
-			/*
-		         * Check if the user made any changes.
-		         * If he did, then propagate the changes to the
-		         * edit and execute data structures.
-		         */
-			for (i = 0; i < C_NCC; i++)
-				if (el->el_tty.t_c[TS_IO][i] !=
-				    el->el_tty.t_c[EX_IO][i])
-					break;
-
-			if (i != C_NCC) {
-				/*
-				 * Propagate changes only to the unprotected
-				 * chars that have been modified just now.
-				 */
-				for (i = 0; i < C_NCC; i++) {
-					if (!((el->el_tty.t_t[ED_IO][MD_CHAR].t_setmask & C_SH(i)))
-					    && (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i]))
-						el->el_tty.t_c[ED_IO][i] = el->el_tty.t_c[TS_IO][i];
-					if (el->el_tty.t_t[ED_IO][MD_CHAR].t_clrmask & C_SH(i))
-						el->el_tty.t_c[ED_IO][i] = el->el_tty.t_vdisable;
-				}
-				tty_bind_char(el, 0);
-				tty__setchar(&el->el_tty.t_ed, el->el_tty.t_c[ED_IO]);
-
-				for (i = 0; i < C_NCC; i++) {
-					if (!((el->el_tty.t_t[EX_IO][MD_CHAR].t_setmask & C_SH(i)))
-					    && (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i]))
-						el->el_tty.t_c[EX_IO][i] = el->el_tty.t_c[TS_IO][i];
-					if (el->el_tty.t_t[EX_IO][MD_CHAR].t_clrmask & C_SH(i))
-						el->el_tty.t_c[EX_IO][i] = el->el_tty.t_vdisable;
-				}
-				tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
-			}
-		}
-	}
-	if (tty_setty(el, &el->el_tty.t_ed) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile, "tty_rawmode: tty_setty: %s\n",
-		    strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	el->el_tty.t_mode = ED_IO;
-	return (0);
-}
-
-
-/* tty_cookedmode():
- *	Set the tty back to normal mode
- */
-protected int
-tty_cookedmode(EditLine *el)
-{				/* set tty in normal setup */
-
-	if (el->el_tty.t_mode == EX_IO)
-		return (0);
-
-	if (el->el_flags & EDIT_DISABLED)
-		return (0);
-
-	if (tty_setty(el, &el->el_tty.t_ex) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile,
-		    "tty_cookedmode: tty_setty: %s\n",
-		    strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	el->el_tty.t_mode = EX_IO;
-	return (0);
-}
-
-
-/* tty_quotemode():
- *	Turn on quote mode
- */
-protected int
-tty_quotemode(EditLine *el)
-{
-	if (el->el_tty.t_mode == QU_IO)
-		return (0);
-
-	el->el_tty.t_qu = el->el_tty.t_ed;
-
-	el->el_tty.t_qu.c_iflag &= ~el->el_tty.t_t[QU_IO][MD_INP].t_clrmask;
-	el->el_tty.t_qu.c_iflag |= el->el_tty.t_t[QU_IO][MD_INP].t_setmask;
-
-	el->el_tty.t_qu.c_oflag &= ~el->el_tty.t_t[QU_IO][MD_OUT].t_clrmask;
-	el->el_tty.t_qu.c_oflag |= el->el_tty.t_t[QU_IO][MD_OUT].t_setmask;
-
-	el->el_tty.t_qu.c_cflag &= ~el->el_tty.t_t[QU_IO][MD_CTL].t_clrmask;
-	el->el_tty.t_qu.c_cflag |= el->el_tty.t_t[QU_IO][MD_CTL].t_setmask;
-
-	el->el_tty.t_qu.c_lflag &= ~el->el_tty.t_t[QU_IO][MD_LIN].t_clrmask;
-	el->el_tty.t_qu.c_lflag |= el->el_tty.t_t[QU_IO][MD_LIN].t_setmask;
-
-	if (tty_setty(el, &el->el_tty.t_qu) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile, "QuoteModeOn: tty_setty: %s\n",
-		    strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	el->el_tty.t_mode = QU_IO;
-	return (0);
-}
-
-
-/* tty_noquotemode():
- *	Turn off quote mode
- */
-protected int
-tty_noquotemode(EditLine *el)
-{
-
-	if (el->el_tty.t_mode != QU_IO)
-		return (0);
-	if (tty_setty(el, &el->el_tty.t_ed) == -1) {
-#ifdef DEBUG_TTY
-		(void) fprintf(el->el_errfile, "QuoteModeOff: tty_setty: %s\n",
-		    strerror(errno));
-#endif /* DEBUG_TTY */
-		return (-1);
-	}
-	el->el_tty.t_mode = ED_IO;
-	return (0);
-}
-
-
-/* tty_stty():
- *	Stty builtin
- */
-protected int
-/*ARGSUSED*/
-tty_stty(EditLine *el, int argc __attribute__((__unused__)), const char **argv)
-{
-	const ttymodes_t *m;
-	char x;
-	int aflag = 0;
-	const char *s, *d;
-	const char *name;
-	struct termios *tios = &el->el_tty.t_ex;
-	int z = EX_IO;
-
-	if (argv == NULL)
-		return (-1);
-	name = *argv++;
-
-	while (argv && *argv && argv[0][0] == '-' && argv[0][2] == '\0')
-		switch (argv[0][1]) {
-		case 'a':
-			aflag++;
-			argv++;
-			break;
-		case 'd':
-			argv++;
-			tios = &el->el_tty.t_ed;
-			z = ED_IO;
-			break;
-		case 'x':
-			argv++;
-			tios = &el->el_tty.t_ex;
-			z = EX_IO;
-			break;
-		case 'q':
-			argv++;
-			tios = &el->el_tty.t_ts;
-			z = QU_IO;
-			break;
-		default:
-			(void) fprintf(el->el_errfile,
-			    "%s: Unknown switch `%c'.\n",
-			    name, argv[0][1]);
-			return (-1);
-		}
-
-	if (!argv || !*argv) {
-		int i = -1;
-		int len = 0, st = 0, cu;
-		for (m = ttymodes; m->m_name; m++) {
-			if (m->m_type != i) {
-				(void) fprintf(el->el_outfile, "%s%s",
-				    i != -1 ? "\n" : "",
-				    el->el_tty.t_t[z][m->m_type].t_name);
-				i = m->m_type;
-				st = len =
-				    strlen(el->el_tty.t_t[z][m->m_type].t_name);
-			}
-			x = (el->el_tty.t_t[z][i].t_setmask & m->m_value)
-			    ?  '+' : '\0';
-			x = (el->el_tty.t_t[z][i].t_clrmask & m->m_value)
-			    ? '-' : x;
-
-			if (x != '\0' || aflag) {
-
-				cu = strlen(m->m_name) + (x != '\0') + 1;
-
-				if (len + cu >= el->el_term.t_size.h) {
-					(void) fprintf(el->el_outfile, "\n%*s",
-					    st, "");
-					len = st + cu;
-				} else
-					len += cu;
-
-				if (x != '\0')
-					(void) fprintf(el->el_outfile, "%c%s ",
-					    x, m->m_name);
-				else
-					(void) fprintf(el->el_outfile, "%s ",
-					    m->m_name);
-			}
-		}
-		(void) fprintf(el->el_outfile, "\n");
-		return (0);
-	}
-	while (argv && (s = *argv++)) {
-		const char *p;
-		switch (*s) {
-		case '+':
-		case '-':
-			x = *s++;
-			break;
-		default:
-			x = '\0';
-			break;
-		}
-		d = s;
-		p = strchr(s, '=');
-		for (m = ttymodes; m->m_name; m++)
-			if ((p ? strncmp(m->m_name, d, (size_t)(p - d)) :
-			    strcmp(m->m_name, d)) == 0 &&
-			    (p == NULL || m->m_type == MD_CHAR))
-				break;
-
-		if (!m->m_name) {
-			(void) fprintf(el->el_errfile,
-			    "%s: Invalid argument `%s'.\n", name, d);
-			return (-1);
-		}
-		if (p) {
-			int c = ffs((int)m->m_value);
-			int v = *++p ? parse__escape((const char **) &p) :
-			    el->el_tty.t_vdisable;
-			assert(c-- != 0);
-			c = tty__getcharindex(c);
-			assert(c != -1);
-			tios->c_cc[c] = v;
-			continue;
-		}
-		switch (x) {
-		case '+':
-			el->el_tty.t_t[z][m->m_type].t_setmask |= m->m_value;
-			el->el_tty.t_t[z][m->m_type].t_clrmask &= ~m->m_value;
-			break;
-		case '-':
-			el->el_tty.t_t[z][m->m_type].t_setmask &= ~m->m_value;
-			el->el_tty.t_t[z][m->m_type].t_clrmask |= m->m_value;
-			break;
-		default:
-			el->el_tty.t_t[z][m->m_type].t_setmask &= ~m->m_value;
-			el->el_tty.t_t[z][m->m_type].t_clrmask &= ~m->m_value;
-			break;
-		}
-	}
-	return (0);
-}
-
-
-#ifdef notyet
-/* tty_printchar():
- *	DEbugging routine to print the tty characters
- */
-private void
-tty_printchar(EditLine *el, unsigned char *s)
-{
-	ttyperm_t *m;
-	int i;
-
-	for (i = 0; i < C_NCC; i++) {
-		for (m = el->el_tty.t_t; m->m_name; m++)
-			if (m->m_type == MD_CHAR && C_SH(i) == m->m_value)
-				break;
-		if (m->m_name)
-			(void) fprintf(el->el_errfile, "%s ^%c ",
-			    m->m_name, s[i] + 'A' - 1);
-		if (i % 5 == 0)
-			(void) fprintf(el->el_errfile, "\n");
-	}
-	(void) fprintf(el->el_errfile, "\n");
-}
-#endif /* notyet */
diff --git a/libedit/tty.h b/libedit/tty.h
deleted file mode 100644
index 10e9b98..0000000
--- a/libedit/tty.h
+++ /dev/null
@@ -1,480 +0,0 @@
-/*	$NetBSD: tty.h,v 1.11 2005/06/01 11:37:52 lukem Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)tty.h	8.1 (Berkeley) 6/4/93
- */
-
-/*
- * el.tty.h: Local terminal header
- */
-#ifndef _h_el_tty
-#define	_h_el_tty
-
-#include "histedit.h"
-#include <termios.h>
-#include <unistd.h>
-
-/* Define our own since everyone gets it wrong! */
-#define	CONTROL(A)	((A) & 037)
-
-/*
- * Aix compatible names
- */
-# if defined(VWERSE) && !defined(VWERASE)
-#  define VWERASE VWERSE
-# endif /* VWERSE && !VWERASE */
-
-# if defined(VDISCRD) && !defined(VDISCARD)
-#  define VDISCARD VDISCRD
-# endif /* VDISCRD && !VDISCARD */
-
-# if defined(VFLUSHO) && !defined(VDISCARD)
-#  define VDISCARD VFLUSHO
-# endif  /* VFLUSHO && VDISCARD */
-
-# if defined(VSTRT) && !defined(VSTART)
-#  define VSTART VSTRT
-# endif /* VSTRT && ! VSTART */
-
-# if defined(VSTAT) && !defined(VSTATUS)
-#  define VSTATUS VSTAT
-# endif /* VSTAT && ! VSTATUS */
-
-# ifndef ONLRET
-#  define ONLRET 0
-# endif /* ONLRET */
-
-# ifndef TAB3
-#  ifdef OXTABS
-#   define TAB3 OXTABS
-#  else
-#   define TAB3 0
-#  endif /* OXTABS */
-# endif /* !TAB3 */
-
-# if defined(OXTABS) && !defined(XTABS)
-#  define XTABS OXTABS
-# endif /* OXTABS && !XTABS */
-
-# ifndef ONLCR
-#  define ONLCR 0
-# endif /* ONLCR */
-
-# ifndef IEXTEN
-#  define IEXTEN 0
-# endif /* IEXTEN */
-
-# ifndef ECHOCTL
-#  define ECHOCTL 0
-# endif /* ECHOCTL */
-
-# ifndef PARENB
-#  define PARENB 0
-# endif /* PARENB */
-
-# ifndef EXTPROC
-#  define EXTPROC 0
-# endif /* EXTPROC */
-
-# ifndef FLUSHO
-#  define FLUSHO  0
-# endif /* FLUSHO */
-
-
-# if defined(VDISABLE) && !defined(_POSIX_VDISABLE)
-#  define _POSIX_VDISABLE VDISABLE
-# endif /* VDISABLE && ! _POSIX_VDISABLE */
-
-/*
- * Work around ISC's definition of IEXTEN which is
- * XCASE!
- */
-# ifdef ISC
-#  if defined(IEXTEN) && defined(XCASE)
-#   if IEXTEN == XCASE
-#    undef IEXTEN
-#    define IEXTEN 0
-#   endif /* IEXTEN == XCASE */
-#  endif /* IEXTEN && XCASE */
-#  if defined(IEXTEN) && !defined(XCASE)
-#   define XCASE IEXTEN
-#   undef IEXTEN
-#   define IEXTEN 0
-#  endif /* IEXTEN && !XCASE */
-# endif /* ISC */
-
-/*
- * Work around convex weirdness where turning off IEXTEN makes us
- * lose all postprocessing!
- */
-#if defined(convex) || defined(__convex__)
-# if defined(IEXTEN) && IEXTEN != 0
-#  undef IEXTEN
-#  define IEXTEN 0
-# endif /* IEXTEN != 0 */
-#endif /* convex || __convex__ */
-
-/*
- * So that we don't lose job control.
- */
-#ifdef __SVR4
-# undef CSWTCH
-#endif
-
-#ifndef _POSIX_VDISABLE
-# define _POSIX_VDISABLE ((unsigned char) -1)
-#endif /* _POSIX_VDISABLE */
-
-#if !defined(CREPRINT) && defined(CRPRNT)
-# define CREPRINT CRPRNT
-#endif /* !CREPRINT && CRPRNT */
-#if !defined(CDISCARD) && defined(CFLUSH)
-# define CDISCARD CFLUSH
-#endif /* !CDISCARD && CFLUSH */
-
-#ifndef CINTR
-# define CINTR		CONTROL('c')
-#endif /* CINTR */
-#ifndef CQUIT
-# define CQUIT		034	/* ^\ */
-#endif /* CQUIT */
-#ifndef CERASE
-# define CERASE		0177	/* ^? */
-#endif /* CERASE */
-#ifndef CKILL
-# define CKILL		CONTROL('u')
-#endif /* CKILL */
-#ifndef CEOF
-# define CEOF		CONTROL('d')
-#endif /* CEOF */
-#ifndef CEOL
-# define CEOL		_POSIX_VDISABLE
-#endif /* CEOL */
-#ifndef CEOL2
-# define CEOL2		_POSIX_VDISABLE
-#endif /* CEOL2 */
-#ifndef CSWTCH
-# define CSWTCH		_POSIX_VDISABLE
-#endif /* CSWTCH */
-#ifndef CDSWTCH
-# define CDSWTCH	_POSIX_VDISABLE
-#endif /* CDSWTCH */
-#ifndef CERASE2
-# define CERASE2	_POSIX_VDISABLE
-#endif /* CERASE2 */
-#ifndef CSTART
-# define CSTART		CONTROL('q')
-#endif /* CSTART */
-#ifndef CSTOP
-# define CSTOP		CONTROL('s')
-#endif /* CSTOP */
-#ifndef CSUSP
-# define CSUSP		CONTROL('z')
-#endif /* CSUSP */
-#ifndef CDSUSP
-# define CDSUSP		CONTROL('y')
-#endif /* CDSUSP */
-
-#ifdef hpux
-
-# ifndef CREPRINT
-#  define CREPRINT	_POSIX_VDISABLE
-# endif /* CREPRINT */
-# ifndef CDISCARD
-#  define CDISCARD	_POSIX_VDISABLE
-# endif /* CDISCARD */
-# ifndef CLNEXT
-#  define CLNEXT	_POSIX_VDISABLE
-# endif /* CLNEXT */
-# ifndef CWERASE
-#  define CWERASE	_POSIX_VDISABLE
-# endif /* CWERASE */
-
-#else /* !hpux */
-
-# ifndef CREPRINT
-#  define CREPRINT	CONTROL('r')
-# endif /* CREPRINT */
-# ifndef CDISCARD
-#  define CDISCARD	CONTROL('o')
-# endif /* CDISCARD */
-# ifndef CLNEXT
-#  define CLNEXT	CONTROL('v')
-# endif /* CLNEXT */
-# ifndef CWERASE
-#  define CWERASE	CONTROL('w')
-# endif /* CWERASE */
-
-#endif /* hpux */
-
-#ifndef CSTATUS
-# define CSTATUS	CONTROL('t')
-#endif /* CSTATUS */
-#ifndef CPAGE
-# define CPAGE		' '
-#endif /* CPAGE */
-#ifndef CPGOFF
-# define CPGOFF		CONTROL('m')
-#endif /* CPGOFF */
-#ifndef CKILL2
-# define CKILL2		_POSIX_VDISABLE
-#endif /* CKILL2 */
-#ifndef CBRK
-# ifndef masscomp
-#  define CBRK		0377
-# else
-#  define CBRK		'\0'
-# endif /* masscomp */
-#endif /* CBRK */
-#ifndef CMIN
-# define CMIN		CEOF
-#endif /* CMIN */
-#ifndef CTIME
-# define CTIME		CEOL
-#endif /* CTIME */
-
-/*
- * Fix for sun inconsistency. On termio VSUSP and the rest of the
- * ttychars > NCC are defined. So we undefine them.
- */
-#if defined(TERMIO) || defined(POSIX)
-# if defined(POSIX) && defined(NCCS)
-#  define NUMCC		NCCS
-# else
-#  ifdef NCC
-#   define NUMCC	NCC
-#  endif /* NCC */
-# endif /* POSIX && NCCS */
-# ifdef NUMCC
-#  ifdef VINTR
-#   if NUMCC <= VINTR
-#    undef VINTR
-#   endif /* NUMCC <= VINTR */
-#  endif /* VINTR */
-#  ifdef VQUIT
-#   if NUMCC <= VQUIT
-#    undef VQUIT
-#   endif /* NUMCC <= VQUIT */
-#  endif /* VQUIT */
-#  ifdef VERASE
-#   if NUMCC <= VERASE
-#    undef VERASE
-#   endif /* NUMCC <= VERASE */
-#  endif /* VERASE */
-#  ifdef VKILL
-#   if NUMCC <= VKILL
-#    undef VKILL
-#   endif /* NUMCC <= VKILL */
-#  endif /* VKILL */
-#  ifdef VEOF
-#   if NUMCC <= VEOF
-#    undef VEOF
-#   endif /* NUMCC <= VEOF */
-#  endif /* VEOF */
-#  ifdef VEOL
-#   if NUMCC <= VEOL
-#    undef VEOL
-#   endif /* NUMCC <= VEOL */
-#  endif /* VEOL */
-#  ifdef VEOL2
-#   if NUMCC <= VEOL2
-#    undef VEOL2
-#   endif /* NUMCC <= VEOL2 */
-#  endif /* VEOL2 */
-#  ifdef VSWTCH
-#   if NUMCC <= VSWTCH
-#    undef VSWTCH
-#   endif /* NUMCC <= VSWTCH */
-#  endif /* VSWTCH */
-#  ifdef VDSWTCH
-#   if NUMCC <= VDSWTCH
-#    undef VDSWTCH
-#   endif /* NUMCC <= VDSWTCH */
-#  endif /* VDSWTCH */
-#  ifdef VERASE2
-#   if NUMCC <= VERASE2
-#    undef VERASE2
-#   endif /* NUMCC <= VERASE2 */
-#  endif /* VERASE2 */
-#  ifdef VSTART
-#   if NUMCC <= VSTART
-#    undef VSTART
-#   endif /* NUMCC <= VSTART */
-#  endif /* VSTART */
-#  ifdef VSTOP
-#   if NUMCC <= VSTOP
-#    undef VSTOP
-#   endif /* NUMCC <= VSTOP */
-#  endif /* VSTOP */
-#  ifdef VWERASE
-#   if NUMCC <= VWERASE
-#    undef VWERASE
-#   endif /* NUMCC <= VWERASE */
-#  endif /* VWERASE */
-#  ifdef VSUSP
-#   if NUMCC <= VSUSP
-#    undef VSUSP
-#   endif /* NUMCC <= VSUSP */
-#  endif /* VSUSP */
-#  ifdef VDSUSP
-#   if NUMCC <= VDSUSP
-#    undef VDSUSP
-#   endif /* NUMCC <= VDSUSP */
-#  endif /* VDSUSP */
-#  ifdef VREPRINT
-#   if NUMCC <= VREPRINT
-#    undef VREPRINT
-#   endif /* NUMCC <= VREPRINT */
-#  endif /* VREPRINT */
-#  ifdef VDISCARD
-#   if NUMCC <= VDISCARD
-#    undef VDISCARD
-#   endif /* NUMCC <= VDISCARD */
-#  endif /* VDISCARD */
-#  ifdef VLNEXT
-#   if NUMCC <= VLNEXT
-#    undef VLNEXT
-#   endif /* NUMCC <= VLNEXT */
-#  endif /* VLNEXT */
-#  ifdef VSTATUS
-#   if NUMCC <= VSTATUS
-#    undef VSTATUS
-#   endif /* NUMCC <= VSTATUS */
-#  endif /* VSTATUS */
-#  ifdef VPAGE
-#   if NUMCC <= VPAGE
-#    undef VPAGE
-#   endif /* NUMCC <= VPAGE */
-#  endif /* VPAGE */
-#  ifdef VPGOFF
-#   if NUMCC <= VPGOFF
-#    undef VPGOFF
-#   endif /* NUMCC <= VPGOFF */
-#  endif /* VPGOFF */
-#  ifdef VKILL2
-#   if NUMCC <= VKILL2
-#    undef VKILL2
-#   endif /* NUMCC <= VKILL2 */
-#  endif /* VKILL2 */
-#  ifdef VBRK
-#   if NUMCC <= VBRK
-#    undef VBRK
-#   endif /* NUMCC <= VBRK */
-#  endif /* VBRK */
-#  ifdef VMIN
-#   if NUMCC <= VMIN
-#    undef VMIN
-#   endif /* NUMCC <= VMIN */
-#  endif /* VMIN */
-#  ifdef VTIME
-#   if NUMCC <= VTIME
-#    undef VTIME
-#   endif /* NUMCC <= VTIME */
-#  endif /* VTIME */
-# endif /* NUMCC */
-#endif /* !POSIX */
-
-#define	C_INTR		 0
-#define	C_QUIT		 1
-#define	C_ERASE		 2
-#define	C_KILL		 3
-#define	C_EOF		 4
-#define	C_EOL		 5
-#define	C_EOL2		 6
-#define	C_SWTCH		 7
-#define	C_DSWTCH	 8
-#define	C_ERASE2	 9
-#define	C_START		10
-#define	C_STOP		11
-#define	C_WERASE	12
-#define	C_SUSP		13
-#define	C_DSUSP		14
-#define	C_REPRINT	15
-#define	C_DISCARD	16
-#define	C_LNEXT		17
-#define	C_STATUS	18
-#define	C_PAGE		19
-#define	C_PGOFF		20
-#define	C_KILL2		21
-#define	C_BRK		22
-#define	C_MIN		23
-#define	C_TIME		24
-#define	C_NCC		25
-#define	C_SH(A)		(1 << (A))
-
-/*
- * Terminal dependend data structures
- */
-#define	EX_IO	0	/* while we are executing	*/
-#define	ED_IO	1	/* while we are editing		*/
-#define	TS_IO	2	/* new mode from terminal	*/
-#define	QU_IO	2	/* used only for quoted chars	*/
-#define	NN_IO	3	/* The number of entries	*/
-
-#define	MD_INP	0
-#define	MD_OUT	1
-#define	MD_CTL	2
-#define	MD_LIN	3
-#define	MD_CHAR	4
-#define	MD_NN	5
-
-typedef struct {
-	const char	*t_name;
-	unsigned int	 t_setmask;
-	unsigned int	 t_clrmask;
-} ttyperm_t[NN_IO][MD_NN];
-
-typedef unsigned char ttychar_t[NN_IO][C_NCC];
-
-protected int	tty_init(EditLine *);
-protected void	tty_end(EditLine *);
-protected int	tty_stty(EditLine *, int, const char **);
-protected int	tty_rawmode(EditLine *);
-protected int	tty_cookedmode(EditLine *);
-protected int	tty_quotemode(EditLine *);
-protected int	tty_noquotemode(EditLine *);
-protected void	tty_bind_char(EditLine *, int);
-
-typedef struct {
-    ttyperm_t t_t;
-    ttychar_t t_c;
-    struct termios t_ex, t_ed, t_ts;
-    int t_tabs;
-    int t_eight;
-    speed_t t_speed;
-    int t_mode;
-    unsigned char t_vdisable;
-} el_tty_t;
-
-
-#endif /* _h_el_tty */
diff --git a/libedit/unvis.c b/libedit/unvis.c
deleted file mode 100644
index c57da8f..0000000
--- a/libedit/unvis.c
+++ /dev/null
@@ -1,305 +0,0 @@
-/*	$NetBSD: unvis.c,v 1.28 2005/09/13 01:44:09 christos Exp $	*/
-
-/*-
- * Copyright (c) 1989, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#if defined(LIBC_SCCS) && !defined(lint)
-#if 0
-static char sccsid[] = "@(#)unvis.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: unvis.c,v 1.28 2005/09/13 01:44:09 christos Exp $");
-#endif
-#endif /* LIBC_SCCS and not lint */
-
-#include <sys/types.h>
-
-#include <assert.h>
-#include <ctype.h>
-#include <stdio.h>
-#include <vis.h>
-
-#ifdef __weak_alias
-__weak_alias(strunvis,_strunvis)
-#endif
-
-#if !HAVE_VIS
-/*
- * decode driven by state machine
- */
-#define	S_GROUND	0	/* haven't seen escape char */
-#define	S_START		1	/* start decoding special sequence */
-#define	S_META		2	/* metachar started (M) */
-#define	S_META1		3	/* metachar more, regular char (-) */
-#define	S_CTRL		4	/* control char started (^) */
-#define	S_OCTAL2	5	/* octal digit 2 */
-#define	S_OCTAL3	6	/* octal digit 3 */
-#define	S_HEX1		7	/* hex digit */
-#define	S_HEX2		8	/* hex digit 2 */
-
-#define	isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
-#define xtod(c)		(isdigit(c) ? (c - '0') : ((tolower(c) - 'a') + 10))
-
-/*
- * unvis - decode characters previously encoded by vis
- */
-int
-unvis(cp, c, astate, flag)
-	char *cp;
-	int c;
-	int *astate, flag;
-{
-	unsigned char uc = (unsigned char)c;
-
-	_DIAGASSERT(cp != NULL);
-	_DIAGASSERT(astate != NULL);
-
-	if (flag & UNVIS_END) {
-		if (*astate == S_OCTAL2 || *astate == S_OCTAL3
-		    || *astate == S_HEX2) {
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		}
-		return (*astate == S_GROUND ? UNVIS_NOCHAR : UNVIS_SYNBAD);
-	}
-
-	switch (*astate) {
-
-	case S_GROUND:
-		*cp = 0;
-		if (c == '\\') {
-			*astate = S_START;
-			return (0);
-		}
-		if ((flag & VIS_HTTPSTYLE) && c == '%') {
-			*astate = S_HEX1;
-			return (0);
-		}
-		*cp = c;
-		return (UNVIS_VALID);
-
-	case S_START:
-		switch(c) {
-		case '\\':
-			*cp = c;
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case '0': case '1': case '2': case '3':
-		case '4': case '5': case '6': case '7':
-			*cp = (c - '0');
-			*astate = S_OCTAL2;
-			return (0);
-		case 'M':
-			*cp = (char)0200;
-			*astate = S_META;
-			return (0);
-		case '^':
-			*astate = S_CTRL;
-			return (0);
-		case 'n':
-			*cp = '\n';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'r':
-			*cp = '\r';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'b':
-			*cp = '\b';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'a':
-			*cp = '\007';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'v':
-			*cp = '\v';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 't':
-			*cp = '\t';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'f':
-			*cp = '\f';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 's':
-			*cp = ' ';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case 'E':
-			*cp = '\033';
-			*astate = S_GROUND;
-			return (UNVIS_VALID);
-		case '\n':
-			/*
-			 * hidden newline
-			 */
-			*astate = S_GROUND;
-			return (UNVIS_NOCHAR);
-		case '$':
-			/*
-			 * hidden marker
-			 */
-			*astate = S_GROUND;
-			return (UNVIS_NOCHAR);
-		}
-		*astate = S_GROUND;
-		return (UNVIS_SYNBAD);
-
-	case S_META:
-		if (c == '-')
-			*astate = S_META1;
-		else if (c == '^')
-			*astate = S_CTRL;
-		else {
-			*astate = S_GROUND;
-			return (UNVIS_SYNBAD);
-		}
-		return (0);
-
-	case S_META1:
-		*astate = S_GROUND;
-		*cp |= c;
-		return (UNVIS_VALID);
-
-	case S_CTRL:
-		if (c == '?')
-			*cp |= 0177;
-		else
-			*cp |= c & 037;
-		*astate = S_GROUND;
-		return (UNVIS_VALID);
-
-	case S_OCTAL2:	/* second possible octal digit */
-		if (isoctal(uc)) {
-			/*
-			 * yes - and maybe a third
-			 */
-			*cp = (*cp << 3) + (c - '0');
-			*astate = S_OCTAL3;
-			return (0);
-		}
-		/*
-		 * no - done with current sequence, push back passed char
-		 */
-		*astate = S_GROUND;
-		return (UNVIS_VALIDPUSH);
-
-	case S_OCTAL3:	/* third possible octal digit */
-		*astate = S_GROUND;
-		if (isoctal(uc)) {
-			*cp = (*cp << 3) + (c - '0');
-			return (UNVIS_VALID);
-		}
-		/*
-		 * we were done, push back passed char
-		 */
-		return (UNVIS_VALIDPUSH);
-
-	case S_HEX1:
-		if (isxdigit(uc)) {
-			*cp = xtod(uc);
-			*astate = S_HEX2;
-			return (0);
-		}
-		/*
-		 * no - done with current sequence, push back passed char
-		 */
-		*astate = S_GROUND;
-		return (UNVIS_VALIDPUSH);
-
-	case S_HEX2:
-		*astate = S_GROUND;
-		if (isxdigit(uc)) {
-			*cp = xtod(uc) | (*cp << 4);
-			return (UNVIS_VALID);
-		}
-		return (UNVIS_VALIDPUSH);
-
-	default:
-		/*
-		 * decoder in unknown state - (probably uninitialized)
-		 */
-		*astate = S_GROUND;
-		return (UNVIS_SYNBAD);
-	}
-}
-
-/*
- * strunvis - decode src into dst
- *
- *	Number of chars decoded into dst is returned, -1 on error.
- *	Dst is null terminated.
- */
-
-int
-strunvisx(dst, src, flag)
-	char *dst;
-	const char *src;
-	int flag;
-{
-	char c;
-	char *start = dst;
-	int state = 0;
-
-	_DIAGASSERT(src != NULL);
-	_DIAGASSERT(dst != NULL);
-
-	while ((c = *src++) != '\0') {
- again:
-		switch (unvis(dst, c, &state, flag)) {
-		case UNVIS_VALID:
-			dst++;
-			break;
-		case UNVIS_VALIDPUSH:
-			dst++;
-			goto again;
-		case 0:
-		case UNVIS_NOCHAR:
-			break;
-		default:
-			return (-1);
-		}
-	}
-	if (unvis(dst, c, &state, UNVIS_END) == UNVIS_VALID)
-		dst++;
-	*dst = '\0';
-	return (dst - start);
-}
-
-int
-strunvis(dst, src)
-	char *dst;
-	const char *src;
-{
-	return strunvisx(dst, src, 0);
-}
-#endif
diff --git a/libedit/vi.c b/libedit/vi.c
deleted file mode 100644
index 7fc7fde..0000000
--- a/libedit/vi.c
+++ /dev/null
@@ -1,1130 +0,0 @@
-/*	$NetBSD: vi.c,v 1.24 2005/08/10 12:46:24 christos Exp $	*/
-
-/*-
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Christos Zoulas of Cornell University.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "sys.h"
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/wait.h>
-
-#if !defined(lint) && !defined(SCCSID)
-#if 0
-static char sccsid[] = "@(#)vi.c	8.1 (Berkeley) 6/4/93";
-#else
-__RCSID("$NetBSD: vi.c,v 1.24 2005/08/10 12:46:24 christos Exp $");
-#endif
-#endif /* not lint && not SCCSID */
-
-/*
- * vi.c: Vi mode commands.
- */
-#include "el.h"
-
-private el_action_t	cv_action(EditLine *, int);
-private el_action_t	cv_paste(EditLine *, int);
-
-/* cv_action():
- *	Handle vi actions.
- */
-private el_action_t
-cv_action(EditLine *el, int c)
-{
-
-	if (el->el_chared.c_vcmd.action != NOP) {
-		/* 'cc', 'dd' and (possibly) friends */
-		if (c != el->el_chared.c_vcmd.action)
-			return CC_ERROR;
-
-		if (!(c & YANK))
-			cv_undo(el);
-		cv_yank(el, el->el_line.buffer,
-			    el->el_line.lastchar - el->el_line.buffer);
-		el->el_chared.c_vcmd.action = NOP;
-		el->el_chared.c_vcmd.pos = 0;
-		if (!(c & YANK)) {
-			el->el_line.lastchar = el->el_line.buffer;
-			el->el_line.cursor = el->el_line.buffer;
-		}
-		if (c & INSERT)
-			el->el_map.current = el->el_map.key;
-
-		return (CC_REFRESH);
-	}
-	el->el_chared.c_vcmd.pos = el->el_line.cursor;
-	el->el_chared.c_vcmd.action = c;
-	return (CC_ARGHACK);
-}
-
-/* cv_paste():
- *	Paste previous deletion before or after the cursor
- */
-private el_action_t
-cv_paste(EditLine *el, int c)
-{
-	c_kill_t *k = &el->el_chared.c_kill;
-	int len = k->last - k->buf;
-
-	if (k->buf == NULL || len == 0)
-		return (CC_ERROR);
-#ifdef DEBUG_PASTE
-	(void) fprintf(el->el_errfile, "Paste: \"%.*s\"\n", len, k->buf);
-#endif
-
-	cv_undo(el);
-
-	if (!c && el->el_line.cursor < el->el_line.lastchar)
-		el->el_line.cursor++;
-
-	c_insert(el, len);
-	if (el->el_line.cursor + len > el->el_line.lastchar)
-		return (CC_ERROR);
-	(void) memcpy(el->el_line.cursor, k->buf, len +0u);
-
-	return (CC_REFRESH);
-}
-
-
-/* vi_paste_next():
- *	Vi paste previous deletion to the right of the cursor
- *	[p]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_paste_next(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	return (cv_paste(el, 0));
-}
-
-
-/* vi_paste_prev():
- *	Vi paste previous deletion to the left of the cursor
- *	[P]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_paste_prev(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	return (cv_paste(el, 1));
-}
-
-
-/* vi_prev_big_word():
- *	Vi move to the previous space delimited word
- *	[B]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_prev_big_word(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv_prev_word(el->el_line.cursor,
-	    el->el_line.buffer,
-	    el->el_state.argument,
-	    cv__isWord);
-
-	if (el->el_chared.c_vcmd.action != NOP) {
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	return (CC_CURSOR);
-}
-
-
-/* vi_prev_word():
- *	Vi move to the previous word
- *	[b]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_prev_word(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor == el->el_line.buffer)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv_prev_word(el->el_line.cursor,
-	    el->el_line.buffer,
-	    el->el_state.argument,
-	    cv__isword);
-
-	if (el->el_chared.c_vcmd.action != NOP) {
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	return (CC_CURSOR);
-}
-
-
-/* vi_next_big_word():
- *	Vi move to the next space delimited word
- *	[W]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_next_big_word(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor >= el->el_line.lastchar - 1)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv_next_word(el, el->el_line.cursor,
-	    el->el_line.lastchar, el->el_state.argument, cv__isWord);
-
-	if (el->el_map.type == MAP_VI)
-		if (el->el_chared.c_vcmd.action != NOP) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	return (CC_CURSOR);
-}
-
-
-/* vi_next_word():
- *	Vi move to the next word
- *	[w]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_next_word(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor >= el->el_line.lastchar - 1)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv_next_word(el, el->el_line.cursor,
-	    el->el_line.lastchar, el->el_state.argument, cv__isword);
-
-	if (el->el_map.type == MAP_VI)
-		if (el->el_chared.c_vcmd.action != NOP) {
-			cv_delfini(el);
-			return (CC_REFRESH);
-		}
-	return (CC_CURSOR);
-}
-
-
-/* vi_change_case():
- *	Vi change case of character under the cursor and advance one character
- *	[~]
- */
-protected el_action_t
-vi_change_case(EditLine *el, int c)
-{
-	int i;
-
-	if (el->el_line.cursor >= el->el_line.lastchar)
-		return (CC_ERROR);
-	cv_undo(el);
-	for (i = 0; i < el->el_state.argument; i++) {
-
-		c = *(unsigned char *)el->el_line.cursor;
-		if (isupper(c))
-			*el->el_line.cursor = tolower(c);
-		else if (islower(c))
-			*el->el_line.cursor = toupper(c);
-
-		if (++el->el_line.cursor >= el->el_line.lastchar) {
-			el->el_line.cursor--;
-			re_fastaddc(el);
-			break;
-		}
-		re_fastaddc(el);
-	}
-	return CC_NORM;
-}
-
-
-/* vi_change_meta():
- *	Vi change prefix command
- *	[c]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_change_meta(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	/*
-         * Delete with insert == change: first we delete and then we leave in
-         * insert mode.
-         */
-	return (cv_action(el, DELETE | INSERT));
-}
-
-
-/* vi_insert_at_bol():
- *	Vi enter insert mode at the beginning of line
- *	[I]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_insert_at_bol(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_line.cursor = el->el_line.buffer;
-	cv_undo(el);
-	el->el_map.current = el->el_map.key;
-	return (CC_CURSOR);
-}
-
-
-/* vi_replace_char():
- *	Vi replace character under the cursor with the next character typed
- *	[r]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_replace_char(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor >= el->el_line.lastchar)
-		return CC_ERROR;
-
-	el->el_map.current = el->el_map.key;
-	el->el_state.inputmode = MODE_REPLACE_1;
-	cv_undo(el);
-	return (CC_ARGHACK);
-}
-
-
-/* vi_replace_mode():
- *	Vi enter replace mode
- *	[R]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_replace_mode(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_map.current = el->el_map.key;
-	el->el_state.inputmode = MODE_REPLACE;
-	cv_undo(el);
-	return (CC_NORM);
-}
-
-
-/* vi_substitute_char():
- *	Vi replace character under the cursor and enter insert mode
- *	[s]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_substitute_char(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	c_delafter(el, el->el_state.argument);
-	el->el_map.current = el->el_map.key;
-	return (CC_REFRESH);
-}
-
-
-/* vi_substitute_line():
- *	Vi substitute entire line
- *	[S]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_substitute_line(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	cv_undo(el);
-	cv_yank(el, el->el_line.buffer,
-		    el->el_line.lastchar - el->el_line.buffer);
-	(void) em_kill_line(el, 0);
-	el->el_map.current = el->el_map.key;
-	return (CC_REFRESH);
-}
-
-
-/* vi_change_to_eol():
- *	Vi change to end of line
- *	[C]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_change_to_eol(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	cv_undo(el);
-	cv_yank(el, el->el_line.cursor,
-		    el->el_line.lastchar - el->el_line.cursor);
-	(void) ed_kill_line(el, 0);
-	el->el_map.current = el->el_map.key;
-	return (CC_REFRESH);
-}
-
-
-/* vi_insert():
- *	Vi enter insert mode
- *	[i]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_insert(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_map.current = el->el_map.key;
-	cv_undo(el);
-	return (CC_NORM);
-}
-
-
-/* vi_add():
- *	Vi enter insert mode after the cursor
- *	[a]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_add(EditLine *el, int c __attribute__((__unused__)))
-{
-	int ret;
-
-	el->el_map.current = el->el_map.key;
-	if (el->el_line.cursor < el->el_line.lastchar) {
-		el->el_line.cursor++;
-		if (el->el_line.cursor > el->el_line.lastchar)
-			el->el_line.cursor = el->el_line.lastchar;
-		ret = CC_CURSOR;
-	} else
-		ret = CC_NORM;
-
-	cv_undo(el);
-
-	return (ret);
-}
-
-
-/* vi_add_at_eol():
- *	Vi enter insert mode at end of line
- *	[A]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_add_at_eol(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	el->el_map.current = el->el_map.key;
-	el->el_line.cursor = el->el_line.lastchar;
-	cv_undo(el);
-	return (CC_CURSOR);
-}
-
-
-/* vi_delete_meta():
- *	Vi delete prefix command
- *	[d]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_delete_meta(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	return (cv_action(el, DELETE));
-}
-
-
-/* vi_end_big_word():
- *	Vi move to the end of the current space delimited word
- *	[E]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_end_big_word(EditLine *el, int c)
-{
-
-	if (el->el_line.cursor == el->el_line.lastchar)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv__endword(el->el_line.cursor,
-	    el->el_line.lastchar, el->el_state.argument, cv__isWord);
-
-	if (el->el_chared.c_vcmd.action != NOP) {
-		el->el_line.cursor++;
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	return (CC_CURSOR);
-}
-
-
-/* vi_end_word():
- *	Vi move to the end of the current word
- *	[e]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_end_word(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor == el->el_line.lastchar)
-		return (CC_ERROR);
-
-	el->el_line.cursor = cv__endword(el->el_line.cursor,
-	    el->el_line.lastchar, el->el_state.argument, cv__isword);
-
-	if (el->el_chared.c_vcmd.action != NOP) {
-		el->el_line.cursor++;
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	return (CC_CURSOR);
-}
-
-
-/* vi_undo():
- *	Vi undo last change
- *	[u]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_undo(EditLine *el, int c __attribute__((__unused__)))
-{
-	c_undo_t un = el->el_chared.c_undo;
-
-	if (un.len == -1)
-		return CC_ERROR;
-
-	/* switch line buffer and undo buffer */
-	el->el_chared.c_undo.buf = el->el_line.buffer;
-	el->el_chared.c_undo.len = el->el_line.lastchar - el->el_line.buffer;
-	el->el_chared.c_undo.cursor = el->el_line.cursor - el->el_line.buffer;
-	el->el_line.limit = un.buf + (el->el_line.limit - el->el_line.buffer);
-	el->el_line.buffer = un.buf;
-	el->el_line.cursor = un.buf + un.cursor;
-	el->el_line.lastchar = un.buf + un.len;
-
-	return (CC_REFRESH);
-}
-
-
-/* vi_command_mode():
- *	Vi enter command mode (use alternative key bindings)
- *	[<ESC>]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_command_mode(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	/* [Esc] cancels pending action */
-	el->el_chared.c_vcmd.action = NOP;
-	el->el_chared.c_vcmd.pos = 0;
-
-	el->el_state.doingarg = 0;
-
-	el->el_state.inputmode = MODE_INSERT;
-	el->el_map.current = el->el_map.alt;
-#ifdef VI_MOVE
-	if (el->el_line.cursor > el->el_line.buffer)
-		el->el_line.cursor--;
-#endif
-	return (CC_CURSOR);
-}
-
-
-/* vi_zero():
- *	Vi move to the beginning of line
- *	[0]
- */
-protected el_action_t
-vi_zero(EditLine *el, int c)
-{
-
-	if (el->el_state.doingarg)
-		return ed_argument_digit(el, c);
-
-	el->el_line.cursor = el->el_line.buffer;
-	if (el->el_chared.c_vcmd.action != NOP) {
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	return (CC_CURSOR);
-}
-
-
-/* vi_delete_prev_char():
- * 	Vi move to previous character (backspace)
- *	[^H] in insert mode only
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_delete_prev_char(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor <= el->el_line.buffer)
-		return (CC_ERROR);
-
-	c_delbefore1(el);
-	el->el_line.cursor--;
-	return (CC_REFRESH);
-}
-
-
-/* vi_list_or_eof():
- *	Vi list choices for completion or indicate end of file if empty line
- *	[^D]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_list_or_eof(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_line.cursor == el->el_line.lastchar) {
-		if (el->el_line.cursor == el->el_line.buffer) {
-			term_overwrite(el, STReof, 4);	/* then do a EOF */
-			term__flush();
-			return (CC_EOF);
-		} else {
-			/*
-			 * Here we could list completions, but it is an
-			 * error right now
-			 */
-			term_beep(el);
-			return (CC_ERROR);
-		}
-	} else {
-#ifdef notyet
-		re_goto_bottom(el);
-		*el->el_line.lastchar = '\0';	/* just in case */
-		return (CC_LIST_CHOICES);
-#else
-		/*
-		 * Just complain for now.
-		 */
-		term_beep(el);
-		return (CC_ERROR);
-#endif
-	}
-}
-
-
-/* vi_kill_line_prev():
- *	Vi cut from beginning of line to cursor
- *	[^U]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_kill_line_prev(EditLine *el, int c __attribute__((__unused__)))
-{
-	char *kp, *cp;
-
-	cp = el->el_line.buffer;
-	kp = el->el_chared.c_kill.buf;
-	while (cp < el->el_line.cursor)
-		*kp++ = *cp++;	/* copy it */
-	el->el_chared.c_kill.last = kp;
-	c_delbefore(el, el->el_line.cursor - el->el_line.buffer);
-	el->el_line.cursor = el->el_line.buffer;	/* zap! */
-	return (CC_REFRESH);
-}
-
-
-/* vi_search_prev():
- *	Vi search history previous
- *	[?]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_search_prev(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	return (cv_search(el, ED_SEARCH_PREV_HISTORY));
-}
-
-
-/* vi_search_next():
- *	Vi search history next
- *	[/]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_search_next(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	return (cv_search(el, ED_SEARCH_NEXT_HISTORY));
-}
-
-
-/* vi_repeat_search_next():
- *	Vi repeat current search in the same search direction
- *	[n]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_repeat_search_next(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_search.patlen == 0)
-		return (CC_ERROR);
-	else
-		return (cv_repeat_srch(el, el->el_search.patdir));
-}
-
-
-/* vi_repeat_search_prev():
- *	Vi repeat current search in the opposite search direction
- *	[N]
- */
-/*ARGSUSED*/
-protected el_action_t
-vi_repeat_search_prev(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	if (el->el_search.patlen == 0)
-		return (CC_ERROR);
-	else
-		return (cv_repeat_srch(el,
-		    el->el_search.patdir == ED_SEARCH_PREV_HISTORY ?
-		    ED_SEARCH_NEXT_HISTORY : ED_SEARCH_PREV_HISTORY));
-}
-
-
-/* vi_next_char():
- *	Vi move to the character specified next
- *	[f]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_next_char(EditLine *el, int c __attribute__((__unused__)))
-{
-	return cv_csearch(el, CHAR_FWD, -1, el->el_state.argument, 0);
-}
-
-
-/* vi_prev_char():
- *	Vi move to the character specified previous
- *	[F]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_prev_char(EditLine *el, int c __attribute__((__unused__)))
-{
-	return cv_csearch(el, CHAR_BACK, -1, el->el_state.argument, 0);
-}
-
-
-/* vi_to_next_char():
- *	Vi move up to the character specified next
- *	[t]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_to_next_char(EditLine *el, int c __attribute__((__unused__)))
-{
-	return cv_csearch(el, CHAR_FWD, -1, el->el_state.argument, 1);
-}
-
-
-/* vi_to_prev_char():
- *	Vi move up to the character specified previous
- *	[T]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_to_prev_char(EditLine *el, int c __attribute__((__unused__)))
-{
-	return cv_csearch(el, CHAR_BACK, -1, el->el_state.argument, 1);
-}
-
-
-/* vi_repeat_next_char():
- *	Vi repeat current character search in the same search direction
- *	[;]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_repeat_next_char(EditLine *el, int c __attribute__((__unused__)))
-{
-
-	return cv_csearch(el, el->el_search.chadir, el->el_search.chacha,
-		el->el_state.argument, el->el_search.chatflg);
-}
-
-
-/* vi_repeat_prev_char():
- *	Vi repeat current character search in the opposite search direction
- *	[,]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_repeat_prev_char(EditLine *el, int c __attribute__((__unused__)))
-{
-	el_action_t r;
-	int dir = el->el_search.chadir;
-
-	r = cv_csearch(el, -dir, el->el_search.chacha,
-		el->el_state.argument, el->el_search.chatflg);
-	el->el_search.chadir = dir;
-	return r;
-}
-
-
-/* vi_match():
- *	Vi go to matching () {} or []
- *	[%]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_match(EditLine *el, int c)
-{
-	const char match_chars[] = "()[]{}";
-	char *cp;
-	int delta, i, count;
-	char o_ch, c_ch;
-
-	*el->el_line.lastchar = '\0';		/* just in case */
-
-	i = strcspn(el->el_line.cursor, match_chars);
-	o_ch = el->el_line.cursor[i];
-	if (o_ch == 0)
-		return CC_ERROR;
-	delta = strchr(match_chars, o_ch) - match_chars;
-	c_ch = match_chars[delta ^ 1];
-	count = 1;
-	delta = 1 - (delta & 1) * 2;
-
-	for (cp = &el->el_line.cursor[i]; count; ) {
-		cp += delta;
-		if (cp < el->el_line.buffer || cp >= el->el_line.lastchar)
-			return CC_ERROR;
-		if (*cp == o_ch)
-			count++;
-		else if (*cp == c_ch)
-			count--;
-	}
-
-	el->el_line.cursor = cp;
-
-	if (el->el_chared.c_vcmd.action != NOP) {
-		/* NB posix says char under cursor should NOT be deleted
-		   for -ve delta - this is different to netbsd vi. */
-		if (delta > 0)
-			el->el_line.cursor++;
-		cv_delfini(el);
-		return (CC_REFRESH);
-	}
-	return (CC_CURSOR);
-}
-
-/* vi_undo_line():
- *	Vi undo all changes to line
- *	[U]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_undo_line(EditLine *el, int c)
-{
-
-	cv_undo(el);
-	return hist_get(el);
-}
-
-/* vi_to_column():
- *	Vi go to specified column
- *	[|]
- * NB netbsd vi goes to screen column 'n', posix says nth character
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_to_column(EditLine *el, int c)
-{
-
-	el->el_line.cursor = el->el_line.buffer;
-	el->el_state.argument--;
-	return ed_next_char(el, 0);
-}
-
-/* vi_yank_end():
- *	Vi yank to end of line
- *	[Y]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_yank_end(EditLine *el, int c)
-{
-
-	cv_yank(el, el->el_line.cursor,
-		el->el_line.lastchar - el->el_line.cursor);
-	return CC_REFRESH;
-}
-
-/* vi_yank():
- *	Vi yank
- *	[y]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_yank(EditLine *el, int c)
-{
-
-	return cv_action(el, YANK);
-}
-
-/* vi_comment_out():
- *	Vi comment out current command
- *	[#]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_comment_out(EditLine *el, int c)
-{
-
-	el->el_line.cursor = el->el_line.buffer;
-	c_insert(el, 1);
-	*el->el_line.cursor = '#';
-	re_refresh(el);
-	return ed_newline(el, 0);
-}
-
-/* vi_alias():
- *	Vi include shell alias
- *	[@]
- * NB: posix implies that we should enter insert mode, however
- * this is against historical precedent...
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_alias(EditLine *el, int c)
-{
-#ifdef __weak_extern
-	char alias_name[3];
-	char *alias_text;
-	extern char *get_alias_text(const char *);
-	__weak_extern(get_alias_text);
-
-	if (get_alias_text == 0) {
-		return CC_ERROR;
-	}
-
-	alias_name[0] = '_';
-	alias_name[2] = 0;
-	if (el_getc(el, &alias_name[1]) != 1)
-		return CC_ERROR;
-
-	alias_text = get_alias_text(alias_name);
-	if (alias_text != NULL)
-		el_push(el, alias_text);
-	return CC_NORM;
-#else
-	return CC_ERROR;
-#endif
-}
-
-/* vi_to_history_line():
- *	Vi go to specified history file line.
- *	[G]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_to_history_line(EditLine *el, int c)
-{
-	int sv_event_no = el->el_history.eventno;
-	el_action_t rval;
-
-
-	if (el->el_history.eventno == 0) {
-		 (void) strncpy(el->el_history.buf, el->el_line.buffer,
-		     EL_BUFSIZ);
-		 el->el_history.last = el->el_history.buf +
-			 (el->el_line.lastchar - el->el_line.buffer);
-	}
-
-	/* Lack of a 'count' means oldest, not 1 */
-	if (!el->el_state.doingarg) {
-		el->el_history.eventno = 0x7fffffff;
-		hist_get(el);
-	} else {
-		/* This is brain dead, all the rest of this code counts
-		 * upwards going into the past.  Here we need count in the
-		 * other direction (to match the output of fc -l).
-		 * I could change the world, but this seems to suffice.
-		 */
-		el->el_history.eventno = 1;
-		if (hist_get(el) == CC_ERROR)
-			return CC_ERROR;
-		el->el_history.eventno = 1 + el->el_history.ev.num 
-					- el->el_state.argument;
-		if (el->el_history.eventno < 0) {
-			el->el_history.eventno = sv_event_no;
-			return CC_ERROR;
-		}
-	}
-	rval = hist_get(el);
-	if (rval == CC_ERROR)
-		el->el_history.eventno = sv_event_no;
-	return rval;
-}
-
-/* vi_histedit():
- *	Vi edit history line with vi
- *	[v]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_histedit(EditLine *el, int c)
-{
-	int fd;
-	pid_t pid;
-	int st;
-	char tempfile[] = "/tmp/histedit.XXXXXXXXXX";
-	char *cp;
-	int rv;
-
-	if (el->el_state.doingarg) {
-		if (vi_to_history_line(el, 0) == CC_ERROR)
-			return CC_ERROR;
-	}
-
-	fd = mkstemp(tempfile);
-	if (fd < 0)
-		return CC_ERROR;
-	cp = el->el_line.buffer;
-	rv = write(fd, cp, el->el_line.lastchar - cp +0u);
-	if (rv < 0)
-		return CC_ERROR;
-	rv = write(fd, "\n", 1);
-	if (rv < 0)
-		return CC_ERROR;
-	pid = fork();
-	switch (pid) {
-	case -1:
-		close(fd);
-		unlink(tempfile);
-		return CC_ERROR;
-	case 0:
-		close(fd);
-		execlp("vi", "vi", tempfile, NULL);
-		exit(0);
-		/*NOTREACHED*/
-	default:
-		while (waitpid(pid, &st, 0) != pid)
-			continue;
-		lseek(fd, 0ll, SEEK_SET);
-		st = read(fd, cp, el->el_line.limit - cp +0u);
-		if (st > 0 && cp[st - 1] == '\n')
-			st--;
-		el->el_line.cursor = cp;
-		el->el_line.lastchar = cp + st;
-		break;
-	}
-
-	close(fd);
-	unlink(tempfile);
-	/* return CC_REFRESH; */
-	return ed_newline(el, 0);
-}
-
-/* vi_history_word():
- *	Vi append word from previous input line
- *	[_]
- * Who knows where this one came from!
- * '_' in vi means 'entire current line', so 'cc' is a synonym for 'c_'
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_history_word(EditLine *el, int c)
-{
-	const char *wp = HIST_FIRST(el);
-	const char *wep, *wsp;
-	int len;
-	char *cp;
-	const char *lim;
-
-	if (wp == NULL)
-		return CC_ERROR;
-
-	wep = wsp = 0;
-	do {
-		while (isspace((unsigned char)*wp))
-			wp++;
-		if (*wp == 0)
-			break;
-		wsp = wp;
-		while (*wp && !isspace((unsigned char)*wp))
-			wp++;
-		wep = wp;
-	} while ((!el->el_state.doingarg || --el->el_state.argument > 0) && *wp != 0);
-
-	if (wsp == 0 || (el->el_state.doingarg && el->el_state.argument != 0))
-		return CC_ERROR;
-
-	cv_undo(el);
-	len = wep - wsp;
-	if (el->el_line.cursor < el->el_line.lastchar)
-		el->el_line.cursor++;
-	c_insert(el, len + 1);
-	cp = el->el_line.cursor;
-	lim = el->el_line.limit;
-	if (cp < lim)
-		*cp++ = ' ';
-	while (wsp < wep && cp < lim)
-		*cp++ = *wsp++;
-	el->el_line.cursor = cp;
-
-	el->el_map.current = el->el_map.key;
-	return CC_REFRESH;
-}
-
-/* vi_redo():
- *	Vi redo last non-motion command
- *	[.]
- */
-protected el_action_t
-/*ARGSUSED*/
-vi_redo(EditLine *el, int c)
-{
-	c_redo_t *r = &el->el_chared.c_redo;
-
-	if (!el->el_state.doingarg && r->count) {
-		el->el_state.doingarg = 1;
-		el->el_state.argument = r->count;
-	}
-
-	el->el_chared.c_vcmd.pos = el->el_line.cursor;
-	el->el_chared.c_vcmd.action = r->action;
-	if (r->pos != r->buf) {
-		if (r->pos + 1 > r->lim)
-			/* sanity */
-			r->pos = r->lim - 1;
-		r->pos[0] = 0;
-		el_push(el, r->buf);
-	}
-
-	el->el_state.thiscmd = r->cmd;
-	el->el_state.thisch = r->ch;
-	return  (*el->el_map.func[r->cmd])(el, r->ch);
-}
diff --git a/libedit/vis.c b/libedit/vis.c
deleted file mode 100644
index 3062bdc..0000000
--- a/libedit/vis.c
+++ /dev/null
@@ -1,409 +0,0 @@
-/*	$NetBSD: vis.c,v 1.34 2005/11/18 08:32:46 martin Exp $	*/
-
-/*-
- * Copyright (c) 1989, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*-
- * Copyright (c) 1999, 2005 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* AIX requires this to be the first thing in the file.  */
-#if defined (_AIX) && !defined (__GNUC__)
- #pragma alloca
-#endif
-
-#include "sys.h"
-
-#ifdef __GNUC__
-# undef alloca
-# define alloca(n) __builtin_alloca (n)
-#else
-# ifdef HAVE_ALLOCA_H
-#  include <alloca.h>
-# else
-#  ifndef _AIX
-extern char *alloca ();
-#  endif
-# endif
-#endif
-
-#if defined(LIBC_SCCS) && !defined(lint)
-__RCSID("$NetBSD: vis.c,v 1.34 2005/11/18 08:32:46 martin Exp $");
-#endif /* LIBC_SCCS and not lint */
-
-#include <sys/types.h>
-
-#include <assert.h>
-#include <vis.h>
-#include <stdlib.h>
-
-#ifdef __weak_alias
-__weak_alias(strsvis,_strsvis)
-__weak_alias(strsvisx,_strsvisx)
-__weak_alias(strvis,_strvis)
-__weak_alias(strvisx,_strvisx)
-__weak_alias(svis,_svis)
-__weak_alias(vis,_vis)
-#endif
-
-#if !HAVE_VIS || !HAVE_SVIS
-#include <ctype.h>
-#include <limits.h>
-#include <stdio.h>
-#include <string.h>
-
-#undef BELL
-#define BELL '\a'
-
-#define isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
-#define iswhite(c)	(c == ' ' || c == '\t' || c == '\n')
-#define issafe(c)	(c == '\b' || c == BELL || c == '\r')
-#define xtoa(c)		"0123456789abcdef"[c]
-
-#define MAXEXTRAS	5
-
-
-#define MAKEEXTRALIST(flag, extra, orig_str)				      \
-do {									      \
-	const char *orig = orig_str;					      \
-	const char *o = orig;						      \
-	char *e;							      \
-	while (*o++)							      \
-		continue;						      \
-	extra = malloc((size_t)((o - orig) + MAXEXTRAS));		      \
-	if (!extra) break;						      \
-	for (o = orig, e = extra; (*e++ = *o++) != '\0';)		      \
-		continue;						      \
-	e--;								      \
-	if (flag & VIS_SP) *e++ = ' ';					      \
-	if (flag & VIS_TAB) *e++ = '\t';				      \
-	if (flag & VIS_NL) *e++ = '\n';					      \
-	if ((flag & VIS_NOSLASH) == 0) *e++ = '\\';			      \
-	*e = '\0';							      \
-} while (/*CONSTCOND*/0)
-
-
-/*
- * This is HVIS, the macro of vis used to HTTP style (RFC 1808)
- */
-#define HVIS(dst, c, flag, nextc, extra)				      \
-do									      \
-	if (!isascii(c) || !isalnum(c) || strchr("$-_.+!*'(),", c) != NULL) { \
-		*dst++ = '%';						      \
-		*dst++ = xtoa(((unsigned int)c >> 4) & 0xf);		      \
-		*dst++ = xtoa((unsigned int)c & 0xf);			      \
-	} else {							      \
-		SVIS(dst, c, flag, nextc, extra);			      \
-	}								      \
-while (/*CONSTCOND*/0)
-
-/*
- * This is SVIS, the central macro of vis.
- * dst:	      Pointer to the destination buffer
- * c:	      Character to encode
- * flag:      Flag word
- * nextc:     The character following 'c'
- * extra:     Pointer to the list of extra characters to be
- *	      backslash-protected.
- */
-#define SVIS(dst, c, flag, nextc, extra)				      \
-do {									      \
-	int isextra;							      \
-	isextra = strchr(extra, c) != NULL;				      \
-	if (!isextra && isascii(c) && (isgraph(c) || iswhite(c) ||	      \
-	    ((flag & VIS_SAFE) && issafe(c)))) {			      \
-		*dst++ = c;						      \
-		break;							      \
-	}								      \
-	if (flag & VIS_CSTYLE) {					      \
-		switch (c) {						      \
-		case '\n':						      \
-			*dst++ = '\\'; *dst++ = 'n';			      \
-			continue;					      \
-		case '\r':						      \
-			*dst++ = '\\'; *dst++ = 'r';			      \
-			continue;					      \
-		case '\b':						      \
-			*dst++ = '\\'; *dst++ = 'b';			      \
-			continue;					      \
-		case BELL:						      \
-			*dst++ = '\\'; *dst++ = 'a';			      \
-			continue;					      \
-		case '\v':						      \
-			*dst++ = '\\'; *dst++ = 'v';			      \
-			continue;					      \
-		case '\t':						      \
-			*dst++ = '\\'; *dst++ = 't';			      \
-			continue;					      \
-		case '\f':						      \
-			*dst++ = '\\'; *dst++ = 'f';			      \
-			continue;					      \
-		case ' ':						      \
-			*dst++ = '\\'; *dst++ = 's';			      \
-			continue;					      \
-		case '\0':						      \
-			*dst++ = '\\'; *dst++ = '0';			      \
-			if (isoctal(nextc)) {				      \
-				*dst++ = '0';				      \
-				*dst++ = '0';				      \
-			}						      \
-			continue;					      \
-		default:						      \
-			if (isgraph(c)) {				      \
-				*dst++ = '\\'; *dst++ = c;		      \
-				continue;				      \
-			}						      \
-		}							      \
-	}								      \
-	if (isextra || ((c & 0177) == ' ') || (flag & VIS_OCTAL)) {	      \
-		*dst++ = '\\';						      \
-		*dst++ = (u_char)(((u_int32_t)(u_char)c >> 6) & 03) + '0';    \
-		*dst++ = (u_char)(((u_int32_t)(u_char)c >> 3) & 07) + '0';    \
-		*dst++ =			     (c	      & 07) + '0';    \
-	} else {							      \
-		if ((flag & VIS_NOSLASH) == 0) *dst++ = '\\';		      \
-		if (c & 0200) {						      \
-			c &= 0177; *dst++ = 'M';			      \
-		}							      \
-		if (iscntrl(c)) {					      \
-			*dst++ = '^';					      \
-			if (c == 0177)					      \
-				*dst++ = '?';				      \
-			else						      \
-				*dst++ = c + '@';			      \
-		} else {						      \
-			*dst++ = '-'; *dst++ = c;			      \
-		}							      \
-	}								      \
-} while (/*CONSTCOND*/0)
-
-
-/*
- * svis - visually encode characters, also encoding the characters
- *	  pointed to by `extra'
- */
-char *
-svis(char *dst, int c, int flag, int nextc, const char *extra)
-{
-	char *nextra = NULL;
-
-	_DIAGASSERT(dst != NULL);
-	_DIAGASSERT(extra != NULL);
-	MAKEEXTRALIST(flag, nextra, extra);
-	if (!nextra) {
-		*dst = '\0';		/* can't create nextra, return "" */
-		return dst;
-	}
-	if (flag & VIS_HTTPSTYLE)
-		HVIS(dst, c, flag, nextc, nextra);
-	else
-		SVIS(dst, c, flag, nextc, nextra);
-	free(nextra);
-	*dst = '\0';
-	return dst;
-}
-
-
-/*
- * strsvis, strsvisx - visually encode characters from src into dst
- *
- *	Extra is a pointer to a \0-terminated list of characters to
- *	be encoded, too. These functions are useful e. g. to
- *	encode strings in such a way so that they are not interpreted
- *	by a shell.
- *
- *	Dst must be 4 times the size of src to account for possible
- *	expansion.  The length of dst, not including the trailing NULL,
- *	is returned.
- *
- *	Strsvisx encodes exactly len bytes from src into dst.
- *	This is useful for encoding a block of data.
- */
-int
-strsvis(char *dst, const char *csrc, int flag, const char *extra)
-{
-	int c;
-	char *start;
-	char *nextra = NULL;
-	const unsigned char *src = (const unsigned char *)csrc;
-
-	_DIAGASSERT(dst != NULL);
-	_DIAGASSERT(src != NULL);
-	_DIAGASSERT(extra != NULL);
-	MAKEEXTRALIST(flag, nextra, extra);
-	if (!nextra) {
-		*dst = '\0';		/* can't create nextra, return "" */
-		return 0;
-	}
-	if (flag & VIS_HTTPSTYLE) {
-		for (start = dst; (c = *src++) != '\0'; /* empty */)
-			HVIS(dst, c, flag, *src, nextra);
-	} else {
-		for (start = dst; (c = *src++) != '\0'; /* empty */)
-			SVIS(dst, c, flag, *src, nextra);
-	}
-	free(nextra);
-	*dst = '\0';
-	return (dst - start);
-}
-
-
-int
-strsvisx(char *dst, const char *csrc, size_t len, int flag, const char *extra)
-{
-	unsigned char c;
-	char *start;
-	char *nextra = NULL;
-	const unsigned char *src = (const unsigned char *)csrc;
-
-	_DIAGASSERT(dst != NULL);
-	_DIAGASSERT(src != NULL);
-	_DIAGASSERT(extra != NULL);
-	MAKEEXTRALIST(flag, nextra, extra);
-	if (! nextra) {
-		*dst = '\0';		/* can't create nextra, return "" */
-		return 0;
-	}
-
-	if (flag & VIS_HTTPSTYLE) {
-		for (start = dst; len > 0; len--) {
-			c = *src++;
-			HVIS(dst, c, flag, len ? *src : '\0', nextra);
-		}
-	} else {
-		for (start = dst; len > 0; len--) {
-			c = *src++;
-			SVIS(dst, c, flag, len ? *src : '\0', nextra);
-		}
-	}
-	free(nextra);
-	*dst = '\0';
-	return (dst - start);
-}
-#endif
-
-#if !HAVE_VIS
-/*
- * vis - visually encode characters
- */
-char *
-vis(char *dst, int c, int flag, int nextc)
-{
-	char *extra = NULL;
-	unsigned char uc = (unsigned char)c;
-
-	_DIAGASSERT(dst != NULL);
-
-	MAKEEXTRALIST(flag, extra, "");
-	if (! extra) {
-		*dst = '\0';		/* can't create extra, return "" */
-		return dst;
-	}
-	if (flag & VIS_HTTPSTYLE)
-		HVIS(dst, uc, flag, nextc, extra);
-	else
-		SVIS(dst, uc, flag, nextc, extra);
-	free(extra);
-	*dst = '\0';
-	return dst;
-}
-
-
-/*
- * strvis, strvisx - visually encode characters from src into dst
- *
- *	Dst must be 4 times the size of src to account for possible
- *	expansion.  The length of dst, not including the trailing NULL,
- *	is returned.
- *
- *	Strvisx encodes exactly len bytes from src into dst.
- *	This is useful for encoding a block of data.
- */
-int
-strvis(char *dst, const char *src, int flag)
-{
-	char *extra = NULL;
-	int rv;
-
-	MAKEEXTRALIST(flag, extra, "");
-	if (!extra) {
-		*dst = '\0';		/* can't create extra, return "" */
-		return 0;
-	}
-	rv = strsvis(dst, src, flag, extra);
-	free(extra);
-	return rv;
-}
-
-
-int
-strvisx(char *dst, const char *src, size_t len, int flag)
-{
-	char *extra = NULL;
-	int rv;
-
-	MAKEEXTRALIST(flag, extra, "");
-	if (!extra) {
-		*dst = '\0';		/* can't create extra, return "" */
-		return 0;
-	}
-	rv = strsvisx(dst, src, len, flag, extra);
-	free(extra);
-	return rv;
-}
-#endif
diff --git a/libedit/vis.h b/libedit/vis.h
deleted file mode 100644
index 7baba2d..0000000
--- a/libedit/vis.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/*	$NetBSD: vis.h,v 1.16 2005/09/13 01:44:32 christos Exp $	*/
-
-/*-
- * Copyright (c) 1990, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)vis.h	8.1 (Berkeley) 6/2/93
- */
-
-#ifndef _VIS_H_
-#define	_VIS_H_
-
-#include <config.h>
-
-/*
- * to select alternate encoding format
- */
-#define	VIS_OCTAL	0x01	/* use octal \ddd format */
-#define	VIS_CSTYLE	0x02	/* use \[nrft0..] where appropiate */
-
-/*
- * to alter set of characters encoded (default is to encode all
- * non-graphic except space, tab, and newline).
- */
-#define	VIS_SP		0x04	/* also encode space */
-#define	VIS_TAB		0x08	/* also encode tab */
-#define	VIS_NL		0x10	/* also encode newline */
-#define	VIS_WHITE	(VIS_SP | VIS_TAB | VIS_NL)
-#define	VIS_SAFE	0x20	/* only encode "unsafe" characters */
-
-/*
- * other
- */
-#define	VIS_NOSLASH	0x40	/* inhibit printing '\' */
-#define	VIS_HTTPSTYLE	0x80	/* http-style escape % HEX HEX */
-
-/*
- * unvis return codes
- */
-#define	UNVIS_VALID	 1	/* character valid */
-#define	UNVIS_VALIDPUSH	 2	/* character valid, push back passed char */
-#define	UNVIS_NOCHAR	 3	/* valid sequence, no character produced */
-#define	UNVIS_SYNBAD	-1	/* unrecognized escape sequence */
-#define	UNVIS_ERROR	-2	/* decoder in unknown state (unrecoverable) */
-
-/*
- * unvis flags
- */
-#define	UNVIS_END	1	/* no more characters */
-
-__BEGIN_DECLS
-char	*vis(char *, int, int, int);
-char	*svis(char *, int, int, int, const char *);
-int	strvis(char *, const char *, int);
-int	strsvis(char *, const char *, int, const char *);
-int	strvisx(char *, const char *, size_t, int);
-int	strsvisx(char *, const char *, size_t, int, const char *);
-int	strunvis(char *, const char *);
-int	strunvisx(char *, const char *, int);
-#ifndef __LIBC12_SOURCE__
-int	unvis(char *, int, int *, int);
-#endif
-__END_DECLS
-
-#endif /* !_VIS_H_ */
diff --git a/m4/ax_pkg_swig.m4 b/m4/ax_pkg_swig.m4
new file mode 100644
index 0000000..d836eec
--- /dev/null
+++ b/m4/ax_pkg_swig.m4
@@ -0,0 +1,135 @@
+# ===========================================================================
+#        http://www.gnu.org/software/autoconf-archive/ax_pkg_swig.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_PKG_SWIG([major.minor.micro], [action-if-found], [action-if-not-found])
+#
+# DESCRIPTION
+#
+#   This macro searches for a SWIG installation on your system. If found,
+#   then SWIG is AC_SUBST'd; if not found, then $SWIG is empty.  If SWIG is
+#   found, then SWIG_LIB is set to the SWIG library path, and AC_SUBST'd.
+#
+#   You can use the optional first argument to check if the version of the
+#   available SWIG is greater than or equal to the value of the argument. It
+#   should have the format: N[.N[.N]] (N is a number between 0 and 999. Only
+#   the first N is mandatory.) If the version argument is given (e.g.
+#   1.3.17), AX_PKG_SWIG checks that the swig package is this version number
+#   or higher.
+#
+#   As usual, action-if-found is executed if SWIG is found, otherwise
+#   action-if-not-found is executed.
+#
+#   In configure.in, use as:
+#
+#     AX_PKG_SWIG(1.3.17, [], [ AC_MSG_ERROR([SWIG is required to build..]) ])
+#     AX_SWIG_ENABLE_CXX
+#     AX_SWIG_MULTI_MODULE_SUPPORT
+#     AX_SWIG_PYTHON
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Sebastian Huber <sebastian-huber@web.de>
+#   Copyright (c) 2008 Alan W. Irwin
+#   Copyright (c) 2008 Rafael Laboissiere <rafael@laboissiere.net>
+#   Copyright (c) 2008 Andrew Collier
+#   Copyright (c) 2011 Murray Cumming <murrayc@openismus.com>
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation; either version 2 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 11
+
+AC_DEFUN([AX_PKG_SWIG],[
+        # Ubuntu has swig 2.0 as /usr/bin/swig2.0
+        AC_PATH_PROGS([SWIG],[swig swig2.0])
+        if test -z "$SWIG" ; then
+                m4_ifval([$3],[$3],[:])
+        elif test -n "$1" ; then
+                AC_MSG_CHECKING([SWIG version])
+                [swig_version=`$SWIG -version 2>&1 | grep 'SWIG Version' | sed 's/.*\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*/\1/g'`]
+                AC_MSG_RESULT([$swig_version])
+                if test -n "$swig_version" ; then
+                        # Calculate the required version number components
+                        [required=$1]
+                        [required_major=`echo $required | sed 's/[^0-9].*//'`]
+                        if test -z "$required_major" ; then
+                                [required_major=0]
+                        fi
+                        [required=`echo $required | sed 's/[0-9]*[^0-9]//'`]
+                        [required_minor=`echo $required | sed 's/[^0-9].*//'`]
+                        if test -z "$required_minor" ; then
+                                [required_minor=0]
+                        fi
+                        [required=`echo $required | sed 's/[0-9]*[^0-9]//'`]
+                        [required_patch=`echo $required | sed 's/[^0-9].*//'`]
+                        if test -z "$required_patch" ; then
+                                [required_patch=0]
+                        fi
+                        # Calculate the available version number components
+                        [available=$swig_version]
+                        [available_major=`echo $available | sed 's/[^0-9].*//'`]
+                        if test -z "$available_major" ; then
+                                [available_major=0]
+                        fi
+                        [available=`echo $available | sed 's/[0-9]*[^0-9]//'`]
+                        [available_minor=`echo $available | sed 's/[^0-9].*//'`]
+                        if test -z "$available_minor" ; then
+                                [available_minor=0]
+                        fi
+                        [available=`echo $available | sed 's/[0-9]*[^0-9]//'`]
+                        [available_patch=`echo $available | sed 's/[^0-9].*//'`]
+                        if test -z "$available_patch" ; then
+                                [available_patch=0]
+                        fi
+                        # Convert the version tuple into a single number for easier comparison.
+                        # Using base 100 should be safe since SWIG internally uses BCD values
+                        # to encode its version number.
+                        required_swig_vernum=`expr $required_major \* 10000 \
+                            \+ $required_minor \* 100 \+ $required_patch`
+                        available_swig_vernum=`expr $available_major \* 10000 \
+                            \+ $available_minor \* 100 \+ $available_patch`
+
+                        if test $available_swig_vernum -lt $required_swig_vernum; then
+                                AC_MSG_WARN([SWIG version >= $1 is required.  You have $swig_version.])
+                                SWIG=''
+                                m4_ifval([$3],[$3],[])
+                        else
+                                AC_MSG_CHECKING([for SWIG library])
+                                SWIG_LIB=`$SWIG -swiglib`
+                                AC_MSG_RESULT([$SWIG_LIB])
+                                m4_ifval([$2],[$2],[])
+                        fi
+                else
+                        AC_MSG_WARN([cannot determine SWIG version])
+                        SWIG=''
+                        m4_ifval([$3],[$3],[])
+                fi
+        fi
+        AC_SUBST([SWIG_LIB])
+])
diff --git a/m4/ax_prog_python_version.m4 b/m4/ax_prog_python_version.m4
new file mode 100644
index 0000000..628a3e4
--- /dev/null
+++ b/m4/ax_prog_python_version.m4
@@ -0,0 +1,66 @@
+# ===========================================================================
+#  http://www.gnu.org/software/autoconf-archive/ax_prog_python_version.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_PROG_PYTHON_VERSION([VERSION],[ACTION-IF-TRUE],[ACTION-IF-FALSE])
+#
+# DESCRIPTION
+#
+#   Makes sure that python supports the version indicated. If true the shell
+#   commands in ACTION-IF-TRUE are executed. If not the shell commands in
+#   ACTION-IF-FALSE are run. Note if $PYTHON is not set (for example by
+#   running AC_CHECK_PROG or AC_PATH_PROG) the macro will fail.
+#
+#   Example:
+#
+#     AC_PATH_PROG([PYTHON],[python])
+#     AX_PROG_PYTHON_VERSION([2.4.4],[ ... ],[ ... ])
+#
+#   This will check to make sure that the python you have supports at least
+#   version 2.4.4.
+#
+#   NOTE: This macro uses the $PYTHON variable to perform the check.
+#   AX_WITH_PYTHON can be used to set that variable prior to running this
+#   macro. The $PYTHON_VERSION variable will be valorized with the detected
+#   version.
+#
+# LICENSE
+#
+#   Copyright (c) 2009 Francesco Salvestrini <salvestrini@users.sourceforge.net>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 11
+
+AC_DEFUN([AX_PROG_PYTHON_VERSION],[
+    AC_REQUIRE([AC_PROG_SED])
+    AC_REQUIRE([AC_PROG_GREP])
+
+    AS_IF([test -n "$PYTHON"],[
+        ax_python_version="$1"
+
+        AC_MSG_CHECKING([for python version])
+        changequote(<<,>>)
+        python_version=`$PYTHON -V 2>&1 | $GREP "^Python " | $SED -e 's/^.* \([0-9]*\.[0-9]*\.[0-9]*\)/\1/'`
+        changequote([,])
+        AC_MSG_RESULT($python_version)
+
+	AC_SUBST([PYTHON_VERSION],[$python_version])
+
+        AX_COMPARE_VERSION([$ax_python_version],[le],[$python_version],[
+	    :
+            $2
+        ],[
+	    :
+            $3
+        ])
+    ],[
+        AC_MSG_WARN([could not find the python interpreter])
+        $3
+    ])
+])
diff --git a/m4/ax_python_devel.m4 b/m4/ax_python_devel.m4
new file mode 100644
index 0000000..f18ed8a
--- /dev/null
+++ b/m4/ax_python_devel.m4
@@ -0,0 +1,327 @@
+# ===========================================================================
+#      http://www.gnu.org/software/autoconf-archive/ax_python_devel.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_PYTHON_DEVEL([version])
+#
+# DESCRIPTION
+#
+#   Note: Defines as a precious variable "PYTHON_VERSION". Don't override it
+#   in your configure.ac.
+#
+#   This macro checks for Python and tries to get the include path to
+#   'Python.h'. It provides the $(PYTHON_CPPFLAGS) and $(PYTHON_LIBS) output
+#   variables. It also exports $(PYTHON_EXTRA_LIBS) and
+#   $(PYTHON_EXTRA_LDFLAGS) for embedding Python in your code.
+#
+#   You can search for some particular version of Python by passing a
+#   parameter to this macro, for example ">= '2.3.1'", or "== '2.4'". Please
+#   note that you *have* to pass also an operator along with the version to
+#   match, and pay special attention to the single quotes surrounding the
+#   version number. Don't use "PYTHON_VERSION" for this: that environment
+#   variable is declared as precious and thus reserved for the end-user.
+#
+#   This macro should work for all versions of Python >= 2.1.0. As an end
+#   user, you can disable the check for the python version by setting the
+#   PYTHON_NOVERSIONCHECK environment variable to something else than the
+#   empty string.
+#
+#   If you need to use this macro for an older Python version, please
+#   contact the authors. We're always open for feedback.
+#
+# LICENSE
+#
+#   Copyright (c) 2009 Sebastian Huber <sebastian-huber@web.de>
+#   Copyright (c) 2009 Alan W. Irwin
+#   Copyright (c) 2009 Rafael Laboissiere <rafael@laboissiere.net>
+#   Copyright (c) 2009 Andrew Collier
+#   Copyright (c) 2009 Matteo Settenvini <matteo@member.fsf.org>
+#   Copyright (c) 2009 Horst Knorr <hk_classes@knoda.org>
+#   Copyright (c) 2013 Daniel Mullner <muellner@math.stanford.edu>
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 18
+
+AU_ALIAS([AC_PYTHON_DEVEL], [AX_PYTHON_DEVEL])
+AC_DEFUN([AX_PYTHON_DEVEL],[
+	#
+	# Allow the use of a (user set) custom python version
+	#
+	AC_ARG_VAR([PYTHON_VERSION],[The installed Python
+		version to use, for example '2.3'. This string
+		will be appended to the Python interpreter
+		canonical name.])
+
+	AC_PATH_PROG([PYTHON],[python[$PYTHON_VERSION]])
+	if test -z "$PYTHON"; then
+	   AC_MSG_ERROR([Cannot find python$PYTHON_VERSION in your system path])
+	   PYTHON_VERSION=""
+	fi
+
+	#
+	# Check for a version of Python >= 2.1.0
+	#
+	AC_MSG_CHECKING([for a version of Python >= '2.1.0'])
+	ac_supports_python_ver=`$PYTHON -c "import sys; \
+		ver = sys.version.split ()[[0]]; \
+		print (ver >= '2.1.0')"`
+	if test "$ac_supports_python_ver" != "True"; then
+		if test -z "$PYTHON_NOVERSIONCHECK"; then
+			AC_MSG_RESULT([no])
+			AC_MSG_FAILURE([
+This version of the AC@&t@_PYTHON_DEVEL macro
+doesn't work properly with versions of Python before
+2.1.0. You may need to re-run configure, setting the
+variables PYTHON_CPPFLAGS, PYTHON_LIBS, PYTHON_SITE_PKG,
+PYTHON_EXTRA_LIBS and PYTHON_EXTRA_LDFLAGS by hand.
+Moreover, to disable this check, set PYTHON_NOVERSIONCHECK
+to something else than an empty string.
+])
+		else
+			AC_MSG_RESULT([skip at user request])
+		fi
+	else
+		AC_MSG_RESULT([yes])
+	fi
+
+	#
+	# if the macro parameter ``version'' is set, honour it
+	#
+	if test -n "$1"; then
+		AC_MSG_CHECKING([for a version of Python $1])
+		ac_supports_python_ver=`$PYTHON -c "import sys; \
+			ver = sys.version.split ()[[0]]; \
+			print (ver $1)"`
+		if test "$ac_supports_python_ver" = "True"; then
+		   AC_MSG_RESULT([yes])
+		else
+			AC_MSG_RESULT([no])
+			AC_MSG_ERROR([this package requires Python $1.
+If you have it installed, but it isn't the default Python
+interpreter in your system path, please pass the PYTHON_VERSION
+variable to configure. See ``configure --help'' for reference.
+])
+			PYTHON_VERSION=""
+		fi
+	fi
+
+	#
+	# Check if you have distutils, else fail
+	#
+	AC_MSG_CHECKING([for the distutils Python package])
+	ac_distutils_result=`$PYTHON -c "import distutils" 2>&1`
+	if test -z "$ac_distutils_result"; then
+		AC_MSG_RESULT([yes])
+	else
+		AC_MSG_RESULT([no])
+		AC_MSG_ERROR([cannot import Python module "distutils".
+Please check your Python installation. The error was:
+$ac_distutils_result])
+		PYTHON_VERSION=""
+	fi
+
+	#
+	# Check for Python include path
+	#
+	AC_MSG_CHECKING([for Python include path])
+	if test -z "$PYTHON_CPPFLAGS"; then
+		python_path=`$PYTHON -c "import distutils.sysconfig; \
+			print (distutils.sysconfig.get_python_inc ());"`
+		plat_python_path=`$PYTHON -c "import distutils.sysconfig; \
+			print (distutils.sysconfig.get_python_inc (plat_specific=1));"`
+		if test -n "${python_path}"; then
+			if test "${plat_python_path}" != "${python_path}"; then
+				python_path="-I$python_path -I$plat_python_path"
+			else
+				python_path="-I$python_path"
+			fi
+		fi
+		PYTHON_CPPFLAGS=$python_path
+	fi
+	AC_MSG_RESULT([$PYTHON_CPPFLAGS])
+	AC_SUBST([PYTHON_CPPFLAGS])
+
+	#
+	# Check for Python library path
+	#
+	AC_MSG_CHECKING([for Python library path])
+	if test -z "$PYTHON_LIBS"; then
+		# (makes two attempts to ensure we've got a version number
+		# from the interpreter)
+		ac_python_version=`cat<<EOD | $PYTHON -
+
+# join all versioning strings, on some systems
+# major/minor numbers could be in different list elements
+from distutils.sysconfig import *
+e = get_config_var('VERSION')
+if e is not None:
+	print(e)
+EOD`
+
+		if test -z "$ac_python_version"; then
+			if test -n "$PYTHON_VERSION"; then
+				ac_python_version=$PYTHON_VERSION
+			else
+				ac_python_version=`$PYTHON -c "import sys; \
+					print (sys.version[[:3]])"`
+			fi
+		fi
+
+		# Make the versioning information available to the compiler
+		AC_DEFINE_UNQUOTED([HAVE_PYTHON], ["$ac_python_version"],
+                                   [If available, contains the Python version number currently in use.])
+
+		# First, the library directory:
+		ac_python_libdir=`cat<<EOD | $PYTHON -
+
+# There should be only one
+import distutils.sysconfig
+e = distutils.sysconfig.get_config_var('LIBDIR')
+if e is not None:
+	print (e)
+EOD`
+
+		# Now, for the library:
+		ac_python_library=`cat<<EOD | $PYTHON -
+
+import distutils.sysconfig
+c = distutils.sysconfig.get_config_vars()
+if 'LDVERSION' in c:
+	print ('python'+c[['LDVERSION']])
+else:
+	print ('python'+c[['VERSION']])
+EOD`
+
+		# This small piece shamelessly adapted from PostgreSQL python macro;
+		# credits goes to momjian, I think. I'd like to put the right name
+		# in the credits, if someone can point me in the right direction... ?
+		#
+		if test -n "$ac_python_libdir" -a -n "$ac_python_library"
+		then
+			# use the official shared library
+			ac_python_library=`echo "$ac_python_library" | sed "s/^lib//"`
+			PYTHON_LIBS="-L$ac_python_libdir -l$ac_python_library"
+		else
+			# old way: use libpython from python_configdir
+			ac_python_libdir=`$PYTHON -c \
+			  "from distutils.sysconfig import get_python_lib as f; \
+			  import os; \
+			  print (os.path.join(f(plat_specific=1, standard_lib=1), 'config'));"`
+			PYTHON_LIBS="-L$ac_python_libdir -lpython$ac_python_version"
+		fi
+
+		if test -z "PYTHON_LIBS"; then
+			AC_MSG_ERROR([
+  Cannot determine location of your Python DSO. Please check it was installed with
+  dynamic libraries enabled, or try setting PYTHON_LIBS by hand.
+			])
+		fi
+	fi
+	AC_MSG_RESULT([$PYTHON_LIBS])
+	AC_SUBST([PYTHON_LIBS])
+
+	#
+	# Check for site packages
+	#
+	AC_MSG_CHECKING([for Python site-packages path])
+	if test -z "$PYTHON_SITE_PKG"; then
+		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
+			print (distutils.sysconfig.get_python_lib(0,0));"`
+	fi
+	AC_MSG_RESULT([$PYTHON_SITE_PKG])
+	AC_SUBST([PYTHON_SITE_PKG])
+
+	#
+	# libraries which must be linked in when embedding
+	#
+	AC_MSG_CHECKING(python extra libraries)
+	if test -z "$PYTHON_EXTRA_LDFLAGS"; then
+	   PYTHON_EXTRA_LDFLAGS=`$PYTHON -c "import distutils.sysconfig; \
+                conf = distutils.sysconfig.get_config_var; \
+                print (conf('LIBS') + ' ' + conf('SYSLIBS'))"`
+	fi
+	AC_MSG_RESULT([$PYTHON_EXTRA_LDFLAGS])
+	AC_SUBST(PYTHON_EXTRA_LDFLAGS)
+
+	#
+	# linking flags needed when embedding
+	#
+	AC_MSG_CHECKING(python extra linking flags)
+	if test -z "$PYTHON_EXTRA_LIBS"; then
+		PYTHON_EXTRA_LIBS=`$PYTHON -c "import distutils.sysconfig; \
+			conf = distutils.sysconfig.get_config_var; \
+			print (conf('LINKFORSHARED'))"`
+	fi
+	AC_MSG_RESULT([$PYTHON_EXTRA_LIBS])
+	AC_SUBST(PYTHON_EXTRA_LIBS)
+
+	#
+	# final check to see if everything compiles alright
+	#
+	AC_MSG_CHECKING([consistency of all components of python development environment])
+	# save current global flags
+	ac_save_LIBS="$LIBS"
+	ac_save_LDFLAGS="$LDFLAGS"
+	ac_save_CPPFLAGS="$CPPFLAGS"
+	LIBS="$ac_save_LIBS $PYTHON_LIBS $PYTHON_EXTRA_LIBS $PYTHON_EXTRA_LIBS"
+	LDFLAGS="$ac_save_LDFLAGS $PYTHON_EXTRA_LDFLAGS"
+	CPPFLAGS="$ac_save_CPPFLAGS $PYTHON_CPPFLAGS"
+	AC_LANG_PUSH([C])
+	AC_LINK_IFELSE([
+		AC_LANG_PROGRAM([[#include <Python.h>]],
+				[[Py_Initialize();]])
+		],[pythonexists=yes],[pythonexists=no])
+	AC_LANG_POP([C])
+	# turn back to default flags
+	CPPFLAGS="$ac_save_CPPFLAGS"
+	LIBS="$ac_save_LIBS"
+	LDFLAGS="$ac_save_LDFLAGS"
+
+	AC_MSG_RESULT([$pythonexists])
+
+        if test ! "x$pythonexists" = "xyes"; then
+	   AC_MSG_FAILURE([
+  Could not link test program to Python. Maybe the main Python library has been
+  installed in some non-standard library path. If so, pass it to configure,
+  via the LIBS environment variable.
+  Example: ./configure LIBS="-L/usr/non-standard-path/python/lib"
+  ============================================================================
+   ERROR!
+   You probably have to install the development version of the Python package
+   for your distribution.  The exact name of this package varies among them.
+  ============================================================================
+	   ])
+	  PYTHON_VERSION=""
+	fi
+
+	#
+	# all done!
+	#
+])
diff --git a/sample/ipmicmd.c b/sample/ipmicmd.c
index 53ba3a0..37fb913 100644
--- a/sample/ipmicmd.c
+++ b/sample/ipmicmd.c
@@ -267,7 +267,7 @@ typedef struct timed_data_s
     ipmi_con_t     *con;
     struct timeval start_time;
     ipmi_msg_t     msg;
-    unsigned char  data[MAX_IPMI_DATA_SIZE];
+    unsigned char  data[IPMI_MAX_MSG_LENGTH];
     ipmi_addr_t    addr;
     unsigned int   addr_len;
     unsigned int   count;
@@ -368,7 +368,7 @@ process_input_line(char *buf)
     ipmi_addr_t        *addr = (ipmi_addr_t *) addr_data;
     unsigned int       addr_len;
     ipmi_msg_t         msg;
-    unsigned char      outbuf[MAX_IPMI_DATA_SIZE];
+    unsigned char      outbuf[IPMI_MAX_MSG_LENGTH];
     int                rv = 0;
     short              channel;
     unsigned char      seq = 0;
diff --git a/swig/perl/Makefile.am b/swig/perl/Makefile.am
index f83d927..b90b9d4 100644
--- a/swig/perl/Makefile.am
+++ b/swig/perl/Makefile.am
@@ -44,6 +44,8 @@ uninstall-local:
 
 AM_TESTS_ENVIRONMENT = mkdir -p tmppersist && mkdir -p auto/OpenIPMI && cp OpenIPMI.so auto/OpenIPMI && TEST_LD_PRELOAD="$(OPENIPMI_SWIG_SO):$(top_builddir)/swig/perl/.libs/libdummystuff.so" LD_LIBRARY_PATH=$(top_builddir)/glib/.libs PERL5LIB="$(top_builddir)/swig/perl:$(srcdir)" top_builddir="$(top_builddir)" srcdir="$(srcdir)"
 TESTS = test_fru test_chan test_lanparm test_pet test_pef
+REAL_TESTS = test_fru.p test_chan.p test_lanparm.p test_pet.p test_pef.p
 
 EXTRA_DIST = OpenIPMI_perl.c OpenIPMI_lang.i OpenIPMI.h \
-	sample ipmi_powerctl $(TESTS) Lanserv.pm lan.conf dummystuff.c
+	sample ipmi_powerctl $(TESTS) $(REAL_TESTS) \
+	Lanserv.pm lan.conf dummystuff.c
diff --git a/swig/python/Makefile.am b/swig/python/Makefile.am
index da95a81..323d0b1 100644
--- a/swig/python/Makefile.am
+++ b/swig/python/Makefile.am
@@ -1,7 +1,8 @@
 
 SUBDIRS = . @PYTHON_GUI_DIR@
+DIST_SUBDIRS = openipmigui
 
-AM_CFLAGS = $(PYTHON_CFLAGS) \
+AM_CFLAGS = $(PYTHON_CPPFLAGS) \
 	    -I $(top_builddir) \
 	    -I $(top_builddir)/include \
 	    -I $(top_srcdir)/include \
@@ -9,7 +10,7 @@ AM_CFLAGS = $(PYTHON_CFLAGS) \
 	    -DPYTHON_HAS_POSIX_THREADS=@PYTHON_HAS_POSIX_THREADS@
 
 pythonlibdir=$(PYTHON_INSTALL_LIB_DIR)
-PYPATH=$(top_builddir)/swig/python:$(top_builddir)/swig/python/.libs:$(srcdir)/openipmigui
+PYPATH=$(top_builddir)/swig/python:$(top_builddir)/swig/python/.libs
 
 pythonlib_LTLIBRARIES = _OpenIPMI.la
 
@@ -19,22 +20,18 @@ _OpenIPMI_la_LIBADD = $(OPENIPMI_SWIG_LIBS) $(PYTHON_POSIX_LIB)
 
 EXTRA_DIST = OpenIPMI_lang.i OpenIPMI.h openipmigui.py sample.py sample2.py
 
-OpenIPMI.pyc: OpenIPMI.py _OpenIPMI.la
-	-PYTHONPATH=$(PYPATH) $(pythonprog) -c 'import OpenIPMI.py'
-
-OpenIPMI.pyo: OpenIPMI.py _OpenIPMI.la
-	-PYTHONPATH=$(PYPATH) $(pythonprog) -O -c 'import OpenIPMI.py'
-
 OpenIPMI_wrap.c OpenIPMI.py: $(top_srcdir)/swig/OpenIPMI.i OpenIPMI_lang.i
-	$(SWIG) $(DEFS) -python -o OpenIPMI_wrap.c -I$(top_srcdir)/swig/python $<
+	$(SWIG) $(DEFS) -python $(PYTHON_SWIG_FLAGS) -o OpenIPMI_wrap.c \
+		-I$(top_srcdir)/swig/python $<
 
 CLEANFILES = OpenIPMI_wrap.c OpenIPMI.py OpenIPMI.pyo OpenIPMI.pyc
 
-install-exec-local: _OpenIPMI.la OpenIPMI.py OpenIPMI.pyc OpenIPMI.pyo
+clean-local:
+	rm -rf __pycache__
+
+install-exec-local: _OpenIPMI.la OpenIPMI.py
 	$(INSTALL) -d $(DESTDIR)$(PYTHON_INSTALL_DIR)
 	$(INSTALL_DATA) OpenIPMI.py "$(DESTDIR)$(PYTHON_INSTALL_DIR)"
-	$(INSTALL_DATA) OpenIPMI.pyc "$(DESTDIR)$(PYTHON_INSTALL_DIR)"
-	$(INSTALL_DATA) OpenIPMI.pyo "$(DESTDIR)$(PYTHON_INSTALL_DIR)"
 	if test "x$(PYTHON_GUI_DIR)" = "xopenipmigui"; then \
 	    $(INSTALL) -d $(DESTDIR)$(bindir); \
 	    $(INSTALL_SCRIPT) $(srcdir)/openipmigui.py "$(DESTDIR)$(bindir)/openipmigui";\
@@ -43,9 +40,7 @@ install-exec-local: _OpenIPMI.la OpenIPMI.py OpenIPMI.pyc OpenIPMI.pyo
 uninstall-local:
 	$(LIBTOOL) --mode=uninstall rm -f "$(DESTDIR)$(PYTHON_INSTALL_LIB_DIR)/_OpenIPMI.so"
 	rm -f "$(DESTDIR)$(PYTHON_INSTALL_DIR)/OpenIPMI.py"
-	rm -f "$(DESTDIR)$(PYTHON_INSTALL_DIR)/OpenIPMI.pyc"
-	rm -f "$(DESTDIR)$(PYTHON_INSTALL_DIR)/OpenIPMI.pyo"
 	rm -f "$(DESTDIR)$(bindir)/openipmigui"
 
 rungui:
-	LD_LIBRARY_PATH=$(top_builddir)/glib/.libs LD_PRELOAD=$(OPENIPMI_SWIG_SO):$(top_builddir)/swig/python/.libs/_OpenIPMI.so PYTHONPATH=$(PYPATH) $(pythonprog) $(top_srcdir)/swig/python/openipmigui.py
+	LD_LIBRARY_PATH=$(top_builddir)/glib/.libs LD_PRELOAD=$(OPENIPMI_SWIG_SO):$(top_builddir)/swig/python/.libs/_OpenIPMI.so PYTHONPATH=$(PYPATH) $(PYTHON) $(top_srcdir)/swig/python/openipmigui.py
diff --git a/swig/python/openipmigui.py b/swig/python/openipmigui.py
index 9b80ca1..e874c87 100755
--- a/swig/python/openipmigui.py
+++ b/swig/python/openipmigui.py
@@ -248,7 +248,7 @@ def run(args):
     # Detect if we need a separate OpenIPMI driver thread.  See the
     # openipmi_driver function above for the reason.
     try:
-        import thread
+        import threading
         try:
             top.tk.getvar("tcl_platform", "threaded")
             # Tcl is threaded, no need for another thread.
diff --git a/swig/python/openipmigui/Makefile.am b/swig/python/openipmigui/Makefile.am
index 570e7b9..b8c66d8 100644
--- a/swig/python/openipmigui/Makefile.am
+++ b/swig/python/openipmigui/Makefile.am
@@ -1,5 +1,5 @@
 
-EXTRA_DIST = _control.py _domain.py _entity.py _mc.py _sensor.py \
+PY_FILES = _control.py _domain.py _entity.py _mc.py _sensor.py \
 	gui_domainDialog.py gui.py __init__.py _saveprefs.py _fru.py \
 	_sel.py _oi_logging.py _mc_chan.py _mc_lanparm.py _mc_user.py \
 	_conn.py gui_cmdwin.py _term.py gui_SoL.py _mc_solparm.py \
@@ -7,21 +7,9 @@ EXTRA_DIST = _control.py _domain.py _entity.py _mc.py _sensor.py \
 	gui_lightset.py gui_treelist.py gui_list.py gui_term.py \
 	_misc.py gui_winsys.py
 
-PYC_FILES = _control.pyc _domain.pyc _entity.pyc _mc.pyc _sensor.pyc \
-	gui_domainDialog.pyc gui.pyc __init__.pyc _saveprefs.pyc _fru.pyc \
-	_sel.pyc _oi_logging.pyc _mc_chan.pyc _mc_lanparm.pyc _mc_user.pyc \
-	_conn.pyc gui_cmdwin.pyc _term.pyc gui_SoL.pyc _mc_solparm.pyc \
-	_mc_pefparm.pyc gui_errstr.pyc gui_popup.pyc gui_setdialog.pyc \
-	gui_lightset.pyc gui_treelist.pyc gui_list.pyc gui_term.pyc \
-	_misc.pyc gui_winsys.pyc
-
-PYO_FILES = _control.pyo _domain.pyo _entity.pyo _mc.pyo _sensor.pyo \
-	gui_domainDialog.pyo gui.pyo __init__.pyo _saveprefs.pyo _fru.pyo \
-	_sel.pyo _oi_logging.pyo _mc_chan.pyo _mc_lanparm.pyo _mc_user.pyo \
-	_conn.pyo gui_cmdwin.pyo _term.pyo gui_SoL.pyo _mc_solparm.pyo \
-	_mc_pefparm.pyo gui_errstr.pyo gui_popup.pyo gui_setdialog.pyo \
-	gui_lightset.pyo gui_treelist.pyo gui_list.pyo gui_term.pyo \
-	_misc.pyo gui_winsys.pyo
+EXTRA_DIST = $(PY_FILES)
+
+CLEANFILES = $(PY_FILES) *.pyc *.pyo
 
 # Python doesn't have any way to output the compiled files somewhere else,
 # and it doesn't work very well for them to be remote, anyway, so maintain
@@ -34,24 +22,16 @@ localcopy:
 		fi \
 	done
 
-all-local: localcopy $(PYC_FILES) $(PYO_FILES)
+all-local: localcopy
 
-install-exec-local: $(EXTRA_DIST) $(PYC_FILES) $(PYO_FILES)
+install-exec-local: $(EXTRA_DIST)
 	$(INSTALL) -d $(DESTDIR)$(PYTHON_INSTALL_DIR)/openipmigui
 	$(INSTALL_DATA) $^ $(DESTDIR)$(PYTHON_INSTALL_DIR)/openipmigui
 
 uninstall-local:
-	(for i in $(EXTRA_DIST) $(PYC_FILES) $(PYO_FILES); do \
+	(for i in $(EXTRA_DIST); do \
 		rm -f $(DESTDIR)$(PYTHON_INSTALL_DIR)/openipmigui/$$i; \
 	done)
 	-rmdir "$(DESTDIR)$(PYTHON_INSTALL_DIR)/openipmigui"
 
 PYPATH=$(top_builddir)/swig/python:$(top_builddir)/swig/python/.libs:$(srcdir)
-
-.py.pyc:
-	LD_PRELOAD=$(OPENIPMI_SWIG_SO):$(top_builddir)/swig/python/.libs/_OpenIPMI.so PYTHONPATH=$(PYPATH) $(pythonprog) -c 'import $*'
-
-.py.pyo:
-	LD_PRELOAD=$(OPENIPMI_SWIG_SO):$(top_builddir)/swig/python/.libs/_OpenIPMI.so PYTHONPATH=$(PYPATH) $(pythonprog) -O -c 'import $*'
-
-CLEANFILES = $(PYC_FILES) $(PYO_FILES)
diff --git a/swig/python/openipmigui/_conn.py b/swig/python/openipmigui/_conn.py
index 84f7de9..e0dc9bc 100644
--- a/swig/python/openipmigui/_conn.py
+++ b/swig/python/openipmigui/_conn.py
@@ -31,8 +31,8 @@
 #
 
 import OpenIPMI
-import gui_popup
-import gui_SoL
+from openipmigui import gui_popup
+from openipmigui import gui_SoL
 
 class Port:
     def __init__(self, domain, c, pnum):
diff --git a/swig/python/openipmigui/_control.py b/swig/python/openipmigui/_control.py
index 829d1cf..2923d34 100644
--- a/swig/python/openipmigui/_control.py
+++ b/swig/python/openipmigui/_control.py
@@ -31,9 +31,9 @@
 #
 
 import OpenIPMI
-import gui_popup
-import gui_setdialog
-import gui_lightset
+from openipmigui import gui_popup
+from openipmigui import gui_setdialog
+from openipmigui import gui_lightset
 
 class ControlRefreshData:
     def __init__(self, c):
diff --git a/swig/python/openipmigui/_domain.py b/swig/python/openipmigui/_domain.py
index 21a8162..9af5b9e 100644
--- a/swig/python/openipmigui/_domain.py
+++ b/swig/python/openipmigui/_domain.py
@@ -30,16 +30,16 @@
 #  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 #
 
-import gui_popup
-import gui_setdialog
+from openipmigui import gui_popup
+from openipmigui import gui_setdialog
 import OpenIPMI
-import _entity
-import _mc
-import _saveprefs
-import _sel
-import _fru
-import _conn
-import _oi_logging
+from openipmigui import _entity
+from openipmigui import _mc
+from openipmigui import _saveprefs
+from openipmigui import _sel
+from openipmigui import _fru
+from openipmigui import _conn
+from openipmigui import _oi_logging
 
 class InvalidDomainError(Exception):
     def __init__(self, value):
diff --git a/swig/python/openipmigui/_entity.py b/swig/python/openipmigui/_entity.py
index 7a1fa10..e0bc3ea 100644
--- a/swig/python/openipmigui/_entity.py
+++ b/swig/python/openipmigui/_entity.py
@@ -31,12 +31,12 @@
 #
 
 import OpenIPMI
-import _oi_logging
-import _sensor
-import _control
-import _fru
-import gui_popup
-import gui_setdialog
+from openipmigui import _oi_logging
+from openipmigui import _sensor
+from openipmigui import _control
+from openipmigui import _fru
+from openipmigui import gui_popup
+from openipmigui import gui_setdialog
 
 class EntityOp:
     def __init__(self, e, func):
diff --git a/swig/python/openipmigui/_fru.py b/swig/python/openipmigui/_fru.py
index 8ee020e..d87a514 100644
--- a/swig/python/openipmigui/_fru.py
+++ b/swig/python/openipmigui/_fru.py
@@ -31,10 +31,10 @@
 #
 
 import OpenIPMI
-import _oi_logging
-import gui_treelist
-import gui_popup
-import gui_setdialog
+from openipmigui import _oi_logging
+from openipmigui import gui_treelist
+from openipmigui import gui_popup
+from openipmigui import gui_setdialog
 
 class ReinitOnAny:
     def __init__(self, glist):
diff --git a/swig/python/openipmigui/_mc.py b/swig/python/openipmigui/_mc.py
index 93eef34..db07d6b 100644
--- a/swig/python/openipmigui/_mc.py
+++ b/swig/python/openipmigui/_mc.py
@@ -30,12 +30,12 @@
 #  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 #
 import OpenIPMI
-import gui_popup
-import gui_setdialog
-import _oi_logging
-import _sel
-import _mc_chan
-import _mc_pefparm
+from openipmigui import gui_popup
+from openipmigui import gui_setdialog
+from openipmigui import _oi_logging
+from openipmigui import _sel
+from openipmigui import _mc_chan
+from openipmigui import _mc_pefparm
 
 class MCOpHandler:
     def __init__(self, m, func, handler=None, boolval=None):
diff --git a/swig/python/openipmigui/_mc_chan.py b/swig/python/openipmigui/_mc_chan.py
index ce25bf1..c7aab3a 100644
--- a/swig/python/openipmigui/_mc_chan.py
+++ b/swig/python/openipmigui/_mc_chan.py
@@ -31,12 +31,12 @@
 #
 
 import OpenIPMI
-import gui_popup
-import gui_treelist
-import _oi_logging
-import _mc_lanparm
-import _mc_solparm
-import _mc_user
+from openipmigui import gui_popup
+from openipmigui import gui_treelist
+from openipmigui import _oi_logging
+from openipmigui import _mc_lanparm
+from openipmigui import _mc_solparm
+from openipmigui import _mc_user
 
 # Collect all the info for the channels of an MC.  For each channel
 # all the info is requested using the types immediately below.  If the
diff --git a/swig/python/openipmigui/_mc_lanparm.py b/swig/python/openipmigui/_mc_lanparm.py
index 54f009c..e61293a 100644
--- a/swig/python/openipmigui/_mc_lanparm.py
+++ b/swig/python/openipmigui/_mc_lanparm.py
@@ -32,11 +32,11 @@
 
 import sys
 import OpenIPMI
-import _oi_logging
-import gui_errstr
-import gui_list
-import gui_popup
-import gui_setdialog
+from openipmigui import _oi_logging
+from openipmigui import gui_errstr
+from openipmigui import gui_list
+from openipmigui import gui_popup
+from openipmigui import gui_setdialog
 
 class MCLPData:
     def __init__(self, glist, lpc, parm, aidx, pname, ptype, origval):
diff --git a/swig/python/openipmigui/_mc_pefparm.py b/swig/python/openipmigui/_mc_pefparm.py
index 9cf71ec..596a9f1 100644
--- a/swig/python/openipmigui/_mc_pefparm.py
+++ b/swig/python/openipmigui/_mc_pefparm.py
@@ -32,11 +32,11 @@
 
 import sys
 import OpenIPMI
-import _oi_logging
-import gui_errstr
-import gui_list
-import gui_popup
-import gui_setdialog
+from openipmigui import _oi_logging
+from openipmigui import gui_errstr
+from openipmigui import gui_list
+from openipmigui import gui_popup
+from openipmigui import gui_setdialog
 
 class MCPEFData:
     def __init__(self, glist, pefc, parm, aidx, pname, ptype, origval):
diff --git a/swig/python/openipmigui/_mc_solparm.py b/swig/python/openipmigui/_mc_solparm.py
index e1b1fde..b16de44 100644
--- a/swig/python/openipmigui/_mc_solparm.py
+++ b/swig/python/openipmigui/_mc_solparm.py
@@ -32,11 +32,11 @@
 
 import sys
 import OpenIPMI
-import _oi_logging
-import gui_errstr
-import gui_list
-import gui_popup
-import gui_setdialog
+from openipmigui import _oi_logging
+from openipmigui import gui_errstr
+from openipmigui import gui_list
+from openipmigui import gui_popup
+from openipmigui import gui_setdialog
 
 class MCSOLData:
     def __init__(self, glist, solc, parm, aidx, pname, ptype, origval):
diff --git a/swig/python/openipmigui/_mc_user.py b/swig/python/openipmigui/_mc_user.py
index c2163a3..67d725c 100644
--- a/swig/python/openipmigui/_mc_user.py
+++ b/swig/python/openipmigui/_mc_user.py
@@ -31,11 +31,11 @@
 #
 
 import OpenIPMI
-import gui_popup
-import gui_treelist
-import gui_setdialog
-import _oi_logging
-import _mc_lanparm
+from openipmigui import gui_popup
+from openipmigui import gui_treelist
+from openipmigui import gui_setdialog
+from openipmigui import _oi_logging
+from openipmigui import _mc_lanparm
 
 class BoolSetter:
     def __init__(self, mcusers, user, setter):
diff --git a/swig/python/openipmigui/_saveprefs.py b/swig/python/openipmigui/_saveprefs.py
index c033942..d749e6a 100644
--- a/swig/python/openipmigui/_saveprefs.py
+++ b/swig/python/openipmigui/_saveprefs.py
@@ -32,7 +32,7 @@
 
 import xml.dom
 import xml.dom.minidom
-import _oi_logging
+from openipmigui import _oi_logging
 import os
 import stat
 import sys
diff --git a/swig/python/openipmigui/_sel.py b/swig/python/openipmigui/_sel.py
index 5e72bb5..70ae121 100644
--- a/swig/python/openipmigui/_sel.py
+++ b/swig/python/openipmigui/_sel.py
@@ -32,9 +32,9 @@
 
 import OpenIPMI
 import sys
-import gui_list
-import gui_popup
-import _misc
+from openipmigui import gui_list
+from openipmigui import gui_popup
+from openipmigui import _misc
 
 class EventData:
     def __init__(self, slist, ev, has_second_data):
diff --git a/swig/python/openipmigui/_sensor.py b/swig/python/openipmigui/_sensor.py
index e5a5b66..3189865 100644
--- a/swig/python/openipmigui/_sensor.py
+++ b/swig/python/openipmigui/_sensor.py
@@ -30,9 +30,9 @@
 #  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 #
 import OpenIPMI
-import gui_popup
-import gui_setdialog
-import _oi_logging
+from openipmigui import gui_popup
+from openipmigui import gui_setdialog
+from openipmigui import _oi_logging
 
 class SensorRefreshData:
     def __init__(self, s):
diff --git a/swig/python/openipmigui/gui.py b/swig/python/openipmigui/gui.py
index 5321f15..64b216c 100644
--- a/swig/python/openipmigui/gui.py
+++ b/swig/python/openipmigui/gui.py
@@ -36,14 +36,14 @@ except:
     from tkinter import tix as Tix
 
 import OpenIPMI
-import _saveprefs
-import _oi_logging
-import gui_domainDialog
-import gui_errstr
-import gui_cmdwin
-import gui_list
-import gui_popup
-import gui_winsys
+from openipmigui import _saveprefs
+from openipmigui import _oi_logging
+from openipmigui import gui_domainDialog
+from openipmigui import gui_errstr
+from openipmigui import gui_cmdwin
+from openipmigui import gui_list
+from openipmigui import gui_popup
+from openipmigui import gui_winsys
 
 init_treenamewidth = 150
 init_sashposition = 400
diff --git a/swig/python/openipmigui/gui_SoL.py b/swig/python/openipmigui/gui_SoL.py
index 5cdc2c9..c4d7662 100644
--- a/swig/python/openipmigui/gui_SoL.py
+++ b/swig/python/openipmigui/gui_SoL.py
@@ -36,9 +36,9 @@ except:
     import tkinter
     from tkinter import tix as Tix
 
-import gui_setdialog
-import gui_term
-import gui_errstr
+from openipmigui import gui_setdialog
+from openipmigui import gui_term
+from openipmigui import gui_errstr
 
 # Note in this file SoL refers to the main SoL object and sol refers
 # to the connection.
diff --git a/swig/python/openipmigui/gui_cmdwin.py b/swig/python/openipmigui/gui_cmdwin.py
index b8d8ece..e05f246 100644
--- a/swig/python/openipmigui/gui_cmdwin.py
+++ b/swig/python/openipmigui/gui_cmdwin.py
@@ -39,8 +39,8 @@ except:
 import xml.dom
 import xml.dom.minidom
 import OpenIPMI
-import _saveprefs
-import _misc
+from openipmigui import _saveprefs
+from openipmigui import _misc
 import os
 import stat
 import sys
diff --git a/swig/python/openipmigui/gui_domainDialog.py b/swig/python/openipmigui/gui_domainDialog.py
index c3b27e7..8920935 100644
--- a/swig/python/openipmigui/gui_domainDialog.py
+++ b/swig/python/openipmigui/gui_domainDialog.py
@@ -36,8 +36,8 @@ except:
     from tkinter import tix as Tix
 
 import OpenIPMI
-import _domain
-import gui_errstr
+from openipmigui import _domain
+from openipmigui import gui_errstr
 
 class EnumHolder:
     def __init__(self):
diff --git a/swig/python/openipmigui/gui_list.py b/swig/python/openipmigui/gui_list.py
index ca1882a..0b229df 100644
--- a/swig/python/openipmigui/gui_list.py
+++ b/swig/python/openipmigui/gui_list.py
@@ -35,8 +35,8 @@ try:
 except:
     import tkinter
     from tkinter import tix as Tix
-import gui_errstr
-import gui_winsys
+from openipmigui import gui_errstr
+from openipmigui import gui_winsys
 
 # A list widget that can be embedded in something else
 class SubList(Tix.ScrolledHList):
diff --git a/swig/python/openipmigui/gui_setdialog.py b/swig/python/openipmigui/gui_setdialog.py
index 581cab4..6dd72ec 100644
--- a/swig/python/openipmigui/gui_setdialog.py
+++ b/swig/python/openipmigui/gui_setdialog.py
@@ -35,7 +35,7 @@ try:
 except:
     import tkinter
     from tkinter import tix as Tix
-import gui_errstr
+from openipmigui import gui_errstr
 
 def isbool(v):
     return type(v) == type(True)
diff --git a/swig/python/openipmigui/gui_term.py b/swig/python/openipmigui/gui_term.py
index 85bbec8..cdb2d87 100644
--- a/swig/python/openipmigui/gui_term.py
+++ b/swig/python/openipmigui/gui_term.py
@@ -35,7 +35,7 @@ try:
 except:
     import tkinter
     from tkinter import tix as Tix
-import _term
+from openipmigui import _term
 
 def gpos(x, y):
     return str(y+1) + "." + str(x)
diff --git a/swig/python/openipmigui/gui_treelist.py b/swig/python/openipmigui/gui_treelist.py
index 0493781..a6fc22c 100644
--- a/swig/python/openipmigui/gui_treelist.py
+++ b/swig/python/openipmigui/gui_treelist.py
@@ -35,8 +35,8 @@ try:
 except:
     import tkinter
     from tkinter import tix as Tix
-import gui_errstr
-import gui_winsys
+from openipmigui import gui_errstr
+from openipmigui import gui_winsys
 
 class TreeList(Tix.Toplevel):
     def __init__(self, name, root, columns):
diff --git a/unix/selector.c b/unix/selector.c
index 4251a25..d6cea65 100644
--- a/unix/selector.c
+++ b/unix/selector.c
@@ -52,6 +52,7 @@
 #include <syslog.h>
 #include <signal.h>
 #include <string.h>
+#include <assert.h>
 #ifdef HAVE_EPOLL_PWAIT
 #include <sys/epoll.h>
 #else
@@ -60,11 +61,23 @@
 #define EPOLL_CTL_MOD 0
 #endif
 
+struct sel_runner_s
+{
+    struct selector_s *sel;
+    sel_runner_func_t func;
+    void *cb_data;
+    int in_use;
+    sel_runner_t *next;
+};
+
 typedef struct fd_state_s
 {
     int               deleted;
     unsigned int      use_count;
     sel_fd_cleared_cb done;
+    sel_runner_t      done_runner;
+    int               tmp_fd;
+    void              *done_cbdata;
 } fd_state_t;
 
 /* The control structure for each file descriptor. */
@@ -78,6 +91,9 @@ typedef struct fd_control_s
     sel_fd_handler_t handle_read;
     sel_fd_handler_t handle_write;
     sel_fd_handler_t handle_except;
+#ifdef HAVE_EPOLL_PWAIT
+    uint32_t saved_events;
+#endif
 } fd_control_t;
 
 typedef struct heap_val_s
@@ -147,7 +163,7 @@ heap_cmp_key(heap_val_t *v1, heap_val_t *v2)
 
 /* Used to build a list of threads that may need to be woken if a
    timer on the top of the heap changes, or an FD is added/removed.
-   See wake_sel_thread() for more info. */
+   See i_wake_sel_thread() for more info. */
 typedef struct sel_wait_list_s
 {
     /* The thread to wake up. */
@@ -164,15 +180,6 @@ typedef struct sel_wait_list_s
     struct sel_wait_list_s *next, *prev;
 } sel_wait_list_t;
 
-struct sel_runner_s
-{
-    struct selector_s *sel;
-    sel_runner_func_t func;
-    void *cb_data;
-    int in_use;
-    sel_runner_t *next;
-};
-
 struct selector_s
 {
     /* This is an array of all the file descriptors possible.  This is
@@ -195,7 +202,7 @@ struct selector_s
     theap_t timer_heap;
 
     /* This is a list of items waiting to be woken up because they are
-       sitting in a select.  See wake_sel_thread() for more info. */
+       sitting in a select.  See i_wake_sel_thread() for more info. */
     sel_wait_list_t wait_list;
 
     void *timer_lock;
@@ -255,7 +262,7 @@ sel_fd_unlock(struct selector_s *sel)
    this after we have calculated the timeout, but before we have
    called select, thus only things in the wait list matter. */
 static void
-wake_sel_thread(struct selector_s *sel)
+i_wake_sel_thread(struct selector_s *sel)
 {
     sel_wait_list_t *item;
 
@@ -269,10 +276,18 @@ wake_sel_thread(struct selector_s *sel)
     }
 }
 
+void
+sel_wake_all(struct selector_s *sel)
+{
+    sel_timer_lock(sel);
+    i_wake_sel_thread(sel);
+    sel_timer_unlock(sel);
+}
+
 static void
 wake_fd_sel_thread(struct selector_s *sel)
 {
-    wake_sel_thread(sel);
+    sel_wake_all(sel);
     sel_fd_unlock(sel);
 }
 
@@ -281,7 +296,7 @@ wake_timer_sel_thread(struct selector_s *sel, volatile sel_timer_t *old_top)
 {
     if (old_top != theap_get_top(&sel->timer_heap))
 	/* If the top value changed, restart the waiting thread. */
-	wake_sel_thread(sel);
+	i_wake_sel_thread(sel);
 }
 
 /* Wait list management.  These *must* be called with the timer list
@@ -322,8 +337,9 @@ init_fd(fd_control_t *fd)
 
 #ifdef HAVE_EPOLL_PWAIT
 static int
-sel_update_epoll(struct selector_s *sel, int fd, int op)
+sel_update_epoll(struct selector_s *sel, int fd, int op, int read_enable)
 {
+    fd_control_t *fdc = (fd_control_t *) &sel->fds[fd];
     struct epoll_event event;
 
     if (sel->epollfd < 0)
@@ -332,24 +348,40 @@ sel_update_epoll(struct selector_s *sel, int fd, int op)
     memset(&event, 0, sizeof(event));
     event.events = EPOLLONESHOT;
     event.data.fd = fd;
-    if (FD_ISSET(fd, &sel->read_set))
-	event.events |= EPOLLIN | EPOLLHUP;
-    if (FD_ISSET(fd, &sel->write_set))
-	event.events |= EPOLLOUT;
-    if (FD_ISSET(fd, &sel->write_set))
-	event.events |= EPOLLERR | EPOLLPRI;
-
+    if (fdc->saved_events) {
+	if (!read_enable)
+	    return 0;
+	op = EPOLL_CTL_ADD;
+	event.events = EPOLLIN | EPOLLHUP;
+    } else {
+	if (FD_ISSET(fd, &sel->read_set))
+	    event.events |= EPOLLIN | EPOLLHUP;
+	if (FD_ISSET(fd, &sel->write_set))
+	    event.events |= EPOLLOUT;
+	if (FD_ISSET(fd, &sel->except_set))
+	    event.events |= EPOLLERR | EPOLLPRI;
+    }
     epoll_ctl(sel->epollfd, op, fd, &event);
     return 0;
 }
 #else
 static int
-sel_update_epoll(struct selector_s *sel, int fd, int op)
+sel_update_epoll(struct selector_s *sel, int fd, int op, int dummy)
 {
     return 1;
 }
 #endif
 
+static void
+finish_oldstate(sel_runner_t *runner, void *cbdata)
+{
+    fd_state_t *oldstate = cbdata;
+
+    if (oldstate->done)
+	oldstate->done(oldstate->tmp_fd, oldstate->done_cbdata);
+    free(oldstate);
+}
+
 /* Set the handlers for a file descriptor. */
 int
 sel_set_fd_handlers(struct selector_s *sel,
@@ -368,9 +400,10 @@ sel_set_fd_handlers(struct selector_s *sel,
     state = malloc(sizeof(*state));
     if (!state)
 	return ENOMEM;
-    state->deleted = 0;
-    state->use_count = 0;
+    memset(state, 0, sizeof(*state));
     state->done = done;
+    memset(&state->done_runner, 0, sizeof(state->done_runner));
+    state->done_runner.sel = sel;
 
     sel_fd_lock(sel);
     fdc = (fd_control_t *) &(sel->fds[fd]);
@@ -391,7 +424,7 @@ sel_set_fd_handlers(struct selector_s *sel,
 	    sel->maxfd = fd;
 	}
 
-	if (sel_update_epoll(sel, fd, EPOLL_CTL_ADD)) {
+	if (sel_update_epoll(sel, fd, EPOLL_CTL_ADD, 0)) {
 	    wake_fd_sel_thread(sel);
 	    goto out;
 	}
@@ -402,19 +435,16 @@ sel_set_fd_handlers(struct selector_s *sel,
     if (oldstate) {
 	oldstate->deleted = 1;
 	if (oldstate->use_count == 0) {
-	    if (oldstate->done)
-		oldstate->done(fd, olddata);
-	    free(oldstate);
+	    oldstate->tmp_fd = fd;
+	    oldstate->done_cbdata = olddata;
+	    sel_run(&oldstate->done_runner, finish_oldstate, oldstate);
 	}
     }
     return 0;
 }
 
-/* Clear the handlers for a file descriptor and remove it from
-   select's monitoring. */
-void
-sel_clear_fd_handlers(struct selector_s *sel,
-		      int        fd)
+static void
+i_sel_clear_fd_handler(struct selector_s *sel, int fd, int imm)
 {
     fd_control_t *fdc;
     fd_state_t   *oldstate = NULL;
@@ -428,7 +458,8 @@ sel_clear_fd_handlers(struct selector_s *sel,
 	olddata = fdc->data;
 	fdc->state = NULL;
 
-	sel_update_epoll(sel, fd, EPOLL_CTL_DEL);
+	sel_update_epoll(sel, fd, EPOLL_CTL_DEL, 0);
+	fdc->saved_events = 0;
     }
 
     init_fd(fdc);
@@ -447,14 +478,34 @@ sel_clear_fd_handlers(struct selector_s *sel,
 
     if (oldstate) {
 	oldstate->deleted = 1;
-	if (oldstate->use_count == 0) {
-	    if (oldstate->done)
-		oldstate->done(fd, olddata);
-	    free(oldstate);
+	if (imm) {
+	    assert(oldstate->use_count == 0);
+	} else if (oldstate->use_count == 0) {
+	    oldstate->tmp_fd = fd;
+	    oldstate->done_cbdata = olddata;
+	    sel_run(&oldstate->done_runner, finish_oldstate, oldstate);
 	}
     }
 }
 
+/* Clear the handlers for a file descriptor and remove it from
+   select's monitoring. */
+void
+sel_clear_fd_handlers(struct selector_s *sel, int fd)
+{
+    i_sel_clear_fd_handler(sel, fd, 0);
+}
+
+/* Clear the handlers for a file descriptor and remove it from
+   select's monitoring, except this can only be called if no
+   callbacks are active (like you haven't started listening
+   yet).  If a callback is active, it will assert. */
+void
+sel_clear_fd_handlers_imm(struct selector_s *sel, int fd)
+{
+    i_sel_clear_fd_handler(sel, fd, 1);
+}
+
 /* Set whether the file descriptor will be monitored for data ready to
    read on the file descriptor. */
 void
@@ -475,7 +526,8 @@ sel_set_fd_read_handler(struct selector_s *sel, int fd, int state)
 	    goto out;
 	FD_CLR(fd, &sel->read_set);
     }
-    if (sel_update_epoll(sel, fd, EPOLL_CTL_MOD)) {
+    if (sel_update_epoll(sel, fd, EPOLL_CTL_MOD,
+			 state == SEL_FD_HANDLER_ENABLED)) {
 	wake_fd_sel_thread(sel);
 	return;
     }
@@ -504,7 +556,7 @@ sel_set_fd_write_handler(struct selector_s *sel, int fd, int state)
 	    goto out;
 	FD_CLR(fd, &sel->write_set);
     }
-    if (sel_update_epoll(sel, fd, EPOLL_CTL_MOD)) {
+    if (sel_update_epoll(sel, fd, EPOLL_CTL_MOD, 0)) {
 	wake_fd_sel_thread(sel);
 	return;
     }
@@ -533,7 +585,7 @@ sel_set_fd_except_handler(struct selector_s *sel, int fd, int state)
 	    goto out;
 	FD_CLR(fd, &sel->except_set);
     }
-    if (sel_update_epoll(sel, fd, EPOLL_CTL_MOD)) {
+    if (sel_update_epoll(sel, fd, EPOLL_CTL_MOD, 0)) {
 	wake_fd_sel_thread(sel);
 	return;
     }
@@ -566,6 +618,19 @@ diff_timeval(struct timeval *dest,
     }
 }
 
+static void
+add_timeval(struct timeval *dest,
+	    struct timeval *left,
+	    struct timeval *right)
+{
+    dest->tv_sec = left->tv_sec + right->tv_sec;
+    dest->tv_usec = left->tv_usec + right->tv_usec;
+    while (dest->tv_usec > 1000000) {
+	dest->tv_usec -= 1000000;
+	dest->tv_sec++;
+    }
+}
+
 int
 sel_alloc_timer(struct selector_s     *sel,
 		sel_timeout_handler_t handler,
@@ -613,7 +678,7 @@ sel_start_timer(sel_timer_t    *timer,
 		struct timeval *timeout)
 {
     struct selector_s *sel = timer->val.sel;
-    volatile sel_timer_t *top;
+    volatile sel_timer_t *old_top;
 
     sel_timer_lock(sel);
     if (timer->val.in_heap) {
@@ -621,7 +686,7 @@ sel_start_timer(sel_timer_t    *timer,
 	return EBUSY;
     }
 
-    top = theap_get_top(&sel->timer_heap);
+    old_top = theap_get_top(&sel->timer_heap);
 
     timer->val.timeout = *timeout;
 
@@ -632,7 +697,7 @@ sel_start_timer(sel_timer_t    *timer,
     }
     timer->val.stopped = 0;
 
-    wake_timer_sel_thread(sel, top);
+    wake_timer_sel_thread(sel, old_top);
 
     sel_timer_unlock(sel);
 
@@ -643,7 +708,6 @@ int
 sel_stop_timer(sel_timer_t *timer)
 {
     struct selector_s *sel = timer->val.sel;
-    volatile sel_timer_t *top;
 
     sel_timer_lock(sel);
     if (timer->val.stopped) {
@@ -652,11 +716,11 @@ sel_stop_timer(sel_timer_t *timer)
     }
 
     if (timer->val.in_heap) {
-	top = theap_get_top(&sel->timer_heap);
+	volatile sel_timer_t *old_top = theap_get_top(&sel->timer_heap);
 
 	theap_remove(&sel->timer_heap, timer);
 	timer->val.in_heap = 0;
-	wake_timer_sel_thread(sel, top);
+	wake_timer_sel_thread(sel, old_top);
     }
     timer->val.stopped = 1;
 
@@ -671,34 +735,37 @@ sel_stop_timer_with_done(sel_timer_t *timer,
 			 void *cb_data)
 {
     struct selector_s *sel = timer->val.sel;
-    volatile sel_timer_t *top;
 
     sel_timer_lock(sel);
-    if (timer->val.stopped) {
+    if (timer->val.stopped || timer->val.done_handler) {
 	sel_timer_unlock(sel);
-	goto out;
+	return ETIMEDOUT;
     }
 
-    if (timer->val.in_handler) {
-	timer->val.done_handler = done_handler;
-	timer->val.done_cb_data = cb_data;
-	sel_timer_unlock(sel);
-	return 0;
-    }
+    timer->val.stopped = 1;
 
-    if (timer->val.in_heap) {
-	top = theap_get_top(&sel->timer_heap);
+    timer->val.done_handler = done_handler;
+    timer->val.done_cb_data = cb_data;
+
+    if (timer->val.in_handler)
+	goto out_unlock;
 
+    /*
+     * We don't want to run the done handler here do avoid locking
+     * issues.  So set it in_handler and stick it on the top of the
+     * heap with an immediate timeout so it will be processed now.
+     */
+    timer->val.in_handler = 1;
+    if (timer->val.in_heap) {
 	theap_remove(&sel->timer_heap, timer);
 	timer->val.in_heap = 0;
-
-	wake_timer_sel_thread(sel, top);
     }
-    timer->val.stopped = 1;
-    sel_timer_unlock(sel);
+    sel_get_monotonic_time(&timer->val.timeout);
+    theap_add(&sel->timer_heap, timer);
+    wake_timer_sel_thread(sel, NULL);
 
- out:
-    done_handler(sel, timer, cb_data);
+ out_unlock:
+    sel_timer_unlock(sel);
     return 0;
 }
 
@@ -720,32 +787,42 @@ sel_get_monotonic_time(struct timeval *tv)
  */
 static void
 process_timers(struct selector_s       *sel,
+	       unsigned int            *count,
 	       volatile struct timeval *timeout)
 {
     struct timeval now;
     sel_timer_t    *timer;
-    int            called = 0;
 
     timer = theap_get_top(&sel->timer_heap);
     sel_get_monotonic_time(&now);
     while (timer && cmp_timeval(&now, &timer->val.timeout) >= 0) {
-	called = 1;
 	theap_remove(&(sel->timer_heap), timer);
 	timer->val.in_heap = 0;
 	timer->val.stopped = 1;
-	timer->val.in_handler = 1;
-	sel_timer_unlock(sel);
-	timer->val.handler(sel, timer, timer->val.user_data);
-	sel_timer_lock(sel);
-	timer->val.in_handler = 0;
+
+	/*
+	 * A timer may be in a handler here if it has been stopped with
+	 * a done_handler.  In that case the timer was stopped, so we
+	 * don't call the main handler.
+	 */
+	if (!timer->val.in_handler) {
+	    timer->val.in_handler = 1;
+	    sel_timer_unlock(sel);
+	    timer->val.handler(sel, timer, timer->val.user_data);
+	    sel_timer_lock(sel);
+	}
+	(*count)++;
 	if (timer->val.done_handler) {
 	    sel_timeout_handler_t done_handler = timer->val.done_handler;
 	    void *done_cb_data = timer->val.done_cb_data;
+
 	    timer->val.done_handler = NULL;
+	    timer->val.in_handler = 1;
 	    sel_timer_unlock(sel);
 	    done_handler(sel, timer, done_cb_data);
 	    sel_timer_lock(sel);
 	}
+	timer->val.in_handler = 0;
 	if (timer->val.freed)
 	    free(timer);
 	else if (!timer->val.stopped) {
@@ -757,7 +834,7 @@ process_timers(struct selector_s       *sel,
 	timer = theap_get_top(&sel->timer_heap);
     }
 
-    if (called) {
+    if (*count) {
 	/* If called, set the timeout to zero. */
 	timeout->tv_sec = 0;
 	timeout->tv_usec = 0;
@@ -829,9 +906,11 @@ sel_run(sel_runner_t *runner, sel_runner_func_t func, void *cb_data)
     return 0;
 }
 
-static void
+static unsigned int
 process_runners(struct selector_s *sel)
 {
+    int count = 0;
+
     while (sel->runner_head) {
 	sel_runner_t *runner = sel->runner_head;
 	sel_runner_func_t func;
@@ -845,8 +924,11 @@ process_runners(struct selector_s *sel)
 	cb_data = runner->cb_data;
 	sel_timer_unlock(sel);
 	func(runner, cb_data);
+	count++;
 	sel_timer_lock(sel);
     }
+
+    return count;
 }
 
 static void
@@ -941,6 +1023,7 @@ process_fds_epoll(struct selector_s *sel, struct timeval *tvtimeout)
     struct epoll_event event;
     int timeout;
     sigset_t sigmask;
+    fd_control_t *fdc;
 
     if (tvtimeout->tv_sec > 600)
 	 /* Don't wait over 10 minutes, to work around an old epoll bug
@@ -964,42 +1047,65 @@ process_fds_epoll(struct selector_s *sel, struct timeval *tvtimeout)
 
     sel_fd_lock(sel);
     fd = event.data.fd;
+    fdc = (fd_control_t *) &sel->fds[fd];
+    if (event.events & (EPOLLHUP | EPOLLERR)) {
+	/*
+	 * The crazy people that designed epoll made it so that EPOLLHUP
+	 * and EPOLLERR always wake it up, even if they are not set.  That
+	 * makes this fairly inconvenient, because we don't want to wake
+	 * up in that case unless we explicitly ask for it.  Fortunately,
+	 * in those cases we can pretty easily simulate it by just deleting
+	 * it, since in those cases you will not get anything but an
+	 * EPOLLHUP or EPOLLERR, anyway, and then doing the callback
+	 * by hand.
+	 */
+	sel_update_epoll(sel, fd, EPOLL_CTL_DEL, 0);
+	fdc->saved_events = event.events & (EPOLLHUP | EPOLLERR);
+    }
     if (event.events & (EPOLLIN | EPOLLHUP))
-	handle_selector_call(sel, fd, &sel->read_set,
-			     sel->fds[fd].handle_read);
+	handle_selector_call(sel, fd, &sel->read_set, fdc->handle_read);
     if (event.events & EPOLLOUT)
-	handle_selector_call(sel, fd, &sel->write_set,
-			     sel->fds[fd].handle_write);
-    if (event.events & (EPOLLERR | EPOLLPRI))
-	handle_selector_call(sel, fd, &sel->except_set,
-			     sel->fds[fd].handle_except);
+	handle_selector_call(sel, fd, &sel->write_set, fdc->handle_write);
+    if (event.events & (EPOLLPRI | EPOLLERR))
+	handle_selector_call(sel, fd, &sel->except_set, fdc->handle_except);
 
     /* Rearm the event.  Remember it could have been deleted in the handler. */
-    if (sel->fds[fd].state)
-	sel_update_epoll(sel, fd, EPOLL_CTL_MOD);
+    if (fdc->state)
+	sel_update_epoll(sel, fd, EPOLL_CTL_MOD, 0);
     sel_fd_unlock(sel);
 
-    return 0;
+    return rv;
 }
 #endif
 
 int
-sel_select(struct selector_s *sel,
-	   sel_send_sig_cb send_sig,
-	   long            thread_id,
-	   void            *cb_data,
-	   struct timeval  *timeout)
+sel_select_intr(struct selector_s *sel,
+		sel_send_sig_cb send_sig,
+		long            thread_id,
+		void            *cb_data,
+		struct timeval  *timeout)
 {
-    int             err;
+    int             err, old_errno;
     struct timeval  loc_timeout = { 0, 0 };
     sel_wait_list_t wait_entry;
+    unsigned int    count;
+    struct timeval  end, now;
+    int user_timeout = 0;
+
+    if (timeout) {
+	sel_get_monotonic_time(&now);
+	add_timeval(&end, &now, timeout);
+    }
 
     sel_timer_lock(sel);
-    process_runners(sel);
-    process_timers(sel, &loc_timeout);
+    count = process_runners(sel);
+    /* If count is non-zero or any timers are processed, timeout is set to 0. */
+    process_timers(sel, &count, (struct timeval *)(&loc_timeout));
     if (timeout) {
-	if (cmp_timeval(&loc_timeout, timeout) >= 0)
-	    memcpy(&loc_timeout, timeout, sizeof(loc_timeout));
+	if (cmp_timeval((struct timeval *)(&loc_timeout), timeout) >= 0) {
+	    loc_timeout = *timeout;
+	    user_timeout = 1;
+	}
     }
     add_sel_wait_list(sel, &wait_entry, send_sig, cb_data, thread_id,
 		      &loc_timeout);
@@ -1012,10 +1118,49 @@ sel_select(struct selector_s *sel,
 #endif
 	err = process_fds(sel, &loc_timeout);
 
+    old_errno = errno;
+    if (!user_timeout && !err) {
+	/*
+	 * Only return a timeout if we waited on the user's timeout
+	 * Otherwise there is a timer to process.
+	 */
+	count++;
+	err = 0;
+    }
+
     sel_timer_lock(sel);
     remove_sel_wait_list(sel, &wait_entry);
     sel_timer_unlock(sel);
 
+    if (timeout) {
+	sel_get_monotonic_time(&now);
+	diff_timeval(timeout, &end, &now);
+    }
+
+    if (err < 0) {
+	errno = old_errno;
+	return err;
+    }
+
+    return err + count;
+}
+
+int
+sel_select(struct selector_s *sel,
+	   sel_send_sig_cb send_sig,
+	   long            thread_id,
+	   void            *cb_data,
+	   struct timeval  *timeout)
+{
+    int err;
+
+    err = sel_select_intr(sel, send_sig, thread_id, cb_data, timeout);
+    if (err < 0 && errno == EINTR)
+	/*
+	 * If we get an EINTR, we don't want to report a timeout.  Just
+	 * return that we did something.
+	 */
+	return 1;
     return err;
 }
 
